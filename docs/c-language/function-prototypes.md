---
title: Прототипы функций
ms.date: 11/04/2016
helpviewer_keywords:
- function prototypes
- function return types, function prototypes
- data types [C], function return types
- functions [C], return types
- prototypes [C++], function
ms.assetid: d152f8e6-971e-432c-93ca-5a91400653c2
ms.openlocfilehash: 76e8abdaa2e2d0d8ba14209b45982b6a7f63f2e4
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227859"
---
# <a name="function-prototypes"></a>Прототипы функций

Объявление функции предшествует ее определению и указывает имя, тип возвращаемого значения, класс хранения и другие атрибуты функции. Чтобы объявление функции стало ее прототипом, оно должно также задавать типы и идентификаторы аргументов функции.

## <a name="syntax"></a>Синтаксис

*declaration*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declaration-specifiers* *attribute-seq*<sub>opt</sub> *init-declarator-list*<sub>opt</sub> **;**

/\* *attribute-seq*<sub>opt</sub> поддерживается только компилятором Майкрософт \*/

*declaration-specifiers*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*storage-class-specifier* *declaration-specifiers*<sub>opt</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-specifier* *declaration-specifiers*<sub>opt</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-qualifier* *declaration-specifiers*<sub>opt</sub>

*init-declarator-list*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*init-declarator*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*init-declarator-list*  **,**  *init-declarator*

*init-declarator*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declarator*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declarator* **=** *initializer*

*declarator*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*pointer*<sub>opt</sub> *direct-declarator*

*direct-declarator*: /\* Декларатор функции \*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*direct-declarator*  **(**  *parameter-type-list*  **)**   /\* Декларатор нового стиля \*/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*direct-declarator*  **(**  *identifier-list*<sub>opt</sub> **)**  /\* Декларатор устаревшего стиля \*/

Прототип имеет ту же форму, что и определение функции, но завершается точкой с запятой сразу после закрывающей круглой скобки и поэтому не имеет тела. В любом случае возвращаемый тип должен соответствовать возвращаемому типу, указанному в определении функции.

Ниже перечислены важные случаи применения прототипов функций:

- Они определяют тип возвращаемого значения для функции, возвращающих типы, отличные от **`int`** . Хотя для функций, возвращающих значения типа **`int`** , прототипы не обязательны, рекомендуется их использовать.

- Без полных прототипов выполняются стандартные преобразования, но не производится попытка сравнения типа или количества аргументов с количеством параметров.

- Прототипы используются для инициализации указателей на функции до определения этих функций.

- Список параметров используется для проверки соответствия аргументов в вызове функции и параметров в ее определении.

Преобразованный тип каждого параметра определяет интерпретацию аргументов, помещаемых в стек при вызове функции. Несоответствие типов аргументов и параметров может приводить к неправильной интерпретации аргументов в стеке. Например, если на 16-разрядном компьютере в качестве аргумента передается 16-разрядный указатель, объявленный как параметр **`long`** , первые 32 бита в стеке интерпретируются как параметр типа **`long`** . Такая ошибка создает проблемы не только с параметром **`long`** , но и со всеми последующими параметрами. Ошибки такого типа можно обнаруживать, объявляя полные прототипы для всех функций.

Прототип задает атрибуты функции, поэтому вызовы функции, предшествующие ее определению (или производимые из других файлов исходного кода), можно проверять на соответствие типов аргументов и возвращаемого типа. Например, если в прототипе указан описатель класса хранения **`static`** , необходимо также задать класс хранения **`static`** в определении функции.

Полные объявления параметров (`int a`) могут использоваться совместно с абстрактными операторами объявления ( **`int`** ) в одном объявлении. Например, следующее объявление является допустимым:

```C
int add( int a, int );
```

Прототип может содержать как тип, так и идентификатор для каждого выражения, которая передается в качестве аргумента. Однако область действия такие идентификатор распространяется только до конца объявления. Прототип также может отражать тот факт, что число аргументов является переменным, или что никакие аргументы не передаются. Без такого списка выявление несоответствий невозможно, поэтому компилятор не может создавать соответствующие диагностические сообщения. Дополнительные сведения о проверке типов содержатся в статье [Аргументы](../c-language/arguments.md).

Теперь область видимости прототипа в компиляторе Microsoft C соответствует стандарту ANSI при компиляции с параметром **/Za**. Таким образом, если вы объявите в прототипе тег **`struct`** или **`union`** , этот тег добавляется именно в этой области, а не в глобальной области. Например, если выполнять компиляцию с параметром **/Za** в соответствии со стандартом ANSI, эту функцию невозможно будет вызвать без получения ошибки несоответствия типов:

```C
void func1( struct S * );
```

Чтобы исправить код, определите или объявите **`struct`** или **`union`** в глобальной области перед прототипом функции:

```C
struct S;
void func1( struct S * );
```

При использовании параметра **/Ze** этот тег будет по-прежнему находиться в глобальной области.

## <a name="see-also"></a>См. также

[Функции](../c-language/functions-c.md)
