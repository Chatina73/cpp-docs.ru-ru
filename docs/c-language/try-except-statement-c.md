---
title: Оператор try-except (C)
description: Microsoft C/C++ реализует структурированную обработку исключений (SEH) с помощью расширения языка оператора try-except.
ms.date: 08/24/2020
helpviewer_keywords:
- try-except keyword [C]
- structured exception handling, try-except
- try-catch keyword [C]
- __try keyword [C]
- __except keyword [C]
- __except keyword [C], in try-except
- try-catch keyword [C], try-except keyword [C]
ms.assetid: f76db9d1-fc78-417f-b71f-18e545fc01c3
ms.openlocfilehash: e327150431fef3384f2b98940939444b2e6d96ea
ms.sourcegitcommit: efc8c32205c9d610f40597556273a64306dec15d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/26/2020
ms.locfileid: "88898717"
---
# <a name="try-except-statement-c"></a>Оператор try-except (C)

**Только для систем Майкрософт**

Оператор `try-except` является расширением Майкрософт для языка C, которое позволяет приложениям получать управление программой при возникновении событий, обычно приводящих к прекращению выполнения. Такие события вызываются исключениями, а механизм, предназначенный для работы с ними, называется структурированной обработкой исключений.

Исключения могут вызываться аппаратными или программными средствами. Даже если работу приложения после таких исключений нельзя полностью восстановить, структурированная обработка исключений позволяет записать и отобразить информацию об ошибке. Также полезно зафиксировать внутреннее состояние приложения, чтобы выполнить диагностику проблемы. В частности, это помогает при возникновении периодических проблем, которые сложно воспроизводить.

## <a name="syntax"></a>Синтаксис

> *`try-except-statement`*:\
> &emsp;**`__try`** *`compound-statement`* **`__except (`**  *`expression`*  **`)`** *`compound-statement`*

Составной оператор после предложения **`__try`**  — это *защищенный раздел*. Составной оператор после предложения **`__except`**  — это *обработчик исключений*. Обработчик определяет набор действий, предпринимаемых при возникновении исключения во время выполнения защищенного раздела. Выполнение происходит следующим образом:

1. Сначала выполняется защищенный раздел.

1. Если исключение при этом не возникает, выполнение переходит в инструкцию, стоящую после предложения **`__except`** .

1. Если исключение возникло во время выполнения защищенного раздела или в любой процедуре, вызываемой защищенным разделом, вычисляется выражение **`__except`** . Способ обработки исключения определяется возвращенным значением. Возможны три значения.

   - `EXCEPTION_CONTINUE_SEARCH`. Исключение не распознано. Программа переходит к поиску обработчика в стеке (сначала находятся выражения с оператором `try-except`, а затем обработчики со следующим наивысшим приоритетом).

   - `EXCEPTION_CONTINUE_EXECUTION`. Исключение распознано, но отклонено. Выполнение продолжается в точке, в которой возникло исключение.

   - `EXCEPTION_EXECUTE_HANDLER` Исключение распознано. Управление передается в обработчик исключений путем выполнения составного оператора **`__except`** , а затем выполнение продолжается с точки, в которой возникло исключение.

Так как выражение **`__except`** вычисляется как выражение C, оно ограничивается одиночным значением, оператором условного выражения или оператором "запятая". Если требуется более сложная обработка, выражение может вызывать процедуру, которая возвращает одно из этих трех значений.

> [!NOTE]
> Структурированная обработка исключений поддерживается с исходными файлами C и C++. Но она не предназначена специально для C++. Для переносимых программ C++ вместо структурированной обработки исключений следует использовать обработку исключений C++. Кроме того, механизм обработки исключений C++ обеспечивает намного более высокую гибкость, поскольку может обрабатывать исключения любого типа. Дополнительные сведения см. в разделе [Обработка исключений](../cpp/exception-handling-in-visual-cpp.md) в *справочнике по языку C++* .

Каждая процедура в приложении может иметь свой собственный обработчик исключений. Выражение **`__except`** выполняется в области тела **`__try`** . Оно имеет доступ ко всем локальным переменным, объявленным в этой области.

В блоке операторов **`__leave`** можно использовать ключевое слово `try-except`. Результат использования **`__leave`**  — переход в конец блока `try-except`. Выполнение продолжается после окончания обработчика исключений. Хотя для получения того же результата можно использовать оператор **`goto`** , он (оператор **`goto`** ) приводит к освобождению стека. Оператор **`__leave`** более эффективен, так как он не вызывает раскрутку стека.

Выход из оператора `try-except` с помощью функции времени выполнения `longjmp` считается ненормальным завершением. Переход к оператору **`__try`** недопустим, но выход из него допускается. Обработчик исключений не вызывается, если процесс удаляется во время выполнения оператора `try-except`.

## <a name="example"></a>Пример

Ниже приведен пример обработчика исключений и обработчика завершения. Дополнительные сведения об обработчиках завершения см. в разделе [Оператор `try-finally` (С)](../c-language/try-finally-statement-c.md).

```C
.
.
.
puts("hello");
__try {
   puts("in try");
   __try {
      puts("in try");
      RAISE_AN_EXCEPTION();
   } __finally {
      puts("in finally");
   }
} __except( puts("in filter"), EXCEPTION_EXECUTE_HANDLER ) {
   puts("in except");
}
puts("world");
```

Ниже показаны выходные данные для этого примера с комментариями справа:

```Output
hello
in try              /* fall into try                        */
in try              /* fall into nested try                 */
in filter           /* execute filter; returns 1 so accept  */
in finally          /* unwind nested finally                */
in except           /* transfer control to selected handler */
world               /* flow out of handler                  */
```

**КОНЕЦ Только для систем Майкрософт**

## <a name="see-also"></a>См. также раздел

[Оператор `try-except` (C++)](../cpp/try-except-statement.md)
