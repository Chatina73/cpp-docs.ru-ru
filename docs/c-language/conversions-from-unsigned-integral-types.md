---
title: Преобразования из целочисленных типов без знака
ms.date: 03/27/2019
helpviewer_keywords:
- integers, converting
- type casts, involving integers
- data type conversion [C++], signed and unsigned integers
- type conversion [C++], signed and unsigned integers
- integral conversions, from unsigned
ms.assetid: 60fb7e10-bff9-4a13-8a48-e19f25a36a02
ms.openlocfilehash: 3f6136a721f84332451184baa648ebc7c909d5d7
ms.sourcegitcommit: 309dc532f13242854b47759cef846de59bb807f1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2019
ms.locfileid: "58565026"
---
# <a name="conversions-from-unsigned-integral-types"></a>Преобразования из целочисленных типов без знака

Целое число без знака можно преобразовать в более короткое целое число без знака или со знаком путем усечения битов высокого порядка, или в более длинное целое число со знаком или без знака путем нулевого расширения. Дополнительные сведения см. в [таблице преобразований из целочисленных типов без знака](#conversions-from-unsigned-integral-types-table).

Если значение с целочисленным типом понижено до целого числа со знаком меньшего размера или целое число без знака преобразовано в соответствующее целое число со знаком, значение остается неизменным, если его можно представить в новом типе. Однако это значение представляет изменения, если бит знака задан, как показано в следующем примере.

```C
int j;
unsigned short k = 65533;

j = k;
printf_s( "%hd\n", j );   // Prints -3
```

Если осуществить представление невозможно, результат определяется реализацией. См. статью [Преобразования приведений типов](../c-language/type-cast-conversions.md), чтобы получить сведения об обработке понижения целых чисел компилятором Microsoft C. То же поведение является результатом преобразования целого числа или типового приведения целого числа.

Для преобразования значений без знака используется метод, сохраняющий их значения, который не может быть представлен непосредственно на языке C. Единственным исключением является преобразование из **unsigned long** во **float**, при котором в предельном случае теряются младшие разряды. В противном случае значение сохраняется (со знаком или без). Если значение целочисленного типа преобразуется в тип с плавающей запятой и это значение находится за пределами представляемого диапазона, результат не определен. (Сведения о диапазонах для целочисленных типов и типов с плавающей запятой см. в статье [Хранение базовых типов](../c-language/storage-of-basic-types.md).)

В следующей таблице перечислены преобразования из целочисленных типов без знака.

## <a name="conversions-from-unsigned-integral-types-table"></a>Таблица преобразований из целочисленных типов без знака

|Исходный тип|Кому|Метод|
|----------|--------|------------|
|**unsigned char**|**char**|Сохранение битового шаблона; бит высокого порядка становится битом знака|
|**unsigned char**|**short**|Нулевое расширение|
|**unsigned char**|**long**|Нулевое расширение|
|**unsigned char**|**unsigned short**|Нулевое расширение|
|**unsigned char**|**unsigned long**|Нулевое расширение|
|**unsigned char**|**float**|Преобразование в значение **long**; преобразование значения **long** в значение **float**|
|**unsigned char**|**double**|Преобразование в значение **long**; преобразование значения **long** в значение **double**|
|**unsigned char**|**long double**|Преобразование в значение **long**; преобразование значения **long** в значение **double**|
|**unsigned short**|**char**|Сохранение байта низкого порядка|
|**unsigned short**|**short**|Сохранение битового шаблона; бит высокого порядка становится битом знака|
|**unsigned short**|**long**|Нулевое расширение|
|**unsigned short**|**unsigned char**|Сохранение байта низкого порядка|
|**unsigned short**|**unsigned long**|Нулевое расширение|
|**unsigned short**|**float**|Преобразование в значение **long**; преобразование значения **long** в значение **float**|
|**unsigned short**|**double**|Преобразование в значение **long**; преобразование значения **long** в значение **double**|
|**unsigned short**|**long double**|Преобразование в значение **long**; преобразование значения **long** в значение **double**|
|**unsigned long**|**char**|Сохранение байта низкого порядка|
|**unsigned long**|**short**|Сохранение слова низкого порядка|
|**unsigned long**|**long**|Сохранение битового шаблона; бит высокого порядка становится битом знака|
|**unsigned long**|**unsigned char**|Сохранение байта низкого порядка|
|**unsigned long**|**unsigned short**|Сохранение слова низкого порядка|
|**unsigned long**|**float**|Преобразование в значение **long**; преобразование значения **long** в значение **float**|
|**unsigned long**|**double**|Непосредственное преобразование в **double**|
|**unsigned long**|**long double**|Преобразование в значение **long**; преобразование значения **long** в значение **double**|

**Блок, относящийся только к системам Microsoft**

Для компилятора Microsoft С тип **unsigned int** эквивалентен типу **unsigned long**. Преобразование значения **unsigned int** выполняется так же, как и преобразование **unsigned long**. Преобразования значений **unsigned long** во **float** не точны, если преобразуемое значение больше, чем максимально возможное положительное значение **long** со знаком.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Преобразования назначений](../c-language/assignment-conversions.md)
