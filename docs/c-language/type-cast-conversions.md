---
title: Преобразования приведений типов
ms.date: 11/04/2016
helpviewer_keywords:
- data type conversion [C++], type-cast conversions
- conversions [C++], type-cast
- type casts
- explicit type conversions
- type casts [C++], about type-cast conversion
- type-cast conversions [C++]
ms.assetid: 57ab5902-f12f-4326-a2f6-6282f1d4025a
ms.openlocfilehash: cc2b6d87d6fedf8d36373c901cdb6a6ba8b5f0e7
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231459"
---
# <a name="type-cast-conversions"></a>Преобразования приведений типов

Приведения типов можно использовать для явного преобразования типов.

**Синтаксис**

*cast-expression*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*унарное выражение*<br/>
&nbsp;&nbsp;&nbsp;&nbsp; **(**  *type-name*  **)**  *cast-expression*

*type-name*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*specifier-qualifier-list* *abstract-declarator*<sub>opt</sub>

*type-name* обозначает тип, а *cast-expression* содержит значение, которое требуется привести к этому типу. Выражение с приведением типов не является L-значением. *cast-expression* преобразуется так, как если бы оно было присвоено переменной с типом *type-name*. Правила преобразования при операциях присваивания (которые описаны в статье [Преобразования назначений](../c-language/assignment-conversions.md)) применяются и к приведению типов. В следующей таблице показаны типы, которые могут приводиться к любому заданному типу.

### <a name="legal-type-casts"></a>Допустимые приведения типов

|Целевые типы|Потенциальные источники|
|-----------------------|-----------------------|
|Целочисленные типы|Любой целочисленный тип, тип с плавающей запятой или указатель на объект|
|С плавающей запятой|Любой арифметический тип|
|Указатель на объект, или ( **`void`** <strong>\*</strong>)|Любой целочисленный тип, ( **`void`** <strong>\*</strong>), указатель на объект или указатель функции|
|Указатель на функцию|Любой целочисленный тип, указатель на объект или указатель функции|
|Структура, объединение или массив|Отсутствуют|
|Тип void|Любой тип|

Любой идентификатор можно привести к типу **`void`** . Однако если тип, указанный в выражении приведения типа, отличается от типа **`void`** , идентификатор, приводимый к этому типу, не может быть выражением **`void`** . Любое выражение можно привести к типу **`void`** , но выражение типа **`void`** невозможно привести к любому другому типу. Например, функция с возвращаемым типом **`void`** не может иметь обратное приведение к другому типу.

Обратите внимание, что выражение **`void`** <strong>\*</strong> содержит указатель типа **`void`** , а не **`void`** . Если объект приводится к типу **`void`** , результирующее выражение невозможно присвоить элементу. Аналогично объект приведения типа не является приемлемым L-значением, поэтому для такого объекта невозможно выполнить присваивание.

**Блок, относящийся только к системам Microsoft**

Приведение типа может быть выражением L-значения, если размер идентификатора не изменяется. Дополнительные сведения о левосторонних значениях см. в статье [Выражения L-Value и R-Value](../c-language/l-value-and-r-value-expressions.md).

**Завершение блока, относящегося только к системам Майкрософт**

Выражение можно преобразовать в тип **`void`** с помощью приведения, но результирующее выражение можно использовать только в том случае, если значение не требуется. После преобразования в тип **`void`** <strong>\*</strong> и обратно в исходный тип любой указатель объекта возвращается к своему исходному значению.

## <a name="see-also"></a>См. также

[Преобразования типов](../c-language/type-conversions-c.md)
