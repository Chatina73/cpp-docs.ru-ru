---
title: Многомерные массивы (C)
ms.date: 11/04/2016
helpviewer_keywords:
- arrays [C], multidimensional
- multidimensional arrays
- subscript expressions
ms.assetid: 4ba5c360-1f17-4575-b370-45f62e1f2bc2
ms.openlocfilehash: f94cdff03763f689edbdedffad4ac56abec5ee53
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87218836"
---
# <a name="multidimensional-arrays-c"></a>Многомерные массивы (C)

Индексное выражение также может иметь несколько индексов, как показано ниже:

```
expression1 [ expression2 ] [ expression3 ] ...
```

Индексные выражения связываются в направлении слева направо. Сначала вычисляется левое индексное выражение *expression1* **[** *expression2* **]** . Адрес, получающийся в результате сложения *expression1* и *expression2*, формирует выражение указателя. Затем к этому выражению указателя добавляется выражение *expression3*, чтобы образовать новое выражение указателя. Эти операции повторяются до тех пор, пока не будет добавлено последнее индексное выражение. После вычисления последнего индексного выражения выполняется оператор косвенного обращения (<strong>\*</strong>), если конечное значение указателя не указывает на тип массива (см. примеры ниже).

Выражения с несколькими индексами ссылаются на элементы многомерных массивов. Многомерный массив — это массив, элементы которого сами являются массивами. Например, первый элемент трехмерного массива является двумерным массивом.

## <a name="examples"></a>Примеры

В следующих примерах массив с именем `prop` объявляется с тремя элементами, каждый из которых представляет собой массив 4x6, содержащий значения типа **`int`** .

```
int prop[3][4][6];
int i, *ip, (*ipp)[6];
```

Ссылка на массив `prop` выглядит следующим образом:

```
i = prop[0][0][1];
```

В приведенном выше примере показано, как ссылаться на второй отдельный элемент **`int`** массива `prop`. Массивы хранятся по строкам, поэтому последний индекс изменяется быстрее; выражение `prop[0][0][2]` ссылается на следующий (третий) элемент массива и т. д.

```
i = prop[2][1][3];
```

Этот оператор представляет собой более сложную ссылку на отдельный элемент массива `prop`. Выражение вычисляется следующим образом.

1. Первый индекс, `2`, умножается на размер массива **`int`** 4x6 и добавляется к значению указателя `prop`. Результат указывает на третий массив 4x6 массива `prop`.

1. Второй индекс, `1`, умножается на размер 6-элементного массива **`int`** и добавляется к адресу, представленному значением `prop[2]`.

1. Каждый элемент 6-элементного массива является значением типа **`int`** , поэтому конечный индекс, `3`, перед добавлением к выражению `prop[2][1]` умножается на размер **`int`** . Результирующий указатель указывает на четвертый элемент 6-элементного массива.

1. Оператор косвенного обращения применяется к значению указателя. Результат — элемент **`int`** , расположенный по этому адресу.

Ниже приведены два примера, в которых оператор косвенного обращения не применяется.

```
ip = prop[2][1];

ipp = prop[2];
```

В первом из показанных операторов выражение `prop[2][1]` представляет собой допустимую ссылку на трехмерный массив `prop`; эта ссылка относится к 6-элементному массиву (объявленному выше). Поскольку значение указателя указывает на массив, оператор косвенного обращения не применяется.

Аналогично результат выражения `prop[2]` во втором операторе `ipp = prop[2];` представляет значение указателя, указывающее на двумерный массив.

## <a name="see-also"></a>См. также

[Оператор индекса:](../cpp/subscript-operator.md)
