---
title: Аргументы
ms.date: 11/04/2016
helpviewer_keywords:
- arguments [C++], function
- function parameters
- functions [C], parameters
- function parameters, about function parameters
- function arguments
- function calls, arguments
ms.assetid: 14cf0389-2265-41f0-9a96-f2223eb406ca
ms.openlocfilehash: e1c88034044c74a542384873454f993b6bce3244
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87232668"
---
# <a name="arguments"></a>Аргументы

Аргументы в вызове функции могут иметь следующую форму:

> *expression* **(** *expression-list*<SUB>opt</SUB> **)**  /* Вызов функции */

При вызове функции параметр *expression-list* содержит список выражений, разделенных запятыми. Значения этих выражений являются аргументами, которые передаются функции. Если функция не принимает аргументы, то список *expression-list* должен содержать ключевое слово **`void`** .

Аргументом может быть любое значение фундаментального типа или типа структуры, объединения или указателя. Все аргументы передаются по значению. Это означает, что параметру присваивается копия соответствующего аргумента, а где именно переданный аргумент находится в памяти, функции неизвестно. Она лишь обрабатывает полученную копию, не затрагивая исходную переменную.

Хотя массивы и функции не могут передаваться в качестве аргументов, вы можете передать указатели на них. Благодаря этому функция сможет обращаться к значению по ссылке. Поскольку указатель на переменную содержит адрес переменной, то функция может обращаться к значению по этому адресу. Аргументы-указатели позволяют функции обращаться к массивам и функциям, хотя сами они и не могут передаваться в качестве аргументов.

Порядок вычисления аргументов может различаться в зависимости от конкретного компилятора и уровня оптимизации. Однако аргументы и все побочные эффекты полностью вычисляются до входа в функцию. Дополнительные сведения см. в статье [Побочные эффекты](../c-language/side-effects.md).

При вызове функции вычисляются все выражения из списка *expression-list*, и для каждого аргумента выполняются обычные арифметические преобразования. Если доступен прототип, то результат вычисления аргументов сравнивается по типу с соответствующим параметром прототипа. Если они не совпадают, то либо выполняется преобразование, либо выводится диагностическое сообщение. Для параметров также проводятся обычные арифметические преобразования.

Количество выражений в *expression-list* должно совпадать с количеством параметров, если в прототипе или определении функции не указано явным образом переменное количество аргументов. В этом случае компилятор проверяет столько аргументов, сколько имен типов содержится в списке параметров. При необходимости он преобразует их, как описано выше. Дополнительные сведения см. в статье [Вызовы с переменным количеством аргументов](../c-language/calls-with-a-variable-number-of-arguments.md).

Если список параметров прототипа содержит только ключевое слово **`void`** , то компилятор не ожидает ни аргументов в вызове функции, ни параметров в определении. Если аргументы будут обнаружены, он выведет диагностическое сообщение.

## <a name="example"></a>Пример

В следующем примере в качестве аргументов используются указатели:

```C
int main()
{
    /* Function prototype */

    void swap( int *num1, int *num2 );
    int x, y;
    .
    .
    .
    swap( &x, &y );  /* Function call */
}

/* Function definition */

void swap( int *num1, int *num2 )
{
    int t;

    t = *num1;
    *num1 = *num2;
    *num2 = t;
}
```

В этом примере функция `swap` объявлена внутри функции `main`. Она имеет два аргумента, `num1` и `num2`, которые являются указателями на значения типа **`int`** . Параметры `num1` и `num2` в определении прототипа также объявляются как указатели на значения типа **`int`** .

Функция вызывается следующей инструкцией:

```C
swap( &x, &y )
```

Адрес `x`, который здесь используется, сохраняется в аргументе `num1`, а адрес `y` — в аргументе `num2`. Теперь для одного и того же местоположения имеется два имени, или псевдонима. Ссылки на значения `*num1` и `*num2` в функции `swap` одновременно представляют собой ссылки на значения `x` и `y` в функции `main`. Присваивания внутри функции `swap`, по сути, меняют содержимое переменных `x` и `y`. Поэтому оператор **`return`** не требуется.

Компилятор выполняет проверку типов для аргументов функции `swap`, поскольку в прототипе `swap` указаны типы аргументов для каждого параметра. Идентификаторы, приведенные в круглых скобках в прототипе и определении функции, могут совпадать, но могут и различаться. Важно лишь то, что типы аргументов в функции должны соответствовать типам параметров как в прототипе, так и в определении.

## <a name="see-also"></a>См. также

[Вызовы функций](../c-language/function-calls.md)
