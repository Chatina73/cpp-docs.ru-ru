---
title: Операторы побитового сдвига
ms.date: 10/18/2018
helpviewer_keywords:
- operators [C++], bitwise
- shift operators, bitwise
- bitwise-shift operators
- operators [C++], shift
ms.assetid: d0485785-5c72-47e1-a7c0-0adde03ade23
ms.openlocfilehash: a8a72a8657daec39bb042fea744b5f97d3b34009
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87226533"
---
# <a name="bitwise-shift-operators"></a>Операторы побитового сдвига

Операторы сдвига сдвигают свой первый операнд влево ( **&lt;&lt;** ) или вправо ( **>>** ) на число позиций, задаваемое вторым операндом.

## <a name="syntax"></a>Синтаксис

*shift-expression*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*additive-expression*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*shift-expression* **&lt;&lt;** *additive-expression*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*shift-expression* **>>** *additive-expression*

Оба операнда должны быть целыми значениями. Эти операторы выполняют обычные арифметические преобразования; типом результата является тип левого операнда после преобразования.

В случае сдвига влево для освобождаемых правых битов задается значение 0. В случае сдвига вправо освобождающиеся левые биты заполняются в зависимости от типа первого операнда после преобразования. В случае типа **`unsigned`** для них устанавливается значение 0. В противном случае они заполняются путем копирования бита знака. Для операторов сдвига влево без переполнения оператор

```C
expr1 << expr2
```

эквивалентен умножению на 2<sup>expr2</sup>. Для операторов сдвига вправо операция

```C
expr1 >> expr2
```

эквивалентна делению на 2<sup>expr2</sup>, если операнд `expr1` не имеет знака или имеет неотрицательное значение.

Результат операции сдвига не определен, если второй операнд имеет отрицательное значение или если правый операнд больше или равен ширине сдвигаемого левого операнда в битах.

Поскольку преобразования, выполняемые операторами сдвига, не обеспечивают условия переполнения и потери значимости, данные могут быть потеряны, если результат операции сдвига невозможно представить в типе первого операнда после преобразования.

```C
unsigned int x, y, z;

x = 0x00AA;
y = 0x5500;

z = ( x << 8 ) + ( y >> 8 );
```

В этом примере значение `x` сдвигается влево на 8 позиций, а значение `y` сдвигается вправо на 8 позиций. Значения после сдвига складываются, а получившееся в результате число 0xAA55 присваивается переменной `z`.

Сдвиг вправо отрицательного значения соответствует делению исходного значения на два с округлением вниз. Например, сдвиг вправо значения –253 (11111111 00000011 в двоичном представлении) дает значение –127 (11111111 10000001 в двоичном представлении). Сдвиг вправо положительного числа 253 дает +126.

При сдвиге вправо бит знака сохраняется. При сдвиге вправо целого числа со знаком старший значащий бит остается установленным. При сдвиге вправо целого числа без знака старший значащий бит очищается.

## <a name="see-also"></a>См. также

[Операторы сдвигов влево и вправо (>> и <<)](../cpp/left-shift-and-right-shift-operators-input-and-output.md)
