---
title: Операторы косвенного обращения и адреса операнда
ms.date: 02/16/2018
helpviewer_keywords:
- address-of operator (&)
- '* operator'
- operators [C++], address-of
- ampersand operator (&)
- '* operator, indirection operator'
- addresses [C++], indirection
- addresses [C++]
- indirection operator
- '& operator, address-of operator'
- null pointers [C++]
- '* operator, address-of operator'
- operators [C++], indirection
ms.assetid: 10d62b00-12ba-4ea9-a2d5-09ac29ca2232
ms.openlocfilehash: 146f84c90aa56b5abf6ae5212c1729022cb7e4dc
ms.sourcegitcommit: c6f8e6c2daec40ff4effd8ca99a7014a3b41ef33
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/24/2019
ms.locfileid: "64343899"
---
# <a name="indirection-and-address-of-operators"></a>Операторы косвенного обращения и адреса операнда

Унарный оператор косвенного обращения ( __&#42;__ ) обращается к значению не напрямую, а через указатель. Операнд должен иметь тип указателя. Результатом операции является значение в том адресе, на который указывает операнд. Тип результата совпадает с типом значения в адресе операнда.

Результат выполнения оператора косвенного обращения представляет собой *тип*, если тип операнда — *указатель на тип*. Если операнд указывает на функцию, результатом является указатель функции. Если он указывает на объект, результатом является адресующее объект значение (lvalue).

Если значение указателя недопустимо, результат оператора косвенного обращения не определен. Вот некоторые типичные условия, при которых значение указателя становится недопустимым.

- Указатель является пустым указателем.

- Указатель задает в момент ссылки адрес объекта после окончания его времени существования (например, объекта, вышедшего из области или освобожденного из памяти).

- Указатель определяет адрес, выравнивание которого не подходит для типа указываемого объекта.

- Указатель определяет адрес, который не используется выполняемой программой.

Унарный оператор взятия адреса ( **&** ) предоставляет адрес своего операнда. Операнд может быть либо значением, адресующим объект, который не объявлен как __register__ и не является битовым полем, либо результатом унарного оператора __&#42;__ или оператора разыменования массива ( __&#91;&#93;__ ), либо обозначением функции. Результат является *указателем на тип*, если тип операнда — *тип*.

Если операнд является результатом унарного оператора __&#42;__ , ни один из операторов не вычисляется, как если бы они оба были пропущены. Результат не является адресующим значением, и к операторам по-прежнему применяются ограничения. Если операнд является результатом оператора __&#91;&#93;__ , то ни оператор __&__ , ни унарный оператор __&#42;__ , подразумеваемый оператором __&#91;&#93;__ , не вычисляются. Результат будет таким же, как при удалении оператора __&__ и смене оператора __&#91;&#93;__ на __+__ . В противном случае будет получен указатель на объект или функцию, назначаемую операндом.

## <a name="examples"></a>Примеры

Далее в примерах используются следующие типичные объявления.

```C
int *pa, x;
int a[20];
double d;
```

Эта инструкция использует оператор взятия адреса ( **&** ) для получения адреса шестого элемента массива `a`. Результат сохраняется в переменной указателя `pa`:

```C
pa = &a[5];
```

Оператор косвенного обращения ( __&#42;__ ) в этом примере обращается к значению `int` по адресу, сохраненному в переменной `pa`. Значение присваивается целочисленной переменной `x`:

```C
x = *pa;
```

В этом примере показано, что косвенное обращение к адресу `x` дает результат, равный значению `x`.

```C
assert( x == *&x );
```

Этот пример показывает эквивалентные способы объявления указателя на функцию.

```C
int roundup( void );     /* Function declaration */

int  *proundup  = roundup;
int  *pround  = &roundup;
assert( pround == proundup );
```

После объявления функции `roundup` объявляются и инициализируются два указателя на `roundup`. При инициализации первого из них, `proundup`, указывается только имя функции, а для второго, `pround`, используется оператор взятия адреса. Обе инициализации эквивалентны.

## <a name="see-also"></a>См. также

[Оператор косвенного обращения: &#42;](../cpp/indirection-operator-star.md)<br/>
[Оператор address-of: &](../cpp/address-of-operator-amp.md)
