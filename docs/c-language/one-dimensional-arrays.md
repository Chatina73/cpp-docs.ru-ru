---
title: Одномерные массивы
ms.date: 11/04/2016
helpviewer_keywords:
- brackets [ ]
- brackets [ ], arrays
- one-dimensional arrays
- arrays [C++], one-dimensional
- square brackets [ ]
- square brackets [ ], arrays
- subscript expressions
ms.assetid: e28536e5-3b77-46b5-97fd-9b938c771816
ms.openlocfilehash: 7ac57a65d575ba6a9134f3c4474103735411847d
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75299108"
---
# <a name="one-dimensional-arrays"></a>Одномерные массивы

Постфиксное выражение, за которым следует выражение в квадратных скобках ( **[ ]** ), является представлением элемента объекта массива с индексом. Выражение с индексом в представленной ниже форме ссылается на значение, размешенное по адресу на *expression* позиций дальше *postfix-expression*:

```
postfix-expression [ expression ]
```

Обычно *postfix-expression* является указателем, например идентификатором массива, а *expression* является целочисленным значением. Однако все, что необходимо синтаксически, — это чтобы одно из выражений имело тип указателя, а другие — целочисленный тип. Таким образом, целочисленное значение может находиться в позиции *postfix-expression*, а значение указателя — в "позиции индекса", т. е. *expression*. Например, такой код является допустимым:

```c
// one_dimensional_arrays.c
int sum, *ptr, a[10];
int main() {
   ptr = a;
   sum = 4[ptr];
}
```

Выражения индекса обычно используются для ссылки на элементы массива, но индекс может применяться к любому указателю. Независимо от порядка значений, выражение *expression* должно быть заключено в квадратные скобки ( **[ ]** ).

Выражение индекса вычисляется путем добавления целочисленного значения к значению указателя, а результат передается в оператор косвенного обращения (<strong>\*</strong>). (См. раздел [Операторы косвенного обращения и адреса-of](../c-language/indirection-and-address-of-operators.md) для обсуждения оператора косвенного обращения.) В действительности для одномерного массива следующие четыре выражения эквивалентны, предполагая, что `a` является указателем, а `b` является целым числом:

```
a[b]
*(a + b)
*(b + a)
b[a]
```

В соответствии с правилами преобразования для оператора сложения (их описание вы найдете в статье [Аддитивные операторы в C](../c-language/c-additive-operators.md)) целочисленное значение преобразуется в смещение адреса путем умножения целочисленного значения на длину типа, на который указывает указатель.

Например, предположим, что идентификатор `line` ссылается на массив значений `int`. Для вычисления выражения индекса `line[ i ]` используется следующая процедура:

1. Целочисленное значение `i` умножается на количество байт, определенное как длина элемента `int`. Преобразованное значение `i` представляющее `i` позиции `int`.

1. Это преобразованное значение добавляется к исходному значению указателя (`line`), чтобы получить адрес, который смещен `i` `int` позициям от `line`.

1. Оператор косвенного обращения применяется к новому адресу. Результат представляет собой значение элемента массива в этой позиции (интуитивно, `line [ i ]`).

Выражение индекса `line[0]` представляет значение первого элемента массива line, поскольку смещение от адреса, представляемого `line`, равно 0. Аналогично, выражение `line[5]` ссылается на элемент, смещенный на 5 позиций относительно line, или на шестой элемент массива.

## <a name="see-also"></a>См. также:

[Оператор индекса:](../cpp/subscript-operator.md)
