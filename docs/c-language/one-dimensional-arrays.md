---
title: Одномерные массивы
ms.date: 11/04/2016
helpviewer_keywords:
- brackets [ ]
- brackets [ ], arrays
- one-dimensional arrays
- arrays [C++], one-dimensional
- square brackets [ ]
- square brackets [ ], arrays
- subscript expressions
ms.assetid: e28536e5-3b77-46b5-97fd-9b938c771816
ms.openlocfilehash: c310d610b4e4cfc5ae5620d38337a5b8fd5243ef
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87226357"
---
# <a name="one-dimensional-arrays"></a>Одномерные массивы

Постфиксное выражение, за которым следует выражение в квадратных скобках ( **[ ]** ), является представлением элемента объекта массива с индексом. Выражение с индексом в представленной ниже форме ссылается на значение, размешенное по адресу на *expression* позиций дальше *postfix-expression*:

```
postfix-expression [ expression ]
```

Обычно *postfix-expression* является указателем, например идентификатором массива, а *expression* является целочисленным значением. Однако все, что необходимо синтаксически, — это чтобы одно из выражений имело тип указателя, а другие — целочисленный тип. Таким образом, целочисленное значение может находиться в позиции *postfix-expression*, а значение указателя — в "позиции индекса", т. е. *expression*. Например, такой код является допустимым:

```c
// one_dimensional_arrays.c
int sum, *ptr, a[10];
int main() {
   ptr = a;
   sum = 4[ptr];
}
```

Выражения индекса обычно используются для ссылки на элементы массива, но индекс может применяться к любому указателю. Независимо от порядка значений, выражение *expression* должно быть заключено в квадратные скобки ( **[ ]** ).

Выражение индекса вычисляется путем добавления целочисленного значения к значению указателя, а результат передается в оператор косвенного обращения (<strong>\*</strong>). (Этот механизм обсуждается в статье [Операторы косвенного обращения и адреса операнда](../c-language/indirection-and-address-of-operators.md).) В конечном итоге в случае одномерного массива следующие 4 выражения эквивалентны, при условии что `a` является указателем, а `b` — целым числом:

```
a[b]
*(a + b)
*(b + a)
b[a]
```

В соответствии с правилами преобразования для оператора сложения (их описание вы найдете в статье [Аддитивные операторы в C](../c-language/c-additive-operators.md)) целочисленное значение преобразуется в смещение адреса путем умножения целочисленного значения на длину типа, на который указывает указатель.

Например, предположим, что идентификатор `line` ссылается на массив значений **`int`** . Для вычисления выражения индекса `line[ i ]` используется следующая процедура:

1. Целочисленное значение `i` умножается на количество байт, определенное как длина элемента **`int`** . Преобразованное значение `i` представляет позиции `i` **`int`** .

1. Это преобразованное значение добавляется к исходному значению указателя (`line`) для получения адреса, представляющего позиции, смещенные на `i` **`int`** относительно `line`.

1. Оператор косвенного обращения применяется к новому адресу. Результат представляет собой значение элемента массива в этой позиции (интуитивно, `line [ i ]`).

Выражение индекса `line[0]` представляет значение первого элемента массива line, поскольку смещение от адреса, представляемого `line`, равно 0. Аналогично, выражение `line[5]` ссылается на элемент, смещенный на 5 позиций относительно line, или на шестой элемент массива.

## <a name="see-also"></a>См. также

[Оператор индекса:](../cpp/subscript-operator.md)
