---
title: Инициализация скалярных типов
ms.date: 11/04/2016
helpviewer_keywords:
- initializing scalar types
- register variables
- initialization, scalar types
- initializing variables, scalar types
- scalar types
- static variables, initializing
- automatic storage class, initializing scalar types
- automatic storage class
- types [C], initializing
ms.assetid: 73c516f5-c3ad-4d56-ab3b-f2a82b621104
ms.openlocfilehash: f991eff82e5b6919f7960513ae9bc502cad77069
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50641094"
---
# <a name="initializing-scalar-types"></a>Инициализация скалярных типов

При инициализации скалярных типов значение *assignment-expression* присваивается переменной. Применяются правила преобразования для присваивания. (См. сведения о правилах преобразования в статье [Преобразования типов (C)](../c-language/type-conversions-c.md).)

## <a name="syntax"></a>Синтаксис

*declaration*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declaration-specifiers* *init-declarator-list*<sub>opt</sub> **;**

*declaration-specifiers*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*storage-class-specifier* *declaration-specifiers*<sub>opt</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-specifier* *declaration-specifiers*<sub>opt</sub> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;*type-qualifier* *declaration-specifiers*<sub>opt</sub>

*init-declarator-list*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*init-declarator*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*init-declarator-list* **,** *init-declarator*

*init-declarator*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declarator*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*declarator* **=** *initializer* /\* Для инициализации скалярных переменных \*/

*initializer*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*assignment-expression*

Можно инициализировать переменные любого типа при условии соблюдения следующих правил.

- Переменные, объявленные на уровне области файлов, можно инициализировать. Если явно не инициализировать переменную на внешнем уровне, она инициализируется значением 0 по умолчанию.

- Константное выражение можно использовать для инициализации любой глобальной переменной, объявленной со статическим **static** описателем класса хранения (*storage-class-specifier*). Переменные, объявленные как **static**, инициализируются после начала исполнения программы. Если явно не инициализировать глобальную переменную, объявленную как **static**, она инициализируется значением 0 по умолчанию, и каждому элементу типа "указатель" присваивается указатель NULL.

- Переменные, объявленные с описателем класса хранения **auto** или **register**, инициализируются каждый раз при передаче контроля исполнения блоку, в котором они объявлены. Если исключить инициализатор из объявления переменной **auto** или **register**, начальное значение переменной будет неопределенным. Для автоматических значений и значений регистра инициализатор не обязательно должен являться константой; он может быть любым выражением, включая ранее определенные значения (даже вызовами функции).

- Начальные значения для внешних объявлений переменных и для всех переменных **static** (как внешних, так и внутренних) должны представлять собой константные выражения. (Дополнительные сведения см. в разделе [Постоянные выражения в C](../c-language/c-constant-expressions.md).) Так как адрес объявленной внешне или статической переменной является константным, его можно использовать для инициализации объявленной внутренне переменной указателя **static**. Однако адрес переменной **auto** невозможно использовать как статический инициализатор, так как он может быть разным для каждого исполнения блока. Для инициализации переменных **auto** и **register** можно использовать константные или переменные значения.

- Если объявление идентификатора имеет область видимости блока и идентификатор имеет внешнюю компоновку, объявление не может иметь инициализацию.

## <a name="examples"></a>Примеры

Инициализация иллюстрируется следующими примерами.

```C
int x = 10;
```

Целочисленная переменная `x` инициализируется с константным выражением `10`.

```C
register int *px = 0;
```

Указатель `px` инициализируется значением 0, создавая указатель null.

```C
const int c = (3 * 1024);
```

В этом примере константное выражение `(3 * 1024)` используется для инициализации `c` с константным значением, которое невозможно изменить из-за ключевого слова **const**.

```C
int *b = &x;
```

Этот оператор инициализирует указатель `b` адресом другой переменной, `x`.

```C
int *const a = &z;
```

Указатель `a` инициализируется с адресом переменной с именем `z`. Но так как он определен как **const**, переменную `a` можно только инициализировать, но не изменить. Она всегда указывает на одно и то же расположение.

```C
int GLOBAL ;

int function( void )
{
    int LOCAL ;
    static int *lp = &LOCAL;   /* Illegal initialization */
    static int *gp = &GLOBAL;  /* Legal initialization   */
    register int *rp = &LOCAL; /* Legal initialization   */
}
```

Глобальная переменная `GLOBAL` объявляется на внешнем уровне и поэтому имеет глобальное время существования. Локальная переменная `LOCAL` относится к классу хранения **auto**, и ей присваивается адрес только во время исполнения функции, в которой она объявлена. Поэтому инициализировать **статическую** переменную указателя `lp` с адресом `LOCAL` невозможно. **Статическую** переменную указателя `gp` можно инициализировать с адресом `GLOBAL`, так как этот адрес остается неизменным. Аналогично, `*rp` можно инициализировать, поскольку `rp` — это локальная переменная и может иметь неконстантный инициализатор. Всякий раз при входе в блок `LOCAL` имеет новый адрес, который затем присваивается `rp`.

## <a name="see-also"></a>См. также

[Инициализация](../c-language/initialization.md)