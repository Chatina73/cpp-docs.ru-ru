---
title: Квалификаторы типов
description: Сведения о квалификаторах типов для языка C, которые используются в компиляторе Microsoft Visual C
ms.date: 11/6/2020
helpviewer_keywords:
- volatile keyword [C], type qualifier
- type qualifiers
- volatile keyword [C]
- qualifiers for types
- const keyword [C]
- memory, access using volatile
- volatile keyword [C], type specifier
ms.assetid: bb4c6744-1dd7-40a8-b4eb-f5585be30908
ms.openlocfilehash: dd36aeb5d142eebbd6e4a339fe6c18925a6fd45a
ms.sourcegitcommit: 3f0c1dcdcce25865d1a1022bcc5b9eec79f69025
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2020
ms.locfileid: "94381614"
---
# <a name="type-qualifiers"></a>Квалификаторы типов

Квалификаторы типов предоставляют идентификатору одно из двух свойств. Квалификатор типа **`const`** объявляет объект как неизменяемый. Квалификатор типа **`volatile`** объявляет элемент, значение которого можно изменить допустимым образом с помощью средств, недоступных программе, в которой он находится, таких как выполняемый в данный момент поток.

Квалификаторы типов **`const`** , **`restrict`** и **`volatile`** могут использоваться в объявлении только один раз. Квалификаторы типов могут использоваться с любым описателем типа; они не могут находиться после первой запятой в объявлении нескольких элементов. Например, следующие объявления допустимы.

```c
typedef volatile int VI;
const int ci;
```

Следующие объявления недопустимы.

```c
typedef int *i, volatile *vi;
float f, const cf;
```

Квалификаторы типов имеют смысл только при обращении к идентификаторам как к l-значениям в выражениях. Дополнительные сведения о левосторонних значениях и выражениях см. в статье [Выражения L-Value и R-Value](../c-language/l-value-and-r-value-expressions.md).

## <a name="syntax"></a>Синтаксис

*`type-qualifier`*:\
&emsp;**`const`**\
&emsp;**`restrict`**\
&emsp;**`volatile`**

## <a name="const-and-volatile"></a>`const` и `volatile`

Ниже представлены допустимые объявления **`const`** и **`volatile`** .

```c
int const *p_ci;      // Pointer to constant int
int const (*p_ci);   // Pointer to constant int
int *const cp_i;     // Constant pointer to int
int (*const cp_i);   // Constant pointer to int
int volatile vint;     // Volatile integer
```

Если спецификация типа массива включает квалификаторы типов, определяется элемент, а не тип массива. Если спецификация типа функции включает квалификаторы, поведение не определено. **`volatile`** и **`const`** не влияют на диапазон значений или арифметические свойства объекта.

- Ключевое слово **`const`** можно использовать для изменения любого фундаментального или агрегатного типа, указателя на объект любого типа или **`typedef`** . Если элемент объявлен только с квалификатором типа **`const`** , считается, что он имеет тип **const int**. Переменную с квалификатором **`const`** можно инициализировать в области хранения, доступной только для чтения, или переместить в такую область. Ключевое слово **`const`** полезно при объявлении указателей на значения **`const`** . Так вы сообщите функции, что этот указатель нельзя изменять.

- Компилятор предполагает, что в любом месте программы к переменной **`volatile`** может обратиться неизвестный процесс, который использует или изменяет ее значение. Независимо от оптимизаций, указанных в командной строке, нужно создать код для каждого назначения переменной **`volatile`** или ссылки на нее, даже если кажется, что он ничего не делает.

Если **`volatile`** используется отдельно, предполагается **`int`** . Описатель типа **`volatile`** можно использовать для предоставления надежного доступа к специальным адресам памяти. Используйте **`volatile`** с объектами данных, к которым можно получить доступ или которые можно изменить с помощью обработчиков сигналов, одновременного выполнения программ или специального оборудования, например регистров управления MMIO. Можно объявить переменную как **`volatile`** на весь срок ее существования или объявить как **`volatile`** только одну ссылку.

- Элемент может одновременно быть **`const`** и **`volatile`** , и тогда его невозможно изменить допустимым образом в той же программе, но можно изменить в некотором асинхронном процессе.
 
## `restrict`

Квалификатор типа **`restrict`** , который появился в C99, можно применять к объявлениям указателей. Он определяет сам указатель, а не то, на что он указывает.

**`restrict`** является для компилятора указанием оптимизации и обозначает то, что ни один другой указатель в текущей области не ссылается на то же расположение в памяти. Таким образом, для получения доступа к объекту в течение времени существования такого указателя используется только этот указатель или производное от него значение (например, "указатель + 1"). Это помогает компилятору создавать более оптимизированный код. C++ имеет эквивалентный механизм: [`__restrict`](../cpp/extension-restrict.md).

На забывайте, что **`restrict`** считается контрактом между вами и компилятором. Если вы создадите псевдоним для указателя с пометкой **`restrict`** , результат будет неопределенным.

Вот пример с использованием **`restrict`** :

```c
void test(int* restrict first, int* restrict second, int* val)
{
    *first += *val;
    *second += *val;
}

int main()
{
    int i = 1, j = 2, k = 3;
    test(&i, &j, &k);

    return 0;
}

// Marking union members restrict tells the compiler that
// only z.x or z.y will be accessed in any scope, which allows
// the compiler to optimize access to the members.
union z 
{
    int* restrict x;
    double* restrict y;
};
```

## <a name="see-also"></a>См. также раздел

[`/std` (определение стандартной версии языка)](../build/reference/std-specify-language-standard-version.md)\
[Объявления и типы](../c-language/declarations-and-types.md)
