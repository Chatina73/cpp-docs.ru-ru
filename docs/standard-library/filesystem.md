---
title: '&lt;filesystem&gt;'
description: Описывает классы, функции и типы в заголовке filesystem стандартной C++ библиотеки.
ms.date: 01/22/2020
f1_keywords:
- <filesystem>
ms.assetid: 5005753b-46fa-43e1-8d4e-1b38617d3cfd
no-loc:
- filesystem
- experimental
- char
- wchar_t
- char16_t
- char32_t
ms.openlocfilehash: f9e384953a4e675ad6235a274c447031976a1585
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79441711"
---
# &lt;filesystem&gt;

Включите заголовок &lt;filesystem> для доступа к классам и функциям, которые управляют и извлекают сведения о путях, файлах и каталогах.

## <a name="syntax"></a>Синтаксис

```cpp
#include <filesystem> // C++17 standard header file name
#include <experimental/filesystem> // Header file for pre-standard implementation
using namespace std::experimental::filesystem::v1;
```

> [!IMPORTANT]
> В выпуске Visual Studio 2017 заголовок \<filesystem> был еще не C++ стандартным. C++в Visual Studio 2017 RTW реализует окончательный черновой стандарт, который находится в стандарте [ISO/IEC JTC 1/SC 22/WG 21 N4100](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4100.pdf). Visual Studio 2017 версии 15,7 и более поздних версий поддерживает новый язык C++ 17 \<filesystem> Standard.
> Это совершенно новая реализация, несовместимая с предыдущей версией `std::experimental`. Она была необходима для поддержки символьную ссылку, исправления ошибок и изменений в стандартном поведении. В настоящее время, включая \<filesystem> предоставляет новые `std::filesystem` и предыдущее `std::experimental::filesystem`. Включая \<experimental/filesystem> предоставляет только старую реализацию experimental. Реализация experimental будет удалена в следующем выпуске библиотек ABI.

Этот заголовок поддерживает файловые системы для одного из двух основных классов операционных систем размещения: Microsoft Windows и POSIX.

Хотя большинство функций являются общими для обеих операционных систем, в этом документе указываются некоторые отличия. Пример:

- Windows поддерживает несколько корневых имен, например `c:` или `\\network_name`. Файловая система состоит из леса деревьев, каждый из которых имеет собственный корневой каталог, например `c:\` или `\\network_name\`, и каждый с собственным текущим каталогом для заполнения относительного пути (не является абсолютным путем).

- POSIX поддерживает одно дерево без корневого имени, один корневой каталог `/`и один текущий каталог.

Другое важное отличие состоит в представлении путей:

- В Windows используется завершающая нуль последовательность **wchar_t** , закодированная как UTF-16 (один или несколько элементов для каждого символа).

- POSIX использует последовательность, завершающуюся нулем, **char** в кодировке UTF-8 (один или несколько элементов для каждого символа).

- Объект класса `path` сохраняет путь в собственной форме, но поддерживает простое преобразование между этой хранимой формой и несколькими внешними формами:

  - Последовательность **char** , завершающаяся нулем, в кодировке, которая является предпочтительной операционной системой.

  - Последовательность **char** , завершающаяся нулем, в кодировке UTF-8.

  - Последовательность **wchar_t** , завершающаяся нулем, в кодировке, которая является предпочтительной операционной системой.

  - Последовательность **char16_t** , завершающаяся нулем, в кодировке UTF-16.

  - Последовательность **char32_t** , завершающаяся нулем, в кодировке UTF-32.

  Взаимные преобразования между этими представлениями выполняются по мере необходимости с помощью одного или нескольких аспектов `codecvt`. Если определенный объект локали не указан, эти аспекты получаются из глобального языкового стандарта.

Еще одно различие заключается в степени детализации, с которой каждая операционная система позволяет указать разрешения доступа к файлу или каталогу.

- Windows записывает, является ли файл доступным только для чтения или доступен для записи, атрибутом, который не имеет смысла для каталогов.

- POSIX записывает, может ли файл быть прочитан, записан или выполнен (просматривается, если каталог). А также сведения о том, разрешена ли каждая операция для владельца, Группа владельца или для всех, и несколько других разрешений.

Общей характеристикой обеих систем является структура, применяемая к пути после корневого имени. Для `c:/abc/xyz/def.ext`пути:

- Имя корня — `c:`.

- Корневой каталог — `/`.

- Корневой путь — `c:/`.

- Относительный путь `abc/xyz/def.ext`.

- Родительский путь — `c:/abc/xyz`.

- Имя файла — `def.ext`.

- Ресурс `def`.

- Расширение — `.ext`.

Незначительное различие — это предпочтительный разделитель между последовательностью каталогов в пути. Обе операционные системы позволяют написать косую черту `/`, но в некоторых контекстах Windows предпочитает обратную косую черту `\`. Реализация сохраняет свой предпочтительный разделитель в элементе данных `preferred_separator` в `path`.

Наконец, `path` объекты имеют важную возможность: их можно использовать везде, где требуется аргумент filename в классах, определенных в заголовке [\<fstream >](fstream.md).

Дополнительные сведения и примеры кода см. в разделе [Навигация по файловойC++системе ()](../standard-library/file-system-navigation.md).

## <a name="members"></a>Члены

### <a name="classes"></a>Классы

|||
|-|-|
|[класс directory_entry](../standard-library/directory-entry-class.md)|Описывает объект, возвращаемый `directory_iterator` или `recursive_directory_iterator` и содержащий `path`.|
|[класс directory_iterator](../standard-library/directory-iterator-class.md)|Описывает итератор ввода, выполняющий последовательный перебор имен файлов в каталоге файловой системы.|
|[класс filesystem_error](../standard-library/filesystem-error-class.md)|Базовый класс для исключений, создаваемых для отчета о переполнении системы низкого уровня.|
|[класс Path](../standard-library/path-class.md)|Определяет класс, который хранит объект типа шаблона `String` , пригодный для использования в качестве имени файла.|
|[класс recursive_directory_iterator](../standard-library/recursive-directory-iterator-class.md)|Описывает итератор ввода, выполняющий последовательный перебор имен файлов в каталоге файловой системы. Итератор может также просматривать подкаталоги.|
|[класс file_status](../standard-library/file-status-class.md)|Создает оболочку для `file_type`.|

### <a name="structs"></a>Структуры

|||
|-|-|
|[Структура space_info](../standard-library/space-info-structure.md)|Содержит сведения о томе.|

## <a name="functions"></a>Функции

[функции > filesystem\<](../standard-library/filesystem-functions.md)

## <a name="operators"></a>Операторы

[операторы > filesystem\<](../standard-library/filesystem-operators.md)

## <a name="enumerations"></a>Перечисления

|||
|-|-|
|[copy_options](../standard-library/filesystem-enumerations.md#copy_options)|Перечисление, используемое с функцией [copy_file](../standard-library/filesystem-functions.md#copy_file), которое определяет поведение в случае, если конечный файл уже существует.|
|[directory_options](../standard-library/filesystem-enumerations.md#directory_options)|Перечисление, указывающее параметры итераторов каталога.|
|[file_type](../standard-library/filesystem-enumerations.md#file_type)|Перечисление для типов файлов.|
|[perm_options](../standard-library/filesystem-enumerations.md#perm_options)| Перечисляет параметры для функции `permissions`. |
|[perms](../standard-library/filesystem-enumerations.md#perms)|Тип битовой маски, используемый для передачи разрешений и параметров для разрешений.|

## <a name="see-also"></a>См. также раздел

[Справочник по файлам заголовков](../standard-library/cpp-standard-library-header-files.md)
