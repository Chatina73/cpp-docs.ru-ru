---
title: '&lt;новый&gt; операторов и перечислений'
ms.date: 11/04/2016
f1_keywords:
- new/std::operator delete
- new/std::operator new
ms.assetid: d1af4b56-9a95-4c65-ab01-bf43e982c7bd
ms.openlocfilehash: a3fd5b825fe1eaf3a07d9d001f03b9d0c64ffa31
ms.sourcegitcommit: 3590dc146525807500c0477d6c9c17a4a8a2d658
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/16/2019
ms.locfileid: "68243682"
---
# <a name="ltnewgt-operators-and-enums"></a>&lt;новый&gt; операторов и перечислений

## <a name="op_align_val_t"></a> Перечисление align_val_t

```cpp
enum class align_val_t : size_t {};
```

## <a name="op_delete"></a> оператор delete

Функция, вызываемая с помощью выражения delete для отмены выделения хранилища для отдельных объектов.

```cpp
void operator delete(void* ptr) throw();
void operator delete(void *, void*) throw();
void operator delete(void* ptr, const std::nothrow_t&) throw();
```

### <a name="parameters"></a>Параметры

*PTR*\
Указатель, значение которого при удалении устанавливается в недействительное.

### <a name="remarks"></a>Примечания

Первая функция вызывается с помощью выражения delete для подготовки к просмотру значение *ptr* недопустимый. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принимать значение *ptr* то есть значение null или результат предыдущего вызова к [оператор new](../standard-library/new-operators.md#op_new)(**size_t**).

Значение null по умолчанию *ptr* не нужно ничего делать. Любое другое значение *ptr* должно быть значением, возвращенным ранее путем вызова как описано выше. Поведение по умолчанию для таких отличное от NULL значение *ptr* — освободить память, выделенную предыдущим вызовом. Он не указывается, при каких условиях часть или вся такая освобожденная память выделяется при последующих вызовах для `operator new`(**size_t**), или к любой `calloc`( **size_t**), `malloc`( **size_t**), или `realloc`( **void**<strong>\*</strong>, **size_t**).

Вторая функция вызывается помещением выражения delete, соответствующего новому выражению, в форме **new**( **std::size_t**). Она ничего не делает.

Третья функция вызывается помещением выражения delete, соответствующего новому выражению, в форме **new**( **std::size_t**, **conststd::nothrow_t&** ). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение: принимать значение `ptr` — null или результат возврата предыдущего вызова `operator new`( **size_t**). Поведение по умолчанию — вычислить **удалить**(`ptr`).

### <a name="example"></a>Пример

См. в разделе [оператор new](../standard-library/new-operators.md#op_new) пример, используйте **оператор delete**.

## <a name="op_delete_arr"></a> оператор delete]

Функция, вызываемая с помощью выражения delete для отмены выделения хранилища для массива объектов.

```cpp
void operator delete[](void* ptr) throw();
void operator delete[](void *, void*) throw();
void operator delete[](void* ptr, const std::nothrow_t&) throw();
```

### <a name="parameters"></a>Параметры

*PTR*\
Указатель, значение которого при удалении устанавливается в недействительное.

### <a name="remarks"></a>Примечания

Первая функция вызывается `delete[]` выражения для отображения значения *ptr* недопустимый. Это заменяемая функция, так как в программе можно определить функцию с сигнатурой этой функции, которая заменит версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принимать значение *ptr* то есть значение null или результат предыдущего вызова к [оператор new&#91;&#93;](../standard-library/new-operators.md#op_new_arr)(**size_t**). Значение null по умолчанию *ptr* не нужно ничего делать. Любое другое значение *ptr* должно быть значением, возвращенным ранее путем вызова как описано выше. Поведение по умолчанию для таких отличное от null значение *ptr* — освободить память, выделенную предыдущим вызовом. Он не указывается, при каких условиях часть или вся такая освобожденная память выделяется при последующих вызовах для [оператор new](../standard-library/new-operators.md#op_new)(**size_t**), или к любой `calloc`(**size_t**), `malloc`(**size_t**), или `realloc`( **void**<strong>\*</strong>, **size_t**) .

Вторая функция вызывается размещение `delete[]` значение, соответствующее `new[]` выражение в форме `new[]`(**std::size_t**). Она ничего не делает.

Третья функция вызывается помещением выражения delete, соответствующего выражению `new[]` в форме `new[]`( **std::size_t**, **const std::nothrow_t&** ). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принимать значение *ptr* то есть значение null или результат предыдущего вызова оператора `new[]`(**size_t**). Поведение по умолчанию — вычислить `delete[]`( `ptr`).

### <a name="example"></a>Пример

См. раздел [Оператор new&#91;&#93;](../standard-library/new-operators.md#op_new_arr) с примерами использования `operator delete[]`.

## <a name="op_new"></a> оператор new

Функция вызывается выражением new для выделения памяти для отдельных объектов.

```cpp
void* operator new(std::size_t count) throw(bad_alloc);
void* operator new(std::size_t count, const std::nothrow_t&) throw();
void* operator new(std::size_t count, void* ptr) throw();
```

### <a name="parameters"></a>Параметры

*число*\
Количество байт памяти для выделения.

*PTR*\
Возвращаемый указатель.

### <a name="return-value"></a>Возвращаемое значение

Указатель на адрес младшего байта выделенной памяти. Или *ptr*.

### <a name="remarks"></a>Примечания

Первая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.

Требуемое поведение — вернуть указатель, отличный от null, только если память может быть выделена, как это запрошено. Каждое такое выделение выдает указатель на память, которая не пересекается ни с одной другой выделенной памятью. Порядок и непрерывность памяти, выделяемой последовательными вызовами, не уточняется. Начальное сохраненное значение не уточняется. Возвращаемый указатель указывает на начало (адрес младшего байта) выделенной памяти. Если счетчик равен нулю, возвращенное значение не будет равно ни одному другому значению, возвращенному функцией.

Поведение по умолчанию — выполнить цикл. Внутри цикла функция сначала пытается выделить запрошенную память. Будут ли эти попытки включать вызов `malloc`( **size_t**), не уточняется. Если попытка успешна, функция возвращает указатель на выделенную память. В противном случае функция вызывает назначенный [обработчик new](../standard-library/new-typedefs.md#new_handler). Если вызванная функция возвращает управление, цикл повторяется. Цикл прекращается, когда попытка выделения запрошенной памяти завершилась успехом или если вызванная функция не вернула управление.

Требуемое поведение обработчика new — выполнить одну из следующих операций:

- Сделать больше памяти, доступной для выделения, и завершить выполнение.

- Вызвать либо метод **прервать** или **выйти из**(`int`).

- Выдать объект типа **bad_alloc.**

Поведение по умолчанию для [обработчика new](../standard-library/new-typedefs.md#new_handler) — выдать объект типа `bad_alloc`. Пустой указатель обозначает обработчик new по умолчанию.

Порядок и непрерывность памяти, выделяемой последовательными вызовами метода `operator new`(**size_t**) не определен, как и начальные значения, хранящиеся в ней.

Вторая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.

Поведение по умолчанию — вернуть `operator new`(`count`) Если эта функция выполняется успешно. В противном случае метод возвращает пустой указатель.

Третья функция вызывается выражением **new** в форме **new** ( *args*) T. Здесь *args* состоит из одного указателя на объект. Это может быть полезно для создания объекта по известному адресу. Функция возвращает *ptr*.

Для освобождения памяти, выделенной **оператор new**, вызовите [оператор delete](../standard-library/new-operators.md#op_delete).

Сведения о выводе или запрещающий поведение нового, см. в разделе [новых и удаленных операторах](../cpp/new-and-delete-operators.md).

### <a name="example"></a>Пример

```cpp
// new_op_new.cpp
// compile with: /EHsc
#include<new>
#include<iostream>

using namespace std;

class MyClass
{
public:
   MyClass( )
   {
      cout << "Construction MyClass." << this << endl;
   };

   ~MyClass( )
   {
      imember = 0; cout << "Destructing MyClass." << this << endl;
   };
   int imember;
};

int main( )
{
   // The first form of new delete
   MyClass* fPtr = new MyClass;
   delete fPtr;

   // The second form of new delete
   MyClass* fPtr2 = new( nothrow ) MyClass;
   delete fPtr2;

   // The third form of new delete
   char x[sizeof( MyClass )];
   MyClass* fPtr3 = new( &x[0] ) MyClass;
   fPtr3 -> ~MyClass();
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;
}
```

## <a name="op_new_arr"></a> оператор new]

Функция выделения, вызываемая выражением new для выделения памяти для массива объектов.

```cpp
void* operator new[](std::size_t count) throw(std::bad_alloc);
void* operator new[](std::size_t count, const std::nothrow_t&) throw();
void* operator new[](std::size_t count, void* ptr) throw();
```

### <a name="parameters"></a>Параметры

*число*\
Число байт памяти, которые нужно выделить для объекта-массива.

*PTR*\
Возвращаемый указатель.

### <a name="return-value"></a>Возвращаемое значение

Указатель на адрес младшего байта выделенной памяти. Или *ptr*.

### <a name="remarks"></a>Примечания

Первая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого или меньшего размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — так же, как [оператор new](../standard-library/new-operators.md#op_new)(**size_t**). Поведение по умолчанию — вернуть `operator new`( `count`).

Вторая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Поведение по умолчанию — вернуть **оператор New**(`count`) Если эта функция выполняется успешно. В противном случае метод возвращает пустой указатель.

Третья функция вызывается выражением `new[]` в форме **new** ( *args*) **T**[ **N**]. Здесь *args* — указатель на единичный объект. Функция возвращает `ptr`.

Для освобождения памяти, выделенной `operator new[]`, вызовите [оператор delete&#91;&#93;](../standard-library/new-operators.md#op_delete_arr).

Для информации о поведении new с выдачей исключений и без выдачи исключений см. раздел [Операторы new и delete](../cpp/new-and-delete-operators.md).

### <a name="example"></a>Пример

```cpp
// new_op_alloc.cpp
// compile with: /EHsc
#include <new>
#include <iostream>

using namespace std;

class MyClass {
public:
   MyClass() {
      cout << "Construction MyClass." << this << endl;
   };

   ~MyClass() {
      imember = 0; cout << "Destructing MyClass." << this << endl;
      };
   int imember;
};

int main() {
   // The first form of new delete
   MyClass* fPtr = new MyClass[2];
   delete[ ] fPtr;

   // The second form of new delete
   char x[2 * sizeof( MyClass ) + sizeof(int)];

   MyClass* fPtr2 = new( &x[0] ) MyClass[2];
   fPtr2[1].~MyClass();
   fPtr2[0].~MyClass();
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;

   // The third form of new delete
   MyClass* fPtr3 = new( nothrow ) MyClass[2];
   delete[ ] fPtr3;
}
```
