---
title: '&lt;новые операторы&gt; и перечисления'
ms.date: 11/04/2016
f1_keywords:
- new/std::operator delete
- new/std::operator new
ms.assetid: d1af4b56-9a95-4c65-ab01-bf43e982c7bd
ms.openlocfilehash: a3fd5b825fe1eaf3a07d9d001f03b9d0c64ffa31
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78854952"
---
# <a name="ltnewgt-operators-and-enums"></a>&lt;новые операторы&gt; и перечисления

## <a name="op_align_val_t"></a>Перечисление align_val_t

```cpp
enum class align_val_t : size_t {};
```

## <a name="op_delete"></a>оператор DELETE

Функция, вызываемая с помощью выражения DELETE для отмены выделения хранилища для отдельных объектов.

```cpp
void operator delete(void* ptr) throw();
void operator delete(void *, void*) throw();
void operator delete(void* ptr, const std::nothrow_t&) throw();
```

### <a name="parameters"></a>Параметры

\ *ptr*
Указатель, значение которого при удалении устанавливается в недействительное.

### <a name="remarks"></a>Remarks

Первая функция вызывается выражением DELETE для визуализации значения *ptr* invalid. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принять значение типа *ptr* , которое равно null или было возвращено предыдущим вызовом [оператора New](../standard-library/new-operators.md#op_new)(**size_t**).

Поведение по умолчанию для значения NULL типа *ptr* — не выполнять никаких действий. Любое другое значение *типа PTR* должно быть возвращено ранее с помощью вызова, как описано выше. Поведение по умолчанию для такого значения *, не* равного null, — это освобождение хранилища, выделенного предыдущим вызовом. Он не указывается при условии, что часть условий или все освобожденное хранилище выделены последующим вызовом `operator new`(**size_t**), или на любой из `calloc`( **size_t**), `malloc`( **size_t**) или `realloc`( **void** <strong>\*</strong>, **size_t**).

Вторая функция вызывается помещением выражения delete, соответствующего новому выражению, в форме **new**( **std::size_t**). Она ничего не делает.

Третья функция вызывается помещением выражения delete, соответствующего новому выражению, в форме **new**( **std::size_t**, **conststd::nothrow_t&** ). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение: принимать значение `ptr` — null или результат возврата предыдущего вызова `operator new`( **size_t**). Поведение по умолчанию — вычислить **Удаление**(`ptr`).

### <a name="example"></a>Пример

Пример использования **оператора delete**см. в разделе [оператор New](../standard-library/new-operators.md#op_new) .

## <a name="op_delete_arr"></a>Оператор delete []

Функция, вызываемая с помощью выражения delete для отмены выделения хранилища для массива объектов.

```cpp
void operator delete[](void* ptr) throw();
void operator delete[](void *, void*) throw();
void operator delete[](void* ptr, const std::nothrow_t&) throw();
```

### <a name="parameters"></a>Параметры

\ *ptr*
Указатель, значение которого при удалении устанавливается в недействительное.

### <a name="remarks"></a>Remarks

Первая функция вызывается выражением `delete[]` для отображения значения *ptr* недопустимо. Это заменяемая функция, так как в программе можно определить функцию с сигнатурой этой функции, которая заменит версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принять значение типа *ptr* , которое равно null или было возвращено предыдущим вызовом [оператора New&#91;](../standard-library/new-operators.md#op_new_arr)(**size_t**). Поведение по умолчанию для значения NULL типа *ptr* — не выполнять никаких действий. Любое другое значение *типа PTR* должно быть возвращено ранее с помощью вызова, как описано выше. Поведение по умолчанию для такого значения типа *ptr* , отличное от NULL, — это освобождение хранилища, выделенного предыдущим вызовом. Он не указывается при условии, что часть условий или все освобожденное хранилище выделены последующим вызовом [оператора New](../standard-library/new-operators.md#op_new)(**size_t**) или любого `calloc`(**size_t**), `malloc`(**size_t**) или `realloc`( **void** <strong>\*</strong>, **size_t**).

Вторая функция вызывается выражением `delete[]` размещения, соответствующим `new[]` выражению формы `new[]`(**std:: size_t**). Она ничего не делает.

Третья функция вызывается помещением выражения delete, соответствующего выражению `new[]` в форме `new[]`( **std::size_t**, **const std::nothrow_t&** ). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принять значение типа *ptr* , которое равно null или было возвращено предыдущим вызовом оператора `new[]`(**size_t**). Поведение по умолчанию — вычислить `delete[]`( `ptr`).

### <a name="example"></a>Пример

См. раздел [Оператор new&#91;&#93;](../standard-library/new-operators.md#op_new_arr) с примерами использования `operator delete[]`.

## <a name="op_new"></a>Оператор New

Функция вызывается выражением new для выделения памяти для отдельных объектов.

```cpp
void* operator new(std::size_t count) throw(bad_alloc);
void* operator new(std::size_t count, const std::nothrow_t&) throw();
void* operator new(std::size_t count, void* ptr) throw();
```

### <a name="parameters"></a>Параметры

*количество*\
Количество байт памяти для выделения.

\ *ptr*
Возвращаемый указатель.

### <a name="return-value"></a>Возвращаемое значение

Указатель на адрес младшего байта выделенной памяти. Или *ptr*.

### <a name="remarks"></a>Remarks

Первая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.

Требуемое поведение — вернуть указатель, отличный от null, только если память может быть выделена, как это запрошено. Каждое такое выделение выдает указатель на память, которая не пересекается ни с одной другой выделенной памятью. Порядок и непрерывность памяти, выделяемой последовательными вызовами, не уточняется. Начальное сохраненное значение не уточняется. Возвращаемый указатель указывает на начало (адрес младшего байта) выделенной памяти. Если счетчик равен нулю, возвращенное значение не будет равно ни одному другому значению, возвращенному функцией.

Поведение по умолчанию — выполнить цикл. Внутри цикла функция сначала пытается выделить запрошенную память. Будут ли эти попытки включать вызов `malloc`( **size_t**), не уточняется. Если попытка успешна, функция возвращает указатель на выделенную память. В противном случае функция вызывает назначенный [обработчик new](../standard-library/new-typedefs.md#new_handler). Если вызванная функция возвращает управление, цикл повторяется. Цикл прекращается, когда попытка выделения запрошенной памяти завершилась успехом или если вызванная функция не вернула управление.

Требуемое поведение обработчика new — выполнить одну из следующих операций:

- Сделать больше памяти, доступной для выделения, и завершить выполнение.

- Вызовите команду **Abort** или **Exit**(`int`).

- Выдать объект типа **bad_alloc.**

Поведение по умолчанию для [обработчика new](../standard-library/new-typedefs.md#new_handler) — выдать объект типа `bad_alloc`. Пустой указатель обозначает обработчик new по умолчанию.

Порядок и непрерывность хранилища, выделенные последовательными вызовами `operator new`(**size_t**), не заданы, как и начальные значения, хранящиеся там.

Вторая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.

Поведение по умолчанию — возврат `operator new`(`count`), если эта функция выполнена. В противном случае метод возвращает пустой указатель.

Третья функция вызывается выражением **new** в форме **new** ( *args*) T. Здесь *args* состоит из одного указателя на объект. Это может быть полезно для создания объекта по известному адресу. Функция возвращает *ptr*.

Чтобы освободить хранилище, выделенное **оператором new**, вызовите [оператор DELETE](../standard-library/new-operators.md#op_delete).

Сведения о вызове или невызове нового поведения New см. [в разделе операторы new и DELETE](../cpp/new-and-delete-operators.md).

### <a name="example"></a>Пример

```cpp
// new_op_new.cpp
// compile with: /EHsc
#include<new>
#include<iostream>

using namespace std;

class MyClass
{
public:
   MyClass( )
   {
      cout << "Construction MyClass." << this << endl;
   };

   ~MyClass( )
   {
      imember = 0; cout << "Destructing MyClass." << this << endl;
   };
   int imember;
};

int main( )
{
   // The first form of new delete
   MyClass* fPtr = new MyClass;
   delete fPtr;

   // The second form of new delete
   MyClass* fPtr2 = new( nothrow ) MyClass;
   delete fPtr2;

   // The third form of new delete
   char x[sizeof( MyClass )];
   MyClass* fPtr3 = new( &x[0] ) MyClass;
   fPtr3 -> ~MyClass();
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;
}
```

## <a name="op_new_arr"></a>оператор new []

Функция выделения, вызываемая выражением new для выделения памяти для массива объектов.

```cpp
void* operator new[](std::size_t count) throw(std::bad_alloc);
void* operator new[](std::size_t count, const std::nothrow_t&) throw();
void* operator new[](std::size_t count, void* ptr) throw();
```

### <a name="parameters"></a>Параметры

*количество*\
Число байт памяти, которые нужно выделить для объекта-массива.

\ *ptr*
Возвращаемый указатель.

### <a name="return-value"></a>Возвращаемое значение

Указатель на адрес младшего байта выделенной памяти. Или *ptr*.

### <a name="remarks"></a>Remarks

Первая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого или меньшего размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение аналогично поведению [оператора New](../standard-library/new-operators.md#op_new)(**size_t**). Поведение по умолчанию — вернуть `operator new`( `count`).

Вторая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Поведение по умолчанию — возврат **операторнев**(`count`), если эта функция выполнена. В противном случае метод возвращает пустой указатель.

Третья функция вызывается выражением `new[]` в форме **new** ( *args*) **T**[ **N**]. Здесь *args* — указатель на единичный объект. Функция возвращает `ptr`.

Для освобождения памяти, выделенной `operator new[]`, вызовите [оператор delete&#91;&#93;](../standard-library/new-operators.md#op_delete_arr).

Для информации о поведении new с выдачей исключений и без выдачи исключений см. раздел [Операторы new и delete](../cpp/new-and-delete-operators.md).

### <a name="example"></a>Пример

```cpp
// new_op_alloc.cpp
// compile with: /EHsc
#include <new>
#include <iostream>

using namespace std;

class MyClass {
public:
   MyClass() {
      cout << "Construction MyClass." << this << endl;
   };

   ~MyClass() {
      imember = 0; cout << "Destructing MyClass." << this << endl;
      };
   int imember;
};

int main() {
   // The first form of new delete
   MyClass* fPtr = new MyClass[2];
   delete[ ] fPtr;

   // The second form of new delete
   char x[2 * sizeof( MyClass ) + sizeof(int)];

   MyClass* fPtr2 = new( &x[0] ) MyClass[2];
   fPtr2[1].~MyClass();
   fPtr2[0].~MyClass();
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;

   // The third form of new delete
   MyClass* fPtr3 = new( nothrow ) MyClass[2];
   delete[ ] fPtr3;
}
```
