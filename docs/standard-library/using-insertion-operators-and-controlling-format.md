---
title: Использование операторов вставки и управление форматом
ms.date: 11/04/2016
helpviewer_keywords:
- insertion operators
ms.assetid: cdefe986-6548-4cd1-8a67-b431d7d36a1c
ms.openlocfilehash: 2cf399501c0eab32e8bee80dfcb98d870c0193cb
ms.sourcegitcommit: 0dcab746c49f13946b0a7317fc9769130969e76d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/24/2019
ms.locfileid: "68458028"
---
# <a name="using-insertion-operators-and-controlling-format"></a>Использование операторов вставки и управление форматом

В этой статье описывается, как управлять форматом и как создавать операторы вставки для собственных классов. Оператор вставки ( **<<** ), который изначально включен во все стандартные типы данных C++, отправляет байты в объект потока вывода. Операторы вставки работают с предопределенными "манипуляторами" — элементами, которые изменяют формат целочисленных аргументов, заданный по умолчанию.

Форматом можно управлять с помощью следующих параметров:

- [Ширина выходных данных](#vclrfoutputwidthanchor3)

- [Выравнивание](#vclrfalignmentanchor4)

- [Точность](#vclrfprecisionanchor5)

- [Основание системы счисления](#vclrfradixanchor6)

## <a name="vclrfoutputwidthanchor3"></a> Ширина выходных данных

Чтобы выстроить выходные данные, необходимо указать ширину выходных данных для каждого элемента, `setw` поместив манипулятор в поток или `width` вызвав функцию члена. В этом примере выравниваются по правому краю значения в столбце шириной по крайней мере 10 символов:

```cpp
// output_width.cpp
// compile with: /EHsc
#include <iostream>
using namespace std;

int main( )
{
   double values[] = { 1.23, 35.36, 653.7, 4358.24 };
   for( int i = 0; i < 4; i++ )
   {
      cout.width(10);
      cout << values[i] << '\n';
   }
}
```

```Output
      1.23
     35.36
     653.7
   4358.24
```

Начальные пробелы добавляются в любое значение шириной менее 10 символов.

Чтобы заполнить поле, используйте `fill` функцию-член, которая задает значение символа заполнения для полей с заданной шириной. По умолчанию используется пробел. Чтобы заполнить столбец чисел звездочками, измените предыдущий цикл **for** следующим образом:

```cpp
for (int i = 0; i <4; i++)
{
    cout.width(10);
    cout.fill('*');
    cout << values[i] << endl;
}
```

Манипулятор `endl` заменяет символ перевода строки (`'\n'`). Вывод выглядит следующим образом.

```Output
******1.23
*****35.36
*****653.7
***4358.24
```

Чтобы указать ширину элементов выходных данных в той же строке, используйте манипулятор `setw`:

```cpp
// setw.cpp
// compile with: /EHsc
#include <iostream>
#include <iomanip>
using namespace std;

int main( )
{
   double values[] = { 1.23, 35.36, 653.7, 4358.24 };
   char *names[] = { "Zoot", "Jimmy", "Al", "Stan" };
   for( int i = 0; i < 4; i++ )
      cout << setw( 7 )  << names[i]
           << setw( 10 ) << values[i] << endl;
}
```

\<Функция- `width` член объявляется в iostream >. Если вы используете `setw` или любой другой манипулятор с аргументами, необходимо включить \<iomanip>. В выходных данных строки выводятся в поле шириной 6, а целые числа — в поле шириной 10:

```Output
   Zoot      1.23
  Jimmy     35.36
     Al     653.7
   Stan   4358.24
```

Оба `setw`значения не усекаются.`width` Если форматированные выходные данные превышают ширину, значения выводятся полностью в соответствии с заданной в потоке точностью. `setw` И`width` влияют только на следующее поле. Для ширины поля восстанавливается значение по умолчанию (необходимая ширина) после вывода одного поля. Другие параметры форматирования потока остаются в силе, пока не будут изменены.

## <a name="vclrfalignmentanchor4"></a> Выравнивание

По умолчанию выравнивание текста в потоках вывода задано по правому краю. Чтобы выровнять имена по левому краю, а числа — по правому краю, измените цикл **for** в предыдущем примере следующим образом:

```cpp
for (int i = 0; i <4; i++)
    cout << setiosflags(ios::left)
         << setw(6) << names[i]
         << resetiosflags(ios::left)
         << setw(10) << values[i] << endl;
```

Вывод выглядит следующим образом.

```Output
Zoot        1.23
Jimmy      35.36
Al         653.7
Stan     4358.24
```

Флаг выравнивания по левому краю устанавливается с помощью манипулятора [setiosflags](../standard-library/iomanip-functions.md#setiosflags) с перечислителем `left`. Этот перечислитель определен в классе [ios](../standard-library/basic-ios-class.md), поэтому его ссылка должна содержать префикс **ios::** . Манипулятор [resetiosflags](../standard-library/iomanip-functions.md#resetiosflags) снимает флаг выравнивания по левому краю. В отличие `width` от `setw`и, результат `setiosflags` и `resetiosflags` является постоянным.

## <a name="vclrfprecisionanchor5"></a> Точность

По умолчанию для чисел с плавающей запятой задана точность шесть. Например, число 3466,9768 выводится как 3466,98. Чтобы изменить способ вывода этого значения, используйте манипулятор [setprecision](../standard-library/iomanip-functions.md#setprecision). Манипулятор имеет два флага: [fixed](../standard-library/ios-functions.md#fixed) и [scientific](../standard-library/ios-functions.md#scientific). Если указан флаг [fixed](../standard-library/ios-functions.md#fixed), число выводится как 3466,976800. Если `scientific` задано значение, оно распечатывается как 3.4669773 + 003.

Чтобы отобразить числа с плавающей запятой, приведенные в разделе [Выравнивание](#vclrfalignmentanchor4), с одной значащей цифрой, измените цикл **for** следующим образом:

```cpp
for (int i = 0; i <4; i++)
    cout << setiosflags(ios::left)
         << setw(6)
         << names[i]
         << resetiosflags(ios::left)
         << setw(10)
         << setprecision(1)
         << values[i]
         << endl;
```

Программа выведет этот список:

```Output
Zoot          1
Jimmy     4e+01
Al        7e+02
Stan      4e+03
```

Чтобы исключить экспоненциальное представление чисел, вставьте перед циклом **for** следующий оператор:

```cpp
cout << setiosflags(ios::fixed);
```

С фиксированной нотацией программа выводит числа с одной цифрой после десятичной запятой.

```Output
Zoot         1.2
Jimmy       35.4
Al         653.7
Stan      4358.2
```

При изменении `ios::fixed` флага на `ios::scientific`выводится следующее:

```cpp
Zoot    1.2e+00
Jimmy   3.5e+01
Al      6.5e+02
Stan    4.4e+03
```

В этом случае программа также выводит числа с одной цифрой после десятичной запятой. Если задан параметр `ios::scientific`или, то значение точности определяет количество цифр после десятичной запятой. `ios::fixed` Если не установлен ни один из флагов, значение точности определяет общее количество значащих цифр. Манипулятор `resetiosflags` снимает эти флаги.

## <a name="vclrfradixanchor6"></a> Основание системы счисления

Манипуляторы `oct` ,и`hex` устанавливают основание системы счисления по умолчанию для входных и выходных данных. `dec` Например, при вставке `hex` манипулятора в поток вывода объект правильно преобразует внутреннее представление целых чисел в шестнадцатеричный формат выходных данных. Числа отображаются с цифрами от a до f в нижнем регистре, если не установлен флаг [uppercase](../standard-library/ios-functions.md#uppercase) (по умолчанию). В противном случае они отображаются в верхнем регистре. Основание системы счисления по `dec` умолчанию — (десятичное число).

## <a name="quoted-strings-c14"></a>Строки в кавычках (C++ 14)

Если вы вставляете строку в поток, вы можете легко извлечь ту же строку обратно с помощью вызова функции-члена stringstream::str(). Однако, если вы хотите использовать оператор извлечения для вставки потока в новую строку позднее, вы можете получить непредвиденный результат, потому что оператор >> по умолчанию останавливается, когда встречает первый символ пробела.

```cpp
std::stringstream ss;
std::string inserted = "This is a sentence.";
std::string extracted;

ss << inserted;
ss >> extracted;

std::cout << inserted;     //  This is a sentence.
std::cout << extracted;    //  This
```

Такое поведение можно решить вручную, но чтобы сделать строку более удобной, c++ 14 добавит `std::quoted` потоковый манипулятор в \<iomanip >. При вставке `quoted()` окружает строку разделителями (по умолчанию — двойные кавычки «"»), а при извлечении манипулирует потоком так, чтобы извлекать все символы, пока не будет обнаружен конечный разделитель. Все вложенные кавычки экранируются с помощью escape-символа (по умолчанию — '\\\\').

Разделители существуют только в объекте потока; они отсутствуют в извлеченной строке, но представлены в строке, возвращаемой функцией [basic_stringstream:: str](../standard-library/basic-stringstream-class.md#str).

Обработка пробелов операциями вставки и извлечения не зависит от способа представления строки в коде, поэтому заключение оператора в кавычки будет полезно в любом случае, независимо от того, является входная строка необработанным строковым литералом или обычной строкой. Входная строка независимо от ее формата может иметь вложенные кавычки, разрывы строк, символы табуляции и т. д. Все они сохраняются с помощью манипулятора quoted().

Дополнительные сведения и полные примеры кода см. [в](../standard-library/iomanip-functions.md#quoted)разделе с кавычками.

## <a name="see-also"></a>См. также

[Потоки вывода](../standard-library/output-streams.md)
