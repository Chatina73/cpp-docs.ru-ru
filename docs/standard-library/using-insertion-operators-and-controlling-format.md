---
description: 'Дополнительные сведения: использование операторов вставки и Управление форматом'
title: Использование операторов вставки и управление форматом
ms.date: 11/04/2016
helpviewer_keywords:
- insertion operators
ms.assetid: cdefe986-6548-4cd1-8a67-b431d7d36a1c
ms.openlocfilehash: 1e5098beb7ff3c83439780c2dc3f908f7fec946a
ms.sourcegitcommit: a89eac9acdbd54a181e3bd5d5bc71a3ef3c1abca
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2021
ms.locfileid: "106506004"
---
# <a name="using-insertion-operators-and-controlling-format"></a>Использование операторов вставки и управление форматом

В этой статье описывается, как управлять форматом и как создавать операторы вставки для собственных классов. Оператор вставки ( **`<<`** ), который предпрограммируется для всех стандартных типов данных C++, отправляет байты в объект потока вывода. Операторы вставки работают с предопределенными "манипуляторами" — элементами, которые изменяют формат целочисленных аргументов, заданный по умолчанию.

Форматом можно управлять с помощью следующих параметров:

- [Ширина выходных данных](#vclrfoutputwidthanchor3)

- [Выравнивание](#vclrfalignmentanchor4)

- [Точность](#vclrfprecisionanchor5)

- [Основание системы счисления](#vclrfradixanchor6)

## <a name="output-width"></a><a name="vclrfoutputwidthanchor3"></a> Ширина выходных данных

Чтобы выстроить выходные данные, необходимо указать ширину выходных данных для каждого элемента, поместив `setw` манипулятор в поток или вызвав `width` функцию члена. В этом примере выравниваются по правому краю значения в столбце шириной по крайней мере 10 символов:

```cpp
// output_width.cpp
// compile with: /EHsc
#include <iostream>
using namespace std;

int main( )
{
   double values[] = { 1.23, 35.36, 653.7, 4358.24 };
   for( int i = 0; i < 4; i++ )
   {
      cout.width(10);
      cout << values[i] << '\n';
   }
}
```

```Output
      1.23
     35.36
     653.7
   4358.24
```

Начальные пробелы добавляются в любое значение шириной менее 10 символов.

Чтобы заполнить поле, используйте функцию- `fill` член, которая задает значение символа заполнения для полей с заданной шириной. По умолчанию используется пробел. Чтобы заполнить столбец цифр звездочками, измените предыдущий **`for`** цикл следующим образом:

```cpp
for (int i = 0; i <4; i++)
{
    cout.width(10);
    cout.fill('*');
    cout << values[i] << endl;
}
```

Манипулятор `endl` заменяет символ перевода строки (`'\n'`). Выходные данные выглядят следующим образом:

```Output
******1.23
*****35.36
*****653.7
***4358.24
```

Чтобы указать ширину элементов выходных данных в той же строке, используйте манипулятор `setw`:

```cpp
// setw.cpp
// compile with: /EHsc
#include <iostream>
#include <iomanip>
using namespace std;

int main( )
{
   double values[] = { 1.23, 35.36, 653.7, 4358.24 };
   char *names[] = { "Zoot", "Jimmy", "Al", "Stan" };
   for( int i = 0; i < 4; i++ )
      cout << setw( 7 )  << names[i]
           << setw( 10 ) << values[i] << endl;
}
```

`width`Функция-член объявлена в `<iostream>` . При использовании `setw` или любых других манипуляторов с аргументами необходимо включить `<iomanip>` . В выходных данных строки выводятся в поле шириной 6, а целые числа — в поле шириной 10:

```Output
   Zoot      1.23
  Jimmy     35.36
     Al     653.7
   Stan   4358.24
```

Оба `setw` `width` значения не усекаются. Если форматированные выходные данные превышают ширину, значения выводятся полностью в соответствии с заданной в потоке точностью. `setw`И `width` влияют только на следующее поле. Для ширины поля восстанавливается значение по умолчанию (необходимая ширина) после вывода одного поля. Другие параметры форматирования потока остаются в силе, пока не будут изменены.

## <a name="alignment"></a><a name="vclrfalignmentanchor4"></a> Выравнивание

По умолчанию выравнивание текста в потоках вывода задано по правому краю. Чтобы выровняйте имена по левому краю в предыдущем примере и выровняйте числа по правому краю, замените **`for`** цикл следующим образом:

```cpp
for (int i = 0; i <4; i++)
    cout << setiosflags(ios::left)
         << setw(6) << names[i]
         << resetiosflags(ios::left)
         << setw(10) << values[i] << endl;
```

Выходные данные выглядят следующим образом:

```Output
Zoot        1.23
Jimmy      35.36
Al         653.7
Stan     4358.24
```

Флаг left-aligned устанавливается с помощью [`setiosflags`](../standard-library/iomanip-functions.md#setiosflags) манипулятора с `left` перечислителем. Этот перечислитель определен в [`ios`](../standard-library/basic-ios-class.md) классе, поэтому его ссылка должна включать **`ios::`** префикс. [`resetiosflags`](../standard-library/iomanip-functions.md#resetiosflags)Манипулятор отключает флаг left-aligned. В отличие от `width` и `setw` , результат `setiosflags` и `resetiosflags` является постоянным.

## <a name="precision"></a><a name="vclrfprecisionanchor5"></a> Обеспечивают

По умолчанию для чисел с плавающей запятой задана точность шесть. Например, число 3466,9768 выводится как 3466,98. Чтобы изменить способ печати этого значения, используйте [`setprecision`](../standard-library/iomanip-functions.md#setprecision) манипулятор. Манипулятор имеет два флага: [`fixed`](../standard-library/ios-functions.md#fixed) и [`scientific`](../standard-library/ios-functions.md#scientific) . Если [`fixed`](../standard-library/ios-functions.md#fixed) задано значение, число выводится как 3466,976800. Если `scientific` задано значение, оно распечатывается как 3.4669773 + 003.

Чтобы отобразить числа с плавающей запятой, отображаемые при [выравнивании](#vclrfalignmentanchor4) , с одной значащий цифрой, замените **`for`** цикл следующим образом:

```cpp
for (int i = 0; i <4; i++)
    cout << setiosflags(ios::left)
         << setw(6)
         << names[i]
         << resetiosflags(ios::left)
         << setw(10)
         << setprecision(1)
         << values[i]
         << endl;
```

Программа выведет этот список:

```Output
Zoot          1
Jimmy     4e+01
Al        7e+02
Stan      4e+03
```

Чтобы исключить экспоненциальное представление, вставьте эту инструкцию перед **`for`** циклом:

```cpp
cout << setiosflags(ios::fixed);
```

С фиксированной нотацией программа выводит числа с одной цифрой после десятичной запятой.

```Output
Zoot         1.2
Jimmy       35.4
Al         653.7
Stan      4358.2
```

При изменении `ios::fixed` флага на `ios::scientific` выводится следующее:

```cpp
Zoot    1.2e+00
Jimmy   3.5e+01
Al      6.5e+02
Stan    4.4e+03
```

В этом случае программа также выводит числа с одной цифрой после десятичной запятой. Если `ios::fixed` задан параметр или `ios::scientific` , то значение точности определяет количество цифр после десятичной запятой. Если не установлен ни один из флагов, значение точности определяет общее количество значащих цифр. Манипулятор `resetiosflags` снимает эти флаги.

## <a name="radix"></a><a name="vclrfradixanchor6"></a> Основание системы счисления

`dec` `oct` Манипуляторы, и `hex` устанавливают основание системы счисления по умолчанию для входных и выходных данных. Например, при вставке `hex` манипулятора в поток вывода объект правильно преобразует внутреннее представление целых чисел в шестнадцатеричный формат выходных данных. Числа отображаются с цифрами от a до f в нижнем регистре, если [`uppercase`](../standard-library/ios-functions.md#uppercase) флаг снят (по умолчанию); в противном случае они отображаются в верхнем регистре. Основание системы счисления по умолчанию — `dec` (десятичное число).

## <a name="quoted-strings-c14"></a>Строки в кавычках (C++ 14)

При вставке строки в поток можно легко получить ту же строку обратно, вызвав `stringstream::str()` функцию-член. Однако если вы хотите использовать оператор извлечения для вставки потока в новую строку позже, возможно, вы получите непредвиденный результат, так как `>>` оператор по умолчанию будет останавливаться при обнаружении первого символа пробела.

```cpp
std::stringstream ss;
std::string inserted = "This is a sentence.";
std::string extracted;

ss << inserted;
ss >> extracted;

std::cout << inserted;     //  This is a sentence.
std::cout << extracted;    //  This
```

Эту проблему можно устранить вручную, но чтобы сделать обход строки более удобным, C++ 14 добавляет манипулятор потока `std::quoted` в `<iomanip>`. При вставке `quoted()` окружает строку разделителями (по умолчанию — двойные кавычки «"»), а при извлечении манипулирует потоком так, чтобы извлекать все символы, пока не будет обнаружен конечный разделитель. Все вложенные кавычки экранируются с помощью escape-символа (по умолчанию — '\\\\').

Разделители существуют только в объекте потока; они отсутствуют в извлеченной строке, но представлены в строке, возвращаемой методом [`basic_stringstream::str`](../standard-library/basic-stringstream-class.md#str) .

Обработка пробелов операциями вставки и извлечения не зависит от способа представления строки в коде, поэтому заключение оператора в кавычки будет полезно в любом случае, независимо от того, является входная строка необработанным строковым литералом или обычной строкой. Входная строка любого формата может содержать внедренные кавычки, разрывы строк, табуляции и т. д., и все они будут сохранены `quoted()` манипулятором.

Дополнительные сведения и полные примеры кода см. в разделе [`quoted`](../standard-library/iomanip-functions.md#quoted) .

## <a name="see-also"></a>См. также раздел

[Выходные потоки](../standard-library/output-streams.md)
