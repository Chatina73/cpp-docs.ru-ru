---
title: Класс enable_if
ms.date: 11/04/2016
f1_keywords:
- type_traits/std::enable_if
helpviewer_keywords:
- enable_if class
- enable_if
ms.assetid: c6b8d41c-a18f-4e30-a39e-b3aa0e8fd926
ms.openlocfilehash: 6e6b8a286dca8c451e6920e7f25f07829d3b453f
ms.sourcegitcommit: 0dcab746c49f13946b0a7317fc9769130969e76d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/24/2019
ms.locfileid: "68454215"
---
# <a name="enableif-class"></a>Класс enable_if

Условно создает экземпляр типа для разрешения перегрузки SFINAE. Вложенное typedef `enable_if<Condition,Type>::type` существует — и является синонимом для `Type`— только в том случае `Condition` , если имеет **значение true**.

## <a name="syntax"></a>Синтаксис

```cpp
template <bool B, class T = void>
struct enable_if;
```

### <a name="parameters"></a>Параметры

*&* \
Значение, определяющее наличие результирующего типа.

*T*\
Тип для создания экземпляра, если *B* имеет значение true.

## <a name="remarks"></a>Примечания

Если *B* имеет значение true `enable_if<B, T>` , то имеет вложенное определение typedef с именем Type, которое является синонимом для *T*.

Если *B* имеет значение false `enable_if<B, T>` , не имеет вложенного typedef с именем Type.

Предоставляется следующий шаблон псевдонима.

```cpp
template <bool B, class T = void>
using enable_if_t = typename enable_if<B,T>::type;
```

В C++ ошибка замены параметров шаблона не является ошибкой — этот факт называют *SFINAE* (неудачная замена не ошибка). Обычно `enable_if` используется для удаления кандидатов из разрешения перегрузки, т. е. функция отбраковывает набор перегрузки, чтобы одно определение было отброшено в пользу другого. Это соответствует поведению SFINAE. Дополнительные сведения об SFINAE см. в статье [Ошибка замены не ошибка](https://go.microsoft.com/fwlink/p/?linkid=394798) на веб-сайте Википедии.

Вот 4 примера сценариев.

- Сценарий 1. Заключение типа возвращаемого значения функции:

```cpp
    template <your_stuff>
typename enable_if<your_condition, your_return_type>::type
    yourfunction(args) {// ...
}
// The alias template makes it more concise:
    template <your_stuff>
enable_if_t<your_condition, your_return_type>
yourfunction(args) {// ...
}
```

- Сценарий 2. Добавление параметра функции, имеющего аргумент по умолчанию:

```cpp
    template <your_stuff>
your_return_type_if_present
    yourfunction(args, enable_if_t<your condition, FOO> = BAR) {// ...
}
```

- Сценарий 3. Добавление параметра шаблона, имеющего аргумент по умолчанию:

```cpp
    template <your_stuff, typename Dummy = enable_if_t<your_condition>>
rest_of_function_declaration_goes_here
```

- Сценарий 4. Если функция имеет аргумент, не являющийся шаблоном, можно обернуть его тип:

```cpp
    template <typename T>
void your_function(const T& t,
    enable_if_t<is_something<T>::value, const string&>
s) {// ...
}
```

Сценарий 1 не применяется к конструкторам и операторам преобразования, так как у них нет возвращаемых типов.

В сценарии 2 параметр остается без имени. Можно использовать `::type Dummy = BAR`, но имя `Dummy` не играет роли, поэтому указание имени, вероятно, вызовет предупреждение о параметре без ссылки. Необходимо выбрать тип параметра функции `FOO` и аргумент по умолчанию `BAR`.  Можно сказать,  что int `0`и, но затем пользователи кода случайно передавали функции дополнительное целое число, которое будет пропущено. Вместо `void **` этого рекомендуется использовать и либо `0` OR, либо **nullptr** , так как почти ничего не преобразуется в `void **`:

```cpp
template <your_stuff>
your_return_type_if_present
yourfunction(args, typename enable_if<your_condition, void **>::type = nullptr) {// ...
}
```

Сценарий 2 также подходит для обычных конструкторов.  Но он не работает с операторами преобразования, так как они не могут принимать дополнительные параметры.  Он также не подходит для конструкторов [с переменным числом аргументов](../cpp/ellipses-and-variadic-templates.md), так как из-за добавления параметров пакет параметров функции становится невыводимым контекстом, что противоречит цели `enable_if`.

В сценарии 3 используется имя `Dummy`, но это необязательно. Подойдет и просто "`typename = typename`", но, если вы считаете, что это выглядит странно, можно использовать имя-заглушку (только не применяйте имя, которое может использоваться в определении функции). Если не передать тип функции `enable_if`, по умолчанию используется тип void, и это вполне логично, так как `Dummy` не играет никакой роли. Такой метод подходит для всего, в том числе для операторов преобразования и конструкторов с [переменным числом аргументов](../cpp/ellipses-and-variadic-templates.md).

Сценарий 4 работает для конструкторов без возвращаемых типов, что устраняет ограничение упаковки сценария 1.  Однако сценарий 4 применяется только для аргументов функции без шаблонов, которые не всегда доступны.  (При использовании сценария 4 для аргументов функции на основе шаблона устранение аргументов шаблона не работает.)

`enable_if` — это мощное средство, которое может быть опасным при неправильном использовании.  Так как цель функции — удалить кандидаты до разрешения перегрузки, при ее неправильном применении результаты могут быть очень запутанными.  Вот несколько рекомендаций.

- Не используйте `enable_if` для выбора между реализациями во время компиляции. Не пишите одну функцию `enable_if` для `CONDITION` и другую для `!CONDITION`.  Используйте шаблон *отправки тегов*, например, алгоритм может выбирать реализации в зависимости от силы указанных итераторов.

- Не используйте `enable_if` для применения требований.  Если вы хотите проверить параметры шаблонов, но проверка завершается неудачно и вызывает ошибку вместо выбора другой реализации, используйте [static_assert](../cpp/static-assert.md).

- Используйте `enable_if` при наличии набора перегрузок, который делает код неоднозначным.  Чаще всего это происходит в конструкторах с неявным преобразованием.

## <a name="example"></a>Пример

В этом примере объясняется, как функция шаблона стандартной библиотеки C++ [std::make_pair()](../standard-library/utility-functions.md#make_pair) использует `enable_if`.

```cpp
void func(const pair<int, int>&);

void func(const pair<string, string>&);

func(make_pair("foo", "bar"));
```

В этом примере `make_pair("foo", "bar")` возвращает `pair<const char *, const char *>`. Разрешение перегрузок должно определить требуемую функцию `func()`. `pair<A, B>` содержит конструктор с неявным преобразованием из `pair<X, Y>`.  Это не новый элемент, он был представлен в C++98. Однако в C++98/03 сигнатура конструктора с неявным преобразованием всегда существует, даже если это `pair<int, int>(const pair<const char *, const char *>&)`.  Разрешение перегрузки не имеет значения, что попытка создать экземпляр конструктора разворачивает `const char *` ужасно, так как не может неявно преобразовываться в **тип int**; в нем отображаются только сигнатуры, до создания экземпляров определений функций.  Поэтому этот пример кода неоднозначен, так как существуют сигнатуры для преобразования `pair<const char *, const char *>` в `pair<int, int>` и `pair<string, string>`.

В C++11 эта неоднозначность была устранена с помощью `enable_if`, чтобы конструкция `pair<A, B>(const pair<X, Y>&)` существовала **только**, если `const X&` неявно преобразуется в `A`, а `const Y&` неявно преобразуется в `B`.  Это позволяет процессу разрешения перегрузок определить, что `pair<const char *, const char *>` не преобразуется в `pair<int, int>` и что перегрузка, принимающая тип `pair<string, string>`, допустима.

## <a name="requirements"></a>Требования

**Заголовок:** \<type_traits>

**Пространство имен:** std

## <a name="see-also"></a>См. также

[<type_traits>](../standard-library/type-traits.md)
