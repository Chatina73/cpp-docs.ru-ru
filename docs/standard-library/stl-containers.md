---
title: Контейнеры стандартной библиотеки C++
ms.date: 11/04/2016
helpviewer_keywords:
- C++ Standard Library, template class containers
- containers, C++ Standard Library
ms.assetid: 8e915ca1-19ba-4f0d-93c8-e2c3bfd638eb
ms.openlocfilehash: 6077ff76e04e6f078946eed0856723e2a9998f58
ms.sourcegitcommit: 0dcab746c49f13946b0a7317fc9769130969e76d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/24/2019
ms.locfileid: "68449598"
---
# <a name="c-standard-library-containers"></a>Контейнеры стандартной библиотеки C++

Стандартная библиотека предоставляет различные типобезопасные контейнеры для хранения коллекций связанных объектов. Контейнеры — это шаблоны классов. При объявлении переменной контейнера указывается тип элементов, которые будет содержать контейнер. Контейнеры могут создаваться с использованием списков инициализаторов. Они содержат функции-члены для добавления и удаления элементов и выполнения других операций.

Итерация элементов в контейнере и доступ к отдельным элементам осуществляются с помощью [итераторов](../standard-library/iterators.md). Вы можете использовать итераторы явно, с помощью их функций-членов и операторов, а также глобальных функций. Вы можете также использовать их неявно, например с помощью цикла range-for. Итераторы для всех контейнеров стандартной библиотеки C++ имеют общий интерфейс, но каждый контейнер определяет собственные специализированные итераторы.

Контейнеры можно разделить на три категории: последовательные контейнеры, ассоциативные контейнеры и контейнеры-адаптеры.

## <a name="sequence_containers"></a> Последовательные контейнеры

Последовательные контейнеры поддерживают указанный пользователем порядок вставляемых элементов.

Контейнер `vector` ведет себя как массив, но может автоматически увеличиваться по мере необходимости. Он поддерживает прямой доступ и связанное хранение и имеет очень гибкую длину. По этим и многим другим причинам контейнер `vector` является наиболее предпочтительным последовательным контейнером для большинства областей применения. Если вы сомневаетесь в выборе вида последовательного контейнера, начните с использования вектора. Дополнительные сведения см. в разделе [Класс vector](../standard-library/vector-class.md).

Контейнер `array` обладает некоторыми преимуществами контейнера `vector`, однако его длина не обладает такой гибкостью. Дополнительные сведения см. в разделе [Класс array](../standard-library/array-class-stl.md).

Контейнер `deque` (двусторонняя очередь) обеспечивает быструю вставку и удаление в начале и в конце контейнера. Он, как и контейнер `vector`, обладает преимуществами прямого доступа и гибкой длины, но не обеспечивает связанное хранение. Дополнительные сведения см. в разделе [Класс deque](../standard-library/deque-class.md).

Контейнер `list` — это двунаправленный список, который обеспечивает двунаправленный доступ, быструю вставку и удаления в любом месте контейнера, но не поддерживает прямой доступ к элементам контейнера. Дополнительные сведения см. в разделе [Класс list](../standard-library/list-class.md).

Контейнер `forward_list` — однонаправленный список. Это версия контейнера `list` только с доступом в прямом направлении. Дополнительные сведения см. в разделе [Класс forward_list](../standard-library/forward-list-class.md).

## <a name="associative-containers"></a>Ассоциативные контейнеры

В ассоциативных контейнерах элементы вставляются в предварительно определенном порядке — например, с сортировкой по возрастанию. Также доступны неупорядоченные ассоциативные контейнеры. Ассоциативные контейнеры можно объединить в два подмножества: сопоставления (set) и наборы (map).

Контейнер `map`, который иногда называют словарем, состоит из пар "ключ-значение". Ключ используется для упорядочивания последовательности, а значение связано с ключом. Например, `map` может содержать ключи, представляющие каждое уникальное ключевое слово в тексте, и соответствующие значения, которые обозначают количество повторений каждого слова в тексте. `map` — это неупорядоченная версия `unordered_map`. Дополнительные сведения см. в разделах [Класс map](../standard-library/map-class.md) и [Класс unordered_map](../standard-library/unordered-map-class.md).

`set` — это контейнер уникальных элементов, упорядоченных по возрастанию. Каждое его значение также является и ключом. `set` — это неупорядоченная версия `unordered_set`. Дополнительные сведения см. в разделах [Класс set](../standard-library/set-class.md) и [Класс unordered_set](../standard-library/unordered-set-class.md).

Контейнеры `map` и `set` разрешают вставку только одного экземпляра ключа или элемента. Если необходимо включить несколько экземпляров элемента, следует использовать контейнер `multimap` или `multiset`. Неупорядоченные версии этих контейнеров — `unordered_multimap` и `unordered_multiset`. Дополнительные сведения см. в статьях [Класс multimap](../standard-library/multimap-class.md), [Класс unordered_multimap](../standard-library/unordered-multimap-class.md), [Класс multiset](../standard-library/multiset-class.md) и [Класс unordered_multiset](../standard-library/unordered-multiset-class.md).

Упорядоченные контейнеры map и set поддерживают двунаправленные итераторы, а их неупорядоченный аналоги — итераторы с перебором в прямом направлении. Дополнительные сведения см. в разделе [Итераторы](../standard-library/iterators.md).

### <a name="heterogeneous-lookup-in-associative-containers-c14"></a>Разнородный поиск в ассоциативных контейнерах (C++ 14)

Упорядоченные ассоциативные контейнеры (сопоставление, мультиотображение, набор и мультинабор) теперь поддерживают разнородный поиск. Это означает, что вам больше не нужно передавать объект точно такого же типа как ключ или элемент в функциях-членах, таких как `find()` и `lower_bound()`. Вы можете передать объект любого типа, для которого определен перегруженный `operator<`, позволяющий выполнять сравнение с типом ключа.

Разнородный поиск включается дополнительно, когда указывается средство сравнения "ромбовидный функтор" `std::less<>` или `std::greater<>` при объявлении переменной контейнера, как показано ниже:

```cpp
std::set<BigObject, std::less<>> myNewSet;
```

Если используется средство сравнения, заданное по умолчанию, контейнер ведет себя точно так же, как в C++ 11 и более ранних версиях.

В следующем примере показано, как можно перегрузить `operator<`, чтобы дать возможность пользователям `std::set` выполнять поиск, просто передав небольшую строку, которую можно сравнивать с членом `BigObject::id` каждого объекта.

```cpp
#include <set>
#include <string>
#include <iostream>
#include <functional>

using namespace std;

class BigObject
{
public:
    string id;
    explicit BigObject(const string& s) : id(s) {}
    bool operator< (const BigObject& other) const
    {
        return this->id < other.id;
    }

    // Other members....
};

inline bool operator<(const string& otherId, const BigObject& obj)
{
    return otherId < obj.id;
}

inline bool operator<(const BigObject& obj, const string& otherId)
{
    return obj.id < otherId;
}

int main()
{
    // Use C++14 brace-init syntax to invoke BigObject(string).
    // The s suffix invokes string ctor. It is a C++14 user-defined
    // literal defined in <string>
    BigObject b1{ "42F"s };
    BigObject b2{ "52F"s };
    BigObject b3{ "62F"s };
    set<BigObject, less<>> myNewSet; // C++14
    myNewSet.insert(b1);
    myNewSet.insert(b2);
    myNewSet.insert(b3);
    auto it = myNewSet.find(string("62F"));
    if (it != myNewSet.end())
        cout << "myNewSet element = " << it->id << endl;
    else
        cout << "element not found " << endl;

    // Keep console open in debug mode:
    cout << endl << "Press Enter to exit.";
    string s;
    getline(cin, s);
    return 0;
}

//Output: myNewSet element = 62F
```

Следующие функции-члены в контейнерах "сопоставление", "мультиотображение", "набор" и "мультинабор" были перегружены для поддержки разнородного поиска:

1. find

1. count

1. lower_bound

1. upper_bound

1. equal_range

## <a name="container-adapters"></a>Контейнеры-адаптеры

Контейнер-адаптер — это разновидность последовательного или ассоциативного контейнера, который ограничивает интерфейс для простоты и ясности. Контейнеры-адаптеры не поддерживают итераторы.

Контейнер `queue` соответствует семантике FIFO (первым поступил — первым обслужен). Первый элемент, который *отправляется*, то есть вставляется, в очередь, должен быть первым элементом, *извлекаемым* из очереди. Дополнительные сведения см. в разделе [Класс queue](../standard-library/queue-class.md).

Контейнер `priority_queue` упорядочен таким образом, что первым в очереди всегда оказывается элемент с наибольшим значением. Дополнительные сведения см. в разделе [Класс priority_queue](../standard-library/priority-queue-class.md).

Контейнер `stack` соответствует семантике LIFO (последним поступил — первым обслужен). Последний элемент, отправленный в стек, становится первым извлекаемым элементом. Дополнительные сведения см. в разделе [Класс stack](../standard-library/stack-class.md).

Поскольку контейнеры-адаптеры не поддерживают итераторы, их невозможно использовать в алгоритмах стандартной библиотеки C++. Дополнительные сведения см. в разделе [Алгоритмы](../standard-library/algorithms.md).

## <a name="requirements-for-container-elements"></a>Требования для элементов контейнеров

Как правило, элементы, вставленные в контейнер стандартной библиотеки C++, могут быть практически любого типа объекта, если их можно копировать. Элементы, доступные только для перемещения — например, объекты `vector<unique_ptr<T>>`, создаваемые с помощью `unique_ptr<>`, — также можно использовать, если вы не вызываете функции-члены, которые пытаются скопировать их.

Деструктору не разрешено вызывать исключение.

Для упорядоченных ассоциативных контейнеров — ранее описанных в этом разделе — необходимо определить открытый оператор сравнения. (По умолчанию это оператор `operator<`, однако поддерживаются даже типы, которые не работают с `operator<`.)

Для некоторых операций в контейнерах может также потребоваться открытый конструктор по умолчанию и открытый оператор равенства. Например, неупорядоченным ассоциативным контейнерам требуется поддержка сравнения на равенство и хэширования.

## <a name="accessing-container-elements"></a>Доступ к элементам контейнера

Доступ к элементам контейнеров осуществляется с помощью итераторов. Дополнительные сведения см. в разделе [Итераторы](../standard-library/iterators.md).

> [!NOTE]
> Для перебора коллекций стандартной библиотеки C++ можно также использовать [циклы for на основе диапазонов](../cpp/range-based-for-statement-cpp.md).

## <a name="comparing-containers"></a>Сравнение контейнеров

Все контейнеры перегружают оператор == для сравнения двух контейнеров одного типа, содержащих элементы одного типа. Можно использовать оператор == для сравнения вектора \<string> с другим вектором\<string>, однако невозможно использовать его для сравнения вектора \<string> со списком \<string> или вектора \<string> с вектором \<char*>.  В C++ 98/03 можно использовать функцию [std::equal](algorithm-functions.md#equal) или [std::mismatch](algorithm-functions.md#mismatch) для сравнения контейнеров разного типа или элементов разного типа. В C++ 11 можно также использовать функцию [std::is_permutation](algorithm-functions.md#is_permutation). Но во всех этих случаях при работе функций предполагается, что контейнеры имеют одинаковую длину. Если второй диапазон короче первого, результат будет неопределенным. Если второй диапазон длиннее, результат также может быть неверным, поскольку сравнение не будет выполнено за пределами первого диапазона.

### <a name="comparing-dissimilar-containers-c14"></a>Сравнение контейнеров разного типа (C++ 14)

В c++ 14 и более поздних версиях можно сравнивать несхожие контейнеры и (или) типы элементов, используя одну `std::equal`из `std::mismatch`перегрузок функций, или `std::is_permutation` , принимающих два полных диапазона. Эти перегрузки позволяют сравнивать контейнеры разной длины. Эти перегрузки намного менее подвержены ошибкам пользователя и оптимизированы для возврата значения false в одно и то же время, когда сравниваются контейнеры разной длины. Поэтому рекомендуется использовать эти перегрузки, если у вас нет веской причины против их использования и если вы не используете контейнер [std::list](../standard-library/list-class.md), в котором не реализуются преимущества двухдиапазонной оптимизации.

## <a name="see-also"></a>См. также

[Контейнеры](../cpp/containers-modern-cpp.md)\
[Справочник по стандартной библиотеке C++](../standard-library/cpp-standard-library-reference.md)\
[\<образец контейнера>](../standard-library/sample-container.md)\
[Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)
