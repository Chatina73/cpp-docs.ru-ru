---
title: Контейнеры стандартной библиотеки C++
ms.date: 11/04/2016
helpviewer_keywords:
- C++ Standard Library, class template containers
- containers, C++ Standard Library
ms.assetid: 8e915ca1-19ba-4f0d-93c8-e2c3bfd638eb
ms.openlocfilehash: 01be754dd7b418f64cf495d7563f65b323265df8
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81376703"
---
# <a name="c-standard-library-containers"></a>Контейнеры стандартной библиотеки C++

Стандартная библиотека предоставляет различные типобезопасные контейнеры для хранения коллекций связанных объектов. Контейнеры представляют шаблоны классов. При объявлении переменной контейнера указывается тип элементов, которые будет удерживаться контейнером. Контейнеры могут создаваться с использованием списков инициализаторов. Они имеют функции членов для добавления и удаления элементов и выполнения других операций.

Итерация элементов в контейнере и доступ к отдельным элементам осуществляются с помощью [итераторов](../standard-library/iterators.md). Вы можете использовать итераторы явно, используя их функции членов и операторов и глобальные функции. Вы можете также использовать их неявно, например с помощью цикла range-for. Итераторы для всех контейнеров стандартной библиотеки C++ имеют общий интерфейс, но каждый контейнер определяет собственные специализированные итераторы.

Контейнеры можно разделить на три категории: последовательные контейнеры, ассоциативные контейнеры и контейнеры-адаптеры.

## <a name="sequence-containers"></a><a name="sequence_containers"></a> Последовательные контейнеры

Последовательные контейнеры поддерживают указанный пользователем порядок вставляемых элементов.

Контейнер `vector` ведет себя как массив, но может автоматически увеличиваться по мере необходимости. Он поддерживает прямой доступ и связанное хранение и имеет очень гибкую длину. По этим и многим другим причинам контейнер `vector` является наиболее предпочтительным последовательным контейнером для большинства областей применения. Если вы сомневаетесь в выборе вида последовательного контейнера, начните с использования вектора. Дополнительные сведения см. в разделе [Класс vector](../standard-library/vector-class.md).

Контейнер `array` имеет некоторые сильные `vector`стороны, но длина не столь гибкая. Дополнительные сведения см. в разделе [Класс array](../standard-library/array-class-stl.md).

Контейнер `deque` (двусторонняя очередь) обеспечивает быструю вставку и удаление в начале и в конце контейнера. Он разделяет случайный доступ и гибкие преимущества длины, `vector`но не является смежным. Дополнительные сведения см. в разделе [Класс deque](../standard-library/deque-class.md).

Контейнер `list` — это вдвойне связанный список, который обеспечивает двунаправленный доступ, быстрые вставки и быстрые удаления в любом месте контейнера, но вы не можете случайно получить доступ к элементу в контейнере. Дополнительные сведения см. в разделе [Класс list](../standard-library/list-class.md).

Контейнер `forward_list` — однонаправленный список. Это версия контейнера `list` только с доступом в прямом направлении. Дополнительные сведения см. в разделе [Класс forward_list](../standard-library/forward-list-class.md).

## <a name="associative-containers"></a>Ассоциативные контейнеры

В ассоциативных контейнерах элементы вставляются в предварительно определенном порядке — например, с сортировкой по возрастанию. Также доступны неупорядоченные ассоциативные контейнеры. Ассоциативные контейнеры можно объединить в два подмножества: сопоставления (set) и наборы (map).

Контейнер `map`, который иногда называют словарем, состоит из пар "ключ-значение". Ключ используется для упорядочивания последовательности, а значение связано с ключом. Например, `map` может содержать ключи, представляющие каждое уникальное ключевое слово в тексте, и соответствующие значения, которые обозначают количество повторений каждого слова в тексте. `map` — это неупорядоченная версия `unordered_map`. Дополнительные сведения см. в разделах [Класс map](../standard-library/map-class.md) и [Класс unordered_map](../standard-library/unordered-map-class.md).

`set` — это контейнер уникальных элементов, упорядоченных по возрастанию. Каждое его значение также является и ключом. `set` — это неупорядоченная версия `unordered_set`. Дополнительные сведения см. в разделах [Класс set](../standard-library/set-class.md) и [Класс unordered_set](../standard-library/unordered-set-class.md).

Контейнеры `map` и `set` разрешают вставку только одного экземпляра ключа или элемента. Если необходимо включить несколько экземпляров элемента, следует использовать контейнер `multimap` или `multiset`. Неупорядоченные версии этих контейнеров — `unordered_multimap` и `unordered_multiset`. Дополнительные сведения см. в статьях [Класс multimap](../standard-library/multimap-class.md), [Класс unordered_multimap](../standard-library/unordered-multimap-class.md), [Класс multiset](../standard-library/multiset-class.md) и [Класс unordered_multiset](../standard-library/unordered-multiset-class.md).

Упорядоченные контейнеры map и set поддерживают двунаправленные итераторы, а их неупорядоченный аналоги — итераторы с перебором в прямом направлении. Для получения дополнительной информации [см.](../standard-library/iterators.md)

### <a name="heterogeneous-lookup-in-associative-containers-c14"></a>Разнородный поиск в ассоциативных контейнерах (C++ 14)

Заказанные ассоциативные контейнеры (карта, мультикарта, набор и мультисет) теперь поддерживают неоднородный поиск, что означает, что вам больше `find()` не `lower_bound()`требуется проходить тот же тип объекта, что и ключ или элемент в функциях членов, таких как и . Вы можете передать объект любого типа, для которого определен перегруженный `operator<`, позволяющий выполнять сравнение с типом ключа.

Разнородный поиск включается дополнительно, когда указывается средство сравнения "ромбовидный функтор" `std::less<>` или `std::greater<>` при объявлении переменной контейнера, как показано ниже:

```cpp
std::set<BigObject, std::less<>> myNewSet;
```

Если используется средство сравнения, заданное по умолчанию, контейнер ведет себя точно так же, как в C++ 11 и более ранних версиях.

В следующем примере показано, как перегружать, `operator<` чтобы позволить пользователям `std::set` делать поиск, просто передавая `BigObject::id` в небольшой строке, которая может быть по сравнению с членом каждого объекта.

```cpp
#include <set>
#include <string>
#include <iostream>
#include <functional>

using namespace std;

class BigObject
{
public:
    string id;
    explicit BigObject(const string& s) : id(s) {}
    bool operator< (const BigObject& other) const
    {
        return this->id < other.id;
    }

    // Other members....
};

inline bool operator<(const string& otherId, const BigObject& obj)
{
    return otherId < obj.id;
}

inline bool operator<(const BigObject& obj, const string& otherId)
{
    return obj.id < otherId;
}

int main()
{
    // Use C++14 brace-init syntax to invoke BigObject(string).
    // The s suffix invokes string ctor. It is a C++14 user-defined
    // literal defined in <string>
    BigObject b1{ "42F"s };
    BigObject b2{ "52F"s };
    BigObject b3{ "62F"s };
    set<BigObject, less<>> myNewSet; // C++14
    myNewSet.insert(b1);
    myNewSet.insert(b2);
    myNewSet.insert(b3);
    auto it = myNewSet.find(string("62F"));
    if (it != myNewSet.end())
        cout << "myNewSet element = " << it->id << endl;
    else
        cout << "element not found " << endl;

    // Keep console open in debug mode:
    cout << endl << "Press Enter to exit.";
    string s;
    getline(cin, s);
    return 0;
}

//Output: myNewSet element = 62F
```

Следующие функции участника на карте, мультикарте, наборе и мультисете были перегружены для поддержки неоднородного поиска:

1. поиск

1. count

1. lower_bound

1. upper_bound

1. equal_range

## <a name="container-adapters"></a>Контейнеры-адаптеры

Контейнер-адаптер — это разновидность последовательного или ассоциативного контейнера, который ограничивает интерфейс для простоты и ясности. Контейнерные адаптеры не поддерживают итераторы.

Контейнер `queue` соответствует семантике FIFO (первым поступил — первым обслужен). Первый элемент, который *отправляется*, то есть вставляется, в очередь, должен быть первым элементом, *извлекаемым* из очереди. Дополнительные сведения см. в разделе [Класс queue](../standard-library/queue-class.md).

Контейнер `priority_queue` упорядочен таким образом, что первым в очереди всегда оказывается элемент с наибольшим значением. Дополнительные сведения см. в разделе [Класс priority_queue](../standard-library/priority-queue-class.md).

Контейнер `stack` соответствует семантике LIFO (последним поступил — первым обслужен). Последний элемент, отправленный в стек, становится первым извлекаемым элементом. Дополнительные сведения см. в разделе [Класс stack](../standard-library/stack-class.md).

Поскольку контейнерные адаптеры не поддерживают итераторы, они не могут быть использованы с помощью алгоритмов стандартной библиотеки СЗ. Дополнительные сведения см. в разделе [Алгоритмы](../standard-library/algorithms.md).

## <a name="requirements-for-container-elements"></a>Требования для элементов контейнеров

Как правило, элементы, вставленные в контейнер стандартной библиотеки C++, могут быть практически любого типа объекта, если их можно копировать. Элементы, доступные только для перемещения — например, объекты `vector<unique_ptr<T>>`, создаваемые с помощью `unique_ptr<>`, — также можно использовать, если вы не вызываете функции-члены, которые пытаются скопировать их.

Уничтожить не разрешается бросать исключение.

Для упорядоченных ассоциативных контейнеров — ранее описанных в этом разделе — необходимо определить открытый оператор сравнения. (По умолчанию это оператор `operator<`, однако поддерживаются даже типы, которые не работают с `operator<`.)

Для некоторых операций в контейнерах может также потребоваться открытый конструктор по умолчанию и открытый оператор равенства. Например, неупорядоченным ассоциативным контейнерам требуется поддержка сравнения на равенство и хэширования.

## <a name="accessing-container-elements"></a>Доступ к элементам контейнера

Доступ к элементам контейнеров осуществляется с помощью итераторов. Для получения дополнительной информации [см.](../standard-library/iterators.md)

> [!NOTE]
> Для перебора коллекций стандартной библиотеки C++ можно также использовать [циклы for на основе диапазонов](../cpp/range-based-for-statement-cpp.md).

## <a name="comparing-containers"></a>Сравнение контейнеров

Все контейнеры перегружают оператор == для сравнения двух контейнеров одного типа, содержащих элементы одного типа. Можно сравнить>\<векторной строки\<с другой> векторной строки,\<но вы\<не можете использовать\<ее для\<сравнения> векторной строки с строкой списка> или> векторной строки с > векторного шара.  В C-98/03 можно использовать [std::equal](algorithm-functions.md#equal) или [std::mismatch](algorithm-functions.md#mismatch) для сравнения различных типов контейнеров и/или типов элементов. В С-11 вы также можете использовать [std::is_permutation](algorithm-functions.md#is_permutation). Но во всех этих случаях функции предполагают, что контейнеры одинаковой длины. Если второй диапазон короче первого, результат будет неопределенным. Если второй диапазон длиннее, результат также может быть неверным, поскольку сравнение не будет выполнено за пределами первого диапазона.

### <a name="comparing-dissimilar-containers-c14"></a>Сравнение контейнеров разного типа (C++ 14)

В C-14 и позже можно сравнить различные контейнеры и/или разные типы элементов, используя один из `std::equal`перегрузок, `std::mismatch` `std::is_permutation` которые занимают два полных диапазона. Эти перегрузки позволяют сравнивать контейнеры разной длины. Эти перегрузки намного менее подвержены ошибкам пользователя и оптимизированы для возврата значения false в одно и то же время, когда сравниваются контейнеры разной длины. Поэтому мы рекомендуем вам использовать эти перегрузки, если у вас нет четкой причины не делать этого, или вы используете [std::list](../standard-library/list-class.md) контейнер, который не выигрывает от оптимизации двойного диапазона.

## <a name="see-also"></a>См. также раздел

[Параллельные контейнеры](../parallel/concrt/parallel-containers-and-objects.md)\
[\<образец контейнера>](../standard-library/sample-container.md)\
[Безопасность резьбы в стандартной библиотеке СЗ](../standard-library/thread-safety-in-the-cpp-standard-library.md)
