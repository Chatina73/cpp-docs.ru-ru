---
title: '&lt;Мьютекс&gt;'
ms.date: 11/04/2016
f1_keywords:
- <mutex>
ms.assetid: efb60c89-687a-4e38-8fe4-694e11c4e8a3
ms.openlocfilehash: 4655278e312647f4e69cf48cb772df854260ce57
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50482567"
---
# <a name="ltmutexgt"></a>&lt;Мьютекс&gt;

Включите стандартный заголовок \<mutex> для определения классов `mutex`, `recursive_mutex`, `timed_mutex` и `recursive_timed_mutex`, шаблонов `lock_guard` и `unique_lock`, а также поддерживающих типов и функций, определяющих взаимоисключающие регионы кода.

> [!WARNING]
> Типы синхронизации стандартной библиотеки C++, начиная с Visual Studio 2015 основаны на примитивах синхронизации Windows и больше не используют ConcRT (кроме случаев, когда целевой платформы Windows XP). Типы, определенные в \<mutex>, не должны использоваться с какими-либо типами или функциями ConcRT.

## <a name="syntax"></a>Синтаксис

```cpp
#include <mutex>
```

## <a name="remarks"></a>Примечания

> [!NOTE]
> В коде, скомпилированном с помощью **/CLR**, этот заголовок блокируется.

Классы `mutex` и `recursive_mutex` имеют *тип мьютекса*. Тип мьютекса содержит конструктор по умолчанию и деструктор, который не вызывает исключения. Эти объекты содержат методы, обеспечивающие взаимное исключение в случаях, когда несколько потоков пытаются заблокировать один объект. В частности, тип мьютекса содержит методы `lock`, `try_lock` и `unlock`:

- Метод `lock` блокирует вызывающий поток до тех пор, пока этот поток не получит права владения мьютексом. Его возвращаемое значение игнорируется.

- Метод `try_lock` пытается получить права владения мьютексом без блокировки. Его возвращаемое значение можно преобразовать в **bool** и **true** Если метод получает владение; в противном случае — значение **false**.

- Метод `unlock` выпускает права владения мьютексом из вызывающего потока.

Вы можете использовать типы мьютекса в качестве аргументов для создания экземпляров шаблонов `lock_guard` и `unique_lock`. Вы можете использовать объекты этих типов в качестве аргумента `Lock` для функций-членов wait в шаблоне [condition_variable_any](../standard-library/condition-variable-any-class.md).

*Тип мьютекса с ограничением по времени* удовлетворяет требованиям к типу мьютексов. Кроме того, он имеет `try_lock_for` и `try_lock_until` методы, которые должны вызываться с помощью одного аргумента и должен возвращать тип, который может быть преобразован **bool**. Тип мьютекса с ограничением по времени может определять эти функции с помощью дополнительных аргументов, если эти дополнительные аргументы имеют значения по умолчанию.

- Метод `try_lock_for` должен иметь возможность вызова с одним аргументом `Rel_time`, тип которого является экземпляром [chrono::duration](../standard-library/duration-class.md). Метод пытается получить права владения мьютексом, но возвращается в период времени, назначенный `Rel_time`, независимо от успешности выполнения операции. Возвращаемое значение преобразуется в **true** Если метод получает права владения; в противном случае возвращаемое значение преобразует **false**.

- Метод `try_lock_until` должен быть доступен для вызова с одним аргументом `Abs_time`, тип которого является экземпляром [chrono::time_point](../standard-library/time-point-class.md). Метод пытается получить права владения мьютексом, но возвращается раньше окончания периода, назначенного `Abs_time`, независимо от успешности выполнения операции. Возвращаемое значение преобразуется в **true** Если метод получает права владения; в противном случае возвращаемое значение преобразует **false**.

Тип мьютекса также известен как *блокируемый тип*. Если он не предоставляет функцию-член `try_lock`, это *базовый блокируемый тип*. Мьютекс с ограничением по времени также известен как *блокируемый тип с ограничением по времени* .

### <a name="classes"></a>Классы

|Имя|Описание|
|----------|-----------------|
|[Класс lock_guard](../standard-library/lock-guard-class.md)|Представляет шаблон, для которого можно создать экземпляры и объект, деструктор которого разблокирует `mutex`.|
|[Класс mutex (Стандартная библиотека C++)](../standard-library/mutex-class-stl.md)|Представляет тип мьютекса. Используйте объекты этого типа для принудительного взаимного исключения в программе.|
|[Класс recursive_mutex](../standard-library/recursive-mutex-class.md)|Представляет тип мьютекса. В отличие от класса `mutex`, поведение вызывающих методов блокировки для объектов, которые уже заблокированы, четко определено.|
|[Класс recursive_timed_mutex](../standard-library/recursive-timed-mutex-class.md)|Представляет тип мьютекса с ограничением по времени. Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе. В отличие от объектов типа `timed_mutex`, эффект вызова методов блокировки для объектов `recursive_timed_mutex` четко определен.|
|[Класс timed_mutex](../standard-library/timed-mutex-class.md)|Представляет тип мьютекса с ограничением по времени. Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе.|
|[Класс unique_lock](../standard-library/unique-lock-class.md)|Представляет шаблон, для которого можно создать экземпляры и объекты, управляющие блокировкой и разблокировкой `mutex`.|

### <a name="functions"></a>Функции

|Имя|Описание|
|----------|-----------------|
|[call_once](../standard-library/mutex-functions.md#call_once)|Предоставляет механизм для однократного вызова указанного объекта во время выполнения.|
|[lock](../standard-library/mutex-functions.md#lock)|Пытается заблокировать все аргументы без взаимоблокировки.|

### <a name="structs"></a>структурам;

|name|Описание|
|----------|-----------------|
|[Структура adopt_lock_t](../standard-library/adopt-lock-t-structure.md)|Представляет тип, который используется для определения `adopt_lock`.|
|[Структура defer_lock_t](../standard-library/defer-lock-t-structure.md)|Представляет тип, который определяет объект `defer_lock`, используемый для выбора одного из перегруженных конструкторов `unique_lock`.|
|[Структура once_flag](../standard-library/once-flag-structure.md)|Представляет **структуры** , используемый с функцией шаблона `call_once` чтобы убедиться, что инициализация кода вызывается только один раз, даже при наличии нескольких потоков выполнения.|
|[Структура try_to_lock_t](../standard-library/try-to-lock-t-structure.md)|Представляет **структуры** , определяющий `try_to_lock` объекта и используется для выбора одного из перегруженных конструкторов `unique_lock`.|

### <a name="variables"></a>Переменные

|name|Описание|
|----------|-----------------|
|[adopt_lock](../standard-library/mutex-functions.md#adopt_lock)|Представляет объект, который можно передать в конструкторы для `lock_guard` и `unique_lock`, чтобы указать на блокировку объекта мьютекса, также передаваемого в конструктор.|
|[defer_lock](../standard-library/mutex-functions.md#defer_lock)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор не должен блокировать объект мьютекса, который также передается в него.|
|[try_to_lock](../standard-library/mutex-functions.md#try_to_lock)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор должен попытаться разблокировать объект `mutex`, который также передается в него без блокировки.|

## <a name="see-also"></a>См. также

[Справочник по файлам заголовков](../standard-library/cpp-standard-library-header-files.md)<br/>
