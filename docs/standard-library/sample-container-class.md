---
title: Пример класса контейнера
ms.date: 11/04/2016
helpviewer_keywords:
- container classes [C++]
ms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a
ms.openlocfilehash: dbfa076756b9e4829898d38e0277ad90106ba579
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62410997"
---
# <a name="sample-container-class"></a>Пример класса контейнера

> [!NOTE]
> Данный раздел включен в документацию Visual C++ в качестве нефункционального примера контейнеров, используемых в стандартной библиотеке C++. Дополнительные сведения см. в разделе [Контейнеры стандартной библиотеки C++](../standard-library/stl-containers.md).

Описывает объект, управляющий последовательностью элементов, обычно типа переменной длины `Ty`. Последовательность сохраняется по-разному в зависимости от фактического контейнера.

Может возникнуть ситуация, когда конструктор контейнеров или функция-член вызовет конструктор **Ty**(**const Ty&**) или функцию **Ty::operator=**(**const Ty&**). Если такой вызов порождает исключение, объект-контейнер должен сохранять свою целостность и поэтому он повторно создает любое перехватываемое исключение. Можно безопасно заменять, назначать, удалять или уничтожать объект-контейнер после того, как он создаст одно из следующих исключений. В целом, тем не менее, невозможно иначе спрогнозировать состояние последовательности, контролируемой объектом-контейнером.

Несколько дополнительных предупреждений:

- Если выражение `~Ty` создает исключение, результирующее состояние объекта-контейнера не определено.

- Если контейнер сохраняет объект-распределитель *al*, и *al* вызывает исключение, отличное от результате обращения к `al.allocate`, получившееся состояние объекта-контейнера не определено.

- Если контейнер сохраняет объект-функцию *comp*, чтобы определить, как упорядочить контролируемую последовательность, и *comp* создает исключение любого вида, получившееся состояние объекта-контейнера не определено.

Классы контейнеров, определяемые стандартной библиотекой C++, удовлетворяют несколько дополнительных требований, как показано ниже.

Класс шаблонов контейнера [list](../standard-library/list-class.md) предоставляет детерминированное и полезное поведение даже в присутствии вышеуказанных исключений. Например, если исключение создается во время вставки одного или более элементов контейнер не меняется, а исключение создается снова.

Для *все* классов контейнеров, определяемых стандартной библиотекой C++, если исключение во время вызовов следующих функций-членов, `insert`, `push_back`, или `push_front`, контейнер остается без изменений и исключение создается снова.

Для *все* классов контейнеров, определяемых стандартной библиотекой C++, исключение не создается во время вызовов следующих функций-членов: `pop_back`, `pop_front`.

Функция-член [erase](../standard-library/container-class-erase.md) создает исключение, только если операция копирования (назначение или создание копии) создает исключение.

Кроме того, исключение не создается при копировании итератора, возвращаемого функцией-членом.

Функция-член [swap](../standard-library/container-class-swap.md) делает дополнительные обещания для *всех* классов контейнеров, определяемых стандартной библиотекой C++:

- Функция-член создает исключение, только если контейнер хранит объект-распределитель al и `al` создает исключение при копировании.

- Ссылки, указатели и итераторы, обозначающие элементы заменяемой управляемой последовательности, остаются действительными.

Объект класса контейнера, определяемый стандартной библиотекой C++, выделяет и освобождает хранилище для последовательности, которой он управляет через хранимый объект типа `Alloc`, который, как правило, является параметром шаблона. Такой объект распределителя должен иметь такой же внешний интерфейс, как объект класса `allocator<Ty>`. В частности `Alloc` должен быть тот же тип, что `Alloc::rebind<value_type>::other`

Для *все* классов контейнеров, определяемых стандартной библиотекой C++, функция-член `Alloc get_allocator const;` возвращает копию объекта сохраненный объект распределителя. Обратите внимание, что сохраненный объект-распределитель *не* копируется, если назначается объект контейнера. Все конструкторы инициализируют значение, хранящееся в `allocator`, `Alloc` Если конструктор не содержит параметр распределителя.

Согласно стандарту C++, класс контейнера, определяемый стандартной библиотекой C++, может допускать следующее:

- Все объекты класса `Alloc` равны при сравнении.

- Тип `Alloc::const_pointer` совпадает со значением `const Ty *`.

- Тип `Alloc::const_reference` совпадает со значением `const Ty&`.

- Тип `Alloc::pointer` совпадает со значением `Ty *`.

- Тип `Alloc::reference` совпадает со значением `Ty&`.

В этой реализации, однако, контейнеры не делают таких упрощающих допущений. Следовательно, они правильно работают с более требовательными объектами-распределителями:

- Объектам класса `Alloc` не нужно быть равными при сравнении. (Можно иметь несколько пулов носителей.)

- Тип `Alloc::const_pointer` не должны совпадать с именем `const Ty *`. (Константный указатель может быть классом.)

- Тип `Alloc::pointer` не должны совпадать с именем `Ty *`. (Указатель может быть классом.)

## <a name="requirements"></a>Требования

**Заголовок**: \<образец контейнера>

## <a name="see-also"></a>См. также

[\<образец контейнера>](../standard-library/sample-container.md)<br/>
