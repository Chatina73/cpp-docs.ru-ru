---
description: Дополнительные сведения о классе "пример контейнера"
title: Пример класса контейнера
ms.date: 11/04/2016
helpviewer_keywords:
- container classes [C++]
ms.assetid: 5b1451f2-c708-45da-bbf0-9e42fd687a1a
ms.openlocfilehash: 728cec44462a8e09aad7f87000520f0fa5a15b3a
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97148880"
---
# <a name="sample-container-class"></a>Пример класса контейнера

> [!NOTE]
> Эта статья содержится в документации по Microsoft C++ как нефункциональный пример контейнеров, используемых в стандартной библиотеке C++. Дополнительные сведения см. в разделе [Контейнеры стандартной библиотеки C++](../standard-library/stl-containers.md).

Описывает объект, управляющий последовательностью элементов различной длины, обычно типа `Ty` . Последовательность сохраняется по-разному в зависимости от фактического контейнера.

Может возникнуть ситуация, когда конструктор контейнеров или функция-член вызовет конструктор **Ty**(**const Ty&**) или функцию **Ty::operator=**(**const Ty&**). Если такой вызов порождает исключение, объект-контейнер должен сохранять свою целостность и поэтому он повторно создает любое перехватываемое исключение. Можно безопасно заменять, назначать, удалять или уничтожать объект-контейнер после того, как он создаст одно из следующих исключений. В целом, тем не менее, невозможно иначе спрогнозировать состояние последовательности, контролируемой объектом-контейнером.

Несколько дополнительных предупреждений:

- Если выражение `~Ty` создает исключение, результирующее состояние объекта контейнера не определено.

- Если контейнер сохраняет объект распределителя *Al*, а *Al* вызывает исключение, отличное от результата вызова `al.allocate` , результирующее состояние объекта контейнера не определено.

- Если контейнер сохраняет объект-функцию *comp*, чтобы определить, как упорядочить контролируемую последовательность, и *comp* создает исключение любого вида, получившееся состояние объекта-контейнера не определено.

Классы контейнеров, определяемые стандартной библиотекой C++, удовлетворяют несколько дополнительных требований, как показано ниже.

[Список](../standard-library/list-class.md) шаблонов классов контейнеров обеспечивает детерминированное и полезное поведение даже при наличии исключений, описанных выше. Например, если исключение создается во время вставки одного или более элементов контейнер не меняется, а исключение создается снова.

Для *всех* классов контейнеров, определенных стандартной библиотекой C++, если исключение возникает во время вызовов следующих функций-членов,, `insert` `push_back` или `push_front` , контейнер остается неизменным, а исключение создается повторно.

Для *всех* классов контейнеров, определенных стандартной библиотекой C++, исключение не возникает во время вызовов следующих функций-членов: `pop_back` , `pop_front` .

Функция-член [erase](../standard-library/container-class-erase.md) создает исключение, только если операция копирования (назначение или создание копии) создает исключение.

Кроме того, исключение не создается при копировании итератора, возвращаемого функцией-членом.

Функция-член [swap](../standard-library/container-class-swap.md) делает дополнительные обещания для *всех* классов контейнеров, определяемых стандартной библиотекой C++:

- Функция-член создает исключение, только если контейнер хранит объект-распределитель al и `al` создает исключение при копировании.

- Ссылки, указатели и итераторы, обозначающие элементы заменяемой управляемой последовательности, остаются действительными.

Объект класса контейнера, определяемый стандартной библиотекой C++, выделяет и освобождает хранилище для последовательности, которой он управляет через хранимый объект типа `Alloc`, который, как правило, является параметром шаблона. Такой объект распределителя должен иметь тот же внешний интерфейс, что и объект класса `allocator<Ty>` . В частности, `Alloc` должен иметь тот же тип, что и `Alloc::rebind<value_type>::other`

Для *всех* классов контейнеров, определенных стандартной библиотекой C++, функция-член `Alloc get_allocator const;` возвращает копию сохраненного объекта распределителя. Обратите внимание, что сохраненный объект распределителя *не* копируется при назначении объекта контейнера. Все конструкторы инициализируют значение, хранящееся в `allocator` , в, `Alloc` Если конструктор не содержит параметр распределителя.

Согласно стандарту C++, класс контейнера, определяемый стандартной библиотекой C++, может допускать следующее:

- Все объекты класса `Alloc` равны при сравнении.

- Тип совпадает с `Alloc::const_pointer` `const Ty *` .

- Тип совпадает с `Alloc::const_reference` `const Ty&` .

- Тип совпадает с `Alloc::pointer` `Ty *` .

- Тип совпадает с `Alloc::reference` `Ty&` .

В этой реализации, однако, контейнеры не делают таких упрощающих допущений. Следовательно, они правильно работают с более требовательными объектами-распределителями:

- Объектам класса `Alloc` не нужно быть равными при сравнении. (Можно иметь несколько пулов носителей.)

- Тип не обязательно должен совпадать с типом `Alloc::const_pointer` `const Ty *` . (Константный указатель может быть классом.)

- Тип не обязательно должен совпадать с типом `Alloc::pointer` `Ty *` . (Указатель может быть классом.)

## <a name="requirements"></a>Требования

**Заголовок**: \<sample container>

## <a name="see-also"></a>См. также раздел

[\<sample container>](../standard-library/sample-container.md)
