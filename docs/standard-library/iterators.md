---
title: Iterators
ms.date: 11/04/2016
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
ms.openlocfilehash: c3bb2825ec6ad98f523fa4c3a616d0807eac50a8
ms.sourcegitcommit: 5ef9697b4cb1947bec9669be57bc920d2c4d82a6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2020
ms.locfileid: "87870156"
---
# <a name="iterators"></a>Iterators

Итератор — это объект, который может перебирать элементы в контейнере стандартной библиотеки С++ и предоставлять доступ к отдельным элементам. Все контейнеры стандартной библиотеки С++ предоставляют итераторы, чтобы алгоритмы могли получить доступ к их элементам стандартным способом, независимо от типа контейнера, в котором сохранены элементы.

Можно явно использовать итераторы с помощью членов и глобальных функций, таких как и, и `begin()` `end()` `++` `--` для перемещения вперед или назад. Можно также использовать итераторы неявно с циклом Range-for или (для некоторых типов итераторов) оператором индекса `[]` .

В стандартной библиотеке С++ началом последовательности или диапазона является первый элемент. Конец последовательности или диапазона всегда определяется как элемент, следующий за последним элементом. Глобальные функции `begin` и `end` возвращают итераторы в указанный контейнер. Типичный цикл явных итераторов, включающий все элементы, выглядит следующим образом:

```cpp
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++)
{
    // Access element using dereference operator
    cout << *it << " ";
}
```

Того же можно достичь более простым способом, с помощью цикла range-for:

```cpp
for (auto num : vec)
{
    // no dereference operator
    cout << num << " ";
}
```

Существует пять категорий итераторов. Ниже описаны категории в порядке возрастания силы.

- **Выход**. *Итератор вывода* `X` может выполнять итерацию по последовательности с помощью `++` оператора и может записывать элемент только один раз с помощью __`*`__ оператора.

- **Вход.** *Входной итератор* `X` может выполнять итерацию по последовательности с помощью `++` оператора и может считывать элемент любое количество раз с помощью `*` оператора. Можно сравнить итераторы ввода с помощью `==` `!=` операторов и. После увеличения любой копии итератора ввода ни одна из остальных копий не может быть безопасно сравниваться, разыменована или увеличена позже.

- **Вперед**. *Прямой итератор* `X` может перебрать последовательность с помощью оператора + + и может считывать любой элемент или записывать неконстантные элементы любое количество раз с помощью `*` оператора. Доступ к элементам элементов можно получить с помощью `->` оператора и сравнить прямые итераторы с помощью `==` операторов и `!=` . Вы можете сделать несколько копий однонаправленного итератора, каждая из которых может быть разыменована и для нее может быть выполнено независимое приращение. Прямой итератор, инициализируемый без ссылки на какой-либо контейнер, называется *прямым итератором NULL*. Пустые однонаправленные итераторы всегда равны.

- **Двунаправленный**. *Двунаправленный итератор* `X` может принимать место от прямого итератора. Однако можно также уменьшить двунаправленный итератор, как в `--X` , `X--` или `(V = *X--)` . Получить доступ к членам элементов и сравнить двунаправленные итераторы можно так же, как и однонаправленные итераторы.

- **Произвольный доступ**. *Итератор произвольного доступа* `X` может использовать место для двунаправленного итератора. С помощью итератора произвольного доступа можно использовать оператор индекса `[]` для доступа к элементам. `+`Операторы, и можно использовать `-` `+=` `-=` для перемещения указанного числа элементов вперед или назад, а также для вычисления расстояния между итераторами. Двунаправленные итераторы можно сравнивать с помощью `==` , `!=` , `<` , `>` , `<=` и `>=` .

Все итераторы можно назначать и копировать. Предполагается, что они являются простыми объектами и часто передаются и возвращаются по значению, а не по ссылке. Обратите внимание, что ни одна из операций, описанных выше, не может создавать исключения при выполнении с допустимым итератором.

Иерархия категорий итераторов может быть представлена в виде трех последовательностей. Для доступа в режиме только для записи в последовательность можно использовать любой из следующих итераторов.

> Итератор вывода \
> -> прямой итератор \
> -> двунаправленный итератор \
> -> итератор произвольного доступа

Стрелка вправо означает "могут быть заменены". Любой алгоритм, использующий итератор вывода, должен хорошо работать, например, с однонаправленным итератором, но *не* наоборот.

Для доступа в режиме только для чтения в последовательность можно использовать любой из следующих итераторов.

> входной итератор \
> -> прямой итератор \
> -> двунаправленный итератор \
> -> итератор произвольного доступа

Итератор ввода является самым слабым по всем категориям в этом смысле.

Наконец, для доступа в режиме чтения и записи в последовательность можно использовать любой из следующих итераторов.

> прямой итератор \
> -> двунаправленный итератор \
> -> итератор произвольного доступа

Указатель на объект всегда можно использовать как итератор произвольного доступа, поэтому он может относиться к любой категории итераторов, если он поддерживает необходимый уровень доступа для чтения и записи в последовательность, которую он обозначает.

Итератор `Iterator`, не являющийся указателем на объект, должен также определять типы элементов, необходимые для специализации `iterator_traits<Iterator>`. Эти требования могут быть выполнены путем наследования `Iterator` от открытого [итератора](../standard-library/iterator-struct.md)базового класса.

Важно понимать обещания и ограничения каждой категории итераторов, чтобы увидеть, как итераторы используются контейнерами и алгоритмами в стандартной библиотеке C++.

> [!NOTE]
> Вы можете избежать явного использования итераторов с помощью циклов range-for. Дополнительные сведения см. в разделе [оператор на основе диапазона for](../cpp/range-based-for-statement-cpp.md).

Теперь Microsoft C++ предлагает проверенные итераторы и отладочные итераторы, чтобы не перезаписать границы контейнера. Дополнительные сведения см. в разделах [Проверяемые итераторы](../standard-library/checked-iterators.md) и [Поддержка отладочных итераторов](../standard-library/debug-iterator-support.md).

## <a name="see-also"></a>См. также

[Справочник по стандартной библиотеке C++](../standard-library/cpp-standard-library-reference.md)\
[Безопасность потоков в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)
