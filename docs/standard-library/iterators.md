---
title: Итераторы
ms.date: 11/04/2016
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
ms.openlocfilehash: 3b6713a80244d7063baac2c75ffead76fe93facc
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62396149"
---
# <a name="iterators"></a>Итераторы

Итератор — это объект, который может перебирать элементы в контейнере стандартной библиотеки С++ и предоставлять доступ к отдельным элементам. Все контейнеры стандартной библиотеки С++ предоставляют итераторы, чтобы алгоритмы могли получить доступ к их элементам стандартным способом, независимо от типа контейнера, в котором сохранены элементы.

Вы можете использовать итераторы явно с помощью члена и глобальные функции например `begin()` и `end()` и операторы, такие как **++** и **--** для перемещения вперед или назад. Можно также использовать итераторы неявно с диапазоном-цикл for или (для некоторых типов итераторов) оператор индекса  **\[]**.

В стандартной библиотеке С++ началом последовательности или диапазона является первый элемент. Конец последовательности или диапазона всегда определяется как элемент, следующий за последним элементом. Глобальные функции `begin` и `end` возвращают итераторы в указанный контейнер. Типичный цикл явных итераторов, включающий все элементы, выглядит следующим образом:

```cpp
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++)
{
    // Access element using dereference operator
    cout << *it << " ";
}
```

Того же можно достичь более простым способом, с помощью цикла range-for:

```cpp
for (auto num : vec)
{
    // no deference operator
    cout << num << " ";
}
```

Существует пять категорий итераторов. Ниже описаны категории в порядке возрастания силы.

- **Вывод**. *Выходной итератор* `X` можно выполнить итерацию последовательности с помощью **++** оператор и записать элемент только один раз, с помощью __\*__ оператор.

- **Ввод**. *Итератор ввода* `X` можно выполнить итерацию последовательности с помощью ++ оператор и прочитать элемент любое количество раз с помощью **&ast;** оператор. Вы можете сравнить итераторы ввода с помощью **++** и **! =** операторы. После выполнения приращения любой копии итератора ввода ни одну из других копий нельзя будет безопасно сравнивать, разыменовывать и выполнять приращение.

- **Прямой**. Объект *прямой итератор* `X` можно выполнить итерацию последовательности с помощью ++ оператор и может читать любой элемент или записать неконстантные элементы любое количество раз с помощью **&ast;** оператор. Доступ к членам элементов с помощью **->** оператор и сравнение пересылать итераторы с помощью **==** и **! =** операторы. Вы можете сделать несколько копий однонаправленного итератора, каждая из которых может быть разыменована и для нее может быть выполнено независимое приращение. Прямой итератор, который инициализируется без ссылки на любой контейнер называется *пустом однонаправленном итераторе*. Пустые однонаправленные итераторы всегда равны.

- **Двунаправленный**. Объект *Двунаправленный итератор* `X` может использоваться вместо прямого итератора. Вы можно также выполнить уменьшение двунаправленного итератора, как показано на `--X`, `X--`, или `(V = *X--)`. Получить доступ к членам элементов и сравнить двунаправленные итераторы можно так же, как и однонаправленные итераторы.

- **Произвольный доступ**. Объект *итератор произвольного доступа,* `X` может использоваться вместо двунаправленного итератора. С итератором произвольного доступа можно использовать оператор индекса  **\[]** для доступа к элементам. Можно использовать **+**, **-**, **+=** и **-=** операторы для перемещения вперед или назад указанного числа элементов, для вычисления расстояния между итераторами. Вы можете сравнить Двунаправленные итераторы с помощью **==**, **! =**, **\<**, **>**, **\< =**, и **>=**.

Все итераторы можно назначать и копировать. Они считаются простыми объектами и поэтому часто передаются и возвращаются по значению, а не по ссылке. Обратите внимание, что ни одна из операций, описанных выше, не может создавать исключения при выполнении с допустимым итератором.

Иерархия категорий итераторов может быть представлена в виде трех последовательностей. Для доступа в режиме только для записи в последовательность можно использовать любой из следующих итераторов.

> итератор вывода<br/>
> "->" прямой итератор<br/>
> "->" Двунаправленный итератор<br/>
> "->" итератор произвольного доступа<br/>

Стрелка вправо означает "могут быть заменены". Любой алгоритм, использующий итератор вывода, должен хорошо работать, например, с однонаправленным итератором, но *не* наоборот.

Для доступа в режиме только для чтения в последовательность можно использовать любой из следующих итераторов.

> итератор ввода<br/>
> "->" прямой итератор<br/>
> "->" Двунаправленный итератор<br/>
> "->" итератор произвольного доступа<br/>

Итератор ввода является самым слабым по всем категориям в этом смысле.

Наконец, для доступа в режиме чтения и записи в последовательность можно использовать любой из следующих итераторов.

> прямой итератор<br/>
> "->" Двунаправленный итератор<br/>
> "->" итератор произвольного доступа<br/>

Указатель на объект всегда можно использовать как итератор произвольного доступа, поэтому он может относиться к любой категории итераторов, если он поддерживает необходимый уровень доступа для чтения и записи в последовательность, которую он обозначает.

Итератор `Iterator`, не являющийся указателем на объект, должен также определять типы элементов, необходимые для специализации `iterator_traits<Iterator>`. Обратите внимание, что эти требования могут быть выполнены путем наследования `Iterator` от общего базового класса [iterator](../standard-library/iterator-struct.md).

Важно знать возможности и ограничения каждой категории итераторов, чтобы понимать, как итераторы используются контейнерами и алгоритмами в стандартной библиотеке С++.

> [!NOTE]
> Вы можете избежать явного использования итераторов с помощью циклов range-for. Дополнительные сведения см. в разделе [основанных на диапазоне оператор for](../cpp/range-based-for-statement-cpp.md).

Visual C++ теперь предоставляет проверяемые итераторы и итераторы, чтобы убедиться, что вы не переопределите границ контейнера. Дополнительные сведения см. в разделах [Проверяемые итераторы](../standard-library/checked-iterators.md) и [Поддержка отладочных итераторов](../standard-library/debug-iterator-support.md).

## <a name="see-also"></a>См. также

[Справочник по стандартной библиотеке C++](../standard-library/cpp-standard-library-reference.md)<br/>
[Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)<br/>
