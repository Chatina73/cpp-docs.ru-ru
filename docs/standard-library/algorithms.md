---
title: Алгоритмы
ms.date: 10/18/2018
helpviewer_keywords:
- libraries [C++], C++ algorithm conventions
- algorithms [C++], C++
- C++ Standard Library, algorithms
- algorithm template function C++ library conventions
- conventions [C++], C++ algorithm
ms.assetid: dec9b373-7d5c-46cc-b7d2-21a938ecd0a6
ms.openlocfilehash: d363dc3f06222121ac5efc79b30516ebd55ff539
ms.sourcegitcommit: 0dcab746c49f13946b0a7317fc9769130969e76d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/24/2019
ms.locfileid: "68456489"
---
# <a name="algorithms"></a>Алгоритмы

Алгоритмы являются важнейшей частью стандартной библиотеки C++. Алгоритмы работают с контейнерами не самостоятельно, а с помощью итераторов. Поэтому один и тот же алгоритм можно использовать с большинством, а то и со всеми контейнерами стандартной библиотеки C++. В этом разделе рассматриваются правила и терминология алгоритмов стандартной библиотеки C++.

## <a name="remarks"></a>Примечания

В описаниях функций шаблонов алгоритмов используется ряд стандартных сокращенных фраз:

- Фраза "в диапазоне \[*объект*, *B*)» означает последовательность из нуля или более дискретных значений, начиная с версии *объект* до, но не включая *B*. Диапазон является допустимым только если *B* доступен с *A;* можно хранить *объект* в объекте *N* (*N*  =  *Объект*), увеличить объект ноль или более раз (++*N*), и объект равны *B* после конечного числа увеличивает (*N*  ==  *B*).

- Фраза "каждый *N* в диапазоне \[*объект*, *B*)» означает, что *N* начинается со значения *A*и приращивается ноль или более раз, пока не будет равно значению *B*. Случай *N* == *B* не находится в диапазоне.

- Фраза «самое низкое значение *N* в диапазоне \[ *a*, *B*) таким образом, что *x*» означает, что условие *x* определяется для каждого *N* в \[диапазоне *a*, *b*) до тех пор, пока условие *X* выполнено.

- Фраза «наибольшее значение *N* в диапазоне \[ *A*, *B*) означает, что *x* определяется для каждого  *N* в диапазоне \[ *A*, *b*). Функция сохраняет в *K* копию *N* каждый раз, когда достигается условие *X* . Если происходит такое хранилище, функция заменяет конечное значение *N*, которое равно *B*, значением *K*. Для двунаправленного итератора или итератора произвольного доступа это также может означать, что *N* начинается с наибольшего значения в диапазоне и постепенно уменьшается вплоть до выполнения условия *X*.

- Такие выражения, как *X* - *Y*, где *X* и *Y* могут быть итераторами, отличными от итераторов произвольного доступа, предусмотрены по математическим соображениям. Функция не обязательно вычисляет оператор **-** если она должна определить такое значение. То же справедливо и для таких выражений, как *X* + *N* и *X* - *N*, где *N* имеет тип integer.

Несколько алгоритмов используют предикат, который выполняет попарное сравнение, например с `operator==`, для получения **логического** результата. Функция предиката `operator==` или любая ее замена не должны изменять ни один из операндов. Он должен возвращать один и тот же **логический** результат при каждом вычислении, и он должен дать тот же результат, если для операнда заменяется копия любого из операндов.

Некоторые алгоритмы используют предикат, который налагает строгое слабое упорядочение к парам элементов из последовательности. Для предиката " *пред*" (*X*, *Y*):

- В-смысле, значение " *пред*" (*x*, *x*) равно "false".

- Слабое означает, что *X* и *y* имеют эквивалентное \!упорядочение, если " *пред*" ( \!*x*, *Y*) & & " *пред*" (*y*, *x*) (*x* == *Y* не необходимо определить).

- Упорядочение означает, что " *пред*" (*x*, *Y*) & & " *пред*" (*y*, *z*) подразумевает " *пред*" (*x*, *z*).

Некоторые из алгоритмов неявно используют предикат *X* \< *Y*. Другие предикаты, которые обычно отвечают строгим требованиям к слабому упорядочению, — это *x* > *Y*, `greater` `less`(*x*, *y*) и (*x*, *y*). Однако обратите внимание, что такие предикаты, как *X* \<= *Y* и *X* >= *Y*, не удовлетворяют этим требованиям.

Последовательность элементов, обозначенная итераторами в диапазоне \[*первый*, *последнего*) является последовательностью, упорядоченной оператором **<** Если для каждого *N* в диапазоне \[0, *последнего* - *первый*) и для каждого *M* в диапазоне (*N*, *Последнего* - *первый*) предикат \!(\*(*первый* + *M*) < \*(*первый* + *N*)) имеет значение true. (Обратите внимание, что элементы сортируются по возрастанию). Функция предиката `operator<` или любая ее замена не должны изменять ни один из операндов. Он должен возвращать один и тот же **логический** результат при каждом вычислении, и он должен дать тот же результат, если для операнда заменяется копия любого из операндов. Кроме того она должен применить строгого слабое упорядочение с операндами, которые она сравнивает.

Последовательность элементов, обозначенных итераторами в диапазоне \[ \[ `Last` `First`, — это куча, упорядоченная `operator<` по, если для каждого *N* в диапазоне 1, *последним* - *первым*) Предикат \!(\*_First_ *(First*N))имеет значение true. +  < \* (Первый элемент является наибольшим.) Его внутренняя структура в противном случае известна только для функций-шаблонов [make_heap](../standard-library/algorithm-functions.md#make_heap), [pop_heap](../standard-library/algorithm-functions.md#pop_heap)и [push_heap](../standard-library/algorithm-functions.md#push_heap). Как и в случае с упорядоченной последовательностью, функция `operator<`предиката или любая замена для нее не должна изменять ни один из своих операндов, и она должна накладывать строгое слабое упорядочивание сравниваемых операндов. Он должен возвращать один и тот же **логический** результат при каждом вычислении, и он должен дать тот же результат, если для операнда заменяется копия любого из операндов.

Алгоритмы стандартной библиотеки C++ находятся в файлах заголовков [\<algorithm>](../standard-library/algorithm.md) и [\<numeric>](../standard-library/numeric.md).

## <a name="see-also"></a>См. также

[Справочник по стандартной библиотеке C++](../standard-library/cpp-standard-library-reference.md)\
[Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)
