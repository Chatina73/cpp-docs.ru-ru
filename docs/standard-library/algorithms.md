---
title: Алгоритмы
ms.date: 10/18/2018
helpviewer_keywords:
- libraries [C++], C++ algorithm conventions
- algorithms [C++], C++
- C++ Standard Library, algorithms
- algorithm template function C++ library conventions
- conventions [C++], C++ algorithm
ms.assetid: dec9b373-7d5c-46cc-b7d2-21a938ecd0a6
ms.openlocfilehash: a0a1165d731e44568d530e3ed919d73e2a3e8e5e
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50648036"
---
# <a name="algorithms"></a>Алгоритмы

Алгоритмы являются важнейшей частью стандартной библиотеки C++. Алгоритмы работают с контейнерами не самостоятельно, а с помощью итераторов. Поэтому один и тот же алгоритм можно использовать с большинством, а то и со всеми контейнерами стандартной библиотеки C++. В этом разделе рассматриваются правила и терминология алгоритмов стандартной библиотеки C++.

## <a name="remarks"></a>Примечания

В описаниях функций шаблонов алгоритмов используется ряд стандартных сокращенных фраз:

- Фраза "в диапазоне \[ *объект*, *B*)» означает последовательность из нуля или более дискретных значений, начиная с версии *объект* до, но не включая *B* . Диапазон является допустимым только если *B* доступен с *A;* можно хранить *объект* в объекте *N* (*N*  =  *Объект*), увеличить объект ноль или более раз (++*N*), и объект равны *B* после конечного числа увеличивает (*N*  ==  *B*).

- Фраза "каждый *N* в диапазоне \[ *объект*, *B*)» означает, что *N* начинается со значения *A*и приращивается ноль или более раз, пока не будет равно значению *B*. Случай *N* == *B* не находится в диапазоне.

- Фраза "наименьшее значение *N* в диапазоне \[ *объект*, *B*) таким образом, чтобы *X*" означает, что условие *X* определяется для каждого *N* в диапазоне \[ *объект*, *B*) вплоть до выполнения условия *X*удовлетворяется.

- Фраза "наибольшее значение *N* в диапазоне \[ *объект*, *B*) таким образом, чтобы *X* означает, что *X* определяется для каждого *N* в диапазоне \[ *объект*, *B*). Функция сохраняет в *K* копию *N* каждый раз при выполнении условия *X* удовлетворяется. При каждом таком сохранении функция заменяет конечное значение *N*, равное *B*, со значением *K*. Для двунаправленного итератора или итератора произвольного доступа это также может означать, что *N* начинается с наибольшего значения в диапазоне и постепенно уменьшается вплоть до выполнения условия *X*.

- Такие выражения, как *X* - *Y*, где *X* и *Y* могут быть итераторами, отличными от итераторов произвольного доступа, предусмотрены по математическим соображениям. Функция не обязательно вычисляет оператор **-** если она должна определить такое значение. То же справедливо и для таких выражений, как *X* + *N* и *X* - *N*, где *N* имеет тип integer.

Некоторые алгоритмы используют предикат, выполняющие попарное сравнение, например с `operator==`, для получения **bool** результат. Функция предиката `operator==` или любая ее замена не должны изменять ни один из операндов. Она должна возвращать одинаковый **bool** привести каждый раз, оно вычисляется, и она должна возвращать тот же результат, если операнд заменяется копию один из операндов.

Некоторые алгоритмы используют предикат, который налагает строгое слабое упорядочение к парам элементов из последовательности. Для предиката *pred*(*X*, *Y*):

- Strict означает, что *pred*(*X*, *X*) имеет значение false.

- Weak означает, что *X* и *Y* имеют эквивалентное упорядочение, если \! *pred*(*X*, *Y*) & & \! *pred*(*Y*, *X*) (*X* == *Y*не должны быть определены).

- Упорядочение означает, что *pred*(*X*, *Y*) & & *pred*(*Y*, *Z*) подразумевает *pred*(*X*, *Z*).

Некоторые из алгоритмов неявно используют предикат *X* \< *Y*. Другие предикаты, обычно удовлетворяющие требованию строгого слабого упорядочения: *X* > *Y*, `less`(*X*, *Y*), и `greater`(*X*, *Y*). Однако обратите внимание, что такие предикаты, как *X* \<= *Y* и *X* >= *Y*, не удовлетворяют этим требованиям.

Последовательность элементов, обозначенная итераторами в диапазоне \[ *первый*, *последнего*) является последовательностью, упорядоченной оператором **<** Если для каждого  *N* в диапазоне \[0, *последнего* - *первый*) и для каждого *M* в диапазоне (*N*, *Последнего* - *первый*) предикат \!(\*(*первый*  +  *M*) < \*(*первый* + *N*)) имеет значение true. (Обратите внимание, что элементы сортируются по возрастанию). Функция предиката `operator<` или любая ее замена не должны изменять ни один из операндов. Она должна возвращать одинаковый **bool** привести каждый раз, оно вычисляется, и она должна возвращать тот же результат, если операнд заменяется копию один из операндов. Кроме того она должен применить строгого слабое упорядочение с операндами, которые она сравнивает.

Последовательность элементов, обозначенная итераторами в диапазоне \[ `First`, `Last`) является кучей, упорядоченной по `operator<` Если для каждого *N* в диапазоне \[1, *последнего*  -  *Первый*) предикат \!(\*_первый_ < \*(*первый*  +  *N*)) имеет значение true. (Первый элемент является наибольшим.) Его внутренняя структура иначе известна только для функций шаблона [make_heap](../standard-library/algorithm-functions.md#make_heap), [pop_heap](../standard-library/algorithm-functions.md#pop_heap), и [push_heap](../standard-library/algorithm-functions.md#push_heap). Как и в упорядоченной последовательности, функция предиката `operator<`, или любая ее замена, не должна изменять его операнды и должна налагать строгое слабое упорядочение на сравниваемые операнды. Она должна возвращать одинаковый **bool** привести каждый раз, оно вычисляется, и она должна возвращать тот же результат, если операнд заменяется копию один из операндов.

Алгоритмы стандартной библиотеки C++ находятся в файлах заголовков [\<algorithm>](../standard-library/algorithm.md) и [\<numeric>](../standard-library/numeric.md).

## <a name="see-also"></a>См. также

[Справочник по стандартной библиотеке C++](../standard-library/cpp-standard-library-reference.md)<br/>
[Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)<br/>
