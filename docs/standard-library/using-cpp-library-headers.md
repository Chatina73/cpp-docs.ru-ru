---
title: Использование заголовков библиотеки C++
ms.date: 11/04/2016
helpviewer_keywords:
- headers, naming in C++ include directive
- standard header in C++
- headers
- INCLUDE directive
- headers, C++ Standard Library
- library headers
- C++ Standard Library, headers
ms.assetid: a36e889e-1af2-4cd9-a211-bfc7a3fd8e85
ms.openlocfilehash: 9cc0bb51b159f6668adad05ebd2d386364ae2f81
ms.sourcegitcommit: 0dcab746c49f13946b0a7317fc9769130969e76d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/24/2019
ms.locfileid: "68450063"
---
# <a name="using-c-library-headers"></a>Использование заголовков библиотеки C++

Чтобы включить содержимое стандартного заголовка, необходимо указать его рядом с директивой include.

```cpp
#include <iostream>// include I/O facilities
```

Вы можете включать стандартные заголовки в любом порядке — вы можете включить несколько стандартных заголовков или два или более стандартных заголовка, которые определяют один и тот же макрос или один и тот же тип. Не следует включать стандартный заголовок в объявление. Не следует определять макросы, имена которых совпадают с ключевыми словами, до включения стандартного заголовка.

Заголовок библиотеки C++ включает все остальные заголовки библиотеки C++ для определения необходимых типов. (Всегда явным образом включайте все заголовки библиотеки C++ в блок преобразования, за исключением случая, когда вы плохо представляете себе фактические зависимости блока.) Стандартный заголовок в языке C никогда не включает в себя другой стандартный заголовок. Стандартный заголовок объявляет и определяет только сущности, описанные для него в этом документе.

Каждая функция в библиотеке объявляется в стандартном заголовке. В отличие от стандартного языка C стандартный заголовок никогда не предоставляет маскирование макроса с тем же именем по аналогии с функцией, которая маскирует объявление функции и позволяет добиться того же эффекта. Дополнительные сведения о маскировании макросов см. в разделе [Соглашения библиотеки C++](../standard-library/cpp-library-conventions.md).

Все имена C++ `std` ,отличныеотоператоровDELETEиNewвзаголовкахбиблиотек,определяютсявпространствеимениливпространствеимен,вложенномвпространствоимен.`std` Вы ссылаетесь на имя `cin`, например `std::cin`. Обратите внимание, что имена макросов не подлежат квалификации пространства имен, поэтому всегда используйте форму `__STD_COMPLEX`, без квалификатора пространства имен.

В некоторых средах преобразования, включая C++ заголовок библиотеки, может также посчитать внешние имена `std` , объявленные в пространстве имен, в глобальное пространство имен, при этом отдельные объявления **используются** для каждого из имен. В противном случае заголовок *не* добавляет никаких библиотечных имен в текущее пространство имен.

C++ Стандарт требует, чтобы стандартные заголовки C объявляют все внешние имена в пространстве имен `std`, а затем передают их в глобальное пространство имен с **использованием** отдельных объявлений для каждого имени. Однако в некоторых средах преобразования в стандарте C заголовки не включают объявлений пространств имен и все имена объявляются непосредственно в глобальном пространстве имен. Таким образом, для обеспечения максимальной переносимости при работе с пространствами имен следует соблюдать два правила:

- Объявлять в пространстве имен `std` внешние имена, которые традиционно объявляются в \<stdlib.h>, включая заголовок \<cstdlib>. Помнить, что имена также могут быть объявлены в глобальном пространстве имен.

- Объявлять в глобальном пространстве имен внешние имена, объявленные в \<stdlib.h>, включая заголовок \<stdlib.h>. Помнить, что имена также могут быть объявлены в пространстве имен `std`.

Таким образом, если вы хотите, чтобы вызов `std::abort` привел к аварийному завершению работы, следует включить заголовок \<cstdlib>. Если вы хотите вызвать `abort`, следует включить заголовок \<stdlib.h>.

Также можно написать объявление:

```cpp
using namespace std;
```

которое переводит все имена библиотек в текущее пространство имен. Если разместить это объявление сразу после всех директив include, вы расширите имена в глобальное пространство имен. В оставшейся части записи блока преобразования пространства имен можно не учитывать. Вы также сможете избежать большинства различий между различными средами преобразования.

Если явно не указано иначе, вы не можете определять в своей программе имена в пространстве имен `std` или пространстве имен, вложенном в пространство имен `std`.

## <a name="see-also"></a>См. также

[Общие сведения о стандартной библиотеке C++](../standard-library/cpp-standard-library-overview.md)\
[Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)
