---
title: Использование заголовков библиотеки C++
ms.date: 11/04/2016
helpviewer_keywords:
- headers, naming in C++ include directive
- standard header in C++
- headers
- INCLUDE directive
- headers, C++ Standard Library
- library headers
- C++ Standard Library, headers
ms.assetid: a36e889e-1af2-4cd9-a211-bfc7a3fd8e85
ms.openlocfilehash: a73ebebb4fdde5dd72f148390d004c32b9f4dff7
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87215482"
---
# <a name="using-c-library-headers"></a>Использование заголовков библиотеки C++

Чтобы включить содержимое стандартного заголовка, необходимо указать его рядом с директивой include.

```cpp
#include <iostream>// include I/O facilities
```

Вы можете включать стандартные заголовки в любом порядке — вы можете включить несколько стандартных заголовков или два или более стандартных заголовка, которые определяют один и тот же макрос или один и тот же тип. Не следует включать стандартный заголовок в объявление. Не следует определять макросы, имена которых совпадают с ключевыми словами, до включения стандартного заголовка.

Заголовок библиотеки C++ включает все остальные заголовки библиотеки C++ для определения необходимых типов. (Всегда включайте в себя явно все заголовки библиотек C++, необходимые в записи преобразования, однако, допустим, что вы не знаете о фактических зависимостях.) Стандартный заголовок C никогда не включает другой стандартный заголовок. Стандартный заголовок объявляет и определяет только сущности, описанные для него в этом документе.

Каждая функция в библиотеке объявляется в стандартном заголовке. В отличие от стандартного языка C стандартный заголовок никогда не предоставляет маскирование макроса с тем же именем по аналогии с функцией, которая маскирует объявление функции и позволяет добиться того же эффекта. Дополнительные сведения о маскировании макросов см. в разделе [Соглашения библиотеки C++](../standard-library/cpp-library-conventions.md).

Все имена, кроме **оператора delete** и **New** в заголовках библиотеки C++, определяются в `std` пространстве имен или в пространстве имен, вложенном в `std` пространство имен. Вы ссылаетесь на имя `cin`, например `std::cin`. Обратите внимание, что имена макросов не подлежат квалификации пространства имен, поэтому всегда используйте форму `__STD_COMPLEX`, без квалификатора пространства имен.

В некоторых средах преобразования, включая заголовок библиотеки C++, могут также посчитать внешние имена, объявленные в `std` пространстве имен, в глобальном пространстве имен с отдельными **`using`** объявлениями для каждого имени. В противном случае заголовок *не* добавляет никаких библиотечных имен в текущее пространство имен.

Стандарт C++ требует, чтобы стандартные заголовки C объявляют все внешние имена в пространстве имен `std` , а затем передают их в глобальное пространство имен с отдельными **`using`** объявлениями для каждого имени. Однако в некоторых средах преобразования в стандарте C заголовки не включают объявлений пространств имен и все имена объявляются непосредственно в глобальном пространстве имен. Таким образом, для обеспечения максимальной переносимости при работе с пространствами имен следует соблюдать два правила:

- Для гарантированного объявления в пространстве имен `std` внешнее имя, которое традиционно объявлено в \<stdlib.h> , например, включает заголовок \<cstdlib> . Помнить, что имена также могут быть объявлены в глобальном пространстве имен.

- Для гарантированного объявления в глобальном пространстве имен внешнее имя, объявленное в \<stdlib.h> , включите заголовок \<stdlib.h> напрямую. Помнить, что имена также могут быть объявлены в пространстве имен `std`.

Таким образом, если вы хотите вызвать метод `std::abort` для аварийного завершения, следует включить \<cstdlib> . Если вы хотите вызвать `abort` , следует включить \<stdlib.h> .

Также можно написать объявление:

```cpp
using namespace std;
```

которое переводит все имена библиотек в текущее пространство имен. Если разместить это объявление сразу после всех директив include, вы расширите имена в глобальное пространство имен. В оставшейся части записи блока преобразования пространства имен можно не учитывать. Вы также сможете избежать большинства различий между различными средами преобразования.

Если явно не указано иначе, вы не можете определять в своей программе имена в пространстве имен `std` или пространстве имен, вложенном в пространство имен `std`.

## <a name="see-also"></a>См. также раздел

[Общие сведения о стандартной библиотеке C++](../standard-library/cpp-standard-library-overview.md)\
[Безопасность потоков в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)
