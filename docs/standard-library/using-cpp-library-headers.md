---
title: Использование заголовков библиотеки C++
ms.date: 11/04/2016
helpviewer_keywords:
- headers, naming in C++ include directive
- standard header in C++
- headers
- INCLUDE directive
- headers, C++ Standard Library
- library headers
- C++ Standard Library, headers
ms.assetid: a36e889e-1af2-4cd9-a211-bfc7a3fd8e85
ms.openlocfilehash: b9841d1045a6d2d1126414f1ce4cfc93f9667eef
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62362374"
---
# <a name="using-c-library-headers"></a>Использование заголовков библиотеки C++

Чтобы включить содержимое стандартного заголовка, необходимо указать его рядом с директивой include.

```cpp
#include <iostream>// include I/O facilities
```

Вы можете включать стандартные заголовки в любом порядке — вы можете включить несколько стандартных заголовков или два или более стандартных заголовка, которые определяют один и тот же макрос или один и тот же тип. Не следует включать стандартный заголовок в объявление. Не следует определять макросы, имена которых совпадают с ключевыми словами, до включения стандартного заголовка.

Заголовок библиотеки C++ включает все остальные заголовки библиотеки C++ для определения необходимых типов. (Всегда явным образом включайте все заголовки библиотеки C++ в блок преобразования, за исключением случая, когда вы плохо представляете себе фактические зависимости блока.) Стандартный заголовок в языке C никогда не включает в себя другой стандартный заголовок. Стандартный заголовок объявляет и определяет только сущности, описанные для него в этом документе.

Каждая функция в библиотеке объявляется в стандартном заголовке. В отличие от стандартного языка C стандартный заголовок никогда не предоставляет маскирование макроса с тем же именем по аналогии с функцией, которая маскирует объявление функции и позволяет добиться того же эффекта. Дополнительные сведения о маскировании макросов см. в разделе [Соглашения библиотеки C++](../standard-library/cpp-library-conventions.md).

Все имена, отличные от **оператор delete** и **оператор new** определенные заголовки библиотеки C++ в `std` пространства имен, или в пространстве имен, вложенным в `std` пространства имен. Вы ссылаетесь на имя `cin`, например `std::cin`. Обратите внимание, что имена макросов не подлежат квалификации пространства имен, поэтому всегда используйте форму `__STD_COMPLEX`, без квалификатора пространства имен.

В некоторых средах перевода включение заголовка библиотеки C++ может привести к добавлению внешних имен, объявленных в `std` пространства имен в глобальном пространстве имен, с отдельными **с помощью** объявлениями для каждого из имен. В противном случае заголовок *не* добавляет никаких библиотечных имен в текущее пространство имен.

Стандарт C++ требует, что в стандарте C заголовки объявить все внешние имена в пространство имен `std`, затем помещать их в глобальном пространстве имен с отдельными **с помощью** объявлениями для каждого из имен. Однако в некоторых средах преобразования в стандарте C заголовки не включают объявлений пространств имен и все имена объявляются непосредственно в глобальном пространстве имен. Таким образом, для обеспечения максимальной переносимости при работе с пространствами имен следует соблюдать два правила:

- Объявлять в пространстве имен `std` внешние имена, которые традиционно объявляются в \<stdlib.h>, включая заголовок \<cstdlib>. Помнить, что имена также могут быть объявлены в глобальном пространстве имен.

- Объявлять в глобальном пространстве имен внешние имена, объявленные в \<stdlib.h>, включая заголовок \<stdlib.h>. Помнить, что имена также могут быть объявлены в пространстве имен `std`.

Таким образом, если вы хотите, чтобы вызов `std::abort` привел к аварийному завершению работы, следует включить заголовок \<cstdlib>. Если вы хотите вызвать `abort`, следует включить заголовок \<stdlib.h>.

Также можно написать объявление:

```cpp
using namespace std;
```

которое переводит все имена библиотек в текущее пространство имен. Если разместить это объявление сразу после всех директив include, вы расширите имена в глобальное пространство имен. В оставшейся части записи блока преобразования пространства имен можно не учитывать. Вы также сможете избежать большинства различий между различными средами преобразования.

Если явно не указано иначе, вы не можете определять в своей программе имена в пространстве имен `std` или пространстве имен, вложенном в пространство имен `std`.

## <a name="see-also"></a>См. также

[Общие сведения о стандартной библиотеке C++](../standard-library/cpp-standard-library-overview.md)<br/>
[Потокобезопасность в стандартной библиотеке C++](../standard-library/thread-safety-in-the-cpp-standard-library.md)<br/>
