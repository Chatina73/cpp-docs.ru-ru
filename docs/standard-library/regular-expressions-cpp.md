---
title: Регулярные выражения (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- regular expressions [C++]
ms.assetid: aafe202a-1d96-4b36-a270-d676dfd3c51c
ms.openlocfilehash: 291b25959f790db328080aa74a6320775a33e981
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2019
ms.locfileid: "65220311"
---
# <a name="regular-expressions-c"></a>Регулярные выражения (C++)

Стандартная библиотека C++ поддерживает несколько грамматиках регулярных выражений. В этом разделе рассматриваются доступные варианты грамматики, при использовании регулярных выражений.

## <a name="regexgrammar"></a> Грамматика регулярных выражений

Грамматика регулярных выражений для использования с указывается с помощью одного из `std::regex_constants::syntax_option_type` значений перечисления. Эти грамматиках регулярных выражений определяются в std::regex_constants:

- `ECMAScript`: Это наиболее близкое к грамматике, используемые JavaScript, а также на языках .NET.
- `basic`: POSIX основные регулярных выражений или BRE.
- `extended`: POSIX расширенных регулярных выражений или ERE.
- `awk`: Это `extended`, но у него есть дополнительные escape-последовательности для непечатаемые символы.
- `grep`: Это `basic`, но также позволяет новой строки («\n») символы для разделения чередований.
- `egrep`: Это `extended`, но это также позволяет символы новой строки для разделения чередований.

По умолчанию, если указан не грамматики `ECMAScript` предполагается, что. Может быть указан только один грамматики.

В дополнение к грамматики можно применить несколько флагов:
- `icase`: Не учитывать регистр при сопоставлении.
- `nosubs`: Пропустить помеченной совпадения (то есть выражения в скобках); Нет замены, сохраняются.
- `optimize`: Упростить быстрее за счет возможного больше времени создания.
- `collate`: Использование параметров сортировки с учетом языкового стандарта (например, диапазоны в формате «[a-z]»).

Ноль или несколько флагов могут быть объединены с грамматикой для указания поведения обработчик регулярных выражений. Если только указаны флаги, `ECMAScript` считается грамматики.

### <a name="element"></a>Элемент

Элемент может представлять собой один из указанных ниже объектов:

- *Обычный символ*, который соответствует такому же символу в целевой последовательности.

- *Символ-шаблон* ".", который соответствует любому символу в целевой последовательности, кроме символа новой строки.

- *Выражение в квадратных скобках* в формате "[`expr`]", который соответствует символу или элементу таблицы сортировки в целевой последовательности, также представленному в наборе, заданном выражением `expr`; или в формате "[^`expr`]", который соответствует символу или элементу таблицы сортировки в целевой последовательности, не представленном в наборе, заданном выражением `expr`.

   Выражение `expr` может содержать любое сочетание следующих объектов:

   - Отдельный символ. Добавление символа в набор, заданный выражением `expr`.

   - *Диапазон символов* в формате "`ch1`-`ch2`". Добавление символов, представленных значениями в закрытом диапазоне [`ch1`] `ch2`, в набор, определенный выражением `expr`.

   - *Класс символов* в формате "[:`name`:]". Добавление символов в именованном классе в набор, заданный выражением `expr`.

   - *Класс эквивалентности* в формате "[=`elt`=]". Добавление элементов упорядочивания, эквивалентных `elt`, в набор, заданный выражением `expr`.

   - *Символ упорядочения* в формате "[.`elt`.]". Добавление элемента упорядочения `elt` в набор, заданный выражением `expr`.

- *Привязка*. Привязка "^" соответствует началу целевой последовательности; привязка "$" соответствует концу целевой последовательности.

*Группа захвата* в формате "(*часть выражения*)" или "\\(*часть выражения* \\)" в `basic` и `grep`, соответствующая последовательности символов в целевой последовательности, которой соответствует шаблон между разделителями.

- *escape-удостоверение* в формате "\\`k`", соответствующее символу `k` в целевой последовательности.

Примеры

- "a" соответствует целевой последовательности "a", но не соответствует целевой последовательности "B", "b" или "c".

- "." соответствует всем целевым последовательностям "a", "B", "b" и "c".

- "[b-z]" соответствует целевым последовательностям "b" и "c", но не соответствует целевым последовательностям "a" или "B".

- "[:lower:]" соответствует целевым последовательностям "a", "b" и "c", но не соответствует целевой последовательности "B".

- "(a)" соответствует целевой последовательности "a" и связывает группу захвата 1 с частью последовательности "a", но не соответствует целевым последовательностям "B", "b" или "c".

В `ECMAScript`, `basic` и `grep` элемент также может быть *обратной ссылкой* в формате "\\`dd`", где `dd` представляет десятичное значение N, которое соответствует последовательности символов в целевой последовательности, совпадающей с последовательностью символов, соответствующих N-й *группе захвата*. Например, "(a)\1" соответствует целевой последовательности "aa", поскольку первая (и единственная) группа захвата соответствует первоначальной последовательности "a", а затем \1 соответствует завершающей последовательности "a".

В `ECMAScript` элемент также может являться одним из приведенных ниже объектов:

- Объект *группа незахвата* формы "(?: *subexpression* )». Соответствует последовательности символов в целевой последовательности, которой соответствует шаблон между разделителями.

- Ограниченное *escape-выражение формата файла* в формате "\f", "\n", "\r", "\t" или "\v". В целевой последовательности они соответствуют символам перевода строки, возврата каретки, горизонтальной табуляции и вертикальной табуляции, в порядке перечисления.

- *Положительное утверждение* в формате "(= *часть выражения*)". Соответствует последовательности символов в целевой последовательности, которой соответствует шаблон между разделителями, но которая не меняет позицию соответствия в целевой последовательности.

- *Отрицательное утверждение* в формате "(! *часть выражения*)". Соответствует любой последовательности символов в целевой последовательности, которой не соответствует шаблон между разделителями и которая не меняет позицию соответствия в целевой последовательности.

- *Шестнадцатеричная escape-последовательность* в формате "\x`hh`". Соответствует символу в целевой последовательности, представленному двумя шестнадцатеричными цифрами `hh`.

- *Escape-последовательность Юникод* в формате "\u`hhhh`". Соответствует символу в целевой последовательности, представленному четырьмя шестнадцатеричными цифрами `hhhh`.

- *Управляющая escape-последовательность* в формате "\c`k`". Совпадает с управляющим символом, который именуется символом `k`.

- *Утверждение границы слова* в формате "\b". Совпадает, если текущая позиция в целевой последовательности расположена сразу после *границы слова*.

- *Отрицательное утверждение границы слова* в формате "\B". Совпадает, если текущая позиция в целевой последовательности расположена не сразу после *границы слова*.

- *Escape-последовательность DSW* в формате "\d", "\D", "\s", "\S", "\w", "\W". Обеспечивает краткое имя класса символов.

Примеры

- "(?:a)" соответствует целевой последовательности "a", но "(?:a)\1" является недействительным по причине отсутствия группы захвата 1.

- "(=a)a" соответствует целевой последовательности "a". Положительное утверждение соответствует первоначальной последовательности "a" в целевой последовательности, и завершающий символ "a" в регулярном выражении соответствует первоначальной последовательности "a" в целевой последовательности.

- "(!a)a" не соответствует целевой последовательности "a".

- "a\b." соответствует целевой последовательности "a~", но не соответствует целевой последовательности "ab".

- "a\B." соответствует целевой последовательности "ab", но не соответствует целевой последовательности "a~".

В `awk` элемент также может являться одним из приведенных ниже объектов:

- *Escape-выражение формата файлов* в формате "\\\\", "\a", "\b", "\f", "\n", "\r", "\t" или "\v". В целевой последовательности они соответствуют символам обратной косой черты, оповещения, стирания назад, перевода строки, возврата каретки, горизонтальной табуляции и вертикальной табуляции, в порядке перечисления.

- *Восьмеричная escape-последовательность* в формате "\\`ooo`". Соответствует символу в целевой последовательности, представлением которого является значение, представленное одной, двумя или тремя восьмеричными цифрами `ooo`.

### <a name="repetition"></a>Повторение

За любым элементом, кроме *положительного утверждения*, *отрицательного утверждения* или *привязки*, может следовать число повторений. Наиболее распространенный тип числа повторений имеет формат "{`min`,`max`}" или "\\{`min`,`max`\\}" в `basic` и `grep`. Элемент, за которым следует такой формат числа повторений, соответствует числу успешных вхождений последовательности, соответствующей элементу, не менее `min` и не более `max`. Например «{2,3}"соответствует целевой последовательности «aa» и целевой последовательности «aaa», но не целевой последовательности «» или целевой последовательности «aaaa».

Число повторений также может иметь один из перечисленных ниже форматов:

- "{`min`}" или "\\{`min`\\}" в `basic` и `grep`. Аналогично "{`min`,`min`}".

- "{`min`,}" или "\\{`min`,\\}" в `basic` и `grep`. Аналогично "{`min`,unbounded}".

- "\*". Аналогично "{0,unbounded}".

Примеры

- «{2}"соответствует целевой последовательности «aa», но не целевой последовательности «» или целевой последовательности «aaa».

- «{2,}"соответствует целевой последовательности «aa», целевой последовательности «aaa» и т. д., но не соответствует целевой последовательности «».

- «\*"соответствует целевой последовательности «», целевой последовательности «», целевой последовательности «aa» и т. д.

Для всех грамматик, кроме `basic` и `grep`, число повторений также может обладать одним из следующих форматов:

- "?". Эквивалентно "{0,1}«.

- "+". Аналогично "{1,unbounded}".

Примеры

- «?» соответствует целевой последовательности «» и целевой последовательности «a», но не целевой последовательности «aa».

- "a+" соответствует целевой последовательности "a", целевой последовательности "aa" и т.д., но не целевой последовательности "".

В `ECMAScript`, все виды число повторений может следовать символ "?", указывающий *нежадном повторение*.

### <a name="concatenation"></a>Сцепление

Элементы регулярного выражения с *числом повторений* или без него можно объединять для формирования более длинных регулярных выражений. Результирующее выражение соответствует целевой последовательности, которая является объединением последовательностей, соотнесенных по отдельным элементам. Например «{2,3}b» соответствует целевой последовательности «aab» и целевой последовательности «aaab», но не соответствует целевой последовательности «ab» или целевой последовательности «aaaab».

### <a name="alternation"></a>Чередование

Во всех грамматиках регулярных выражений, кроме `basic` и `grep`, за соединенным регулярным выражением может следовать символ "&#124;" и другое соединенное регулярное выражение. Таким образом можно объединить любое количество регулярных выражений. Результирующее выражение соответствует любой целевой последовательности, которая соответствует одному или нескольким соединенным регулярным выражением.

Если целевой последовательности соответствует больше одного соединенного регулярного выражения, `ECMAScript` выбирает первое из соединенных регулярных выражений, соответствующих последовательности (*первое соответствие*); грамматики других регулярных выражений выбирают регулярное выражение, которое обеспечивает *наиболее длинное соответствие*. Например, "ab&#124;cd" соответствует целевой последовательности "ab" и целевой последовательности "cd", но не соответствует целевым последовательностям "abd" или "acd".

В `grep` и `egrep` символ новой строки ("\n") используется для разделения чередований.

### <a name="subexpression"></a>Часть выражения

В `basic` и `grep` часть выражения является объединением. В других грамматиках регулярных выражений часть выражения является чередованием.

## <a name="grammarsummary"></a> Сводка по грамматике

В следующей таблице приведены возможности, доступные в различных грамматиках регулярных выражений:

|Элемент|простые|расширенный|ECMAScript|grep|egrep|awk|
|-------------|---------|---------|----------|----------|-----------|---------|
|чередование с помощью "&#124;"||+|+||+|+|
|чередование с помощью "\n"||||+|+||
|привязка|+|+|+|+|+|+|
|обратная ссылка|+||+|+|||
|выражение в квадратных скобках|+|+|+|+|+|+|
|группа захвата с помощью "()"||+|+||+|+|
|группа захвата с помощью "\\(\\)"|+|||+|||
|управляющая escape-последовательность|||+||||
|escape-символ DSW|||+||||
|escape-выражение формата файлов|||+|||+|
|шестнадцатеричная escape-последовательность|||+||||
|escape-последовательность удостоверения|+|+|+|+|+|+|
|отрицательное утверждение|||+||||
|отрицательное утверждение границы слова|||+||||
|группа незахвата|||+||||
|"нежадное" повторение|||+||||
|восьмеричная escape-последовательность||||||+|
|обычный символ|+|+|+|+|+|+|
|положительное утверждение|||+||||
|Повторение с помощью "{}"||+|+||+|+|
|повторение с помощью "\\{\\}"|+|||+|||
|Повторение с помощью "\*"|+|+|+|+|+|+|
|повторение с помощью "?" и "+"||+|+||+|+|
|escape-последовательность Юникода|||+||||
|знак подстановки|+|+|+|+|+|+|
|утверждение границы слова|||+||||

## <a name="semanticdetails"></a> Семантические подробности

### <a name="anchor"></a>Привязка

Привязка соответствует позиции в целевой строке, а не символу. Привязка "^" соответствует началу целевой строки, а привязка "$" — концу целевой строки.

### <a name="back-reference"></a>Обратная ссылка

Обратная ссылка — это обратная косая черта, за которой следует десятичное значение N. Она соответствует содержимому N-й *группы захвата*. Значение N не должно превышать количество групп захвата, предшествующих обратной ссылке. В `basic` и `grep` значение N определяется десятичным разрядом, который следует за обратной косой чертой. В грамматике `ECMAScript` значение N определяется всеми десятичными разрядами, которые следуют за обратной косой чертой. Поэтому в `basic` и `grep` значение N никогда не будет больше 9, даже если регулярное выражение содержит более 9 групп захвата. В грамматике `ECMAScript` значение N не ограничено.

Примеры

- "((a+)(b+))(c+)\3" соответствует целевой последовательности "aabbbcbbb". Обратная ссылка "\3" соответствует тексту в третьей группе захвата, т. е. "(b+)". Она не соответствует целевой последовательности "aabbbcbb".

- Значение "(a)\2" не является допустимым.

- "(b(((((((((a))))))))))\10" имеет разные значения в `basic` и в `ECMAScript`. В `basic` обратной ссылкой является "\1". Обратная ссылка соответствует содержимому первой группы захвата (которая начинается с символов "(b", заканчивается последним символом ")" и предшествует обратной ссылке), а завершающий символ "0" соответствует обычному символу "0". В грамматике `ECMAScript` обратной ссылкой является "\10". Она соответствует десятой группе захвата, т. е. группе, которая находится на наиболее глубоком уровне.

### <a name="bracket-expression"></a>Выражение в квадратных скобках

Выражение в квадратных скобках определяет набор символов и *элементы упорядочивания*. Если выражение в квадратных скобках начинается с символа "^", соответствие считается успешным, когда ни один элемент в наборе не соответствует текущему символу в целевой последовательности. В противном случае соответствие считается успешным, если любой из элементов в наборе соответствует текущему символу в целевой последовательности.

Набор символов можно определить путем перечисления любого сочетания *отдельных символов*, *диапазонов символов*, *классов символов*, *классов эквивалентности* и *символов упорядочивания*.

### <a name="capture-group"></a>Группа захвата

Группа захвата помечает свое содержимое в качестве единого элемента в грамматике регулярного выражения и снабжает меткой целевой текст, соответствующий ее содержимому. Метка, связанная с каждой группой захвата, является числом, которое определяется подсчетом открытых скобок, которыми помечаются группы захвата, включительно до открывающей скобки, которой помечается текущая группа захвата. В данном случае максимальное число групп захвата равно 31.

Примеры

- "ab+" соответствует целевой последовательности "abb", но не соответствует целевой последовательности "abab".

- "(ab)+" не соответствует целевой последовательности "abb", но соответствует целевой последовательности "abab".

- "((a+)(b+))(c+)" соответствует целевой последовательности "aabbbc" и связывает группу захвата 1 с частью последовательности "aabbb", группу захвата 2 с частью последовательности "aa", группу захвата 3 с частью последовательности "bbb" и группу захвата 4 с частью последовательности "c".

### <a name="character-class"></a>Класс символов

Класс символов в выражении в квадратных скобках добавляет все символы в именованном классе в набор символов, который определяется выражением в квадратных скобках. Чтобы создать класс символов, используйте символ"[:", после которого необходимо указать имя класса, а затем — символ ":]". На внутреннем уровне имена классов символов распознаются путем обращения к функции `id = traits.lookup_classname`. Символ `ch` принадлежит к одному классу, если `traits.isctype(ch, id)` возвращает значение "true". Шаблон `regex_traits` по умолчанию поддерживает имена классов в следующей таблице.

|Имя класса|Описание|
|----------------|-----------------|
|"alnum"|строчные буквы, прописные буквы и цифры|
|"alpha"|строчные буквы и прописные буквы|
|"blank"|пробел или символ табуляции|
|"cntrl"|символы *escape-выражения формата файлов*|
|"digit"|цифры|
|"graph"|строчные буквы, прописные буквы, цифры и символы пунктуации|
|"lower"|строчные буквы|
|"print"|строчные буквы, прописные буквы, цифры, символы пунктуации и пробел|
|"punct"|символы пунктуации|
|"space"|пробел|
|"upper|прописные символы|
|"xdigit"|цифры, "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"|
|"d"|то же, что и для имени "digit"|
|"s"|то же, что и для имени "space"|
|"w"|то же, что и для имени "alnum"|

### <a name="character-range"></a>Диапазон символов

Диапазон символов в выражении в квадратных скобках добавляет все символы в диапазоне в набор символов, который определяется выражением в квадратных скобках. Для создания диапазона символов поместите символ "—" между первым и последними символами в диапазоне. В этом случае в набор будут добавлены все символы, обладающие числовым значением, которое больше или равно числовому значению первого символа и меньше или равно числовому значению последнего символа. Обратите внимание, что этот набор добавленных символов зависит от представления символов, соответствующего платформе. Если символ " — " находится в конце или в начале выражения в квадратных скобках либо является первым или последним символом в диапазоне символов, он представляет сам себя.

Примеры

- "[0-7]" представляет набор символов { '0', '1', '2', '3', '4', '5', '6', '7' }. Это выражение соответствует целевой последовательности "0", "1" и т.д., но не "a".

- В системах, использующих кодировку символов ASCII, "[h-k]" представляет набор символов { 'h', 'i', 'j', 'k' }. Это выражение соответствует целевой последовательности "h", "i" и т.д., но не "\x8A" или "0".

- В системах, использующих кодировку символов EBCDIC, "[h-k]" представляет набор символов { 'h', 'i', '\x8A', '\x8B', '\x8C', '\x8D', '\x8E', '\x8F', '\x90', 'j', 'k' } ("h" кодируется как 0x88, а "k" — как 0x92). Это выражение соответствует целевой последовательности "h", "i", "\x8A" и т.д., но не "0".

- "[-0-24]" представляет набор символов { '-', '0', '1', '2', '4' }.

- "[0-2-]" представляет набор символов { '0', '1', '2', '-' }.

- В системах, использующих кодировку символов ASCII, "[+--]" представляет набор символов { '+', ',', '-' }.

Однако если используются диапазоны с учетом языкового стандарта, символы в диапазоне определяются правилами сортировки, заданными для языкового стандарта. Символы, которые сортируются после первого символа в определении диапазона и до последнего символа в определении диапазона, входят в набор. Также в набор входят два завершающих символа.

### <a name="collating-element"></a>Элемент упорядочивания

Элемент упорядочивания — это многосимвольная последовательность, которая обрабатывается как один символ.

### <a name="collating-symbol"></a>Символ упорядочивания

Символ упорядочивания в выражении в квадратных скобках добавляет *элемент упорядочивания* в набор, заданный выражением в квадратных скобках. Чтобы создать символ упорядочивания, используйте "[." , за которым следует элемент упорядочивания и "]".

### <a name="control-escape-sequence"></a>Управляющая escape-последовательность

Управляющая escape-последовательность — это обратная косая черта, за которой следует буква "c", а затем — одна из букв в диапазоне от "a" до "z" или от "A" до "Z". Она соответствует управляющему символу ASCII, который именуется данной буквой. Например, "\ci" соответствует целевой последовательности "\x09", так как \<ctrl-i> имеет значение 0x09.

### <a name="dsw-character-escape"></a>Escape-символ DSW

Escape-символ DSW — это краткое имя класса символов, как указано в таблице ниже.

|Escape-последовательность|Эквивалентный именованный класс|Именованный класс по умолчанию|
|---------------------|----------------------------|-------------------------|
|"\d"|"[[:d:]]"|"[[:цифра:]]"|
|"\D"|"[^[:d:]]"|"[^[:цифра:]]"|
|"\s"|"[[:s:]]"|"[[:пробел:]]"|
|"\S"|"[^[:s:]]"|"[^[:пробел:]]"|
|"\w"|"[[:w:]]"|"[a-zA-Z0-9_]"\*|
|"\W"|"[^[:w:]]"|"[^a-zA-Z0-9_]"\*|

\*Набор символов ASCII

### <a name="equivalence-class"></a>Класс эквивалентности

Класс эквивалентности в выражении в квадратных скобках добавляет все символы и *элементы упорядочивания*, эквивалентные элементу упорядочивания в определении класса эквивалентности, в набор, заданный выражением в квадратных скобках. Чтобы создать класс эквивалентности, используйте символ "[=", после которого укажите элемент упорядочивания, а затем — "=]". На внутреннем уровне два элемента упорядочивания `elt1` и `elt2` эквивалентны, если `traits.transform_primary(elt1.begin(), elt1.end()) == traits.transform_primary(elt2.begin(), elt2.end())`.

### <a name="file-format-escape"></a>Escape-выражение формата файлов

Escape-выражение формата файлов состоит из стандартных последовательностей escape-символов языка C, "\\\\", "\a", "\b", "\f", "\n", "\r", "\t", "\v". Они обладают стандартными значениями: обратная косая черта, оповещение, стирание назад, перевод страницы, новая строка, возврат каретки, горизонтальная табуляция и вертикальная табуляция соответственно. В грамматике `ECMAScript` использование элементов "\a" и "\b" не допускается. (Использование элемента "\\\\" допускается, но он является escape-выражением удостоверения, а не формата файлов.)

### <a name="hexadecimal-escape-sequence"></a>Шестнадцатеричная escape-последовательность

Шестнадцатеричная escape-последовательность — это обратная косая черта, за которой следует буква "x" и две шестнадцатеричные цифры (0-9a-fA-F). Она соответствует символу в целевой последовательности, имеющему значение, указанное данными двумя цифрами. Например, "\x41" соответствует целевой последовательности "A", если используется кодировка символов ASCII.

### <a name="identity-escape"></a>Escape-последовательность удостоверения

Escape-последовательность удостоверения — это обратная косая черта, за которой следует один символ. Она соответствует данному символу. Данная последовательность необходима, если символ имеет особое значение; при использовании escape-последовательности удостоверения специальное значение удаляется. Пример:

- «\*"соответствует целевой последовательности «aaa», но не соответствует целевой последовательности «\*«.

- «\\\*"соответствует целевой последовательности «aaa», но соответствует целевой последовательности «\*«.

Набор символов, которые могут использоваться в escape-последовательности удостоверения, зависит от грамматики регулярного выражения, как указано в таблице ниже.

|Грамматика|Допустимые символы escape-последовательности удостоверения|
|-------------|----------------------------------------|
|`basic`, `grep`|{ '(', ')', '{', '}', '.', '[', '\\', '\*', '^', '$' }|
|`extended`, `egrep`|{ '(', ')', '{', '.', '[', '\\', '\*', '^', '$', '+', '?', '&#124;' }|
|`awk`|`extended` плюс { '"', '/' }|
|`ECMAScript`|Все символы, кроме символов, которые могут быть частью идентификатора. Как правило, это включает в себя буквы, цифры, «$», "\_" и escape-последовательности Юникода. Дополнительные сведения см в спецификации языка ECMAScript.|

### <a name="individual-character"></a>Отдельный символ

Отдельный символ в выражении в квадратных скобках добавляет данный символ в набор символов, который определяется выражением в квадратных скобках. В любом месте выражения в квадратных скобках, кроме начала выражения, символ "^" представляет сам себя.

Примеры

- "[abc]" соответствует целевым последовательностям "a", "b" и "c", но не последовательности "d".

- "[^abc]" соответствует целевой последовательности "d", но не целевым последовательностям "a", "b" или "c".

- "[a^bc]" соответствует целевым последовательностям "a", "b", "c" и "^", но не целевой последовательности "d".

Во всех грамматиках регулярных выражений, кроме `ECMAScript`, если символ "]" является первым символом, за которым следует открывающая скобка "[", или первым символом, за которым следует первоначальный символ "^", то данный символ представляет сам себя.

Примеры

- Выражение в квадратных скобках "[]a" является недопустимым, поскольку не завершается символом "]".

- Выражение "[]abc]" соответствует целевым последовательностям "a", "b", "c" и "]", но не целевой последовательности "d".

- "[^]abc]" соответствует целевой последовательности "d", но не целевым последовательностям "a", "b", "c" или "]".

В `ECMAScript` используйте элемент "\\]" для представления символа "]" в выражении в квадратных скобках.

Примеры

- "[]a" соответствует целевой последовательности "a", поскольку выражение в квадратных скобках является пустым.

- "[\\]abc]" соответствует целевым последовательностям "a", "b", "c" и "]", но не целевой последовательности "d".

### <a name="negative-assert"></a>Отрицательное утверждение

Отрицательное утверждение соответствует любым данным, кроме своего содержимого. Он не использует никакие символы в целевой последовательности. Например, "(!aa) (\*)» соответствует целевой последовательности «» и связывает группу захвата 1 с частью последовательности «». Это выражение не соответствует целевой последовательности "aa" или целевой последовательности "aaa".

### <a name="negative-word-boundary-assert"></a>Отрицательное утверждение границы слова

Отрицательное утверждение границы слова соответствует целевой строке, если текущая позиция в целевой строке не находится сразу же после *границы слова*.

### <a name="non-capture-group"></a>Группа незахвата

Группа незахвата помечает свое содержимое в качестве единого элемента в грамматике регулярного выражения, но не снабжает меткой целевой текст. Например "(a)(?:b)\*(c)» соответствует целевому тексту «abbc» и связывает группу захвата 1 с частью последовательности ««и группу захвата 2 с частью последовательности «c».

### <a name="non-greedy-repetition"></a>"Нежадное" повторение

"Нежадное" повторение использует наиболее краткую часть целевой последовательности, соответствующую шаблону. "Жадное" повторение использует наиболее длинное. Например, "(a+) (\*b)» соответствует целевой последовательности «aaab». Если используется "нежадное" повторение, оно связывает группу захвата 1 с частью целевой последовательности "a" в начале данной последовательности, а группу захвата 2 — с частью целевой последовательности "aab" в конце данной последовательности. Если используется "нежадное" повторение, оно связывает группу захвата 1 с частью последовательности "aaa", а группу захвата 2 — с частью последовательности "b".

### <a name="octal-escape-sequence"></a>Восьмеричная escape-последовательность

Восьмеричная escape-последовательность — это обратная косая черта, за которой следует одна, две или три восьмеричных цифры (0-7). Она соответствует символу в целевой последовательности со значением, заданным этими цифрами. Если все цифры имеют значение "0", последовательность является недопустимой. Например, "\101" соответствует целевой последовательности "A", если используется кодировка символов ASCII.

### <a name="ordinary-character"></a>Обычный символ

Обычный символ — это любой допустимый символ, который не имеет специального значения в текущей грамматике.

В грамматике `ECMAScript` специальное значение имеют следующие символы:

- ^  $  \  .  \*  +  ?  (  )  \[  ]  {  }  &#124;

В грамматиках `basic` и `grep` специальное значение имеют следующие символы:

- .   \[   \

Также в `basic` и `grep`, следующие символы имеют специальное значение при использовании в указанном контексте.

- "\*" обладает специальным значением во всех случаях, кроме случаев, когда его первого символа в регулярном выражении, или первый символ, который следует за первым "^" в регулярном выражении, или когда он является первым символом записи группы или первым символом, который следует за первым "^" в группе захвата.

- Символ "^" обладает специальным значением, если является первым символом регулярного выражения.

- Символ "$'" обладает специальным значением, если является последним символом регулярного выражения.

В грамматиках `extended`, `egrep` и `awk` специальное значение имеют следующие символы:

- .   \[   \   (   \*   +   ?   {   &#124;

Кроме того, в грамматиках `extended`, `egrep` и `awk` следующие символы имеют специальное значение при использовании в указанном контексте.

- Символ ")" имеет специальное значение, если соответствует предшествующему символу "(".

- Символ "^" обладает специальным значением, если является первым символом регулярного выражения.

- Символ "$'" обладает специальным значением, если является последним символом регулярного выражения.

Обычный символ соответствует такому же символу в целевой последовательности. По умолчанию это означает, что соответствие успешно, если два символа представлены тем же значением. В соответствии без учета регистра два символа `ch0` и `ch1` являются соответствующими, если `traits.translate_nocase(ch0) == traits.translate_nocase(ch1)`. В соответствии с учетом языкового стандарта два символа `ch0` и `ch1` являются соответствующими, если `traits.translate(ch0) == traits.translate(ch1)`.

### <a name="positive-assert"></a>Положительное утверждение

Положительное утверждение соответствует своему содержимому, но не использует никакие символы в целевой последовательности.

Примеры

- "(=AA) (\*)» соответствует целевой последовательности «aaaa» и связывает группу захвата 1 с частью последовательности «aaaa».

- «(aa) (\*)» соответствует целевой последовательности «aaaa» и связывает группу захвата 1 с частью последовательности «aa» в начале целевой последовательности, а группу захвата 2 с частью последовательности «aa» в конце целевой последовательности.

- "(?=aa)(a)&#124;(a)" соответствует целевой последовательности "a" и связывает группу захвата 1 с пустой последовательностью (так как положительное утверждение не выполняется), а группу захвата 2 — с частью последовательности "a". Данное выражение также соответствует целевой последовательности "aa" и связывает группу захвата 1 с частью последовательности "aa", а группу захвата 2 — с пустой последовательностью.

### <a name="unicode-escape-sequence"></a>Escape-последовательность Юникод

Escape-последовательность Юникод — это обратная косая черта, за которой следует буква "u" и четыре шестнадцатеричные цифры (0-9a-fA-F). Она соответствует символу в последовательности целевого объекта, имеющего значение, заданное четырьмя цифрами. Например, "\u0041" соответствует целевой последовательности "A", если используется кодировка символов ASCII.

### <a name="wildcard-character"></a>Символ-шаблон

Символ-шаблон соответствует любому символу в целевом выражении, кроме новой строки.

### <a name="word-boundary"></a>Граница слова

Граница слова появляется в следующих ситуациях:

- Текущий символ находится в начале целевой последовательности и является одним из словообразующих символов `A-Za-z0-9_.`

- Текущая позиция символа находится за целевой последовательностью, и последний символ в целевой последовательности является одним из словообразующих символов.

- Текущий символ является одним из словообразующих символов, а предшествующий символ — нет.

- Текущий символ не является одним из словообразующих символов, а предшествующий символ является.

### <a name="word-boundary-assert"></a>Утверждение границы слова

Утверждение границы слова является соответствующим, если текущая позиция в целевой строке — сразу после *границы слова*.

## <a name="matchingandsearching"></a> Соответствие и поиск

Чтобы регулярное выражение соответствовало целевой последовательности, все данное выражение должно соответствовать целевой последовательности целиком. Например, регулярное выражение "bcd" соответствует целевой последовательности "bcd", однако не соответствует целевой последовательности "abcd" или "bcde".

Для успешного поиска регулярного выражения одна из частей целевой последовательности должна соответствовать данному регулярному выражению. Обычно результатом поиска является крайняя левая соответствующая часть последовательности.

Примеры

- Поиск регулярного выражения "bcd" в целевой последовательности "bcd" выполняется успешно, и результат соответствует всей последовательности. Поиск с такими же критериями в целевой последовательности "abcd" также выполняется успешно, и результат соответствует последним трем символам. Поиск с такими же критериями в целевой последовательности "bcde" также выполняется успешно, и результат соответствует первым трем символам.

- Поиск регулярного выражения "bcd" в целевой последовательности "bcdbcd" выполняется успешно, и результат соответствует первым трем символам.

При наличии нескольких соответствующих частей целевой последовательности существует два способа выбрать соответствующий шаблон. *Первое соответствие* выбирает часть последовательности, найденную первой при установке соответствия с регулярным выражением. *Наиболее длинное соответствие* выбирает самую длинную часть последовательности из соответствующих в данном положении. Если максимальную длину имеет несколько частей последовательности, наиболее длинное соответствие выбирает часть последовательности, найденную первой. Например, если используется первое соответствие, то при поиске регулярного выражения "b&#124;bc" в целевой последовательности "abcd" результатом будет часть последовательности "b", так как левое условие чередования соответствует данной части последовательности; поэтому первое соответствие не предпринимает попытки обратиться к правому условию чередования. Если используется наиболее длинное соответствие, такие же условия поиска дают результат "bc", поскольку "bc" длиннее, чем "b".

Частичное соответствие является успешным, если достигает конца целевой последовательности без ошибок, даже в том случае, когда оно не достигает конца регулярного выражения. Поэтому после успешного частичного совпадения добавление символов в конец целевой последовательности может вызвать ошибку последующего частичного соответствия. Однако после ошибки частичного соответствия добавление символов в конец целевой последовательности не может обеспечить успешное последующее частичное соответствие. Например, при частичном соответствии "ab" соответствует целевой последовательности "a", но не "ac".

## <a name="formatflags"></a> Флаги формата

|Правила форматирования ECMAScript|Правила форматирования sed|Текст замены|
|-----------------------------|----------------------|----------------------|
|"$&"|"&"|Последовательность символов, которая соответствует всему регулярному выражению (`[match[0].first, match[0].second)`)|
|"$$"||"$"|
||"\\&"|"&"|
|«$\`"(знак доллара за которым следует обратного апострофа) || Последовательность символов, предшествующая части последовательности, которая соответствует регулярному выражению (`[match.prefix().first, match.prefix().second)`)|
|"$'" (знак доллара и символ прямого апострофа)||Последовательность символов, следующая за частью последовательности, которая соответствует регулярному выражению (`[match.suffix().first, match.suffix().second)`)|
|"$n"|"\n"|Последовательность символов, которая соответствует группе захвата в позиции `n`, где `n` — это число от 0 до 9 (`[match[n].first, match[n].second)`)|
||"\\\n"|"\n"|
|"$nn"||Последовательность символов, которая соответствует группе захвата в позиции `nn`, где `nn` — это число в диапазоне от 10 до 99 (`[match[nn].first, match[nn].second)`)|

## <a name="see-also"></a>См. также

[Общие сведения о стандартной библиотеке C++](../standard-library/cpp-standard-library-overview.md)<br/>
