---
title: <ranges>
description: Общие сведения о библиотеке диапазонов библиотеки стандартных шаблонов (STL)
ms.date: 04/14/2021
f1_keywords:
- <ranges>
helpviewer_keywords:
- ranges
ms.openlocfilehash: d805039a8c3920bdd5dedcb5d40acb3b651a7033
ms.sourcegitcommit: aaab04df80e2d00389c13b075cfac59afc7f4681
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2021
ms.locfileid: "107467620"
---
# `<ranges>`

На высоком уровне диапазон — это то, что можно перебирать. Диапазон отделяет итераторы таким образом, что упрощает и усиливает возможности использования стандартной библиотеки шаблонов (STL).

Алгоритмы STL обычно принимают итераторы, указывающие на часть коллекции, в которой они должны обрабатываться. Рассмотрим, как вы сортируете `vector` уже сегодня. Для вызова `std::sort()` вы передаете два итератора, которые отмечают начало и конец `vector` . Это обеспечивает гибкость, но передача итераторов в алгоритм является дополнительным помехой, так как большую часть времени нужно просто отсортировать всю вещь.

С помощью диапазонов можно просто вызвать метод, `std::ranges::sort(myVector);` который обрабатывается так, как если бы вы вызывали `std::sort(myVector.begin(), myVector.end());` в библиотеках диапазонов, алгоритмы принимают диапазоны в качестве параметров (хотя они также могут принимать итераторы, если требуется). Примеры алгоритмов диапазона, доступных в `<algorithm>` include `copy` , `copy_n` ,,, `copy_if` `all_of` `any_of` , `none_of` и `find` `find_if` `find_if_not` `count` `count_if` `for_each` `for_each_n` `equal` `mismatch` ,,, и, и, и.

Код, который проще писать и удобен для чтения, отлично подходит, но преимущества диапазонов больше, чем это. Они также упрощают фильтрацию и преобразование коллекций данных в части, позволяя более легко создавать Алгоритмы STL.

## <a name="a-ranges-example"></a>Пример диапазонов

Перед диапазонами, если требуется преобразовать только элементы коллекции, соответствующие определенным критериям, необходимо ввести промежуточный шаг для хранения результатов между операциями. Например, предположим, что нужно создать вектор квадратов из элементов другого вектора, кратного 3. Вы пишете нечто вроде:

```cpp
std::vector<int> input = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
std::vector<int> intermediate, output;

std::copy_if(input.begin(), input.end(), std::back_inserter(intermediate), [](const int i) { return i%3 == 0; });
std::transform(intermediate.begin(), intermediate.end(), std::back_inserter(output), [](const int i) {return i*i; });
```

С помощью диапазонов можно выполнять одно и то же действие без необходимости `intermediate` вектора:

```cpp
// requires /std:c++latest
std::vector<int> input = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

auto output = input | std::views::filter([](const int n) {return n % 3 == 0; }) | std::views::transform([](const int n) {return n * n; });
```  

Помимо упрощения чтения, это позволяет избежать выделения памяти, необходимой для `intermediate` вектора и его содержимого, а также создавать две операции.

В приведенном выше коде каждый элемент, который делится на три, объединяется с операцией для квадратного элемента. Символ " `|` " объединяет операции вместе и читается слева направо.

Результат, `output` , сам по себе является типом диапазона, называемого представлением, который рассматривается далее.

> [!NOTE]
> Для примеров диапазонов требуется [`/std:c++latest`](../build/reference/std-specify-language-standard-version.md) параметр компилятора.

## <a name="views"></a>Представления

Представление — это диапазон с добавленным требованием, что все операции представления (построение по умолчанию, создание и присваивание копирования, создание и присваивание копий (если они есть), уничтожение, начало и конец) происходят в постоянном времени независимо от количества элементов в представлении.

Отображение элементов в представлении зависит от алгоритма или операции, заданной для представления. В приведенном выше примере представление принимает диапазон и возвращает представление только тех элементов, которые делятся на три. Базовый диапазон не изменяется.

Представления являются составными. В приведенном выше примере представление векторных элементов, которые делятся на три, объединяется с представлением, в котором эти элементы находятся в квадрате.

Элементы представления оцениваются отложенно. То есть преобразования, применяемые для получения элементов в представлении, не оцениваются до тех пор, пока не будет запрашиваться элемент. Например, если запустить следующий код в отладчике и разместить точку останова в строках `auto divisible_by_three = ...` и, вы увидите, `auto square =  ...` что попадание в `divisible_by_three` лямбда-точку останова происходит, когда каждый элемент в `input` проверяется на дивисибилити на три. `square`Будет достигнута точка останова в лямбда-выражении, так как элементы, которые делятся на три, являются квадратными.

```cpp
// requires /std:c++latest
#include <ranges>
#include <vector>
#include <iostream>

int main()
{
    std::vector<int> input =  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    auto divisible_by_three = [](const int n) {return n % 3 == 0; };
    auto square = [](const int n) {return n * n; };

    auto x = input | std::views::filter(divisible_by_three)
                   | std::views::transform(square);

    for (int i : x)
    {
        std::cout << i << '\n';
    }
    return 0;
}
```

## <a name="view-adaptors"></a>Просмотр адаптеров

Адаптер представления создает представление для диапазона. Просматриваемый диапазон остается неизменным. Представление не владеет какими-либо элементами. Он позволяет выполнять итерацию по базовому диапазону с помощью настраиваемого поведения, указанного вами.

В приведенном выше примере первое представление предоставляет элементы `input` , которые делятся на три. Другое представление принимает элементы, кратные трем, и предоставляет квадрат элемента.

`<ranges>`Библиотека предоставляет множество видов переходников представлений. Помимо представлений Filter и Transform, существуют представления, которые принимают или пропускают первые N элементов диапазона, отменяют порядок диапазонов, диапазоны объединения, пропускают элементы диапазона, пока не будет выполнено условие, преобразуйте элементы диапазона и многое другое.

## <a name="range-adaptors"></a>Адаптеры диапазонов

Адаптер диапазона создает новый диапазон из существующего диапазона и преобразует доступ к его элементам. Например, адаптер диапазона может взять диапазон и создать новый, который представляет элементы из исходного диапазона в обратном порядке. Представления, обсуждаемые ранее, представляют собой распространенный тип адаптера диапазона.

Адаптеры диапазонов создают отложенно вычисляемые диапазоны. То есть вы не несете затрат на преобразование каждого элемента в диапазоне — только те, к которым у вас есть доступ, и во время доступа к ним.

Адаптеры диапазонов бывают многих видов. Например, существуют адаптеры диапазона, позволяющие фильтровать другой диапазон на основе предиката ( `view::filter` ), преобразовывать элементы в диапазон ( `view::transform` ), разделять диапазон ( `view::split()` ) и многое другое.

Адаптеры диапазонов могут быть объединены в цепочку или состоять из-за того, что мощность и гибкость диапазонов наиболее очевидны.

## <a name="range-algorithms"></a>Алгоритмы диапазона

Созданы алгоритмы диапазона, которые принимают аргумент Range. Например `std::ranges::sort(myVector);`.

Алгоритмы диапазона практически идентичны соответствующим алгоритмам-итераторам в `std` пространстве имен, за исключением того, что они имеют ограничения, применяемые концепцией, и принимают аргументы диапазона или более общие пары аргументов итератора-Sentinel. Они могут работать непосредственно с контейнером. их можно легко объединить в цепочку.

## <a name="types-of-ranges"></a>Типы диапазонов

Действия, которые можно выполнять с диапазоном, зависят от типа базового итератора диапазона. Концепции диапазона — это уточнения `range` концепции. В C++ 20, чтобы сказать, что концепция X уточнения концепции Y означает, что все, что удовлетворяет Y, также соответствует X, хотя и не всегда является другим способом. Например, автомобиль, шина и грузовик.

Основные понятия диапазона отражают иерархию категорий итераторов. В этой таблице перечислены различные основные понятия диапазона, а также тип контейнера, к которому они могут применяться.

| Концепция диапазона | Описание | Поддерживаемые контейнеры |
|--|--|--|
| `std::ranges::input_range` | Может выполнять итерацию от начала до конца по крайней мере один раз |
| `std::forward_list`<br>`std::unordered_map`<br>`std::unordered_multimap`<br>`std::unordered_set`<br>`std::unordered_multiset`<br>`basic_istream_view` |
| `std::ranges::forward_range` | Может выполнять итерацию от начала до конца более одного раза) | `std::forward_list`<br>`std::unordered_map`<br>`std::unordered_multimap`<br>`std::unordered_set`<br>`std::unordered_multiset` |
| `std::ranges::bidirectional_range` | Может выполнять итерацию вперед и назад более одного раза | `std::list`<br>`std::map`<br>`std::multimap`<br>`std::multiset`<br>`std::set`|
| `std::ranges::random_access_range` | Может получить доступ к произвольному элементу (в константном времени) с помощью `[]` оператора). | `std::deque` |
| `std::ranges::contiguous_range` | Каждый элемент хранится в памяти последовательно | `std::array`<br>`std::string`<br>`std::vector` |



## <a name="see-also"></a>См. также раздел

[Справочник по файлам заголовков](../standard-library/cpp-standard-library-header-files.md)