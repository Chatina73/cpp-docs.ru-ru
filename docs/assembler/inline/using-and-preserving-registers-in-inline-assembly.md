---
title: Использование и сохранение регистров во встроенном коде на языке ассемблера
ms.date: 08/30/2018
helpviewer_keywords:
- __asm keyword [C++], register values
- inline assembly, registers
- registers, inline assembly
- preserving registers
ms.assetid: dbcd7360-6f3e-4b22-9ee2-9f65ca6f2543
ms.openlocfilehash: 99ca0093bb27e859854dfd1ca64addea923e5a5c
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87191512"
---
# <a name="using-and-preserving-registers-in-inline-assembly"></a>Использование и сохранение регистров во встроенном коде на языке ассемблера

**Блок, относящийся только к системам Microsoft**

В общем случае не следует рассчитывать, что регистр будет иметь заданное значение при **`__asm`** начале блока. Не гарантируется, что значения регистров будут сохраняться в отдельных **`__asm`** блоках. Когда заканчивается один блок встроенного кода и начинается следующий блок, не следует полагать, что регистры во втором блоке сохраняют свои значения из первого блока. **`__asm`** Блок наследует все значения регистров, которые являются результатом обычного потока управления.

Если используется **`__fastcall`** соглашение о вызовах, компилятор передает аргументы функции в регистрах, а не в стек. Это может привести к возникновению проблем в функциях с **`__asm`** блоками, так как функция не может определить, какой параметр зарегистрирован. Если функция получила параметр в регистре EAX и сразу же записала в регистр EAX какое-то другое значение, исходный параметр будет потерян. Кроме того, необходимо сохранить регистр ECX в любой функции, объявленной с помощью **`__fastcall`** .

Чтобы избежать таких конфликтов регистров, не используйте **`__fastcall`** соглашение для функций, содержащих **`__asm`** блок. Если вы укажете **`__fastcall`** соглашение глобально с параметром компилятора/GR, объявите каждую функцию, содержащую **`__asm`** блок, с помощью **`__cdecl`** или **`__stdcall`** . ( **`__cdecl`** Атрибут указывает компилятору использовать соглашение о вызовах C для этой функции.) Если компиляция не выполняется с параметром/GR, не объявляйте функцию с **`__fastcall`** атрибутом.

При использовании **`__asm`** для написания языка ассемблера в функциях C/C++ не нужно сохранять регистры EAX, EBX, ECX, EDX, ESI или EDI. Например, в POWER2. В. пример с [написанием функций со встроенной сборкой](../../assembler/inline/writing-functions-with-inline-assembly.md) `power2` функция не сохраняет значение в регистре eax. Однако использование этих регистров повлияет на качество кода, поскольку распределитель регистров не может использовать их для хранения значений в **`__asm`** блоках. Кроме того, если во встроенном коде на языке ассемблера используется регистр EBX, ESI или EDI, компилятор вынужден сохранять и восстанавливать значения этих регистров в прологе и эпилоге функции.

Необходимо сохранить другие используемые вами регистры (например, регистры DS, SS, SP, BP и flags) для области **`__asm`** блока. Необходимо сохранять значения регистров ESP и EBP, если только нет определенной причины для их изменения (переключение стека, например). См. также раздел [Оптимизация встроенной сборки](../../assembler/inline/optimizing-inline-assembly.md).

Для некоторых типов SSE требуется 8-байтовое выравнивание стека, в результате чего компилятор вынужден создавать код динамического выравнивания стека. Чтобы иметь возможность доступа к локальным переменным и параметрам функций после выравнивания, компилятор поддерживает два указателя фреймов.  Если компилятор выполняет подавление указателя кадра (FPO), он будет использовать EBP и ESP.  Если компилятор не выполняет FPO, он будет использовать EBX и EBP. Чтобы обеспечить правильное выполнение кода, не изменяйте значение регистра EBX в коде на языке ассемблера, если функция требует динамического выравнивания стека, так как при этом может измениться указатель фрейма. Переместите типы с 8-байтовым выравниванием за пределы функции или не используйте регистр EBX.

> [!NOTE]
> Если встроенный код на языке ассемблера изменяет флаг направления с помощью инструкций STD или CLD, необходимо восстановить исходное значение этого флага.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Встроенный ассемблер](../../assembler/inline/inline-assembler.md)<br/>
