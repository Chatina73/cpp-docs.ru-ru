---
title: Избежание состязания за кучу
ms.date: 11/04/2016
helpviewer_keywords:
- heap contention
ms.assetid: 797129d7-5f8c-4b0e-8974-bb93217e9ab5
ms.openlocfilehash: c28e5ba01cc2bb1e3cae19087a67cf97e6ac415f
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50536790"
---
# <a name="avoidance-of-heap-contention"></a>Избежание состязания за кучу

Диспетчеры строка по умолчанию, предоставляемые MFC и ATL являются простыми оболочками на основе глобальной кучи. Этот глобальный кучи является полностью поточно ориентированной, это означает, что несколько потоков можно выделить и освободить память из него одновременно, без повреждения кучи. Для обеспечения потокобезопасности, куча имеет для сериализации доступа к самому себе. Обычно это осуществляется с помощью критической секции или похожий механизм блокировки. Каждый раз, когда два пытаются одновременно получить доступ к куче, один поток блокируется до завершения другого потока запроса. Для многих приложений такая ситуация возникает редко, и механизм блокировки кучи влияние на производительность незначительно. Тем не менее для приложений, которые часто обращаются к куче из нескольких потоков конкуренции за блокировки кучи может привести к приложению выполняться медленнее, чем если бы это был один поток (даже на компьютерах с несколькими процессорами).

Приложения, использующие [CStringT](../atl-mfc-shared/reference/cstringt-class.md) особенно восприимчивы к конкуренции кучи так как операции с `CStringT` объектов часто требуется перераспределение буфера строки.

Один из способов смягчению конфликтов кучи между потоками является Пусть каждый поток выделить строки из кучи частного, локальную для потока. До тех пор, пока выделены строки с помощью определенного потока распределителя используются только в этом потоке, распределитель не обязательно должны быть поточно ориентированными.

## <a name="example"></a>Пример

В приведенном ниже примере показана процедура потока, который выделяет свой собственный закрытый кучи не являющихся потокобезопасными, следует использовать для строк в этом потоке:

[!code-cpp[NVC_ATLMFC_Utilities#182](../atl-mfc-shared/codesnippet/cpp/avoidance-of-heap-contention_1.cpp)]

## <a name="comments"></a>Комментарии

Несколько потоков могут выполняться с помощью этой же процедуре потока, но так как каждый поток имеет свою собственную кучу нет конкуренции между потоками нет. Кроме того тот факт, что каждой кучи не является поточно ориентированной дает измеримое увеличение производительности, даже если выполняется только одна копия потока. Это результат кучи, не используете ресурсоемкие Блокируемые операции для защиты от одновременного доступа.

Для более сложных процедуру потока то может оказаться удобнее для хранения указателя для диспетчера потока строк в слоте (TLS) с локального хранилища потока. Благодаря этому других функциях, вызванных процедуре потока для доступа к диспетчеру строка потока.

## <a name="see-also"></a>См. также

[Управление памятью с помощью CStringT](../atl-mfc-shared/memory-management-with-cstringt.md)

