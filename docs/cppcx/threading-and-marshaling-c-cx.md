---
title: Работа с потоками и маршалинг (C++/CX)
ms.date: 12/30/2016
f1_keywords:
- C4451
helpviewer_keywords:
- threading issues, C++/CX
- agility, C++/CX
- C++/CX, threading issues
ms.assetid: 83e9ca1d-5107-4194-ae6f-e01bd928c614
ms.openlocfilehash: 6b57366df5f466ffe49e4c0b46e05b1eed515535
ms.sourcegitcommit: 89d9e1cb08fa872483d1cde98bc2a7c870e505e9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "82032490"
---
# <a name="threading-and-marshaling-ccx"></a>Работа с потоками и маршалинг (C++/CX)

В подавляющем большинстве случаев экземпляры классов Windows Runtime, такие как стандартные объекты C, могут быть доступны из любого потока. Такие классы называются "гибкими". Однако небольшое число классов Windows Runtime, которые поставляются с Windows, не являются гибкими и должны потребляться больше как объекты COM, чем стандартные объекты C. Для работы с негибкими классами не нужно быть специалистом по COM, однако нужно учитывать модель потоков классов и их механизмы маршалинга. В этой статье приведены общие сведения и инструкции по реализации редких сценариев, в которых приходится использовать экземпляры негибких классов.

## <a name="threading-model-and-marshaling-behavior"></a>Модель потоков и механизмы маршалинга

Класс Runtime Windows может поддерживать параллельный доступ к потокам различными способами, о чем свидетельствуют два атрибута, которые применяются к нему:

- Атрибут`ThreadingModel` может иметь одно из следующих значений: STA, MTA или Both, которые определены в перечислении `ThreadingModel` .

- Атрибут`MarshallingBehavior` может иметь одно из следующих значений: Agile, None или Standard, которые определены в перечислении `MarshallingType` .

Атрибут `ThreadingModel` определяет, где загружается класс при активации: только в контексте потока пользовательского интерфейса (STA), только в контексте фонового потока (MTA) или в контексте потока, создающего объект (Both). Значения атрибутов `MarshallingBehavior` определяют поведение объекта в контекстах различных потоков; в большинстве случаев не требуется подробно разбираться в этих значениях.  Среди классов, предоставляемых API Windows, около 90 процентов имеют значения атрибутов `ThreadingModel`=Both и `MarshallingType`=Agile. Это означает, что они могут обрабатывать низкоуровневые сведения потоков прозрачно и эффективно.   Если создать гибкий класс с помощью ключевого слова `ref new` , его методы можно из основного потока приложения или из одного или нескольких рабочих потоков.  Иначе говоря, гибкий класс можно использовать из любого места в коде, независимо от того, предоставляется ли он Windows или сторонними разработчиками. О потоковой модели класса и его поведении маршалинга можно не беспокоиться.

## <a name="consuming-windows-runtime-components"></a>Потребление компонентов Runtime Windows

При создании универсального приложения платформы Windows можно взаимодействовать как с гибкими, так и с негибкими компонентами. При работе с негибкими компонентами может возникнуть следующее предупреждение.

### <a name="compiler-warning-c4451-when-consuming-non-agile-classes"></a>Компилятор предупреждение C4451 при потреблении негибких классов

По различным причинам некоторые классы не могут быть гибкими. Если вы обращаетесь к экземплярам негибких классов и из потока пользовательского интерфейса, и из фонового потока, необходимо уделить особое внимание тому, чтобы обеспечить правильное поведение во время выполнения. Компилятор Microsoft C's выдает предупреждения, когда вы мгновенно подготавливаете негибкий класс времени выполнения в вашем приложении в глобальном диапазоне или объявляете негибкий тип в качестве члена класса в классе реф, который сам по себе помечен как гибкий.

Из негибких классов проще всего работать с теми, у которых `ThreadingModel`=Both и `MarshallingType`=Standard.  Эти классы можно сделать гибкими с помощью вспомогательного класса `Agile<T>` .   В следующем примере показано объявление негибкого объекта типа `Windows::Security::Credentials::UI::CredentialPickerOptions^`и результирующее предупреждение компилятора.

```

ref class MyOptions
    {
    public:
        property Windows::Security::Credentials::UI::CredentialPickerOptions^ Options

        {
            Windows::Security::Credentials::UI::CredentialPickerOptions^ get()
            {
                return _myOptions;
            }
        }
    private:
        Windows::Security::Credentials::UI::CredentialPickerOptions^ _myOptions;
    };
```

Выдается следующее предупреждение:

> `Warning 1 warning C4451: 'Platform::Agile<T>::_object' : Usage of ref class 'Windows::Security::Credentials::UI::CredentialPickerOptions' inside this context can lead to invalid marshaling of object across contexts. Consider using 'Platform::Agile<Windows::Security::Credentials::UI::CredentialPickerOptions>' instead`

При добавлении ссылки (в области членов или глобальной области) на объект, имеющий поведение маршалинга "Standard", компилятор выдает предупреждение, рекомендующее заключить этот тип в оболочку `Platform::Agile<T>`: `Consider using 'Platform::Agile<Windows::Security::Credentials::UI::CredentialPickerOptions>' instead` Если воспользоваться типом `Agile<T>`, класс можно будет использовать как любой другой гибкий класс. Используйте `Platform::Agile<T>` в следующих ситуациях:

- Негибкая переменная объявляется в глобальной области.

- Негибкая переменная объявляется в области класса, и существует возможность того, что код использует указатель в другом подразделении без надлежащего маршалинга.

Если ни одно из этих условий не выполняется, можно пометить содержащий класс как негибкий. Другими словами, следует напрямую удерживать негибкие объекты только в негибких классах и удерживать\<негибкие объекты через Platform::Agile T> в гибких классах.

В следующем примере показано, как благодаря `Agile<T>` можно пропустить это предупреждение без последствий.

```

#include <agile.h>
ref class MyOptions
    {
    public:
        property Windows::Security::Credentials::UI::CredentialPickerOptions^ Options

        {
            Windows::Security::Credentials::UI::CredentialPickerOptions^ get()
            {
                return m_myOptions.Get();
            }
        }
    private:
        Platform::Agile<Windows::Security::Credentials::UI::CredentialPickerOptions^> m_myOptions;

    };
```

Обратите внимание, что `Agile` нельзя передавать в качестве возвращаемого значения или параметра в классе ссылки. Метод `Agile<T>::Get()` возвращает дескриптор объекта (^), который можно передать через границу интерфейса ABI в открытом методе или свойстве.

При создании ссылки на класс In-proc Windows Runtime, который имеет поведение маршалинга "Нет", компилятор выдает предупреждение `Platform::Agile<T>`C4451, но не предлагает использовать .  Компилятор не может ничем помочь помимо этого предупреждения, поэтому вам необходимо самостоятельно обеспечить надлежащую работу класса и убедиться, что код вызывает компоненты однопотокового подразделения (STA) только из потока пользовательского интерфейса, а компоненты многопотокового подразделения (MTA) — только из фонового потока.

## <a name="authoring-agile-windows-runtime-components"></a>Авторство гибких компонентов Runtime Windows

Когда вы определяете класс реф в C-CX, он проворный по умолчанию, то есть он имеет `ThreadingModel`«Оба» и `MarshallingType`«Agile».  Если вы используете библиотеку шаблонов Windows Runtime, вы можете сделать свой `FtmBase`класс гибким, произвольно используя `FreeThreadedMarshaller`.  Создавая класс с атрибутами `ThreadingModel`=Both или `ThreadingModel`=MTA, убедитесь, что он является потокобезопасным.

Потоковую модель и поведение маршалинга класса ссылки можно изменять. Однако если внести изменения, которые делают класс негибким, необходимо четко понимать их последствия.

В следующем примере `MarshalingBehavior` показано, как применять и `ThreadingModel` атрибуты для класса времени выполнения в библиотеке класса Windows Runtime. Если приложение использует библиотеку DLL и в нем активируется объект класса `ref new` с помощью ключевого слова `MySTAClass` , этот объект активируется в однопотоковом подразделении и не поддерживает маршалинг.

```
using namespace Windows::Foundation::Metadata;
using namespace Platform;

[Threading(ThreadingModel::STA)]
[MarshalingBehavior(MarshalingType::None)]
public ref class MySTAClass
{
};
```

Незапечатанный класс должен иметь атрибуты маршалинга и потоковой модели, чтобы компилятор мог проверить, что производные классы имеют такие же значения этих атрибутов. Если эти параметры не заданы для класса явным образом, компилятор выдает ошибку и не выполняет компиляцию. Любой класс, производный от незапечатанного класса, выдает ошибку компилятора в каждом из следующих случаев:

- Атрибуты `ThreadingModel` и `MarshallingBehavior` не определены в производном классе.

- Значения атрибутов `ThreadingModel` и `MarshallingBehavior` в производном классе не соответствуют аналогичным атрибутам базового класса.

Информация о потоках и маршалинге, требуемая сторонним компонентом Windows Runtime, указана в регистрационной информации приложения. Мы рекомендуем сделать все компоненты Windows Runtime гибкими. Это гарантирует, что клиентский код сможет вызывать компонент из любого потока приложения, и улучшает производительность таких вызовов, поскольку они являются прямыми вызовами без маршалирования. Если создать класс таким образом, клиентскому коду не придется применять `Platform::Agile<T>` , чтобы использовать этот класс.

## <a name="see-also"></a>См. также раздел

[ThreadingModel](/uwp/api/windows.foundation.metadata.threadingmodel)<br/>
[MarshallingBehavior](/uwp/api/windows.foundation.metadata.marshalingbehaviorattribute)
