---
title: Работа с потоками и маршалинг (C++/CX)
ms.date: 12/30/2016
f1_keywords:
- C4451
helpviewer_keywords:
- threading issues, C++/CX
- agility, C++/CX
- C++/CX, threading issues
ms.assetid: 83e9ca1d-5107-4194-ae6f-e01bd928c614
ms.openlocfilehash: c5bce60e564bef490bcfafd6f8559dffe5fd4f1d
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62404641"
---
# <a name="threading-and-marshaling-ccx"></a>Работа с потоками и маршалинг (C++/CX)

В подавляющем большинстве случаев экземпляры классов среды выполнения Windows, как и стандартные объекты C++, может осуществляться из любого потока. Такие классы называются "гибкими". Тем не менее небольшое количество классов среды выполнения Windows, входящие в состав Windows, не являются гибкими и должны использоваться скорее как COM-объекты, чем стандартные объекты C++. Для работы с негибкими классами не нужно быть специалистом по COM, однако нужно учитывать модель потоков классов и их механизмы маршалинга. В этой статье приведены общие сведения и инструкции по реализации редких сценариев, в которых приходится использовать экземпляры негибких классов.

## <a name="threading-model-and-marshaling-behavior"></a>Модель потоков и механизмы маршалинга

Класс среды выполнения Windows поддерживает одновременный доступ к потокам различными способами, как указано в двух атрибутов, которые применяются к нему:

- Атрибут`ThreadingModel` может иметь одно из следующих значений: STA, MTA или Both, которые определены в перечислении `ThreadingModel` .

- Атрибут`MarshallingBehavior` может иметь одно из следующих значений: Agile, None или Standard, которые определены в перечислении `MarshallingType` .

Атрибут `ThreadingModel` определяет, где загружается класс при активации: только в контексте потока пользовательского интерфейса (STA), только в контексте фонового потока (MTA) или в контексте потока, создающего объект (Both). Значения атрибутов `MarshallingBehavior` определяют поведение объекта в контекстах различных потоков; в большинстве случаев не требуется подробно разбираться в этих значениях.  Среди классов, предоставляемых API Windows, около 90 процентов имеют значения атрибутов `ThreadingModel`=Both и `MarshallingType`=Agile. Это означает, что они могут обрабатывать низкоуровневые сведения потоков прозрачно и эффективно.   Если создать гибкий класс с помощью ключевого слова `ref new` , его методы можно из основного потока приложения или из одного или нескольких рабочих потоков.  Иначе говоря, гибкий класс можно использовать из любого места в коде, независимо от того, предоставляется ли он Windows или сторонними разработчиками. О потоковой модели класса и его поведении маршалинга можно не беспокоиться.

## <a name="consuming-windows-runtime-components"></a>Использование компонентов среды выполнения Windows

При создании приложения универсальной платформы Windows, может взаимодействовать с гибкими, так и негибкими компонентами. При работе с негибкими компонентами может возникнуть следующее предупреждение.

### <a name="compiler-warning-c4451-when-consuming-non-agile-classes"></a>Компилятор выдает предупреждение C4451 при использовании негибких классов

По различным причинам некоторые классы не могут быть гибкими. Если вы обращаетесь к экземплярам негибких классов и из потока пользовательского интерфейса, и из фонового потока, необходимо уделить особое внимание тому, чтобы обеспечить правильное поведение во время выполнения. Компилятор Visual C++ выдает предупреждение, если вы создаете экземпляр негибкого класса среды выполнения в приложении в глобальной области или объявляете негибкий тип как член класса в классе ссылки, который сам помечен как гибкий.

Из негибких классов проще всего работать с теми, у которых `ThreadingModel`=Both и `MarshallingType`=Standard.  Эти классы можно сделать гибкими с помощью вспомогательного класса `Agile<T>` .   В следующем примере показано объявление негибкого объекта типа `Windows::Security::Credentials::UI::CredentialPickerOptions^`и результирующее предупреждение компилятора.

```

ref class MyOptions
    {
    public:
        property Windows::Security::Credentials::UI::CredentialPickerOptions^ Options

        {
            Windows::Security::Credentials::UI::CredentialPickerOptions^ get()
            {
                return _myOptions;
            }
        }
    private:
        Windows::Security::Credentials::UI::CredentialPickerOptions^ _myOptions;
    };
```

Выдается следующее предупреждение:

> `Warning 1 warning C4451: 'Platform::Agile<T>::_object' : Usage of ref class 'Windows::Security::Credentials::UI::CredentialPickerOptions' inside this context can lead to invalid marshaling of object across contexts. Consider using 'Platform::Agile<Windows::Security::Credentials::UI::CredentialPickerOptions>' instead`

При добавлении ссылки — в области членов или глобальной области видимости — объект, имеющий поведение маршалинга «Standard», компилятор выдает предупреждение, предлагающее тип в `Platform::Agile<T>`: `Consider using 'Platform::Agile<Windows::Security::Credentials::UI::CredentialPickerOptions>' instead` Если вы используете `Agile<T>`, вы можете использовать класс, как и любой другой гибкий класс. Используйте `Platform::Agile<T>` в следующих ситуациях:

- Негибкая переменная объявляется в глобальной области.

- Негибкая переменная объявляется в области класса, и существует возможность того, что код использует указатель в другом подразделении без надлежащего маршалинга.

Если ни одно из этих условий не выполняется, можно пометить содержащий класс как негибкий. Другими словами, вы должны непосредственно держите негибкие объекты только в негибких классов, а объекты с помощью Platform::Agile\<T > в гибких классах.

В следующем примере показано, как благодаря `Agile<T>` можно пропустить это предупреждение без последствий.

```

#include <agile.h>
ref class MyOptions
    {
    public:
        property Windows::Security::Credentials::UI::CredentialPickerOptions^ Options

        {
            Windows::Security::Credentials::UI::CredentialPickerOptions^ get()
            {
                return m_myOptions.Get();
            }
        }
    private:
        Platform::Agile<Windows::Security::Credentials::UI::CredentialPickerOptions^> m_myOptions;

    };
```

Обратите внимание, что `Agile` нельзя передавать в качестве возвращаемого значения или параметра в классе ссылки. Метод `Agile<T>::Get()` возвращает дескриптор объекта (^), который можно передать через границу интерфейса ABI в открытом методе или свойстве.

В Visual C++ при создании ссылки в класс среды выполнения Windows в процессе, имеющий поведение маршалинга «None», компилятор выдает предупреждение C4451, но не предлагает рассмотреть использование `Platform::Agile<T>`.  Компилятор не может ничем помочь помимо этого предупреждения, поэтому вам необходимо самостоятельно обеспечить надлежащую работу класса и убедиться, что код вызывает компоненты однопотокового подразделения (STA) только из потока пользовательского интерфейса, а компоненты многопотокового подразделения (MTA) — только из фонового потока.

## <a name="authoring-agile-windows-runtime-components"></a>Разработка гибких компонентов среды выполнения Windows

При определении ссылочного класса в C++/CX, он является гибким по умолчанию — то есть он имеет `ThreadingModel`= Both и `MarshallingType`= Agile.  Если вы используете библиотека шаблонов C++ среды выполнения Windows, необходимо сделать класс agile путем наследования от `FtmBase`, которая использует `FreeThreadedMarshaller`.  Создавая класс с атрибутами `ThreadingModel`=Both или `ThreadingModel`=MTA, убедитесь, что он является потокобезопасным.

Потоковую модель и поведение маршалинга класса ссылки можно изменять. Однако если внести изменения, которые делают класс негибким, необходимо четко понимать их последствия.

В следующем примере показано, как применить `MarshalingBehavior` и `ThreadingModel` атрибуты к классу среды выполнения в библиотеке классов среды выполнения Windows. Если приложение использует библиотеку DLL и в нем активируется объект класса `ref new` с помощью ключевого слова `MySTAClass` , этот объект активируется в однопотоковом подразделении и не поддерживает маршалинг.

```
using namespace Windows::Foundation::Metadata;
using namespace Platform;

[Threading(ThreadingModel::STA)]
[MarshalingBehavior(MarshalingType::None)]
public ref class MySTAClass
{
};
```

Незапечатанный класс должен иметь атрибуты маршалинга и потоковой модели, чтобы компилятор мог проверить, что производные классы имеют такие же значения этих атрибутов. Если эти параметры не заданы для класса явным образом, компилятор выдает ошибку и не выполняет компиляцию. Любой класс, производный от незапечатанного класса, выдает ошибку компилятора в каждом из следующих случаев:

- Атрибуты `ThreadingModel` и `MarshallingBehavior` не определены в производном классе.

- Значения атрибутов `ThreadingModel` и `MarshallingBehavior` в производном классе не соответствуют аналогичным атрибутам базового класса.

Работа с потоками и маршалинг сведения, необходимые в компонент среды выполнения Windows сторонних указан в сведениях о регистрации манифеста приложения для компонента. Мы рекомендуем внести все компоненты среды выполнения Windows agile. Это гарантирует, что клиентский код сможет вызывать компонент из любого потока приложения, и улучшает производительность таких вызовов, поскольку они являются прямыми вызовами без маршалирования. Если создать класс таким образом, клиентскому коду не придется применять `Platform::Agile<T>` , чтобы использовать этот класс.

## <a name="see-also"></a>См. также

[ThreadingModel](/uwp/api/Windows.Foundation.Metadata.ThreadingModel)<br/>
[MarshallingBehavior](/uwp/api/windows.foundation.metadata.marshalingbehaviorattribute)
