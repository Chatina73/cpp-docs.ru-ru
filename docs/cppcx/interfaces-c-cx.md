---
title: Интерфейсы (C++/CX)
ms.date: 01/22/2017
ms.assetid: 11034314-d54a-426d-923b-5ab7a6b9f8ce
ms.openlocfilehash: df010468d5e90fe61ac2cf57c754ac5ed01b1c0f
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87230991"
---
# <a name="interfaces-ccx"></a>Интерфейсы (C++/CX)

Хотя класс ссылки может наследовать не более чем от одного конкретного базового класса, он может реализовывать любое количество классов интерфейсов. Сам класс интерфейса (или структура интерфейса) может наследовать (или требовать) несколько классов интерфейсов, может перегружать свои функции-члены и иметь параметры-типы.

## <a name="characteristics"></a>Характеристики

Интерфейс имеет следующие характеристики:

- Класс интерфейса (или структура) должен быть объявлен в пространстве имен, а также может иметь режим доступа public (открытый) или private (закрытый). Только открытые интерфейсы формируют метаданные.

- члены интерфейса могут включать в себя свойства, методы и события;

- Все члены интерфейса неявно являются открытыми и виртуальными.

- поля и статические члены запрещены;

- Типы, используемые как свойства, параметры метода или возвращаемые значения, могут быть только среда выполнения Windows типами. к ним относятся фундаментальные типы и типы классов Enum.

## <a name="declaration-and-usage"></a>Объявление и использование

В следующем примере показан способ объявления интерфейса. Обратите внимание, что интерфейс можно объявить или как класс, или как тип структуры.

[!code-cpp[cx_interfaces#01](../cppcx/codesnippet/CPP/interfacestest/class1.h#01)]

Для реализации интерфейса класс ссылки или структура ссылки объявляет и реализует виртуальные методы и свойства. Интерфейс и реализующий его класс ссылки должны использовать одинаковые имена параметров методов, как показано в следующем примере:

[!code-cpp[cx_interfaces#02](../cppcx/codesnippet/CPP/interfacestest/class1.h#02)]

## <a name="interface-inheritance-hierarchies"></a>Иерархии наследования интерфейсов

Интерфейс может наследовать от одного или нескольких интерфейсов. Но в отличие от структуры и класса ссылки, интерфейс не объявляет наследуемые члены интерфейса. Если интерфейс B наследует от интерфейса A, а класс ссылки C наследует от интерфейса B, класс C должен реализовывать и A, и B. Это показано в следующем примере.

[!code-cpp[cx_interfaces#03](../cppcx/codesnippet/CPP/interfacestest/class1.h#03)]

## <a name="implementing-interface-properties-and-events"></a>Реализация свойств и событий интерфейса

Как показано в предыдущем примере, для реализации свойств интерфейса можно использовать тривиальные виртуальные свойства. Также можно определить пользовательские методы получения и задания в реализующем классе.  Оба эти метода должны быть открытыми в свойстве интерфейса.

[!code-cpp[cx_interfaces#04](../cppcx/codesnippet/CPP/interfacestest/class1.h#04)]

Если интерфейс объявляет свойство, доступное только для получения или только для задания, реализующий класс должен явно предоставить метод получения или задания.

[!code-cpp[cx_interfaces#05](../cppcx/codesnippet/CPP/interfacestest/class1.h#05)]

Кроме того, можно реализовать пользовательские методы добавления и удаления для событий в реализующем классе.

## <a name="explicit-interface-implementation"></a>Явная реализация интерфейса

Если класс ссылки реализует несколько интерфейсов, и эти интерфейсы содержат методы, имена и сигнатуры которых идентичны компилятору, можно использовать следующий синтаксис для явного указания метода интерфейса, который реализуется методом класса.

[!code-cpp[cx_interfaces#06](../cppcx/codesnippet/CPP/interfacestest/class1.h#06)]

## <a name="generic-interfaces"></a>Универсальные интерфейсы

В C++/CX **`generic`** ключевое слово используется для представления среда выполнения Windows параметризованного типа. Параметризованный тип передается в метаданные и может использоваться кодом, который написан на любом языке, поддерживающем параметры-типы. Среда выполнения Windows определяет некоторые универсальные интерфейсы, например [Windows:: Foundation:: Collections:: IVector \<T> ](/uwp/api/windows.foundation.collections.ivector-1), но не поддерживает создание общедоступных определяемых пользователем универсальных интерфейсов в C++/CX. Однако можно создавать закрытые универсальные интерфейсы.

Вот как можно использовать типы среда выполнения Windows для создания универсального интерфейса:

- Универсальный пользователь, определенный **`interface class`** в компоненте, не может быть передан в свой файл метаданных Windows, поэтому он не может иметь открытый доступ, а клиентский код в других WinMD-файлах не может его реализовать. Он может быть реализован неоткрытыми классами ссылок в том же компоненте. Открытый класс ссылки может иметь универсальный тип интерфейса в качестве закрытого члена.

   В следующем фрагменте кода показано, как объявить универсальный объект **`interface class`** , а затем реализовать его в закрытом классе ссылки и использовать класс ссылки в качестве закрытого члена в открытом классе ссылки.

   [!code-cpp[cx_interfaces#07](../cppcx/codesnippet/CPP/interfacestest/class1.h#07)]

- Универсальный интерфейс должен следовать стандартным правилам интерфейсов, регламентирующим возможности доступа, члены, отношения *requires* (требует), базовые классы и т. д.

- Универсальный интерфейс может принимать один или несколько параметров универсального типа, которым предшествует **`typename`** или **`class`** . Параметры, не являющиеся типами, не поддерживаются.

- Параметром типа может быть любой тип среда выполнения Windows. Это означает, что параметр-тип может быть ссылочным типом, типом значения, классом интерфейса, делегатом, основным типом или открытым перечислимым классом.

- *Закрытый универсальный интерфейс* — это интерфейс, наследующий от универсального интерфейса и указывающий аргументы конкретного типа для всех параметров-типов. Его можно использовать везде, где допускается использовать неуниверсальный закрытый интерфейс.

- *Открытый универсальный интерфейс* — это интерфейс, имеющий один или несколько параметров-типов, для которых пока не предоставлено никаких конкретных типов. Его можно использовать везде, где допускается использовать типы, в том числе в качестве аргумента-типа другого универсального интерфейса.

- Параметризовать можно только весь интерфейс, но не отдельные методы.

- Параметры-типы нельзя ограничивать.

- Закрытый универсальный интерфейс имеет неявно создаваемый UUID. Пользователь не может задать UUID.

- Если в интерфейсе имеется какая-либо ссылка на текущий интерфейс (в параметре метода, возвращаемом значении или свойстве), предполагается, что она указывает на текущий экземпляр. Например, *иминтф* означает *иминтф \<T> *.

- Если тип параметра метода является параметром-типом, при объявлении этого параметра или переменной используется имя параметра-типа без указателя, собственной ссылки и деклараторов дескрипторов. Иначе говоря, невозможно написать "T^".

- Шаблонные классы ссылок должны быть закрытыми. Они могут реализовывать универсальные интерфейсы и передавать параметр шаблона *t* в универсальный аргумент *t*. Каждый экземпляр класса ссылки в шаблоне сам по себе является классом ссылки.

## <a name="see-also"></a>См. также статью

[Система типов](../cppcx/type-system-c-cx.md)<br/>
[Справочник по языку C++/CX](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[Справочник по пространствам имен](../cppcx/namespaces-reference-c-cx.md)
