---
title: Разделяемые классы (C++/CX)
ms.date: 12/30/2016
ms.assetid: 69d93575-636c-4564-8cca-6dfba0c7e328
ms.openlocfilehash: 1f5583354481248e8df201be200fe99da61791dd
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87185467"
---
# <a name="partial-classes-ccx"></a>Разделяемые классы (C++/CX)

Разделяемый класс — это конструкция, предназначенная для ситуаций, когда вы изменяете часть определения класса, и программное обеспечение для автоматического построения кода (например, конструктор XAML) также изменяет код в этом классе. Использование разделяемых классов позволяет предотвратить изменение вашего кода конструктором. В проекте Visual Studio к сгенерированному файлу автоматически применяется модификатор `partial` .

## <a name="syntax"></a>Синтаксис

Чтобы определить разделяемый класс, укажите ключевое слово `partial` непосредственно перед ключевым словом класса, которое иначе было бы обычным определением класса. Результирующее ключевое слово, например `partial ref class` , является контекстным ключевым словом, содержащим пробелы. Определения разделяемых классов поддерживаются в следующих конструкциях.

- **`class`** или **`struct`**

- **`ref class`** или **`ref struct`**

- **`value class`** или **`value struct`**

- **`enum`** или **`enum class`**

- `ref interface`, **`interface class`** , **`interface struct`** или **"__interface**

- **`union`**

В этом примере демонстрируется частичное **`ref class`** :

[!code-cpp[cx_partial#01](../cppcx/codesnippet/CPP/partialclassexample/class1.h#01)]

## <a name="contents"></a>Содержимое

Определение разделяемого класса может содержать любые конструкции, которые могли бы содержаться в полном определении класса, если бы ключевое слово `partial` не было указано. Оно может содержать любые допустимые конструкции (за единственным исключением), такие как базовые классы, данные-члены, функции-члены, перечисления, объявления дружественных функций и атрибуты. Встроенные определения и статические данные-члены также допускаются.

Единственное исключение — ключевые слова, указывающие возможность доступа к классу. Например, выражение `public partial class MyInvalidClass {/* ... */};` является ошибкой. Ключевые слова в определении разделяемого класса MyInvalidClass, указывающие возможность доступа, не влияют на возможность доступа по умолчанию в последующем разделяемом или полном определении класса MyInvalidClass.

В следующем фрагменте кода демонстрируются ключевые слова, указывающие возможность доступа. В первом разделяемом классе `Method1` является открытым, поскольку для него задано ключевое слово public. Во втором разделяемом классе `Method2` является закрытым, поскольку по умолчанию класс является закрытым.

[!code-cpp[cx_partial#02](../cppcx/codesnippet/CPP/partialclassexample/class1.h#02)]

## <a name="declaration"></a>Объявление

Частичное определение класса, например *MyClass* , является лишь объявлением класса MyClass. Таким образом, оно вводит только имя *MyClass*. *MyClass* нельзя использовать способом, требующим определения класса, например, чтобы узнать размер *MyClass* , или применять основание или член класса *MyClass*. Класс*MyClass* считается определенным, только когда компилятор обнаружит полное определение *MyClass*.

Следующий пример демонстрирует принципы объявления разделяемого класса. После объявления #1 класс *MyClass* можно использовать так же, как если бы он был оформлен с применением опережающего объявления `ref class MyClass;`. Объявление №2 эквивалентно объявлению №1. Объявление №3 допустимо, поскольку является опережающим объявлением для класса. Однако объявление №4 недопустимо, потому что

*MyClass* не определен полностью.

В объявлении #5 не используется ключевое слово `partial` , и это объявление полностью определяет класс *MyClass*. Поэтому объявление #6 допустимо.

[!code-cpp[Cx_partial#03](../cppcx/codesnippet/CPP/partialclassexample/class1.h#03)]

## <a name="number-and-ordering"></a>Количество и порядок указания

Для каждого полного определения класса может существовать одно определение разделяемого класса, несколько таких определений или ни одного.

Каждое разделяемое определение класса должно лексически предшествовать его единственному полному определению, но не обязательно — его опережающим объявлениям. Если у класса отсутствует полное определение, объявления разделяемого класса могут быть только опережающими объявлениями.

Все ключи класса, такие как **`class`** и, **`struct`** должны совпадать. Например, ошибкой будет создать код `partial class X {}; struct X {};`.

В следующем примере демонстрируется количество и порядок указания объявлений. Последнее объявление разделяемого класса вызывает сбой, поскольку класс уже определен.

[!code-cpp[cx_partial#04](../cppcx/codesnippet/CPP/partialclassexample/class1.h#04)]

## <a name="full-definition"></a>Полное определение

Когда компилятор встречает полное определение класса X, он действует, как если бы именно в нем были объявлены все базовые классы, члены и т. п. в том порядке, в котором они определены в разделяемых классах. Таким образом, содержимое разделяемых классов обрабатывается так, как если бы оно находилось в полном определении класса, и поиск имени и другие языковые правила применяются к полному определению класса, как если бы в нем находилось содержимое разделяемых классов.

Следующие два примера кода аналогичны и действуют одинаково. В первом примере используется разделяемый класс, а втором — нет.

[!code-cpp[cx_partial#05](../cppcx/codesnippet/CPP/partialclassexample/class1.h#05)]

[!code-cpp[cx_partial#06](../cppcx/codesnippet/CPP/partialclassexample/class1.h#06)]

## <a name="templates"></a>Шаблоны

Разделяемый класс не может быть шаблоном.

## <a name="restrictions"></a>Ограничения

Разделяемый класс не может распространяться за пределы одной записи преобразования.

`partial`Ключевое слово поддерживается только в сочетании с **`ref class`** ключевым словом или **`value class`** ключевым словом.

### <a name="examples"></a>Примеры

В следующем примере класс `Address` определяется в двух файлах кода. Конструктор изменяет файл `Address.details.h` , а пользователь — файл `Address.h`. Ключевое слово `partial` используется только в определении класса в первом файле.

[!code-cpp[cx_partial#07](../cppcx/codesnippet/CPP/partialclassexample/address.details.h#07)]

[!code-cpp[cx_partial#09](../cppcx/codesnippet/CPP/partialclassexample/address.h#09)]

## <a name="see-also"></a>См. также раздел

[Система типов](../cppcx/type-system-c-cx.md)<br/>
[Справочник по языку C++/CX](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[Справочник по пространствам имен](../cppcx/namespaces-reference-c-cx.md)
