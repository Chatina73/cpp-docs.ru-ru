---
title: Разделяемые классы (C++/CX)
description: Объявление и использование разделяемых классов в C++/CX.
ms.date: 12/30/2016
ms.assetid: 69d93575-636c-4564-8cca-6dfba0c7e328
ms.openlocfilehash: 70225069c948a50b38ac3642113cf940c86cf8da
ms.sourcegitcommit: 0df2b7ab4e81284c5248e4584767591dcc1950c3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/09/2020
ms.locfileid: "89609067"
---
# <a name="partial-classes-ccx"></a>Разделяемые классы (C++/CX)

Разделяемый класс — это конструкция, предназначенная для ситуаций, когда вы изменяете часть определения класса, и программное обеспечение для автоматического построения кода (например, конструктор XAML) также изменяет код в этом классе. Использование разделяемых классов позволяет предотвратить изменение вашего кода конструктором. В проекте Visual Studio **`partial`** Модификатор автоматически применяется к созданному файлу.

## <a name="syntax"></a>Синтаксис

Чтобы определить разделяемый класс, используйте **`partial`** ключевое слово непосредственно перед ключом класса, что в противном случае было бы обычным определением класса. Ключевое слово, например, **`partial ref class`** является контекстным ключевым словом, содержащим символы пробела. Определения разделяемых классов поддерживаются в следующих конструкциях.

- **`class`** или **`struct`**

- **`ref class`** или **`ref struct`**

- **`value class`** или **`value struct`**

- **`enum`** или **`enum class`**

- **`ref interface`**, **`interface class`** , **`interface struct`** или **`__interface`**

- **`union`**

В этом примере демонстрируется частичное **`ref class`** :

[!code-cpp[cx_partial#01](../cppcx/codesnippet/CPP/partialclassexample/class1.h#01)]

## <a name="contents"></a>Содержимое

Определение разделяемого класса может содержать все, что может содержать полное определение класса, если **`partial`** ключевое слово было пропущено. Оно может содержать любые допустимые конструкции (за единственным исключением), такие как базовые классы, данные-члены, функции-члены, перечисления, объявления дружественных функций и атрибуты. Встроенные определения и статические данные-члены также допускаются.

Единственное исключение — ключевые слова, указывающие возможность доступа к классу. Например, выражение `public partial class MyInvalidClass {/* ... */};` является ошибкой. Ключевые слова в определении разделяемого класса MyInvalidClass, указывающие возможность доступа, не влияют на возможность доступа по умолчанию в последующем разделяемом или полном определении класса MyInvalidClass.

В следующем фрагменте кода демонстрируются ключевые слова, указывающие возможность доступа. В первом разделяемом классе `Method1` является открытым, поскольку для него задано ключевое слово public. Во втором разделяемом классе `Method2` является закрытым, поскольку по умолчанию класс является закрытым.

[!code-cpp[cx_partial#02](../cppcx/codesnippet/CPP/partialclassexample/class1.h#02)]

## <a name="declaration"></a>Объявление

Частичное определение класса, например `MyClass` , является только объявлением MyClass. То есть он только вводит имя `MyClass` . `MyClass` не может использоваться способом, требующим определения класса, например, знание размера `MyClass` или использования базового типа или члена `MyClass` . `MyClass` считается определенным, только если компилятор обнаруживает не разделяемое определение `MyClass` .

Следующий пример демонстрирует принципы объявления разделяемого класса. После #1 объявления `MyClass` можно использовать, как если бы оно было написано в качестве прямого объявления, `ref class MyClass;` . Объявление №2 эквивалентно объявлению №1. Объявление №3 допустимо, поскольку является опережающим объявлением для класса. Однако объявление №4 недопустимо, потому что

`MyClass` не определяется полностью.

Объявление #5 не использует **`partial`** ключевое слово, а объявление полностью определяет `MyClass` . Поэтому объявление #6 допустимо.

[!code-cpp[Cx_partial#03](../cppcx/codesnippet/CPP/partialclassexample/class1.h#03)]

## <a name="number-and-ordering"></a>Количество и порядок указания

Для каждого полного определения класса может существовать одно определение разделяемого класса, несколько таких определений или ни одного.

Каждое определение разделяемого класса класса должно быть лексической перед одним полным определением этого класса, но не должно предшествовать объявлениям класса вперед. Если у класса отсутствует полное определение, объявления разделяемого класса могут быть только опережающими объявлениями.

Все ключи класса, такие как **`class`** и, **`struct`** должны совпадать. Например, ошибкой будет создать код `partial class X {}; struct X {};`.

В следующем примере демонстрируется количество и порядок указания объявлений. Последнее объявление разделяемого класса вызывает сбой, поскольку класс уже определен.

[!code-cpp[cx_partial#04](../cppcx/codesnippet/CPP/partialclassexample/class1.h#04)]

## <a name="full-definition"></a>Полное определение

Когда компилятор встречает полное определение класса X, он действует, как если бы именно в нем были объявлены все базовые классы, члены и т. п. в том порядке, в котором они определены в разделяемых классах. Таким образом, содержимое разделяемых классов обрабатывается так, как если бы оно находилось в полном определении класса, и поиск имени и другие языковые правила применяются к полному определению класса, как если бы в нем находилось содержимое разделяемых классов.

Следующие два примера кода аналогичны и действуют одинаково. В первом примере используется разделяемый класс, а втором — нет.

[!code-cpp[cx_partial#05](../cppcx/codesnippet/CPP/partialclassexample/class1.h#05)]

[!code-cpp[cx_partial#06](../cppcx/codesnippet/CPP/partialclassexample/class1.h#06)]

## <a name="templates"></a>Шаблоны

Разделяемый класс не может быть шаблоном.

## <a name="restrictions"></a>Ограничения

Разделяемый класс не может распространяться за пределы одной записи преобразования.

**`partial`** Ключевое слово поддерживается только в сочетании с **`ref class`** ключевым словом или **`value class`** ключевым словом.

### <a name="examples"></a>Примеры

В следующем примере класс `Address` определяется в двух файлах кода. Конструктор изменяет файл `Address.details.h` , а пользователь — файл `Address.h`. Только определение класса в первом файле использует **`partial`** ключевое слово.

[!code-cpp[cx_partial#07](../cppcx/codesnippet/CPP/partialclassexample/address.details.h#07)]

[!code-cpp[cx_partial#09](../cppcx/codesnippet/CPP/partialclassexample/address.h#09)]

## <a name="see-also"></a>См. также раздел

[Система типов](../cppcx/type-system-c-cx.md)<br/>
[Справочник по языку C++/CX](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[Справочник по пространствам имен](../cppcx/namespaces-reference-c-cx.md)
