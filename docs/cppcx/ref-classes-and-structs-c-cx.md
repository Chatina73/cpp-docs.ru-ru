---
title: Классы и структуры ссылки (C++/CX)
ms.date: 01/22/2017
ms.assetid: 3d736b82-0bf0-48cf-bac1-cc9d110b70d1
ms.openlocfilehash: d128734f8c78c9198f0731b415c1be35b0c58e65
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87214962"
---
# <a name="ref-classes-and-structs-ccx"></a>Классы и структуры ссылки (C++/CX)

C++/CX поддерживает определяемые пользователем *ссылочные классы* и *Ссылочные структуры*, а также пользовательские *классы значений* и *структуры значений*. Эти структуры данных являются основными контейнерами, по которым C++/CX поддерживает систему типов среда выполнения Windows. Их содержимое передается в метаданные в соответствии с определенными правилами, и это позволяет передавать их между компонентами среда выполнения Windows и универсальная платформа Windows приложениями, написанными на C++ или на других языках.

Класс ссылки и структура ссылки имеют следующие основные особенности:

- они должны объявляться в пространстве имен, в области пространства имен, и в этом пространстве имен они могут иметь режим доступа public (открытый) или private (закрытый). Только открытые типы формируют метаданные; Определения вложенных открытых классов не допускаются, в том числе определения вложенных открытых классов [enum](../cppcx/enums-c-cx.md) . Дополнительные сведения см. в разделе [пространства имен и видимость типов](../cppcx/namespaces-and-type-visibility-c-cx.md).

- Он может содержать члены C++/CX, включая классы ссылок, классы значений, структуры ссылок, структуры значений или структуры значений, допускающие значения NULL. Он также может содержать скалярные типы, такие как `float64` , **`bool`** и т. д. Он также может содержать стандартные типы C++, например `std::vector` , или пользовательский класс при условии, что они не являются открытыми. Конструкции C++/CX могут иметь **`public`** **`protected`** **`internal`** Специальные возможности,,, **`private`** или **`protected private`** . Все **`public`** **`protected`** члены или передаются в метаданные. Стандартные типы C++ должны иметь **`private`** **`internal`** доступ, или **`protected private`** , что не позволяет выдавать их в метаданные.

- они могут реализовывать один или несколько *классов интерфейсов* или *структур интерфейсов*;

- они могут наследовать одному базовому классу, а на сами базовые классы налагаются дополнительные ограничения. Наследование в иерархиях открытых классов ссылок имеет больше ограничений, чем наследование закрытых классов ссылок;

- они не могут объявляться как универсальные. Если они имеют закрытый доступ, они могут быть шаблонами;

- Их время жизни управляется автоматическим подсчетом ссылок.

## <a name="declaration"></a>Объявление

В следующем фрагменте кода объявляется класс ссылки `Person` . Обратите внимание, что стандартный `std::map` тип C++ используется в закрытых членах, а `IMapView` интерфейс Среда выполнения Windows используется в открытом интерфейсе. Также обратите внимание, что в конце объявлений ссылочных типов используется оператор "^".

[!code-cpp[cx_classes#03](../cppcx/codesnippet/CPP/classesstructs/class1.h#03)]

## <a name="implementation"></a>Реализация

В этом примере кода демонстрируется реализация класса ссылки `Person` .

[!code-cpp[cx_classes#04](../cppcx/codesnippet/CPP/classesstructs/class1.cpp#04)]

## <a name="usage"></a>Использование

В следующем примере кода показано, как клиентский код использует класс ссылки `Person` .

[!code-cpp[cx_classes#05](../cppcx/codesnippet/CPP/classesstructs/class1.cpp#05)]

Также можно также объявить локальную переменную класса ссылки с помощью семантики стека. Поведение такого объекта аналогично поведению стековой переменной, несмотря на то что память все же выделяется динамически. Важное отличие заключается в том, что нельзя присвоить отслеживаемую ссылку (%) переменной, объявленной с использованием семантики стека: таким образом гарантируется, что счетчик ссылок уменьшается до нуля, когда выполняется выход из функции. В этом примере показаны базовый класс ссылки `Uri`и функция, в которой он используется с семантикой стека:

[!code-cpp[cx_classes#06](../cppcx/codesnippet/CPP/classesstructs/class1.cpp#06)]

## <a name="memory-management"></a>Управление памятью

Класс ссылки выделяется в динамической памяти с помощью **`ref new`** ключевого слова.

[!code-cpp[cx_classes#01](../cppcx/codesnippet/CPP/classesstructs/class1.h#01)]

Оператор Handle-to-Object **`^`** известен как *Hat* и является принципиально интеллектуальным указателем C++. Память, на которую он указывает, автоматически уничтожается, когда последний элемент выходит за пределы области или явно имеет значение **`nullptr`** .

По определению класс ссылки имеет семантику ссылки. Когда вы присваиваете значение переменной класса ссылки, копируется не сам объект, а его дескриптор. В следующем примере после операции присваивания оба объекта `myClass` и `myClass2` указывают на одно и то же расположение в памяти.

[!code-cpp[cx_classes#02](../cppcx/codesnippet/CPP/classesstructs/class1.h#02)]

Когда создается экземпляр класса ссылки C++/CX, его память перед вызовом конструктора инициализируется нулями, поэтому такая инициализация для отдельных членов, включая свойства, не требуется. Если класс C++/CX является производным от класса библиотеки C++ для среды выполнения Windows (WRL), инициализация нулями осуществляется только для области производного класса C++/CX.

### <a name="members"></a>Элементы

Ссылочный класс может содержать **`public`** члены функций, и, а также **`protected`** **`private`** только **`public`** члены, **`protected`** которые передаются в метаданные. Вложенные классы и классы ссылок разрешены, но не могут быть **`public`** . Открытые поля не допускаются; открытые члены данных должны объявляться как свойства. Закрытые и защищенные внутренние данные-члены могут быть полями. По умолчанию в классе ссылки доступность всех членов имеет значение **`private`** .

Структура ref аналогична ссылочному классу, за исключением того, что ее члены по умолчанию имеют **`public`** доступ.

**`public`** Ссылочный класс или структура ссылки создаются в метаданных, но их можно использовать из других универсальная платформа Windows приложений и среда выполнения Windows компонентов, которые должны иметь по крайней мере один открытый или защищенный конструктор. Открытый класс ссылки, имеющий открытый конструктор, также должен быть объявлен как **`sealed`** для предотвращения дальнейшего наследования через двоичный интерфейс приложения (ABI).

Открытые члены не могут быть объявлены как **`const`** , так как система типов Среда выполнения Windows не поддерживает const. Можно использовать статическое свойство для объявления открытого члена данных с постоянным значением.

При определении открытого класса или структуры ссылок компилятор применяет необходимые атрибуты к классу и сохраняет эти сведения в файле WinMD приложения. Однако при определении открытого незапечатанного класса ссылки вручную примените `Windows::Foundation::Metadata::WebHostHidden` атрибут, чтобы класс не был видимым для универсальная платформа Windows приложений, написанных на JavaScript.

Класс ссылки может иметь стандартные типы C++, включая **`const`** типы, в любых **`private`** **`internal`** членах, или **`protected private`** .

Открытые классы ссылки, имеющие параметры-типы, не допускаются. Определяемые пользователем универсальные классы ссылок не допускаются. Класс ссылки с атрибутами private, internal или protected private может быть шаблоном.

## <a name="destructors"></a>Деструкторы

В C++/CX вызов метода **`delete`** в открытом деструкторе вызывает деструктор независимо от счетчика ссылок объекта. Это позволяет определить деструктор, который будет выполнять пользовательскую очистку ресурсов, не относящихся к RAII, детерминированным образом. Однако даже в этом случае сам объект не удаляется из памяти. Память для объекта освобождается, только когда число ссылок достигает нуля.

Если деструктор класса не является общим, он вызывается только в случае, когда число ссылок достигает нуля. При вызове `delete` для объекта, имеющего закрытый деструктор, компилятор выдает предупреждение C4493, что говорит о том, что выражение delete не действует, так как деструктор не имеет модификатора \<type name> public.

Деструкторы классов ссылок можно объявлять только следующим образом:

- открытый и виртуальный (допускается только для запечатанных и незапечатанных типов);

- защищенный закрытый и невиртуальный (допускается только для незапечатанных типов);

- закрытый и невиртуальный (допускается только для запечатанных типов).

Никакие другие сочетания режимов доступа, виртуальности и запечатанности не допускаются.  Если деструктор явно не объявлен, компилятор создает открытый виртуальный деструктор, если у базового класса типа или любого из его членов имеется открытый деструктор. В противном случае компилятор создает защищенный закрытый невиртуальный деструктор для незапечатанных типов и закрытый невиртуальный деструктор для запечатанных типов.

При попытке обращения к членам класса, для которого уже запускался деструктор, поведение будет неопределенным; это наиболее вероятная причина сбоя программы. При вызове `delete t` для типа, у которого нет открытого деструктора, ничего не происходит. Вызов `delete this` для типа или базового класса, который имеет известный **`private`** деструктор или **`protected private`** из его иерархии типов, не оказывает никакого влияния.

При объявлении открытого деструктора компилятор создает код таким образом, чтобы класс ссылки реализовывал интерфейс `Platform::IDisposable` , а деструктор реализовывал метод `Dispose` . `Platform::IDisposable`— Это проекция C++/CX `Windows::Foundation::IClosable` . Никогда не следует явным образом реализовывать эти интерфейсы.

## <a name="inheritance"></a>Наследование

Platform::Object является универсальным базовым классом для всех классов ссылок. Все классы ссылок неявно преобразуются в Platform::Object и могут переопределять [Object::ToString](../cppcx/platform-object-class.md#tostring). Однако модель наследования среда выполнения Windows не предназначена как общая модель наследования. в C++/CX это означает, что определяемый пользователем открытый класс ссылки не может служить базовым классом.

При создании пользовательского элемента управления XAML можно использовать в качестве базового класса `Windows::UI::Xaml::DependencyObject` , если объект участвует в системе свойств зависимостей.

После определения незапечатанного класса `MyBase` , который наследует классу `DependencyObject`, другие открытые или закрытые классы ссылок в компоненте или приложении могут наследовать этому классу `MyBase`. Наследование в открытых классах ссылок должно использоваться только для поддержки переопределений виртуальных методов, полиморфной идентичности и инкапсуляции.

Закрытый базовый класс ссылки не требуется для наследования от существующего незапечатанного класса. Если требуется, чтобы иерархия объектов моделировала собственную структуру программы или обеспечивала повторное использование кода, используйте закрытые или внутренние классы ссылок, а лучше стандартные классы C++. Доступ к функциональности закрытой иерархии объектов можно реализовать с помощью оболочки открытого запечатанного класса ссылки.

Класс ссылки, имеющий открытый или защищенный конструктор в C++/CX, должен быть объявлен как Sealed. Это ограничение означает, что для классов, написанных на других языках, таких как C# или Visual Basic, не существует способа наследования от типов, объявляемых в среда выполнения Windows компоненте, написанном на C++/CX.

Ниже приведены основные правила наследования в C++/CX.

- классы ссылок могут напрямую наследовать не более чем от одного базового класса, но могут реализовывать любое количество интерфейсов;

- если у класса имеется открытый конструктор, он должен объявляться как запечатанный, чтобы запретить его дальнейшее наследование;

- можно создавать открытые незапечатанные базовые классы, которые имеют внутренние или защищенные закрытые конструкторы, при условии что базовый класс является производным (прямо или косвенно) от существующего незапечатанного базового класса, такого как `Windows::UI::Xaml::DependencyObject`. Наследование определяемых пользователем классов ссылок между файлами WinMD не поддерживается; однако класс ссылки может наследовать от интерфейса, определенного в другом файле WinMD. Производные классы можно создавать из определяемого пользователем базового класса ссылки только в том же среда выполнения Windows компоненте или универсальная платформа Windows приложении.

- для классов ссылок поддерживается только открытое наследование.

   [!code-cpp[cx_classes#08](../cppcx/codesnippet/CPP/classesstructs/class1.h#08)]

В следующем примере показано, как предоставлять доступ к открытому классу ссылки, производному от других классов ссылки в иерархии наследования.

[!code-cpp[cx_classes#09](../cppcx/codesnippet/CPP/classesstructs/class1.h#09)]

## <a name="see-also"></a>См. также раздел

[Система типов](../cppcx/type-system-c-cx.md)<br/>
[Классы и структуры значения](../cppcx/value-classes-and-structs-c-cx.md)<br/>
[Справочник по языку C++/CX](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[Справочник по пространствам имен](../cppcx/namespaces-reference-c-cx.md)
