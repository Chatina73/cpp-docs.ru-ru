---
title: 'Синтаксис спецификации формата: `printf` и `wprintf` функции'
description: Описывает синтаксис описателя формата для среды выполнения `printf` и функций Microsoft C `wprintf`
ms.date: 10/26/2020
helpviewer_keywords:
- format specification fields for printf function
- printf function format specification fields
- flag directives, printf function
- type fields, printf function
- width fields, printf function
- precision fields, printf function
ms.assetid: 664b1717-2760-4c61-bd9c-22eee618d825
ms.openlocfilehash: 18642f650949e346fd3421b4a123acb4e84ed659
ms.sourcegitcommit: 9c801a43ee0d4d84956b03fd387716c818705e0d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/28/2020
ms.locfileid: "92907536"
---
# <a name="format-specification-syntax-printf-and-wprintf-functions"></a>Синтаксис описания формата: функции printf и wprintf

Различные функции `printf` и `wprintf` принимают строку формата и необязательные аргументы и создают форматированную последовательность символов для выходных данных. Строка формата не содержит ни одной или содержит несколько *директив* , которые являются либо литеральными символами для выходных данных, либо закодированными *спецификациями преобразования* , описывающими способ форматирования аргумента в выходных данных. Эта статья описывает синтаксис для кодирования спецификаций преобразования в строке формата. Список этих функций см. в разделе [Потоковый ввод-вывод](../c-runtime-library/stream-i-o.md).

Спецификация преобразования состоит из необязательных и обязательных полей, имеющих следующий вид:

**%** [ [*flags*](#flags)] [ [*Ширина*](#width)] [. [*точность*](#precision)] [ [*Размер*](#size)] [*тип*](#type)

Каждое поле спецификации преобразования — это символ или число, указывающее конкретный параметр формата или описатель преобразования. Обязательное поле *type* определяет тип преобразования, которое применяется к аргументу. Необязательные поля *flags* , *width* и *precision* управляют дополнительными аспектами формата, такими как начальные пробелы или нули, выравнивание и отображаемая точность. Поле *size* указывает размер использованного и преобразованного аргумента.

Базовая спецификация преобразования содержит только символ процента и символ *type* . Например, `%s` определяет преобразование строк. Чтобы вывести символ знака процента, используйте `%%`. Если за символом процента следует символ, который не имеет смысла в поле формата, вызывается обработчик недопустимого параметра. Дополнительные сведения см. в разделе [Проверка параметров](../c-runtime-library/parameter-validation.md).

> [!IMPORTANT]
> Для обеспечения безопасности и стабильности убедитесь, что строки спецификации преобразования не определяются пользователем. Например, рассмотрим программу, которая предлагает пользователю ввести имя и сохраняет введенные данные в строковой переменной с именем `user_name`. Для печати переменной `user_name` не используйте следующий код:
>
> `printf( user_name ); /* Danger!  If user_name contains "%s", program will crash */`
>
> Вместо этого используйте следующий код:
>
> `printf( "%s", user_name );`

<a name="type"></a>

> [!NOTE]
> В Visual Studio 2015 `printf` функции и `scanf` семейство функций были объявлены как **`inline`** и перемещены в `<stdio.h>` `<conio.h>` заголовки и. При переносе старого кода вы можете увидеть ошибку *LNK2019* в подключении к этим функциям. Дополнительные сведения см. в статье [Visual C++ журнал изменений 2003-2015](../porting/visual-cpp-change-history-2003-2015.md#stdio_and_conio).

## <a name="type-conversion-specifier"></a>Спецификатор преобразования типов

Символ спецификации преобразования *type* определяет, как должен интерпретироваться соответствующий аргумент: как символ, строка, указатель, целое число или число с плавающей запятой. Символ *type*  — единственное обязательное поле спецификации преобразования; он указывается после всех необязательных полей.

Аргументы, которые следуют за строкой формата, интерпретируются согласно соответствующему символу *type* и необязательному префиксу [size](#size). Преобразования для символьных типов и задаются с `char` `wchar_t` помощью **`c`** или **`C`** , а строки однобайтовых и многобайтовых или расширенных символов задаются с помощью **`s`** или **`S`** , в зависимости от того, какая функция форматирования используется. Символьные и строковые аргументы, заданные с помощью **`c`** и **`s`** , обрабатываются как `char` и `char*` `printf` функциями семейства, а также как `wchar_t` и `wchar_t*` `wprintf` функциями семейства. Символьные и строковые аргументы, заданные с помощью **`C`** и **`S`** , обрабатываются как `wchar_t` и `wchar_t*` `printf` функциями семейства, а также как `char` и `char*` `wprintf` функциями семейства. Такое поведение характерно для Microsoft.

Целочисленные типы, такие как,,, `short` `int` `long` `long long` и их варианты, задаются `unsigned` с помощью **`d`** , **`i`** , **`o`** ,, **`u`** **`x`** и **`X`** . Типы с плавающей запятой, такие как `float` , `double` и **`long double`** , задаются с помощью **`a`** , **`A`** , **`e`** , **`E`** , **`f`** , **`F`** , **`g`** и **`G`** . По умолчанию, если они не изменяются префиксом *размера* , целочисленные аргументы приводятся к `int` типу, а аргументы с плавающей запятой приводятся к `double` . В 64-разрядных системах `int` значение является 32-битным значением, поэтому 64-разрядные целые числа будут обрезаны при форматировании для вывода, если не используется префикс *размера* **LL** или **I64** . Типы указателей, заданные с помощью, **`p`** используют размер указателя по умолчанию для платформы.

> [!NOTE]
> **Зависит от корпорации Майкрософт:**\
> **`Z`** Символ типа, а также поведение **`c`** **`C`** **`s`** символов типа,, и, **`S`** если они используются с `printf` `wprintf` функциями и, являются расширениями Майкрософт. Стандарт ISO C использует **`c`** и **`s`** согласованно для узких символов и строк, а **`C`** также **`S`** для расширенных символов и строк во всех функциях форматирования.

### <a name="type-field-characters"></a>Символы поля типа

|Символ типа|Аргумент|Формат вывода|
|--------------------|--------------|-------------------|
|**`c`**|Знак|При использовании с функциями `printf` определяет однобайтовый символ; при использовании с функциями `wprintf` определяет расширенный символ.|
|**`C`**|Знак|При использовании с функциями `printf` определяет расширенный символ; при использовании с функциями `wprintf` определяет однобайтовый символ.|
|**`d`**|Целое число|Десятичное целое число со знаком.|
|**`i`**|Целое число|Десятичное целое число со знаком.|
|**`o`**|Целое число|Восьмеричное целое число без знака.|
|**`u`**|Целое число|Десятичное целое число без знака.|
|**`x`**|Целое число|Шестнадцатеричное целое число без знака; использует " `abcdef` ".|
|**`X`**|Целое число|Шестнадцатеричное целое число без знака; использует " `ABCDEF` ".|
|**`e`**|С плавающей запятой|Значение со знаком, имеющее форму [-] *`d.dddd`* __e ±__ *`dd`* \[ *`d`* ], где *`d`* — одна десятичная цифра, *`dddd`* — одна или несколько десятичных цифр в зависимости от указанной точности, или шесть по умолчанию, а *`dd`* \[ *`d`* ] — две или три десятичные цифры в зависимости от [формата выходных данных](../c-runtime-library/set-output-format.md) и размера экспоненты.|
|**`E`**|С плавающей запятой|Аналогично **`e`** формату, за исключением того, что **`E`** **`e`** он представляет экспоненту.|
|**`f`**|С плавающей запятой|Значение со знаком, имеющее форму [-] *`dddd`* __.__ *`dddd`* , где *`dddd`* — одна или несколько десятичных цифр. Количество цифр перед десятичной запятой зависит от величины числа, а количество знаков после десятичной запятой зависит от указанной точности либо используется шесть по умолчанию.|
|**`F`**|С плавающей запятой|Идентично **`f`** формату, за исключением того, что выходные данные бесконечности и NaN заменяются прописными буквами.|
|**`g`**|С плавающей запятой|Значения со знаком отображаются в **`f`** **`e`** формате или, в зависимости от более компактных значений для заданного значения и точности. **`e`** Формат используется только в том случае, если экспонента значения меньше-4 или больше или равна аргументу *точности* . Нули в конце отбрасываются, а десятичная запятая отображается только в том случае, если за ней следует хотя бы одна цифра.|
|**`G`**|С плавающей запятой|Аналогично **`g`** формату, за исключением того, что **`E`** **`e`** в нем вводится экспонента (где это необходимо).|
|**`a`**|С плавающей запятой|Подписанное шестнадцатеричное значение двойной точности с плавающей запятой, имеющее форму *[-] 0xh. hhhh*__p ±__ *`dd`* , где *h. hhhh* — шестнадцатеричные цифры мантиссаа, а *`dd`* — одна или несколько цифр для экспоненты. Точность определяет количество цифр после запятой.|
|**`A`**|С плавающей запятой|Шестнадцатеричное значение двойной точности с плавающей запятой, имеющее форму *[-] 0xh. hhhh*__P ±__ *`dd`* , где *h. hhhh* — шестнадцатеричные цифры (с использованием прописных букв) мантисса, а *дд* — одна или несколько цифр для экспоненты. Точность определяет количество цифр после запятой.|
|**`n`**|Указатель на целое число|Число символов, которые успешно записаны на данный момент в поток или буфер. Это значение хранится в целом числе, адрес которого указан в качестве аргумента. Размер целочисленного значения, на которое ссылается указатель, управляется префиксом спецификации размера аргумента. **`n`** Описатель отключен по умолчанию. Дополнительные сведения см. в статье важное замечание по безопасности.|
|**`p`**|Тип указателя|Отображение аргумента в виде адреса в шестнадцатеричных цифрах.|
|**`s`**|Строка|При использовании с функциями `printf` определяет строку однобайтовых или многобайтовых символов; при использовании с функциями `wprintf` определяет строку расширенных символов. Символы отображаются до первого нулевого символа или до тех пор, пока не будет достигнуто значение *precision* .|
|**`S`**|Строка|При использовании с функциями `printf` определяет строку расширенных символов; при использовании с функциями `wprintf` определяет строку однобайтовых или многобайтовых символов. Символы отображаются до первого нулевого символа или до тех пор, пока не будет достигнуто значение *precision* .|
|**`Z`**|Структура `ANSI_STRING` или `UNICODE_STRING`|Если адрес [`ANSI_STRING`](/windows/win32/api/ntdef/ns-ntdef-string) [`UNICODE_STRING`](/windows/win32/api/ntdef/ns-ntdef-_unicode_string) структуры или передается в качестве аргумента, отобразите строку, содержащуюся в буфере, на который указывает `Buffer` поле структуры. Используйте префикс модификатора *размера* **`w`** для, чтобы указать аргумент, например `UNICODE_STRING` `%wZ` . Поле `Length` структуры должно содержать значение длины строки в байтах. Поле `MaximumLength` структуры должно содержать значение длины буфера в байтах.<br /><br />Как правило, **`Z`** символ типа используется только в отладочных функциях драйвера, использующих спецификацию преобразования, например `dbgPrint` и `kdPrint` .|

Начиная с Visual Studio 2015, если аргумент, соответствующий спецификатору преобразования с плавающей запятой ( **`a`** ,,,,,, **`A`** **`e`** **`E`** **`f`** **`F`** **`g`** , **`G`** ) имеет бесконечную, неопределенное или NaN, отформатированные выходные данные соответствуют стандарту C99. В этой таблице перечислены форматированные выходные данные.

|Значение|Выходные данные|
|-----------|------------|
|infinity|`inf`|
|Несигнальное значение NaN|`nan`|
|Сигнальное значение NaN|`nan(snan)`|
|Неопределенное значение NaN|`nan(ind)`|

Любое из этих значение может иметь префикс в виде знака. Если символ описателя преобразования *type* с плавающей запятой является прописной буквой, выходные данные форматируются также прописными буквами. Например, если спецификатором формата является `%F` вместо `%f`, бесконечность форматируется как `INF` вместо `inf`. Функции `scanf` также могут анализировать эти строки, поэтому эти значения могут совершать круговой путь через функции `printf` и `scanf`.

До выхода Visual Studio 2015 в среде CRT использовался другой нестандартный формат для выходных данных значений бесконечности, неопределенных значений и значений NaN.

|Значение|Выходные данные|
|-----------|------------|
|+ бесконечность|`1.#INF` *случайные цифры*|
|- infinity|`-1.#INF` *случайные цифры*|
|Неопределенное (то же, что и не число без вызова исключения)|*цифра* `.#IND` *случайные цифры*|
|не число|*цифра* `.#NAN` *случайные цифры*|

Любое из них могло быть предваряться знаком и может быть отформатировано по-разному в зависимости от ширины и точности поля, иногда с ненеобычными эффектами. Например, `printf("%.2f\n", INFINITY)` печатается, `1.#J` так как *#INF* будет "округляться" до двух цифр точности.

> [!NOTE]
> Если аргумент, который соответствует `%s` или `%S`, или поле `Buffer` аргумента, который соответствует `%Z`, является указателем NULL, отображается значение "(NULL)".

> [!NOTE]
> Во всех экспоненциальных форматах минимальное отображаемое количество цифр показателя степени по умолчанию равно двум (три используются только при необходимости). С помощью [`_set_output_format`](../c-runtime-library/set-output-format.md) функции можно задать число цифр, отображаемых в трех, для обеспечения обратной совместимости с кодом, написанным для Visual Studio 2013 и более.

> [!IMPORTANT]
> Так как `%n` Формат по своей природе небезопасен, он по умолчанию отключен. Если в строке формата имеется символ `%n`, вызывается обработчик недопустимого параметра, как описано в разделе [Проверка параметров](../c-runtime-library/parameter-validation.md). Сведения о включении `%n` поддержки см. в разделе [`_set_printf_count_output`](../c-runtime-library/reference/set-printf-count-output.md) .

<a name="flags"></a>

## <a name="flag-directives"></a>Директивы флагов

Первое необязательное поле в спецификации преобразования содержит *директивы флагов* , ни одного или несколько символов флага, указывающих выравнивание выходных данных и управляющих выводом символов, пустых значений, начальных нулей, десятичных запятых и восьмеричных и шестнадцатеричных префиксов. В спецификации преобразования может быть указано несколько директив флагов, и символы флагов могут размещаться в любом порядке.

### <a name="flag-characters"></a>Символы флагов

|Флаг|Значение|По умолчанию|
|----------|-------------|-------------|
|**`-`**|Выравнивание результата по левому краю в пределах заданной ширины поля.|Выравнивание по правому краю.|
|**`+`**|Используйте знак (+ или-), чтобы добавить в качестве префикса выходное значение, если оно имеет тип со знаком.|Знак отображается только для отрицательных значений со знаком –.|
|**`0`**|Если параметр *Width* имеет префикс **`0`** , то добавляются начальные нули до тех пор, пока не будет достигнута минимальная ширина. Если оба **`0`** и **`-`** отображаются, параметр **`0`** игнорируется. Если параметр **`0`** указан для целочисленного формата ( **`i`** , **`u`** , **`x`** , **`X`** , **`o`** , **`d`** ), а также имеется спецификация точности (например,), `%04.d` то параметр **`0`** игнорируется. Если **`0`** для **`a`** **`A`** формата с плавающей запятой задано значение, начальные нули добавляются к мантисса после `0x` `0X` префикса или.|Без заполнения.|
|**пусто ("")**|Используйте пустое поле, чтобы добавить в качестве префикса выходное значение, если оно подписано и положительно. Пустой префикс игнорируется, если одновременно с ним присутствует флаг +.|Пустой префикс не отображается.|
|**`#`**|Если он используется с **`o`** **`x`** форматом,, или, **`X`** то **`#`** флаг использует `0` , `0x` или `0X` , соответственно, для префикса любого ненулевого выходного значения.|Пустой префикс не отображается.|
||Если он используется с **`e`** **`E`** форматом,, **`f`** ,, или, **`F`** **`a`** **`A`** то **`#`** флаг заставляет выходное значение содержать десятичную запятую.|Десятичный разделитель появляется, только если после него есть цифры.|
||Когда он используется с **`g`** **`G`** форматом или, **`#`** флаг заставляет выходное значение содержать десятичную запятую и не допустить усечения конечных нулей.<br /><br /> Игнорируется при использовании с **`c`** , **`d`** , **`i`** , **`u`** или **`s`** .|Десятичный разделитель появляется, только если после него есть цифры. Конечные нули отбрасываются.|

<a name="width"></a>

## <a name="width-specification"></a>Спецификация ширины

В спецификации преобразования необязательное поле спецификации ширины отображается после любых символов *флага* . Аргумент *width*  — неотрицательное целое десятичное число, управляющее минимальным количеством выводимых символов. Если число символов в выходном значении меньше указанной ширины, то слева или справа от значений добавляются пробелы, в зависимости от того, задан ли флаг выравнивания влево ( **`-`** ), до тех пор, пока не будет достигнута минимальная ширина. Если параметр *width* имеет префикс 0, при преобразовании к целому числу или числу с плавающей запятой добавляются начальные нули до тех пор, пока не будет достигнута минимальная ширина, кроме случаев преобразования в бесконечность или NaN (не число).

Спецификация ширины никогда не вызывает усечения значения. Если число символов в выходном значении больше указанной ширины или если не указана *Ширина* , все символы значения будут выводиться в соответствии со спецификацией *точности* .

Если в качестве спецификации ширины указана звездочка (`*`), значение ширины задается аргументом `int` из списка аргументов. Аргумент *width* должен предшествовать форматируемому значению в списке аргументов, как показано в следующем примере:

`printf("%0*d", 5, 3);  /* 00003 is output */`

Отсутствующее или малое значение *width* в спецификации преобразования не приводит к усечению выходного значения. Если количество символов в результате преобразования больше значения параметра *width* , поле расширяется, чтобы вместить результат преобразования.

<a name="precision"></a>

## <a name="precision-specification"></a>Спецификация точности

В спецификации преобразования третье необязательное поле является спецификацией точности. Он состоит из точки ( `.` ), за которой следует Неотрицательное десятичное целое число, которое в зависимости от типа конвертации указывает число символов строки, число десятичных разрядов или число значащих цифр для вывода.

В отличие от спецификации ширины, спецификация точности может вызывать либо усечение выходного значения, либо округление значения с плавающей запятой. Если *точность* указана как 0, а преобразуемое значение равно 0, результат не будет содержать символы, как показано в следующем примере:

`printf( "%.0d", 0 );      /* No characters output */`

Если спецификация точности представляет собой звездочку (`*`), аргумент `int` из списка аргументов предоставляет значение. В списке аргументов аргумент *precision* должен предшествовать форматируемому значению, как показано в следующем примере:

`printf( "%.*f", 3, 3.14159265 );  /* 3.142 output */`

Символ *type* определяет либо интерпретацию аргумента *precision* , либо точность по умолчанию при опущенном аргументе *precision* , как показано в следующей таблице.

### <a name="how-precision-values-affect-type"></a>Влияние значений точности на тип

|Тип|Значение|По умолчанию|
|----------|-------------|-------------|
|**`a`** , **`A`**|Точность определяет количество цифр после запятой.|Точность по умолчанию — 13. Если точность равна 0, то десятичная запятая не печатается, если не **`#`** используется флаг.|
|**`c`** , **`C`**|Точность не применяется.|Символ выводится.|
|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** , **`X`**|Точность определяет минимальное выводимое количество цифр. Если количество цифр в аргументе меньше значения *precision* , выходное значение дополняется слева нулями. Значение не усекается, если число цифр превышает *точность* .|Точность по умолчанию — 1.|
|**`e`** , **`E`**|Выводимое количество знаков дробной части задается спецификацией точности. Последняя выводимая цифра округляется.|Точность по умолчанию — 6. Если *точность* равна 0 или точка ( `.` ) отображается без номера, то десятичная запятая не печатается.|
|**`f`** , **`F`**|Значение точности задает количество цифр после десятичной запятой. Если десятичная запятая присутствует, перед ней присутствует по крайней мере одна цифра. Значение округляется до соответствующего количества цифр.|Точность по умолчанию — 6. Если *точность* равна 0 или если точка ( `.` ) отображается без числа после него, десятичная запятая не печатается.|
|**`g`** , **`G`**|Точность определяет максимальное выводимое количество значащих цифр.|Выводятся шесть значащих цифр, а конечные нули усекаются.|
|**`s`** , **`S`**|Точность определяет максимальное количество выводимых символов. Символы, выходящие за рамки *precision* , не выводятся.|Символы выводятся до тех пор, пока не будет найден символ null.|

<a name="size"></a>

## <a name="argument-size-specification"></a>Спецификация размера аргумента

В спецификации преобразования поле *size*  — это модификатор длины аргумента для описателя преобразования *type* . Префиксы полей *размера* для поля *типа* —,, **`hh`** , **`h`** **`j`** **`l`** (строчные буквы L),,,,, **`L`** **`ll`** **`t`** **`w`** **`z`** , **`I`** (прописные i), **`I32`** и **`I64`** — Укажите размер соответствующего аргумента — длинный или короткий, 32-разрядный или 64-разрядный, однобайтовый или расширенный символ — в зависимости от описателя преобразования, который они изменяют. Эти префиксы размера используются с символами *type* в семействах функций `printf` и `wprintf` для определения интерпретации размеров аргументов, как показано в следующей таблице. Поле *size* является необязательным для некоторых типов аргументов. Если префикс размера не указан, модуль форматирования использует целые аргументы, например подписанные или не подписанные `char`, `short`, `int`, `long` и типы перечисления как 32-разрядные типы `int`, а аргументы `float`, `double` и `long double` с плавающей запятой используются как 64-разрядные типы `double`. Такое поведение соответствует правилам повышения уровня аргументов по умолчанию для списков аргументов переменных. Дополнительные сведения об акциях аргументов см. в разделе аргументы многоточия и по умолчанию в [постфиксных выражениях](../cpp/postfix-expressions.md). В 32-разрядных и 64-разрядных системах спецификация преобразования для целочисленного аргумента 64-bit должна включать в себя префикс размера **`ll`** или **`I64`** . В противном случае поведение модуля форматирования не определено.

Некоторые типы имеют разный размер в 32-разрядном и 64-разрядном коде. Например, `size_t` на 32 бита длиннее в коде, скомпилированном для x86, и на 64 бита длиннее в коде, скомпилированном для x64. Чтобы создать код форматирования для типов с переменным количеством байт, не зависящий от платформы, можно использовать модификатор размера аргумента с переменным количеством байт. Вместо этого используйте 64-разрядный модификатор размера аргумента и явно додвигайте тип аргумента переменной ширины в 64 бит. **`I`** Модификатор размера аргумента, зависящий от Майкрософт (в верхнем регистре), обрабатывает целочисленные аргументы переменной ширины, но **`j`** **`t`** **`z`** для переносимости рекомендуется использовать модификаторы для конкретного типа, и.

### <a name="size-prefixes-for-printf-and-wprintf-format-type-specifiers"></a>Префиксы размера для описателей формата функций printf и wprintf

|Чтобы указать|Используемый префикс|Со спецификатором типа|
|----------------|----------------|-------------------------|
|`char`<br />`unsigned char`|**`hh`**|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|`short int`<br />`short unsigned int`|**`h`**|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|`__int32`<br />`unsigned __int32`|**`I32`**|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|`__int64`<br />`unsigned __int64`|**`I64`**|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|`intmax_t`<br />`uintmax_t`|**`j`** или **`I64`**|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|`long double`|**`l`** (строчная L) или **`L`**|**`a`** , **`A`** , **`e`** , **`E`** , **`f`** , **`F`** , **`g`** или **`G`**|
|`long int`<br />`long unsigned int`|**`l`** (строчная L) |**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`** |
|`long long int`<br />`unsigned long long int`|**`ll`**  (все символы в нижнем регистре)|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|`ptrdiff_t`|**`t`** или **`I`** (прописная i)|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|`size_t`|**`z`** или **`I`** (прописная i)|**`d`** , **`i`** , **`o`** , **`u`** , **`x`** или **`X`**|
|Однобайтовый символ|**`h`**|**`c`** или **`C`**|
|Расширенный символ|**`l`** (строчная L) или **`w`**|**`c`** или **`C`**|
|Строка однобайтовых символов|**`h`**|**`s`** , **`S`** или **`Z`**|
|Строка расширенных символов|**`l`** (строчная L) или **`w`**|**`s`** , **`S`** или **`Z`**|

Типы `ptrdiff_t` и `size_t` являются `__int32` или `unsigned __int32` на 32-разрядных платформах и `__int64` или `unsigned __int64` на 64-разрядных платформах. **`I`** Префиксы (прописные i), **`j`** , **`t`** и **`z`** size имеют правильную ширину аргумента для платформы.

В Visual C++ хотя `long double` является отдельным типом, он имеет то же внутреннее представление, что и тип `double`.

**`hc`** **`hC`** Описатель типа или является синонимом **`c`** в `printf` функциях и **`C`** в `wprintf` функциях. **`lc`** **`lC`** **`wc`** Описатель типа,, или **`wC`** является синонимом **`C`** в `printf` функциях и **`c`** в `wprintf` функциях. **`hs`** **`hS`** Описатель типа или является синонимом **`s`** в `printf` функциях и **`S`** в `wprintf` функциях. **`ls`** **`lS`** **`ws`** Описатель типа,, или **`wS`** является синонимом **`S`** в `printf` функциях и **`s`** в `wprintf` функциях.

> [!NOTE]
> **Зависит от корпорации Майкрософт:**\
> **`I`** **`I32`** **`I64`** Префиксы модификатора размера аргумента (прописные i),, и, и **`w`** являются расширениями Майкрософт и не совместимы с ISO C. **`h`** Префикс при использовании с данными типа `char` и **`l`** префикс (строчная L) при использовании с данными типа `double` — расширения Майкрософт.

## <a name="see-also"></a>См. также

[`printf, _printf_l, wprintf, _wprintf_l`](../c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l.md)\
[`printf_s, _printf_s_l, wprintf_s, _wprintf_s_l`](../c-runtime-library/reference/printf-s-printf-s-l-wprintf-s-wprintf-s-l.md)\
[`printf_p` Параметры позиционирования](../c-runtime-library/printf-p-positional-parameters.md)
