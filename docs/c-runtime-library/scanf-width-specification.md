---
title: Спецификация ширины scanf
ms.date: 10/22/2019
helpviewer_keywords:
- scanf function, width specification
ms.assetid: 94b4e8fe-c4a2-4799-8b6c-a2cf28ffb09c
ms.openlocfilehash: ea0b2728021e3093ab7818af17e60c598f73587f
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79444703"
---
# <a name="scanf-width-specification"></a>Спецификация ширины scanf

Эти данные применяются для интерпретации строк формата в семействе функций `scanf`, включая безопасные версии, такие как `scanf_s`. Эти функции обычно предполагают, что входной поток разбивается на последовательность токенов. Маркеры разделяются пробелами (пробел, символ табуляции, символ новой строки) или для числовых типов с помощью естественного конца числового типа данных, как указано первым символом, который не может быть преобразован в числовой текст. Однако с помощью спецификации ширины можно остановить анализ входных данных перед естественным концом токена.

Спецификация *width* состоит из символов между символом `%` и описателем типа поля, который может содержать целое положительное число, называемое полем ширины *width*, и один или несколько символов, указывающих размер поля, которые также могут считаться модификаторами типа поля, например показывать, является ли целочисленный тип типом **short** или **long**. Такие символы называются префиксами размера.

## <a name="the-width-field"></a>Поле Width

Поле *Width* — это положительное десятичное целое число, которое управляет максимальным числом символов, считываемых для этого поля. Не более *ширины* символов преобразуются и сохраняются в соответствующем `argument`. Если знак пробела или символ, который не может быть преобразован в соответствии с заданным форматом, происходит до достижения *ширины* , может быть считано *меньше символов.*

Спецификация ширины является отдельной и отличается от аргумента размер буфера, необходимого для использования безопасных версий этих функций (например, `scanf_s`, `wscanf_s`и т. д.). В следующем примере спецификация ширины равна 20; это означает, что из входного потока могут быть прочитаны до 20 символов. Длина буфера равна 21, что включает место для возможных 20 символов плюс завершающий нуль-символ:

```C
char str[21];
scanf_s("%20s", str, 21);
```

Если поле *Width* не используется, `scanf_s` пытается прочитать весь токен в строку. Если указанный размер недостаточно велик для хранения всего маркера, в целевую строку ничего не записывается. Если указано поле *Width* , то символы первой *ширины* в маркере записываются в строку назначения вместе с нулевым символом конца строки.

## <a name="the-size-prefix"></a>Префикс размера

Необязательные префиксы **h**, **чч**, **l**, **ll**, **I64**и **l** указывают размер `argument` (длинный или короткий, однобайтовый или широкий символ, в зависимости от того, какой символ типа они изменяют). Эти символы спецификации формата используются с символами типа в функциях `scanf` и `wscanf` для определения интерпретации аргументов, как показано в следующей таблице. Префикс типа **I64** является расширением Microsoft и несовместим со стандартом C. Символы типа и их значения описаны в таблице "символы типа для функций scanf" в [символах поля типа scanf](../c-runtime-library/scanf-type-field-characters.md).

> [!NOTE]
> Префиксы **h**, **l**и **l** являются расширениями Майкрософт при использовании с данными типа **char**.

### <a name="size-prefixes-for-scanf-and-wscanf-format-type-specifiers"></a>Префиксы размера для описателей типа формата scanf и wscanf

|Чтобы указать|Используемый префикс|Со спецификатором типа|
|----------------|----------------|-------------------------|
|**double**|**l**|**e**, **E**, **f**, **g** или **G**|
|**long double** (аналогично double)|**L**|**e**, **E**, **f**, **g** или **G**|
|**long int**|**l**|**d**, **i**, **o**, **x** или **X**|
|**long unsigned int**|**l**|**u**|
|**long long**|**ll**|**d**, **i**, **o**, **x** или **X**|
|**короткое целое**|**h**|**d**, **i**, **o**, **x** или **X**|
|**short unsigned int**|**h**|**u**|
|**char**|**hh**|**d**, **i**, **o**, **x** или **X**|
|**unsigned char**|**hh**|**u**|
|**int64**|**I64**|**d**, **i**, **o**, **u**, **x** или **X**|
|Однобайтовый символ для функции `scanf`|**h**|**c** или **C**|
|Однобайтовый символ для функции `wscanf`|**h**|**c** или **C**|
|Расширенный символ для функции `scanf`|**l**|**c** или **C**|
|Расширенный символ для функции `wscanf`|**l**|**c** или **C**|
|Однобайтовая строка символов с `scanf`|**h**|**s** или **S**|
|Однобайтовая строка символов с `wscanf`|**h**|**s** или **S**|
|Строка расширенных символов с `scanf`|**l**|**s** или **S**|
|Строка расширенных символов с `wscanf`|**l**|**s** или **S**|

В следующих примерах префиксы **h** и **l** используются с функциями `scanf_s` и `wscanf_s`:

```C
scanf_s("%ls", &x, 2);     // Read a wide-character string
wscanf_s(L"%hC", &x, 2);    // Read a single-byte character
```

При использовании небезопасной функции из семейства `scanf` опустите параметр размера, указывающий длину буфера предыдущего аргумента.

## <a name="reading-undelimited-strings"></a>Чтение неразделяющих строк

Для чтения строк, не разделенных пробельными символами, вместо символа типа **s** (строка) можно подставлять набор символов в квадратных скобках ( **[ ]** ). Набор символов в квадратных скобках называется *строкой элемента управления*. Соответствующее поле ввода считывается до первого символа, который не отображается в управляющей строке. Если первый символ в наборе — символ каретки ( **^** ), логика работы меняется на обратную: поле ввода считывается до первого символа, который есть в остальной части набора символов.

И **% [a-z]** , и **% [z-a]** считаются эквивалентными для **% [ABCD... z]** . Это стандартное расширение функции `scanf`, но не является обязательным для стандарта C.

## <a name="reading-unterminated-strings"></a>Чтение незавершенных строк

Чтобы сохранить строку без сохранения завершающего нуль-символа ("\ 0"), используйте спецификацию `%Nc`, где *N* — десятичное целое число. В этом случае символ типа **c** указывает, что аргумент — указатель на массив символов. Следующие *N* символов считываются из входного потока в указанное место, и не добавляется символ null ("\ 0"). Если *N* не указано, значение по умолчанию равно 1.

## <a name="when-scanf-stops-reading-a-field"></a>Когда функция scanf прекращает чтение поля

Функция `scanf` считывает каждое поле ввода, символ за символом. Он может прерывать чтение определенного поля ввода до того, как оно достигнет символа пробела по одной из следующих причин:

- Достигнута указанная ширина.

- Следующий символ не может быть преобразован, как указано.

- Следующий символ конфликтует с символом в управляющей строке, которой он должен соответствовать.

- Следующий символ отсутствует в заданном наборе символов.

По какой бы причине функция `scanf` не прекратила чтение поля ввода, считается, что следующее поле ввода начинается с первого непрочитанного символа. Конфликтующий символ, если таковой имеется, считается непрочтенным. Это первый символ следующего поля ввода или первый символ в последующих операциях чтения входного потока.

## <a name="see-also"></a>См. также раздел

[scanf, _scanf_l, wscanf, _wscanf_l](../c-runtime-library/reference/scanf-scanf-l-wscanf-wscanf-l.md)<br/>
[scanf_s, _scanf_s_l, wscanf_s, _wscanf_s_l](../c-runtime-library/reference/scanf-s-scanf-s-l-wscanf-s-wscanf-s-l.md)<br/>
[Поля спецификации формата: функции scanf и wscanf](../c-runtime-library/format-specification-fields-scanf-and-wscanf-functions.md)<br/>
[Символы поля типа для функции scanf](../c-runtime-library/scanf-type-field-characters.md)<br/>
