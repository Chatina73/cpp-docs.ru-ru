---
title: fopen_s, _wfopen_s
ms.date: 4/2/2020
api_name:
- _wfopen_s
- fopen_s
- _o__wfopen_s
- _o_fopen_s
api_location:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-stdio-l1-1-0.dll
- api-ms-win-crt-private-l1-1-0
api_type:
- DLLExport
topic_type:
- apiref
f1_keywords:
- fopen_s
- _tfopen_s
- _wfopen_s
helpviewer_keywords:
- _wfopen_s function
- opening files, for file I/O
- _tfopen_s function
- tfopen_s function
- wfopen_s function
- fopen_s function
- Unicode [C++], creating files
- Unicode [C++], writing files
- files [C++], opening
- Unicode [C++], files
ms.assetid: c534857e-39ee-4a3f-bd26-dfe551ac96c3
ms.openlocfilehash: 80d04e75637cfab9795bf5dfb9da9786cf4ebd71
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81346494"
---
# <a name="fopen_s-_wfopen_s"></a>fopen_s, _wfopen_s

Открывает файл. Это версии функций [fopen, _wfopen](fopen-wfopen.md) с усовершенствованной безопасностью, как описано в разделе [Усовершенствования безопасности в CRT](../../c-runtime-library/security-features-in-the-crt.md).

## <a name="syntax"></a>Синтаксис

```C
errno_t fopen_s(
   FILE** pFile,
   const char *filename,
   const char *mode
);
errno_t _wfopen_s(
   FILE** pFile,
   const wchar_t *filename,
   const wchar_t *mode
);
```

### <a name="parameters"></a>Параметры

*pFile*<br/>
Указатель на файловый указатель, который получит указатель на открытый файл.

*Имени файла*<br/>
Имя файла.

*Режим*<br/>
Тип разрешенного доступа.

## <a name="return-value"></a>Возвращаемое значение

Возвращает нуль в случае успеха или код ошибки в случае неудачи. Дополнительные сведения об этих кодах ошибки см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

### <a name="error-conditions"></a>Ситуации, которые могут привести к ошибке

|*pFile*|*Имени файла*|*Режим*|Возвращаемое значение|Содержимое *pFile*|
|-------------|----------------|------------|------------------|------------------------|
|**Null**|any|any|**EINVAL**|без изменений|
|any|**Null**|any|**EINVAL**|без изменений|
|any|any|**Null**|**EINVAL**|без изменений|

## <a name="remarks"></a>Remarks

Файлы, которые открываются **fopen_s** и **_wfopen_s** не являются sharable. Если требуется, чтобы файл был sharable, используйте [_fsopen, _wfsopen](fsopen-wfsopen.md) с соответствующим режимом обмена постоянной, например, **_SH_DENYNO** для чтения / обмена.

Функция **fopen_s** открывает файл, указанный *по имени файла.* **_wfopen_s** является широкохарактерным вариантом **fopen_s;** аргументы **в пользу _wfopen_s** являются широкохарактерными строками. **_wfopen_s** и **fopen_s** ведут себя одинаково иначе.

**fopen_s** принимает пути, действительные в файловой системе в момент выполнения; Пути и пути КООН, вовлекающие на карту сетевые диски, принимаются **fopen_s** до тех пор, пока система, исполняющая код, имеет доступ к сетевому диску общего доступа на момент выполнения. При построении путей для **fopen_s**не делайте предположений о доступности дисков, путей или сетевых акций в среде выполнения. В пути в качестве разделителей каталогов можно использовать прямую (/) или обратную (\\) косую черту.

Эти функции проверяют свои параметры. Если *pFile,* *имя файла*или *режим* является нулевой указателем, эти функции генерируют недействительное исключение параметра, как описано в [проверке параметра.](../../c-runtime-library/parameter-validation.md)

Всегда проверяйте возвращаемое значение, чтобы узнать, успешно ли выполнила свою работу функция, прежде чем выполнять какие-либо дальнейшие операции с файлом. Если возникает ошибка, возвращается код ошибки и задается глобальная переменная со значением " **No**". Дополнительные сведения см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

По умолчанию глобальное состояние этой функции приспозировано к приложению. Чтобы изменить это, [см. Глобальное состояние в CRT](../global-state.md).

## <a name="unicode-support"></a>Поддержка Юникода

**fopen_s** поддерживает потоки файлов Unicode. Чтобы открыть новый или существующий файл Unicode, передайте флаг *ccs,* который определяет желаемое кодирование **для fopen_s:**

**fopen_s (&fp, "newfile.txt", "rw, ccs'**_кодирование_**");**

Разрешенные значения *кодирования* являются **UNICODE,** **UTF-8**и **UTF-16LE.** Если для *кодирования*не указано значение, **fopen_s** использует кодирование ANSI.

Если файл уже существует и открыт для чтения или добавления, метка порядка байтов (BOM), если она присутствует в файле, определяет кодировку. Кодирование BOM имеет приоритет над кодированием, указанным флагом *ccs.* Кодирование *ccs* используется только в том случае, если НЕТ BOM или если файл является новым файлом.

> [!NOTE]
> BoM-обнаружение применяется только к файлам, которые открыты в режиме Unicode; то есть, проходя *ccs* флаг.

В следующей таблице кратко излагаются режимы для различных *флагов ccs,* которые даются **fopen_s** и для знаков заказа Байта в файле.

### <a name="encodings-used-based-on-ccs-flag-and-bom"></a>Кодирования, используемые на основе CCS-флага и метки BOM

|ccs флаг|Нет метки BOM (или новый файл)|BOM: UTF-8|BOM: UTF-16|
|----------------|----------------------------|-----------------|------------------|
|**Юникода**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|
|**UTF-8**|**UTF-8**|**UTF-8**|**UTF-16LE**|
|**UTF-16LE**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|

В файлы, открываемые для записи в режиме Юникода, метка BOM записывается автоматически.

Если *режим* **"а, ccs'**_кодирования_**"**, **fopen_s** сначала пытается открыть файл как читать доступ и писать доступ. Если эта операция завершается успешно, функция считывает метку BOM, чтобы определить кодировку для файла; если операция завершается сбоем, функция использует для файла кодировку по умолчанию. В любом **случае, fopen_s** затем вновь открывает файл с записью только доступ. (Это относится к **a** режиме, не **a+**.)

### <a name="generic-text-routine-mappings"></a>Универсальное текстовое сопоставление функций

|Подпрограмма TCHAR.H|_UNICODE и _MBCS не определены|_MBCS определено|_UNICODE определено|
|---------------------|------------------------------------|--------------------|-----------------------|
|**_tfopen_s**|**fopen_s**|**fopen_s**|**_wfopen_s**|

*Режим* строки персонажа определяет вид доступа, который запрашивается для файла, следующим образом.

|*Режим*|Доступ|
|-|-|
| **"r"** | Открывает для чтения. Если файл не существует или не может быть найден, **вызов fopen_s** завершается неудачей. |
| **"w"** | Открывает пустой файл для записи. Если указанный файл существует, его содержимое удаляется. |
| **"а"** | Открывается для записи в конце файла (добавление) без удаления маркера в конце файла (EOF) перед записью новых данных в файл. Создает файл, если он не существует. |
| **"r"** | Открывает для чтения и записи. Файл должен существовать. |
| **"W"** | Открывает пустой файл для чтения и записи. Если файл существует, его содержимое удаляется. |
| **"а"** | Открывается для чтения и добавления. Операция добавления включает удаления маркера EOF перед записью новых данных в файл. Маркер EOF не восстанавливается по окончании записи. Создает файл, если он не существует. |

При открытии файла с помощью типа доступа **"a"** или **"a"** все операции записи происходят в конце файла. Указатель файла можно переместить с помощью [fseek](fseek-fseeki64.md) или [перемотать](rewind.md)назад, но он всегда перемещается обратно в конец файла, прежде чем любая операция записи выполняется так, что существующие данные не могут быть перезаписаны.

Режим **"а"** не удаляет маркер EOF перед приложением к файлу. После добавления команда MS-DOS TYPE отображает данные только до первоначального маркера конца файла, но не данные, добавленные в файл. Режим **«аЗ»** удаляет маркер EOF перед приложением к файлу. После добавления команда TYPE MS-DOS отображает все данные в файле. Режим **«а»** необходим для приложения к файлу потока, который завершается с помощью маркера CTRL.

При указании типа доступа **«r »**, **«w »** или **«a»** допускается чтение и письмо. (Файл, как говорят, открыт для "обновления".) Однако при переходе от чтения к записи операция ввода должна столкнуться с маркером EOF. Если маркер конца файла отсутствует, необходимо воспользоваться промежуточным вызовом функции позиционирования в файле. Функции позиционирования файлов: **fsetpos,** [fseek](fseek-fseeki64.md)и [rewind.](rewind.md) При переходе от записи к чтению необходимо использовать промежуточный вызов либо **для fflush,** либо для функции позиционирования файлов.

В дополнение к вышеуказанным значениям, следующие символы могут быть включены в *режим* для указания режима перевода для новых символов:

|*модификатор режима*|Режим перевода|
|-|-|
| **T** | Откройте файл в текстовом (переведенном) режиме. |
| **B** | Открыт в двоичном (непереведенном) режиме; переводы, включающие символы перевозки-возврата и линейных кормов, подавляются. |

В текстовом (переводном) режиме CTRL-- интерпретируется как символ конца файла при вхотворе. В файлах, открытых для чтения/записи с **помощью "а"**, **fopen_s** проверяет CTRL в конце файла и удаляет его, если это возможно. Это делается потому, что использование [fseek](fseek-fseeki64.md) и **ftell** для перемещения в файле, который заканчивается CTRL, может привести к тому, что [fseek](fseek-fseeki64.md) ведет себя ненадлежащим образом ближе к концу файла.

Кроме того, в текстовом режиме комбинации подач ретрансляционных линий переводятся на одну строку, а символы линейного корма переводятся в комбинации подачи обратных линий на выходе. Если функция ввода-вывода потока Юникода работает в текстовом режиме (по умолчанию) исходный или конечный поток рассматривается как последовательность многобайтовых символов. Поэтому входные функции потока Юникода преобразуют многобайтовые символы в расширенные (как если бы для этого вызывалась функция **mbtowc**). По той же причине выходные функции потока Юникода преобразуют расширенные символы в многобайтовые (как если бы для этого вызывалась функция **wctomb**).

Если **t** или **b** не приведен в *режиме,* режим перевода по умолчанию определяется глобальной переменной [_fmode.](../../c-runtime-library/fmode.md) Если **t** или **b** прикрепляется к аргументу, функция выходит из строя и возвращает **NULL**.

Дополнительные сведения об использовании текстового и двоичного режима в Юникоде и многобайтовом потоковом вводе-выводе см. в разделах [Файловый ввод-вывод в текстовом и двоичном режиме](../../c-runtime-library/text-and-binary-mode-file-i-o.md) и [Ввод-вывод в поток в кодировке Юникод в текстовом и двоичном режиме](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md).

|*модификатор режима*|Поведение|
|-|-|
| **C** | Включите флаг коммита для связанного *имени файла,* чтобы содержимое буфера файла было записано непосредственно на диск, если **вызваны fflush** или **_flushall.** |
| **n** | Сбросить флаг коммитов для связанного *имени файла* на "не-коммит". Это значение по умолчанию. Оно также переопределяет глобальный флаг фиксации при соединении программы с COMMODE.OBJ. Значение по умолчанию глобального флага фиксации — без фиксации (no-commit), если только программа не связана явно с файлом COMMODE.OBJ (см. раздел [Параметры ссылок](../../c-runtime-library/link-options.md)). |
| **N** | Указывает, что файл не наследуется дочерними процессами. |
| **S** | Указывает, что кэширование оптимизировано для последовательного доступа с диска, но не ограничивается им. |
| **R** | Указывает, что кэширование оптимизировано для случайного доступа с диска, но не ограничивается им. |
| **T** | Определяет файл как временный. По возможности он не сбрасывается на диск. |
| **D** | Определяет файл как временный. Он удаляется, если закрывается последний указатель файла. |
| **кодирование ccs'**_encoding_ | Определяем закодированный набор символов для использования (один из **UTF-8,** **UTF-16LE**, или **UNICODE)** для этого файла. Не указывайте никакое значение, если требуется использовать кодировку ANSI. |

Допустимые символы для *строки режима,* используемые в **fopen_s** и [_fdopen,](fdopen-wfdopen.md) соответствуют аргументам *oflag,* используемым в [_open](open-wopen.md) и [_sopen,](sopen-wsopen.md)следующим образом.

|Персонажи в *строке режима*|Эквивалент *стоимости лага* для _open/_sopen|
|-------------------------------|----------------------------------------------------|
|**a**|**_O_WRONLY** **&#124; _O_APPEND** (обычно **_O_WRONLY** &#124; **_O_CREAT** &#124; _O_APPEND)|
|**аа**|**_O_RDWR** **&#124; _O_APPEND** (обычно **_O_RDWR &#124;** **_O_APPEND** &#124; **_O_CREAT)**|
|**R**|**_O_RDONLY**|
|**рЗ**|**_O_RDWR**|
|**Ж**|**_O_WRONLY** (обычно **_O_WRONLY &#124;** **_O_CREAT** _O_TRUNC &#124;)|
|**w**|**_O_RDWR** (обычно **_O_RDWR &#124;** **_O_CREAT** &#124; **_O_TRUNC)**|
|**B**|**_O_BINARY**|
|**T**|**_O_TEXT**|
|**C**|Отсутствуют|
|**n**|Отсутствуют|
|**S**|**_O_SEQUENTIAL**|
|**R**|**_O_RANDOM**|
|**T**|**_O_SHORTLIVED**|
|**D**|**_O_TEMPORARY**|
|**ccs-UNICODE**|**_O_WTEXT**|
|**ccs-UTF-8**|**_O_UTF8**|
|**ccs-UTF-16LE**|**_O_UTF16**|

Если вы используете режим **rb,** не нужно будет портировать свой код, и ожидать, чтобы прочитать много файла и / или не заботятся о производительности сети, памяти отображаются Win32 файлы также может быть вариантом.

## <a name="requirements"></a>Требования

|Компонент|Обязательный заголовок|
|--------------|---------------------|
|**fopen_s**|\<stdio.h>|
|**_wfopen_s**|\<stdio.h> или \<wchar.h>|

Дополнительные сведения о совместимости см. в статье [Compatibility](../../c-runtime-library/compatibility.md).

## <a name="libraries"></a>Библиотеки

Все версии [библиотек времени выполнения языка C](../../c-runtime-library/crt-library-features.md).

**c,** **n,** и **t** *параметры режима* являются расширениями Microsoft для **fopen_s** и [_fdopen](fdopen-wfdopen.md) и не должны использоваться там, где желательно переносимость ANSI.

## <a name="example"></a>Пример

```C
// crt_fopen_s.c
// This program opens two files. It uses
// fclose to close the first file and
// _fcloseall to close all remaining files.

#include <stdio.h>

FILE *stream, *stream2;

int main( void )
{
   errno_t err;

   // Open for read (will fail if file "crt_fopen_s.c" does not exist)
   err  = fopen_s( &stream, "crt_fopen_s.c", "r" );
   if( err == 0 )
   {
      printf( "The file 'crt_fopen_s.c' was opened\n" );
   }
   else
   {
      printf( "The file 'crt_fopen_s.c' was not opened\n" );
   }

   // Open for write
   err = fopen_s( &stream2, "data2", "w+" );
   if( err == 0 )
   {
      printf( "The file 'data2' was opened\n" );
   }
   else
   {
      printf( "The file 'data2' was not opened\n" );
   }

   // Close stream if it is not NULL
   if( stream )
   {
      err = fclose( stream );
      if ( err == 0 )
      {
         printf( "The file 'crt_fopen_s.c' was closed\n" );
      }
      else
      {
         printf( "The file 'crt_fopen_s.c' was not closed\n" );
      }
   }

   // All other files are closed:
   int numclosed = _fcloseall( );
   printf( "Number of files closed by _fcloseall: %u\n", numclosed );
}
```

```Output
The file 'crt_fopen_s.c' was opened
The file 'data2' was opened
Number of files closed by _fcloseall: 1
```

## <a name="see-also"></a>См. также раздел

[Потоковый ввод-вывод](../../c-runtime-library/stream-i-o.md)<br/>
[fclose, _fcloseall](fclose-fcloseall.md)<br/>
[_fdopen, _wfdopen](fdopen-wfdopen.md)<br/>
[ferror](ferror.md)<br/>
[_fileno](fileno.md)<br/>
[freopen, _wfreopen](freopen-wfreopen.md)<br/>
[_open, _wopen](open-wopen.md)<br/>
[_setmode](setmode.md)<br/>
