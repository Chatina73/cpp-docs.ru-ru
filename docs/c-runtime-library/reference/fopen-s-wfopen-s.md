---
title: fopen_s, _wfopen_s
description: Описывает API для `fopen_s` и `_wfopen_s`
ms.date: 11/20/2020
api_name:
- _wfopen_s
- fopen_s
- _o__wfopen_s
- _o_fopen_s
api_location:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-stdio-l1-1-0.dll
- api-ms-win-crt-private-l1-1-0.dll
api_type:
- DLLExport
topic_type:
- apiref
f1_keywords:
- fopen_s
- _tfopen_s
- _wfopen_s
helpviewer_keywords:
- _wfopen_s function
- opening files, for file I/O
- _tfopen_s function
- tfopen_s function
- wfopen_s function
- fopen_s function
- Unicode [C++], creating files
- Unicode [C++], writing files
- files [C++], opening
- Unicode [C++], files
ms.assetid: c534857e-39ee-4a3f-bd26-dfe551ac96c3
ms.openlocfilehash: 1d6d0b739db1177b903c0e8aa8e6f55e49c1df16
ms.sourcegitcommit: b02c61667ff7f38e7add266d0aabd8463f2dbfa1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2020
ms.locfileid: "95483169"
---
# <a name="fopen_s-_wfopen_s"></a>`fopen_s`, `_wfopen_s`

Открывает файл. Эти версии [`fopen, _wfopen`](fopen-wfopen.md) имеют улучшения системы безопасности, как описано в разделе [функции безопасности в CRT](../../c-runtime-library/security-features-in-the-crt.md).

## <a name="syntax"></a>Синтаксис

```C
errno_t fopen_s(
   FILE** pFile,
   const char *filename,
   const char *mode
);
errno_t _wfopen_s(
   FILE** pFile,
   const wchar_t *filename,
   const wchar_t *mode
);
```

### <a name="parameters"></a>Параметры

*`pFile`*\
Указатель на файловый указатель, который получит указатель на открытый файл.

*`filename`*\
Имя файла.

*`mode`*\
Тип разрешенного доступа.

## <a name="return-value"></a>Возвращаемое значение

Возвращает нуль в случае успеха или код ошибки в случае неудачи. Дополнительные сведения об этих кодах ошибок см. в разделе [`errno, _doserrno, _sys_errlist, and _sys_nerr`](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md) .

### <a name="error-conditions"></a>Ситуации, которые могут привести к ошибке

|*`pFile`*|*`filename`*|*`mode`*|Возвращаемое значение|Содержимое *`pFile`*|
|-------------|----------------|------------|------------------|------------------------|
|**`NULL`**|any|any|**`EINVAL`**|без изменений|
|any|**`NULL`**|any|**`EINVAL`**|без изменений|
|any|any|**`NULL`**|**`EINVAL`**|без изменений|

## <a name="remarks"></a>Комментарии

Файлы, открытые **`fopen_s`** и **`_wfopen_s`** не являющиеся совместно используемыми. Если требуется, чтобы файл был доступен для совместного использования, используйте [`_fsopen, _wfsopen`](fsopen-wfsopen.md) параметр с соответствующей константой режима общего доступа, например **`_SH_DENYNO`** для общего доступа на чтение и запись.

**`fopen_s`** Функция открывает файл, указанный параметром *filename*. **`_wfopen_s`** — Это версия с расширенными символами **`fopen_s`** ; аргументы для **`_wfopen_s`** представляют собой строки расширенных символов. **`_wfopen_s`****`fopen_s`** поведение и идентично в противном случае.

**`fopen_s`** принимает пути, допустимые в файловой системе в момент выполнения; Пути UNC и пути, затрагивающие сопоставленные сетевые диски, принимаются при условии, что **`fopen_s`** система, в которой выполняется код, имеет доступ к общему или подключенному сетевому диску во время выполнения. При создании путей для **`fopen_s`** не следует делать предположения о доступности дисков, путей или сетевых общих папок в среде выполнения. В пути в качестве разделителей каталогов можно использовать прямую (/) или обратную (\\) косую черту.

Эти функции проверяют свои параметры. Если *`pFile`* , *`filename`* или *`mode`* является пустым указателем, эти функции создают исключение недопустимого параметра, как описано в разделе [Проверка параметров](../../c-runtime-library/parameter-validation.md).

Всегда проверяйте возвращаемое значение, чтобы узнать, была ли функция успешной, прежде чем выполнять дальнейшие операции с файлом. Если возникает ошибка, возвращается код ошибки и **`errno`** задается глобальная переменная. Дополнительные сведения см. в разделе [`errno, _doserrno, _sys_errlist, and _sys_nerr`](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

По умолчанию глобальное состояние этой функции ограничивается приложением. Чтобы изменить это, см. раздел [глобальное состояние в CRT](../global-state.md).

## <a name="unicode-support"></a>Поддержка Юникода

**`fopen_s`** поддерживает файловые потоки в Юникоде. Чтобы открыть новый или существующий файл в Юникоде, передайте флаг *CCS* , указывающий требуемую кодировку **`fopen_s`** :

**`fopen_s(&fp, "newfile.txt", "rw, ccs=**_encoding_**");`**

Допустимые значения *кодировки* : **`UNICODE`** , **`UTF-8`** и **`UTF-16LE`** . Если для параметра не указано значение *`encoding`* , **`fopen_s`** используется кодировка ANSI.

Если файл уже существует и открыт для чтения или добавления, метка порядка байтов (BOM), если она присутствует в файле, определяет кодировку. Кодировка спецификации имеет приоритет над кодировкой, заданной *`ccs`* флагом. *`ccs`* Кодировка используется только в том случае, если отсутствует спецификация или если файл является новым файлом.

> [!NOTE]
> Определение спецификации применяется только к файлам, открываемым в режиме Юникода. то есть путем передачи *`ccs`* флага.

В следующей таблице перечислены режимы для различных *`ccs`* флагов, предоставляемых **`fopen_s`** и для меток порядка байтов в файле.

### <a name="encodings-used-based-on-ccs-flag-and-bom"></a>Кодирования, используемые на основе CCS-флага и метки BOM

|Флаг CCS|Нет метки BOM (или новый файл)|BOM: UTF-8|BOM: UTF-16|
|----------------|----------------------------|-----------------|------------------|
|**`UNICODE`**|**`UTF-16LE`**|**`UTF-8`**|**`UTF-16LE`**|
|**`UTF-8`**|**`UTF-8`**|**`UTF-8`**|**`UTF-16LE`**|
|**`UTF-16LE`**|**`UTF-16LE`**|**`UTF-8`**|**`UTF-16LE`**|

В файлы, открываемые для записи в режиме Юникода, метка BOM записывается автоматически.

При *`mode`* использовании **`"a, ccs=` _кодировки_ `"`** **`fopen_s`** сначала пытается открыть файл с доступом на чтение и на запись. Если эта операция завершается успешно, функция считывает метку BOM, чтобы определить кодировку для файла; если операция завершается сбоем, функция использует для файла кодировку по умолчанию. В любом случае **`fopen_s`** снова открывает файл с доступом только на запись. (Это относится **`a`** только к режиму, а не к **`a+`** ).

### <a name="generic-text-routine-mappings"></a>Универсальное текстовое сопоставление функций

|Подпрограмма TCHAR.H|_UNICODE и _MBCS не определены|_MBCS определено|_UNICODE определено|
|---------------------|------------------------------------|--------------------|-----------------------|
|**`_tfopen_s`**|**`fopen_s`**|**`fopen_s`**|**`_wfopen_s`**|

Строка символов *`mode`* указывает тип доступа, запрашиваемый для файла, как показано ниже.

|*`mode`*|Доступ|
|-|-|
| **`"r"`** | Открывает для чтения. Если файл не существует или не найден, **`fopen_s`** вызов завершается ошибкой. |
| **`"w"`** | Открывает пустой файл для записи. Если указанный файл существует, его содержимое удаляется. |
| **`"a"`** | Открывается для записи в конце файла (добавление) без удаления маркера в конце файла (EOF) перед записью новых данных в файл. Создает файл, если он не существует. |
| **`"r+"`** | Открывает для чтения и записи. Файл должен существовать. |
| **"w +"** | Открывает пустой файл для чтения и записи. Если файл существует, его содержимое удаляется. |
| **`"a+"`** | Открывается для чтения и добавления. Операция добавления включает удаления маркера EOF перед записью новых данных в файл. Маркер EOF не восстанавливается после завершения записи. Создает файл, если он не существует. |

Когда файл открывается с использованием **`"a"`** **`"a+"`** типа доступа или, все операции записи выполняются в конце файла. Указатель файла может быть перемещен с помощью [`fseek`](fseek-fseeki64.md) или [`rewind`](rewind.md) , но всегда перемещается обратно в конец файла перед выполнением любой операции записи, чтобы существующие данные не могли быть перезаписаны.

**`"a"`** Перед добавлением в файл режим не удаляет маркер конца файла. После добавления `TYPE` данных команда MS-DOS отображает только исходный маркер EOF, а не все данные, добавленные в файл. **`"a+"`** Перед добавлением в файл режим удаляет маркер EOF. После добавления `TYPE` команда MS-DOS отображает все данные в файле. **`"a+"`** Режим необходим для добавления в потоковый файл, заканчивающийся `CTRL+Z` маркером EOF.

Если **`"r+"`** **`"w+"`** **`"a+"`** указан тип доступа, или, то чтение и запись разрешены. (Считается, что файл открыт для обновления.) Однако при переключении с чтения на запись входная операция должна идти по маркеру EOF. Если маркер EOF отсутствует, необходимо использовать промежуточный вызов функции позиционирования файла. Функции позиционирования файлов: **`fsetpos`** , [`fseek`](fseek-fseeki64.md) и [`rewind`](rewind.md) . При переключении с записи на чтение необходимо использовать промежуточный вызов **`fflush`** функции либо в функцию позиционирования файла.

В дополнение к приведенным выше значениям в можно включить следующие символы *`mode`* для указания режима преобразования символов новой строки:

|*`mode`* Модификатор|Режим преобразования|
|-|-|
| **`t`** | Откройте файл в текстовом (переведенном) режиме. |
| **`b`** | Открыть в двоичном (непреобразованном) режиме; переводы, включающие символы возврата каретки и перевода строки, подавляются. |

В текстовом режиме (преобразованном) `CTRL+Z` интерпретируется как символ конца файла во входных данных. В файлах, открытых для чтения и записи с **`"a+"`** , проверяет наличие в **`fopen_s`** `CTRL+Z` конце файла и удаляет его, если это возможно. Это делается потому, что использование [`fseek`](fseek-fseeki64.md) и **`ftell`** для перемещения в файле, который заканчивается на `CTRL+Z` , может привести [`fseek`](fseek-fseeki64.md) к неправильному ведению в конце файла.

Кроме того, в текстовом режиме сочетания возврата каретки и перевода строки преобразуются в однострочные каналы ввода, а символы перевода строки преобразуются в сочетания символов возврата каретки и перевода строки на выходе. Если функция ввода-вывода потока Юникода работает в текстовом режиме (по умолчанию) исходный или конечный поток рассматривается как последовательность многобайтовых символов. Входные функции потока Юникода преобразуют многобайтовые символы в широкие символы (как при вызове **`mbtowc`** функции). По той же причине функции потокового вывода в Юникоде преобразуют расширенные символы в многобайтовые символы (как при вызове **`wctomb`** функции).

Если параметр **`t`** или **`b`** не указан в *`mode`* , режим преобразования по умолчанию определяется глобальной переменной [_fmode](../../c-runtime-library/fmode.md). Если **`t`** **`b`** аргумент или имеет префикс, функция завершается ошибкой и возвращает значение **`NULL`** .

Дополнительные сведения об использовании текстового и двоичного режима в Юникоде и многобайтовом потоковом вводе-выводе см. в разделах [Файловый ввод-вывод в текстовом и двоичном режиме](../../c-runtime-library/text-and-binary-mode-file-i-o.md) и [Ввод-вывод в поток в кодировке Юникод в текстовом и двоичном режиме](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md).

|*`mode`* Модификатор|Поведение|
|-|-|
| **`c`** | Включите флаг фиксации для связанного *имени файла* , чтобы содержимое файлового буфера записывалось непосредственно на диск при **`fflush`** **`_flushall`** вызове или. |
| **`n`** | Сбросьте флаг фиксации для связанного *файла* с состоянием "без фиксации". Это значение по умолчанию. Оно также переопределяет глобальный флаг фиксации при соединении программы с COMMODE.OBJ. Значение по умолчанию глобального флага фиксации — без фиксации (no-commit), если только программа не связана явно с файлом COMMODE.OBJ (см. раздел [Параметры ссылок](../../c-runtime-library/link-options.md)). |
| **`n`** | Указывает, что файл не наследуется дочерними процессами. |
| **`S`** | Указывает, что кэширование оптимизировано для последовательного доступа с диска, но не ограничивается им. |
| **`R`** | Указывает, что кэширование оптимизировано для случайного доступа с диска, но не ограничивается им. |
| **`t`** | Определяет файл как временный. Если возможно, он не будет сброшен на диск. |
| **`D`** | Определяет файл как временный. Он удаляется при закрытии указателя последнего файла. |
| **`ccs=**`_шифрования_ | Задает кодировку, используемую для использования (один из **`UTF-8`** , **`UTF-16LE`** или **`UNICODE`** ) для этого файла. Не указывайте никакое значение, если требуется использовать кодировку ANSI. |

Допустимые символы для *`mode`* строки, используемой в параметре **`fopen_s`** и [`_fdopen`](fdopen-wfdopen.md) *`oflag`* , соответствуют аргументам, используемым в [`_open`](open-wopen.md) и [`_sopen`](sopen-wsopen.md) , как показано ниже.

|Символы в *`mode`* строке|Эквивалентное *`oflag`* значение для `_open`/`_sopen`|
|-------------------------------|----------------------------------------------------|
|**`a`**|**`_O_WRONLY`** &#124; **`_O_APPEND`** (обычно **`_O_WRONLY`** &#124; **`_O_CREAT`** &#124; **`_O_APPEND`** )|
|**`a+`**|**`_O_RDWR`** &#124; **`_O_APPEND`** (обычно **`_O_RDWR`** &#124; **`_O_APPEND`** &#124; **`_O_CREAT`** )|
|**`R`**|**`_O_RDONLY`**|
|**`r+`**|**`_O_RDWR`**|
|**`w`**|**`_O_WRONLY`** (обычно **`_O_WRONLY`** &#124; **`_O_CREAT`** &#124; **_O_TRUNC**)|
|**`w+`**|**`_O_RDWR`** (обычно **`_O_RDWR`** &#124; **`_O_CREAT`** &#124; **_O_TRUNC**)|
|**`b`**|**`_O_BINARY`**|
|**`t`**|**`_O_TEXT`**|
|**`c`**|None|
|**`n`**|None|
|**`S`**|**`_O_SEQUENTIAL`**|
|**`R`**|**`_O_RANDOM`**|
|**`t`**|**`_O_SHORTLIVED`**|
|**`D`**|**`_O_TEMPORARY`**|
|**`ccs=UNICODE`**|**`_O_WTEXT`**|
|**`ccs=UTF-8`**|**`_O_UTF8`**|
|**`ccs=UTF-16LE`**|**`_O_UTF16`**|

Если вы используете **`rb`** режим, файлы Win32, сопоставленные с памятью, также могут быть вариантами, если вам не нужно переносить код, вы будете читать большую часть файла или не волнует производительность сети.

## <a name="requirements"></a>Требования

|Функция|Обязательный заголовок|
|--------------|---------------------|
|**`fopen_s`**|`<stdio.h>`|
|**`_wfopen_s`**|`<stdio.h>` или `<wchar.h>`|

Дополнительные сведения о совместимости см. в статье [Compatibility](../../c-runtime-library/compatibility.md).

## <a name="libraries"></a>Библиотеки

Все версии [библиотек времени выполнения языка C](../../c-runtime-library/crt-library-features.md).

**`c`** Параметры, **`n`** и **`t`** *`mode`* являются расширениями Майкрософт для **`fopen_s`** и [`_fdopen`](fdopen-wfdopen.md) и не должны использоваться там, где требуется переносимость ANSI.

## <a name="example"></a>Пример

```C
// crt_fopen_s.c
// This program opens two files. It uses
// fclose to close the first file and
// _fcloseall to close all remaining files.

#include <stdio.h>

FILE *stream, *stream2;

int main( void )
{
   errno_t err;

   // Open for read (will fail if file "crt_fopen_s.c" doesn't exist)
   err  = fopen_s( &stream, "crt_fopen_s.c", "r" );
   if( err == 0 )
   {
      printf( "The file 'crt_fopen_s.c' was opened\n" );
   }
   else
   {
      printf( "The file 'crt_fopen_s.c' was not opened\n" );
   }

   // Open for write
   err = fopen_s( &stream2, "data2", "w+" );
   if( err == 0 )
   {
      printf( "The file 'data2' was opened\n" );
   }
   else
   {
      printf( "The file 'data2' was not opened\n" );
   }

   // Close stream if it isn't NULL
   if( stream )
   {
      err = fclose( stream );
      if ( err == 0 )
      {
         printf( "The file 'crt_fopen_s.c' was closed\n" );
      }
      else
      {
         printf( "The file 'crt_fopen_s.c' was not closed\n" );
      }
   }

   // All other files are closed:
   int numclosed = _fcloseall( );
   printf( "Number of files closed by _fcloseall: %u\n", numclosed );
}
```

```Output
The file 'crt_fopen_s.c' was opened
The file 'data2' was opened
Number of files closed by _fcloseall: 1
```

## <a name="see-also"></a>См. также

[Потоковый ввод-вывод](../../c-runtime-library/stream-i-o.md)\
[`fclose, _fcloseall`](fclose-fcloseall.md)\
[`_fdopen, _wfdopen`](fdopen-wfdopen.md)\
[`ferror`](ferror.md)\
[`_fileno`](fileno.md)\
[`freopen, _wfreopen`](freopen-wfreopen.md)\
[`_open, _wopen`](open-wopen.md)\
[`_setmode`](setmode.md)
