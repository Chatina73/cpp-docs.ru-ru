---
title: fopen, _wfopen
ms.date: 11/04/2016
api_name:
- _wfopen
- fopen
api_location:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-stdio-l1-1-0.dll
api_type:
- DLLExport
topic_type:
- apiref
f1_keywords:
- fopen
- _wfopen
- _tfopen
- corecrt_wstdio/_wfopen
- stdio/fopen
helpviewer_keywords:
- opening files, for file I/O
- wfopen function
- tfopen function
- _tfopen function
- _wfopen function
- files [C++], opening
- fopen function
ms.assetid: e868993f-738c-4920-b5e4-d8f2f41f933d
ms.openlocfilehash: 0e50854cf35dd58f7f59f67ed861247b51fd4541
ms.sourcegitcommit: f19474151276d47da77cdfd20df53128fdcc3ea7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/12/2019
ms.locfileid: "70957054"
---
# <a name="fopen-_wfopen"></a>fopen, _wfopen

Открывает файл. Доступны более надежные и безопасные версии этих функций, выполняющие дополнительные проверки параметров и возвращающие коды ошибок. См. [fopen_s, _wfopen_s](fopen-s-wfopen-s.md).

## <a name="syntax"></a>Синтаксис

```C
FILE *fopen(
   const char *filename,
   const char *mode
);
FILE *_wfopen(
   const wchar_t *filename,
   const wchar_t *mode
);
```

### <a name="parameters"></a>Параметры

*filename*<br/>
Имя файла.

*mode*<br/>
Включенный тип доступа.

## <a name="return-value"></a>Возвращаемое значение

Каждая из этих функций возвращает указатель на открытый файл. Значение указателя null обозначает ошибку. Если параметр *filename* или *mode* имеет **значение NULL** или является пустой строкой, эти функции активируют обработчик недопустимых параметров, который описан в разделе [Проверка параметров](../../c-runtime-library/parameter-validation.md). Если выполнение может быть продолжено, эти функции возвращают **значение NULL** и **задают значение** **еинвал**.

Дополнительные сведения см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

## <a name="remarks"></a>Примечания

Функция **fopen** открывает файл, указанный параметром *filename*. По умолчанию строка с узким *именем* интерпретируется с помощью кодовой страницы ANSI (CP_ACP). В классических приложениях Windows эту страницу можно изменить на кодовую страницу OEM (CP_OEMCP) с помощью функции [SetFileApisToOEM](/windows/win32/api/fileapi/nf-fileapi-setfileapistooem) . С помощью функции [AreFileApisANSI](/windows/win32/api/fileapi/nf-fileapi-arefileapisansi) можно определить, интерпретируется ли *имя файла* с использованием ANSI или системной кодовой страницы OEM по умолчанию. **_wfopen** — это версия **fopen**для расширенных символов; аргументы для **_wfopen** являются строками расширенных символов. В противном случае поведение **_wfopen** и **fopen** работает одинаково. Простое использование **_wfopen** не влияет на закодированную кодировку, используемую в файловом потоке.

**fopen** принимает пути, допустимые в файловой системе в момент выполнения. **fopen** принимает UNC-пути и пути, которые используют сопоставленные сетевые диски, если система, в которой выполняется код, имеет доступ к общей папке или подключенному диску во время выполнения. При создании путей для **fopen**убедитесь, что диски, пути или сетевые папки будут доступны в среде выполнения. В пути в качестве разделителей каталогов можно использовать прямую (/) или обратную (\\) косую черту.

Всегда проверяйте возвращаемое значение, чтобы узнать, равен ли указатель NULL, прежде чем выполнять какие-либо дальнейшие операции с файлом. При возникновении ошибки устанавливается глобальная переменная со значением « **No** », которую можно использовать для получения конкретных сведений об ошибке. Дополнительные сведения см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

## <a name="unicode-support"></a>Поддержка Юникода

**fopen** поддерживает файловые потоки в Юникоде. Чтобы открыть файл Юникода, передайте флаг **CCS** , указывающий требуемую кодировку для **fopen**, как показано ниже.

> **File\*FP = fopen ("NewFile. txt", "RT +, CCS =** _Encoding_ **");**

Допустимые значения *кодировки* : **Unicode**, **UTF-8**и **UTF-16LE**.

Когда файл открывается в режиме Юникода, входные функции преобразуют данные, считываемые из файла, в данные UTF-16, хранящиеся как тип **wchar_t**. Функции, записывающие в файл, Открытый в режиме Юникода, предполагают буферы, содержащие данные UTF-16, хранящиеся как тип **wchar_t**. Если кодировка файла — UTF-8, при его записи данные UTF-16 преобразуются в UTF-8, а содержимое файла с кодировкой UTF-8 преобразуется в данные UTF-16 при его считывании. Попытка чтения или записи нечетного числа байт в режиме Юникода приводит к возникновению ошибки [проверки параметра](../../c-runtime-library/parameter-validation.md) . Для чтения или записи данных, хранимых в программе в кодировке UTF-8, используйте режим текстового или двоичного файла вместо режима Юникода. Вам необходимо реализовать все обязательные преобразования кодировки.

Если файл уже существует и открыт для чтения или добавления, метка порядка байтов (BOM), если она присутствует в файле, определяет кодирование. Кодировка спецификации имеет приоритет над кодировкой, заданной флагом **CCS** . Кодировка **CCS** используется только в том случае, если отсутствует спецификация или файл является новым файлом.

> [!NOTE]
> Обнаружение спецификации применяется только к файлам, открываемым в режиме Юникода (то есть путем передачи флага **CCS** ).

В следующей таблице перечислены режимы, используемые для различных флагов **CCS** , заданных в **fopen** и метках порядка байтов в файле.

### <a name="encodings-used-based-on-ccs-flag-and-bom"></a>Кодирования, используемые на основе CCS-флага и метки BOM

|Флаг CCS|Нет метки BOM (или новый файл)|BOM UTF-8|BOM UTF-16|
|----------------|----------------------------|-----------------|------------------|
|**ЮНИКОД**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|
|**UTF-8**|**UTF-8**|**UTF-8**|**UTF-16LE**|
|**UTF-16LE**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|

В файлы, открытые для записи в режиме Юникода, метка BOM записывается автоматически.

Если *mode* имеет **значение "a, CCS =** _Encoding_ **"** , **fopen** сначала пытается открыть файл, используя доступ на чтение и запись. Если это завершается успешно, функция считывает метку BOM, чтобы определить кодировку для файла; если операция завершается сбоем, функция использует для файла кодировку по умолчанию. В любом случае **fopen** будет повторно открывать файл с помощью доступа только для записи. (Это относится только к режиму " **a"** , а не к режиму **"a +"** .)

### <a name="generic-text-routine-mappings"></a>Сопоставления подпрограмм обработки обычного текста

|Подпрограмма TCHAR.H|_UNICODE и _MBCS не определены|_MBCS определено|_UNICODE определено|
|---------------------|------------------------------------|--------------------|-----------------------|
|**_tfopen**|**fopen**|**fopen**|**_wfopen**|

*Режим* символьной строки определяет тип доступа, запрашиваемый для файла, как показано ниже.

|*mode*|Access|
|-|-|
| **"r"** | Открывает для чтения. Если файл не существует или не найден, вызов **fopen** завершается ошибкой. |
| **"w"** | Открывает пустой файл для записи. Если указанный файл существует, его содержимое удаляется. |
| **"a"** | Открывается для записи в конце файла (добавление) без удаления маркера в конце файла (EOF) перед записью новых данных в файл. Создает файл, если он не существует. |
| **"r+"** | Открывает для чтения и записи. Файл должен существовать. |
| **"w+"** | Открывает пустой файл для чтения и записи. Если файл существует, его содержимое удаляется. |
| **"a+"** | Открывается для чтения и добавления. Операция добавления включает удаления маркера EOF перед записью новых данных в файл. Маркер EOF не восстанавливается по окончании записи. Создает файл, если он не существует. |

При открытии файла с помощью типа доступа **"a"** или типа доступа **"a +"** все операции записи выполняются в конце файла. Указатель файла может быть перемещен с помощью [fseek](fseek-fseeki64.md) или [rewind](rewind.md), но всегда перемещается обратно в конец файла перед выполнением любой операции записи. Поэтому невозможно перезаписать существующие данные.

Режим **"a"** не УДАЛЯЕТ маркер EOF перед добавлением к файлу. После добавления команда MS-DOS TYPE отображает данные только до первоначального маркера EOF и не отображает данные, добавленные в файл. Перед добавлением в файл в режиме **"a +"** удаляется маркер EOF. После добавления команда TYPE MS-DOS отображает все данные в файле. Для добавления в потоковый файл, заканчивающийся маркером EOF CTRL + Z, требуется режим **"a +"** .

При указании типа доступа **"r +"** , **"w +"** или **"a +"** разрешены операции чтения и записи (считается, что файл открыт для обновления). Однако при переходе от чтения к записи операция ввода должна получить маркер конца файла. Если маркер EOF отсутствует, необходимо воспользоваться промежуточным вызовом функции размещения файла. Функции позиционирования файлов: **fsetpos**, [fseek](fseek-fseeki64.md)и [rewind](rewind.md). При переключении с записи на чтение необходимо использовать промежуточный вызов либо **fflush** , либо в функцию позиционирования файла.

В дополнение к предыдущим значениям к режиму можно добавить следующие символы, чтобы указать режим преобразования для символов новой строки.

|Модификатор *режима*|Режим преобразования|
|-|-|
| **t** | Откройте файл в текстовом (переведенном) режиме. |
| **b** | Открыть в двоичном (непреобразованном) режиме; переводы, включающие символы возврата каретки и перевода строки, подавляются. |

В текстовом режиме CTRL + Z интерпретируется как символ EOF на входе. В файлах, открытых для чтения и записи с помощью **"a +"** , **FOPEN** проверяет наличие CTRL + Z в конце файла и удаляет его, если это возможно. Это делается потому, что использование [fseek](fseek-fseeki64.md) и **ftell** для перемещения в файле, заканчивающемся клавишей CTRL + Z, может привести к неправильному поведению [fseek](fseek-fseeki64.md) в конце файла.

В текстовом режиме сочетания возврата каретки и перевода строки преобразуются в однострочные каналы ввода, а символы перевода строки преобразуются в сочетания символов возврата каретки и перевода строки на выходе. Если функция ввода-вывода потока Юникода работает в текстовом режиме (по умолчанию) исходный или конечный поток рассматривается как последовательность многобайтовых символов. Поэтому входные функции потока Юникода преобразуют многобайтовые символы в расширенные (как если бы для этого вызывалась функция **mbtowc**). По той же причине выходные функции потока Юникода преобразуют расширенные символы в многобайтовые (как если бы для этого вызывалась функция **wctomb**).

Если **t** или **b** не задан в *режиме*, то режим преобразования по умолчанию определяется глобальной переменной [_fmode](../../c-runtime-library/fmode.md). Если **t** или **b** является префиксом аргумента, функция завершается ошибкой и возвращает **значение NULL**.

Дополнительные сведения об использовании текстового и двоичного режимов в Юникоде, а также многобайтового потока ввода-вывода см. в статьях [Text and Binary Mode File I/O](../../c-runtime-library/text-and-binary-mode-file-i-o.md) и [Ввод-вывод в поток в кодировке Юникод в текстовом и двоичном режиме](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md).

Следующие параметры могут быть добавлены в *режим* для указания дополнительных поведений.

|Модификатор *режима*|Поведение|
|-|-|
| **c** | Включите флаг фиксации для связанного *имени файла* , чтобы содержимое файлового буфера записывалось непосредственно на диск при вызове **fflush** или **_flushall** . |
| **n** | Сбросьте флаг фиксации для связанного *файла* с состоянием "без фиксации". Это значение по умолчанию. Оно также переопределяет глобальный флаг фиксации при соединении программы с COMMODE.OBJ. Значение по умолчанию глобального флага фиксации — "без фиксации" (no-commit), если только программа не связана явно с файлом COMMODE.OBJ (см. статью [Link Options](../../c-runtime-library/link-options.md)). |
| **N** | Указывает, что файл не наследуется дочерними процессами. |
| **S** | Указывает, что кэширование оптимизировано для последовательного доступа с диска, но не ограничивается им. |
| **R** | Указывает, что кэширование оптимизировано для случайного доступа с диска, но не ограничивается им. |
| **T** | Определяет файл как временный. По возможности он не сбрасывается на диск. |
| **D** | Определяет файл как временный. Он удаляется, если закрывается последний указатель файла. |
| **CCS =** _кодирование_ | Задает кодировку, используемую для этого файла (один из **UTF-8**, **UTF-16LE**или **Unicode**). Не указывайте никакое значение, если требуется использовать кодировку ANSI. |

Допустимые символы для строки *режима* , используемой в **fopen** и **_fdopen** , соответствуют аргументам *офлаг* , которые используются в [_open](open-wopen.md) и [_sopen](sopen-wsopen.md), как показано ниже.

|Символы в строке *режима*|Эквивалентное значение *офлаг* для \_Open\_/Сопен|
|-------------------------------|----------------------------------------------------|
|**a**|**\_O\_вронли** &#124; **o ( обычно\_o вронли),\_** создание  **\_\_** &#124;  **\_\_** &#124;  **\_ O\_Append**)|
|**a +**|**\_O\_РДВР** &#124; &#124; **o(\_обычно o РДВР o Append) \_** &#124;  **\_\_**  **\_\_**  **\_ O\_** создание)|
|**r**|**\_O\_RDONLY**|
|**r +**|**\_O\_РДВР**|
|**w**|**\_O\_вронли** (обычно  **\_oвронли\_** &#124; o &#124; **TRUNC\_) \_**  **\_\_**|
|**w +**|**\_O\_РДВР** (обычно  **\_oРДВР\_** &#124; o &#124; **TRUNC\_) \_**  **\_\_**|
|**b**|**\_O\_BINARY**|
|**t**|**\_O\_TEXT**|
|**c**|Отсутствуют|
|**n**|Отсутствуют|
|**S**|**\_O\_ПОСЛЕДОВАТЕЛЬНЫЙ**|
|**R**|**\_O\_СЛУЧАЙНЫЙ**|
|**T**|**\_O\_ШОРТЛИВЕД**|
|**D**|**\_O\_ВРЕМЕННЫЕ**|
|**CCS = Юникод**|**\_O\_WTEXT**|
|**CCS = UTF-8**|**\_O\_UTF8**|
|**CCS = UTF-16LE**|**\_O\_UTF16**|

Если используется режим **RB** , вам не нужно переносить код, и если предполагается читать большую часть большого файла или не беспокоиться о производительности сети, можно также подумать, следует ли использовать файлы Win32, сопоставленные с памятью, в качестве параметра.

## <a name="requirements"></a>Требования

|Функция|Обязательный заголовок|
|--------------|---------------------|
|**fopen**|\<stdio.h>|
|**_wfopen**|\<stdio.h> или \<wchar.h>|

**_wfopen** — это расширение Майкрософт. Дополнительные сведения о совместимости см. в разделе [Совместимость](../../c-runtime-library/compatibility.md).

Параметры **c**, **n**, **t**, **S**, **R**, **t**и **D** являются расширениями Майкрософт для **fopen** и **_fdopen** и не должны использоваться там, где требуется переносимость ANSI.

## <a name="example-1"></a>Пример 1

Следующая программа открывает два файла.  Он использует **фклосе** , чтобы закрыть первый файл, и **_fcloseall** , чтобы закрыть все оставшиеся файлы.

```C
// crt_fopen.c
// compile with: /W3
// This program opens two files. It uses
// fclose to close the first file and
// _fcloseall to close all remaining files.

#include <stdio.h>

FILE *stream, *stream2;

int main( void )
{
   int numclosed;

   // Open for read (will fail if file "crt_fopen.c" does not exist)
   if( (stream  = fopen( "crt_fopen.c", "r" )) == NULL ) // C4996
   // Note: fopen is deprecated; consider using fopen_s instead
      printf( "The file 'crt_fopen.c' was not opened\n" );
   else
      printf( "The file 'crt_fopen.c' was opened\n" );

   // Open for write
   if( (stream2 = fopen( "data2", "w+" )) == NULL ) // C4996
      printf( "The file 'data2' was not opened\n" );
   else
      printf( "The file 'data2' was opened\n" );

   // Close stream if it is not NULL
   if( stream)
   {
      if ( fclose( stream ) )
      {
         printf( "The file 'crt_fopen.c' was not closed\n" );
      }
   }

   // All other files are closed:
   numclosed = _fcloseall( );
   printf( "Number of files closed by _fcloseall: %u\n", numclosed );
}
```

```Output
The file 'crt_fopen.c' was opened
The file 'data2' was opened
Number of files closed by _fcloseall: 1
```

## <a name="example-2"></a>Пример 2

Следующая программа создает файл (или перезаписывает его, если имеется) в текстовом режиме с кодировкой Юникода.  Затем она записывает две строки в файл и закрывает его. В результате получается файл с именем _wfopen_test.xml, который содержит данные из раздела вывода.

```C
// crt__wfopen.c
// compile with: /W3
// This program creates a file (or overwrites one if
// it exists), in text mode using Unicode encoding.
// It then writes two strings into the file
// and then closes the file.

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <wchar.h>

#define BUFFER_SIZE 50

int main(int argc, char** argv)
{
    wchar_t str[BUFFER_SIZE];
    size_t  strSize;
    FILE*   fileHandle;

    // Create an the xml file in text and Unicode encoding mode.
    if ((fileHandle = _wfopen( L"_wfopen_test.xml",L"wt+,ccs=UNICODE")) == NULL) // C4996
    // Note: _wfopen is deprecated; consider using _wfopen_s instead
    {
        wprintf(L"_wfopen failed!\n");
        return(0);
    }

    // Write a string into the file.
    wcscpy_s(str, sizeof(str)/sizeof(wchar_t), L"<xmlTag>\n");
    strSize = wcslen(str);
    if (fwrite(str, sizeof(wchar_t), strSize, fileHandle) != strSize)
    {
        wprintf(L"fwrite failed!\n");
    }

    // Write a string into the file.
    wcscpy_s(str, sizeof(str)/sizeof(wchar_t), L"</xmlTag>");
    strSize = wcslen(str);
    if (fwrite(str, sizeof(wchar_t), strSize, fileHandle) != strSize)
    {
        wprintf(L"fwrite failed!\n");
    }

    // Close the file.
    if (fclose(fileHandle))
    {
        wprintf(L"fclose failed!\n");
    }
    return 0;
}
```

## <a name="see-also"></a>См. также

[Потоковый ввод-вывод](../../c-runtime-library/stream-i-o.md)<br/>
[Интерпретация последовательностей многобайтовых символов](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)<br/>
[fclose, _fcloseall](fclose-fcloseall.md)<br/>
[_fdopen, _wfdopen](fdopen-wfdopen.md)<br/>
[ferror](ferror.md)<br/>
[_fileno](fileno.md)<br/>
[freopen, _wfreopen](freopen-wfreopen.md)<br/>
[_open, _wopen](open-wopen.md)<br/>
[_setmode](setmode.md)<br/>
[_sopen, _wsopen](sopen-wsopen.md)<br/>
