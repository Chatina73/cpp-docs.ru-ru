---
title: fopen, _wfopen
ms.date: 11/04/2016
apiname:
- _wfopen
- fopen
apilocation:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-stdio-l1-1-0.dll
apitype: DLLExport
f1_keywords:
- fopen
- _wfopen
- _tfopen
- corecrt_wstdio/_wfopen
- stdio/fopen
helpviewer_keywords:
- opening files, for file I/O
- wfopen function
- tfopen function
- _tfopen function
- _wfopen function
- files [C++], opening
- fopen function
ms.assetid: e868993f-738c-4920-b5e4-d8f2f41f933d
ms.openlocfilehash: a8b204c2bf48802b8efcfe5ca487d62876942c29
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50540340"
---
# <a name="fopen-wfopen"></a>fopen, _wfopen

Открывает файл. Доступны более надежные и безопасные версии этих функций, выполняющие дополнительные проверки параметров и возвращающие коды ошибок. См. [fopen_s, _wfopen_s](fopen-s-wfopen-s.md).

## <a name="syntax"></a>Синтаксис

```C
FILE *fopen(
   const char *filename,
   const char *mode
);
FILE *_wfopen(
   const wchar_t *filename,
   const wchar_t *mode
);
```

### <a name="parameters"></a>Параметры

*filename*<br/>
Имя файла.

*mode*<br/>
Включенный тип доступа.

## <a name="return-value"></a>Возвращаемое значение

Каждая из этих функций возвращает указатель на открытый файл. Значение указателя null обозначает ошибку. Если *filename* или *режим* — **NULL** или является пустой строкой, эти функции активируют обработчик недопустимого параметра, который описан в [параметр Проверка](../../c-runtime-library/parameter-validation.md). Если выполнение может быть продолжено, эти функции возвращают **NULL** и задайте **errno** для **EINVAL**.

Дополнительные сведения см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

## <a name="remarks"></a>Примечания

**Fopen** функция открывает файл, который задается параметром *filename*. По умолчанию узкая *filename* строка интерпретируется с использованием кодовой страницы ANSI (CP_ACP). В классических приложениях Windows эту страницу можно изменить на кодовую страницу OEM (CP_OEMCP) с помощью функции [SetFileApisToOEM](/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem) . Можно использовать [AreFileApisANSI](/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi) функцию, чтобы определить ли *filename* интерпретируется с использованием кодовой страницы ANSI или кодовой страницы OEM системы по умолчанию. **_wfopen** — это двухбайтовая версия **fopen**; аргументы для **_wfopen** представляют собой строки расширенных символов. В противном случае **_wfopen** и **fopen** ведут себя одинаково. Использование исключительно **_wfopen** не влияет на набор закодированных символов, используемый в файловом потоке.

**fopen** принимает пути, допустимые в файловой системе точке выполнения; **fopen** принимает UNC-пути и пути, содержащие сопоставленные сетевые диски, если выполняющая код система имеет доступ к общей папке или сопоставленному диску во время выполнения. При построении путей для **fopen**, убедитесь, что диски, пути или сетевые общие папки будут доступны в среде выполнения. В пути в качестве разделителей каталогов можно использовать прямую (/) или обратную (\\) косую черту.

Всегда проверяйте возвращаемое значение, чтобы узнать, равен ли указатель NULL, прежде чем выполнять какие-либо дальнейшие операции с файлом. При возникновении ошибки глобальная переменная **errno** устанавливается и может использоваться для получения конкретных сведений об ошибке. Дополнительные сведения см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

## <a name="unicode-support"></a>Поддержка Юникода

**fopen** поддерживает файловые потоки Юникода. Чтобы открыть файл в кодировке Юникод, передайте **ccs** флаг, указывающий кодировку для **fopen**, как показано ниже.

> **ФАЙЛ *fp = fopen ("newfile.txt", "rt + ccs =**_кодирование_**");**

Допустимые значения *кодирование* являются **ЮНИКОДА**, **UTF-8**, и **UTF-16LE**.

Если файл открыт в режиме Юникода, функции ввода преобразуют данные, считываемые из файла в данные UTF-16, хранимые с типом **wchar_t**. Функции, записывающие в файл, открытый в режиме Юникода ожидают буферы, содержащие данные UTF-16, хранимые с типом **wchar_t**. Если кодировка файла — UTF-8, при его записи данные UTF-16 преобразуются в UTF-8, а содержимое файла с кодировкой UTF-8 преобразуется в данные UTF-16 при его считывании. Попытка чтения или записи нечетного числа байт в режиме Юникода приводит к возникновению ошибки [проверки параметра](../../c-runtime-library/parameter-validation.md) . Для чтения или записи данных, хранимых в программе в кодировке UTF-8, используйте режим текстового или двоичного файла вместо режима Юникода. Вам необходимо реализовать все обязательные преобразования кодировки.

Если файл уже существует и открыт для чтения или добавления, метка порядка байтов (BOM), если она присутствует в файле, определяет кодирование. Кодирование BOM имеет приоритет над кодированием, который задается параметром **ccs** флаг. **Ccs** кодировка используется только при BOM отсутствует или файл доступен новый файл.

> [!NOTE]
> Обнаружение метки BOM применяется только к файлам, которые будут открываться в режиме Юникода (т. е путем передачи **ccs** флаг).

В следующей таблице приведены режимы, которые используются для различных **ccs** флаги, присвоенный **fopen** и меток порядка следования байтов в файле.

### <a name="encodings-used-based-on-ccs-flag-and-bom"></a>Кодирования, используемые на основе CCS-флага и метки BOM

|флаг CCS|Нет метки BOM (или новый файл)|BOM: UTF-8|BOM: UTF-16|
|----------------|----------------------------|-----------------|------------------|
|**ЮНИКОД**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|
|**UTF-8**|**UTF-8**|**UTF-8**|**UTF-16LE**|
|**UTF-16LE**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|

В файлы, открытые для записи в режиме Юникода, метка BOM записывается автоматически.

Если *режим* — **«, ccs =**_кодирование_**"**, **fopen** сначала пытается открыть файл с помощью чтения и доступ на запись. Если это завершается успешно, функция считывает метку BOM, чтобы определить кодировку для файла; если операция завершается сбоем, функция использует для файла кодировку по умолчанию. В любом случае **fopen** затем снова открывает файл с помощью доступ только для записи. (Это относится к **«»** режим только не **«+»** режиме.)

### <a name="generic-text-routine-mappings"></a>Сопоставления подпрограмм обработки обычного текста

|Подпрограмма TCHAR.H|_UNICODE и _MBCS не определены|_MBCS определено|_UNICODE определено|
|---------------------|------------------------------------|--------------------|-----------------------|
|**_tfopen**|**fopen**|**fopen**|**_wfopen**|

Символьная строка *режим* указывает тип доступа, который запрошен для файла, следующим образом.

|*mode*|Access|
|-|-|
**"r"**|Открывает для чтения. Если файл не существует или не удается найти, **fopen** вызов завершается ошибкой.
**"w"**|Открывает пустой файл для записи. Если указанный файл существует, его содержимое удаляется.
**"a"**|Открывается для записи в конце файла (добавление) без удаления маркера в конце файла (EOF) перед записью новых данных в файл. Создает файл, если он не существует.
**"r+"**|Открывает для чтения и записи. Файл должен существовать.
**"w+"**|Открывает пустой файл для чтения и записи. Если файл существует, его содержимое удаляется.
**"a+"**|Открывается для чтения и добавления. Операция добавления включает удаления маркера EOF перед записью новых данных в файл. Маркер EOF не восстанавливается по окончании записи. Создает файл, если он не существует.

При открытии файла с помощью **«»** типа доступа или **«+»** доступ к типу, все операции записи выполняются в конце файла. Указатель файла может быть перемещен с помощью [fseek](fseek-fseeki64.md) или [rewind](rewind.md), но является всегда возвращается в конец файла перед любой операции записи. Поэтому невозможно перезаписать существующие данные.

**«»** Режим не удаляет маркер EOF, прежде чем он добавляет в файл. После добавления команда MS-DOS TYPE отображает данные только до первоначального маркера EOF и не отображает данные, добавленные в файл. Прежде чем он добавляет в файл **«+»** режим удаляет маркер конца файла. После добавления команда TYPE MS-DOS отображает все данные в файле. **«+»** Режим необходим для добавления в потоковый файл, который прерывается с выдачей маркера конца файла CTRL + Z.

Когда **«r +»**, **«w +»**, или **«+»** задан тип доступа, чтение и запись разрешены (файл считается открыт для «обновления»). Однако при переходе от чтения к записи операция ввода должна получить маркер конца файла. Если маркер EOF отсутствует, необходимо воспользоваться промежуточным вызовом функции размещения файла. Функции размещения файла — **fsetpos**, [fseek](fseek-fseeki64.md), и [rewind](rewind.md). При переходе от записи к чтению необходимо воспользоваться промежуточным вызовом либо **fflush** или функции размещения файла.

В дополнение к указанным ранее значениям следующие символы могут добавляться к *режим* для определения режима преобразования для символов новой строки.

|*режим* модификатор|Режим преобразования|
|-|-|
**t**|Откройте файл в текстовом (переведенном) режиме.
**b**|При открытии в двоичном (непреобразованном) режиме преобразования, включающие символы возврата каретки и перевода строки, подавляются.

В текстовом режиме CTRL + Z интерпретируется как символ конца файла на входе. В файлах, открытых для чтения/записи, с помощью **«+»**, **fopen** проверяет наличие CTRL + Z в конце файла и удаляет его, если это возможно. Это делается потому, что с помощью [fseek](fseek-fseeki64.md) и **ftell** для перемещения в файле, который заканчивается символом CTRL + Z, может вызвать [fseek](fseek-fseeki64.md) неправильное поведение ближе к концу файла.

В текстовом режиме каретки return-перевода строки преобразуются в один символ перевода строки на входе, а символы перевода строки преобразуются на выходе в сочетания перевода строки возврата каретки. Если функция ввода-вывода потока Юникода работает в текстовом режиме (по умолчанию) исходный или конечный поток рассматривается как последовательность многобайтовых символов. Поэтому входные функции потока Юникода преобразуют многобайтовые символы в расширенные (как если бы для этого вызывалась функция **mbtowc**). По той же причине выходные функции потока Юникода преобразуют расширенные символы в многобайтовые (как если бы для этого вызывалась функция **wctomb**).

Если **t** или **b** не имеет *режим*, режим преобразования по умолчанию определяется глобальной переменной [_fmode](../../c-runtime-library/fmode.md). Если **t** или **b** добавляется префикс аргумента, функции и возвращает **NULL**.

Дополнительные сведения об использовании текстового и двоичного режимов в Юникоде, а также многобайтового потока ввода-вывода см. в статьях [Text and Binary Mode File I/O](../../c-runtime-library/text-and-binary-mode-file-i-o.md) и [Unicode Stream I/O in Text and Binary Modes](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md).

Следующие параметры, которые могут добавляться к *режим* чтобы указать дополнительные поведения.

|*режим* модификатор|Поведение|
|-|-|
**c**|Включите флажок фиксации для связанного *filename* таким образом, чтобы содержимое файлового буфера записывается непосредственно на диск при вызове **fflush** или **_flushall** вызывается.
**n**|Сбросьте флажок фиксации для связанного *filename* для «без фиксации». Это значение по умолчанию. Оно также переопределяет глобальный флаг фиксации при соединении программы с COMMODE.OBJ. Значение по умолчанию глобального флага фиксации — "без фиксации" (no-commit), если только программа не связана явно с файлом COMMODE.OBJ (см. статью [Link Options](../../c-runtime-library/link-options.md)).
**N**|Указывает, что файл не наследуется дочерними процессами.
**S**|Указывает, что кэширование оптимизировано для последовательного доступа с диска, но не ограничивается им.
**R**|Указывает, что кэширование оптимизировано для случайного доступа с диска, но не ограничивается им.
**T**|Определяет файл как временный. По возможности он не сбрасывается на диск.
**D**|Определяет файл как временный. Он удаляется, если закрывается последний указатель файла.
**CCS =**_кодирования_|Задает закодированный набор знаков (один из **UTF-8**, **UTF-16LE**, или **ЮНИКОДА**) для этого файла. Не указывайте никакое значение, если требуется использовать кодировку ANSI.

Допустимые символы для *режим* строку, используемую в **fopen** и **_fdopen** соответствуют *oflag* аргументы, которые используются в [_open](open-wopen.md) и [_sopen](sopen-wsopen.md), как показано ниже.

|Символы в *режим* строки|Эквивалентное *oflag* значение _open/_sopen|
|-------------------------------|----------------------------------------------------|
|**a**|**_O_WRONLY** &#124; **_O_APPEND** (обычно **_O_WRONLY** &#124; **_O_CREAT** &#124;** _O_APPEND **)|
|**+**|**_O_RDWR** &#124; **_O_APPEND** (обычно **_O_RDWR** &#124; **_O_APPEND** &#124; **_O_CREAT** )|
|**r**|**_O_RDONLY**|
|**r +**|**_O_RDWR**|
|**w**|**_O_WRONLY** (обычно **_O_WRONLY** &#124; **_O_CREAT** &#124;** _O_TRUNC **)|
|**w +**|**_O_RDWR** (обычно **_O_RDWR** &#124; **_O_CREAT** &#124; **_O_TRUNC**)|
|**b**|**_O_BINARY**|
|**t**|**_O_TEXT**|
|**c**|Нет|
|**n**|Нет|
|**S**|**_O_SEQUENTIAL**|
|**R**|**_O_RANDOM**|
|**T**|**_O_SHORTLIVED**|
|**D**|**_O_TEMPORARY**|
|**CCS = ЮНИКОДА**|**_O_WTEXT**|
|**CCS = UTF-8**|**_O_UTF8**|
|**CCS = UTF-16LE**|**_O_UTF16**|

Если вы используете **rb** режим, у вас нет перенести код, и если ожидается, что будет прочитана большая часть крупного файла или не интересует производительность сети, возможно, стоит ли использовать сопоставленные памяти файлы Win32 свободен.

## <a name="requirements"></a>Требования

|Функция|Обязательный заголовок|
|--------------|---------------------|
|**fopen**|\<stdio.h>|
|**_wfopen**|\<stdio.h> или \<wchar.h>|

**_wfopen** является расширением Майкрософт. Дополнительные сведения о совместимости см. в разделе [Совместимость](../../c-runtime-library/compatibility.md).

**c**, **n**, **t**, **S**, **R**, **T**, и **D**  *режим* представляют собой расширения Майкрософт для **fopen** и **_fdopen** и не должны использоваться где обеспечить переносимость ANSI.

## <a name="example-1"></a>Пример 1

Следующая программа открывает два файла.  Она использует **fclose** для закрытия первого файла и **_fcloseall** для закрытия всех остальных файлов.

```C
// crt_fopen.c
// compile with: /W3
// This program opens two files. It uses
// fclose to close the first file and
// _fcloseall to close all remaining files.

#include <stdio.h>

FILE *stream, *stream2;

int main( void )
{
   int numclosed;

   // Open for read (will fail if file "crt_fopen.c" does not exist)
   if( (stream  = fopen( "crt_fopen.c", "r" )) == NULL ) // C4996
   // Note: fopen is deprecated; consider using fopen_s instead
      printf( "The file 'crt_fopen.c' was not opened\n" );
   else
      printf( "The file 'crt_fopen.c' was opened\n" );

   // Open for write
   if( (stream2 = fopen( "data2", "w+" )) == NULL ) // C4996
      printf( "The file 'data2' was not opened\n" );
   else
      printf( "The file 'data2' was opened\n" );

   // Close stream if it is not NULL
   if( stream)
   {
      if ( fclose( stream ) )
      {
         printf( "The file 'crt_fopen.c' was not closed\n" );
      }
   }

   // All other files are closed:
   numclosed = _fcloseall( );
   printf( "Number of files closed by _fcloseall: %u\n", numclosed );
}
```

```Output
The file 'crt_fopen.c' was opened
The file 'data2' was opened
Number of files closed by _fcloseall: 1
```

## <a name="example-2"></a>Пример 2

Следующая программа создает файл (или перезаписывает его, если имеется) в текстовом режиме с кодировкой Юникода.  Затем она записывает две строки в файл и закрывает его. В результате получается файл с именем _wfopen_test.xml, который содержит данные из раздела вывода.

```C
// crt__wfopen.c
// compile with: /W3
// This program creates a file (or overwrites one if
// it exists), in text mode using Unicode encoding.
// It then writes two strings into the file
// and then closes the file.

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <wchar.h>

#define BUFFER_SIZE 50

int main(int argc, char** argv)
{
    wchar_t str[BUFFER_SIZE];
    size_t  strSize;
    FILE*   fileHandle;

    // Create an the xml file in text and Unicode encoding mode.
    if ((fileHandle = _wfopen( L"_wfopen_test.xml",L"wt+,ccs=UNICODE")) == NULL) // C4996
    // Note: _wfopen is deprecated; consider using _wfopen_s instead
    {
        wprintf(L"_wfopen failed!\n");
        return(0);
    }

    // Write a string into the file.
    wcscpy_s(str, sizeof(str)/sizeof(wchar_t), L"<xmlTag>\n");
    strSize = wcslen(str);
    if (fwrite(str, sizeof(wchar_t), strSize, fileHandle) != strSize)
    {
        wprintf(L"fwrite failed!\n");
    }

    // Write a string into the file.
    wcscpy_s(str, sizeof(str)/sizeof(wchar_t), L"</xmlTag>");
    strSize = wcslen(str);
    if (fwrite(str, sizeof(wchar_t), strSize, fileHandle) != strSize)
    {
        wprintf(L"fwrite failed!\n");
    }

    // Close the file.
    if (fclose(fileHandle))
    {
        wprintf(L"fclose failed!\n");
    }
    return 0;
}
```

## <a name="see-also"></a>См. также

[Потоковый ввод-вывод](../../c-runtime-library/stream-i-o.md)<br/>
[Интерпретация последовательностей многобайтовых символов](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)<br/>
[fclose, _fcloseall](fclose-fcloseall.md)<br/>
[_fdopen, _wfdopen](fdopen-wfdopen.md)<br/>
[ferror](ferror.md)<br/>
[_fileno](fileno.md)<br/>
[freopen, _wfreopen](freopen-wfreopen.md)<br/>
[_open, _wopen](open-wopen.md)<br/>
[_setmode](setmode.md)<br/>
[_sopen, _wsopen](sopen-wsopen.md)<br/>
