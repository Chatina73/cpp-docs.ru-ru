---
title: fopen, _wfopen
ms.date: 4/2/2020
api_name:
- _wfopen
- fopen
- _o__wfopen
- _o_fopen
api_location:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-stdio-l1-1-0.dll
- api-ms-win-crt-private-l1-1-0
api_type:
- DLLExport
topic_type:
- apiref
f1_keywords:
- fopen
- _wfopen
- _tfopen
- corecrt_wstdio/_wfopen
- stdio/fopen
helpviewer_keywords:
- opening files, for file I/O
- wfopen function
- tfopen function
- _tfopen function
- _wfopen function
- files [C++], opening
- fopen function
ms.assetid: e868993f-738c-4920-b5e4-d8f2f41f933d
ms.openlocfilehash: 4b9fa6542996b2c16128a841e2611b85e995be2a
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81346411"
---
# <a name="fopen-_wfopen"></a>fopen, _wfopen

Открывает файл. Доступны более надежные и безопасные версии этих функций, выполняющие дополнительные проверки параметров и возвращающие коды ошибок. См. [fopen_s, _wfopen_s](fopen-s-wfopen-s.md).

## <a name="syntax"></a>Синтаксис

```C
FILE *fopen(
   const char *filename,
   const char *mode
);
FILE *_wfopen(
   const wchar_t *filename,
   const wchar_t *mode
);
```

### <a name="parameters"></a>Параметры

*Имени файла*<br/>
Имя файла.

*Режим*<br/>
Включенный тип доступа.

## <a name="return-value"></a>Возвращаемое значение

Каждая из этих функций возвращает указатель на открытый файл. Значение указателя null обозначает ошибку. Если *имя файла* или *режим* **NULL** или пустая строка, эти функции вызывают недействительный обработчик параметров, который описан в [проверке параметров.](../../c-runtime-library/parameter-validation.md) Если выполнение разрешено продолжать, эти функции возвращают **NULL** и устанавливают **errno** **в EINVAL.**

Дополнительные сведения см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

## <a name="remarks"></a>Remarks

Функция **fopen** открывает файл, указанный *по имени файла.* По умолчанию с помощью кодовой страницы ANSI (CP_ACP) интерпретируется узкая строка *для имен файлов.* В классических приложениях Windows эту страницу можно изменить на кодовую страницу OEM (CP_OEMCP) с помощью функции [SetFileApisToOEM](/windows/win32/api/fileapi/nf-fileapi-setfileapistooem) . Функция [AreFileApisANSI](/windows/win32/api/fileapi/nf-fileapi-arefileapisansi) может быть использоваться для определения того, интерпретируется ли *имя файла* с помощью ANSI или OEM-кода системы по умолчанию. **_wfopen** является широкохарактерным вариантом **fopen**; аргументы **в пользу _wfopen** являются широкохарактерными строками. В противном случае, **_wfopen** и **fopen** ведут себя одинаково. Простое использование **_wfopen** не влияет на набор закодированных символов, который используется в потоке файлов.

**fopen** принимает пути, действительные в файловой системе в момент выполнения; **fopen** принимает пути и пути КООН, которые включают накарту сетевых дисков до тех пор, пока система, выполняя код, имеет доступ к акции или отображеному диску во время выполнения. При построении путей для **fopen**убедитесь, что диски, пути или сетевые доли будут доступны в среде выполнения. В пути в качестве разделителей каталогов можно использовать прямую (/) или обратную (\\) косую черту.

Всегда проверяйте возвращаемое значение, чтобы узнать, равен ли указатель NULL, прежде чем выполнять какие-либо дальнейшие операции с файлом. При возникновении ошибки устанавливается глобальная переменная **errno,** которая может быть использована для получения конкретной информации об ошибке. Дополнительные сведения см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

По умолчанию глобальное состояние этой функции приспозировано к приложению. Чтобы изменить это, [см. Глобальное состояние в CRT](../global-state.md).

## <a name="unicode-support"></a>Поддержка Юникода

**fopen** поддерживает потоки файлов Unicode. Чтобы открыть файл Unicode, передайте флаг **ccs,** который определяет желаемое кодирование для **fopen,** следующим образом.

> **FILE \*fp - fopen ("newfile.txt", "rt", ccs'**_кодирование_**");**

Разрешенные значения *кодирования* являются **UNICODE,** **UTF-8**и **UTF-16LE.**

При открытии файла в режиме Unicode функции ввода переводят данные, считываемые из файла, в данные UTF-16, хранящиеся как **wchar_t**типа. Функции, записываемые в файл, открытый в режиме Unicode, ожидают буферов, содержащих данные UTF-16, хранящиеся как **wchar_t**типа. Если кодировка файла — UTF-8, при его записи данные UTF-16 преобразуются в UTF-8, а содержимое файла с кодировкой UTF-8 преобразуется в данные UTF-16 при его считывании. Попытка прочитать или написать нечетное количество байтов в режиме Unicode вызывает ошибку [проверки параметров.](../../c-runtime-library/parameter-validation.md) Для чтения или записи данных, хранимых в программе в кодировке UTF-8, используйте режим текстового или двоичного файла вместо режима Юникода. Вам необходимо реализовать все обязательные преобразования кодировки.

Если файл уже существует и открыт для чтения или добавления, метка порядка байтов (BOM), если она присутствует в файле, определяет кодирование. Кодирование BOM имеет приоритет над кодированием, которое указывается флагом **ccs.** Кодирование **ccs** используется только в том случае, если нет BOM или файл является новым файлом.

> [!NOTE]
> Обнаружение BOM применяется только к файлам, которые открыты в режиме Unicode (т.е. при прохождении флага **ccs).**

В следующей таблице кратко излагаются режимы, которые используются для различных **флагов ccs,** отданных для **fopen** и Байт-заказа в файле.

### <a name="encodings-used-based-on-ccs-flag-and-bom"></a>Кодирования, используемые на основе CCS-флага и метки BOM

|ccs флаг|Нет метки BOM (или новый файл)|BOM: UTF-8|BOM: UTF-16|
|----------------|----------------------------|-----------------|------------------|
|**Юникода**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|
|**UTF-8**|**UTF-8**|**UTF-8**|**UTF-16LE**|
|**UTF-16LE**|**UTF-16LE**|**UTF-8**|**UTF-16LE**|

В файлы, открытые для записи в режиме Юникода, метка BOM записывается автоматически.

Если *режим* **"а, ccs'**_кодирования_**"**, **Fopen** сначала пытается открыть файл, используя как читать и писать доступ. Если это завершается успешно, функция считывает метку BOM, чтобы определить кодировку для файла; если операция завершается сбоем, функция использует для файла кодировку по умолчанию. В любом случае, **fopen** будет повторно открыть файл с помощью доступа только для записи. (Это относится только к режиму **"а",** а не к режиму **"а".)**

### <a name="generic-text-routine-mappings"></a>Универсальное текстовое сопоставление функций

|Подпрограмма TCHAR.H|_UNICODE и _MBCS не определены|_MBCS определено|_UNICODE определено|
|---------------------|------------------------------------|--------------------|-----------------------|
|**_tfopen**|**fopen**|**fopen**|**_wfopen**|

*Режим* строки символов определяет вид доступа, который запрашивается для файла, следующим образом.

|*Режим*|Доступ|
|-|-|
| **"r"** | Открывает для чтения. Если файл не существует или не может быть найден, **вызов Fopen** завершается сбой. |
| **"w"** | Открывает пустой файл для записи. Если указанный файл существует, его содержимое удаляется. |
| **"а"** | Открывается для записи в конце файла (добавление) без удаления маркера в конце файла (EOF) перед записью новых данных в файл. Создает файл, если он не существует. |
| **"r"** | Открывает для чтения и записи. Файл должен существовать. |
| **"W"** | Открывает пустой файл для чтения и записи. Если файл существует, его содержимое удаляется. |
| **"а"** | Открывается для чтения и добавления. Операция добавления включает удаления маркера EOF перед записью новых данных в файл. Маркер EOF не восстанавливается по окончании записи. Создает файл, если он не существует. |

При открытии файла с помощью типа доступа **"a"** или типа доступа **"a"** все операции записи происходят в конце файла. Указатель файла можно переместить с помощью [fseek](fseek-fseeki64.md) или [перемотать](rewind.md)назад, но всегда перемещается обратно в конец файла до выполнения операции записи. Поэтому невозможно перезаписать существующие данные.

Режим **"а"** не удаляет маркер EOF до его придатка к файлу. После добавления команда MS-DOS TYPE отображает данные только до первоначального маркера EOF и не отображает данные, добавленные в файл. Перед тем, как он пригововит сяочку в файл, режим **«а»** удаляет маркер EOF. После добавления команда TYPE MS-DOS отображает все данные в файле. Режим **«а»** необходим для приложения к файлу потока, который завершается маркером CTRL.

При указании типа доступа **«r »**, **«w»** или **«a»** включено как чтение, так и письмо (файл, как говорят, открыт для «обновления»). Однако при переходе от чтения к записи операция ввода должна получить маркер конца файла. Если маркер EOF отсутствует, необходимо воспользоваться промежуточным вызовом функции размещения файла. Функции позиционирования файлов являются **fsetpos,** [fseek](fseek-fseeki64.md)и [rewind.](rewind.md) При переходе от записи к чтению необходимо использовать промежуточный вызов либо **для fflush,** либо для функции позиционирования файлов.

В дополнение к более ранним значениям, следующие символы могут быть добавлены в *режим,* чтобы указать режим перевода для новых символов.

|*модификатор режима*|Режим перевода|
|-|-|
| **T** | Откройте файл в текстовом (переведенном) режиме. |
| **B** | Открыт в двоичном (непереведенном) режиме; переводы, включающие символы перевозки-возврата и линейных кормов, подавляются. |

В текстовом режиме CTRL-- интерпретируется как символ EOF при вхотворе. В файлах, которые открыты для чтения/записи с помощью **"a"**, **fopen** проверки для CTRL в конце файла и удаляет его, если это возможно. Это делается потому, что использование [fseek](fseek-fseeki64.md) и **ftell** для перемещения в файле, который заканчивается с CTRL, может привести к тому, что [fseek](fseek-fseeki64.md) будет вести себя неправильно ближе к концу файла.

В текстовом режиме комбинации подачи обратных линий перевозки переводится в однолинейные каналы на входной, а символы линейного корма переводятся в комбинации подачи обратных линий на выходе. Если функция ввода-вывода потока Юникода работает в текстовом режиме (по умолчанию) исходный или конечный поток рассматривается как последовательность многобайтовых символов. Поэтому входные функции потока Юникода преобразуют многобайтовые символы в расширенные (как если бы для этого вызывалась функция **mbtowc**). По той же причине выходные функции потока Юникода преобразуют расширенные символы в многобайтовые (как если бы для этого вызывалась функция **wctomb**).

Если **t** или **b** не приведен в *режиме,* режим перевода по умолчанию определяется глобальной переменной [_fmode.](../../c-runtime-library/fmode.md) Если **t** или **b** прикрепляется к аргументу, функция выходит из строя и возвращает **NULL**.

Дополнительные сведения об использовании текстового и двоичного режимов в Юникоде, а также многобайтового потока ввода-вывода см. в статьях [Text and Binary Mode File I/O](../../c-runtime-library/text-and-binary-mode-file-i-o.md) и [Ввод-вывод в поток в кодировке Юникод в текстовом и двоичном режиме](../../c-runtime-library/unicode-stream-i-o-in-text-and-binary-modes.md).

Следующие параметры могут быть придещеты в *режим,* чтобы указать дополнительные поведения.

|*модификатор режима*|Поведение|
|-|-|
| **C** | Включите флаг коммита для связанного *имени файла,* чтобы содержимое буфера файла было записано непосредственно на диск, если **вызваны fflush** или **_flushall.** |
| **n** | Сбросить флаг коммитов для связанного *имени файла* на "не-коммит". Это значение по умолчанию. Оно также переопределяет глобальный флаг фиксации при соединении программы с COMMODE.OBJ. Значение по умолчанию глобального флага фиксации — без фиксации (no-commit), если только программа не связана явно с файлом COMMODE.OBJ (см. раздел [Параметры ссылок](../../c-runtime-library/link-options.md)). |
| **N** | Указывает, что файл не наследуется дочерними процессами. |
| **S** | Указывает, что кэширование оптимизировано для последовательного доступа с диска, но не ограничивается им. |
| **R** | Указывает, что кэширование оптимизировано для случайного доступа с диска, но не ограничивается им. |
| **T** | Определяет файл как временный. По возможности он не сбрасывается на диск. |
| **D** | Определяет файл как временный. Он удаляется, если закрывается последний указатель файла. |
| **кодирование ccs'**_encoding_ | Определяем закодированный набор символов для использования (один из **UTF-8,** **UTF-16LE**, или **UNICODE)** для этого файла. Не указывайте никакое значение, если требуется использовать кодировку ANSI. |

Действительные символы для строки *режима,* которая используется в **fopen** и **_fdopen** соответствуют аргументам *oflag,* которые используются в [_open](open-wopen.md) и [_sopen,](sopen-wsopen.md)следующим образом.

|Персонажи в *строке режима*|Эквивалент значения лага\_для \_ *открытого/открытого*|
|-------------------------------|----------------------------------------------------|
|**a**|**\_O\_WRONLY** &#124; ** \_O\_APPEND** (обычно ** \_O WRONLY\_** &#124; ** \_O\_CREAT** &#124; ** \_O\_APPEND)**|
|**аа**|**\_O\_RDWR** &#124; ** \_O\_APPEND** (обычно ** \_O RDWR\_** &#124; ** \_O\_APPEND** &#124; ** \_O\_CREAT)**|
|**R**|**\_O\_RDONLY**|
|**рЗ**|**\_O\_RDWR**|
|**Ж**|**\_O\_WRONLY** (обычно ** \_O WRONLY\_** &#124; ** \_O\_CREAT** &#124; ** \_O\_TRUNC)**|
|**w**|**\_O\_RDWR** (обычно ** \_O RDWR\_** &#124; ** \_O\_CREAT** &#124; ** \_O\_TRUNC)**|
|**B**|**\_O\_БИНАР**|
|**T**|**\_O\_ТЕКСТ**|
|**C**|Отсутствуют|
|**n**|Отсутствуют|
|**S**|**\_О\_СЕКУЕНТИАЛ**|
|**R**|**\_O\_РАНХИЕ**|
|**T**|**\_O\_ШОРТАВЕВЕД**|
|**D**|**\_O\_TEMPORARY**|
|**ccs-UNICODE**|**\_O\_WTEXT**|
|**ccs-UTF-8**|**\_O\_UTF8**|
|**ccs-UTF-16LE**|**\_O\_UTF16**|

Если вы используете режим **rb,** вам не придется портировать свой код, и если вы ожидаете прочитать большую часть большого файла или не беспокоитесь о производительности сети, вы также можете рассмотреть вопрос об использовании памяти на карте Файлов Win32 в качестве опции.

## <a name="requirements"></a>Требования

|Компонент|Обязательный заголовок|
|--------------|---------------------|
|**fopen**|\<stdio.h>|
|**_wfopen**|\<stdio.h> или \<wchar.h>|

**_wfopen** — это расширение корпорации Майкрософт. Дополнительные сведения о совместимости см. в разделе [Совместимость](../../c-runtime-library/compatibility.md).

**c,** **n,** **t,** **S,** **R,** **T**и **D** *параметры режима* Microsoft являются расширениями Microsoft для **fopen** и **_fdopen** и не должны использоваться там, где anSI портативность является желаемой.

## <a name="example-1"></a>Пример 1

Следующая программа открывает два файла.  Он использует **fclose,** чтобы закрыть первый файл и **_fcloseall,** чтобы закрыть все оставшиеся файлы.

```C
// crt_fopen.c
// compile with: /W3
// This program opens two files. It uses
// fclose to close the first file and
// _fcloseall to close all remaining files.

#include <stdio.h>

FILE *stream, *stream2;

int main( void )
{
   int numclosed;

   // Open for read (will fail if file "crt_fopen.c" does not exist)
   if( (stream  = fopen( "crt_fopen.c", "r" )) == NULL ) // C4996
   // Note: fopen is deprecated; consider using fopen_s instead
      printf( "The file 'crt_fopen.c' was not opened\n" );
   else
      printf( "The file 'crt_fopen.c' was opened\n" );

   // Open for write
   if( (stream2 = fopen( "data2", "w+" )) == NULL ) // C4996
      printf( "The file 'data2' was not opened\n" );
   else
      printf( "The file 'data2' was opened\n" );

   // Close stream if it is not NULL
   if( stream)
   {
      if ( fclose( stream ) )
      {
         printf( "The file 'crt_fopen.c' was not closed\n" );
      }
   }

   // All other files are closed:
   numclosed = _fcloseall( );
   printf( "Number of files closed by _fcloseall: %u\n", numclosed );
}
```

```Output
The file 'crt_fopen.c' was opened
The file 'data2' was opened
Number of files closed by _fcloseall: 1
```

## <a name="example-2"></a>Пример 2

Следующая программа создает файл (или перезаписывает его, если имеется) в текстовом режиме с кодировкой Юникода.  Затем она записывает две строки в файл и закрывает его. В результате получается файл с именем _wfopen_test.xml, который содержит данные из раздела вывода.

```C
// crt__wfopen.c
// compile with: /W3
// This program creates a file (or overwrites one if
// it exists), in text mode using Unicode encoding.
// It then writes two strings into the file
// and then closes the file.

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <wchar.h>

#define BUFFER_SIZE 50

int main(int argc, char** argv)
{
    wchar_t str[BUFFER_SIZE];
    size_t  strSize;
    FILE*   fileHandle;

    // Create an the xml file in text and Unicode encoding mode.
    if ((fileHandle = _wfopen( L"_wfopen_test.xml",L"wt+,ccs=UNICODE")) == NULL) // C4996
    // Note: _wfopen is deprecated; consider using _wfopen_s instead
    {
        wprintf(L"_wfopen failed!\n");
        return(0);
    }

    // Write a string into the file.
    wcscpy_s(str, sizeof(str)/sizeof(wchar_t), L"<xmlTag>\n");
    strSize = wcslen(str);
    if (fwrite(str, sizeof(wchar_t), strSize, fileHandle) != strSize)
    {
        wprintf(L"fwrite failed!\n");
    }

    // Write a string into the file.
    wcscpy_s(str, sizeof(str)/sizeof(wchar_t), L"</xmlTag>");
    strSize = wcslen(str);
    if (fwrite(str, sizeof(wchar_t), strSize, fileHandle) != strSize)
    {
        wprintf(L"fwrite failed!\n");
    }

    // Close the file.
    if (fclose(fileHandle))
    {
        wprintf(L"fclose failed!\n");
    }
    return 0;
}
```

## <a name="see-also"></a>См. также раздел

[Потоковый ввод-вывод](../../c-runtime-library/stream-i-o.md)<br/>
[Интерпретация последовательностей многобайтовых символов](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)<br/>
[fclose, _fcloseall](fclose-fcloseall.md)<br/>
[_fdopen, _wfdopen](fdopen-wfdopen.md)<br/>
[ferror](ferror.md)<br/>
[_fileno](fileno.md)<br/>
[freopen, _wfreopen](freopen-wfreopen.md)<br/>
[_open, _wopen](open-wopen.md)<br/>
[_setmode](setmode.md)<br/>
[_sopen, _wsopen](sopen-wsopen.md)<br/>
