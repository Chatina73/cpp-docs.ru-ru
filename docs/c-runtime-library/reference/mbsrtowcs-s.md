---
title: mbsrtowcs_s
ms.date: 4/2/2020
api_name:
- mbsrtowcs_s
- _o_mbsrtowcs_s
api_location:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-convert-l1-1-0.dll
- api-ms-win-crt-private-l1-1-0
api_type:
- DLLExport
topic_type:
- apiref
f1_keywords:
- mbsrtowcs_s
helpviewer_keywords:
- mbsrtowcs_s function
ms.assetid: 4ee084ec-b15d-4e5a-921d-6584ec3b5a60
ms.openlocfilehash: 62ae534e8080b74ada49cca005811a049055cb65
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81338902"
---
# <a name="mbsrtowcs_s"></a>mbsrtowcs_s

Преобразуют многобайтовую строку символов в текущем языковом стандарте в представление с расширенными символами. Версия функции [mbsrtowcs](mbsrtowcs.md) с усовершенствованиями системы безопасности, описанными в разделе [Функции безопасности в CRT](../../c-runtime-library/security-features-in-the-crt.md).

## <a name="syntax"></a>Синтаксис

```C
errno_t mbsrtowcs_s(
   size_t * pReturnValue,
   wchar_t * wcstr,
   size_t sizeInWords,
   const char ** mbstr,
   size_t count,
   mbstate_t * mbstate
);
template <size_t size>
errno_t mbsrtowcs_s(
   size_t * pReturnValue,
   wchar_t (&wcstr)[size],
   const char ** mbstr,
   size_t count,
   mbstate_t * mbstate
); // C++ only
```

### <a name="parameters"></a>Параметры

*pReturnValue*<br/>
Количество символов для преобразования.

*wcstr*<br/>
Адрес буфера для результирующей преобразованной строки расширенных символов.

*sizeInWords*<br/>
Размер *wcstr* в словах (широкие символы).

*mbstr*<br/>
Косвенный указатель на расположение преобразуемой строки многобайтовых символов.

*count*<br/>
Максимальное количество широких символов для хранения в буфере *wcstr,* не включая термины null или [_TRUNCATE.](../../c-runtime-library/truncate.md)

*mbstate*<br/>
Указатель на **объект состояния mbstate_t.** Если это значение является пустым указателем, используется статичный внутренний объект состояния преобразования. Поскольку внутренний **объект mbstate_t** не является безопасным для потока, мы рекомендуем вам всегда проходить свой собственный параметр *mbstate.*

## <a name="return-value"></a>Возвращаемое значение

Нуль, если преобразование выполнено успешно; код ошибки при неудаче.

|Условие ошибки|Значение возврата и **errno**|
|---------------------|------------------------------|
|*wcstr* является нулевой указатель и *размерInWords* > 0|**EINVAL**|
|*mbstr* является нулевой указатель|**EINVAL**|
|Строка, косвенно накананная *mbstr,* содержит многобайтную последовательность, которая не действительна для текущего локализации.|**EILSEQ**|
|Буфер назначения слишком мал, чтобы содержать преобразованную строку (если *не считать* **_TRUNCATE;** для получения дополнительной информации, см. Замечания)|**ERANGE**|

Если выполняется какое-либо из этих условий, вызывается исключение о недопустимом параметре, как описано в разделе [Проверка параметров](../../c-runtime-library/parameter-validation.md). Если выполнение разрешено продолжать, функция возвращает код ошибки и устанавливает **errno,** как указано в таблице.

## <a name="remarks"></a>Remarks

Функция **mbsrtowcs_s** преобразует строку мультибайтных символов, косвенно на которые указывает *mbstr,* в широкие символы, хранящиеся в буфере, на который указывает *wcstr,* с помощью состояния преобразования, содержащегося в *mbstate.* Преобразование будет продолжаться для каждого символа до тех пор, пока не будет выполнено одно из указанных ниже условий.

- Встретился многобайтовый символ null.

- Встретился недопустимый многобайтовый символ.

- Количество широких символов, хранящихся в буфере *wcstr,* *равному количеству.*

Строка назначения *wcstr* всегда непрекращается, даже в случае ошибки, если *wcstr* не является нулевой указателем.

Если *подсчет* — это особое значение [_TRUNCATE,](../../c-runtime-library/truncate.md) **mbsrtowcs_s** преобразует столько строки, сколько впишется в буфер назначения, оставляя при этом место для нулевого терминатора.

Если **mbsrtowcs_s** успешно преобразует строку исходного кода, он помещает размер в широкие символы преобразованной строки и нулевой терминатор в *&#42;pReturnValue*, при условии, *pReturnValue* не является нулевой указатель. Это происходит даже в том случае, если аргумент *wcstr* является нулевой указателем и позволяет определить необходимый размер буфера. Обратите внимание, что если *wcstr* является нулевой указатель, *кол* игнорируется.

Если *wcstr* не является нулевой указателем, объект указателя, на который указывает *mbstr,* назначается нулевой указатель, если преобразование остановлено, потому что был достигнут термин null. В противном случае ему назначается адрес позиции, следующей за последним преобразованным многобайтовым символом, если таковая имеется. Это позволяет продолжить преобразование с того же места при последующем вызове функции.

Если *mbstate* является нулевой указатель, используется внутренняя **mbstate_t** преобразования состояния статического объекта. Поскольку этот внутренний статичный объект не является безопасным для потоков, мы рекомендуем вам передать свое собственное значение *mbstate.*

Если **mbsrtowcs_s** сталкивается с мультибайтным символом, который не действителен в текущем месте, он помещает -1 в *&#42;pReturnValue,* устанавливает буфер назначения *wcstr* к пустой строке, устанавливает **errno** к **EILSE**, и возвращает **EILSE**.

Если последовательности, указанные *mbstr* и *wcstr,* перекрываются, поведение **mbsrtowcs_s** не определено. **mbsrtowcs_s** зависит от LC_TYPE категории текущего локализации.

> [!IMPORTANT]
> Убедитесь, что *wcstr* и *mbstr* не пересекаются, и это *количество* правильно отражает количество мультибайт символов для преобразования.

Функция **mbsrtowcs_s** отличается от [mbstowcs_s, _mbstowcs_s_l](mbstowcs-s-mbstowcs-s-l.md) ее перезапуском. Состояние преобразования хранится в *mbstate* для последующих вызовов к тем же или другим перезажаемым функциям. При смешанном использовании перезапускаемых и неперезапускаемых функций результаты становятся неопределенными. Например, приложение должно использовать **mbsrlen** вместо **mbslen,** если вместо **mbstowcs_s**используется последующий вызов **mbsrtowcs_s.**

В C++ использование этой функции упрощено наличием шаблонных перегрузок; перегруженные методы могут автоматически определять длину буфера (что исключает необходимость в указании аргумента с размером буфера), а также они могут автоматически заменять более старые, незащищенные функции их новыми безопасными аналогами. Дополнительные сведения см. в разделе [Безопасные перегрузки шаблонов](../../c-runtime-library/secure-template-overloads.md).

По умолчанию глобальное состояние этой функции приспозировано к приложению. Чтобы изменить это, [см. Глобальное состояние в CRT](../global-state.md).

## <a name="exceptions"></a>Исключения

Функция **mbsrtowcs_s** является многопоточной безопасной, если в текущем потоке нет функции **в** установлении текущих потоков, пока эта функция выполняется, а аргумент *mbstate* не является указателем нулевой.

## <a name="requirements"></a>Требования

|Подпрограмма|Обязательный заголовок|
|-------------|---------------------|
|**mbsrtowcs_s**|\<wchar.h>|

## <a name="see-also"></a>См. также раздел

[Преобразование данных](../../c-runtime-library/data-conversion.md)<br/>
[Локаль](../../c-runtime-library/locale.md)<br/>
[Интерпретация последовательностей многобайтовых символов](../../c-runtime-library/interpretation-of-multibyte-character-sequences.md)<br/>
[mbrtowc](mbrtowc.md)<br/>
[mbtowc, _mbtowc_l](mbtowc-mbtowc-l.md)<br/>
[mbstowcs_s, _mbstowcs_s_l](mbstowcs-s-mbstowcs-s-l.md)<br/>
[mbsinit](mbsinit.md)<br/>
