---
title: Типы данных SBCS и MBCS
ms.date: 04/11/2018
f1_keywords:
- MBCS
- SBCS
helpviewer_keywords:
- SBCS and MBCS data types
- data types [C], MBCS and SBCS
ms.assetid: 4c3ef9da-e397-48d4-800e-49dba36db171
ms.openlocfilehash: 72215b7a3fff638daf02f136e3a107ce8a8a00d5
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87233916"
---
# <a name="sbcs-and-mbcs-data-types"></a>Типы данных SBCS и MBCS

Любая подпрограмма библиотеки времени выполнения Microsoft MBCS, которая обрабатывает только один многобайтовый символ или один байт многобайтового символа, принимает **`unsigned int`** аргумент (где 0x00 <= символьное значение <= 0xFFFF и 0x00 <= Byte value <= 0xFF). Подпрограммы MBCS, обрабатывающие многобайтовые байты или символы в строковом контексте, предполагают, что строка многобайтовых символов будет представлена в виде **`unsigned char`** указателя.

> [!CAUTION]
> Каждый байт многобайтового символа может быть представлен в 8-разрядном виде **`char`** . Однако однобайтовый символ типа **`char`** со значением, превышающим 0x7F, имеет отрицательное значение. Если такой символ преобразуется непосредственно в **`int`** или **`long`** , то он расширяется компилятором и поэтому может привести к непредвиденным результатам.

Поэтому лучше представлять байт многобайтового символа как 8-разрядный **`unsigned char`** . Или, чтобы избежать отрицательного результата, просто преобразуйте однобайтовый символ типа **`char`** в **`unsigned char`** перед его преобразованием в **`int`** или **`long`** .

Поскольку некоторые функции обработки строк SBCS принимают (подписанные) **`char`** <strong>\*</strong> Параметры, при определении **_MBCS** будет выдано предупреждение компилятора несоответствия типов. Существует три способа избежать этого предупреждения, они перечислены в порядке эффективности:

1. Использование подставляемых типобезопасных функций из файла TCHAR.H. Это поведение по умолчанию.

1. Использование макроса перехода, содержащегося в файле TCHAR.H, посредством определения символа **_MB_MAP_DIRECT** в командной строке. После этого необходимо сопоставить типы вручную. Этот способ является наиболее быстрым, однако не обеспечивает типобезопасность.

1. Использование типобезопасных функций статической библиотеки, содержащихся в файле TCHAR.H. Для этого необходимо определить константу **_NO_INLINING** в командной строке. Это самый медленный и в то же время самый типобезопасный способ.

## <a name="see-also"></a>См. также статью

[Интернационализация](../c-runtime-library/internationalization.md)<br/>
[Подпрограммы универсальной среды выполнения C по категориям](../c-runtime-library/run-time-routines-by-category.md)<br/>
