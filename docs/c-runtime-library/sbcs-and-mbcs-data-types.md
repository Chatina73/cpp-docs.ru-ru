---
title: Типы данных SBCS и MBCS
description: Как представлять один и многобайтовый символ в среде выполнения Microsoft C.
ms.topic: conceptual
ms.date: 04/11/2018
f1_keywords:
- MBCS
- SBCS
helpviewer_keywords:
- SBCS and MBCS data types
- data types [C], MBCS and SBCS
ms.assetid: 4c3ef9da-e397-48d4-800e-49dba36db171
ms.openlocfilehash: 27d32ffd079cdc82ab8a799df9d9ec778b546a3b
ms.sourcegitcommit: 9451db8480992017c46f9d2df23fb17b503bbe74
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/30/2020
ms.locfileid: "91590255"
---
# <a name="sbcs-and-mbcs-data-types"></a>Типы данных SBCS и MBCS

Любая подпрограмма библиотеки времени выполнения Microsoft MBCS, которая обрабатывает только один многобайтовый символ или 1 байт многобайтового символа, принимает **`unsigned int`** аргумент (где 0x00 <= символьное значение <= 0xFFFF и 0x00 <= Byte value <= 0xFF). Подпрограммы MBCS, обрабатывающие многобайтовые байты или символы в строковом контексте, предполагают, что строка многобайтовых символов будет представлена в виде **`unsigned char`** указателя.

> [!CAUTION]
> Каждый байт многобайтового символа может быть представлен в 8-разрядном виде **`char`** . Однако однобайтовый символ типа **`char`** со значением, превышающим 0x7F, имеет отрицательное значение. Если такой символ преобразуется непосредственно в **`int`** или **`long`** , то он расширяется компилятором и поэтому может привести к непредвиденным результатам.

Лучше представлять байт многобайтового символа как 8-разрядный **`unsigned char`** . Или, чтобы избежать отрицательного результата, преобразуйте однобайтовый символ типа **`char`** в тип **`unsigned char`** перед его преобразованием в **`int`** или **`long`** .

Поскольку некоторые функции обработки строк SBCS принимают (подписанные) **`char`** <strong>\*</strong> Параметры, при определении **_MBCS** будет выдано предупреждение компилятора несоответствия типов. Существует три способа избежать этого предупреждения, они перечислены в порядке эффективности:

1. Использование подставляемых типобезопасных функций из файла TCHAR.H. Это поведение установлено по умолчанию.

1. Использование макроса перехода, содержащегося в файле TCHAR.H, посредством определения символа **_MB_MAP_DIRECT** в командной строке. После этого необходимо сопоставить типы вручную. Это самый быстрый метод, но он не является строго типизированным.

1. Использование типобезопасных функций статической библиотеки, содержащихся в файле TCHAR.H. Для этого необходимо определить константу **_NO_INLINING** в командной строке. Это самый медленный и в то же время самый типобезопасный способ.

## <a name="see-also"></a>См. также

[Интернационализация](../c-runtime-library/internationalization.md)<br/>
[Подпрограммы универсальной среды выполнения C по категориям](../c-runtime-library/run-time-routines-by-category.md)<br/>
