---
title: Материалы для разработчиков C++ для каналов на стороне упреждающего выполнения
ms.date: 07/10/2018
helpviewer_keywords:
- Visual C++, security
- security [C++]
- security [C++], best practices
- Spectre
- CVE-2017-5753
- Speculative Execution
ms.openlocfilehash: b3895cdb060d45d3f75c75f75c930e868b3654b2
ms.sourcegitcommit: 7d64c5f226f925642a25e07498567df8bebb00d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2019
ms.locfileid: "65448605"
---
# <a name="c-developer-guidance-for-speculative-execution-side-channels"></a>Материалы для разработчиков C++ для каналов на стороне упреждающего выполнения

Эта статья содержит рекомендации для разработчиков для помощи по выявлению и устранению рисков при уязвимостях упреждающего исполнения на стороне канала оборудования в программном обеспечении C++. Эти уязвимости может раскрыть конфиденциальную информацию через границы доверия она может влиять на программное обеспечение, выполняемое для процессоров, поддерживающих наблюдающей out порядок выполнения инструкций. Этот класс уязвимостей была первой, описанной в января 2018 г. и Дополнительные сведения и руководство можно найти в [совет по безопасности корпорации Майкрософт](https://portal.msrc.microsoft.com/security-guidance/advisory/ADV180002).

Руководства, предоставленного в этой статье относится к классов уязвимостей, представленный:

1. CVE-2017-5753, также известный как первого варианта Spectre. Этот класс оборудования уязвимость относится к стороне каналов, которые могут возникнуть из-за упреждающего исполнения, которые происходят в результате условного ветвлений. Microsoft C++ компилятора в Visual Studio 2017 (начиная с версии 15.5.5) включает поддержку `/Qspectre` переключатель, который обеспечивает защиту во время компиляции для ограниченного набора потенциально уязвимые шаблоны кодирования, связанных с CVE-2017-5753. `/Qspectre` Коммутатор также доступен в Visual Studio 2015 с обновлением 3 через [4338871 КБ](https://support.microsoft.com/help/4338871). В документации по [/qspectre](https://docs.microsoft.com/cpp/build/reference/qspectre) флаг более подробные сведения о его эффекты и использования.

2. CVE-2018-3639, также известный как [наблюдающей обход Store (SSB)](https://aka.ms/sescsrdssb). Этот класс оборудования уязвимость относится к стороне каналов, которые могут возникнуть из-за упреждающего исполнения нагрузки впереди зависимые хранилища, в результате неверным прогнозированием доступа к памяти.

Это доступное введение уязвимостях упреждающего исполнения на стороне каналам можно найти в презентацию под названием [варианта Spectre и Meltdown](https://www.youtube.com/watch?v=_4O0zMW-Zu4) по одной из групп справочные материалы, которые обнаружены следующие проблемы.

## <a name="what-are-speculative-execution-side-channel-hardware-vulnerabilities"></a>Что такое уязвимости оборудования наблюдающая выполнения на стороне канала

Современные процессоры предоставляют более высокие степени производительности, сделав использование упреждающее и неупорядоченного выполнения инструкций. Например, часто для этого предсказания целевого объекта ветви (условного и косвенных), позволяющий ЦП начинают гипотетически выполнение инструкции на целевом компьютере предсказанные ветви, что позволяет избежать зависания, пока не будет конечный адрес ветвления фактическое Разрешить. В случае, если ЦП позже обнаруживает, что произошло неверным прогнозированием, удаляются все сведения о состоянии компьютера, вычисленная гипотетически. Это гарантирует, что не с точки зрения архитектуры видимые эффекты mispredicted предположение.

Хотя упреждающего исполнения не влияет на режим с точки зрения архитектуры отображения, его можно оставить остаточная трассировки в состоянии архитектуры, например различные кэши, используемые ЦП. Это эти остаточные данные трассировки упреждающего выполнения, который может привести к появлению уязвимостей канала на стороне. Чтобы лучше понять это, рассмотрим следующий фрагмент кода, который предоставляет пример CVE-2017-5753 (обход проверки границ).

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

В этом примере `ReadByte` — предоставленный буфер, размер буфера и индекса в данном буфере. Параметр индекса, в соответствии с `untrusted_index`, предоставляемую меньше привилегированный контекст, таким как обычных процесс. Если `untrusted_index` — меньше, чем `buffer_size`, то символ по этому индексу считывается из `buffer` и используется для индекса в общей области памяти, на который ссылается `shared_buffer`.

С точки зрения архитектуры этой последовательности кода абсолютно безопасных, так как гарантируется, что `untrusted_index` всегда будет меньше, чем `buffer_size`. Однако при наличии наблюдающей выполнения это возможно, что ЦП неверное предсказание Условная ветвь и выполняет тело if инструкции, даже когда `untrusted_index` больше или равно `buffer_size`. В результате, ЦП может гипотетически считывает байт из-за пределов границы `buffer` (который может быть секрет) и затем может использовать это значение byte для вычисления адреса последующих нагрузки через `shared_buffer`.

Во время ЦП в конечном итоге обнаружит это неверным прогнозированием, остаточная побочные эффекты могут остаться в кэше Процессора, раскрывают информацию о байта, считанное вне допустимых границ из `buffer`. Эти побочные эффекты могут определяться с помощью меньше привилегированный контекст, под управлением системы при проверке, насколько быстро каждого кэша строку в `shared_buffer` осуществляется. Ниже приведены шаги, которые можно использовать для выполнения этой задачи.

1. **Вызвать `ReadByte` несколько раз с `untrusted_index` , меньше, чем `buffer_size`** . Контекст, осуществляющих атаки может привести к жертвы контекст для вызова `ReadByte` (например, через RPC), ветвь прогноза является научиться быть не берутся как `untrusted_index` — меньше, чем `buffer_size`.

2. **Очистить все строки кэша в `shared_buffer`** . Контекст, осуществляющих атаки необходимо очистить все строки кэша в общей области памяти, на который ссылается `shared_buffer`. Так как является общей области памяти, это довольно просто и может выполняться с помощью встроенных функций, таких как `_mm_clflush`.

3. **Вызвать `ReadByte` с `untrusted_index` , размер которых превышает `buffer_size`** . Контекст, осуществляющих атаки вызывает жертвы контекст для вызова `ReadByte` таким образом, что неправильно прогнозирует, что ветвь не будет выполнено. Это приводит процессорам выполнять тело if гипотетически блоке с `untrusted_index` , размер которых превышает `buffer_size`, таким образом, что приведет к выходящие за пределы области чтения из `buffer`. Следовательно `shared_buffer` индексируется с помощью потенциально секретную значения, который был прочитан выходящие за пределы области, что приводит к строке соответствующего кэша загрузки ЦП.

4. **Просмотрите каждую строку кэша в `shared_buffer` для просмотра которой осуществляется быстрее всего**. Контекст, осуществляющих атаки можно прочитать каждой строки кэша в `shared_buffer` и обнаружить строку кэша, которая значительно быстрее, чем другие. Это строка кэша, которая, вероятнее всего, которые были перенесены шаге 3. Так как между байтов значение и кэш строки в этом примере устанавливается отношение 1:1, это позволяет злоумышленнику определить фактическое значение байта, который был считан, выходящие за пределы области.

Приведенные выше действия, выполняемые пример использования подход, называемый FLUSH + ПЕРЕЗАГРУЗИТЬ в сочетании с использованием экземпляра CVE-2017-5753.

## <a name="what-software-scenarios-can-be-impacted"></a>Для каких сценариев программного обеспечения могут быть затронуты?

Разработка безопасного программного обеспечения, с помощью процесса, например [Security Development Lifecycle](https://www.microsoft.com/sdl/) (SDL) обычно требует от разработчиков, обозначающих границы доверия, которые существуют в своих приложениях. Границы доверия существует в местах, где приложение может взаимодействовать с данными, предоставляемые context надежный, такие как другой процесс в системе или процесс обычных пользовательского режима в случае драйвера устройства режима ядра. Новый класс уязвимостей, связанных с упреждающим исполнением каналов на стороне подходит для многих границы доверия в существующие модели безопасности программного обеспечения, изолировать код и данные на устройстве.

Следующая таблица предоставляет сводку моделей безопасности программного обеспечения, где разработчикам может потребоваться ли мои опасения возникновения уязвимости:

|Граница доверия|Описание|
|----------------|----------------|
|Граница виртуальной машины|Приложения, которые изоляции рабочих нагрузок на отдельных виртуальных машинах, которые получают непроверенных данных из другой виртуальной машины может находиться в опасности.|
|Ядра границ|Драйвер устройства режима ядра, который получает непроверенных данных из процесса режим пользователь без прав администратора могут подвергаться опасности.|
|Границу процесса|Приложения, которое получает непроверенных данных из другой процесс, работающий в локальной системе, такие как посредством удаленного вызова процедур (RPC), общая память или другие межпроцессное взаимодействие Межпроцессного механизмы могут подвергаться опасности.|
|Анклава границ|Приложение, которое выполняется в безопасным анклавом (например, Intel SGX), принимающий непроверенных данных, из за пределами анклава может находиться в опасности.|
|Границу языка|Приложения, который интерпретирует или эту задачу выполняет JIT компилирует и выполняет ненадежного кода на языке высокоуровневый язык программирования могут подвергаться опасности.|

Приложения, в которых площадь уязвимости к любому из перечисленных выше доверия границ необходимо просмотреть код на область, уязвимую для выявления и устранения возможных экземпляров уязвимостях упреждающего исполнения на стороне каналам. Следует отметить, что границы доверия, подвержен областей удаленных атак, таких как удаленный сетевые протоколы, не была продемонстрирована подвергнуть риску в уязвимостях упреждающего исполнения на стороне каналам.

## <a name="potentially-vulnerable-coding-patterns"></a>Потенциально уязвимые шаблоны кодирования

Уязвимостях упреждающего исполнения на стороне каналам могут возникнуть в результате нескольких шаблоны кодирования. В этом разделе описаны потенциально уязвимого кода шаблоны и примеры для каждого, но он должен распознаваться, могут существовать варианты на эти темы. Таким образом разработчикам рекомендуется использовать эти шаблоны в качестве примеров, а не исчерпывающий список всех потенциально уязвимые шаблоны кодирования. Те же классы уязвимостей безопасности памяти, которые могут существовать в программном обеспечении, сегодня также могут существовать вместе упреждающее и неупорядоченного путей выполнения, включая, но не ограничиваясь к переполнению буфера, выходящие за пределы области массива доступ, использование неинициализированной памяти типа путаницы и т. д. Те же примитивы, которые могут использовать злоумышленники уязвимостями безопасности памяти по путям архитектуры могут также применяться к наблюдающей пути.

Как правило связанные с условного ветвлений стороне упреждающего исполнения каналы могут возникнуть при условное выражение работает с данными, можно контролировать или зависят от контекста, надежный. Например, это могут быть условного выражения, используемые в `if`, `for`, `while`, `switch`, или тернарные условные операторы. Для каждого из этих инструкций компилятор может создать Условная ветвь, ЦП будет может спрогнозировать конечный адрес ветвления для во время выполнения.

Для каждого примера комментарий с фразой «СТАВИТ БАРЬЕР» вставляется, где разработчик может привести к барьер для устранения проблем совместимости. Этот вопрос рассматривается более подробно в разделе на способы их устранения.

## <a name="speculative-out-of-bounds-load"></a>Арифметику наблюдающая загрузка

Шаблоны кода эта категория включает в себя условного ветвлений, которое приводит к наблюдающей, выходящие за пределы области доступа к памяти.

### <a name="array-out-of-bounds-load-feeding-a-load"></a>Загрузка выхода за границы массива вырастить нагрузки

Этот способ кодировки — изначально описано уязвимым шаблон кодирования для CVE-2017-5753 (обход проверки границ). В фоновом режиме части в этой статье объясняется, этот шаблон подробно.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        // SPECULATION BARRIER
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

Аналогичным образом массив арифметику нагрузка может возникнуть в сочетании с цикл, который превышает его завершение условие из-за ошибочного прогнозирования. В этом примере условное ветвление связанные с `x < buffer_size` выражение может неверное предсказание и гипотетически выполнения основной части `for` результату цикла `x` больше или равно `buffer_size`, таким образом в наблюдающей результате Загрузите, выходящие за пределы области.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadBytes(unsigned char *buffer, unsigned int buffer_size) {
    for (unsigned int x = 0; x < buffer_size; x++) {
        // SPECULATION BARRIER
        unsigned char value = buffer[x];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="array-out-of-bounds-load-feeding-an-indirect-branch"></a>Загрузить вне границ массива вырастить косвенных ветвь

Этот способ кодировки входит случай, где условного ветвлений может привести к выходящие за пределы области доступа на массив указателей на функции, что затем приведет к увеличению косвенных перехода целевой адрес, выходящие за пределы области чтения. В следующем фрагменте приведен пример, где демонстрируется такое.

В этом примере идентификатор недоверенных сообщение передается DispatchMessage через `untrusted_message_id` параметра. Если `untrusted_message_id` — меньше, чем `MAX_MESSAGE_ID`, то он используется для индексации в массив указателей на функции и ветвление на соответствующий конечный адрес ветвления. Этот код безопасен с точки зрения архитектуры, но если ЦП неверно предсказанных Условная ветвь, это может привести `DispatchTable` индексирования с `untrusted_message_id` при его значение больше или равно `MAX_MESSAGE_ID`, таким образом, что приведет к выходящие за пределы области доступа. В итоге упреждающего исполнения с адреса целевой ветви, который является производным за границы массива, что может привести к раскрытию информации, в зависимости от того, что гипотетически выполняемый код.

```cpp
#define MAX_MESSAGE_ID 16

typedef void (*MESSAGE_ROUTINE)(unsigned char *buffer, unsigned int buffer_size);

const MESSAGE_ROUTINE DispatchTable[MAX_MESSAGE_ID];

void DispatchMessage(unsigned int untrusted_message_id, unsigned char *buffer, unsigned int buffer_size) {
    if (untrusted_message_id < MAX_MESSAGE_ID) {
        // SPECULATION BARRIER
        DispatchTable[untrusted_message_id](buffer, buffer_size);
    }
}
```

Как в случае выхода за границы массива загрузить вырастить другой нагрузки, это условие может возникнуть в сочетании с цикл, который превышает его завершающий условие, из-за ошибочного прогнозирования.

### <a name="array-out-of-bounds-store-feeding-an-indirect-branch"></a>Вне границ массива хранения вырастить косвенных ветвь

Хотя в предыдущем примере показан как упреждающее арифметику нагрузки может влиять на целевой объект косвенных ветви, возможна также для хранения вне границ для изменения целевого объекта косвенных ветви, такие как указатель на функцию или обратному адресу. Потенциально это может привести к упреждающего исполнения на основе адреса указан злоумышленник.

В этом примере передается недоверенных индекса `untrusted_index` параметра. Если `untrusted_index` меньше, чем число элементов `pointers` массива (256 элементов), то значение заданного указателя в `ptr` записывается `pointers` массива. Этот код безопасен с точки зрения архитектуры, но если ЦП неверно предсказанных Условная ветвь, это может привести `ptr` гипотетически записываемых за пределы выделенной в стеке `pointers` массива. Это может привести к повреждению наблюдающей обратный адрес для `WriteSlot`. Если злоумышленник может управлять значение `ptr`, они могут быть может вызвать упреждающего исполнения из произвольный решить, когда `WriteSlot` возвращает наблюдающей пути.

```cpp
unsigned char WriteSlot(unsigned int untrusted_index, void *ptr) {
    void *pointers[256];
    if (untrusted_index < 256) {
        // SPECULATION BARRIER
        pointers[untrusted_index] = ptr;
    }
}
```

Аналогично Если функция указатель локальную переменную с именем `func` были выделены в стеке, его будет невозможно гипотетически изменить адрес, `func` ссылается на при возникновении условного ветвлений. В итоге упреждающего исполнения на основе адреса произвольной при вызове через указатель функции.

```cpp
unsigned char WriteSlot(unsigned int untrusted_index, void *ptr) {
    void *pointers[256];
    void (*func)() = &callback;
    if (untrusted_index < 256) {
        // SPECULATION BARRIER
        pointers[untrusted_index] = ptr;
    }
    func();
}
```

Следует отметить, что в обоих этих примерах включает упреждающее изменения указателей выделенной в стеке косвенных ветви. Вполне возможно, что гипотетически изменения также может возникнуть по глобальные переменные, динамической памяти и даже память только для чтения на некоторых процессорах. Память, выделенной в стеке, Microsoft C++ компилятора уже выполняет действия, чтобы сделать его более доработке гипотетически выделенной в стеке косвенных ветви целевые объекты, такие как путем реорганизации локальных переменных, таким образом, что буферы помещаются рядом безопасности файл cookie как часть [/GS](https://docs.microsoft.com/cpp/build/reference/gs-buffer-security-check) функции безопасности компилятора.

## <a name="speculative-type-confusion"></a>Путаницы упреждающего типа

Эта категория имеет дело с моделью программирования, которые могут привести к появлению путаницы упреждающего типа. Это происходит при доступе к памяти с помощью неверного типа не архитектуры пути во время упреждающего исполнения. Условного ветвлений и обхода Интеллектуальное хранилище может привести к путанице упреждающего типа.

Для обхода Интеллектуальное хранилище это может произойти в сценариях, где компилятор повторно использует расположение стека для переменные разных типов. Это обусловлено архитектуры хранилища из переменной типа `A` могут быть обойдены, таким образом, нагрузку на тип `A` гипотетически выполнение перед переменной присваивается. Если ранее сохраненные переменной другого типа, это может создать условия для путаницы упреждающего типа.

В следующем фрагменте кода для условного ветвлений, будет использоваться для описания различных условий, которые могут дать путаницы упреждающего типа информаций.

```cpp
enum TypeName {
    Type1,
    Type2
};

class CBaseType {
public:
    CBaseType(TypeName type) : type(type) {}
    TypeName type;
};

class CType1 : public CBaseType {
public:
    CType1() : CBaseType(Type1) {}
    char field1[256];
    unsigned char field2;
};

class CType2 : public CBaseType {
public:
    CType2() : CBaseType(Type2) {}
    void (*dispatch_routine)();
    unsigned char field2;
};

// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ProcessType(CBaseType *obj)
{
    if (obj->type == Type1) {
        // SPECULATION BARRIER
        CType1 *obj1 = static_cast<CType1 *>(obj);

        unsigned char value = obj1->field2;

        return shared_buffer[value * 4096];
    }
    else if (obj->type == Type2) {
        // SPECULATION BARRIER
        CType2 *obj2 = static_cast<CType2 *>(obj);

        obj2->dispatch_routine();

        return obj2->field2;
    }
}
```

### <a name="speculative-type-confusion-leading-to-an-out-of-bounds-load"></a>Путаницы упреждающего типа, что приводит к выходящие за пределы области загрузки

Этот способ кодировки входит случай, где может привести к путанице упреждающего типа выходящие за пределы области или доступ к полям путать тип, где загруженное значение веб-каналов адрес для последующих подсистемы. Это похоже на шаблон выходящие за пределы области кодирования массива, но он подтверждается через альтернативы кодирования последовательности, как показано выше. В этом примере контекст осуществляющих атаки может привести к жертвы контекста для выполнения `ProcessType` несколько раз с объектом типа `CType1` (`type` поле равно `Type1`). Это окажет привыкают Условная ветвь для первого `if` инструкции для прогнозирования не выбирается. Контекст, осуществляющих атаки можно привести жертвы контекста для выполнения `ProcessType` с объектом типа `CType2`. Это может привести путаницы упреждающего типа, если условное ветвление для первого `if` инструкция неверно предсказанных и выполняет тело `if` инструкцию, таким образом, приведение объекта типа `CType2` для `CType1`. Так как `CType2` меньше, чем `CType1`, доступ к памяти для `CType1::field2` приводят наблюдающей арифметику загрузит данных, которые могут быть секрета. Это значение используется загрузкой из `shared_buffer` которого можно создать наблюдаемую побочные эффекты, как и в случае с массивом арифметику примере описанные ранее.

### <a name="speculative-type-confusion-leading-to-an-indirect-branch"></a>Путаницы упреждающего типа, что приводит к косвенных ветвь

Этот способ кодировки входит случай, где путаницы упреждающего типа может привести к ветвь небезопасный косвенных во время упреждающего исполнения. В этом примере контекст осуществляющих атаки может привести к жертвы контекста для выполнения `ProcessType` несколько раз с объектом типа `CType2` (`type` поле равно `Type2`). Это окажет привыкают Условная ветвь для первого `if` инструкции, которые должны выполняться и `else if` инструкции, которые не должны выполняться. Контекст, осуществляющих атаки можно привести жертвы контекста для выполнения `ProcessType` с объектом типа `CType1`. Это может привести путаницы упреждающего типа, если условное ветвление для первого `if` прогнозирует инструкции выполнены и `else if` инструкции прогнозирует не выбирается, выполняя тело `else if` и приведение объекта типа `CType1` для `CType2`. Так как `CType2::dispatch_routine` поле перекрывается с `char` массива `CType1::field1`, в результате наблюдающей косвенных ветвь для целевого объекта непредвиденные ветви. Если контекст осуществляющих атаки можно контролировать байтовых значений в `CType1::field1` массива, они могут иметь возможность управлять конечный адрес ветвления.

## <a name="speculative-uninitialized-use"></a>Интеллектуальное использование неинициализированной

Эта категория шаблонов кодирования включает в себя сценарии, где упреждающего исполнения может получить доступ к неинициализированной памяти и использовать его для веб-канала последующих нагрузки или косвенных ветви. Эти шаблоны кодирования для злоумышленник сможет злоумышленник необходимо иметь возможность управления или значимо влияют на содержимое памяти, который используется без инициализируемого по контексту, он используется.

### <a name="speculative-uninitialized-use-leading-to-an-out-of-bounds-load"></a>Упреждающее неинициализированный использования, что приводит к выходящие за пределы области загрузки

Интеллектуальное использование неинициализированной потенциально может привести к выходящие за пределы области загрузки с помощью значение злоумышленник. В примере ниже значение `index` назначается `trusted_index` на всех путях архитектуры и `trusted_index` предполагается, что меньше или равно `buffer_size`. Тем не менее, в зависимости от кода, созданные компилятором, возможна обход Интеллектуальное хранилище может произойти в том, позволяет нагрузку из `buffer[index]` и зависимые выражения для выполнения заранее назначения `index`. В этом случае неинициализированное значение для `index` будет использоваться как смещение в `buffer` которого может позволить злоумышленнику читать арифметику конфиденциальной информации и передают это через канал на стороне через зависимой загрузки из `shared_buffer` .

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

void InitializeIndex(unsigned int trusted_index, unsigned int *index) {
    *index = trusted_index;
}

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int trusted_index) {
    unsigned int index;

    InitializeIndex(trusted_index, &index); // not inlined

    // SPECULATION BARRIER
    unsigned char value = buffer[index];
    return shared_buffer[value * 4096];
}
```

### <a name="speculative-uninitialized-use-leading-to-an-indirect-branch"></a>Упреждающее неинициализированный использования, что приводит к ветвь косвенных

Интеллектуальное использование неинициализированной потенциально может привести к ветвь косвенных где конечный адрес ветвления контролируется с помощью которых злоумышленники. В следующем примере `routine` назначается либо `DefaultMessageRoutine1` или `DefaultMessageRoutine` зависимости от значения `mode`. В архитектуре пути, в результате `routine` всегда выполняется инициализация впереди косвенных ветви. Тем не менее, в зависимости от кода, созданные компилятором, обход Интеллектуальное хранилище может возникнуть, позволяющий косвенных ветви через `routine` гипотетически выполняемый впереди назначения `routine`. В этом случае злоумышленник может быть возможность гипотетически выполнения на основе адреса произвольной при условии, что злоумышленник может повлиять на или управления инициализированным значением `routine`.

```cpp
#define MAX_MESSAGE_ID 16

typedef void (*MESSAGE_ROUTINE)(unsigned char *buffer, unsigned int buffer_size);

const MESSAGE_ROUTINE DispatchTable[MAX_MESSAGE_ID];
extern unsigned int mode;

void InitializeRoutine(MESSAGE_ROUTINE *routine) {
    if (mode == 1) {
        *routine = &DefaultMessageRoutine1;
    }
    else {
        *routine = &DefaultMessageRoutine;
    }
}

void DispatchMessage(unsigned int untrusted_message_id, unsigned char *buffer, unsigned int buffer_size) {
    MESSAGE_ROUTINE routine;

    InitializeRoutine(&routine); // not inlined

    // SPECULATION BARRIER
    routine(buffer, buffer_size);
}
```

## <a name="mitigation-options"></a>Вариантов устранения этой проблемы

Уязвимостях упреждающего исполнения на стороне каналам можно устранить путем внесения изменений в исходный код. Эти изменения могут включать Устранение конкретные экземпляры уязвимости, например, путем добавления *ставит барьер*, или внесения изменений в структуре приложения, чтобы сделать конфиденциальной информации, недоступной для, наблюдающей выполнение.

### <a name="speculation-barrier-via-manual-instrumentation"></a>Ставит барьер через инструментирование вручную

Объект *ставит барьер* можно вручную вставить разработчиком во избежание упреждающего исполнения останавливающие вдоль пути, отличных от архитектуры. Например, разработчик можно вставить ставит барьер перед шаблона написания кода в теле условного блока, либо в начале блока (после Условная ветвь) или до первой загрузки, который является важным. Это предотвратит условного ветвлений выполнения кода, опасно по пути, отличных от архитектуры путем выполнения сериализации. Последовательность барьера предположение отличается архитектурой оборудования, как описано в следующей таблице:

|Архитектура|Ставит барьер на внутренние для CVE-2017-5753|Ставит барьер на внутренние для CVE-2018-3639|
|----------------|----------------|----------------|
|x86/x64|_mm_lfence()|_mm_lfence()|
|ARM|в настоящее время недоступно|__dsb(0)|
|ARM64|в настоящее время недоступно|__dsb(0)|

Например, следующий шаблон кода можно избежать, используя `_mm_lfence` встроенные, как показано ниже.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        _mm_lfence();
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="speculation-barrier-via-compiler-time-instrumentation"></a>Ставит барьер с помощью компилятора времени инструментирования

Microsoft C++ компилятора в Visual Studio 2017 (начиная с версии 15.5.5) включает поддержку `/Qspectre` переключатель, который автоматически вставляет ставит барьер для ограниченного набора потенциально уязвимые шаблоны кодирования связанные с CVE-2017-5753. В документации по [/qspectre](https://docs.microsoft.com/cpp/build/reference/qspectre) флаг более подробные сведения о его эффекты и использования. Важно отметить, что этот флаг не распространяется на все потенциально уязвимые шаблонов кодирования и таким образом разработчикам не следует полагаться на его как комплексное решение для этого класс уязвимостей.

### <a name="masking-array-indices"></a>Маскирование индексы массива

В случаях, где наблюдающей выходящие за пределы области загрузки может возникать, индекс массива можно строго заключаться по архитектуре и не архитектуры пути, добавив логику явно связать индекс массива. Например если массив можно выделить до размера, который выравнивается по степени 2, затем простой Маска может быть вызвана. Это показано в приведенном ниже примере, где предполагается, что `buffer_size` выравнивается по степени числа два. Это гарантирует, что `untrusted_index` — всегда меньше, чем `buffer_size`, даже если происходит условного ветвлений и `untrusted_index` передается с значение больше или равно `buffer_size`.

Следует отметить, что индекс маски, выполнить здесь могут подвергаться различным угрозам обход Интеллектуальное хранилище в зависимости от того, код, созданный компилятором.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        untrusted_index &= (buffer_size - 1);
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="removing-sensitive-information-from-memory"></a>Удаление конфиденциальной информации из памяти

Другой метод, который может использоваться для устранения уязвимостей упреждающего исполнения на стороне заключается в удалении конфиденциальной информации из памяти. Разработчики программного обеспечения можно найти возможности рефакторинга свои приложения так, чтобы конфиденциальные сведения не доступны во время упреждающего исполнения. Это можно сделать путем оптимизации разработки приложения, чтобы изолировать конфиденциальные данные в отдельные процессы. Например веб-приложения браузера, попытайтесь изолировать данные, связанные с каждый источник web между отдельными процессами, таким образом из-за один процесс не может получить доступ к данным независимо от источника через упреждающего исполнения.

## <a name="see-also"></a>См. также

[Рекомендации для снижения уязвимостях упреждающего исполнения по сторонним каналам](https://portal.msrc.microsoft.com/security-guidance/advisory/ADV180002)<br/>
[Сдерживание уязвимостях упреждающего исполнения на стороне каналам оборудования](https://blogs.technet.microsoft.com/srd/2018/03/15/mitigating-speculative-execution-side-channel-hardware-vulnerabilities/)
