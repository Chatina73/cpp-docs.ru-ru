---
description: Дополнительные сведения см. в руководстве разработчика C++ для параллельных каналов выполнения
title: Руководство разработчика C++ для выполнения гипотетических каналов исполнения
ms.date: 07/10/2018
helpviewer_keywords:
- Visual C++, security
- security [C++]
- security [C++], best practices
- Spectre
- CVE-2017-5753
- Speculative Execution
ms.openlocfilehash: 41376f02c04a9baf83fec19791d77c169c73fa31
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97320083"
---
# <a name="c-developer-guidance-for-speculative-execution-side-channels"></a>Руководство разработчика C++ для выполнения гипотетических каналов исполнения

В этой статье содержатся рекомендации для разработчиков по выявлению и устранению уязвимостей оборудования, влияющих на побочный канал выполнения, в программном обеспечении C++. Эти уязвимости могут раскрыть конфиденциальную информацию через границы доверия и могут повлиять на программное обеспечение, выполняемое на процессорах, которые поддерживают упреждающее, неупорядоченное выполнение инструкций. Этот класс уязвимостей был впервые описан в январе 2018, а дополнительные сведения о них можно найти в [статье рекомендации по безопасности корпорации Майкрософт](https://portal.msrc.microsoft.com/security-guidance/advisory/ADV180002).

Рекомендации, предоставляемые этой статьей, относятся к классам уязвимостей, представленных в:

1. CVE-2017-5753, также известный как устранением рисков Spectre вариант 1. Этот класс уязвимости оборудования связан с побочными каналами, которые могут возникать из-за прогнозируемого выполнения, возникающего в результате условного предсказания ветви. Компилятор Microsoft C++ в Visual Studio 2017 (начиная с версии 15.5.5) включает поддержку `/Qspectre` параметра, который обеспечивает устранение рисков во время компиляции для ограниченного набора потенциально уязвимых шаблонов программирования, связанных с CVE-2017-5753. `/Qspectre`Параметр также доступен в Visual Studio 2015 с обновлением 3 до [KB 4338871](https://support.microsoft.com/help/4338871). В документации по [`/Qspectre`](../build/reference/qspectre.md) флагу содержатся дополнительные сведения о его влиянии и использовании.

2. CVE-2018-3639, также называемый [обходом гипотетических магазинов (SSB)](https://aka.ms/sescsrdssb). Этот класс уязвимости оборудования связан с побочными каналами, которые могут возникать из-за упреждающего выполнения загрузки в зависимости от того, что в результате неверного предсказания доступа к памяти.

Доступное введение в уязвимые места на стороне параллельного канала выполнения можно найти в презентации с названием [устранением рисков Spectre и Meltdown](https://www.youtube.com/watch?v=_4O0zMW-Zu4) одной из исследовательских команд, которые обнаружили эти проблемы.

## <a name="what-are-speculative-execution-side-channel-hardware-vulnerabilities"></a>Что представляют собой уязвимости аппаратного канала выполнения на стороне?

Современные процессоры обеспечивают более высокий уровень производительности благодаря использованию гипотетических и неупорядоченных инструкций. Например, это часто достигается за счет прогнозирования целевого объекта ветвей (условного и косвенного), который позволяет ЦП приступить к выполнению инструкций на целевом объекте прогнозируемой ветви, что позволит избежать задержки до тех пор, пока не будет разрешен фактический целевой объект Branch. В случае, если в результате ЦП будет обнаружено неверное предсказание, все вычислительное состояние компьютера, которое было вычислено, будет отклонено. Это гарантирует отсутствие в архитектуре видимых результатов неверно предсказанного гипотетических.

В то время как гипотетическое выполнение не влияет на состояние, видимое в архитектуре, оно может оставлять остаточные трассировки в неархитектурном состоянии, например в различных кэшах, используемых ЦП. Это остаточная трассировка упреждающего выполнения, которая может привести к уязвимостям на стороне канала. Чтобы лучше понять это, рассмотрим следующий фрагмент кода, который предоставляет пример CVE-2017-5753 (обход проверки границ):

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

В этом примере `ReadByte` предоставляется буфер, размер буфера и индекс в этом буфере. Параметр индекса, как указано `untrusted_index` , предоставляется менее привилегированным контекстом, таким как неадминистративный процесс. Если `untrusted_index` меньше `buffer_size` , то символ в этом индексе считывается `buffer` и используется для индексирования в общей области памяти, на которую ссылается `shared_buffer` .

С точки зрения архитектуры эта последовательность кода вполне надежна, так как гарантируется, что `untrusted_index` всегда будет меньше `buffer_size` . Однако при наличии гипотетического выполнения возможно, что ЦП выполнит неверное предсказание условной ветви и выполнит тело инструкции If, даже если `untrusted_index` значение параметра больше или равно `buffer_size` . Как следствие этого, ЦП может считать байт из диапазона `buffer` (который может быть секретом), а затем использовать это значение для расчета адреса последующей загрузки `shared_buffer` .

Хотя ЦП в конечном итоге обнаружит это неверное предсказание, в кэше ЦП могут быть оставлены остаточные побочные эффекты, которые выпускают сведения о байтовом значении, которое было считано из диапазона `buffer` . Эти побочные эффекты можно обнаружить с помощью менее привилегированного контекста, выполняющегося в системе, выполняя проверку того, как быстро `shared_buffer` осуществляется доступ к каждой строке кэша. Для этого можно выполнить следующие действия.

1. **Вызов `ReadByte` выполняется несколько раз с `untrusted_index` меньшим `buffer_size` , чем**. Контекст атаки может привести к вызову контекста жертвы `ReadByte` (например, через RPC), так что прогнозирование ветвей считается невыполненным, так как `untrusted_index` это меньше `buffer_size` .

2. **Очистить все строки кэша в `shared_buffer`**. Контекст атаки должен очистить все строки кэша в общей области памяти, на которую ссылается `shared_buffer` . Так как область памяти является общей, она проста и может быть выполнена с помощью встроенных функций, таких как `_mm_clflush` .

3. **Вызов `ReadByte` с `untrusted_index` больше чем `buffer_size`**. Контекст атаки заставляет контекст жертвы вызывать `ReadByte` таким образом, что он неправильно прогнозирует, что ветвь не будет создана. Это приводит к тому, что процессор будет выполнять принудительное выполнение тела блока If с большим числом `untrusted_index` `buffer_size` , что приведет к выходу за пределы границ `buffer` . Следовательно, `shared_buffer` индексируется с использованием потенциального секретного значения, которое было считано за пределы диапазона, что приводит к тому, что соответствующая строка кэша загружается ЦП.

4. **Ознакомьтесь со всеми строками кэша в `shared_buffer` , чтобы узнать, какая из них доступна наиболее быстро**. Контекст атаки может считывать каждую строку кэша в `shared_buffer` и определять строку кэша, которая загружается значительно быстрее других. Это строка кэша, которая, скорее всего, была создана на шаге 3. Так как в этом примере существует отношение 1:1 между значением Byte и строкой кэша, это позволяет злоумышленнику определить фактическое значение байта, которое было считано за пределами.

Приведенные выше действия содержат пример использования методики, называемой СБРОСом и перезагрузкой, в сочетании с использованием экземпляра CVE-2017-5753.

## <a name="what-software-scenarios-can-be-impacted"></a>Какие сценарии программного обеспечения могут быть затронуты?

Для разработки защищенного программного обеспечения с помощью процесса, такого как [жизненный цикл разработки безопасности](https://www.microsoft.com/sdl/) (SDL), обычно требуется, чтобы разработчики определяли границы доверия, существующие в их приложении. Границы доверия существуют в местах, где приложение может взаимодействовать с данными, предоставляемыми менее надежным контекстом, например с другим процессом в системе или в пользовательском режиме без прав администратора в случае драйвера устройства в режиме ядра. Новый класс уязвимостей, включающих в себя параллельные каналы выполнения, относится ко многим границам доверия в существующих моделях безопасности программного обеспечения, которые изолируют код и данные на устройстве.

В следующей таблице приведены сводные сведения о моделях безопасности программного обеспечения, которые могут потребоваться разработчикам при возникновении этих уязвимостей.

|Граница доверия|Описание|
|----------------|----------------|
|Граница виртуальной машины|Приложения, которые изолируют рабочие нагрузки на отдельных виртуальных машинах, которые получают ненадежные данные из другой виртуальной машины, могут быть под угрозой.|
|Граница ядра|Драйвер устройства режима ядра, принимающий ненадежные данные из процесса пользовательского режима без прав администратора, может быть под угрозой.|
|Граница процесса|Приложение, получающее ненадежные данные из другого процесса, работающего в локальной системе, например через удаленный вызов процедур (RPC), общую память или другие механизмы Inter-Processного взаимодействия (IPC), может быть под угрозой.|
|Граница анклава|Приложение, которое выполняется в защищенном анклава (например, Intel SGX), которое получает ненадежные данные из-за пределов анклава, может быть под угрозой.|
|Граница языка|Приложение, которое интерпретирует или JIT-компиляция и выполняет ненадежный код, написанный на языке более высокого уровня, может оказаться под угрозой.|

Приложения, у которых есть контактная зона, доступная для любого из приведенных выше границ доверия, должны проверить код на уязвимой стороне, чтобы вычислить и устранить возможные экземпляры уязвимостей, которые могут возникнуть на боковом канале выполнения. Следует отметить, что границы доверия, предоставляемые для областей удаленной атаки, такие как удаленные сетевые протоколы, не были продемонстрированы, так как они подвержены риску уязвимости на стороне параллельного канала выполнения.

## <a name="potentially-vulnerable-coding-patterns"></a>Потенциально уязвимые шаблоны кодирования

В качестве следствие нескольких шаблонов программирования могут возникать уязвимости, связанные с гипотетическым каналом выполнения. В этом разделе описаны потенциально уязвимые шаблоны кодирования, а также приведены примеры для каждого из них, но следует знать, что варианты в этих темах могут существовать. Поэтому разработчикам рекомендуется использовать эти шаблоны как примеры, а не как исчерпывающий список всех потенциально уязвимых шаблонов кодирования. Те же классы уязвимостей безопасности памяти, которые могут существовать в настоящее время в программном обеспечении, также могут существовать в соответствии с согласованными и неупорядоченными путями выполнения, в том числе с неограниченными переполнениями буфера, доступностью неинициализированных массивов, неинициализациным использованием памяти, путаницой типов и т. д. Те же самые примитивы, которые злоумышленники могут использовать для взлома уязвимостей в области безопасности и путей архитектуры, могут также применяться к гипотетическым путям.

В общем случае, если условное выражение работает с данными, которые могут контролироваться или зависеть от менее доверяемого контекста, могут возникать гипотетические каналы выполнения, связанные с непредсказуемыми условными ветвями. Например, это могут быть условные выражения, используемые **`if`** в **`for`** **`while`** инструкциях,,, **`switch`** или ternary. Для каждой из этих инструкций компилятор может создать условную ветвь, которую ЦП может прогнозировать для целевого объекта ветви во время выполнения.

Для каждого примера вставляется комментарий с фразой «барьер ГИПОТЕТИЧЕСКИх», где разработчик может привести барьер в качестве меры к снижению. Это подробно рассматривается в разделе, посвященном устранению рисков.

## <a name="speculative-out-of-bounds-load"></a>Гипотетическая нагрузка за пределами

Эта категория шаблонов кода включает в себя условное неверное предсказание ветви, которое приводит к последовательному доступу к памяти вне границ.

### <a name="array-out-of-bounds-load-feeding-a-load"></a>Загрузка массивов вне границ, подача нагрузки

Этот шаблон кода является первоначально описанным шаблоном уязвимого кода для CVE-2017-5753 (обход проверки границ). В разделе "фон" этой статьи подробно описывается этот шаблон.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        // SPECULATION BARRIER
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

Аналогично, Загрузка массива за пределы границ может происходить в сочетании с циклом, который превышает ее завершающее условие из-за неверного предсказания. В этом примере условная ветвь, связанная с `x < buffer_size` выражением, может быть неверно предсказана и предупреждающее выполнение тела **`for`** цикла, если `x` больше или равно, что приводит к последующей `buffer_size` нагрузке вне границ.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadBytes(unsigned char *buffer, unsigned int buffer_size) {
    for (unsigned int x = 0; x < buffer_size; x++) {
        // SPECULATION BARRIER
        unsigned char value = buffer[x];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="array-out-of-bounds-load-feeding-an-indirect-branch"></a>Нагрузка массива вне границ, подача косвенной ветви

Этот шаблон кода включает случай, когда условное предсказание ветви может привести к неограниченному доступу к массиву указателей функций, который затем приводит к косвенному переходу к целевому адресу, который был считан вне границ. В следующем фрагменте кода приведен пример, демонстрирующий это.

В этом примере для DispatchMessage с помощью параметра предоставляется идентификатор ненадежного сообщения `untrusted_message_id` . Если `untrusted_message_id` меньше, то `MAX_MESSAGE_ID` используется для индексации в массив указателей функций и ветвления к соответствующей цели ветви. Этот код является защищенным по архитектуре, но если ЦП неверно прогнозирует условную ветвь, она может `DispatchTable` индексироваться, `untrusted_message_id` когда ее значение больше или равно `MAX_MESSAGE_ID` , что приводит к выходу за пределы границ. Это может привести к гипотетическому выполнению с целевого адреса ветви, который является производным от границ массива, что может привести к раскрытию информации в зависимости от кода, выполняемого в режиме гипотетических.

```cpp
#define MAX_MESSAGE_ID 16

typedef void (*MESSAGE_ROUTINE)(unsigned char *buffer, unsigned int buffer_size);

const MESSAGE_ROUTINE DispatchTable[MAX_MESSAGE_ID];

void DispatchMessage(unsigned int untrusted_message_id, unsigned char *buffer, unsigned int buffer_size) {
    if (untrusted_message_id < MAX_MESSAGE_ID) {
        // SPECULATION BARRIER
        DispatchTable[untrusted_message_id](buffer, buffer_size);
    }
}
```

Как и в случае, когда нагрузка массива достигает другой нагрузки, это условие может также возникнуть вместе с циклом, который превышает его завершающее условие из-за неверного предсказания.

### <a name="array-out-of-bounds-store-feeding-an-indirect-branch"></a>Массив за пределами границ, подающее косвенную ветвь

Хотя в предыдущем примере показано, как перегруженная загрузка по истечению границы может повлиять на косвенный целевой объект ветвления, в хранилище вне границы можно также изменить косвенную цель ветви, например указатель функции или обратный адрес. Это потенциально может привести к гипотетическому выполнению с адреса, указанного злоумышленником.

В этом примере ненадежный индекс передается через `untrusted_index` параметр. Если `untrusted_index` меньше числа элементов `pointers` массива (256 элементов), то указанное значение указателя в `ptr` записывается в `pointers` массив. Этот код является защищенным по архитектуре, но если ЦП неверно прогнозирует условную ветвь, это может привести `ptr` к некорректному написанию за границами массива, выделенного в стеке `pointers` . Это может привести к гипотетическому повреждению возвращаемого адреса `WriteSlot` . Если злоумышленник может контролировать значение `ptr` , они могут вызвать гипотетическое выполнение из произвольного адреса, если он `WriteSlot` возвращает по гипотетическому пути.

```cpp
unsigned char WriteSlot(unsigned int untrusted_index, void *ptr) {
    void *pointers[256];
    if (untrusted_index < 256) {
        // SPECULATION BARRIER
        pointers[untrusted_index] = ptr;
    }
}
```

Аналогично, если локальная переменная указателя функции `func` , именуемая, была выделена в стеке, возможно, будет возможно изменить адрес, на который ссылается, когда происходит неверное `func` предсказание ветви. Это может привести к гипотетическому выполнению с произвольного адреса, когда указатель функции вызывается через.

```cpp
unsigned char WriteSlot(unsigned int untrusted_index, void *ptr) {
    void *pointers[256];
    void (*func)() = &callback;
    if (untrusted_index < 256) {
        // SPECULATION BARRIER
        pointers[untrusted_index] = ptr;
    }
    func();
}
```

Следует отметить, что оба этих примера подразумевают наблюдаемое изменение косвенных указателей ветвей, выделенных в стеке. Возможно, что для глобальных переменных, выделенной кучи памяти и даже памяти только для чтения на некоторых ЦП может возникнуть гипотетическая модификация. Для памяти, выделенной в стеке, компилятор Microsoft C++ уже выполняет шаги, чтобы сделать более сложным изменение целевых объектов косвенной ветви, выделенных стеком, таких как Переупорядочение локальных переменных, так как буферы помещаются в файл cookie безопасности в рамках [`/GS`](../build/reference/gs-buffer-security-check.md) функции безопасности компилятора.

## <a name="speculative-type-confusion"></a>Путаница с гипотетическым типом

Эта категория связана с шаблонами кода, которые могут привести к путанице в гипотетическом типе. Это происходит, когда доступ к памяти осуществляется с использованием неправильного типа в неархитектурном пути во время гипотетического выполнения. Неправильное предсказание условной ветви и обход в гипотетическом магазине потенциально могут привести к путанице типов.

Для обхода гипотетических хранилищ это может произойти в сценариях, где компилятор повторно использует расположение стека для переменных нескольких типов. Это связано с тем, что хранилище архитектуры переменной типа `A` может быть обходится, таким образом, чтобы загрузка типа `A` выполнялась перед присвоением переменной. Если ранее сохраненная переменная имеет другой тип, то это может создать условия для путаницы с гипотетическым типом.

Для неправильного прогнозирования условной ветви приведенный ниже фрагмент кода будет использоваться для описания различных условий, которые могут привести к подъему неограниченного типа.

```cpp
enum TypeName {
    Type1,
    Type2
};

class CBaseType {
public:
    CBaseType(TypeName type) : type(type) {}
    TypeName type;
};

class CType1 : public CBaseType {
public:
    CType1() : CBaseType(Type1) {}
    char field1[256];
    unsigned char field2;
};

class CType2 : public CBaseType {
public:
    CType2() : CBaseType(Type2) {}
    void (*dispatch_routine)();
    unsigned char field2;
};

// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ProcessType(CBaseType *obj)
{
    if (obj->type == Type1) {
        // SPECULATION BARRIER
        CType1 *obj1 = static_cast<CType1 *>(obj);

        unsigned char value = obj1->field2;

        return shared_buffer[value * 4096];
    }
    else if (obj->type == Type2) {
        // SPECULATION BARRIER
        CType2 *obj2 = static_cast<CType2 *>(obj);

        obj2->dispatch_routine();

        return obj2->field2;
    }
}
```

### <a name="speculative-type-confusion-leading-to-an-out-of-bounds-load"></a>Путаница с гипотетическым типом, ведущая к нагрузке вне границ

Этот шаблон кода включает случай, когда неправильное поведение может привести к выходу за пределы допустимого типа, когда загруженное значение отправляет последующий адрес. Это похоже на шаблон кода, выходящий за пределы границ массива, но он является манифестом с помощью альтернативной последовательности кодирования, как показано выше. В этом примере контекст атаки может привести к тому, что контекст жертвы будет выполняться `ProcessType` несколько раз с объектом типа `CType1` ( `type` поле равно `Type1` ). Это приведет к обучению условной ветви для первого оператора, чтобы предсказать, что оно **`if`** не принято. Контекст атаки может привести к выполнению контекста жертвы `ProcessType` с объектом типа `CType2` . Это может привести к путанице в типе, если условная ветвь первой инструкции неверно **`if`** прогнозирует и выполняет тело **`if`** инструкции, тем самым приведение объекта типа `CType2` к `CType1` . Так как `CType2` размер меньше `CType1` , доступ к памяти будет приводить к `CType1::field2` появлению гипотетической нагрузки на неограниченную нагрузку данных, которые могут быть секретными. Это значение затем используется в нагрузке, из `shared_buffer` которой можно создавать наблюдаемые побочные эффекты, как в примере, приведенном выше.

### <a name="speculative-type-confusion-leading-to-an-indirect-branch"></a>Путаница с гипотетическым типом, ведущая к косвенной ветви

Этот шаблон кода включает случай, когда невозможность согласованного типа может привести к ненадежной непрямой ветви во время гипотетического выполнения. В этом примере контекст атаки может привести к тому, что контекст жертвы будет выполняться `ProcessType` несколько раз с объектом типа `CType2` ( `type` поле равно `Type2` ). Это приведет к поучению условной ветви для первого **`if`** выполняемого оператора, а `else if` инструкция не будет создана. Контекст атаки может привести к выполнению контекста жертвы `ProcessType` с объектом типа `CType1` . Это может привести к путанице в типе, если условная ветвь для первой **`if`** инструкции прогнозируется, а `else if` оператор прогнозируется не будет, таким образом, выполняя тело `else if` и приведя объект типа `CType1` к `CType2` . Поскольку `CType2::dispatch_routine` поле пересекается с **`char`** массивом `CType1::field1` , это может привести к появлению гипотетической косвенной ветви для непреднамеренного целевого объекта ветви. Если контекст атаки может управлять значениями байтов в `CType1::field1` массиве, они могут управлять адресом целевого расположения ветви.

## <a name="speculative-uninitialized-use"></a>Гипотетическое неинициализированное использование

Эта категория шаблонов кода включает сценарии, в которых гипотетическое выполнение может получить доступ к неинициализированной памяти и использовать ее для передачи последующей нагрузки или косвенной ветви. Чтобы эти шаблоны программирования могли использоваться злоумышленниками, злоумышленник должен иметь возможность контролировать содержимое памяти, используемое, без инициализации в контексте, в котором она используется.

### <a name="speculative-uninitialized-use-leading-to-an-out-of-bounds-load"></a>Гипотетическое неинициализированное использование, ведущая к нагрузке вне границ

Гипотетическое неинициализированное использование может привести к неограниченной нагрузке с помощью управляемого злоумышленником значения. В приведенном ниже примере значение `index` назначается `trusted_index` для всех путей архитектуры и считается `trusted_index` меньше или равно `buffer_size` . Однако в зависимости от кода, создаваемого компилятором, может возникнуть гипотетический обход хранилища, позволяющий загрузить `buffer[index]` и зависимые выражения выполнить перед назначением `index` . Если это происходит, в качестве смещения будет использоваться неинициализированное значение, `index` `buffer` которое может позволить злоумышленнику считывать конфиденциальную информацию за пределы границ и передавать их через канал по зависимым нагрузкам `shared_buffer` .

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

void InitializeIndex(unsigned int trusted_index, unsigned int *index) {
    *index = trusted_index;
}

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int trusted_index) {
    unsigned int index;

    InitializeIndex(trusted_index, &index); // not inlined

    // SPECULATION BARRIER
    unsigned char value = buffer[index];
    return shared_buffer[value * 4096];
}
```

### <a name="speculative-uninitialized-use-leading-to-an-indirect-branch"></a>Гипотетическое неинициализированное использование, ведущая к косвенной ветви

Гипотетическое неинициализированное использование может привести к непрямому разветвлению, где целевой объект ветви управляется злоумышленником. В приведенном ниже примере `routine` назначается либо в, либо в `DefaultMessageRoutine1` `DefaultMessageRoutine` зависимости от значения `mode` . В архитектурном пути это приведет к тому, `routine` что всегда будет инициализирована перед косвенной ветвью. Однако в зависимости от кода, создаваемого компилятором, может возникать гипотетический обход хранилища, позволяющий косвенно выполнить непрямое переход `routine` к `routine` . В этом случае злоумышленник может выполнить процедуру с произвольного адреса, предполагая, что злоумышленник может повлиять на неинициализированное значение или управлять им `routine` .

```cpp
#define MAX_MESSAGE_ID 16

typedef void (*MESSAGE_ROUTINE)(unsigned char *buffer, unsigned int buffer_size);

const MESSAGE_ROUTINE DispatchTable[MAX_MESSAGE_ID];
extern unsigned int mode;

void InitializeRoutine(MESSAGE_ROUTINE *routine) {
    if (mode == 1) {
        *routine = &DefaultMessageRoutine1;
    }
    else {
        *routine = &DefaultMessageRoutine;
    }
}

void DispatchMessage(unsigned int untrusted_message_id, unsigned char *buffer, unsigned int buffer_size) {
    MESSAGE_ROUTINE routine;

    InitializeRoutine(&routine); // not inlined

    // SPECULATION BARRIER
    routine(buffer, buffer_size);
}
```

## <a name="mitigation-options"></a>Варианты устранения ошибок

Устранение уязвимостей на стороне параллельного канала выполнения можно устранить, внеся изменения в исходный код. Эти изменения могут привести к устранению конкретных экземпляров уязвимости, например путем добавления *барьера гипотетических* случаев или внесения изменений в структуру приложения, чтобы сделать конфиденциальную информацию недоступной для гипотетического выполнения.

### <a name="speculation-barrier-via-manual-instrumentation"></a>Барьер гипотетических с помощью инструментирования вручную

*Барьер гипотетических* действий может быть вручную вставлен разработчиком, чтобы предотвратить выполнение гипотетического выполнения на неархитектурном пути. Например, разработчик может вставить барьер гипотетических элементов перед небезопасным шаблоном кодирования в теле условного блока, как в начале блока (после условной ветви), так и перед первой нагрузкой. Это предотвратит неверное предсказание ветви для выполнения опасного кода на неархитектурном пути путем сериализации выполнения. Последовательность барьера гипотетических вариантов отличается от архитектуры оборудования, как описано в следующей таблице.

|Архитектура|Встроенная функция барьера гипотетических для CVE-2017-5753|Встроенная функция барьера гипотетических для CVE-2018-3639|
|----------------|----------------|----------------|
|x86/x64|_mm_lfence ()|_mm_lfence ()|
|ARM|в настоящее время недоступно|__dsb (0)|
|ARM64|в настоящее время недоступно|__dsb (0)|

Например, следующий шаблон кода можно уменьшить с помощью `_mm_lfence` встроенной функции, как показано ниже.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        _mm_lfence();
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="speculation-barrier-via-compiler-time-instrumentation"></a>Барьер гипотетических средств через инструментирование времени компилятора

Компилятор Microsoft C++ в Visual Studio 2017 (начиная с версии 15.5.5) включает поддержку `/Qspectre` коммутатора, который автоматически вставляет барьер гипотетических вариантов для ограниченного набора потенциально уязвимых шаблонов программирования, связанных с CVE-2017-5753. В документации по [`/Qspectre`](../build/reference/qspectre.md) флагу содержатся дополнительные сведения о его влиянии и использовании. Важно отметить, что этот флаг не охватывает все потенциально уязвимые шаблоны кодирования, и так как такие разработчики не должны полагаться на него как исчерпывающий способ устранения уязвимости для этого класса уязвимостей.

### <a name="masking-array-indices"></a>Маскирование индексов массивов

В случаях, когда может произойти неограниченная Загрузка, индекс массива может быть строго ограничен как в архитектурном, так и в неархитектурном, путем добавления логики для явной привязки индекса массива. Например, если массив может быть выделен для размера, который соответствует степени двух, может быть введена простая маска. Это показано в примере ниже, где предполагается, что оно соответствует `buffer_size` степени двух. Это гарантирует, что `untrusted_index` всегда будет меньше `buffer_size` , даже если происходит неверное предсказание ветви и `untrusted_index` он передается со значением, большим или равным `buffer_size` .

Следует отметить, что в этом случае в зависимости от кода, создаваемого компилятором, может наблюдаться неконтролируемая операция обхода индекса.

```cpp
// A pointer to a shared memory region of size 1MB (256 * 4096)
unsigned char *shared_buffer;

unsigned char ReadByte(unsigned char *buffer, unsigned int buffer_size, unsigned int untrusted_index) {
    if (untrusted_index < buffer_size) {
        untrusted_index &= (buffer_size - 1);
        unsigned char value = buffer[untrusted_index];
        return shared_buffer[value * 4096];
    }
}
```

### <a name="removing-sensitive-information-from-memory"></a>Удаление конфиденциальной информации из памяти

Другой способ, который можно использовать для устранения уязвимостей на стороне параллельного канала выполнения, заключается в удалении конфиденциальной информации из памяти. Разработчики программного обеспечения могут искать возможные сделки по рефакторингу приложения таким, что конфиденциальная информация недоступна во время гипотетического выполнения. Это можно сделать путем рефакторинга проекта приложения, чтобы изолировать конфиденциальные данные в отдельных процессах. Например, приложение веб-браузера может попытаться изолировать данные, связанные с каждым источником веб-сайта, в отдельные процессы, таким образом запрещая одному процессу получать доступ к данным между источниками с помощью гипотетического выполнения.

## <a name="see-also"></a>См. также раздел

[Рекомендации по устранению уязвимостей на стороне сервера](https://portal.msrc.microsoft.com/security-guidance/advisory/ADV180002)<br/>
[Устранение уязвимостей аппаратного канала выполнения на стороне](https://blogs.technet.microsoft.com/srd/2018/03/15/mitigating-speculative-execution-side-channel-hardware-vulnerabilities/)
