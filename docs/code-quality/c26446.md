---
title: C26446
ms.date: 03/22/2018
ms.topic: reference
f1_keywords:
- C26446
helpviewer_keywords:
- C26446
ms.openlocfilehash: a822378a9782a1a6f0633a34762d0a54992d509d
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/17/2020
ms.locfileid: "79465670"
---
# <a name="c26446-use_gsl_at"></a>C26446 USE_GSL_AT

Предпочитаете использовать `gsl::at()` вместо непроверенного оператора подстрочных символов.

C++Основные рекомендации: [границы. 4. не используйте функции и типы стандартной библиотеки, которые не имеют установленных ограничений](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#probounds-bounds-safety-profile).

Профиль границ C++ основных правил пытается устранить незащищенные манипуляции с памятью, избегая использования необработанных указателей и непроверенных операций. Один из способов выполнить однородный доступ по диапазону к буферам — использовать служебную программу `gsl::at()` из библиотеки поддержки рекомендаций. Также рекомендуется использовать стандартные реализации `at()` доступных в контейнерах STL.

Это правило помогает находить места, где потенциально непроверенный доступ выполняется с помощью вызовов оператора\[] (). В большинстве случаев такие вызовы можно легко заменить на `gsl::at()`.

- Доступ к массивам с известным размером отмечается при использовании неконстантного индекса в операторе подстрочных индексов. Постоянные индексы обрабатываются [C26483 STATIC_INDEX_OUT_OF_RANGE](c26483.md).
- Логика предупреждения о перегруженных вызовах оператора [] более сложная:
  - Если индекс не является целочисленным, вызов игнорируется. Это также обрабатывает индексирование в стандартных картах, так как параметры в таких операторах передаются по ссылке.
  - Если оператор помечается как не создающий **исключение (с использованием**исключений, **Throw ()** или **__declspec (throw)** ), вызов помечается флагом. Предполагается, что если оператор подстрочного индекса никогда не создает исключения, он либо не выполняет проверку диапазона, либо эти проверки скрываются.
  - Если оператор не помечен как не создающий исключение, он может быть помечен, если он поступает из контейнера STL, который также определяет обычную `at()` функцию-член (такие функции обнаруживаются с помощью сопоставления с простым именем).
  - Правило не предупреждает о вызовах стандартных функций `at()`. Эти функции являются надежными и их замена на `gsl::at()` не приведет к значительному значению.
- Индексирование в `std::basic_string_view<>` является ненадежным, поэтому выдается предупреждение. Стандартное представление строки можно заменить на `gsl::basic_string_span<>`, которое всегда имеет значение Checked.
- Реализация не учитывает проверку диапазона, что пользовательский код может находиться где-либо в циклах или ветвях. Точность здесь является компромиссной для повышения производительности. В общем случае явные проверки диапазона часто могут быть заменены более надежными итераторами или более лаконичными усовершенствованными циклами for-loops.
