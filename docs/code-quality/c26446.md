---
title: C26446
ms.date: 03/22/2018
ms.topic: reference
f1_keywords:
- C26446
helpviewer_keywords:
- C26446
ms.openlocfilehash: eff94d61f6c792a6ad720a24b049a25d9d354f91
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87215079"
---
# <a name="c26446-use_gsl_at"></a>C26446 USE_GSL_AT

Предпочитать использовать `gsl::at()` вместо непроверенного оператора индекса.

C++ Core Guidelines: [Bounds. 4: не используйте функции и типы стандартной библиотеки, которые не имеют установленных ограничений](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#probounds-bounds-safety-profile).

Профиль границ C++ Core Guidelines пытается устранить незащищенные манипуляции с памятью, избегая использования необработанных указателей и непроверенных операций. Один из способов выполнить однородный доступ по диапазону для буферов заключается в использовании `gsl::at()` программы из библиотеки поддержки руководств. Также рекомендуется использовать стандартные реализации, `at()` Доступные в контейнерах STL.

Это правило помогает находить места, где потенциально непроверенный доступ выполняется через вызовы оператора \[ ] (). В большинстве случаев такие вызовы можно легко заменить на `gsl::at()` .

- Доступ к массивам с известным размером отмечается при использовании неконстантного индекса в операторе подстрочных индексов. Постоянные индексы обрабатываются [C26483 STATIC_INDEX_OUT_OF_RANGE](c26483.md).
- Логика предупреждения о перегруженных вызовах оператора [] более сложная:
  - Если индекс не является целочисленным, вызов игнорируется. Это также обрабатывает индексирование в стандартных картах, так как параметры в таких операторах передаются по ссылке.
  - Если оператор помечен как не создающий исключение (с помощью **`noexcept`** , **Throw ()** или **`__declspec(nothrow)`** ), вызов помечается. Предполагается, что если оператор подстрочного индекса никогда не создает исключения, он либо не выполняет проверку диапазона, либо эти проверки скрываются.
  - Если оператор не помечен как не создающий исключение, он может быть помечен, если он поступает из контейнера STL, который также определяет обычную `at()` функцию-член (такие функции обнаруживаются с помощью простого сопоставления имен).
  - Правило не предупреждает о вызовах стандартных `at()` функций. Эти функции являются надежными, и их замена на `gsl::at()` не приведет к значительному значению.
- Индексирование в не `std::basic_string_view<>` является надежным, поэтому выдается предупреждение. Стандартное представление строки можно заменить на `gsl::basic_string_span<>` , которое всегда имеет значение Checked.
- Реализация не учитывает проверку диапазона, что пользовательский код может находиться где-либо в циклах или ветвях. Точность здесь является компромиссной для повышения производительности. В общем случае явные проверки диапазона часто могут быть заменены более надежными итераторами или более лаконичными усовершенствованными циклами for-loops.
