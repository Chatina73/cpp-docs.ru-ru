---
title: C26429
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26429
helpviewer_keywords:
- C26429
ms.assetid: 4e1c74d5-7307-436c-927b-f74ae863282c
ms.openlocfilehash: 9645ceb5b1b80365c1fcc7f59655ba4fb649a196
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81359469"
---
# <a name="c26429-use_notnull"></a>C26429 USE_NOTNULL

"Символ никогда не проверяется на недействительность, он может быть помечен как gsl::not_null".

**Основные руководящие принципы:** F.23:\<Используйте not_null T> чтобы указать, что "null" не является допустимой ценностью

Это обычная практика для использования утверждений для обеспечения предположения о достоверности значений указателя. Проблема с утверждает заключается в том, что они не разоблачают предположения через интерфейс (например, в типах или параметрах возврата). Утверждения также труднее поддерживать и поддерживать в синхронизации с другими изменениями кода. Рекомендация заключается в использовании gsl::not_null из Библиотеки поддержки Руководящих принципов в качестве маркера ресурсов, которые никогда не должны иметь нулевую ценность. Правило USE_NOTNULL помогает определить места, которые опускают проверки на nullness и, следовательно, могут быть обновлены для использования gsl::not_null.

## <a name="remarks"></a>Remarks

- Логика правила требует, чтобы код отосвядел переменную указателя, чтобы проверка недействительности (или правоприменение ненулевой стоимости) была оправдана. Таким образом, предупреждение будет излучаться только в том случае, если указатели являются dereferenced и никогда не проверяется на nullness.
  - Текущая реализация обрабатывает только простые указатели (или их псевдонимы) и не обнаруживает умные указатели, даже если gsl::not_null может быть применен а также к интеллектуальным указателям.
  - Переменная помечается как проверенная на наличие нуля при использовании в следующих контекстах:
  - как выражение символа в состоянии ветви, например, "если (p) ...
  - не-bitwise логических операций;
  - сравнительные операции, где одна операнд является постоянным выражением, которое оценивается до нуля.
  - Правило не имеет полного отслеживания потока данных и может привести к неправильным результатам в случаях, когда используются косвенные проверки (например, когда промежуточная переменная имеет нулевую ценность и затем используется в сравнении).

## <a name="example"></a>Пример

скрытые ожидания

```cpp
using client_collection = gsl::span<client*>;
// ...
void keep_alive(const connection *connection)   // C26429
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];               // C26429
        client->send_heartbeat();
        // ...
    }
}
```

скрытые ожидания, - уточнил gsl::not_null

```cpp
using client_collection = gsl::span<gsl::not_null<client*>>;
// ...
void keep_alive(gsl::not_null<const connection*> connection)
{
    const client_collection clients = connection->get_clients();
    for (ptrdiff_t i = 0; i < clients.size(); i++)
    {
        auto client = clients[i];
        client->send_heartbeat();
        // ...
    }
}
```
