---
title: C26441
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26441
helpviewer_keywords:
- C26441
ms.assetid: f923c422-ed01-4644-b40b-93f15fc5bb93
ms.openlocfilehash: 0e6d609ee8b24f40aa06250515f5e60d088a2289
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81369884"
---
# <a name="c26441-no_unnamed_guards"></a>C26441 NO_UNNAMED_GUARDS

"Охранные объекты должны быть названы."

**Основные руководящие принципы**: CP.44: Не забудьте назвать свою lock_guards и unique_locks

Стандартная библиотека предоставляет несколько полезных классов, которые помогают контролировать параллельный доступ к ресурсам. Объекты таких типов блокируют эксклюзивный доступ на весь срок их службы. Это означает, что каждый объект блокировки должен быть назван, т.е. четко определен срок службы, который охватывает период, в котором выполняются операции доступа. Таким образом, неспособность назначить объект блокировки переменной является ошибкой, которая фактически отключает механизм блокировки (потому что временные переменные являются временными). Это правило пытается уловить простые случаи такого непреднамеренного поведения.

## <a name="remarks"></a>Remarks

- Отслеживаются только стандартные типы блокировки: std::scoped_lock, std::unique_lock и std::lock_quard.
  - Анализируются только простые вызовы конструкторам. Более сложное выражение инициализатора может привести к неточным результатам, но это довольно необычный сценарий.
  - Блокировки, передаваемые как аргументы для функции вызовов или возвращенные в результате вызовов функций, игнорируются.
  - Блокировки, созданные как временные, но назначенные названным ссылкам для продления срока их службы, игнорируются.

## <a name="example"></a>Пример

отсутствующая область переменной

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex>{ diagnostic_mutex_ }; // C26441
        write_line(stream, text);
        // ...
    }
}
```

отсутствует область применения переменной - исправлена

```cpp
void print_diagnostic(gsl::string_span<> text)
{
    auto stream = get_diagnostic_stream();
    if (stream)
    {
        std::lock_guard<std::mutex> lock{ diagnostic_mutex_ };
        write_line(stream, text);
        // ...
    }
}
```
