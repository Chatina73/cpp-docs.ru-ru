---
title: C26430
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
ms.openlocfilehash: 27ef1a69d5066adb6fdfaf1cbb737bbd3b2247eb
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/17/2020
ms.locfileid: "79466732"
---
# <a name="c26430-test_on_all_paths"></a>C26430 TEST_ON_ALL_PATHS

"Символ не проверяется на допустимость значений NULL для всех путей".

Основные рекомендации: F. 23: используйте NOT_NULL\<t >, чтобы указать, что "null" не является допустимым значением. **C++**

Если код всегда проверяет значения NULL для переменных-указателей, он должен выполнять это согласованно и проверять указатели на всех путях. Иногда чрезмерная проверка наличия значения NULL по-прежнему лучше, чем вероятность жесткого сбоя в одной из сложных ветвей. В идеале такой код должен быть оптимизирован, чтобы быть менее сложным (путем разделения на несколько функций) и полагаться на маркеры, такие как GSL:: not_null (см. библиотеку поддержки руководств), для изоляции частей алгоритма, которые могут обеспечить надежное предположение о допустимых значениях указателей. Правило TEST_ON_ALL_PATHS помогает находить места, в которых проверки значений NULL не согласованы (поэтому может потребоваться проверка), или фактические ошибки, при которых потенциальное значение NULL может обходить проверку значений NULL в некоторых путях кода.

## <a name="remarks"></a>Remarks

- Это правило предполагает, что код отменяет ссылку на переменную указателя, чтобы проверка значений NULL (или принудительное применение значения, отличного от NULL) была выровнена по ширине. Если разыменование отсутствует, правило приостанавливается.
  - Текущая реализация обрабатывает только простые указатели (или их псевдонимы) и не определяет смарт-указатели, даже если проверки значений NULL применимы и к смарт-указателям.
  - Переменная помечена как отмеченная для значения NULL, если она используется в следующих контекстах:
  - как выражение символа в условии ветвления, например "if (p) {...}";
  - не побитовые логические операции;
  - операции сравнения, в которых один операнд является константным выражением, результатом которого является нуль.
  - Правило не имеет полного отслеживания потока данных и может привести к неправильным результатам в случаях, когда используются косвенные проверки (например, когда промежуточная переменная содержит значение NULL и используется в дальнейшем для сравнения).
  - Неявные проверки значений NULL предполагаются, когда значение указателя присваивается из:
  - выделение, выполняемое с оператором new;
  - указатель, полученный из типа, помеченного с помощью GSL:: not_null.

## <a name="example"></a>Пример

Непоследовательное тестирование раскрывает логическую ошибку

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

Непоследовательное тестирование показывает ошибку логики — исправлено

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
