---
title: C26430
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
ms.openlocfilehash: 73f69b54d7f4635be6fb67099b2864ea3882eb24
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81316909"
---
# <a name="c26430-test_on_all_paths"></a>C26430 TEST_ON_ALL_PATHS

"Символ не проверяется на недействительность на всех путях."

**Основные руководящие принципы:** F.23:\<Используйте not_null T> чтобы указать, что "null" не является допустимой ценностью

Если код когда-либо проверяет недействительность переменных указателей, он должен делать это последовательно и проверять указатели на всех путях. Иногда чрезмерно агрессивная проверка на недоступность все еще лучше, чем вероятность жесткого сбоя в одной из сложных ветвей. В идеале такой код должен быть рефакторинговым, чтобы быть менее сложным (путем разделения на несколько функций) и полагаться на маркеры, такие как gsl::not_null (см. Библиотеку поддержки руководящих принципов), чтобы изолировать части алгоритма, которые могут сделать безопасное предположение о допустимых значениях указателя. Правило TEST_ON_ALL_PATHS помогает найти места, где проверки недействительности либо несовместимы (отсюда и предположения могут потребовать рассмотрения) или фактические ошибки, где потенциальное нулевая стоимость может обойти проверку nullness в некоторых путях кода.

## <a name="remarks"></a>Remarks

- Это правило предполагает, что код dereferences указатель переменной так, что проверка nullness (или исполнение ненулевой стоимости) будет оправдано. Если нет ссылки, правило приостанавливается.
  - Текущая реализация обрабатывает только простые указатели (или их псевдонимы) и не обнаруживает интеллектуальные указатели, даже если проверки nullness применимы и к интеллектуальным указателям.
  - Переменная помечается как проверенная на наличие нуля при использовании в следующих контекстах:
  - как выражение символа в состоянии ветви, например, "если (p) ...
  - не-bitwise логических операций;
  - сравнительные операции, где одна операнд является постоянным выражением, которое оценивается до нуля.
  - Правило не имеет полного отслеживания потока данных и может привести к неправильным результатам в случаях, когда используются косвенные проверки (например, когда промежуточная переменная имеет нулевую ценность и затем используется в сравнении).
  - Неявные проверки недействительности предполагается, когда значение указателя назначается из:
  - распределение выполнено с бросая оператором новым;
  - указатель, полученный из типа, отмеченного gsl::not_null.

## <a name="example"></a>Пример

несогласованное тестирование выявило логическую ошибку

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

несогласованное тестирование выявило логическую ошибку - исправлено

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
