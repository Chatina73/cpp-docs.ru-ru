---
title: C6262
description: Предупреждение анализа кода Visual Studio C++ C6262 описание и разрешение.
ms.date: 10/14/2020
ms.topic: reference
f1_keywords:
- C6262
helpviewer_keywords:
- C6262
ms.openlocfilehash: 8c7df48787652ffa5078166665a68ab0ed1957d8
ms.sourcegitcommit: 6e5429e076e552b32e8bdc49480c51498d7924c1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/15/2020
ms.locfileid: "92099697"
---
# <a name="c6262"></a>C6262

> предупреждение C6262: функция использует *constant_1* байт в стеке: превышает/Analyze: STACKSIZE *constant_2*. Рассмотрите возможность перемещения некоторых данных в кучу.

## <a name="remarks"></a>Комментарии

Это предупреждение означает, что использование стека, превышающее предопределенное пороговое значение (*constant_2*), было обнаружено в функции. Размер кадра стека по умолчанию для этого предупреждения составляет 16 КБ для пользовательского режима, 1 КБ для режима ядра. Stack — даже в пользовательском режиме — ограничено, и Сбой фиксации страницы стека вызывает исключение переполнения стека. Режим ядра имеет ограничение в 12 КБ размера стека, что не может быть увеличено. Старайтесь агрессивно ограничивать использование стека в коде режима ядра.

Чтобы устранить проблему, связанную с этим предупреждением, можно либо переместить данные в кучу, либо в другую динамическую память. В пользовательском режиме один большой кадр стека может не быть проблемой — и это предупреждение может быть подавлено, но большой кадр стека увеличивает риск переполнения стека. (Большой кадр стека может произойти, если функция использует стек сильно или является рекурсивной.) Общий размер стека в пользовательском режиме может быть увеличен, если переполнение стека действительно происходит, но только до ограничения системы.

Для кода режима ядра, например в проектах драйверов, значение *constant_2* устанавливается в 1 КБ. Хорошо написанные драйверы должны иметь несколько функций, которые могут подходить к этому значению, а изменение предела может быть желательным. Те же общие методы, которые используются для кода пользовательского режима для уменьшения размера стека, можно адаптировать в код режима ядра.

## <a name="adjust-the-stack-size-to-suppress-the-warning"></a>Настройка размера стека для подавления предупреждения

Можно использовать [`/analyze:stacksize`](../build/reference/analyze-code-analysis.md) параметр командной строки для изменения значения *constant_2*, но при увеличении он создает риск того, что ошибка может не быть сообщена.

### <a name="to-suppress-the-warning-on-the-command-line"></a>Отключение предупреждения в командной строке

- Добавьте *`/analyze:stacksize <new-size>`* параметр в командную строку компилятора. Используйте значение, превышающее *`<new-size>`* *constant_1*. Например, если *constant_1* имеет значение 27180, можно ввести *`/analyze:stacksize 32768`* .

### <a name="to-suppress-the-warning-in-the-ide"></a>Отключение предупреждения в интегрированной среде разработки

1. В интегрированной среде разработки Visual Studio выберите проект в окне **Обозреватель решений** .

1. В строке меню щелкните **Проект** > **Свойства**.

1. В диалоговом окне **страницы свойств** откройте страницу свойств **конфигурации**  >  **C/C++**  >  **Командная строка** .

1. В окне **Дополнительные параметры**добавьте *`/analyze:stacksize <new-size>`* , где больше *`<new-size>`* *constant_1*. Например, если *constant_1* имеет значение 27180, можно ввести *`/analyze:stacksize 32768`* . Выберите **ОК** для сохранения внесенных изменений.

## <a name="example"></a>Пример

В следующем коде создается это предупреждение `char buffer` , поскольку для стека требуется 16 382 байт, а для локальной целочисленной переменной `i` требуется еще 4 байта, что превышает предельный размер стека по умолчанию (16 КБ).

```cpp
// cl.exe /c /analyze /EHsc /W4
#include <windows.h>
#define MAX_SIZE 16382

void f( )
{
    int i;
    char buffer[MAX_SIZE];

    i = 0;
    buffer[0]='\0';

    // code...
}
```

Следующий код устраняет это предупреждение, перемещая некоторые данные в кучу.

```cpp
// cl.exe /c /analyze /EHsc /W4
#include <stdlib.h>
#include <malloc.h>
#define MAX_SIZE 16382

void f( )
{
    int i;
    char *buffer;

    i = 0;
    buffer = (char *) malloc( MAX_SIZE );
    if (buffer != NULL)
    {
        buffer[0] = '\0';
        // code...
        free(buffer);
    }
}
```

Использование `malloc` и `free` имеет много ловушек, таких как утечка памяти и исключения. Чтобы избежать такого рода утечек и проблем с исключениями, используйте механизмы, предоставляемые стандартной библиотекой C++ (STL). К ним относятся [`shared_ptr`](../standard-library/shared-ptr-class.md) , [`unique_ptr`](../standard-library/unique-ptr-class.md) и [`vector`](../standard-library/vector.md) . Дополнительные сведения см. в разделе [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md) и [Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md).

## <a name="see-also"></a>См. также раздел

[`/STACK` (Выделения стека)](../build/reference/stack-stack-allocations.md)\
[`_resetstkoflw`](../c-runtime-library/reference/resetstkoflw.md)\
[Практическое руководство. Проверки времени выполнения машинного кода](/visualstudio/debugger/how-to-use-native-run-time-checks)
