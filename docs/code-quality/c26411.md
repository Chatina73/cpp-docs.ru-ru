---
title: C26411
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
ms.openlocfilehash: a602a3b8c0545c64d23e60cab4987c4b7a9b4543
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/17/2020
ms.locfileid: "79465820"
---
# <a name="c26411--no_ref_to_unique_ptr"></a>C26411 NO_REF_TO_UNIQUE_PTR

Передача уникального указателя по ссылке предполагает, что его ресурс может быть освобожден или передан внутри целевой функции. Если функция использует его параметр только для доступа к ресурсу, можно передать необработанный указатель или ссылку.

## <a name="remarks"></a>Remarks

- Существуют также ограничения, связанные с предупреждением [C26410](C26410.md) .

- Эвристический подход к определению доступа "Release" или "Reset" к уникальному указателю является довольно наивным: мы обнаруживаем вызовы только для операторов присваивания и функций с именем "Reset" (без учета регистра). Очевидно, что это обнаружение не охватывает все возможные варианты изменения смарт-указателя (например, std:: Swap или любой специальной неконстантной функции в пользовательском смарт-указателе). Ожидается, что это предупреждение будет давать множество ложных срабатываний для пользовательских типов, а также в некоторых сценариях, связанных со стандартными уникальными указателями. Эвристика будет улучшена, так как мы реализуем дополнительные проверки, нацеленные на интеллектуальные указатели.

- Тот факт, что смарт-указатели часто являются шаблонами, предоставляет интересные ограничения, связанные с тем, что компилятор не требуется для обработки кода шаблона в шаблонах, если он не используется. В некоторых минимальных базах кода с ограниченным использованием интерфейсов интеллектуальных указателей средство проверки может привести к непредвиденным результатам из-за невозможности правильно определить семантику типа шаблона (поскольку некоторые важные функции могут не использоваться). Для стандартных `unique_pointer`это ограничение устраняется путем распознавания имени типа. Это может быть расширено в будущем для охвата более хорошо известных смарт-указателей.

- Лямбда-выражения с неявным захватом по ссылке могут привести к неожиданным предупреждениям о ссылках на уникальные указатели. В настоящее время возвращаются все заданные ссылочные параметры в лямбда-выражениях независимо от того, сброшены ли они. Эвристический подход будет расширен для сопоставления лямбда-полей с лямбда-параметрами в будущем выпуске.

## <a name="example-unnecessary-reference"></a>Пример: ненужная ссылка

```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```
