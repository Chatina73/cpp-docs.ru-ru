---
title: C26400
description: Описывает C26400 предупреждение анализа кода Microsoft C/C++, причины и способы его устранения.
ms.date: 10/23/2020
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.openlocfilehash: d8bc3f4605c0a0eb766e36049fec03be79372381
ms.sourcegitcommit: bf54b407169900bb668c85a67b31dbc0f069fe65
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/24/2020
ms.locfileid: "92497156"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Эта проверка позволяет применить *правило I. 11: никогда не передавать владение необработанным указателем (T \* )*, который является подмножеством правила *R. 3: необработанный указатель (a T \* ) не является владельцем*. В частности, он предупреждает о любом вызове метода `operator new` , который сохраняет результат в переменной необработанного типа указателя. Он также предупреждает о вызовах функций, которые возвращают, `gsl::owner<T>` если их результаты назначены необработанным указателям. Идея здесь заключается в том, что следует четко указать владение ресурсами памяти. Дополнительные сведения см. в [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Самый простой способ устранить это предупреждение — использовать **`auto`** объявление, если ресурс был непосредственно назначен в объявлении переменной. Если это исправление невозможно, мы рекомендуем использовать тип `gsl::owner<T>` . **`auto`** Объявления, инициализированные оператором **`new`** , являются "владельцыми", так как предполагается, что результат любого выделения неявно является указателем владельца. Мы переносите это допущение в **`auto`** переменную и рассматриваете его как `owner<T>` .

Если эта проверка помечает вызов функции, которая возвращает `owner<T>` , это может быть указанием допустимой ошибки в коде. По сути, он указывает на место, где код утечекет явное понятие владения (и, возможно, сам ресурс).

## <a name="remarks"></a>Remarks

Это правило в настоящее время проверяет только локальные переменные. Если назначить выделение формальному параметру, глобальную переменную, член класса и т. д., он не помечается. Соответствующее покрытие таких сценариев планируется для будущей работы.

## <a name="example-1-simple-allocation"></a>Пример 1. простое выделение

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Пример 2. простое выделение (с фиксированным `gsl::owner<T>` )

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK
```

## <a name="example-3-simple-allocation-fixed-with-auto"></a>Пример 3. простое выделение (с фиксированным `auto` )

```cpp
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
