---
title: C26407
ms.date: 07/21/2017
ms.topic: conceptual
f1_keywords:
- C26407
helpviewer_keywords:
- C26407
ms.assetid: 5539907a-bfa0-40db-82a6-b860c97209e1
ms.openlocfilehash: 35d8776216fb611416b053371c2703421dcaea08
ms.sourcegitcommit: 7bea0420d0e476287641edeb33a9d5689a98cb98
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/17/2020
ms.locfileid: "79466823"
---
# <a name="c26407-dont_heap_allocate_unnecessarily"></a>C26407 DONT_HEAP_ALLOCATE_UNNECESSARILY

Чтобы избежать ненужного использования указателей, мы пытаемся обнаружить распространенные закономерности локальных распределений, например, когда результат вызова оператора New хранится в локальной переменной и впоследствии явно удален. Это поддерживает правило R. 5: *предпочитать объекты с заданной областью, не выделяйте кучу без необходимости*. Предлагаемое исправление предназначено для использования типа RAII вместо необработанного указателя и позволяет ему работать с ресурсами. Если выделением является один объект, то он может быть очевидно ненужным, а локальная переменная типа объекта будет работать лучше.

## <a name="remarks"></a>Remarks

- Чтобы уменьшить число предупреждений, этот шаблон определяется только для указателей владельца. Поэтому сначала необходимо пометить владельцев надлежащим образом. Это можно легко расширить, чтобы охватить необработанные указатели, если мы получаем отзывы клиентов о поддержке такого сценария.

- Термин объекта с областью действия может оказаться неверной задачей, но общая идея состоит в том, что мы рекомендуем использовать локальную переменную, время существования которой управляется автоматически, или интеллектуальный объект, который эффективно управляет динамическими ресурсами. Смарт-объекты, конечно же, могут выделять память в куче, но не являются явными в коде.

- Если предупреждение срабатывает при выделении массива (которое обычно требуется для динамических буферов), то исправление может быть использовано для использования стандартных контейнеров или `std::unique_pointer<T[]>`.

- Шаблон обнаруживается только для локальных переменных, поэтому мы не будем предупреждать о тех случаях, когда выделение назначается, скажем, к глобальной переменной, а затем удаляется в той же самой функции.

## <a name="example-1-unnecessary-object-allocation-on-heap"></a>Пример 1. ненужное выделение объекта в куче

```cpp
auto tracer = new Tracer();
ScanObjects(tracer);
delete tracer;  // C26407
```

## <a name="example-2-unnecessary-object-allocation-on-heap-fixed-with-local-object"></a>Пример 2. необязательное выделение объекта в куче (с фиксированным локальным объектом)

```cpp
Tracer tracer;  // OK
ScanObjects(&tracer);
```

## <a name="example-3-unnecessary-buffer-allocation-on-heap"></a>Пример 3. ненужное выделение буфера в куче

```cpp
auto value = new char[maxValueSize];
if (ReadSetting(name, value, maxValueSize))
    CheckValue(value);
delete[] value; // C26407
```

## <a name="example-4-unnecessary-buffer-allocation-on-the-heap-fixed-with-container"></a>Пример 4. ненужное выделение буфера в куче (с фиксированным контейнером)

```cpp
auto value = std::vector<char>(maxValueSize); // OK
if (ReadSetting(name, value.data(), maxValueSize))
    CheckValue(value.data());
```
