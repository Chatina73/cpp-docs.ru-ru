---
description: 'Дополнительные сведения о: C26449 NO_SPAN_FROM_TEMPORARY'
title: C26449
ms.date: 03/22/2018
ms.topic: reference
f1_keywords:
- C26449
helpviewer_keywords:
- C26449
ms.openlocfilehash: 013d4785723ef87577fa7ae00597c47a0864236c
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97258620"
---
# <a name="c26449-no_span_from_temporary"></a>C26449 NO_SPAN_FROM_TEMPORARY

`gsl::span` или `std::string_view` создается из временной папки, если временная проверка становится недействительной.

C++ Core Guidelines: [GSL. View: views](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#gslview-views).

Диапазоны и представления — удобные и простые типы, позволяющие ссылаться на буферы памяти. Но они должны использоваться аккуратно: Хотя интерфейс похож на стандартные контейнеры, их поведение более похоже на поведение указателей и ссылок. Они не являются владельцами данных и никогда не должны быть созданы из временных буферов. Эта проверка посвящена тем случаям, когда исходные данные являются временными, а диапазон или представление — нет. Существует еще одна проверка, которая обрабатывает несколько различных сценариев, включающих ссылки на диапазоны: [C26445 NO_SPAN_REF](c26445.md). Оба правила могут помочь избежать незначительных, но опасных ошибок, возникших при внедрении устаревшего кода, и внедрения диапазонов или представлений.

## <a name="remarks"></a>Комментарии

- Это правило предупреждает о местах, где вызываются конструкторы для диапазонов или представлений, а исходный буфер данных принадлежит к временному объекту, созданному в той же инструкции. Сюда входят следующие возможности.
  - неявные преобразования в операторах Return;
  - неявные преобразования в операторах ternary;
  - явные преобразования в `static_cast` выражениях;
  - вызовы функций, возвращающие контейнеры по значению.
- Долгим сроком, созданные для аргументов вызова функции, не помечены. Передавайте диапазоны из таких долгим сроком, если целевые функции не сохранили указатели на данные во внешних переменных.
- Если диапазоны или представления сами долгим сроком, правило пропускает их.
- Отслеживание данных в средстве проверки имеет определенные ограничения. Поэтому сложные сценарии, включающие несколько или маскировку переназначений, могут не обрабатываться.

## <a name="example-subtle-difference-in-result-types"></a>Пример: незаметное различие в типах результатов

```cpp
// Returns a predefined collection. Keeps data alive.
gsl::span<const sequence_item> get_seed_sequence() noexcept;

// Returns a generated collection. Doesn’t own new data.
const std::vector<sequence_item> get_next_sequence(gsl::span<const sequence_item>);

void run_batch()
{
    auto sequence = get_seed_sequence();
    while (send(sequence))
    {
        sequence = get_next_sequence(sequence); // C26449
        // ...
    }
}
```
