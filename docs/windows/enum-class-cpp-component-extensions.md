---
title: Класс перечисления (C + +/ CLI и C + +/ CX)
ms.date: 10/12/2018
ms.topic: reference
ms.assetid: 8010fa8c-bad6-45b4-8214-b4db64d7ffe1
ms.openlocfilehash: aee3d4f44c18074ca536ff028565bbbd0e37d04c
ms.sourcegitcommit: bff17488ac5538b8eaac57156a4d6f06b37d6b7f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2019
ms.locfileid: "57417428"
---
# <a name="enum-class--ccli-and-ccx"></a>Класс перечисления (C + +/ CLI и C + +/ CX)

Объявляет перечисление в области видимости пространства имен, которое является определяемым пользователем типом, состоящим из ряда именованных констант, называемых перечислителями.

## <a name="all-runtimes"></a>Все среды выполнения

### <a name="remarks"></a>Примечания

C + +/ CX и C + +/ CLI поддержка **открытый класс перечисления** и **класс закрытого перечисления** , подобные стандартного c++ **класс перечисления** , но с добавлением доступность спецификатор. В разделе **/CLR**, C ++ 11 **класс перечисления** типа разрешен, но будет создавать предупреждение C4472, предназначенное для обеспечения действительно требуется тип перечисления стандарта ISO, а не C + +/ CX и C + +/ CLI типа. Дополнительные сведения о C++ стандарта ISO **перечисления** ключевое слово, см. в разделе [перечисления](../cpp/enumerations-cpp.md).

## <a name="windows-runtime"></a>Среда выполнения Windows

### <a name="syntax"></a>Синтаксис

```cpp
      access
      enum class
      enumeration-identifier
      [:underlying-type] { enumerator-list } [var];
accessenum structenumeration-identifier[:underlying-type] { enumerator-list } [var];
```

### <a name="parameters"></a>Параметры

*access*<br/>
Уровень доступа перечисления, который может быть **открытый** или **частного**.

*enumeration-identifier*<br/>
Имя перечисления.

*underlying-type*<br/>
(Необязательно) Базовый тип перечисления.

(Необязательно. Windows только среда выполнения) базовый тип перечисления, который может быть **bool**, **char**, `char16`, `int16`, `uint16`, **int**, `uint32`, `int64`, или `uint64`.

*enumerator-list*<br/>
Разделенный запятыми список имен перечислителей.

Значение каждого перечислителя — константное выражение, которое или определяется неявно компилятором, или явно нотацией *enumerator*`=`*constant-expression*. По умолчанию значение первого перечислителя ноль, если он определен неявно. Значение каждого следующего неявно определенного перечислителя — значение предыдущего перечислителя + 1.

*var*<br/>
(Необязательно) Имя переменной типа перечисления.

### <a name="remarks"></a>Примечания

Дополнительные сведения и примеры см. в разделе [Перечисления](../cppcx/enums-c-cx.md).

Обратите внимание, что компилятор выводит сообщения об ошибках, если константное выражение, задающее значение перечислителя, не может быть представлено *underlying-type*.  Однако компилятор не сообщает об ошибке для значения, недопустимого для базового типа. Пример:

- Если тип *underlying-type* числовой и перечислитель определяет максимальное значение для этого типа, то нельзя представить значение следующего неявно указанного перечисления.

- Если *базовый тип* — **bool**, и более двух перечислителей определены неявно определен, представить перечислители после первых двух невозможно.

- Если *underlying-type* является `char16`и значение перечисления в диапазоне от 0xD800 до 0xDFFF, то значение можно представить. Однако логически значение неверно, так как оно представляет половину пары символов-заместителей Юникода и не должно отображаться в изоляции.

### <a name="requirements"></a>Требования

Параметр компилятора: `/ZW`

## <a name="common-language-runtime"></a>Среда CLR

### <a name="syntax"></a>Синтаксис

```cpp
      access
      enum class
      name [:type] { enumerator-list } var;
accessenum structname [:type] { enumerator-list } var;
```

### <a name="parameters"></a>Параметры

*access*<br/>
Уровень доступа перечисления. Может быть либо **открытый** или **частного**.

*enumerator-list*<br/>
Разделенный запятыми список идентификаторов (перечислителей) в перечислении.

*name*<br/>
Имя перечисления. Анонимные управляемые перечисления не допускаются.

*type*<br/>
(Необязательно) Базовый тип *идентификаторы*. Это может быть любой скалярный тип, например со знаком или без знака версии **int**, **короткие**, или **long**.  **bool** или **char** также допустимы.

*var*<br/>
(Необязательно) Имя переменной типа перечисления.

### <a name="remarks"></a>Примечания

**enum class** и **enum struct** являются эквивалентными объявлениями.

Существуют два типа перечислений: управляемые (C++/CX) и стандартные.

Управляемые перечисления (или перечисления C++/CX) могут быть определены следующим образом:

```cpp
public enum class day {sun, mon };
```

Это семантически эквивалентно:

```cpp
ref class day {
public:
   static const int sun = 0;
   static const int mon = 1;
};
```

Стандартное перечисление может быть определено следующим образом:

```cpp
enum day2 { sun, mon };
```

Это семантически эквивалентно:

```cpp
static const int sun = 0;
static const int mon = 1;
```

Управляемые имена перечислителей (*identifiers*) не вводятся в область, в которой определяется перечисление; все ссылки на перечислители должны быть полными (*имя*`::`*идентификатор*).  По этой причине нельзя определить анонимное управляемое перечисление.

Перечислители стандартного перечисления строго вводятся во внешнюю область.  То есть, если есть другой символ с таким же именем, как у перечислителя во внешней области видимости, компилятор выдаст ошибку.

В Visual Studio 2002 и Visual Studio 2003 перечислители были нестрого вводимыми (видимыми во внешней области, если только было другого идентификатора с тем же именем).

Если определяется стандартное перечисление C++ (без **класс** или **структуры**), компиляция с параметром `/clr` приведет к компиляции как управляемое перечисление перечисления.  Перечисление по-прежнему имеет семантику неуправляемого перечисления.  Обратите внимание, что компилятор вводит атрибут `Microsoft::VisualC::NativeEnumAttribute` для определения намерения программиста сделать перечисление собственным.  Другие компиляторы просто увидят стандартное перечисление как управляемое перечисление.

Объект с именем, стандартное перечисление скомпилированные с использованием `/clr` будет видимо в сборке как управляемое перечисление и могут использоваться любым другим управляемым компилятором.   Однако безымянное стандартное перечисление не будет видимо из сборки.

В Visual Studio 2002 и Visual Studio 2003 стандартное перечисление использовалось в качестве типа в параметре функции:

```cpp
// mcppv2_enum.cpp
// compile with: /clr
enum E { a, b };
void f(E) {System::Console::WriteLine("hi");}

int main() {
   E myi = b;
   f(myi);
}
```

Этот код выдал бы в MSIL для сигнатуры функции следующее:

```cpp
void f(int32);
```

Однако в текущих версиях компилятора стандартное перечисление выдается как управляемое перечисление с [NativeEnumAttribute], а в MSIL для сигнатуры функции выдается следующее:

```cpp
void f(E)
```

Дополнительные сведения о неуправляемых перечислителях см. в разделе [Объявление перечислений C++](../cpp/enumerations-cpp.md).

Дополнительные сведения о перечислителях CLR см. в следующем разделе:

- [Базовый тип перечисления](../dotnet/how-to-define-and-consume-enums-in-cpp-cli.md)

### <a name="requirements"></a>Требования

Параметр компилятора: `/clr`

### <a name="examples"></a>Примеры

```cpp
// mcppv2_enum_2.cpp
// compile with: /clr
// managed enum
public enum class m { a, b };

// standard enum
public enum n { c, d };

// unnamed, standard enum
public enum { e, f } o;

int main()
{
   // consume managed enum
   m mym = m::b;
   System::Console::WriteLine("no automatic conversion to int: {0}", mym);
   System::Console::WriteLine("convert to int: {0}", (int)mym);

   // consume standard enum
   n myn = d;
   System::Console::WriteLine(myn);

   // consume standard, unnamed enum
   o = f;
   System::Console::WriteLine(o);
}
```

```Output
no automatic conversion to int: b

convert to int: 1

1

1
```

## <a name="see-also"></a>См. также

[Расширения компонентов для .NET и UWP](../windows/component-extensions-for-runtime-platforms.md)