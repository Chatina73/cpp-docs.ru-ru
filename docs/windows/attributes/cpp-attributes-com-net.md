---
title: Атрибуты C++ для модели COM и .NET
ms.custom: index-page
ms.date: 11/19/2018
ms.topic: conceptual
helpviewer_keywords:
- attributes [C++/CLI], reference topics
ms.assetid: 613a3611-b3eb-4347-aa38-99b654600e1c
ms.openlocfilehash: 4885edf57988d5f83b56ba6a71da85877354d3ce
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78856446"
---
# <a name="c-attributes-for-com-and-net"></a>Атрибуты C++ для модели COM и .NET

Корпорация Майкрософт определяет набор C++ атрибутов, УПРОЩАЮЩИХ программирование COM и .NET Framework разработку среды CLR. При включении атрибутов в исходные файлы компилятор работает с библиотеками DLL поставщика для вставки кода или изменения кода в созданных объектных файлах. Эти атрибуты помогают в создании IDL-файлов, интерфейсов, библиотек типов и других элементов COM. В интегрированной среде разработки (IDE) атрибуты поддерживаются мастерами и окно свойств.

Хотя атрибуты исключают некоторые из подробного кода, необходимого для написания COM-объектов, для оптимального использования в [основных понятиях com](/windows/win32/com/the-component-object-model) требуется фон.

> [!NOTE]
> Если вы ищете C++ стандартные атрибуты, см. раздел [атрибуты](../../cpp/attributes.md).

## <a name="purpose-of-attributes"></a>Назначение атрибутов

Атрибуты расширяются C++ в направлениях в невозможности без нарушения классической структуры языка. Атрибуты позволяют поставщикам (разделять библиотеки DLL) динамически расширять функциональность языка. Основной целью атрибутов является упрощение разработки компонентов COM, а также повышение уровня производительности разработчика компонентов. Атрибуты можно применять практически к любой C++ конструкции, например к классам, элементам данных или функциям элементов. Ниже приведено выделение преимуществ, предоставляемых этой новой технологией:

- Предоставляет привычное и простое соглашение о вызовах.

- Использует вставленный код, который, в отличие от макросов, распознается отладчиком.

- Позволяет легко создавать производные от базовых классов без подробной реализации утомительным.

- Заменяет большой объем кода IDL, требуемый компонентом COM, на несколько кратких атрибутов.

Например, чтобы реализовать простой приемник событий для универсального класса ATL, можно применить атрибут [event_receiver](event-receiver.md) к конкретному классу, например `CMyReceiver`. Затем атрибут `event_receiver` компилируется компилятором Майкрософт C++ , который вставляет правильный код в объектный файл.

```cpp
[event_receiver(com)]
class CMyReceiver
{
   void handler1(int i) { ... }
   void handler2(int i, float j) { ... }
}
```

Затем можно настроить методы `CMyReceiver` `handler1` и `handler2` для управления событиями (с помощью встроенной функции [__hook](../../cpp/hook.md)) из источника событий, который можно создать с помощью [event_source](event-source.md).

## <a name="basic-mechanics-of-attributes"></a>Основные принципы работы атрибутов

Существует три способа вставки атрибутов в проект. Сначала их можно вставить вручную в исходный код. Во вторых, их можно вставить с помощью сетки свойств объекта в проекте. Наконец, их можно вставить с помощью различных мастеров. Дополнительные сведения об использовании окна **Свойства** и различных мастеров см. в разделе [проекты Visual Studio — C++ ](../../build/creating-and-managing-visual-cpp-projects.md).

Как и ранее, при построении проекта компилятор анализирует каждый C++ исходный файл, создавая объектный файл. Однако если компилятор встречает атрибут, он анализируется и синтаксически проверен. Затем компилятор динамически вызывает поставщик атрибута для вставки кода или внесения других изменений во время компиляции. Реализация поставщика зависит от типа атрибута. Например, атрибуты, связанные с библиотекой ATL, реализуются с помощью Атлпров. dll.

На следующем рисунке показана связь между компилятором и поставщиком атрибута.

![Взаимодействие атрибутов компонентов](../media/vccompattrcomm.gif "Взаимодействие атрибутов компонентов")

> [!NOTE]
> Использование атрибута не изменяет содержимое исходного файла. Код созданного атрибута отображается только во время сеансов отладки. Кроме того, для каждого исходного файла в проекте можно создать текстовый файл, отображающий результаты подстановки атрибута. Дополнительные сведения об этой процедуре см. в разделе [/FX (объединение подставляемого кода)](../../build/reference/fx-merge-injected-code.md) и [Отладка внедренного кода](/visualstudio/debugger/how-to-debug-injected-code).

Как и C++ большинство конструкций, атрибуты имеют набор характеристик, определяющих их правильное использование. Это называется контекстом атрибута и разрешается в таблице контекста атрибутов для каждого раздела справки по атрибутам. Например, атрибут [coclass](coclass.md) может применяться только к существующему классу или структуре, а не к атрибуту [cpp_quote](cpp-quote.md) , который можно вставить в любое место в C++ исходном файле.

## <a name="building-an-attributed-program"></a>Сборка атрибутированной программы

После помещения визуальных C++ атрибутов в исходный код может потребоваться, чтобы компилятор Microsoft C++ создал библиотеку типов и IDL-файл. Следующие параметры компоновщика помогают создавать файлы TLB и IDL:

- [/IDLOUT](../../build/reference/idlout-name-midl-output-files.md)

- [/IGNOREIDL](../../build/reference/ignoreidl-don-t-process-attributes-into-midl.md)

- [/MIDL](../../build/reference/midl-specify-midl-command-line-options.md)

- [/TLBOUT](../../build/reference/tlbout-name-dot-tlb-file.md)

Некоторые проекты содержат несколько независимых IDL-файлов. Они используются для создания двух или более TLB файлов и при необходимости привязывают их к блоку ресурсов. В настоящее время этот сценарий не поддерживается в C++Visual.

Кроме того, визуальный C++ компоновщик будет выводить все сведения об атрибутах, связанных с IDL, в один файл MIDL. Создавать две библиотеки типов из одного проекта будет невозможно.

## <a name="contexts"></a>Контексты атрибутов

C++атрибуты можно описать с помощью четырех основных полей: целевой объект, к которому они могут применяться (**применяется к**), если они являются повторяемыми или нет (**повторяемые**), необходимое присутствие других атрибутов (**обязательных атрибутов**) и несовместимость с другими атрибутами (**недопустимые атрибуты**). Эти поля перечислены в сопроводительной таблице в справочном разделе каждого атрибута. Каждое из этих полей описано ниже.

### <a name="applies-to"></a>Применяется к

В этом поле описываются различные C++ элементы языка, которые являются юридическими целями для указанного атрибута. Например, если атрибут указывает "class" в поле " **применяется к** ", это означает, что атрибут может применяться только к юридическим C++ классам. Если атрибут применяется к функции-члену класса, возникнет синтаксическая ошибка.

Дополнительные сведения см. в разделе [атрибуты по использованию](attributes-by-usage.md).

### <a name="repeatable"></a>Повторяемый

В этом поле указывается, может ли атрибут быть многократно применен к тому же целевому объекту. Большинство атрибутов не повторяется.

### <a name="required-attributes"></a>Обязательные атрибуты

В этом поле перечислены другие атрибуты, которые должны присутствовать (то есть примененные к тому же целевому объекту) для правильной работы указанного атрибута. Нередко атрибут может иметь какие-либо записи для этого поля.

### <a name="invalid-attributes"></a>Недопустимые атрибуты

В этом поле перечислены другие атрибуты, несовместимые с указанным атрибутом. Нередко атрибут может иметь какие-либо записи для этого поля.

## <a name="in-this-section"></a>в этом разделе

[Атрибутивное программирование. Часто задаваемые вопросы](attribute-programming-faq.md)<br/>
[Список атрибутов по группам](attributes-by-group.md)<br/>
[Список атрибутов по использованию](attributes-by-usage.md)<br/>
[Алфавитный указатель атрибутов](attributes-alphabetical-reference.md)