---
title: Атрибуты C++ для COM и .NET
ms.custom: index-page
ms.date: 10/02/2018
ms.topic: conceptual
helpviewer_keywords:
- attributes [C++/CLI], reference topics
ms.assetid: 613a3611-b3eb-4347-aa38-99b654600e1c
ms.openlocfilehash: bacfd4cb78c5bf65422fb4472a4563776041a87b
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50589284"
---
# <a name="c-attributes-for-com-and-net"></a>Атрибуты C++ для COM и .NET

Корпорация Майкрософт определяет набор атрибутов C++, которые упрощают программирование COM и .NET Framework среды выполнения разработки языка. При включении атрибутов в исходных файлах, компилятор работает с поставщиком библиотеки DLL для вставки кода или изменения кода в файлах объектов. Эти атрибуты помощи в создании IDL-файлы, интерфейсы, библиотеки типов и другие элементы COM. В интегрированной среде разработки (IDE) атрибуты поддерживаются мастером и окно «Свойства».

Хотя атрибуты исключить некоторые из подробные создание кода, необходимые для написания COM-объектов, вам потребуется фона в [COM fundamentals](/windows/desktop/com/the-component-object-model) лучше всего использовать их.

> [!NOTE]
> Если вы ищете стандартные атрибуты C++, см. в разделе [атрибуты](../../cpp/attributes.md).

## <a name="purpose-of-attributes"></a>Назначение атрибутов

Атрибуты расширения C++ в настоящее время невозможно направлениях без нарушения классической структуру языка. Атрибуты позволяют поставщикам (отдельные библиотеки DLL) для расширения функциональных возможностей языка динамически. Основная цель атрибутов является упрощение создания COM-компонентов, в дополнение к повышению уровня производительности разработчика компонента. Атрибуты могут применяться к практически любой конструкции C++, таких как классы, данные-члены и функции-члены. Ниже приведен выделения преимуществ, предоставляемых этой новой технологии.

- Предоставляет знакомых и простых соглашение о вызовах.

- Использует вставить код, который, в отличие от макросы, распознаваемые отладчиком.

- Позволяет легко наследование от базовых классов, не обременительной деталей.

- Заменяет большой объем кода IDL, необходимого компонента COM с помощью нескольких атрибутов краткими.

Например, для реализации простых событий приемника для универсального класса ATL, можно применить [event_receiver](event-receiver.md) атрибута для определенного класса, например `CMyReceiver`. `event_receiver` Атрибут затем компилируется компилятором Visual C++, который вставляет в объектный файл правильный код.

```cpp
[event_receiver(com)]
class CMyReceiver
{
   void handler1(int i) { ... }
   void handler2(int i, float j) { ... }
}
```

Затем можно настроить `CMyReceiver` методы `handler1` и `handler2` для обработки событий (с помощью встроенная функция [__hook](../../cpp/hook.md)) из источников событий, которые можно создать с помощью [event_source](event-source.md).

## <a name="basic-mechanics-of-attributes"></a>Основные принципы работы атрибутов

Существует три способа вставки атрибутов в проекте. Во-первых можно вставить их вручную в исходном коде. Во-вторых вы можете вставить их с помощью сетки свойств объекта в проекте. Наконец вы можете вставить их с помощью различных мастеров. Дополнительные сведения об использовании **свойства** окно и различными мастерами, см. в разделе [Creating and Managing Visual C++ Projects](../../ide/creating-and-managing-visual-cpp-projects.md).

Как ранее, когда проект будет собран, компилятор анализирует каждый исходный файл C++, с помощью создания объектный файл. Тем не менее когда компилятор встречает атрибут, анализируется и синтаксически проверен. Затем компилятор динамически вызывает поставщика атрибутов для вставки кода или внести другие изменения во время компиляции. Реализация поставщика будет зависеть от типа атрибута. Например атрибуты, связанные с ATL реализуются путем Atlprov.dll.

На следующем рисунке показано отношение между компилятор и поставщик атрибутов.

![Взаимодействие атрибутов компонентов](../media/vccompattrcomm.gif "vcCompAttrComm")

> [!NOTE]
> Использование атрибута не изменяет содержимое исходного файла. Код создаваемого атрибута является видимым только один раз — во время сеансов отладки. Кроме того для каждого исходного файла в проекте, можно создать текстовый файл, который отображает результаты замены атрибута. Дополнительные сведения об этой процедуре см. в разделе [/Fx (слияние подставляемого кода)](../../build/reference/fx-merge-injected-code.md) и [отладка внедренного кода](/visualstudio/debugger/how-to-debug-injected-code).

Как и большинство конструкций C++ атрибуты имеют набор характеристик, определяющий их надлежащего использования. Это упоминается как контекст атрибута, а также опишем в таблице атрибутов контекста для раздела справочника атрибута. Например [coclass](coclass.md) атрибут может применяться только для существующего класса или структуры, в отличие от [cpp_quote](cpp-quote.md) атрибут, который может быть вставлен в любое место в исходном файле C++.

## <a name="building-an-attributed-program"></a>Сборка атрибутированной программы

После помещения атрибутов Visual C++ в исходном коде, вы можете компилятор Visual C++ для создания файла библиотеки и .idl тип для вас. Компоновщик следующие параметры помогают построить файлы с расширением TLB и .idl:

- [/IDLOUT](../../build/reference/idlout-name-midl-output-files.md)

- [/IGNOREIDL](../../build/reference/ignoreidl-don-t-process-attributes-into-midl.md)

- [/MIDL](../../build/reference/midl-specify-midl-command-line-options.md)

- [/TLBOUT](../../build/reference/tlbout-name-dot-tlb-file.md)

Некоторые проекты содержат несколько независимых .idl файлов. Они используются для создания двух или более TLB-файлы и их привязки в блоке ресурсов. Этот сценарий не поддерживается в Visual C++.

Кроме того компоновщик Visual C++ будет выводить все сведения атрибута, связанного с IDL, в единый файл MIDL. Будет невозможно создание двух библиотек типов в рамках одного проекта.

## <a name="contexts"></a> Контексты атрибутов

Атрибуты C++ можно описать с помощью четыре основные поля: они могут применяться к целевой (**применяется к**), если они repeatable или нет (**Repeatable**), требуется наличие других атрибутов ( **Необходимые атрибуты**), проблем с совместимостью с другими атрибутами (**недопустимые атрибуты**). Эти поля перечислены в таблице в разделе справки для каждого атрибута. Ниже описан каждый из этих полей.

### <a name="applies-to"></a>Применение

Это поле Описание различных элементов языка C++, которые являются допустимые целевые объекты для заданного атрибута. Например если атрибут задает «class» в **применяется к** , это означает, что атрибут может применяться только к юридическим класса C++. Если атрибут применяется к функции-члену класса, приведет к синтаксической ошибки.

Дополнительные сведения см. в разделе [атрибутов по использованию](attributes-by-usage.md).

### <a name="repeatable"></a>Повторяемый

Это поле утверждается, может ли атрибут несколько раз применен одного целевого объекта. Большинство атрибутов не повторяются.

### <a name="required-attributes"></a>Обязательные атрибуты

Это поле перечисляет другие атрибуты, которые должны быть присутствует (то есть, применяемая для одного целевого объекта) для заданного атрибута для правильной. Это нередко атрибут иметь какие-либо записи для этого поля.

### <a name="invalid-attributes"></a>Недопустимые атрибуты

В этом поле перечислены другие атрибуты, которые несовместимы с указанным атрибутом. Это нередко атрибут иметь какие-либо записи для этого поля.

## <a name="in-this-section"></a>В этом разделе

[Атрибутивное программирование. Часто задаваемые вопросы](attribute-programming-faq.md)<br/>
[Список атрибутов по группам](attributes-by-group.md)<br/>
[Список атрибутов по использованию](attributes-by-usage.md)<br/>
[Алфавитный указатель атрибутов](attributes-alphabetical-reference.md)