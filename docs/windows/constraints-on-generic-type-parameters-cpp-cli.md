---
title: Ограничения, применяемые к параметрам универсальных типов (C++/CLI)
ms.date: 10/12/2018
ms.topic: reference
f1_keywords:
- where
helpviewer_keywords:
- where keyword [C++]
- constraints, C++
ms.assetid: eb828cc9-684f-48a3-a898-b327700c0a63
ms.openlocfilehash: c0ad5a22adec0d93019e9ea5c81cc8329d1607f8
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50533710"
---
# <a name="constraints-on-generic-type-parameters-ccli"></a>Ограничения, применяемые к параметрам универсальных типов (C++/CLI)

В объявлениях универсального типа или метода можно указывать параметр типа с ограничениями. Ограничение — это требование, которому должны удовлетворять типы, используемые в качестве аргументов типа. Например, ограничение может требовать, чтобы аргумент типа реализовывал определенный интерфейс или наследовался от определенного класса.

Ограничения не являются обязательными; отсутствие ограничения на параметр эквивалентно ограничению этого параметра значением <xref:System.Object>.

## <a name="syntax"></a>Синтаксис

```cpp
where type-parameter: constraint list
```

### <a name="parameters"></a>Параметры

*параметр типа*<br/>
Один из ограниченных параметров типа.

*Список ограничений*<br/>
*Список ограничений* является разделенный запятыми список спецификаций ограничений. Этот список может содержать интерфейсы, которые должны быть реализованы параметром типа.

Список также может содержать класс. Чтобы аргумент типа удовлетворял ограничению базового класса, он должен быть того же класса, что и ограничение, или производным от ограничения.

Можно также указать **gcnew()** чтобы указать аргумент типа должен иметь открытый конструктор без параметров; или **ссылочного класса** чтобы указать аргумент типа должен быть ссылочным типом, включая любой класс интерфейса, делегата или тип массива; или **класса значений** для указания типа аргумент должен быть типом значения. Любое значение типа, кроме Nullable\<T > можно указать.

В качестве ограничения можно также указать универсальный параметр. Аргумент типа, указанный для ограничиваемого типа, должен иметь тип ограничения или наследоваться о него. Это называется открытым ограничением типа.

## <a name="remarks"></a>Примечания

Предложение ограничения состоит из **где** следуют параметр типа, двоеточие (**:**) и ограничение, определяющее характер ограничения параметра типа. **где** является контекстно-зависимые ключевым словом; см. в разделе [контекстные ключевые слова](../windows/context-sensitive-keywords-cpp-component-extensions.md) Дополнительные сведения. Разделите несколько **где** предложения с пробелом.

Ограничения применяются к параметрам типа для задания ограничений на типы, которые могут использоваться в качестве аргументов для универсальных типов и методов.

Ограничения класса и интерфейса определяют, что типы аргументов должны быть указанного класса или унаследованы от него либо должны реализовывать указанный интерфейс.

Применение ограничений к универсальному типу или методу позволяет коду в этом типе или методе использовать известные возможности ограниченных типов. Например, можно объявить универсальный класс таким образом, параметр типа реализовывал `IComparable<T>` интерфейса:

```cpp
// generics_constraints_1.cpp
// compile with: /c /clr
using namespace System;
generic <typename T>
where T : IComparable<T>
ref class List {};
```

Это ограничение требует, что аргумент типа используется для `T` реализует `IComparable<T>` во время компиляции. Он также позволяет методам интерфейса, такие как `CompareTo`, для вызова. Для вызова методов интерфейса приведение типа в экземпляре параметра типа не требуется.

Вызывать статические методы в классе аргумента типа с помощью параметра типа нельзя. Их можно вызывать только с использованием фактического имени типа.

Ограничение не может быть типом значения, включая встроенные типы, такие как **int** или **двойные**. Поскольку типы значений не могут иметь производные классы, ограничению может удовлетворять только один класс. В этом случае универсальный шаблон можно переписать с заменой параметра типа определенным типом значения.

Ограничения требуются в некоторых случаях, поскольку компилятор не допускает использование методов и других возможностей неизвестного типа, если ограничениями не определено, что неизвестный тип поддерживает методы или интерфейсы.

Для одного параметра типа можно определить несколько ограничений в списке, разделенном запятыми.

```cpp
// generics_constraints_2.cpp
// compile with: /c /clr
using namespace System;
using namespace System::Collections::Generic;
generic <typename T>
where T : List<T>, IComparable<T>
ref class List {};
```

С несколькими параметрами типов, используйте один **где** предложение для каждого параметра типа. Пример:

```cpp
// generics_constraints_3.cpp
// compile with: /c /clr
using namespace System;
using namespace System::Collections::Generic;

generic <typename K, typename V>
   where K: IComparable<K>
   where V: IComparable<K>
ref class Dictionary {};
```

Ограничения в коде следует использовать в соответствии с указанными ниже правилами.

- Ограничения можно перечислять в любом порядке.

- Ограничения также могут быть типами классов, например абстрактными базовыми классами. Однако они не могут быть типами значений и запечатанными классами.

- Ограничения сами не могут быть параметрами типа, но могут содержать параметры типа в открытом сконструированном типе. Пример:

    ```cpp
    // generics_constraints_4.cpp
    // compile with: /c /clr
    generic <typename T>
    ref class G1 {};

    generic <typename Type1, typename Type2>
    where Type1 : G1<Type2>   // OK, G1 takes one type parameter
    ref class G2{};
    ```

## <a name="example"></a>Пример

В следующем примере демонстрируется использование ограничений для вызова экземплярных методов для параметров типа.

```cpp
// generics_constraints_5.cpp
// compile with: /clr
using namespace System;

interface class IAge {
   int Age();
};

ref class MyClass {
public:
   generic <class ItemType> where ItemType : IAge
   bool isSenior(ItemType item) {
      // Because of the constraint,
      // the Age method can be called on ItemType.
      if (item->Age() >= 65)
         return true;
      else
         return false;
   }
};

ref class Senior : IAge {
public:
   virtual int Age() {
      return 70;
   }
};

ref class Adult: IAge {
public:
   virtual int Age() {
      return 30;
   }
};

int main() {
   MyClass^ ageGuess = gcnew MyClass();
   Adult^ parent = gcnew Adult();
   Senior^ grandfather = gcnew Senior();

   if (ageGuess->isSenior<Adult^>(parent))
      Console::WriteLine("\"parent\" is a senior");
   else
      Console::WriteLine("\"parent\" is not a senior");

   if (ageGuess->isSenior<Senior^>(grandfather))
      Console::WriteLine("\"grandfather\" is a senior");
   else
      Console::WriteLine("\"grandfather\" is not a senior");
}
```

```Output
"parent" is not a senior
"grandfather" is a senior
```

## <a name="example"></a>Пример

Если в качестве ограничения используется параметр универсального типа, такое ограничение называется открытым ограничением типа. Открытые ограничения типа применимы, когда функция-член со своим параметром типа должна ограничивать этот параметр параметром содержащего типа.

В следующем примере `T` является открытым ограничением типа в контексте `Add` метод.

Открытые ограничения типа также можно использовать в определениях универсальных классов. Применение открытых ограничений типа с универсальными классами ограничено, поскольку в отношении таких ограничений компилятор может предполагать только то, что они являются производными от <xref:System.Object>. Открытые ограничения типа следует использовать в универсальных классах в тех случаях, когда необходимо обеспечить отношение наследования между двумя параметрами типа.

```cpp
// generics_constraints_6.cpp
// compile with: /clr /c
generic <class T>
ref struct List {
   generic <class U>
   where U : T
   void Add(List<U> items)  {}
};

generic <class A, class B, class C>
where A : C
ref struct SampleClass {};
```

## <a name="see-also"></a>См. также

[Универсальные шаблоны](../windows/generics-cpp-component-extensions.md)