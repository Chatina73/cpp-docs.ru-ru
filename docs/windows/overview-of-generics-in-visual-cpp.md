---
title: Обзор универсальных типов в C + +/ CLI
ms.date: 10/12/2018
ms.topic: reference
helpviewer_keywords:
- generics [C++], about generics
- default initializers [C++]
- type parameters [C++]
- constructed types
- type arguments [C++]
- constructed types, open [C++]
- open constructed types [C++]
- constructed types, closed [C++]
ms.assetid: 21f10637-0fce-4916-b925-6c86a126d3aa
ms.openlocfilehash: 1105025ebebdfcbce723505747f6677674c04334
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50655173"
---
# <a name="overview-of-generics-in-ccli"></a>Обзор универсальных типов в C + +/ CLI

Универсальные шаблоны — это параметризованные типы, поддерживаемые средой CLR. Параметризованный тип — это тип, определяемый неизвестным параметром типа, который задается при использовании универсального шаблона.

## <a name="why-generics"></a>Преимущества универсальных шаблонов

C++ поддерживает обычные шаблоны, которые наряду с универсальными поддерживают параметризованные типы для создания классов типизированных коллекций. Однако обычные шаблоны предусматривают параметризацию во время компиляции. Нельзя ссылаться на сборку, содержащую определение шаблона, и создавать его новые специализации. После компиляции специализированный шаблон выглядит подобно любому другому классу или методу. В отличие от обычных, универсальные шаблоны создаются в MSIL в виде параметризованного типа, известного среде выполнения как параметризованный тип; исходный код, ссылающийся на сборку, которая содержит универсальный тип, может создавать специализации этого универсального типа. Дополнительные сведения о сравнении стандартных шаблонов C++ и универсальные шаблоны, см. в разделе [универсальные типы и шаблоны (C + +/ CLI)](../windows/generics-and-templates-visual-cpp.md).

## <a name="generic-functions-and-types"></a>Универсальные функции и типы

Типы классов могут быть универсальными, пока являются управляемыми. Примером может служить класс `List`. Типом объекта в этом списке является параметр типа. При необходимости вы `List` класс для различных типов объектов, до универсальных типов, возможно, вы используете `List` , принимающий `System::Object` как тип элемента. Однако при этом в списке могут использоваться любые объекты (в том числе неверного типа). Такой список называется классом нетипизированных коллекций. В лучшем случае можно проверять тип во время выполнения и создавать исключение. Можно также использовать шаблон, который при компиляции в сборку будет терять свою универсальность. Пользователи вашей сборки не смогут создавать собственные специализации шаблона. Универсальные шаблоны позволяют создавать классы типизированных коллекций, скажем `List<int>` (читается как «Список типа int») и `List<double>` («список типа double») которого вызовет ошибку компиляции, при попытке поместить тип, тип сборки не может принимать в типизированный Коллекция. Кроме того, после компиляции этих типов они остаются универсальными.

Описание синтаксиса универсальных классов можно найти в [универсальные классы (C + +/ CLI)](../windows/generic-classes-cpp-cli.md). Новое пространство имен, <xref:System.Collections.Generic>, введен набор параметризованных типов коллекций включая <xref:System.Collections.Generic.Dictionary%602>, <xref:System.Collections.Generic.List%601> и <xref:System.Collections.Generic.LinkedList%601>.

Экземплярные и статические функции членов классов, делегаты и глобальные функции также могут быть универсальными. Универсальные функции могут потребоваться, если тип параметров функции неизвестен или сама функция должна работать с универсальными типами. Во многих случаях где `System::Object` возможно, был использован ранее в качестве параметра для неизвестного типа объекта, параметр универсального типа можно использовать вместо этого, позволяя более типобезопасный код. Любая попытка передать тип, который функция не поддерживает, во время компиляции отмечается как ошибка. С помощью `System::Object` как параметр функции случайная передача объекта, что функция не был предназначен для работы с не будут обнаружены и пришлось бы привести неизвестного типа объекта к определенному типу в теле функции и учетной записи для возможность появления исключения InvalidCastException. При наличии универсального шаблона код, пытаясь передать объект в функцию, вызывает конфликт типов и поэтому тело функции будет гарантированно содержать правильный тип.

Те же преимущества относятся к классам коллекций, созданным в универсальных шаблонах. Использовать классы коллекций в прошлом `System::Object` для хранения элементов в коллекции. Вставка объектов типа, для которого коллекция не предназначена, во время компиляции не отмечалась и часто не отмечалась даже после вставки объектов. Обычно объект приводится к другому типу после обращения к нему в коллекции. Неизвестный тип обнаруживается только при сбое приведения. Универсальные шаблоны решают эту проблему во время компиляции, обнаруживая любой код, в котором вставляется тип, не соответствующий параметру типа универсальной коллекции (или неявно преобразованный в него).

Описание синтаксиса, см. в разделе [универсальные функции (C + +/ CLI)](../windows/generic-functions-cpp-cli.md).

## <a name="terminology-used-with-generics"></a>Терминология, используемая с универсальными шаблонами

### <a name="type-parameters"></a>Параметры типа

Универсальное объявление содержит один или несколько неизвестных типов, известный как *параметры типа*. Имя параметра типа представляет тип в теле универсального объявления. Параметр типа в теле универсального объявления используется в качестве типа. Универсальное объявление `List<T>` содержит параметр типа T.

### <a name="type-arguments"></a>Аргументы типа

*Аргумент типа* является фактический тип, используемый вместо параметра типа, когда универсальный шаблон определен для конкретного типа или типов. Например **int** — это аргумент типа в `List<int>`. В качестве аргумента универсального типа разрешается использовать только типы значений и типы дескрипторов.

### <a name="constructed-type"></a>Сконструированный тип

Тип, созданный из универсального типа называются *сконструированный тип*. Не полностью заданный тип, такие как `List<T>` — *открытый сконструированный тип*; а полностью заданный, такие как `List<double>,` — *закрытый сконструированный тип* или *специализированным типом* . Открытые сконструированные типы могут использоваться в определении других универсальных типов или методов и не могут быть полностью заданы до тех пор, пока не задан сам включающий универсальный шаблон. Например, ниже показано использование открытого сконструированного типа в качестве базового класса для универсального шаблона.

```cpp
// generics_overview.cpp
// compile with: /clr /c
generic <typename T>

ref class List {};

generic <typename T>

ref class Queue : public List<T> {};
```

### <a name="constraint"></a>Ограничение

Под ограничением понимается ограничение для типов, которые могут использоваться в качестве параметра типа. Например, заданный универсальный класс может принимать только классы, производные от указанного класса или реализующие указанный интерфейс. Дополнительные сведения см. в разделе [ограничений для параметров универсального типа (C + +/ CLI)](../windows/constraints-on-generic-type-parameters-cpp-cli.md).

## <a name="reference-types-and-value-types"></a>Ссылочные типы и типы значений

В качестве аргументов типа могут использоваться типы дескрипторов и типы значений. В универсальном определении, в котором может использоваться любой тип, применяется синтаксис ссылочных типов. Например `->` оператор используется для доступа к членам типа параметра типа, ли тип, используемый в конечном счете является ссылочным типом или типом значения. Если в качестве аргумента типа применяется тип значения, среда выполнения создает код, в котором типы значений используются непосредственно, без упаковки-преобразования.

При использовании ссылочного типа в качестве аргумента универсального типа необходимо применять синтаксис дескриптора. При использовании типа значения в качестве аргумента универсального типа следует непосредственно указывать имя типа.

```cpp
// generics_overview_2.cpp
// compile with: /clr
generic <typename T>

ref class GenericType {};
ref class ReferenceType {};

value struct ValueType {};

int main() {
    GenericType<ReferenceType^> x;
    GenericType<ValueType> y;
}
```

## <a name="type-parameters"></a>Параметры типа

Параметры типов в универсальном классе обрабатываются так же, как и другие идентификаторы. Однако поскольку тип неизвестен, существуют ограничения по их использованию. Например, нельзя использовать члены и методы класса параметра типа, если неизвестно, поддерживает ли параметр типа эти члены. То есть для доступа к члену через параметр типа необходимо добавить тип, содержащий этот член, в список ограничений параметра типа.

```cpp
// generics_overview_3.cpp
// compile with: /clr
interface class I {
   void f1();
   void f2();
};

ref struct R : public I {
   virtual void f1() {}
   virtual void f2() {}
   virtual void f3() {}
};

generic <typename T>
where T : I
void f(T t) {
   t->f1();
   t->f2();
   safe_cast<R^>(t)->f3();
}

int main() {
   f(gcnew R());
}
```

Эти ограничения также относятся к операторам. В произвольном параметре универсального типа нельзя использовать операторы `==` и `!=` для сравнения двух экземпляров параметра типа, если тип не поддерживает эти операторы. Эти проверки необходимы для универсальных шаблонов, но не требуются для обычных шаблонов, поскольку универсальные шаблоны могут быть конкретизированы во время выполнения любым другим классом, удовлетворяющим ограничениям, когда слишком поздно проверять использование недопустимых членов.

Экземпляр по умолчанию параметра типа можно создать с помощью оператора `()`. Пример:

`T t = T();`

где `T` — параметр типа в определении универсального класса или метода; инициализирует переменную со значением по умолчанию. Если параметр `T` является ссылочным классом, он будет пустым указателем; если `T` — класс значения, объект инициализируется с нулевым значением. Это называется *по умолчанию инициализатор*.

## <a name="see-also"></a>См. также

[Универсальные шаблоны](../windows/generics-cpp-component-extensions.md)