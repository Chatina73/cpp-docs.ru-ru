---
title: Практическое руководство. Миграция в - clr
ms.custom: get-started-article
ms.date: 09/18/2018
helpviewer_keywords:
- upgrading Visual C++ applications, /clr compiler option
- compiling native code [C++]
- interoperability [C++], /clr compiler option
- interop [C++], /clr compiler option
- migration [C++], /clr compiler option
- /clr compiler option [C++], porting to
ms.assetid: c9290b8b-436a-4510-8b56-eae51f4a9afc
ms.openlocfilehash: 02e678f98773f9ae7bb4f611210329a7a1116f17
ms.sourcegitcommit: dedd4c3cb28adec3793329018b9163ffddf890a4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2019
ms.locfileid: "57749118"
---
# <a name="how-to-migrate-to-clr"></a>Практическое руководство. Миграция в/CLR

В этом разделе рассматриваются проблемы, возникающие при компиляции машинного кода с **/CLR** (см. в разделе [/CLR (компиляция CLR)](../build/reference/clr-common-language-runtime-compilation.md) Дополнительные сведения). **/ CLR** позволяет машинного кода C++ для вызова, а также быть вызван из сборок .NET в дополнение к другим машинного кода C++. См. в разделе [смешанные (собственные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md) и [машинный код и платформы.NET](../dotnet/native-and-dotnet-interoperability.md) Дополнительные сведения о преимуществах компиляции с использованием **/CLR**.

## <a name="known-issues-compiling-library-projects-with-clr"></a>Известные проблемы при компиляции проектов библиотек с параметром/CLR

Visual Studio содержит некоторые известные проблемы при компиляции проектов библиотек с **/CLR**:

- Ваш код может запрашивать типов во время выполнения с [CRuntimeClass::FromName](../mfc/reference/cruntimeclass-structure.md#fromname). Тем не менее если тип является библиотекой DLL MSIL (скомпилированные с использованием **/CLR**), вызов `FromName` может завершиться ошибкой, если он выполняется перед запуском статических конструкторов в управляемой DLL (недоступен для этой проблемы в случае вызов FromName производится после кода выполняется в управляемых DLL-файл). Чтобы обойти эту проблему, можно принудительно создать управляемый статический конструктор, определив функцию в управляемой DLL, экспортировав ее и вызовом его из собственного приложения MFC. Пример:

    ```
    // MFC extension DLL Header file:
    __declspec( dllexport ) void EnsureManagedInitialization () {
       // managed code that won't be optimized away
       System::GC::KeepAlive(System::Int32::MaxValue);
    }
    ```

## <a name="compile-with-visual-c"></a>Компиляция с помощью Visual C++

Перед использованием **/CLR** для любого модуля в проекте, во-первых, компиляции и компоновки собственный проект с помощью Visual Studio 2010.

Следующие действия, в определенном порядке, предоставляют самый простой способ получить **/CLR** компиляции. Важно скомпилировать и запустить проект после каждого из этих действий.

### <a name="versions-prior-to-visual-c-2003"></a>Версий, предшествующих Visual C++ 2003

Visual Studio 2010 при обновлении с версии до Visual C++ 2003, может появиться ошибки компилятора, связанные с расширенным соответствием стандарту C++ в Visual C++ 2003

### <a name="upgrading-from-visual-c-2003"></a>Обновление с Visual C++ 2003

Проекты, построенные с помощью Visual C++ 2003 ранее также сначала компилироваться без **/CLR** как в Visual Studio теперь более строгое соответствие стандартам ANSI/ISO и ряд важных изменений. Изменения, может потребоваться больше всего внимания [функции безопасности в CRT](../c-runtime-library/security-features-in-the-crt.md). Код, использующий CRT скорее всего, для создания предупреждения о нерекомендуемых функциях. Эти предупреждения можно отключить, однако переход на [версии функций для CRT с улучшенной безопасностью](../c-runtime-library/security-enhanced-versions-of-crt-functions.md) является предпочтительным, так как они обеспечивают более высокий уровень безопасности и могут открыть проблемы с безопасностью в коде.

### <a name="upgrading-from-managed-extensions-for-c"></a>Обновление с управляемых расширений для C++

Начиная с Visual Studio 2005, не будет компилироваться код, написанный с помощью управляемых расширений для C++ в разделе **/CLR**.

## <a name="convert-c-code-to-c"></a>Преобразование кода на C в C++

Несмотря на то, что Visual Studio скомпилирует файлов C, бывает необходимо преобразовать их в C++ для **/CLR** компиляции. Фактическое имя файла не должен быть изменен; можно использовать **/Tp** (см. в разделе [TP, /TC, /TP (определение типа исходного файла)](../build/reference/tc-tp-tc-tp-specify-source-file-type.md).) Обратите внимание, что, несмотря на то, что исходные файлы C++ являются обязательными для **/CLR**, нет необходимости выполнить рефакторинг кода для использования объектно ориентированных парадигм.

Код C скорее всего, потребуется вносить изменения при компиляции как файл C++. Правила безопасности типов C++ неизменны, поэтому преобразования типов должны вноситься явного приведения. Например malloc возвращает указатель void, но могут быть назначены указатель любого типа на языке C с помощью приведения:

```
int* a = malloc(sizeof(int));   // C code
int* b = (int*)malloc(sizeof(int));   // C++ equivalent
```

Указатели на функции также являются строго типизированный язык c++, поэтому следующий код C требует изменения. В C++ лучше всего создать `typedef` , определяет тип указателя на функцию, а затем использовать этот тип для приведения указатели на функции:

```
NewFunc1 = GetProcAddress( hLib, "Func1" );   // C code
typedef int(*MYPROC)(int);   // C++ equivalent
NewFunc2 = (MYPROC)GetProcAddress( hLib, "Func2" );
```

C++ также необходимо использовать функции или ее прототипом, либо полностью задан прежде, чем они могут ссылаться или вызове.

Идентификаторы, используемые в коде C, являются ключевые слова в C++ (такие как **виртуального**, **новый**, **удалить**, **bool**, **true** , **false**т. д.) необходимо переименовать. Как правило, это можно сделать с помощью простых операций поиска и замены.

```
COMObj1->lpVtbl->Method(COMObj, args);  // C code
COMObj2->Method(args);  // C++ equivalent
```

## <a name="reconfigure-project-settings"></a>Изменение параметров проекта

После того как проект компилируется и выполняется в Visual Studio 2010 необходимо создать новые конфигурации проектов для **/CLR** вместо того, чтобы изменения конфигурации по умолчанию. **/ CLR** несовместим с некоторыми параметрами компилятора и создание отдельных конфигураций позволяет построить проект как машинный или управляемый. Когда **/CLR** выбран в окне диалоговое окно страниц свойств, параметры проекта, не совместим с **/CLR** отключены (и отключенные параметры не будут восстановлены автоматически, если **/CLR** последующей отмене выбора).

### <a name="create-new-project-configurations"></a>Создать новые конфигурации проекта

Можно использовать **Копировать параметры из** в диалоговом окне **диалоговое окно "Конфигурация" новый проект "** (**построения** > **Configuration Manager**  >  **Активная конфигурация решения** > **New**) для создания конфигурации проекта, в зависимости от текущих параметров проекта. Для этого один раз для конфигурации отладки и один раз для конфигурации выпуска. Затем последующие изменения могут применяться к **/CLR** -определенных конфигураций, остаются без изменений исходные конфигурации проекта.

Проекты, использующие пользовательские правила сборки может потребоваться дополнительное внимание.

Этот шаг имеет различные последствия для проектов, использующих файлы makefile. В этом случае можно настроить отдельный путь построения или версию, предназначенную для **/CLR** компиляции могут создаваться из копию оригинала.

### <a name="change-project-settings"></a>Изменение параметров проекта

**/ CLR** могут быть выбраны в среде разработки, следуя инструкциям в [/CLR (компиляция CLR)](../build/reference/clr-common-language-runtime-compilation.md). Как упоминалось ранее, этот шаг будет автоматически отключена конфликтующие параметры проекта.

> [!NOTE]
>  При обновлении управляемой библиотеки или проекта веб-службы из Visual C++ 2003 **/Zl** компилятора параметр будет добавлен **командной строки** страницу свойств. В результате LNK2001. Удалить **/Zl** из **командной строки** страницу свойств для решения. См. в разделе [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) и [работа со свойствами проекта](../ide/working-with-project-properties.md) Дополнительные сведения. Либо добавьте msvcrt.lib и msvcmrt.lib в компоновщик **Дополнительные зависимости** свойство.

Для проектов, созданных с помощью файлов makefile, несовместимые параметры компилятора должны быть отключены вручную **/CLR** добавляется. См. в разделе /[ограничения/CLR](../build/reference/clr-restrictions.md) сведения о параметрах компилятора, которые не совместимы с **/CLR**.

### <a name="precompiled-headers"></a>Предкомпилированные заголовочные файлы

Поддерживает использование предкомпилированных заголовков **/CLR**. Тем не менее если вы только компиляции некоторых из CPP-файлов **/CLR** (компиляция остальных native) некоторые изменения будет требоваться потому, что предкомпилированные заголовки, созданные с помощью **/CLR** не совместимы с файлами создается без **/CLR**. Эта несовместимость связано с тем фактом, что **/CLR** приводит к возникновению ошибки и требует наличия метаданных. Модули, скомпилированные **/CLR** таким образом, не может использовать предкомпилированные заголовки, которые не содержат метаданные, а не **/CLR** модули нельзя использовать файлы предкомпилированных заголовков, содержащие метаданные.

Самый простой способ компиляции проекта, где некоторые модули обычно компилируются **/CLR** — Полное отключение предкомпилированных заголовков. (В диалоговом окне страницы свойств проекта откройте узел C/C++ и выберите предкомпилированные заголовки. Затем измените свойство создать/использовать предкомпилированные заголовки на «Не использовать предкомпилированные заголовки».)

Однако особенно для крупных проектов предкомпилированных заголовков обеспечивает гораздо более высокую скорость компиляции, поэтому отключение этой функции является нежелательным. В этом случае лучше всего настроить **/CLR** и не **/CLR** файлы для использования разных предкомпилированных заголовков. Это можно сделать за один шаг, выбрать несколько модулей для компиляции **/CLR** с помощью **обозревателе решений**, щелкнув правой кнопкой мыши на группу и выбрать свойства. Затем измените файл предкомпилированного заголовка и создать или используемый PCH-файл свойства для использования PCH-файл и имя файла в другом заголовке соответственно.

## <a name="fixing-errors"></a>Устранение ошибок

Компиляция с **/CLR** может привести к ошибкам компилятора, компоновщика или среды выполнения. В этом разделе рассматриваются наиболее распространенные проблемы.

### <a name="metadata-merge"></a>Объединения метаданных

Различия в версиях типов данных может привести к компоновщику ошибкой, так как метаданные, созданные для двух типов не соответствует. (Обычно это вызывается при условно определяются членами типа, но условия не то же самое для всех файлов CPP, использующие тип.) В этом случае компоновщик завершается ошибкой, отчеты только имя символа и имя второго файла OBJ, где находится определение этого типа. Часто бывает полезным изменить порядок отправки OBJ-файлы компоновщика обнаружить расположение других версий типа данных.

### <a name="loader-lock-deadlock"></a>Взаимоблокировка при блокировке загрузчика

«Взаимоблокировка при блокировке загрузчика» могут возникнуть, но является детерминированным и обнаруживается и во время выполнения. См. в разделе [Инициализация смешанных сборок](../dotnet/initialization-of-mixed-assemblies.md) подробные сведения, рекомендации и решения.

### <a name="data-exports"></a>Экспорт данных

Экспорт данных библиотек DLL, ошибкам и не рекомендуется. Это обусловлено разделе данных библиотеки DLL не гарантируется, что инициализироваться, пока не был выполнен некоторой управляемые части библиотеки DLL. Эталонные метаданные с [# директива using](../preprocessor/hash-using-directive-cpp.md).

### <a name="type-visibility"></a>Видимость типов

Собственные типы являются закрытыми по умолчанию. Это может привести собственный тип, не отображая вне библиотеки DLL. Устранить эту ошибку, добавив `public` с этими типами.

### <a name="floating-point-and-alignment-issues"></a>С плавающей запятой и проблемы выравнивания

`__controlfp` Среда CLR не поддерживается (см. в разделе [_control87, _controlfp, \__control87_2](../c-runtime-library/reference/control87-controlfp-control87-2.md) Дополнительные сведения). Среда CLR также не будут использовать [выровнять](../cpp/align-cpp.md).

### <a name="com-initialization"></a>Инициализация COM

Среда CLR автоматически инициализирует COM при инициализации модуля (Если автоматическая инициализация COM производится в режиме многопотокового Подразделения). В результате явной инициализации COM будут коды возврата, указывающий, что COM уже инициализирована. Явно инициализировать COM с одной моделью потоков, когда среда CLR уже инициализирован COM в другую модель потоков может вызвать сбой приложения.

Среда CLR запускает COM в режиме многопотокового Подразделения по умолчанию. Используйте [/CLRTHREADATTRIBUTE (значение атрибута потока среды CLR)](../build/reference/clrthreadattribute-set-clr-thread-attribute.md) для этого.

### <a name="performance-issues"></a>Проблемы производительности

При вызове косвенно собственные методы C++, созданных в MSIL, может наблюдаться снижение производительности (вызовов виртуальных функций или с помощью указателей функций). Дополнительные сведения об этом см. в разделе [двойного](../dotnet/double-thunking-cpp.md).

При переходе от собственного в MSIL-код, можно заметить увеличение размера рабочего набора. Это так, как среда CLR предоставляет множество возможностей, чтобы обеспечить правильную работу программ. Если ваш **/CLR** приложение не работает правильно, вы можете включить C4793 (отключено по умолчанию), см. в разделе [Предупреждение компилятора (уровень 1 и 3) C4793](../error-messages/compiler-warnings/compiler-warning-level-1-and-3-c4793.md) Дополнительные сведения.

### <a name="program-crashes-on-shutdown"></a>Случаи сбоя программ при завершении работы

В некоторых случаях среда CLR может завершить работу до завершения управляемого кода под управлением. С помощью `std::set_terminate` и `SIGTERM` может быть вызвано следующими. См. в разделе [константы signal](../c-runtime-library/signal-constants.md) и [set_terminate](../c-runtime-library/abnormal-termination.md) Дополнительные сведения.

## <a name="using-new-visual-c-features"></a>С помощью новых возможностей Visual C++

После компиляции приложения, ссылки и выполняется, вы можете использовать компоненты .NET в любом модуле, скомпилированном с **/CLR**. Дополнительные сведения см. в статье [Расширения компонентов для платформ среды выполнения](../windows/component-extensions-for-runtime-platforms.md).

Если вы использовали управляемых расширений для C++, можно преобразовать код для использования нового синтаксиса. Дополнительные сведения о преобразовании управляемых расширений для C++ см. в разделе [C + +/ CLI Migration Primer](../dotnet/cpp-cli-migration-primer.md).

Сведения о программировании на языке Visual C++ .NET см. в разделе:

- [Программирование .NET с использованием C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)

- [Взаимодействие исходного кода и платформы.NET](../dotnet/native-and-dotnet-interoperability.md)

- [Расширения компонентов для платформ среды выполнения](../windows/component-extensions-for-runtime-platforms.md)

## <a name="see-also"></a>См. также

[Смешанные (собственные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md)
