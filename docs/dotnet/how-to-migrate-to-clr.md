---
title: Практическое руководство. Переход на -clr
ms.custom: get-started-article
ms.date: 09/18/2018
helpviewer_keywords:
- upgrading Visual C++ applications, /clr compiler option
- compiling native code [C++]
- interoperability [C++], /clr compiler option
- interop [C++], /clr compiler option
- migration [C++], /clr compiler option
- /clr compiler option [C++], porting to
ms.assetid: c9290b8b-436a-4510-8b56-eae51f4a9afc
ms.openlocfilehash: 339b1f3172d8b82ece3e98f117f53ed399cbd4e2
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81376071"
---
# <a name="how-to-migrate-to-clr"></a>Практическое руководство. Переход на /clr

Эта тема обсуждает вопросы, возникающие при компиляции родного кода с **/clr** (см./clr [(Общий язык Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md) для получения дополнительной информации). **/clr** позволяет родному коду СЗЗ вызывать и вызываться из сборок .NET в дополнение к другим родным кодам C. Смотрите [Смешанные (родные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md) и [родные и .NET совместимость](../dotnet/native-and-dotnet-interoperability.md) для получения дополнительной информации о преимуществах компиляции с **/clr**.

## <a name="known-issues-compiling-library-projects-with-clr"></a>Известные вопросы Компиляция Библиотечных проектов с /clr

Visual Studio содержит некоторые известные проблемы при составлении библиотечных проектов с **/clr:**

- Ваш код может заметить типы во время выполнения с [CRuntimeClass:: FromName](../mfc/reference/cruntimeclass-structure.md#fromname). Однако, если тип находится в MSIL .dll (компилируется `FromName` с **/clr),** вызов может выйти из строя, если это произойдет до того, как статические конструкторы заработают в управляемом .dll (вы не увидите эту проблему, если вызов FromName произойдет после того, как код выполняется в управляемом .dll). Для решения этой проблемы можно заставить конструкцию управляемого статического конструктора, определив функцию в управляемом .dll, экспортируя ее и ссылаясь на нее из родного приложения MFC. Пример:

    ```
    // MFC extension DLL Header file:
    __declspec( dllexport ) void EnsureManagedInitialization () {
       // managed code that won't be optimized away
       System::GC::KeepAlive(System::Int32::MaxValue);
    }
    ```

## <a name="compile-with-visual-c"></a>Компилируйте с помощью визуального СЗ

Перед использованием **/clr** на любом модуле в вашем проекте, сначала составить и связать ваш родной проект с Visual Studio 2010.

Следующие шаги, следующие в порядке, обеспечивают самый простой путь к **/clr** компиляции. Важно компиляцию и запуск проекта после каждого из этих шагов.

### <a name="versions-prior-to-visual-studio-2003"></a>Версии до визуальной студии 2003

Если вы модернизируете до Visual Studio 2010 от версии до Visual Studio 2003, вы можете увидеть ошибки компилятора, связанные с улучшенным стандартом соответствия ВИзуал 2003

### <a name="upgrading-from-visual-studio-2003"></a>Модернизация от Visual Studio 2003

Проекты, ранее построенные с Visual Studio 2003 также должны быть сначала составлены без **/clr,** как Visual Studio теперь увеличило соответствие ANSI/ISO и некоторые изменения, нарушая. Изменения, которые, вероятно, потребуют наибольшего внимания, это [функции безопасности в CRT.](../c-runtime-library/security-features-in-the-crt.md) Код, который использует CRT, скорее всего, будет производить предупреждения об амортизации. Эти предупреждения могут быть подавлены, но переход на новые [расширенные версии функций CRT, расширенные безопасность,](../c-runtime-library/security-enhanced-versions-of-crt-functions.md) является предпочтительным, поскольку они обеспечивают лучшую безопасность и могут выявить проблемы безопасности в коде.

### <a name="upgrading-from-managed-extensions-for-c"></a>Обновление от управляемых расширений для СЗЗ

Начиная с Visual Studio 2005, код, написанный с управляемыми расширениями для СЗ не будет компилироваться под **/clr**.

## <a name="convert-c-code-to-c"></a>Преобразование C-кода в C

Несмотря на то, что Visual Studio будет компилировать C-файлы, необходимо преобразовать их в C-образную **компиляцию.clr.** Фактическое имя файла не должно быть изменено; Вы можете использовать **/Tp** (см. [/Tc, /Tp, /TC, /TP (Указать тип исходного файла)](../build/reference/tc-tp-tc-tp-specify-source-file-type.md).) Обратите внимание, что, хотя для **/clr**требуются файлы исходного кода СЗЗ, нет необходимости повторно учитывать код для использования объектно-ориентированных парадигм.

C-код, скорее всего, потребует изменений при компиляции в виде файла C. Правила безопасности типа СЗ строги, поэтому конверсии типов должны быть четко определены с отливками. Например, malloc возвращает недействительный указатель, но может быть назначен указателю на любой тип в C с литым:

```
int* a = malloc(sizeof(int));   // C code
int* b = (int*)malloc(sizeof(int));   // C++ equivalent
```

Функционные указатели также строго защищены от типа в СЗ, поэтому следующий код C требует изменения. В СЗ лучше всего создать `typedef` тип указателя функции, а затем использовать этот тип для отливки указателей функций:

```
NewFunc1 = GetProcAddress( hLib, "Func1" );   // C code
typedef int(*MYPROC)(int);   // C++ equivalent
NewFunc2 = (MYPROC)GetProcAddress( hLib, "Func2" );
```

Кроме того, для того, чтобы функции были прототипированы или полностью определены, прежде чем на них можно будет ссылаться или ссылаться.

Идентификаторы, используемые в C-коде, которые, случается, являются ключевыми словами в СЗ (например, **виртуальные,** **новые,** **удалить,** **правда,** **true** **ложные**и т.д.) должны быть переименованы. Как правило, это можно сделать с помощью простых операций поиска и замены.

```
COMObj1->lpVtbl->Method(COMObj, args);  // C code
COMObj2->Method(args);  // C++ equivalent
```

## <a name="reconfigure-project-settings"></a>Перенастройка настроек проекта

После того, как проект компилирует и запускается в Visual Studio 2010, вы должны создать новые конфигурации проекта для **/clr,** а не изменять конфигурации по умолчанию. **/clr** несовместим с некоторыми вариантами компилятора и создание отдельных конфигураций позволяет строить ваш проект как родной или управляемый. При выборе **/clr** в диалоговом поле страниц свойств параметры проекта, не совместимые с **/clr,** отключаются (и параметры отключений автоматически не восстанавливаются, если **/clr** впоследствии не выбран).

### <a name="create-new-project-configurations"></a>Создание новых конфигураций проектов

Для создания конфигурации проекта на основе существующих настроек проекта можно использовать **параметры Copy S From option** in the New Project Configuration **Dialog Box** **(Build** > **Configuration Manager** > **Active Solution Configuration** > **New)** для создания конфигурации проекта на основе существующих настроек проекта. Сделайте это один раз для конфигурации Debug и один раз для конфигурации release. Последующие изменения могут быть применены только к **конфигурациям /clr,** оставляя исходные конфигурации проекта нетронутыми.

Проекты, в которые используются пользовательские правила сборки, могут потребовать дополнительного внимания.

Этот шаг имеет различные последствия для проектов, которые используют makefiles. В этом случае можно настроить отдельную цель сборки или создать из копии оригинала специальную для компиляции **/clr.**

### <a name="change-project-settings"></a>Изменение настроек проекта

**/clr** может быть выбран в среде разработки, следуя инструкциям в [/clr (Общий язык Runtime Compilation)](../build/reference/clr-common-language-runtime-compilation.md). Как упоминалось ранее, этот шаг автоматически отсванет противоречивые настройки проекта.

> [!NOTE]
> При обновлении управляемой библиотеки или веб-сервиса проекта из Visual Studio 2003, **/ L** компилятор вариант будет добавлен на странице свойства **командной строки.** Это вызовет LNK2001. Удалите **/Зл** с страницы свойства **командной строки** для решения. [См/ зл (Название библиотеки Omit Default)](../build/reference/zl-omit-default-library-name.md) и [установить компилятор и построить свойства](../build/working-with-project-properties.md) для получения дополнительной информации. Или добавьте msvcrt.lib и msvcmrt.lib в свойство **дополнительных зависимостей** linker.

Для проектов, построенных с makefiles, несовместимые параметры компилятора должны быть отключены вручную после **добавления /clr.** Смотрите /[/clr Ограничения](../build/reference/clr-restrictions.md) для информации о компилятор вариантов, которые не совместимы с **/clr**.

### <a name="precompiled-headers"></a>Предкомпилированные заголовочные файлы

Предварительно компилированные заголовки поддерживаются под **/clr**. Однако, если вы только компилировать некоторые из ваших файлов CPP с **/clr** (компиляция остальных как родной) некоторые изменения будут необходимы, потому что предварительно собранные заголовки, генерируемые с **/clr** не совместимы с теми, которые генерируются без **/clr**. Эта несовместимость связана с тем, что **/clr** генерирует и требует метаданных. Таким образом, модули, компилированные **/clr,** не могут использовать предварительно собранные заголовки, которые не включают метаданные, а не **-clr-модули** не могут использовать предкомпилированные файлы заголовка, содержащие метаданные.

Самый простой способ компиляции проекта, в котором компилируются некоторые **модули/clr,** — полностью отключить предварительно собранные заголовки. (В диалоге страниц свойств проекта откройте узла C/C и выберите предкомпилированные заголовки. Затем измените свойство «Создание/использование предварительно компилированных заголовков» на «Не используя предварительно собранные заголовки».)

Однако, особенно для крупных проектов, предварительно компиляционные заголовки обеспечивают гораздо лучшую скорость компиляции, поэтому отключение этой функции нежелательно. В этом случае лучше настроить **файлы /clr** и **non/clr** для использования отдельных предварительно собранных заголовков. Это можно сделать в один шаг путем мульти-выбора модулей, которые будут составлены **/clr** с помощью **Solution Explorer,** правого нажатия на группу, и выбора свойств. Затем измените как создание/использование PCH через файл, так и свойства предварительно компилированных файлов заголовка, чтобы использовать другое имя файла заголовка и файл PCH соответственно.

## <a name="fixing-errors"></a>Исправление ошибок

Компиляция с **/clr** может привести к ошибкам компилятора, связующего или времени выполнения. В этом разделе рассматриваются наиболее распространенные проблемы.

### <a name="metadata-merge"></a>Метаданные Слияния

Различные версии типов данных могут привести к сбою связующего, поскольку метаданные, генерируемые для двух типов, не совпадают. (Это обычно происходит, когда члены типа условно определены, но условия не одинаковы для всех файлов CPP, которые используют тип.) В этом случае ссылка не удается, сообщая только имя символа и имя второго файла OBJ, где тип был определен. Часто полезно повернуть порядок отправки файлов OBJ ссылке, чтобы узнать местоположение другой версии типа данных.

### <a name="loader-lock-deadlock"></a>Блокировка погрузчика

"Блокировка загрузчика взаимосвязана" может произойти, но является детерминированной и обнаруживается и сообщается во время выполнения. Подробнее о настройках, рекомендациях и решениях читайте в [инициализации смешанных ассамблей.](../dotnet/initialization-of-mixed-assemblies.md)

### <a name="data-exports"></a>Экспорт данных

Экспорт данных DLL подвержен ошибкам и не рекомендуется. Это связано с тем, что раздел данных DLL не гарантируется инициализоваться до тех пор, пока не будет выполнена некоторая управляемая часть DLL. Справочные метаданные с [директивой #using](../preprocessor/hash-using-directive-cpp.md).

### <a name="type-visibility"></a>Видимость типов

Типы коренных народов являются частными по умолчанию. Это может привести к тому, что родной тип не будет виден за пределами DLL. Устраните `public` эту ошибку, добавив к этим типам.

### <a name="floating-point-and-alignment-issues"></a>Вопросы плавающей точки и выравнивания

`__controlfp`не поддерживается на общем языке времени выполнения (см. [_control87, _controlfp, \__control87_2](../c-runtime-library/reference/control87-controlfp-control87-2.md) для получения дополнительной информации). CLR также не будет уважать [выравнивание.](../cpp/align-cpp.md)

### <a name="com-initialization"></a>Инициализация COM

Общий язык Runtime инициализирует COM автоматически, когда модуль инициализирован (когда COM инициализирован автоматически это делается так, как MTA). В результате явно инициализация COM дает возвратные коды, указывающие на то, что COM уже инициализирован. Попытка явно инициализировать COM с одной моделью потоков, когда CLR уже инициализировал COM на другую модель потоков, может привести к сбою приложения.

Общее время выполнения языка начинается COM как MTA по умолчанию; использовать [/CLRTHREADATTRIBUTE (Установить атрибут потока CLR)](../build/reference/clrthreadattribute-set-clr-thread-attribute.md) для изменения этого.

### <a name="performance-issues"></a>Проблемы с производительностью

Вы можете увидеть снижение производительности, когда родние методы C', генерируемые в MSIL, называются косвенно (виртуальные вызовы функции или с помощью указателей функций). Чтобы узнать больше об этом, [см.](../dotnet/double-thunking-cpp.md)

При переходе от родного к MSIL, вы заметите увеличение размера вашего рабочего набора. Это связано с тем, что время выполнения общего языка обеспечивает множество функций, обеспечивающих правильную приправную работа программ. Если ваше приложение **/clr** работает неправильно, вы можете включить C4793 (выкл по умолчанию), см. [Предупреждение о компиляторе (уровень 1 и 3) C4793](../error-messages/compiler-warnings/compiler-warning-level-1-and-3-c4793.md) для получения дополнительной информации.

### <a name="program-crashes-on-shutdown"></a>Сбои программы при завершении работы

В некоторых случаях CLR может отключиться до завершения работы управляемого кода. Использование `std::set_terminate` `SIGTERM` и может привести к этому. Для получения дополнительной информации смотрите [сигнал константы](../c-runtime-library/signal-constants.md) и [set_terminate.](../c-runtime-library/abnormal-termination.md)

## <a name="using-new-visual-c-features"></a>Использование новых функций Visual C

После того, как приложение компилирует, связывает и запускает, вы можете начать использовать функции .NET в любом модуле, составленном с **помощью /clr**. Дополнительные сведения см. в статье [Расширения компонентов для платформ среды выполнения](../extensions/component-extensions-for-runtime-platforms.md).

Для получения информации о программировании .NET в Visual C е см.:

- [Программирование .NET с использованием C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)

- [Взаимосвязь между коренными жителями и .NET](../dotnet/native-and-dotnet-interoperability.md)

- [Расширения компонентов для платформ среды выполнения](../extensions/component-extensions-for-runtime-platforms.md)

## <a name="see-also"></a>См. также раздел

[Смешанные (родные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md)
