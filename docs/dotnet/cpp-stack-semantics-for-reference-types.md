---
title: Семантика стека C++ для ссылочных типов
ms.date: 11/04/2016
helpviewer_keywords:
- reference types, C++ stack semantics for
ms.assetid: 319a1304-f4a4-4079-8b84-01cec847d531
ms.openlocfilehash: 4d9aaa493eab39199ac75b6b9fe888c3e103f115
ms.sourcegitcommit: 7d64c5f226f925642a25e07498567df8bebb00d4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2019
ms.locfileid: "65448067"
---
# <a name="c-stack-semantics-for-reference-types"></a>Семантика стека C++ для ссылочных типов

До Visual Studio 2005, экземпляр ссылочного типа может создаваться только с помощью `new` оператор, который создал объект в сборке мусора куче. Тем не менее теперь можно создать экземпляр ссылочного типа, используя тот же синтаксис, который используется для создания экземпляра собственного типа в стеке. Таким образом, не нужно использовать [ref new, gcnew](../extensions/ref-new-gcnew-cpp-component-extensions.md) для создания объекта ссылочного типа. И, когда объект выходит за пределы области, компилятор вызывает деструктор объекта.

## <a name="remarks"></a>Примечания

При создании экземпляра типа ссылки, с помощью семантики стека, компилятор внутренним образом создания экземпляра в куче сбора мусора (с помощью `gcnew`).

При подписи или возвращаемого типа функции включает экземпляр ссылочного типа по значению, функция будут помечены в метаданных как требующие специальной обработки (с помощью элементов modreq). Эта специальная обработка является в настоящее время предоставляется только клиентами Visual C++; в настоящее время другие языки не поддерживают много функций или данных, использовать ссылочные типы, созданные с помощью семантики стека.

Одна из причин для использования `gcnew` (динамическое выделение) вместо стека семантику бы, имеет ли тип деструктор. Кроме того с помощью ссылочных типов, созданных с помощью семантики стека сигнатур функций не будет возможно в том случае, если требуется, чтобы ваши функции для использования в языках, отличных от Visual C++.

Компилятор не создает конструктор копии для ссылочного типа. Таким образом Если вы определяете функцию, которая использует типом ссылки по значению в сигнатуре, необходимо определить конструктор копии для ссылочного типа. Конструктор копии для ссылочного типа имеет подпись следующего вида: `R(R%){}`.

Компилятор не создает оператор присваивания по умолчанию для ссылочного типа. Оператор присваивания позволяет создать объект, с помощью семантики стека и инициализируйте его с существующим объектом, созданных с помощью семантики стека. Оператор присваивания для ссылочного типа имеет подпись следующего вида: `void operator=( R% ){}`.

Если ваш тип деструктор освобождает ресурсы, критические и использовании семантики стека для ссылочных типов, не нужно явным образом вызовите деструктор (или вызвать `delete`). Дополнительные сведения о деструкторах в ссылочных типах см. в разделе [деструкторы и методы завершения в разделе: Определение и использование классов и структур (C++выполняет)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers).

Оператор присваивания, созданные компилятором последует за обычные стандартные правила C++ со следующими дополнениями:

- Данные нестатических членов, тип которого является дескриптором ссылочного типа будут shallow скопированный (обрабатываются как нестатические данные-член, тип которого является указателем).

- Любой член нестатических данных, тип которого является типом значения, будет неполную скопированы.

- Любой член нестатических данных, тип которого — это экземпляр ссылочного типа вызовет вызов конструктора копирования ссылочного типа.

Компилятор также предоставляет `%` унарный оператор для преобразования экземпляра ссылочного типа, созданных с помощью семантики стека к его базовому типу дескриптора.

Следующие типы ссылок не доступны для использования с семантикой стека:

- [delegate (расширения компонентов C++)](../extensions/delegate-cpp-component-extensions.md)

- [Массивы](../extensions/arrays-cpp-component-extensions.md)

- <xref:System.String>

## <a name="example"></a>Пример

### <a name="description"></a>Описание

В следующем образце кода показан способ объявления экземпляров ссылочных типов с помощью семантики стека, как оператор присваивания и работает конструктор копирования, а также способы инициализации с ссылочным типом, созданных с помощью семантики стека отслеживаемую ссылку.

### <a name="code"></a>Код

```cpp
// stack_semantics_for_reference_types.cpp
// compile with: /clr
ref class R {
public:
   int i;
   R(){}

   // assignment operator
   void operator=(R% r) {
      i = r.i;
   }

   // copy constructor
   R(R% r) : i(r.i) {}
};

void Test(R r) {}   // requires copy constructor

int main() {
   R r1;
   r1.i = 98;

   R r2(r1);   // requires copy constructor
   System::Console::WriteLine(r1.i);
   System::Console::WriteLine(r2.i);

   // use % unary operator to convert instance using stack semantics
   // to its underlying handle
   R ^ r3 = %r1;
   System::Console::WriteLine(r3->i);

   Test(r1);

   R r4;
   R r5;
   r5.i = 13;
   r4 = r5;   // requires a user-defined assignment operator
   System::Console::WriteLine(r4.i);

   // initialize tracking reference
   R % r6 = r4;
   System::Console::WriteLine(r6.i);
}
```

### <a name="output"></a>Вывод

```Output
98
98
98
13
13
```

## <a name="see-also"></a>См. также

[Классы и структуры](../extensions/classes-and-structs-cpp-component-extensions.md)
