---
title: Инициализация смешанных сборок
ms.date: 03/09/2018
helpviewer_keywords:
- mixed assemblies [C++], loader lock
- loader lock [C++]
- initializing mixed assemblies
- deadlocks [C++]
- .cctor [C++]
- custom locales [C++]
- mixed assemblies [C++], initilizing
ms.assetid: bfab7d9e-f323-4404-bcb8-712b15f831eb
ms.openlocfilehash: 1f4ea7f5cfc6e99390c93ba9c2beadc46fce8584
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50665014"
---
# <a name="initialization-of-mixed-assemblies"></a>Инициализация смешанных сборок

Разработчики Windows необходимо всегда быть настороже, во время блокировки загрузчика, при выполнении кода во время `DllMain`. Однако существуют некоторые дополнительные соображения, которые следует учитывать при работе с использованием C + +/ смешанной сборки среды clr.

Код в [DllMain](/windows/desktop/Dlls/dllmain) не должен иметь доступа к среде CLR. Это означает, что функция `DllMain` не должна вызывать управляемые функции напрямую или косвенно. В функции `DllMain`запрещается объявлять или реализовывать неуправляемый код. В функции `DllMain`запрещается выполнять сборку мусора или автоматическую загрузку библиотек.

## <a name="causes-of-loader-lock"></a>Причины блокировки загрузчика

После введения платформы .NET появились два механизма загрузки исполняемых модулей (EXE или DLL): один для Windows, который используется для неуправляемых модулей, и другой для среды CLR .NET, загружающий сборки .NET. Проблема загрузки смешанных библиотек DLL касается загрузчика ОС Microsoft Windows.

Если в процесс загружается сборка, содержащая только конструкции .NET, загрузчик CLR сам может выполнить все необходимые задачи загрузки и инициализации. Однако для смешанных сборок, поскольку они могут содержать машинный код и неуправляемые данные, необходимо использовать и загрузчик Windows.

Загрузчик Windows гарантирует, что никакая часть кода не получит доступ к коду или данным в этой библиотеке DLL перед тем, как она будет инициализирована, и что никакая часть кода не сможет загрузить DLL, если она частично инициализирована. Для этого загрузчик Windows использует глобальный для всего процесса критический раздел (часто называемый "блокировкой загрузчика"), предотвращающий небезопасное обращение во время инициализации модуля. В результате процесс загрузки является уязвимым для многих случаев взаимоблокировки. Для смешанных сборок следующие две ситуации повышают риск взаимоблокировки.

- Первая ситуация возникает, если пользователи пытаются выполнить функции, скомпилированные в код MSIL, во время блокировки загрузчика (например, в функции `DllMain` или в статических инициализаторах) — это может вызвать взаимоблокировку. Рассмотрим случай, в котором функция MSIL ссылается на тип в еще не загруженной сборке. Среда CLR пытается автоматически загрузить эту сборку, а для этого может потребоваться установить блокировку загрузчика Windows. Поскольку в коде, вызванном ранее, уже происходит блокировка загрузчика, это вызывает взаимоблокировку. Однако выполнение функции MSIL во время блокировки не обязательно приводит к появлению взаимоблокировки, поэтому данную ситуацию трудно диагностировать и исправить. При некоторых обстоятельствах, например если библиотека DLL ссылочного типа и все зависимые от нее модули не содержат неуправляемых конструкций, для загрузки сборки .NET ссылочного типа загрузчик Windows не требуется. Кроме того, требуемая сборка или ее зависимые смешанные неуправляемые модули или модули .NET могли быть загружены другим кодом. Следовательно, взаимоблокировку трудно прогнозировать и вероятность ее возникновения зависит от конфигурации целевого компьютера.

- Вторая ситуация происходит при загрузке библиотек DLL на платформе .NET Framework версии 1.0 и 1.1, когда среда CLR предполагает, что блокировка загрузчика не используется, и выполняет несколько действий, которые являются недопустимыми во время блокировки загрузчика. Предположение об отсутствии блокировки загрузчика верно только для чистых DLL-библиотек .NET, тогда как смешанные библиотеки DLL выполняют неуправляемые процедуры инициализации, для которых требуется загрузчик Windows и, следовательно, блокировка загрузчика. Как следствие, даже если разработчик не пытается выполнить какие-либо функции MSIL во время инициализации библиотеки DLL, все равно есть небольшая вероятность возникновения взаимоблокировки для платформы .NET Framework версии 1.0 и 1.1.

Все недетерминированные ситуации при загрузке смешанных библиотек DLL исключены. Этого удалось достигнуть за счет следующих изменений.

- Среда CLR больше не делает ложных предположений при загрузке смешанных DLL.

- Неуправляемая и управляемая инициализация выполняются на двух отдельных этапах. Сначала выполняется неуправляемая инициализация (через DllMain), а управляемая инициализация выполняется после с помощью поддерживаемой .NET конструкции *.cctor*. Последняя конструкция полностью прозрачная для пользователей, если только не используется параметр **/Zl** или **/NODEFAULTLIB** . Дополнительные сведения см. в разделах[/NODEFAULTLIB (Ignore Libraries)](../build/reference/nodefaultlib-ignore-libraries.md) и [/Zl (Omit Default Library Name)](../build/reference/zl-omit-default-library-name.md) .

Блокировка загрузчика все равно может произойти, но теперь эти случаи можно воспроизвести и обнаружить. Если `DllMain` содержит инструкции MSIL, компилятор выдает предупреждение [Предупреждение компилятора (уровень 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md). Кроме того, либо библиотека CRT, либо среда CLR попытаются определить случаи выполнения функций MSIL во время блокировки загрузчика и сообщат о них, если такие были. Если библиотека CRT обнаруживает попытку, выдается ошибка во время выполнения C R6033

В остальной части этого документа описываются другие случаи выполнения MSIL при блокировке загрузчика, решения для устранения проблем в каждой их этих ситуаций и методы отладки.

## <a name="scenarios-and-workarounds"></a>Ситуации и способы решения проблем

Существует несколько ситуаций, в которых пользовательский код может выполнять функции MSIL во время блокировки загрузчика. Разработчик должен убедиться, что в реализации пользовательского кода не предпринимаются попытки выполнить инструкции MSIL в ситуациях, описанных ниже. В следующих подразделах описываются все возможные ситуации, а также способы решения распространенных проблем.

### <a name="dllmain"></a>DllMain

Функция `DllMain` — это определяемая пользователем точка входа для библиотеки DLL. Если пользователь не указывает иное, функция `DllMain` вызывается каждый раз, когда процесс или поток присоединяется к библиотеке DLL или отсоединяется от нее. Поскольку подобный вызов может произойти во время блокировки загрузчика, запрещается компилировать пользовательские функции `DllMain` в код MSIL. Кроме того, в MSIL нельзя скомпилировать никакую функцию в дереве вызовов с корнем `DllMain` . Для решения этой проблемы блок кода, в котором задается функция `DllMain` , необходимо изменить с помощью директивы #pragma `unmanaged`. То же необходимо сделать для каждой функции, которая вызывается в `DllMain` .

В случаях, когда эти функции должны вызывать функцию, для которой требуется MSIL-реализация для вызова другого контекста, можно использовать стратегию дупликации, согласно которой создается версия .NET и неуправляемая версия одной функции.

Кроме того, если функция `DllMain` не требуется или если она не выполняется при блокировке загрузчика, можно удалить пользовательскую реализацию функции `DllMain` , что решит проблему.

Если DllMain пытается выполнить код MSIL напрямую, выдается [Compiler Warning (level 1) C4747](../error-messages/compiler-warnings/compiler-warning-level-1-c4747.md) . Однако компилятор не может обнаружить ситуации, в которых DllMain вызывает функцию в другом модуле, который, в свою очередь, пытается выполнить код MSIL.

Дополнительные сведения об этой ситуации см. в разделе "Трудности при диагностике".

### <a name="initializing-static-objects"></a>Инициализация статических объектов

Инициализация статических объектов может вызвать взаимоблокировку, если требуется динамический инициализатор. В простых случаях, например когда статической переменной просто присваивается значение, известное на время компиляции, динамическая инициализация не требуется, поэтому нет риска возникновения взаимоблокировки. Однако для статических переменных, инициализируемых при вызове функции, конструктора или инициализируемых выражениями, значения которых получить во время компиляции невозможно, необходимо выполнять код во время инициализации модуля.

В коде, приведенном ниже, показаны примеры статических инициализаторов, для которых требуется динамическая инициализация: вызов функции, конструирование объекта и инициализация указателя. (Эти примеры не статические, но предполагается, что определены глобально, что дает тот же результат.)

```cpp
// dynamic initializer function generated
int a = init();
CObject o(arg1, arg2);
CObject* op = new CObject(arg1, arg2);
```

Возможность возникновения взаимоблокировки зависит от того, скомпилирован ли содержащий модуль с использованием параметра **/clr** и будет ли выполняться код MSIL. Так, если статическая переменная скомпилирована без использования параметра **/clr** (или если она расположена в блоке #pragma `unmanaged` ) и для ее инициализации требуется динамический инициализатор, это может привести к выполнению инструкций MSIL и, как следствие, вызвать взаимоблокировку. Это происходит потому, что для модулей, скомпилированных без использования параметра **/clr**, инициализацию статических переменных выполняет функция DllMain. Напротив, статические переменные, скомпилированные с использованием **/clr** , инициализируются конструкцией .cctor после того, как этап неуправляемой инициализации завершен, а блокировка загрузчика отключена.

Существует несколько способов предотвратить взаимоблокировку, вызванную динамической инициализацией статических переменных (ниже они приблизительно упорядочены по времени, необходимому для решения проблемы).

- Исходный файл, содержащий статическую переменную, можно скомпилировать с использованием параметра **/clr**.

- Все функции, вызываемые статической переменной, можно скомпилировать в машинный код с помощью директивы #pragma `unmanaged` .

- Можно вручную клонируйте код, от которого зависит статическая переменная, создав версию .NET и неуправляемую версию с разными именами. Разработчики могут затем вызвать собственную версию из неуправляемых статических инициализаторов и вызывать версию .NET в других случаях.

### <a name="user-supplied-functions-affecting-startup"></a>Пользовательские функции, влияющие на автозагрузку

Существует несколько пользовательских функций, от которых зависит инициализация библиотек при автозагрузке. Например, при глобальной перегрузке операторов C++, таких как `new` и `delete` операторы, пользовательские версии используются повсеместно, включая стандартной библиотеки C++ инициализацию и уничтожение. В результате стандартной библиотеки C++ и пользователя статические инициализаторы вызывают любые пользовательские, версии этих операторов.

Если они скомпилированы в код MSIL, эти инициализаторы пытаются выполнить инструкции MSIL во время блокировки загрузчика. Предоставленное пользователем `malloc` приводит к тем же последствиям. Для решения этой проблемы все подобные перегрузки или пользовательские определения необходимо реализовать в машинном коде с помощью директивы #pragma `unmanaged` .

Дополнительные сведения об этой ситуации см. в разделе "Трудности при диагностике".

### <a name="custom-locales"></a>Пользовательские языковые стандарты

Если пользователь применяет глобальный пользовательский языковой стандарт, он используется для инициализации всех будущих потоков ввода-вывода, включая статически инициализируемые потоки. Если объект глобального языкового стандарта скомпилирован в код MSIL, функции элемента этого объекта, скомпилированные в MSIL, могут быть вызваны во время блокировки загрузчика.

Существует три способа решения этой проблемы.

Исходные файлы, содержащие все глобальные определения потока ввода-вывода, можно скомпилировать с использованием параметра **/clr** . Это предотвратит выполнение статической инициализации во время блокировки загрузчика.

Определения функций пользовательского языкового стандарта можно скомпилировать в машинный код с помощью директивы #pragma `unmanaged` .

Рекомендуется устанавливать пользовательский языковой стандарт как глобальный языковой стандарт только после отключения блокировки загрузчика. Затем следует явно настроить потоки ввода-вывода, созданные во время инициализации с использованием пользовательского языкового стандарта.

## <a name="impediments-to-diagnosis"></a>Трудности при диагностике

В некоторых случаях сложно обнаружить источник взаимоблокировки. В следующих подразделах описываются эти случаи и способы решения возникающих проблем.

### <a name="implementation-in-headers"></a>Реализация в заголовках

В некоторых случаях реализация функций в файлах заголовка может затруднить диагностику. Для встроенных функций и кода шаблона требуется, чтобы функции были заданы в файле заголовка.  Язык C++ указывает "правило одного определения", которое говорит о том, что все реализации функций с одинаковым именем должны быть семантически эквивалентны. Как следствие, компоновщику C++ не требуются особые предосторожности при слиянии объектных файлов с дублированными реализациями определенной функции.

До Visual Studio 2005 компоновщик просто выбирает самое большое из этих семантически эквивалентных определений, чтобы использовать упреждающие объявления и сценарии, если используются параметры оптимизации для разных исходных файлов. Это создает проблему для смешанных библиотек DLL.

Так как один и тот же заголовок может быть включен как файлами C++ с **/CLR** включенных и отключенных, или #include может быть размещен в #pragma `unmanaged` блок, это может быть MSIL и версии в машинном коде функции, предоставляющие Реализация в заголовках. Эти реализации обладают различной семантикой по отношению к инициализации во время блокировки загрузчика, что нарушает правило одного определения. Как следствие, когда компоновщик выбирает самую большую реализацию, он может выбрать MSIL-реализацию функции, даже если она была явно скомпилирована в машинный код в другой части кода с помощью директивы #pragma unmanaged. Для предотвращения вызова MSIL-версии встроенной функции или шаблона во время блокировки загрузчика в каждое определение подобной функции, вызываемой во время блокировки загрузчика, необходимо добавить директиву #pragma `unmanaged` . Если файл заголовка предоставлен сторонним поставщиком, самый простой способ сделать это — поместить директиву #pragma unmanaged в стек и восстановить ее из стека вокруг директивы #include файла заголовка, вызывающего проблему. (См. в разделе [управляемые, неуправляемые](../preprocessor/managed-unmanaged.md) пример.) Однако этот метод не действует для заголовков, содержащих другой код, который напрямую вызывает API-интерфейсы .NET.

Для удобства пользователей, решающих проблему блокировку загрузчика, компоновщик выбирает реализацию на машинном, а не управляемом коде, если существует две версии реализации. Это позволяет предотвратить проблемы, описанные выше. Однако в этой версии существуют два исключения из этого правила из-за двух нерешенных проблем компилятора.

- Вызов встроенной функции происходит через указатель глобальной статической функции. Эта ситуация важна, так как виртуальные функции вызываются через указатели глобальной функции. Например, примененная к объекту директива

```cpp
#include "definesmyObject.h"
#include "definesclassC.h"

typedef void (*function_pointer_t)();

function_pointer_t myObject_p = &myObject;

#pragma unmanaged
void DuringLoaderlock(C & c)
{
    // Either of these calls could resolve to a managed implementation,
    // at link-time, even if a native implementation also exists.
    c.VirtualMember();
    myObject_p();
}
```

### <a name="diagnosing-in-debug-mode"></a>Диагностика в режиме отладки

Вся диагностика проблем блокировки загрузчика должна проходить в отладочных построениях. В сборках выпуска диагностика может не дать результатов, а оптимизация в режиме выпуска может скрыть некоторые вызовы MSIL во время блокировки загрузчика.

## <a name="how-to-debug-loader-lock-issues"></a>Отладка проблем при блокировке загрузчика

Диагностика, которую создает среда CLR при вызове функции MSIL, приводит к тому, что CLR приостанавливает выполнение. Это, в свою очередь, приводит к тому, что отладчик смешанного режима Visual C++ также приостанавливает выполнение отлаживаемого кода. Однако при присоединении к процессу невозможно получить управляемый стек вызовов для отлаживаемого кода с помощью смешанного отладчика.

Чтобы определить конкретную функцию MSIL, вызванную во время блокировки загрузчика, разработчики должны выполнить следующие действия.

1. Убедитесь, что доступны символы для библиотек mscoree.dll и mscorwks.dll.

   Это можно сделать двумя способами. Первый способ заключается в том, что PDB-файлы для библиотек mscoree.dll и mscorwks.dll можно добавить к пути поиска. Для этого откройте диалоговое окно параметров пути поиска символов. (Из **средства** меню, выберите **параметры**. В левой части **параметры** , открытом окне **Отладка** узел и выберите **символы**.) Добавьте путь к PDB-файлам библиотек mscoree.dll и mscorwks.dll в список поиска. Эти файлы устанавливаются в каталог % VSINSTALLDIR%\SDK\v2.0\symbols. Нажмите кнопку **ОК**.

   Второй способ заключается в том, что PDB-файлы для mscoree.dll и mscorwks.dll можно загрузить с сервера символов Майкрософт. Для настройки сервера символов откройте диалоговое окно параметров пути поиска символов. (Из **средства** меню, выберите **параметры**. В левой части **параметры** , открытом окне **Отладка** узел и выберите **символы**.) Добавить следующий путь поиска в список поиска: http://msdl.microsoft.com/download/symbols. Добавьте каталог кэша символов в текстовом поле кэша сервера символов. Нажмите кнопку **ОК**.

1. Для отладчика установите режим отладки только машинного кода.

   Чтобы сделать это, откройте **свойства** сетки для запускаемого проекта в решении. Выберите **свойства конфигурации** > **отладки**. Задайте **тип отладчика** для **только машинный код**.

1. Запустите отладчик (F5).

1. Когда **/CLR** создания диагностики, выберите **повторите** и выберите **прервать**.

1. Откройте окно "Стек вызовов". (В строке меню выберите **Отладка** > **Windows** > **стек вызовов**.) Они отмечаются `DllMain` или статический инициализатор вызывают неполадки Стрелка зеленого цвета. Если функция, вызывающая неполадки, не определена, необходимо выполнить следующие действия, чтобы найти ее.

1. Откройте **Интерпретация** окна (в строке меню выберите **Отладка** > **Windows** > **Интерпретация**.)

1. Введите ". Load.SOS.dll" в **Интерпретация** окно, чтобы загрузить службу отладки SOS.

1. Тип! dumpstack в **Интерпретация** окно, чтобы получить полный список внутренних **/CLR** стека.

1. Производят поиск первого вхождения (близкий ко дну стека) _CorDllMain (если `DllMain` вызывающий проблему) или первый экземпляр _VTableBootstrapThunkInitHelperStub или GetTargetForVTableEntry (Если проблему вызывает статический инициализатор). Запись в стеке сразу под этим вызовом является вызовом функции, реализованной в коде MSIL, которая была вызвана во время блокировки загрузчика.

1. Перейдите в исходный файл и номер, указанный на предыдущем шаге и правильный строки проблему, используя сценарии и решения, описанные в разделе "ситуации".

## <a name="example"></a>Пример

### <a name="description"></a>Описание

Следующий пример показано, как избежать блокировки загрузчика, переместив код из `DllMain` в конструктор глобального объекта.

В этом примере имеется глобальный управляемый объект, чей конструктор содержит управляемый объект, первоначально располагающийся в `DllMain`. Во второй части примера присутствует ссылка на сборку, создание экземпляра управляемого объекта для вызова конструктора модуля, который производит инициализацию.

### <a name="code"></a>Код

```cpp
// initializing_mixed_assemblies.cpp
// compile with: /clr /LD
#pragma once
#include <stdio.h>
#include <windows.h>
struct __declspec(dllexport) A {
   A() {
      System::Console::WriteLine("Module ctor initializing based on global instance of class.\n");
   }

   void Test() {
      printf_s("Test called so linker does not throw away unused object.\n");
   }
};

#pragma unmanaged
// Global instance of object
A obj;

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
   // Remove all managed code from here and put it in constructor of A.
   return true;
}
```

В этом примере показаны проблемы в Инициализация смешанных сборок:

```cpp
// initializing_mixed_assemblies_2.cpp
// compile with: /clr initializing_mixed_assemblies.lib
#include <windows.h>
using namespace System;
#include <stdio.h>
#using "initializing_mixed_assemblies.dll"
struct __declspec(dllimport) A {
   void Test();
};

int main() {
   A obj;
   obj.Test();
}
```

Этот код выводит следующие результаты:

```Output
Module ctor initializing based on global instance of class.

Test called so linker does not throw away unused object.
```

## <a name="see-also"></a>См. также

[Смешанные (собственные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md)
