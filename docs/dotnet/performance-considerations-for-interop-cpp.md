---
description: 'Дополнительные сведения: рекомендации по производительности для взаимодействия (C++)'
title: Вопросы производительности взаимодействия (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- /clr compiler option [C++], interop performance considerations
- platform invoke [C++], interoperability
- interop [C++], performance consideraitons
- mixed assemblies [C++], performance considerations
- interoperability [C++], performance considerations
ms.assetid: bb9a282e-c3f8-40eb-a2fa-45d80d578932
ms.openlocfilehash: 29723f0ea5c7b745100ab4c7abb7f59abce47db6
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97255565"
---
# <a name="performance-considerations-for-interop-c"></a>Вопросы производительности взаимодействия (C++)

В этом разделе приводятся рекомендации по уменьшению влияния управляемых и неуправляемых переходов взаимодействия на производительность во время выполнения.

Visual C++ поддерживает те же механизмы взаимодействия, что и другие языки .NET, такие как Visual Basic и C# (P/Invoke), но также обеспечивает поддержку взаимодействия, характерную для Visual C++ (взаимодействие C++). Для приложений, критически важных для производительности, важно понимать влияние каждого метода взаимодействия на производительность.

Независимо от используемого метода взаимодействия, специальные последовательности переходов, называемые преобразователями, требуются каждый раз, когда управляемая функция вызывает неуправляемую функцию и наоборот. Эти преобразователи автоматически вставляются компилятором Microsoft C++, но важно помнить, что эти переходы могут быть дорогостоящими с точки зрения производительности.

## <a name="reducing-transitions"></a>Сокращение переходов

Одним из способов избежать или снижения затрат на преобразователи взаимодействия является рефакторинг интерфейсов, задействованных для уменьшения управляемого и неуправляемого перехода. Существенное улучшение производительности можно сделать, нажимая на неуправляемые интерфейсы, которые часто вызываются через управляемую и неуправляемых границы. Например, управляемая функция, которая вызывает неуправляемую функцию в строгом цикле, является хорошим кандидатом для рефакторинга. Если цикл перемещается на неуправляемую сторону или если создается управляемая альтернатива неуправляемому вызову (возможно, данные помещаются в очередь на управляемой стороне, а затем выполняется их передача в неуправляемый API сразу после цикла), число переходов может значительно снизиться.

## <a name="pinvoke-vs-c-interop"></a>Сравнение P/Invoke с C++ Interop

Для языков .NET, таких как Visual Basic и C#, предписанным методом для взаимодействия с собственными компонентами является P/Invoke. Так как P/Invoke поддерживается .NET Framework, Visual C++ также поддерживает его, но Visual C++ также предоставляет собственную поддержку взаимодействия, которая называется взаимодействием C++. Взаимодействие C++ предпочтительнее P/Invoke, так как вызов P/Invoke не является типобезопасным. В результате ошибки в основном сообщаются во время выполнения, но взаимодействие C++ также имеет преимущества производительности по сравнению с P/Invoke.

При вызове управляемой функцией неуправляемой функции для обоих методов необходимо выполнить несколько действий:

- Аргументы вызова функции маршалируются из среды CLR в собственные типы.

- Выполняется преобразователь управляемого и неуправляемого кода.

- Вызывается неуправляемая функция (с использованием собственных версий аргументов).

- Выполняется преобразователь неуправляемого кода.

- Тип возвращаемого значения и все аргументы "out" и "in; out" маршалируются из машинного типа в типы CLR.

Управляемые и неуправляемые преобразователи необходимы для работы взаимодействия, но требуемый маршалинг данных зависит от используемых типов данных, сигнатуры функции и того, как будут использоваться данные.

Маршалинг данных, выполняемый с помощью взаимодействия C++, является простейшей формой: параметры просто копируются через управляемую и неуправляемую границу побитовым образом. преобразование не выполняется. Для P/Invoke это справедливо только в том случае, если все параметры являются простыми преобразуемыми типами. В противном случае P/Invoke выполняет очень надежные действия для преобразования каждого управляемого параметра в соответствующий собственный тип, и наоборот, если аргументы помечены как "out" или "in; out".

Другими словами, взаимодействие C++ использует самый быстрый способ маршалинга данных, в то время как P/Invoke использует самый надежный метод. Это означает, что взаимодействие C++ (в стандартном для C++) обеспечивает оптимальную производительность по умолчанию, и программист отвечает за устранение случаев, когда такое поведение ненадежно или неприемлемо.

Поэтому взаимодействие с C++ требует, чтобы маршалинг данных был явно предоставлен, но преимущество заключается в том, что программист может решить, что подходит, учитывая природу данных и как они будут использоваться. Более того, несмотря на то, что поведение маршалинга данных P/Invoke можно изменить в соответствии с определенной степенью, взаимодействие C++ позволяет настроить маршалинг данных на основе вызова по требованию. Это невозможно сделать с помощью P/Invoke.

Дополнительные сведения о взаимодействии C++ см. [в разделе Использование взаимодействия c++ (неявный PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md).

## <a name="see-also"></a>См. также раздел

[Смешанные (собственные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md)
