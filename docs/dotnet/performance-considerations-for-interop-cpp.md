---
title: Вопросы производительности взаимодействия (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- /clr compiler option [C++], interop performance considerations
- platform invoke [C++], interoperability
- interop [C++], performance consideraitons
- mixed assemblies [C++], performance considerations
- interoperability [C++], performance considerations
ms.assetid: bb9a282e-c3f8-40eb-a2fa-45d80d578932
ms.openlocfilehash: 29dbfa6465f6bcbcf4d0618b1820e59a8edbd3a3
ms.sourcegitcommit: 7d64c5f226f925642a25e07498567df8bebb00d4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2019
ms.locfileid: "65447253"
---
# <a name="performance-considerations-for-interop-c"></a>Вопросы производительности взаимодействия (C++)

Этот раздел содержит рекомендации по уменьшению влияния управляемых и неуправляемых переходов взаимодействия на производительность во время выполнения.

Visual C++ поддерживает тот же механизм взаимодействия в других языках .NET, таких как Visual Basic и C# (P/Invoke), но он также поддерживает взаимодействия, относящиеся к Visual C++ (C++ взаимодействие). Для приложений важно понимать последствия для производительности каждого метода взаимодействия.

Независимо от используемого метода взаимодействия специальные последовательности передачи, называемые преобразователями, требуются каждый раз, управляемой функции вызывает неуправляемой функции и наоборот. Эти преобразователи автоматически вставляются корпорацией Майкрософт C++ компилятора, но важно помнить, что все вместе, эти переходы могут быть затратными с точки зрения производительности.

## <a name="reducing-transitions"></a>Уменьшение количества передач

Один из способов снижения влияния преобразователей взаимодействия заключается в реструктуризации интерфейсов, необходимых свести к минимуму переходы управляемым и неуправляемым кодом. Значительного повышения производительности можно достичь, неаккуратные интерфейсы, которые вовлеченные часто использовать вызовы в границах управляемым и неуправляемым кодом. Например, управляемую функцию, которая вызывает неуправляемую функцию в непрерывном цикле, является хорошим кандидатом для оптимизации кода. Если цикл перемещается в неуправляемом коде, или управляемую альтернативу вызова неуправляемого создается (возможно постановки данных в управляемом коде и затем маршалинга в неуправляемый API после цикла), количество переходов, может быть уменьшен входа ificantly.

## <a name="pinvoke-vs-c-interop"></a>Vs P/Invoke. взаимодействие C++

Для языков .NET, например Visual Basic и C# предписанным методом для взаимодействия с собственными компонентами является P/Invoke. Так как P/Invoke поддерживается платформой .NET Framework, она также поддерживается Visual C++, но Visual C++ также представлена поддержка взаимодействия, который называется взаимодействия C++. Взаимодействие C++ предпочтительнее P/Invoke, так как P/Invoke не является строго типизированным. В результате возникают ошибки во время выполнения, но взаимодействие C++ также имеет преимущество в производительности перед P/Invoke.

Для обоих методов требуется несколько действий при вызове неуправляемой функции управляемой функцией:

- Аргументы функции маршалируются из среды CLR в собственные типы.

- Преобразователь управляемого и неуправляемого выполнения.

- Неуправляемая функция вызывается (с помощью собственных версий аргументов).

- Выполняется неуправляемого к управляемому преобразованию.

- Тип возвращаемого значения и любые «out» или «в, out» аргументы маршалируются из исходного в типы CLR.

Преобразователи управляемым и неуправляемым кодом необходимы для взаимодействия, чтобы вообще работать, но маршалинг данных, которая необходима зависит от используемых типов данных, в сигнатуре функции и использования данных.

Маршалинг данных с помощью взаимодействия C++ является самым простым: параметры просто копируются через границы управляемого и неуправляемого побитовое образом; преобразования не выполняется вообще. Для P/Invoke, это только значение true, если все параметры являются простыми непреобразуемых типов. В противном случае P/Invoke выполняет очень сложные действия для преобразования каждого управляемого параметра в соответствующий тип собственного, и наоборот в том случае, если аргументы помечаются как «out» или «в, out».

Другими словами взаимодействия C++ использует самый быстрый из возможных способов маршалинга данных, а P/Invoke самый трудоемкий метод. Это означает, что взаимодействия C++ (в манере, типичной для C++) обеспечивает оптимальную производительность, по умолчанию, что программист несет ответственность за определение случаев, где это поведение не является безопасным или подходящим.

Для взаимодействия C++ требуется маршалинг данных должен быть предоставлен явно, что удобен тем, что программист может решить, что является более подходящим с учетом характера данных и как он будет использоваться. Кроме того несмотря на то, что поведение маршалинга данных P/Invoke могут изменяться в в определенной степени настроены, взаимодействия C++ позволяет настраивать на основе вызова по вызову маршалинг данных. Это не поддерживается с помощью P/Invoke.

Дополнительные сведения о взаимодействии C++ см. в разделе [с помощью взаимодействия C++ (неявный PInvoke)](../dotnet/using-cpp-interop-implicit-pinvoke.md).

## <a name="see-also"></a>См. также

[Смешанные (собственные и управляемые) сборки](../dotnet/mixed-native-and-managed-assemblies.md)
