---
title: Практическое руководство. Организация выходных файлов проекта для построения
ms.date: 11/04/2016
helpviewer_keywords:
- Visual C++, output files
- output files, organizing
ms.assetid: 521d95ea-2dcc-4da0-b5eb-ac3e57941446
ms.openlocfilehash: 9dd70f52c79d00282122f935b19770b973901103
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50575972"
---
# <a name="how-to-organize-project-output-files-for-builds"></a>Практическое руководство. Организация выходных файлов проекта для построения

Этот раздел описывает рекомендации по упорядочению выходных файлов проекта. Ошибки сборки могут быть вызваны неправильной настройкой выходных файлов проекта. Кроме того, этот раздел описывает преимущества и недостатки каждого из вариантов упорядочения выходных файлов проекта.

## <a name="referencing-clr-assemblies"></a>Ссылки на сборки CLR

#### <a name="to-reference-assemblies-with-using"></a>Ссылка на сборки с помощью #using

1. Вы можете сослаться на сборку прямо из кода с помощью директивы #using, например `#using <System.Data.dll>`. Дополнительные сведения см. в разделе [Директива using](../preprocessor/hash-using-directive-cpp.md).

   Указанный файл может иметь тип DLL, EXE, NETMODULE или OBJ при условии, что он относится к MSIL. Компонент, на который указывает ссылка, может быть создан на любом языке. При использовании этого варианта вы получите доступ к IntelliSense, так как метаданные извлекаются из MSIL. Соответствующий файл должен находиться в пути к проекту; в противном случае проект не будет компилироваться, а технология IntelliSense будет недоступна. Быстро определить, находится ли файл в по данному пути, можно, щелкнув правой кнопкой мыши строку #using и выбрав команду **Открыть документ**. Вы получите уведомление, если файл не удается найти.

   Если вы не хотите указывать полный путь к файлу, можете использовать параметр компилятора **/AI**, чтобы изменить путь поиска для ссылок #using. Дополнительные сведения см. в разделе [/AI (указание каталогов метаданных)](../build/reference/ai-specify-metadata-directories.md).

#### <a name="to-reference-assemblies-with-fu"></a>Ссылка на сборки с помощью /FU

1. Вместо ссылки на сборку прямо из файла кода, как описано выше, можно использовать параметр компилятора **/FU**. Преимуществом этого метода является то, что вам не нужно добавлять отдельный оператор #using в каждый файл, ссылающийся на данную сборку.

   Чтобы задать этот параметр, откройте **Страницы свойств** для проекта. Разверните узлы **Свойства конфигурации** и **C/C++** и выберите **Дополнительно**. Добавьте необходимые сборки в рядом с элементом **Принудительное #using**. Дополнительные сведения см. в разделе [/FU (именование файла с принудительно используемым атрибутом #using)](../build/reference/fu-name-forced-hash-using-file.md).

#### <a name="to-reference-assemblies-with-add-new-reference"></a>Ссылка на сборки с помощью параметра "Добавить новую ссылку"

1. Это простейший способ для использования ссылок CLR. Сначала убедитесь, что проект компилируется с параметром компилятора **/clr**. Затем щелкните проект в **обозревателе решений** правой кнопкой мыши, выберите элемент **Добавить** и **Ссылки**. Открывается диалоговое окно **Страницы свойств**.

1. В диалоговом окне **Страницы свойств** выберите **Добавить новую ссылку**. Открывается диалоговое окно с списком всех .NET, COM и других сборок, доступных в текущем проекте. Выберите нужную сборку и нажмите кнопку **ОК**.

   После задания ссылки на проект соответствующие зависимости обрабатываются автоматически. Кроме того, так как метаданные являются частью сборки, не нужно добавлять файл заголовка или создавать прототип элементов, используемых из управляемых сборок.

## <a name="referencing-native-dlls-or-static-libraries"></a>Ссылки на собственные библиотеки DLL или статические библиотеки

#### <a name="to-reference-native-dlls-or-static-libraries"></a>Создание ссылок на собственные библиотеки DLL или статические библиотеки

1. Вы можете сослаться на соответствующий файл заголовка в коде с помощью директивы #include. Файл заголовка должен находиться в пути включения включаемых файлов или являться частью текущего проекта. Дополнительные сведения см. в разделе [Директива #include (C/C++)](../preprocessor/hash-include-directive-c-cpp.md).

1. Можно также задать зависимости проекта. Это гарантирует две вещи. Во-первых, гарантирует, что сборка проектов выполняется в правильном порядке, чтобы проект всегда мог найти нужные зависимые файлы. Во-вторых, неявно добавляет выходной каталог зависимого проекта в путь, чтобы можно было легко найти файлы во время компоновки.

1. Для развертывания приложения нужно поместить библиотеку DLL в подходящее место. Оно может быть одним из следующих.

   1. Путь к исполняемому файлу.

   1. Любое место внутри системного пути (переменная среды **path**).

   1. В параллельной сборке. Дополнительные сведения см. в разделе [Построение параллельных сборок C/C++](../build/building-c-cpp-side-by-side-assemblies.md).

## <a name="working-with-multiple-projects"></a>Работа с несколькими проектами

По умолчанию проекты создаются таким образом, что все выходные файлы создаются в подкаталоге каталога проекта. Имя этого каталога задается на основе конфигурации сборки (например, Debug или Release). Чтобы проекты того же уровня могли ссылаться друг на друга, каждый проект должен явно добавлять выходные каталоги других проектов в свой путь успешной компоновки. Это выполняется автоматически при задании зависимостей проекта. Тем не менее, если вы не используете зависимости, нужно соблюдать осторожность, так как управление сборками может быть сильно затруднено. Например, если проект имеет конфигурации Debug и Release, а также включает внешнюю библиотеку проекта из того же уровня, он должен использовать разные файлы библиотеки в зависимости от конфигурации, для которой осуществляется сборка. Таким образом, попытка жестко запрограммировать эти пути может вызывать проблемы.

Все основные выходные файлы (например, исполняемые файлы, файлы инкрементного компоновщика и PDB-файлы) копируются в общий каталог решения. Таким образом, при работе с решением, содержащим несколько проектов C++ с аналогичными конфигурациями, все выходные файлы обрабатываются централизовано, чтобы упростить компоновку и развертывание. Вы можете быть уверены в правильной работе приложения или библиотеки, если эти файлы хранятся вместе (так как файлы гарантированно попадают в этот путь).

Расположение выходных файлов может стать источником проблем при развертывании в рабочей среде. При запуске проектов в интегрированной среде разработки пути к включенным библиотекам необязательно являются такими же, как в рабочей среде. Например, если в коде есть `#using "../../lib/debug/mylib.dll"`, а вы развертываете mylib.dll в другом относительном положении, приложение завершится с ошибкой во время выполнения. Чтобы это не произошло, следует избегать использования относительных путей в операторах #include в коде. Лучше убедитесь, что необходимые файлы находятся в пути сборки проекта, а соответствующие рабочие файлы размещены правильно.

#### <a name="how-to-specify-where-output-files-go"></a>Указание расположения для выходных файлов

1. Расположение выходных параметров проекта можно найти на **страницах свойств** проекта. Разверните узел рядом с элементом **Свойства конфигурации** и выберите элемент **Общие**. Расположение выходных данных указывается рядом с элементом **Выходной каталог**. Дополнительные сведения см. в разделе [Страница свойств "Общие" (проект)](../ide/general-property-page-project.md).

## <a name="see-also"></a>См. также

[Типы проектов Visual C++](../ide/visual-cpp-project-types.md)