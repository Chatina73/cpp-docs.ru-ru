---
description: 'Дополнительные сведения: схемы сообщений (ATL)'
title: Схемы сообщений (ATL)
ms.date: 11/04/2016
ms.topic: reference
helpviewer_keywords:
- message maps, ATL
- ATL, message handlers
ms.assetid: 9e100400-65c7-4a85-8857-4e6cb6dd7340
ms.openlocfilehash: c5b3340abbfbc66ac710ab716e3daa38dd7cd6df
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97159522"
---
# <a name="message-maps-atl"></a>Схемы сообщений (ATL)

Схема сообщений связывает функцию обработчика с определенным сообщением, командой или уведомлением. С помощью [макросов схемы сообщений](../atl/reference/message-map-macros-atl.md)ATL можно указать схему сообщений для окна. Оконные процедуры в `CWindowImpl` , `CDialogImpl` и `CContainedWindowT` направляют сообщения окна на схему сообщений.

[Функции обработчика сообщений](../atl/message-handler-functions.md) принимают дополнительный аргумент типа `BOOL&` . Этот аргумент указывает, было ли сообщение обработано, и по умолчанию имеет значение TRUE. Затем функция обработчика может установить аргумент в значение FALSE, чтобы указать, что он не обработал сообщение. В этом случае ATL будет по-прежнему искать функцию обработчика на схеме сообщений. Установив этот аргумент в значение FALSE, можно сначала выполнить какое-либо действие в ответ на сообщение, а затем разрешить обработку сообщения по умолчанию или другой функции обработчика.

## <a name="chained-message-maps"></a>Связанные схемы сообщений

ATL также позволяет создавать цепочки карт сообщений, которые направляют обработку сообщений в схему сообщений, определенную в другом классе. Например, можно реализовать общую обработку сообщений в отдельном классе, чтобы обеспечить единообразное поведение для всех цепочек окон в этом классе. Можно создать цепочку для базового класса или элемента данных класса.

ATL также поддерживает динамическое связывание, которое позволяет связать с картой сообщений другого объекта во время выполнения. Для реализации динамической цепочки необходимо создать класс, производный от [кдинамикчаин](../atl/reference/cdynamicchain-class.md). Затем объявите макрос [CHAIN_MSG_MAP_DYNAMIC](reference/message-map-macros-atl.md#chain_msg_map_dynamic) в схеме сообщений. CHAIN_MSG_MAP_DYNAMIC требуется уникальный номер, определяющий объект и схему сообщения, с которой выполняется связывание. Это уникальное значение необходимо определить с помощью вызова `CDynamicChain::SetChainEntry` .

Можно создать цепочку для любого класса, объявляющего схему сообщений, при условии, что класс является производным от [кмессажемап](../atl/reference/cmessagemap-class.md). `CMessageMap` позволяет объекту предоставлять свои карты сообщений другим объектам. Обратите внимание, что `CWindowImpl` уже является производным от `CMessageMap` .

## <a name="alternate-message-maps"></a>Альтернативные схемы сообщений

Наконец, ATL поддерживает альтернативные схемы сообщений, объявленные с помощью макроса [ALT_MSG_MAP](reference/message-map-macros-atl.md#alt_msg_map) . Каждая альтернативная схема сообщения определяется уникальным числом, которое передается в ALT_MSG_MAP. С помощью альтернативных схем сообщений можно управлять сообщениями нескольких окон в одном сопоставлении. Обратите внимание, что по умолчанию не `CWindowImpl` используются альтернативные схемы сообщений. Чтобы добавить эту поддержку, переопределите `WindowProc` метод в `CWindowImpl` классе, производном от, и вызовите `ProcessWindowMessage` его с помощью идентификатора схемы сообщения.

## <a name="see-also"></a>См. также раздел

[Реализация окна](../atl/implementing-a-window.md)
