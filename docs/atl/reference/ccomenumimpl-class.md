---
title: Класс Ккоменумимпл
ms.date: 11/04/2016
f1_keywords:
- CComEnumImpl
- ATLCOM/ATL::CComEnumImpl
- ATLCOM/ATL::CComEnumImpl::CComEnumImpl
- ATLCOM/ATL::CComEnumImpl::Clone
- ATLCOM/ATL::CComEnumImpl::Init
- ATLCOM/ATL::CComEnumImpl::Next
- ATLCOM/ATL::CComEnumImpl::Reset
- ATLCOM/ATL::CComEnumImpl::Skip
- ATLCOM/ATL::CComEnumImpl::m_begin
- ATLCOM/ATL::CComEnumImpl::m_dwFlags
- ATLCOM/ATL::CComEnumImpl::m_end
- ATLCOM/ATL::CComEnumImpl::m_iter
- ATLCOM/ATL::CComEnumImpl::m_spUnk
helpviewer_keywords:
- CComEnumImpl class
ms.assetid: cc0d8e76-e608-46db-87cd-4c7161fe32d2
ms.openlocfilehash: 7d26c59a38bfe43e49215fbb6108453e10ca6dea
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69497173"
---
# <a name="ccomenumimpl-class"></a>Класс Ккоменумимпл

Этот класс предоставляет реализацию для интерфейса перечислителя COM, в котором перечисляемые элементы хранятся в массиве.

## <a name="syntax"></a>Синтаксис

```
template <class Base,
    const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : public Base
```

#### <a name="parameters"></a>Параметры

*Из*<br/>
Интерфейс перечислителя COM. Пример см. в разделе [иенумстринг](/windows/win32/api/objidl/nn-objidl-ienumstring) .

*пиид*<br/>
Указатель на идентификатор интерфейса интерфейса перечислителя.

*T*<br/>
Тип элемента, предоставляемого интерфейсом перечислителя.

*Copy*.<br/>
Однородный [класс политики копирования](../../atl/atl-copy-policy-classes.md).

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|name|Описание|
|----------|-----------------|
|[Ккоменумимпл:: Ккоменумимпл](#ccomenumimpl)|Конструктор.|
|[Ккоменумимпл:: ~ Ккоменумимпл](#dtor)|Деструктор|

### <a name="public-methods"></a>Открытые методы

|name|Описание|
|----------|-----------------|
|[Ккоменумимпл:: Clone](#clone)|Реализация метода интерфейса перечисления **клонов** .|
|[Ккоменумимпл:: init](#init)|Инициализирует перечислитель.|
|[CComEnumImpl::Next](#next)|Реализация **Next**.|
|[Ккоменумимпл:: Reset](#reset)|Реализация метода **Reset**.|
|[Ккоменумимпл:: Skip](#skip)|Реализация метода **Skip**.|

### <a name="public-data-members"></a>Открытые члены данных

|name|Описание|
|----------|-----------------|
|[Ккоменумимпл:: m_begin](#m_begin)|Указатель на первый элемент в массиве.|
|[Ккоменумимпл:: m_dwFlags](#m_dwflags)|Копирование флагов, `Init`переданных через.|
|[Ккоменумимпл:: m_end](#m_end)|Указатель на расположение непосредственно за последним элементом в массиве.|
|[Ккоменумимпл:: m_iter](#m_iter)|Указатель на текущий элемент в массиве.|
|[Ккоменумимпл:: m_spUnk](#m_spunk)|`IUnknown` Указатель объекта, который предоставляет перечисление коллекции.|

## <a name="remarks"></a>Примечания

Пример реализации метода см. в разделе [иенумстринг](/windows/win32/api/objidl/nn-objidl-ienumstring) . `CComEnumImpl`предоставляет реализацию для интерфейса перечислителя COM, в котором перечисляемые элементы хранятся в массиве. Этот класс аналогичен `IEnumOnSTLImpl` классу, который предоставляет реализацию интерфейса перечислителя на основе контейнера C++ стандартной библиотеки.

> [!NOTE]
>  Дополнительные сведения о дальнейших различиях `IEnumOnSTLImpl`между `CComEnumImpl` и см. в разделе [ккоменумимпл:: init](#init).

Как правило, *не* требуется создавать собственный класс перечислителя, производный от реализации этого интерфейса. Если вы хотите использовать перечислитель, предоставляемый библиотекой ATL, на основе массива, чаще всего создается экземпляр [ккоменум](../../atl/reference/ccomenum-class.md).

Однако, если необходимо предоставить пользовательский перечислитель (например, интерфейс, предоставляющий интерфейсы в дополнение к интерфейсу перечислителя), можно создать производный от этого класса. В этом случае, скорее всего, потребуется переопределить метод [ккоменумимпл:: Clone](#clone) , чтобы обеспечить собственную реализацию.

Дополнительные сведения см. в разделе [коллекции и перечислители ATL](../../atl/atl-collections-and-enumerators.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`Base`

`CComEnumImpl`

## <a name="requirements"></a>Требования

**Заголовок:** атлком. h

##  <a name="ccomenumimpl"></a>Ккоменумимпл:: Ккоменумимпл

Конструктор.

```
CComEnumImpl();
```

##  <a name="dtor"></a>Ккоменумимпл:: ~ Ккоменумимпл

Деструктор

```
~CComEnumImpl();
```

##  <a name="init"></a>Ккоменумимпл:: init

Этот метод необходимо вызывать перед передачей указателя на интерфейс перечислителя обратно клиентам.

```
HRESULT Init(
    T* begin,
    T* end,
    IUnknown* pUnk,
    CComEnumFlags flags = AtlFlagNoCopy);
```

### <a name="parameters"></a>Параметры

*begin*<br/>
Указатель на первый элемент массива, содержащий элементы для перечисления.

*end*<br/>
Указатель на расположение сразу за последним элементом массива, содержащего элементы для перечисления.

*pUnk*<br/>
окне `IUnknown` Указатель объекта, который должен храниться в активном состоянии в течение времени существования перечислителя. Если такой объект не существует, передается значение NULL.

*flags*<br/>
Флаги, указывающие, должен ли перечислитель перестать владельцем массива или создать его копию. Возможные значения описаны ниже.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Примечания

Вызывайте этот метод только один раз — инициализируйте перечислитель, используйте его, а затем отбрасывает.

Если передаются указатели на элементы массива, хранящегося в другом объекте (и вы не запрашиваете перечислитель для копирования данных), можно использовать параметр *Punk* , чтобы убедиться, что объект и содержащийся в нем массив доступны, пока они необходимы перечислителю. Перечислитель просто содержит ссылку COM на объект, чтобы поддерживать его в активном состоянии. Ссылка COM автоматически освобождается при уничтожении перечислителя.

Параметр *flags* позволяет указать, каким образом перечислитель должен обрабатывать переданные ему элементы массива. *Флаги* могут принимать одно из значений перечисления, `CComEnumFlags` как показано ниже.

```
enum CComEnumFlags
   {
   AtlFlagNoCopy = 0,
   AtlFlagTakeOwnership = 2, // BitOwn
   AtlFlagCopy = 3           // BitOwn | BitCopy
   };
```

`AtlFlagNoCopy`означает, что время существования массива не контролируется перечислителем. В этом случае либо массив будет статическим, либо объект, идентифицируемый *Punk* , будет отвечать за освобождение массива, когда он больше не нужен.

`AtlFlagTakeOwnership`означает, что уничтожение массива должно контролироваться перечислителем. В этом случае массив должен быть динамически выделен с помощью **New**. Перечислитель удалит массив в его деструкторе. Как правило, значение NULL передается для *Punk*, хотя можно передать допустимый указатель, если необходимо получать уведомления об уничтожении перечислителя по какой-либо причине.

`AtlFlagCopy`означает, что новый массив создается путем копирования массива, переданного в `Init`. Время существования нового массива должно контролироваться перечислителем. Перечислитель удалит массив в его деструкторе. Как правило, значение NULL передается для *Punk*, хотя можно передать допустимый указатель, если необходимо получать уведомления об уничтожении перечислителя по какой-либо причине.

> [!NOTE]
>  Прототип этого метода задает элементы массива как тип `T`, где `T` был определен как параметр шаблона для класса. Это тот же тип, который предоставляется посредством метода COM-интерфейса [ккоменумимпл:: Next](#next). Следствием этого является то, что, в отличие от [иенумонстлимпл](../../atl/reference/ienumonstlimpl-class.md), этот класс не поддерживает различные хранилища и типы данных. Тип данных элементов в массиве должен совпадать с типом данных, предоставляемым средствами COM-интерфейса.

##  <a name="clone"></a>Ккоменумимпл:: Clone

Этот метод обеспечивает реализацию метода **clone** , создавая объект типа `CComEnum`, инициализируя его с тем же массивом и итератором, который используется текущим объектом, и возвращая интерфейс для только что созданного объекта.

```
STDMETHOD(Clone)(Base** ppEnum);
```

### <a name="parameters"></a>Параметры

*ппенум*<br/>
заполняет Интерфейс перечислителя для вновь созданного объекта, клонированного из текущего перечислителя.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Примечания

Обратите внимание, что клонированные перечислители никогда не делают собственную копию данных, используемых исходным перечислителем (или стать владельцем). При необходимости клонированные перечислители сохраняют исходный перечислитель в активном состоянии (используя ссылку COM), чтобы обеспечить доступность данных до тех пор, пока они им нужны.

##  <a name="m_spunk"></a>Ккоменумимпл:: m_spUnk

Этот смарт-указатель поддерживает ссылку на объект, передаваемый в [ккоменумимпл:: init](#init), гарантируя, что он остается в активном состоянии в течение времени существования перечислителя.

```
CComPtr<IUnknown> m_spUnk;
```

##  <a name="m_begin"></a>Ккоменумимпл:: m_begin

Указатель на расположение сразу за последним элементом массива, содержащего элементы для перечисления.

```
T* m_begin;
```

##  <a name="m_end"></a>Ккоменумимпл:: m_end

Указатель на первый элемент массива, содержащий элементы для перечисления.

```
T* m_end;
```

##  <a name="m_iter"></a>Ккоменумимпл:: m_iter

Указатель на текущий элемент массива, содержащий элементы для перечисления.

```
T* m_iter;
```

##  <a name="m_dwflags"></a>Ккоменумимпл:: m_dwFlags

Флаги, передаваемые в [ккоменумимпл:: init](#init).

```
DWORD m_dwFlags;
```

##  <a name="next"></a>Ккоменумимпл:: Next

Этот метод предоставляет реализацию **следующего** метода.

```
STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
```

### <a name="parameters"></a>Параметры

*celt*<br/>
окне Количество запрошенных элементов.

*rgelt*<br/>
заполняет Массив, который должен быть заполнен элементами.

*пцелтфетчед*<br/>
заполняет Число элементов, фактически возвращаемых в *rgelt*. Это значение может быть меньше, чем значение *celt* , если в списке осталось менее *celt* элементов.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

##  <a name="reset"></a>Ккоменумимпл:: Reset

Этот метод обеспечивает реализацию метода **Reset** .

```
STDMETHOD(Reset)(void);
```

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

##  <a name="skip"></a>Ккоменумимпл:: Skip

Этот метод предоставляет реализацию метода **Skip** .

```
STDMETHOD(Skip)(ULONG celt);
```

### <a name="parameters"></a>Параметры

*celt*<br/>
окне Число пропускаемых элементов.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Примечания

Возвращает E_INVALIDARG, если значение *celt* равно нулю, возвращает S_FALSE, если возвращается меньшее число элементов, в противном случае возвращает значение S_OK.

## <a name="see-also"></a>См. также

[Класс IEnumOnSTLImpl](../../atl/reference/ienumonstlimpl-class.md)<br/>
[Класс CComEnum](../../atl/reference/ccomenum-class.md)<br/>
[Обзор класса](../../atl/atl-class-overview.md)
