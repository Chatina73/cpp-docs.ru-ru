---
title: Класс CComEnumImpl
ms.date: 11/04/2016
f1_keywords:
- CComEnumImpl
- ATLCOM/ATL::CComEnumImpl
- ATLCOM/ATL::CComEnumImpl::CComEnumImpl
- ATLCOM/ATL::CComEnumImpl::Clone
- ATLCOM/ATL::CComEnumImpl::Init
- ATLCOM/ATL::CComEnumImpl::Next
- ATLCOM/ATL::CComEnumImpl::Reset
- ATLCOM/ATL::CComEnumImpl::Skip
- ATLCOM/ATL::CComEnumImpl::m_begin
- ATLCOM/ATL::CComEnumImpl::m_dwFlags
- ATLCOM/ATL::CComEnumImpl::m_end
- ATLCOM/ATL::CComEnumImpl::m_iter
- ATLCOM/ATL::CComEnumImpl::m_spUnk
helpviewer_keywords:
- CComEnumImpl class
ms.assetid: cc0d8e76-e608-46db-87cd-4c7161fe32d2
ms.openlocfilehash: 2104d98cbc068eb5d8f1408cdda0898fd55c9473
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50467150"
---
# <a name="ccomenumimpl-class"></a>Класс CComEnumImpl

Этот класс предоставляет реализацию интерфейса перечислителя COM, где хранятся перечисляемых элементов в массиве.

## <a name="syntax"></a>Синтаксис

```
template <class Base,
    const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : public Base
```

#### <a name="parameters"></a>Параметры

*Base*<br/>
COM-интерфейса перечислителя. См. в разделе [IEnumString](/windows/desktop/api/objidl/nn-objidl-ienumstring) пример.

*piid*<br/>
Указатель на идентификатор интерфейса интерфейса перечислителя.

*T*<br/>
Тип элемента, доступные в интерфейсе перечислителя.

*Копировать*<br/>
Однородную [скопируйте класс политики](../../atl/atl-copy-policy-classes.md).

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CComEnumImpl::CComEnumImpl](#ccomenumimpl)|Конструктор.|
|[CComEnumImpl:: ~ CComEnumImpl](#dtor)|Деструктор|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CComEnumImpl::Clone](#clone)|Реализация **клона** метода интерфейса перечисления.|
|[CComEnumImpl::Init](#init)|Инициализирует перечислитель.|
|[CComEnumImpl::Next](#next)|Реализация **Далее**.|
|[CComEnumImpl::Reset](#reset)|Реализация **сбросить**.|
|[CComEnumImpl::Skip](#skip)|Реализация **Skip**.|

### <a name="public-data-members"></a>Открытые члены данных

|Имя|Описание|
|----------|-----------------|
|[CComEnumImpl::m_begin](#m_begin)|Указатель на первый элемент в массиве.|
|[CComEnumImpl::m_dwFlags](#m_dwflags)|Скопируйте флаги, передаваемые через `Init`.|
|[CComEnumImpl::m_end](#m_end)|Указатель на расположение после последнего элемента в массиве.|
|[CComEnumImpl::m_iter](#m_iter)|Указатель на текущий элемент в массиве.|
|[CComEnumImpl::m_spUnk](#m_spunk)|`IUnknown` Указатель объекта, указав перебора коллекции.|

## <a name="remarks"></a>Примечания

См. в разделе [IEnumString](/windows/desktop/api/objidl/nn-objidl-ienumstring) пример реализации метода. `CComEnumImpl` предоставляет реализацию для COM-интерфейс перечислителя, где хранятся перечисляемых элементов в массиве. Этот класс является аналогом `IEnumOnSTLImpl` , предоставляющего реализацию интерфейса перечислителя на основе контейнера стандартной библиотеки C++.

> [!NOTE]
>  Дополнительные сведения о дальнейшей различия между `CComEnumImpl` и `IEnumOnSTLImpl`, см. в разделе [CComEnumImpl::Init](#init).

Как правило, вы будете *не* нужно создать свой собственный класс перечислителя путем наследования от реализации этого интерфейса. Если вы хотите использовать предоставляемую ATL перечислителя на основе массива, очень часто для создания экземпляра [CComEnum](../../atl/reference/ccomenum-class.md).

Тем не менее если требуется для предоставления пользовательского перечислителя (например, по одному, предоставляет интерфейсы, а также интерфейс перечислителя), могут наследовать этот класс. В этом случае вполне вероятно, что вам потребуется переопределить [CComEnumImpl::Clone](#clone) метод, чтобы предоставить свою собственную реализацию.

Дополнительные сведения см. в разделе [коллекции и перечислители ATL](../../atl/atl-collections-and-enumerators.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`Base`

`CComEnumImpl`

## <a name="requirements"></a>Требования

**Заголовок:** atlcom.h

##  <a name="ccomenumimpl"></a>  CComEnumImpl::CComEnumImpl

Конструктор.

```
CComEnumImpl();
```

##  <a name="dtor"></a>  CComEnumImpl:: ~ CComEnumImpl

Деструктор

```
~CComEnumImpl();
```

##  <a name="init"></a>  CComEnumImpl::Init

Этот метод необходимо вызвать перед тем как передать указатель на интерфейс перечисления любой клиентам.

```
HRESULT Init(
    T* begin,
    T* end,
    IUnknown* pUnk,
    CComEnumFlags flags = AtlFlagNoCopy);
```

### <a name="parameters"></a>Параметры

*begin*<br/>
Указатель на первый элемент массива, содержащего элементы, которые необходимо перечислить.

*end*<br/>
Указатель на расположение после последнего элемента массива, содержащего элементы, которые необходимо перечислить.

*pUnk*<br/>
[in] `IUnknown` Указатель на объект, который должен поддерживаться в течение времени существования перечислителя. Передайте значение NULL, если объект не существует.

*flags*<br/>
Флаги, указывающие, следует ли перечислитель стать владельцем массива или сделать его копию. Ниже описаны возможные значения.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Примечания

Этот метод вызывать только один раз — инициализации перечислителя, использовать его, а затем откажемся от него.

Если передать указатели на объекты в массиве, хранящиеся в другом объекте (не спрашивайте перечислитель для копирования данных), можно использовать *pUnk* параметр, чтобы обеспечить доступность в течение перечислитель объекта и массива, он содержит они нужны. Перечислитель просто хранит ссылку на COM для объекта, чтобы поддерживать в активном состоянии. Ссылки COM автоматически освобождается при уничтожении перечислитель.

*Флаги* параметр позволяет указать, как перечислитель должен интерпретировать элементы массива, переданного ему. *флаги* может принимать одно из значений из `CComEnumFlags` перечисления, показано ниже:

```
enum CComEnumFlags
   {
   AtlFlagNoCopy = 0,
   AtlFlagTakeOwnership = 2, // BitOwn
   AtlFlagCopy = 3           // BitOwn | BitCopy
   };
```

`AtlFlagNoCopy` означает, что время существования массива не контролируется перечислитель. В этом случае либо массив будет иметь статический метод или объект, определяемый *pUnk* будете нести ответственность за освобождение массива в том случае, когда он больше не используется.

`AtlFlagTakeOwnership` означает, что уничтожение массива является управление с помощью перечислителя. В этом случае массива должны были динамически выделены с помощью **новый**. Перечислитель приведет к удалению массива в деструкторе. Как правило, следует передавать значение NULL *pUnk*, несмотря на то, что по-прежнему можно передать допустимый указатель, если требуется получать уведомления об уничтожении перечислителя для какой-либо причине.

`AtlFlagCopy` означает, что новый массив с копирование массива, передаваемое `Init`. Время существования нового массива является управление с помощью перечислителя. Перечислитель приведет к удалению массива в деструкторе. Как правило, следует передавать значение NULL *pUnk*, несмотря на то, что по-прежнему можно передать допустимый указатель, если требуется получать уведомления об уничтожении перечислителя для какой-либо причине.

> [!NOTE]
>  Прототип объекта этот метод указывает элементы массива, как оно принадлежит к типу `T`, где `T` была определена как параметр шаблона для класса. Это тот же тип, который предоставляется с помощью метода интерфейса COM [CComEnumImpl::Next](#next). Это то, что в отличие от [IEnumOnSTLImpl](../../atl/reference/ienumonstlimpl-class.md), этот класс не поддерживает различные хранилища и представлены типы данных. Тип данных элементов в массиве должен быть таким же, как тип данных, предоставляемый посредством COM-интерфейса.

##  <a name="clone"></a>  CComEnumImpl::Clone

Этот метод предоставляет реализацию **клона** метод путем создания объекта типа `CComEnum`, инициализировав его с тем же массива и итератор, используемый текущим объектом и возврат на только что созданный интерфейс объект.

```
STDMETHOD(Clone)(Base** ppEnum);
```

### <a name="parameters"></a>Параметры

*ppEnum*<br/>
[out] Интерфейс перечислителя для вновь созданного объекта, клонированный из текущего перечислителя.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Примечания

Обратите внимание, что клонированный перечислители никогда не устанавливать собственные копии (или Смена владельца) данные, используемые перечислителем исходного. При необходимости клонированный перечислители будет сохранения исходной перечислитель (с помощью ссылки COM), чтобы обеспечить доступность для данных до тех пор, пока она им нужна.

##  <a name="m_spunk"></a>  CComEnumImpl::m_spUnk

Этого интеллектуального указателя содержит ссылку на объект, передаваемый в [CComEnumImpl::Init](#init), гарантируя, что он остается активным в течение времени существования перечислителя.

```
CComPtr<IUnknown> m_spUnk;
```

##  <a name="m_begin"></a>  CComEnumImpl::m_begin

Указатель на расположение после последнего элемента массива, содержащего элементы, которые необходимо перечислить.

```
T* m_begin;
```

##  <a name="m_end"></a>  CComEnumImpl::m_end

Указатель на первый элемент массива, содержащего элементы, которые необходимо перечислить.

```
T* m_end;
```

##  <a name="m_iter"></a>  CComEnumImpl::m_iter

Указатель на текущий элемент массива, содержащего элементы, которые необходимо перечислить.

```
T* m_iter;
```

##  <a name="m_dwflags"></a>  CComEnumImpl::m_dwFlags

Флаги, передаваемый [CComEnumImpl::Init](#init).

```
DWORD m_dwFlags;
```

##  <a name="next"></a>  CComEnumImpl::Next

Этот метод предоставляет реализацию **Далее** метод.

```
STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
```

### <a name="parameters"></a>Параметры

*celt*<br/>
[in] Количество запрошенных элементов.

*rgelt*<br/>
[out] Массив для заполнения элементов.

*pceltFetched*<br/>
[out] Число элементов, фактически возвращенных в *rgelt*. Это может быть меньше, чем *celt* если меньше, чем *celt* элементы остаются в списке.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

##  <a name="reset"></a>  CComEnumImpl::Reset

Этот метод предоставляет реализацию **Сброс** метод.

```
STDMETHOD(Reset)(void);
```

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

##  <a name="skip"></a>  CComEnumImpl::Skip

Этот метод предоставляет реализацию **Skip** метод.

```
STDMETHOD(Skip)(ULONG celt);
```

### <a name="parameters"></a>Параметры

*celt*<br/>
[in] Количество пропускаемых элементов.

### <a name="return-value"></a>Возвращаемое значение

Стандартное значение HRESULT.

### <a name="remarks"></a>Примечания

Возвращает значение E_INVALIDARG, если *celt* равно нулю, возвращает S_FALSE, если меньше, чем *celt* возвращаются элементы, в противном случае возвращает значение S_OK.

## <a name="see-also"></a>См. также

[Класс IEnumOnSTLImpl](../../atl/reference/ienumonstlimpl-class.md)<br/>
[Класс CComEnum](../../atl/reference/ccomenum-class.md)<br/>
[Общие сведения о классе](../../atl/atl-class-overview.md)
