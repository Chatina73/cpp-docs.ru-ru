---
title: Классы политики копирования ATL
ms.date: 11/04/2016
helpviewer_keywords:
- data [C++], ATL
- classes [C++], copy policy
- copy policy classes [C++]
- _Copy class
- _CopyInterface class
ms.assetid: 06704b68-d318-4c5d-a65b-71457fe9d00d
ms.openlocfilehash: 73bec31b4ae140797c85a06ee7c5023c9e0c4446
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "58776964"
---
# <a name="atl-copy-policy-classes"></a>Классы политики копирования ATL

Классы политики копирования являются [служебные классы](../atl/utility-classes.md) используется для инициализации, копировать и удалять данные. Классы политики копирования позволяют определить семантику копирования для любого типа данных и определять преобразования между различными типами данных.

Использует классы политики копирования ATL в реализации из следующих шаблонов:

- [CComEnumImpl](../atl/reference/ccomenumimpl-class.md)

- [IEnumOnSTLImpl](../atl/reference/ienumonstlimpl-class.md)

- [ICollectionOnSTLImpl](../atl/reference/icollectiononstlimpl-class.md)

За счет инкапсуляции сведения, необходимые, чтобы скопировать или преобразовать данные в класс политики копирования, который может быть передан в качестве аргумента шаблона, разработчикам ATL предоставили для extreme многократного использования этих классов. Например если необходимо реализовать коллекцию с помощью любого произвольного типа данных, необходимо указать всего лишь политики соответствующей копии; больше не придется менять код, реализующий коллекции.

## <a name="definition"></a>Определение

По определению класс, предоставляющий следующие статические функции — это класс политики копирования:

`static void init(` `DestinationType` `* p);`

`static HRESULT copy(` `DestinationType` `* pTo, const`  `SourceType` `* pFrom);`

`static void destroy(` `DestinationType` `* p);`

Вы можете заменить типы `DestinationType` и *SourceType* с типами произвольные данные для каждой политики копирования.

> [!NOTE]
>  Несмотря на то, что можно определить классы политики копирования для любых типов произвольные данные, использование классов в коде ATL следует ограничить типы, которые имеют смысл. Например, когда с помощью политики копирования класс коллекции ATL или реализации перечислителя, `DestinationType` должен быть типом, который может использоваться в качестве параметра в методе интерфейса COM.

Используйте **init** инициализировать данные, **копирования** для копирования данных, и **уничтожить** для освобождения данных. Точное значение инициализации, копирование и уничтожения входят в домен класс политики копирования и будет зависеть от используемых типов данных.

Существует два требования на использование, а также реализация класса политики копирования:

- Первый параметр для **копирования** должны получать только указатель на данные, которые ранее был инициализирован с помощью **init**.

- **уничтожить** только должен получить указатель на данные, которые ранее был инициализирован с помощью **init** или копирования через **копирования**.

## <a name="standard-implementations"></a>Стандартные реализации

Библиотека ATL предоставляет два классов политики копирования в виде `_Copy` и `_CopyInterface` классы шаблонов:

- `_Copy` Класс позволяет однородных только копирование (не преобразование между типами данных), так как он предлагает только один параметр шаблона указывать оба `DestinationType` и *SourceType*. Отсутствует код инициализации или уничтожения универсальную реализацию этого шаблона и использует `memcpy` для копирования данных. Кроме того, библиотека ATL предоставляет специализации `_Copy` для типов данных VARIANT, LPOLESTR, OLEVERB и CONNECTDATA.

- `_CopyInterface` Класс предоставляет реализацию для копирования следующие стандартные правила COM указателей интерфейса. Еще раз этот класс позволяет только однородных копирование, поэтому используется простой операции присваивания и вызов `AddRef` для выполнения копирования.

## <a name="custom-implementations"></a>Пользовательские реализации

Как правило необходимо определить свои собственные классы политики копирования для разнородных копирования (т. е. преобразование между типами данных). Некоторые примеры пользовательских классов политики копирования, просмотрите файлы файлах VCUE_Copy.h и VCUE_CopyString.h в [ATLCollections](../overview/visual-cpp-samples.md) образца. Эти файлы содержат два классов политики копирования шаблонов, `GenericCopy` и `MapCopy`, а также целый ряд специализаций `GenericCopy` для различных типов данных.

### <a name="genericcopy"></a>GenericCopy

`GenericCopy` можно указать *SourceType* и `DestinationType` как аргументы шаблонов. Вот наиболее распространенная форма `GenericCopy` от файле VCUE_Copy.h класса:

[!code-cpp[NVC_ATL_COM#30](../atl/codesnippet/cpp/atl-copy-policy-classes_1.h)]

Файле VCUE_Copy.h также содержит следующие специализации данного класса: `GenericCopy<BSTR>`, `GenericCopy<VARIANT, BSTR>`, `GenericCopy<BSTR, VARIANT>`. VCUE_CopyString.h содержит специализации для копирования из **std::string**s: `GenericCopy<std::string>`, `GenericCopy<VARIANT, std::string>`, и `GenericCopy<BSTR, std::string>`. Можно улучшить `GenericCopy` , предоставляя дополнительные собственные специализации.

### <a name="mapcopy"></a>MapCopy

`MapCopy` предполагается, что копируемых данных хранится в сопоставление стиле библиотеки C++ Standard, поэтому он позволяет указать тип создаваемой карты, в котором хранятся данные и целевой тип. Реализация класса просто использует определения типов, предоставляемых *MapType* класс для определения типа источника данных и для вызова соответствующего `GenericCopy` класса. Без специализации этого класса не требуются.

[!code-cpp[NVC_ATL_COM#31](../atl/codesnippet/cpp/atl-copy-policy-classes_2.h)]

## <a name="see-also"></a>См. также

[Реализация коллекции на основе стандартной библиотеки C++](../atl/implementing-an-stl-based-collection.md)<br/>
[Пример ATLCollections](../overview/visual-cpp-samples.md)
