---
title: Классы политики копирования ATL
ms.date: 11/04/2016
helpviewer_keywords:
- data [C++], ATL
- classes [C++], copy policy
- copy policy classes [C++]
- _Copy class
- _CopyInterface class
ms.assetid: 06704b68-d318-4c5d-a65b-71457fe9d00d
ms.openlocfilehash: f40f31124d4547076249a7459ac4b63cc25305d1
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81317381"
---
# <a name="atl-copy-policy-classes"></a>Классы политики копирования ATL

Классы политики копирования — это [классы утилит,](../atl/utility-classes.md) используемые для инициализации, копирования и удаления данных. Классы политики копирования позволяют определить семантику копий для любого типа данных и определить преобразования между различными типами данных.

ATL использует классы политики копирования в своих реализациях следующих шаблонов:

- [CComEnumImpl](../atl/reference/ccomenumimpl-class.md)

- [IenumOnSTLImpl](../atl/reference/ienumonstlimpl-class.md)

- [ICollectionOnSTLImpl](../atl/reference/icollectiononstlimpl-class.md)

Инкапсуляция информации, необходимой для копирования или преобразования данных в классе политики копирования, которые могут быть переданы в качестве аргумента шаблона, разработчики ATL предусмотрели крайнюю возможность повторного использования этих классов. Например, если вам необходимо реализовать коллекцию с использованием любого произвольного типа данных, все, что вам нужно предоставить, это соответствующая политика копирования; вам никогда не придется прикасаться к коду, который реализует коллекцию.

## <a name="definition"></a>Определение

По определению, класс, который предоставляет следующие статические функции, является классом политики копирования:

`static void init(` `DestinationType` `* p);`

`static HRESULT copy(` `DestinationType` `* pTo, const`  `SourceType` `* pFrom);`

`static void destroy(` `DestinationType` `* p);`

Вы можете заменить типы `DestinationType` и *SourceType* произвольными типами данных для каждой политики копирования.

> [!NOTE]
> Хотя можно определить классы политики копирования для любых произвольных типов данных, использование классов в коде ATL должно ограничивать типы, которые имеют смысл. Например, при использовании класса политики копирования с реализацией коллекции `DestinationType` или перечисления ATL должен быть тип, который может быть использован в качестве параметра в методе интерфейса COM.

Используйте **init** для инициализации данных, **копирования** данных и **уничтожения** для освобождения данных. Точное значение инициализации, копирования и уничтожения является областью класса политики копирования и будет варьироваться в зависимости от типов данных.

Существует два требования к использованию и внедрению класса политики копирования:

- Первый параметр для **копирования** должен получать только указатель на данные, которые вы ранее инициализировали с помощью **init.**

- **уничтожить** должны только когда-либо получить указатель на данные, которые вы ранее инициализированы с помощью **init** или скопированы через **копию**.

## <a name="standard-implementations"></a>Стандартные реализации

ATL предоставляет два класса политики `_Copy` копирования в виде классов шаблонов: `_CopyInterface`

- Класс `_Copy` позволяет только однородное копирование (а не преобразование между типами `DestinationType` данных), так как он предлагает только один параметр шаблона, чтобы указать оба и *SourceType.* Общая реализация этого шаблона не содержит инициализации или разрушения кода и использует `memcpy` для копирования данных. ATL также предоставляет специализации для типов данных `_Copy` VARIANT, LPOLESTR, OLEVERB и CONNECTDATA.

- Класс `_CopyInterface` обеспечивает реализацию для копирования указателей интерфейса в соответствии со стандартными правилами COM. Еще раз этот класс позволяет только однородное копирование, поэтому `AddRef` он использует простое назначение и вызов для выполнения копии.

## <a name="custom-implementations"></a>Пользовательские реализации

Как правило, необходимо определить собственные классы политики копирования для неоднородного копирования (т.е. преобразования между типами данных). В некоторых примерах пользовательских классов политики копирования смотрите файлы VCUE_Copy.h и VCUE_CopyString.h в примере [ATLCollections.](../overview/visual-cpp-samples.md) Эти файлы содержат два `GenericCopy` класса `MapCopy`политики копирования шаблонов `GenericCopy` и, а также ряд специализаций для различных типов данных.

### <a name="genericcopy"></a>Генерическаякопия

`GenericCopy`позволяет указать *SourceType* `DestinationType` и в качестве шаблона аргументов. Вот самая общая форма `GenericCopy` класса из VCUE_Copy.h:

[!code-cpp[NVC_ATL_COM#30](../atl/codesnippet/cpp/atl-copy-policy-classes_1.h)]

VCUE_Copy.h также содержит следующие специализации `GenericCopy<BSTR>` `GenericCopy<VARIANT, BSTR>`этого `GenericCopy<BSTR, VARIANT>`класса: , . VCUE_CopyString.h содержит специализации для копирования из **std::string**s: `GenericCopy<std::string>`, `GenericCopy<VARIANT, std::string>`и `GenericCopy<BSTR, std::string>`. Вы могли `GenericCopy` бы повысить путем предоставления дополнительных специализаций самостоятельно.

### <a name="mapcopy"></a>MapCopy

`MapCopy`предполагает, что копируются данные, хранящиеся на карте в стиле Стандартной библиотеки, поэтому позволяет указать тип карты, на которой хранятся данные, и тип назначения. Реализация класса просто использует typedefs, поставляемые классом *MapType,* чтобы определить тип `GenericCopy` исходных данных и вызвать соответствующий класс. Специализации этого класса не требуются.

[!code-cpp[NVC_ATL_COM#31](../atl/codesnippet/cpp/atl-copy-policy-classes_2.h)]

## <a name="see-also"></a>См. также раздел

[Внедрение стандартной библиотечной коллекции на основе СЗ](../atl/implementing-an-stl-based-collection.md)<br/>
[Пример ATLCollections](../overview/visual-cpp-samples.md)
