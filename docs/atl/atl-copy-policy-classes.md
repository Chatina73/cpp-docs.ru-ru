---
description: 'Дополнительные сведения: классы политики копирования ATL'
title: Классы политики копирования ATL
ms.date: 11/04/2016
helpviewer_keywords:
- data [C++], ATL
- classes [C++], copy policy
- copy policy classes [C++]
- _Copy class
- _CopyInterface class
ms.assetid: 06704b68-d318-4c5d-a65b-71457fe9d00d
ms.openlocfilehash: 502befadbd9317602c49d9a5815dee6ebc239d78
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97165762"
---
# <a name="atl-copy-policy-classes"></a>Классы политики копирования ATL

Классы политик копирования — это [служебные классы](../atl/utility-classes.md) , используемые для инициализации, копирования и удаления данных. Классы политик копирования позволяют определить семантику копирования для любого типа данных и определить преобразования между различными типами данных.

ATL использует классы политики копирования в своих реализациях следующих шаблонов:

- [ккоменумимпл](../atl/reference/ccomenumimpl-class.md)

- [иенумонстлимпл](../atl/reference/ienumonstlimpl-class.md)

- [иколлектиононстлимпл](../atl/reference/icollectiononstlimpl-class.md)

Инкапсуляция сведений, необходимых для копирования или преобразования данных в классе политики копирования, который можно передать в качестве аргумента шаблона, разработчики ATL предоставили для экстремального использования этих классов. Например, если необходимо реализовать коллекцию с любым произвольным типом данных, необходимо предоставить только соответствующую политику копирования. Вам никогда не придется касаться кода, реализующего коллекцию.

## <a name="definition"></a>Определение

По определению класс, предоставляющий следующие статические функции, является классом политики копирования:

`static void init(` `DestinationType` `* p);`

`static HRESULT copy(` `DestinationType` `* pTo, const`  `SourceType` `* pFrom);`

`static void destroy(` `DestinationType` `* p);`

Можно заменить типы `DestinationType` и *sourceType* произвольными типами данных для каждой политики копирования.

> [!NOTE]
> Хотя классы политик копирования можно определить для любых произвольных типов данных, использование классов в коде ATL должно ограничивать типы, которые имеют смысл. Например, при использовании класса политики копирования с реализациями коллекции или перечислителя ATL `DestinationType` должен быть тип, который можно использовать в качестве параметра в методе COM-интерфейса.

Используйте **init** для инициализации данных, **копирования** для копирования данных и **уничтожения** , чтобы освободить данные. Точное значение инициализации, копирования и уничтожения является доменом класса политики копирования и зависит от используемых типов данных.

Существует два требования к использованию и реализации класса политики копирования.

- Первый параметр для **копирования** должен получить только указатель на данные, которые ранее были инициализированы с помощью **init**.

- При **уничтожении** необходимо только получить указатель на данные, инициализированные ранее с помощью **init** или скопированные с помощью **Copy**.

## <a name="standard-implementations"></a>Стандартные реализации

ATL предоставляет два класса политики копирования в виде `_Copy` `_CopyInterface` классов шаблонов и:

- `_Copy`Класс допускает однородное копирование (не преобразование между типами данных), поскольку оно предлагает только один параметр шаблона для указания `DestinationType` и *sourceType*, и. Универсальная реализация этого шаблона не содержит кода инициализации или уничтожения и использует `memcpy` для копирования данных. ATL также предоставляет специализации `_Copy` для типов данных Variant, лполестр, олеверб и коннектдата.

- `_CopyInterface`Класс предоставляет реализацию для копирования указателей интерфейса на следующие стандартные правила com. Опять же, этот класс допускает однородное копирование, поэтому он использует простое присваивание и вызов для `AddRef` выполнения копирования.

## <a name="custom-implementations"></a>Пользовательские реализации

Как правило, необходимо определить собственные классы политики копирования для разнородного копирования (т. е. преобразования между типами данных). Некоторые примеры пользовательских классов политики копирования см. в файлах VCUE_Copy. h и VCUE_CopyString. h в примере [атлколлектионс](../overview/visual-cpp-samples.md) . Эти файлы содержат два класса политики копирования шаблонов: `GenericCopy` и `MapCopy` , а также несколько специализаций `GenericCopy` для различных типов данных.

### <a name="genericcopy"></a>женериккопи

`GenericCopy` позволяет указать аргументы шаблона *sourceType* и `DestinationType` as. Ниже приведена самая общая форма `GenericCopy` класса из VCUE_Copy. h:

[!code-cpp[NVC_ATL_COM#30](../atl/codesnippet/cpp/atl-copy-policy-classes_1.h)]

VCUE_Copy. h также содержит следующие специализации этого класса: `GenericCopy<BSTR>` , `GenericCopy<VARIANT, BSTR>` , `GenericCopy<BSTR, VARIANT>` . VCUE_CopyString. h содержит специализации для копирования из **std:: String** s: `GenericCopy<std::string>` , `GenericCopy<VARIANT, std::string>` и `GenericCopy<BSTR, std::string>` . Вы можете улучшить `GenericCopy` , предоставив собственные специализации.

### <a name="mapcopy"></a>мапкопи

`MapCopy` Предполагается, что копируемые данные сохраняются в карту стиля стандартной библиотеки C++, поэтому можно указать тип схемы, в которой хранятся данные, и целевой тип. Реализация класса просто использует определения типов, предоставляемые классом *маптипе* , для определения типа исходных данных и вызова соответствующего `GenericCopy` класса. Специализации этого класса не требуются.

[!code-cpp[NVC_ATL_COM#31](../atl/codesnippet/cpp/atl-copy-policy-classes_2.h)]

## <a name="see-also"></a>См. также раздел

[Реализация стандартной Library-Based коллекции C++](../atl/implementing-an-stl-based-collection.md)<br/>
[Пример Атлколлектионс](../overview/visual-cpp-samples.md)
