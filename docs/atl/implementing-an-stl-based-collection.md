---
title: Реализация коллекции на основе библиотеки C++ Standard
ms.date: 11/04/2016
helpviewer_keywords:
- ICollectionOnSTLImpl interface
ms.assetid: 6d49f819-1957-4813-b074-3f12c494d8ca
ms.openlocfilehash: 609ec2547cf7a8ab93ef757f7a8e460542c9de28
ms.sourcegitcommit: 5cecccba0a96c1b4ccea1f7a1cfd91f259cc5bde
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2019
ms.locfileid: "58779252"
---
# <a name="implementing-a-c-standard-library-based-collection"></a>Реализация коллекции на основе библиотеки C++ Standard

Библиотека ATL предоставляет `ICollectionOnSTLImpl` интерфейс, чтобы можно было быстро реализовать интерфейсы коллекций на основе стандартной библиотеки C++ для ваших объектов. Чтобы понять, как работает этот класс, будет работать через простой пример (см. ниже), использующий этот класс для реализации только для чтения коллекция, предназначенных для клиентов автоматизации.

Пример кода взят из [ATLCollections пример](../overview/visual-cpp-samples.md).

Для выполнения этой процедуры, вы научитесь:

- [Создание простого объекта](#vccongenerating_an_object).

- [Измените файл IDL](#vcconedit_the_idl) для созданного интерфейса.

- [Создание определения пять типов](#vcconstorage_and_exposure_typedefs) описанием хранение элементов коллекции и как они будет предоставляться клиентам через COM-интерфейсов.

- [Создайте два определения типов для копирования классов политики](#vcconcopy_classes).

- [Создание определения типов для реализаций перечислителя и коллекции](#vcconenumeration_and_collection).

- [Изменить код C++, созданный мастером, чтобы использовать определение типа коллекции](#vcconedit_the_generated_code).

- [Добавьте код для заполнения коллекции](#vcconpopulate_the_collection).

##  <a name="vccongenerating_an_object"></a> Создание простого объекта

Создайте новый проект, гарантируя, что снят флажок «атрибуты» в разделе параметров приложения. Используйте диалоговое окно Добавление класса ATL и добавить Simple Object Wizard для создания простого объекта с именем `Words`. Убедитесь, что сдвоенный интерфейс с именем `IWords` создается. Объекты созданного класса будет использоваться для представления коллекции слов (то есть строки).

##  <a name="vcconedit_the_idl"></a> Редактирование файла IDL

Теперь откройте IDL-файл и добавьте три свойства, необходимые для включения `IWords` в интерфейс только для чтения коллекция, как показано ниже:

[!code-cpp[NVC_ATL_COM#24](../atl/codesnippet/cpp/implementing-an-stl-based-collection_1.idl)]

Это стандартную форму для только для чтения коллекция интерфейс, разработанные с помощью клиентов автоматизации в виду. Нумерованные комментарии в этом определении интерфейса соответствуют комментариях ниже:

1. Интерфейсы коллекций обычно два, так как клиенты автоматизации обращается к `_NewEnum` свойство с помощью `IDispatch::Invoke`. Тем не менее клиенты автоматизации доступны все остальные методы, с помощью таблицы vtable, поэтому сдвоенные интерфейсы предпочтительнее диспетчерских интерфейсов.

1. Если сдвоенный интерфейс или диспетчерский интерфейс не поддается расширению во время выполнения (то есть не предоставляют дополнительные методы или свойства с помощью `IDispatch::Invoke`), необходимо применить **nonextensible** атрибута в определение. Этот атрибут позволяет клиентам автоматизации полный код проверки подлинности во время компиляции. В этом случае интерфейс не должен быть расширен.

1. Правильный идентификатор DISPID важен в том случае, если требуется, чтобы клиенты автоматизации, чтобы иметь возможность использовать это свойство. (Обратите внимание, что в DISPID_NEWENUM имеется только один символ подчеркивания).

1. Можно указать любое значение в качестве DISPID `Item` свойство. Тем не менее `Item` обычно используется DISPID_VALUE, чтобы сделать его свойство по умолчанию в коллекцию. Это позволяет клиентам автоматизации относятся к свойствам безымянного явным образом.

1. Тип данных, используемый для возврата значения `Item` свойство — это тип элемента, хранящегося в коллекции, как COM-клиентам интересует. Интерфейс возвращает строки, поэтому следует использовать стандартный строковый тип COM, BSTR. Можно хранить данные в другом формате внутренне вы вскоре увидите.

1. Значение, используемое для DISPID `Count` свойства являются произвольными. Нет не стандартный идентификатор DISPID для этого свойства.

##  <a name="vcconstorage_and_exposure_typedefs"></a> Создание определения типов для хранения и раскрытия

После определения интерфейса коллекции необходимо решить, каким образом данные будут храниться, и как данные будут предоставлены через перечислитель.

Ответы на эти вопросы могут быть предоставлены в виде номера из заданных определений типов, которые можно добавить код в начало файла заголовка для только что созданный класс:

[!code-cpp[NVC_ATL_COM#25](../atl/codesnippet/cpp/implementing-an-stl-based-collection_2.h)]

В этом случае будут храниться данные как **std::vector** из **std::string**s. **std::vector** — это класс контейнера стандартной библиотеки C++, который ведет себя как управляемого массива. **std::String** является класс string стандартной библиотеки C++. Эти классы позволяют легко работать с набором строк.

Так как поддержка Visual Basic крайне важно для успеха этот интерфейс, возвращенный перечислитель `_NewEnum` свойство должно поддерживать `IEnumVARIANT` интерфейс. Это интерфейс только перечислителя, поддерживаемая Visual Basic.

##  <a name="vcconcopy_classes"></a> Создание определения типов для классов политики копирования

Определения типов, созданных до сих предоставляют все сведения, необходимые для создания дополнительных определения типов для классов копирования, которые будут использоваться перечислителя и коллекции:

[!code-cpp[NVC_ATL_COM#26](../atl/codesnippet/cpp/implementing-an-stl-based-collection_3.h)]

В этом примере можно использовать пользовательский `GenericCopy` класс, определенный в файле VCUE_Copy.h и VCUE_CopyString.h из [ATLCollections](../overview/visual-cpp-samples.md) образца. Этот класс можно использовать в другом коде, но может потребоваться Дополнительно определите специализации структур `GenericCopy` для поддержки типов данных, используемых в свои собственные коллекции. Дополнительные сведения см. в разделе [классы политики копирования ATL](../atl/atl-copy-policy-classes.md).

##  <a name="vcconenumeration_and_collection"></a> Создание определения типов для перечисления и коллекции

Теперь все параметры шаблона необходимо specialize `CComEnumOnSTL` и `ICollectionOnSTLImpl` классы для этой ситуации были предоставлены в виде определения типов. Чтобы упростить использование специализации, создайте два определения типов как показано ниже:

[!code-cpp[NVC_ATL_COM#27](../atl/codesnippet/cpp/implementing-an-stl-based-collection_4.h)]

Теперь `CollectionType` является синонимом для специализации `ICollectionOnSTLImpl` , реализующий `IWords` интерфейс, определенный ранее и предоставляет перечислитель, поддерживаемые `IEnumVARIANT`.

##  <a name="vcconedit_the_generated_code"></a> Редактирование кода, созданные мастером

Теперь необходимо создать производный `CWords` от реализации интерфейса, представленного `CollectionType` typedef вместо `IWords`, как показано ниже:

[!code-cpp[NVC_ATL_COM#28](../atl/codesnippet/cpp/implementing-an-stl-based-collection_5.h)]

##  <a name="vcconpopulate_the_collection"></a> Добавление кода для заполнения коллекции

Единственное, что остается является заполнение вектор с данными. В этом простом примере можно добавить несколько слов к коллекции в конструктор для класса:

[!code-cpp[NVC_ATL_COM#29](../atl/codesnippet/cpp/implementing-an-stl-based-collection_6.h)]

Теперь можно проверить код с помощью выбранного клиента.

## <a name="see-also"></a>См. также

[Коллекции и перечислители](../atl/atl-collections-and-enumerators.md)<br/>
[Пример ATLCollections](../overview/visual-cpp-samples.md)<br/>
[Классы политики копирования ATL](../atl/atl-copy-policy-classes.md)
