---
description: Дополнительные сведения см. в статье реализация стандартной Library-Based коллекции C++
title: Реализация стандартной Library-Based коллекции C++
ms.date: 11/04/2016
helpviewer_keywords:
- ICollectionOnSTLImpl interface
ms.assetid: 6d49f819-1957-4813-b074-3f12c494d8ca
ms.openlocfilehash: 4a403885a6fe66bf8e8578deeab05c7fc08e88a5
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97152858"
---
# <a name="implementing-a-c-standard-library-based-collection"></a>Реализация стандартной Library-Based коллекции C++

ATL предоставляет интерфейс, позволяющий `ICollectionOnSTLImpl` быстро реализовать интерфейсы коллекций на основе стандартной библиотеки C++ для объектов. Чтобы понять, как работает этот класс, вы будете работать с простым примером (ниже), который использует этот класс для реализации коллекции только для чтения, предназначенной для клиентов автоматизации.

Пример кода представлен в [примере атлколлектионс](../overview/visual-cpp-samples.md).

Для выполнения этой процедуры вам потребуется:

- [Создать новый простой объект](#vccongenerating_an_object).

- [Измените IDL-файл](#vcconedit_the_idl) для созданного интерфейса.

- [Создайте пять определений типов](#vcconstorage_and_exposure_typedefs) , описывающих, как хранятся элементы сбора и как они будут предоставляться клиентам через COM-интерфейсы.

- [Создайте два определения типа typedef для классов политики копирования](#vcconcopy_classes).

- [Создайте определения типов для перечислителей и реализаций коллекций](#vcconenumeration_and_collection).

- [Измените созданный мастером код C++ для использования определения типа коллекции](#vcconedit_the_generated_code).

- [Добавьте код для заполнения коллекции](#vcconpopulate_the_collection).

## <a name="generating-a-new-simple-object"></a><a name="vccongenerating_an_object"></a> Создание нового простого объекта

Создайте новый проект, убедившись, что флажок атрибуты в разделе Параметры приложения снят. Используйте диалоговое окно Добавление класса ATL и мастер добавления простых объектов для создания простого объекта с именем `Words` . Убедитесь, что создан двойной интерфейс с именем `IWords` . Объекты созданного класса будут использоваться для представления коллекции слов (то есть строк).

## <a name="editing-the-idl-file"></a><a name="vcconedit_the_idl"></a> Изменение IDL-файла

Теперь откройте IDL-файл и добавьте три свойства, необходимые для включения `IWords` в интерфейс коллекции, доступного только для чтения, как показано ниже.

[!code-cpp[NVC_ATL_COM#24](../atl/codesnippet/cpp/implementing-an-stl-based-collection_1.idl)]

Это стандартная форма для интерфейса коллекции только для чтения, разработанного с учетом клиентов автоматизации. Нумерованные комментарии в этом определении интерфейса соответствуют следующим комментариям:

1. Интерфейсы коллекций обычно являются сдвоенными, так как клиенты автоматизации обращаются к `_NewEnum` свойству через `IDispatch::Invoke` . Однако клиенты автоматизации могут обращаться к оставшимся методам через vtable, поэтому сдвоенные интерфейсы предпочтительны для диспетчерских интерфейсов.

1. Если сдвоенный интерфейс или DISP-интерфейсы не будут расширяться во время выполнения (то есть вы не будете предоставлять дополнительные методы или свойства через `IDispatch::Invoke` ), следует применить **нерасширяемый** атрибут к определению. Этот атрибут позволяет клиентам автоматизации выполнять полную проверку кода во время компиляции. В этом случае интерфейс не должен расширяться.

1. Правильный идентификатор DISPID важен, если требуется, чтобы клиенты автоматизации могли использовать это свойство. (Обратите внимание, что в DISPID_NEWENUM имеется только один символ подчеркивания.)

1. Можно указать любое значение как DISPID `Item` Свойства. Однако `Item` обычно использует DISPID_VALUE, чтобы сделать его свойством коллекции по умолчанию. Это позволяет клиентам автоматизации ссылаться на свойство без его явного именования.

1. Тип данных, используемый для возвращаемого значения свойства, `Item` — это тип элемента, хранящегося в коллекции, как касается клиентов COM. Интерфейс возвращает строки, поэтому следует использовать стандартный тип строки COM, BSTR. Данные можно хранить в другом формате, как можно будет увидеть в ближайшее время.

1. Значение, используемое для DISPID `Count` свойства, является совершенно произвольным. Для этого свойства нет стандартного DISPID.

## <a name="creating-typedefs-for-storage-and-exposure"></a><a name="vcconstorage_and_exposure_typedefs"></a> Создание определений типов для хранения и раскрытия

После определения интерфейса сбора необходимо решить, как будут храниться данные, а также как данные будут предоставляться через перечислитель.

Ответы на эти вопросы можно указать в виде нескольких определений типов, которые можно добавить в верхнюю часть файла заголовка для созданного класса:

[!code-cpp[NVC_ATL_COM#25](../atl/codesnippet/cpp/implementing-an-stl-based-collection_2.h)]

В этом случае данные будут храниться в виде **std:: Vector** **строки std:: String** s. **std:: Vector** — это класс контейнера стандартной библиотеки C++, который ведет себя как управляемый массив. **std:: String** является строковым классом стандартной библиотеки C++. Эти классы упрощают работу с коллекцией строк.

Так как поддержка Visual Basic важна для успешного выполнения этого интерфейса, перечислитель, возвращаемый `_NewEnum` свойством, должен поддерживать `IEnumVARIANT` интерфейс. Это единственный интерфейс перечислителя, понятный Visual Basic.

## <a name="creating-typedefs-for-copy-policy-classes"></a><a name="vcconcopy_classes"></a> Создание определений типов для классов политик копирования

Созданные ранее определения типов предоставляют всю информацию, необходимую для создания дополнительных определений типов для классов копирования, которые будут использоваться перечислителем и коллекцией:

[!code-cpp[NVC_ATL_COM#26](../atl/codesnippet/cpp/implementing-an-stl-based-collection_3.h)]

В этом примере можно использовать пользовательский `GenericCopy` класс, определенный в VCUE_Copy. h и VCUE_CopyString. h, из примера [атлколлектионс](../overview/visual-cpp-samples.md) . Этот класс можно использовать в другом коде, но может потребоваться определить дополнительные специализации `GenericCopy` для поддержки типов данных, используемых в собственных коллекциях. Дополнительные сведения см. в разделе [классы политики копирования ATL](../atl/atl-copy-policy-classes.md).

## <a name="creating-typedefs-for-enumeration-and-collection"></a><a name="vcconenumeration_and_collection"></a> Создание определений типов для перечисления и коллекции

Теперь все параметры шаблона, необходимые для специализации `CComEnumOnSTL` классов и в `ICollectionOnSTLImpl` этой ситуации, были предоставлены в виде typedefs. Чтобы упростить использование специализаций, создайте еще два определения типов, как показано ниже:

[!code-cpp[NVC_ATL_COM#27](../atl/codesnippet/cpp/implementing-an-stl-based-collection_4.h)]

Теперь `CollectionType` является синонимом для специализации `ICollectionOnSTLImpl` , реализующей `IWords` интерфейс, определенный ранее, и предоставляет перечислитель, который поддерживает `IEnumVARIANT` .

## <a name="editing-the-wizard-generated-code"></a><a name="vcconedit_the_generated_code"></a> Редактирование кода Wizard-Generated

Теперь необходимо создать производную `CWords` от реализации интерфейса, представленной `CollectionType` typedef, а не `IWords` , как показано ниже:

[!code-cpp[NVC_ATL_COM#28](../atl/codesnippet/cpp/implementing-an-stl-based-collection_5.h)]

## <a name="adding-code-to-populate-the-collection"></a><a name="vcconpopulate_the_collection"></a> Добавление кода для заполнения коллекции

Остается только заполнить вектор данными. В этом простом примере можно добавить несколько слов в коллекцию в конструкторе класса:

[!code-cpp[NVC_ATL_COM#29](../atl/codesnippet/cpp/implementing-an-stl-based-collection_6.h)]

Теперь можно протестировать код с помощью клиента по своему усмотрению.

## <a name="see-also"></a>См. также раздел

[Коллекции и перечислители](../atl/atl-collections-and-enumerators.md)<br/>
[Пример Атлколлектионс](../overview/visual-cpp-samples.md)<br/>
[Классы политики копирования ATL](../atl/atl-copy-policy-classes.md)
