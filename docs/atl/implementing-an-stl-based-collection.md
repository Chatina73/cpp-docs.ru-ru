---
title: Внедрение стандартной библиотечной коллекции на основе СЗ
ms.date: 11/04/2016
helpviewer_keywords:
- ICollectionOnSTLImpl interface
ms.assetid: 6d49f819-1957-4813-b074-3f12c494d8ca
ms.openlocfilehash: e80ce5e7bbc6b9c6be1615dad1ea43c18e03eb55
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81319443"
---
# <a name="implementing-a-c-standard-library-based-collection"></a>Внедрение стандартной библиотечной коллекции на основе СЗ

ATL предоставляет `ICollectionOnSTLImpl` интерфейс, позволяющий быстро реализовывать интерфейсы коллекции на основе стандартной библиотеки на объектах. Чтобы понять, как работает этот класс, вы будете работать через простой пример (см. ниже), который использует этот класс для реализации только для чтения коллекции, предназначенной для клиентов автоматизации.

Пример кода взят из [образца ATLCollections.](../overview/visual-cpp-samples.md)

Для завершения этой процедуры вы будете:

- [Создайте новый простой объект.](#vccongenerating_an_object)

- [Отобразите файл IDL](#vcconedit_the_idl) для сгенерированного интерфейса.

- [Создайте пять типодепов,](#vcconstorage_and_exposure_typedefs) описывающих, как хранятся элементы коллекции и как они будут подвергаться воздействию клиентов через интерфейсы COM.

- [Создайте два типа для классов политики копирования.](#vcconcopy_classes)

- [Создавайте типографы для реализаций регистраторов и коллекций.](#vcconenumeration_and_collection)

- [Изнайте созданный мастером код C', чтобы использовать типdef коллекции.](#vcconedit_the_generated_code)

- [Добавьте код для заполнения коллекции.](#vcconpopulate_the_collection)

## <a name="generating-a-new-simple-object"></a><a name="vccongenerating_an_object"></a>Создание нового простого объекта

Создайте новый проект, гарантируя, что поле атрибутов под настройками приложения будет очищено. Используйте диалоговую коробку ATL Add Class и добавьте простого мастера объектов для создания простого объекта под названием. `Words` Убедитесь, что `IWords` генерируется двойной интерфейс. Объекты сгенерированного класса будут использоваться для представления коллекции слов (т.е. строк).

## <a name="editing-the-idl-file"></a><a name="vcconedit_the_idl"></a>Редактирование файла IDL

Теперь откройте файл IDL и добавьте `IWords` три свойства, необходимые для превращения в интерфейс сбора только для чтения, как показано ниже:

[!code-cpp[NVC_ATL_COM#24](../atl/codesnippet/cpp/implementing-an-stl-based-collection_1.idl)]

Это стандартная форма для интерфейса сбора только для чтения, разработанного с учетом клиентов Automation. Пронумерованные комментарии в этом определении интерфейса соответствуют нижеприведенным комментариям:

1. Интерфейсы коллекции, как правило, `_NewEnum` двойные, потому что клиенты автоматизации получают доступ к свойству через `IDispatch::Invoke`. Тем не менее, клиенты Automation могут получить доступ к оставшимся методам через vtable, поэтому двойные интерфейсы предпочтительнее dispinterfaces.

1. Если двойной интерфейс или dispinterface не будут продлены во время выполнения (т.е. вы не будете предоставлять дополнительные методы или свойства через), `IDispatch::Invoke`вы должны применить **nonextensible** атрибут к определению. Этот атрибут позволяет клиентам Automation выполнять полную проверку кода во время компиляции. В этом случае интерфейс не должен быть расширен.

1. Правильный DISPID важен, если вы хотите, чтобы клиенты автоматизации могли использовать это свойство. (Обратите внимание, что есть только один подчеркнуть в DISPID_NEWENUM.)

1. Вы можете предоставить любую ценность, `Item` как DISPID собственности. Однако `Item` обычно использует DISPID_VALUE, чтобы сделать его свойством коллекции по умолчанию. Это позволяет клиентам Automation ссылаться на свойство, не называя его явно.

1. Тип данных, используемый для `Item` возврата стоимости свойства, — это тип товара, хранящийся в коллекции в отношении клиентов COM. Интерфейс возвращает строки, поэтому следует использовать стандартный тип строки COM, BSTR. Данные можно хранить в другом формате, как вы увидите в ближайшее время.

1. Значение, используемое `Count` для DISPID свойства является абсолютно произвольным. Для этого отеля нет стандартного DISPID.

## <a name="creating-typedefs-for-storage-and-exposure"></a><a name="vcconstorage_and_exposure_typedefs"></a>Создание типодепов для хранения и экспозиции

После определения интерфейса сбора необходимо решить, как будут храниться данные и как данные будут подвергаться воздействию через регистратор.

Ответы на эти вопросы могут быть предоставлены в виде нескольких типодепов, которые можно добавить в верхней части файла заголовка для вновь созданного класса:

[!code-cpp[NVC_ATL_COM#25](../atl/codesnippet/cpp/implementing-an-stl-based-collection_2.h)]

В этом случае вы будете хранить данные как **std::vector** **std::string**s. **std::vector** — это класс контейнеров Стандартной библиотеки, который ведет себя как управляемый массив. **std:string** — это класс строки Стандартной библиотеки. Эти классы упрощают работу с набором строк.

Поскольку поддержка Visual Basic имеет жизненно важное значение для успеха `_NewEnum` этого интерфейса, регистратор, возвращенный свойством, должен поддерживать `IEnumVARIANT` интерфейс. Это единственный интерфейс регистратора, понятый Visual Basic.

## <a name="creating-typedefs-for-copy-policy-classes"></a><a name="vcconcopy_classes"></a>Создание типодепов для классов политики копирования

Созданные на данный момент типы предоставляют всю информацию, необходимую для создания дополнительных типов для классов копий, которые будут использоваться регистратором и коллекцией:

[!code-cpp[NVC_ATL_COM#26](../atl/codesnippet/cpp/implementing-an-stl-based-collection_3.h)]

В этом примере можно `GenericCopy` использовать пользовательский класс, определенный в VCUE_Copy.h и VCUE_CopyString.h из образца [ATLCollections.](../overview/visual-cpp-samples.md) Этот класс можно использовать в другом коде, но может `GenericCopy` потребоваться определение дополнительных специализаций для поддержки типов данных, используемых в собственных коллекциях. Для получения дополнительной [ATL Copy Policy Classes](../atl/atl-copy-policy-classes.md)информации см.

## <a name="creating-typedefs-for-enumeration-and-collection"></a><a name="vcconenumeration_and_collection"></a>Создание типофонов для перечисления и сбора

Теперь все параметры шаблона, `CComEnumOnSTL` `ICollectionOnSTLImpl` необходимые для специализации и классы для этой ситуации, были предоставлены в виде typedefs. Чтобы упростить использование специализаций, создайте еще два типа, как показано ниже:

[!code-cpp[NVC_ATL_COM#27](../atl/codesnippet/cpp/implementing-an-stl-based-collection_4.h)]

Теперь `CollectionType` является синонимом специализации, `ICollectionOnSTLImpl` которая реализует `IWords` интерфейс, определенный ранее и обеспечивает `IEnumVARIANT`перечисление, которое поддерживает.

## <a name="editing-the-wizard-generated-code"></a><a name="vcconedit_the_generated_code"></a>Редактирование кода, созданного Волшебником

Теперь вы `CWords` должны извлечь из реализации интерфейса, представленной `CollectionType` typedef, а `IWords`не, как показано ниже:

[!code-cpp[NVC_ATL_COM#28](../atl/codesnippet/cpp/implementing-an-stl-based-collection_5.h)]

## <a name="adding-code-to-populate-the-collection"></a><a name="vcconpopulate_the_collection"></a>Добавление кода для заполнения коллекции

Остается только заселить вектор данными. В этом простом примере можно добавить несколько слов в сборе в конструкторе для класса:

[!code-cpp[NVC_ATL_COM#29](../atl/codesnippet/cpp/implementing-an-stl-based-collection_6.h)]

Теперь вы можете протестировать код с клиентом по вашему выбору.

## <a name="see-also"></a>См. также раздел

[Коллекции и перечислители](../atl/atl-collections-and-enumerators.md)<br/>
[Пример ATLCollections](../overview/visual-cpp-samples.md)<br/>
[Классы политики копирования ATL](../atl/atl-copy-policy-classes.md)
