---
title: Поддержка IDispEventImpl
ms.date: 11/04/2016
helpviewer_keywords:
- event sink maps, declaring
- IDispEventImpl class, advising and unadvising
- SINK_ENTRY macro
- type libraries, importing
- ATL, IDispEventImpl support in COM objects
- BEGIN_SINK_MAP macro
- IDispEventImpl class, declaring
ms.assetid: b957f930-6a5b-4598-8e4d-8027759957e7
ms.openlocfilehash: 31beff30a067416f71029c18051f214c8d4429de
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81329324"
---
# <a name="supporting-idispeventimpl"></a>Поддержка IDispEventImpl

Класс [шаблонов IDispEventImpl](../atl/reference/idispeventimpl-class.md) может быть использован для поддержки топов точек соединения в классе ATL. Раковина точки соединения позволяет классу обрабатывать события, выпущенные с внешних объектов COM. Эти точки соединения отображаются с картой раковины событий, предоставляемой вашим классом.

Для правильной реализации точки соединения для вашего класса необходимо выполнить следующие шаги:

- Импорт библиотек типов для каждого внешнего объекта

- Объявление `IDispEventImpl` интерфейсов

- Объявить карту погружения события

- Консультирование и неконсультирование точек соединения

Все этапы реализации точки соединения выполняются путем изменения только файла заголовка (.h) вашего класса.

## <a name="importing-the-type-libraries"></a>Импорт библиотек типа

Для каждого внешнего объекта, события которого вы хотите обрабатывать, необходимо импортировать библиотеку типов. Этот шаг определяет события, которые могут быть обработаны, и предоставляет информацию, которая используется при объявлении карты раковины события. Для этого можно использовать [директиву #import.](../preprocessor/hash-import-directive-cpp.md) Добавьте `#import` необходимые строки директивы для каждого интерфейса диспетчеризации, который вы будете поддерживать, в файл заголовка (.h) вашего класса.

Следующий пример импортирует библиотеку типов`MSCAL.Calendar.7`внешнего сервера COM ( ):

[!code-cpp[NVC_ATL_Windowing#141](../atl/codesnippet/cpp/supporting-idispeventimpl_1.h)]

> [!NOTE]
> Вы должны иметь `#import` отдельное заявление для каждой внешней библиотеки типа, которая будет поддерживаться.

## <a name="declaring-the-idispeventimpl-interfaces"></a>Объявление интерфейсов IDispEventImpl

Теперь, когда вы импортировали библиотеки типов каждого интерфейса диспетчеризации, необходимо объявить отдельные `IDispEventImpl` интерфейсы для каждого внешнего интерфейса диспетчеризации. Измените декларацию вашего `IDispEventImpl` класса, добавив объявление интерфейса для каждого внешнего объекта. Для получения дополнительной информации о параметрах [см.](../atl/reference/idispeventimpl-class.md)

Следующий код объявляет две точки соединения `DCalendarEvents` раковины, для интерфейса, `CMyCompositCtrl2`для объекта COM реализованы по классу:

[!code-cpp[NVC_ATL_Windowing#142](../atl/codesnippet/cpp/supporting-idispeventimpl_2.h)]

## <a name="declaring-an-event-sink-map"></a>Объявление карты погружения события

Для того, чтобы уведомления о событии были обработаны соответствующей функцией, ваш класс должен направить каждое событие к своему правильному обработчику. Это достигается путем объявления карты раковины события.

ATL предоставляет несколько макросов, [BEGIN_SINK_MAP,](reference/composite-control-macros.md#begin_sink_map) [END_SINK_MAP](reference/composite-control-macros.md#end_sink_map)и [SINK_ENTRY_EX,](reference/composite-control-macros.md#sink_entry_ex)которые делают это отображение проще. Стандартный формат:

```cpp
BEGIN_SINK_MAP(comClass)
  SINK_ENTRY_EX(id, iid, dispid, func)
  . . . //additional external event entries
END_SINK_MAP()
```

Следующий пример объявляет карту раковины события с двумя обработчиками событий:

[!code-cpp[NVC_ATL_Windowing#136](../atl/codesnippet/cpp/supporting-idispeventimpl_3.h)]

Реализация почти завершена. Последний шаг касается консультирования и нежелательности внешних интерфейсов.

## <a name="advising-and-unadvising-the-idispeventimpl-interfaces"></a>Консультирование и неконсультирование интерфейсов IDispEventImpl

Последним шагом является реализация метода, который будет консультировать (или не консультировать) все точки соединения в надлежащее время. Это консультирование должно быть сделано, прежде чем общение между внешними клиентами и вашим объектом может иметь место. Перед тем, как объект становится видимым, каждый внешний интерфейс диспетчеризации, поддерживаемый объектом, запрашивается для исходящих интерфейсов. Устанавливается соединение и используется ссылка на исходящий интерфейс для обработки событий объекта. Эта процедура называется "консультирование".

После завершения вашего объекта с внешними интерфейсами исходящие интерфейсы должны быть уведомлены о том, что они больше не используются вашим классом. Этот процесс называется «нежелательным».

Из-за уникального характера объектов COM эта процедура варьируется, в деталях и исполнения, между реализациями. Эти детали выходят за рамки этой темы и не рассматриваются.

## <a name="see-also"></a>См. также раздел

[Основы объектов ATL COM](../atl/fundamentals-of-atl-com-objects.md)
