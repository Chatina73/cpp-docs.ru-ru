---
title: Расширения компонентов для .NET и UWP
ms.date: 10/12/2018
ms.topic: overview
helpviewer_keywords:
- what's new [C++], keywords
- what's new [C++], language features
- C++, keywords
- keywords [C++]
- Managed Extensions for C++, replacement syntax
ms.assetid: 1e400ee6-3ac9-4910-a608-9d3d5993e423
ms.openlocfilehash: 887fa14153e728735937604d531782a9ae7535bb
ms.sourcegitcommit: a1676bf6caae05ecd698f26ed80c08828722b237
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2020
ms.locfileid: "91509713"
---
# <a name="component-extensions-for-net-and-uwp"></a>Расширения компонентов для .NET и UWP

Стандарт C++ позволяет поставщикам компиляторов предоставлять нестандартные расширения языка. Корпорация Майкрософт предоставляет расширения для подключения собственного кода C++ к коду, выполняемому на платформе .NET Framework или универсальной платформе Windows (UWP). Расширения .NET называются C++/CLI и создают код, который выполняется в управляемой среде выполнения .NET, известной как Common Language Runtime (CLR). Расширения UWP называются C++/CX. Они создают собственный машинный код.

> [!NOTE]
> Для новых приложений рекомендуется использовать C++/WinRT вместо C++/CX. C++/WinRT — это новая стандартная языковая проекция C++17 для API среды выполнения Windows. Мы продолжим предоставлять поддержку C++/CX и WRL, но в новых приложениях настоятельно рекомендуется использовать C++/WinRT. См. дополнительные сведения о [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/index).

### <a name="two-runtimes-one-set-of-extensions"></a>Две среды выполнения, один набор расширений

C++/CLI расширяет стандарт C++ ISO/ANSI и определяется стандартом C++/CLI Ecma. Дополнительные сведения см. в статье [Программирование .NET с использованием C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md).

Расширения C++/CX представляют собой подмножество C++/CLI. Несмотря на то, что в большинстве случаев синтаксис расширения идентичен, создаваемый код зависит от того, указан ли параметр компилятора `/ZW`, предназначенный для UWP, или параметр `/clr`, предназначенный для .NET. Если для создания проекта используется Visual Studio, эти параметры устанавливаются автоматически.

## <a name="data-type-keywords"></a>Ключевые слова типов данных

Расширения языка содержат *агрегатные ключевые слова*, состоящие из двух токенов, разделенных пробелом. Когда токены используются отдельно, они могут иметь одно значение, а при использовании вместе — другое значение. Например, ключевое слово "ref" — это обычный идентификатор, а слово "class" — ключевое слово, объявляющее собственный класс. Однако при объединении этих слов в строку **ref class**, полученное агрегатное ключевое слово объявляет сущность, которая называется *класс среды выполнения*.

Расширения также содержат *контекстно-зависимые* ключевые слова. Ключевое слово рассматривается как контекстно-зависимое на основе типа содержащего его оператора и размещения в нем. Например, токен "property" может быть идентификатором или может объявлять специальный тип открытого члена класса.

В следующей таблице перечислены ключевые слова в расширении языка C++.

|Ключевое слово|Контекстно-зависимое?|Цель|Справочник|
|-------------|-----------------------|-------------|---------------|
|**ref class**<br /><br /> **ref struct**|Нет|Объявляет класс.|[Классы и структуры](classes-and-structs-cpp-component-extensions.md)|
|**value class**<br /><br /> **value struct**|Нет|Объявляет класс значения.|[Классы и структуры](classes-and-structs-cpp-component-extensions.md)|
|**Класс interface**<br /><br /> **interface struct**|Нет|Объявляет интерфейс.|[Класс interface](interface-class-cpp-component-extensions.md)|
|**Класс перечисления**<br /><br /> **enum struct**|Нет|Объявляет перечисление.|[Класс перечисления](enum-class-cpp-component-extensions.md)|
|**`property`**|Да|Объявляет свойство.|[property](property-cpp-component-extensions.md)|
|**delegate**|Да|Объявляет делегат.|[delegate (C++/CLI и C++/CX)](delegate-cpp-component-extensions.md)|
|**event**|Да|Объявление события.|[event](event-cpp-component-extensions.md)|

## <a name="override-specifiers"></a>Спецификаторы переопределения

Для указания поведения переопределения при наследовании можно использовать указанные ниже ключевые слова. Хотя **`new`** ключевое слово не является расширением C++, оно указывается здесь, так как его можно использовать в дополнительном контексте. Некоторые спецификаторы также допустимы для машинного программирования. Дополнительные сведения см. [в разделе инструкции. объявление описателей переопределения в компиляциях в собственном коде (C++/CLI)](../dotnet/how-to-declare-override-specifiers-in-native-compilations-cpp-cli.md).

|Ключевое слово|Контекстно-зависимое?|Цель|Справочник|
|-------------|-----------------------|-------------|---------------|
|**abstract**|Да|Указывает, что функции или классы являются абстрактными.|[abstract](abstract-cpp-component-extensions.md)|
|**`new`**|Нет|Указывает, что функция не является переопределением версии базового класса.|[new (новая ячейка в таблице vtable)](new-new-slot-in-vtable-cpp-component-extensions.md)|
|**override**|Да|Указывает, что метод должен быть переопределением версии базового класса.|[override](override-cpp-component-extensions.md)|
|**sealed**|Да|Предотвращает использование классов в качестве базовых классов.|[sealed](sealed-cpp-component-extensions.md)|

## <a name="keywords-for-generics"></a>Ключевые слова для универсальных шаблонов

Указанные ниже ключевые слова добавлены для поддержки универсальных типов. Дополнительные сведения см. в статье [Универсальные шаблоны](generics-cpp-component-extensions.md).

|Ключевое слово|Контекстно-зависимое?|Цель|
|-------------|-----------------------|-------------|
|**шаблона**|Нет|Объявляет универсальный тип.|
|**where**|Да|Определяет ограничения, применяемые к параметру универсального типа.|

## <a name="miscellaneous-keywords"></a>Прочие ключевые слова

В расширения C++ добавлены следующие ключевые слова.

|Ключевое слово|Контекстно-зависимое?|Цель|Справочник|
|-------------|-----------------------|-------------|---------------|
|**finally**|Да|Указывает поведение обработки исключений по умолчанию.|[Обработка исключений](exception-handling-cpp-component-extensions.md)|
|**for each, in**|Нет|Перечисляет элементы коллекции.|[for each, in](../dotnet/for-each-in.md)|
|**gcnew**|Нет|Выделяет типы в куче со сбором мусора. Используйте вместо **`new`** и **`delete`** .|[ref new, gcnew](ref-new-gcnew-cpp-component-extensions.md)|
|**ref new**|Да|Выделяет тип среды выполнения Windows. Используйте вместо **`new`** и **`delete`** .|[ref new, gcnew](ref-new-gcnew-cpp-component-extensions.md)|
|**initonly**|Да|Указывает, что член можно инициализировать только в объявлении или в статическом конструкторе.|[initonly (C++/CLI)](../dotnet/initonly-cpp-cli.md)|
|**literal**|Да|Создает переменную литерала.|[literal](literal-cpp-component-extensions.md)|
|**`nullptr`**|Нет|Означает, что обработчик или указатель не указывает на объект.|[nullptr](nullptr-cpp-component-extensions.md)|

## <a name="template-constructs"></a>Конструкции шаблонов

Перечисленные ниже языковые конструкции реализуются в виде шаблонов, а не ключевых слов. При указании параметра компилятора `/ZW` они определяются в пространстве имен `lang`. При указании параметра компилятора `/clr` они определяются в пространстве имен `cli`.

|Ключевое слово|Цель|Справочник|
|-------------|-------------|---------------|
|**array**|Объявляет массив.|[Массивы](arrays-cpp-component-extensions.md)|
|**interior_ptr**|(Только для среды CLR). Указывает на данные в ссылочном типе.|[interior_ptr (C++/CLI)](interior-ptr-cpp-cli.md)|
|**pin_ptr**|(Только для среды CLR). Указывает на ссылочные типы среды CLR, чтобы временно отключить систему сборки мусора.|[pin_ptr (C++/CLI)](pin-ptr-cpp-cli.md)|
|**safe_cast**|Определяет и выполняет оптимальный метод приведения для типа среды выполнения.|[safe_cast](safe-cast-cpp-component-extensions.md)|
|**`typeid`**|(Только для среды CLR). Извлекает объект <xref:System.Type?displayProperty=fullName>, описывающий заданный тип или объект.|[типа](typeid-cpp-component-extensions.md)|

## <a name="declarators"></a>Деклараторы

Следующие деклараторы типа указывают среде выполнения на необходимость автоматически управлять временем существования и удалением выделенных объектов.

|Оператор|Назначение|Справочник|
|--------------|-------------|---------------|
|`^`|Объявляет дескриптор объекта, то есть указатель на объект среды выполнения Windows или объект CLR, который автоматически удаляется, если больше не используется.|[Оператор Handle to Object (^)](handle-to-object-operator-hat-cpp-component-extensions.md)|
|`%`|Объявляет отслеживаемую ссылку, то есть ссылку на объект среды выполнения Windows или объект CLR, который автоматически удаляется, если больше не используется.|[Отслеживаемый оператор ссылки](tracking-reference-operator-cpp-component-extensions.md)|

## <a name="additional-constructs-and-related-topics"></a>Дополнительные конструкции и связанные разделы

В этом разделе перечислены дополнительные программные конструкции и разделы, относящиеся к среде CLR.

|Раздел|Описание|
|-----------|-----------------|
|[__identifier (C++/CLI)](identifier-cpp-cli.md)|(Среда выполнения Windows и среда CLR) Позволяет использовать ключевые слова как идентификаторы.|
|[Списки аргументов переменных (...) (C++/CLI)](variable-argument-lists-dot-dot-dot-cpp-cli.md)|(Среда выполнения Windows и среда CLR) Позволяет функции принимать переменное число аргументов.|
|[Эквиваленты собственным типам C++ в .NET Framework (C++/CLI)](../dotnet/managed-types-cpp-cli.md#dotnet)|Перечисляет типы среды CLR, используемые вместо целочисленных типов C++.|
|[AppDomain](../cpp/appdomain.md) **`__declspec`** Модификатор|**`__declspec`** модификатор, который требует, чтобы статические и глобальные переменные существовали для каждого домена AppDomain.|
|[Приведение в стиле C с использованием параметра /clr (C++/CLI)](c-style-casts-with-clr-cpp-cli.md)|Описывается интерпретация приведений в стиле C.|
|Соглашение о вызовах [__clrcall](../cpp/clrcall.md)|Указывается соглашение о вызовах, совместимое со средой CLR.|
|`__cplusplus_cli`|[Предопределенные макросы](../preprocessor/predefined-macros.md)|
|[Настраиваемые атрибуты](user-defined-attributes-cpp-component-extensions.md)|Описывается определение собственных атрибутов среды CLR.|
|[Обработка исключений](exception-handling-cpp-component-extensions.md)|Общие сведения об обработке исключений.|
|[Явные переопределения](explicit-overrides-cpp-component-extensions.md)|Демонстрируется переопределение произвольных членов функциями-членами.|
|[Дружественные сборки (C++)](../dotnet/friend-assemblies-cpp.md)|Описывается доступ клиентской сборки ко всем типам в компоненте сборки.|
|[Упаковка-преобразование](boxing-cpp-component-extensions.md)|Описываются условия, при которых упаковываются типы значений.|
|[Поддержка характеристик типов в компиляторе](compiler-support-for-type-traits-cpp-component-extensions.md)|Описывается выявление характеристик типов во время компиляции.|
|[управляемые, неуправляемые](../preprocessor/managed-unmanaged.md) директивы pragma|Демонстрируется сосуществование управляемых и неуправляемых функций в одном модуле.|
|[Обработка](../cpp/process.md) **`__declspec`** Модификатор|**`__declspec`** модификатор, который требует, чтобы статические и глобальные переменные существовали для каждого процесса.|
|[Отражение (C++/CLI)](../dotnet/reflection-cpp-cli.md)|Демонстрируется CLR-версия данных типа во время выполнения.|
|[String](string-cpp-component-extensions.md)|Описывается преобразование компилятором строковых литералов в объект <xref:System.String>.|
|[Пересылка типов (C++/CLI)](type-forwarding-cpp-cli.md)|Разрешает перемещение типа из поставляемой сборки в другую сборку, чтобы исключить необходимость повторной компиляции клиентского кода.|
|[Определяемые пользователем атрибуты](user-defined-attributes-cpp-component-extensions.md)|Демонстрируются атрибуты, определяемые пользователем.|
|[Директива #using](../preprocessor/hash-using-directive-cpp.md)|Импортирует внешние сборки.|
|[Документация XML](../build/reference/xml-documentation-visual-cpp.md)|Пояснения к документации кода на основе XML с использованием [/doc (обработка комментариев к документации) (C/C++)](../build/reference/doc-process-documentation-comments-c-cpp.md)|

## <a name="see-also"></a>См. также раздел

[Программирование .NET с использованием C++/CLI (Visual C++)](../dotnet/dotnet-programming-with-cpp-cli-visual-cpp.md)<br/>
[Взаимодействие машинного кода и .NET](../dotnet/native-and-dotnet-interoperability.md)
