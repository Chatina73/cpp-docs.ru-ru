---
title: enum class (C++/CLI и C++/CX)
ms.date: 10/12/2018
ms.topic: reference
ms.assetid: 8010fa8c-bad6-45b4-8214-b4db64d7ffe1
ms.openlocfilehash: 6305d41febfe4d55b2b84062e76ff62c3ea2b18a
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80182140"
---
# <a name="enum-class--ccli-and-ccx"></a>enum class (C++/CLI и C++/CX)

Объявляет перечисление в области видимости пространства имен, которое является определяемым пользователем типом, состоящим из ряда именованных констант, называемых перечислителями.

## <a name="all-runtimes"></a>Все среды выполнения

### <a name="remarks"></a>Remarks

C++/CX и C++/CLI поддерживают **открытый класс перечисления** и **закрытый класс перечисления**, которые схожи со стандартным **классом перечисления** C++, но с добавлением спецификатора доступа. В **/CLR** тип **класса перечисления** C++11 разрешен, но будет создавать предупреждение C4472, предназначенное для того, чтобы убедиться, что вам действительно требуется тип перечисления стандарта ISO, а не типы C++/CX или C++/CLI. Дополнительные сведения о ключевом слове стандарта ISO C++ **enum** см. в статье [Перечисления (C++)](../cpp/enumerations-cpp.md).

## <a name="windows-runtime"></a>Среда выполнения Windows

### <a name="syntax"></a>Синтаксис

```cpp
      access
      enum class
      enumeration-identifier
      [:underlying-type] { enumerator-list } [var];
accessenum structenumeration-identifier[:underlying-type] { enumerator-list } [var];
```

### <a name="parameters"></a>Параметры

*access*<br/>
Уровень доступа перечисления, который может быть **public** или **private**.

*enumeration-identifier*<br/>
Имя перечисления.

*underlying-type*<br/>
(Необязательно) Базовый тип перечисления.

(Необязательно. Только среда выполнения Windows) Базовый тип перечисления, который может быть **bool**, **char**, `char16`, `int16`, `uint16`, **int**, `uint32`, `int64` или `uint64`.

*enumerator-list*<br/>
Разделенный запятыми список имен перечислителей.

Значение каждого перечислителя — константное выражение, которое или определяется неявно компилятором, или явно нотацией *enumerator*`=`*constant-expression*. По умолчанию значение первого перечислителя ноль, если он определен неявно. Значение каждого следующего неявно определенного перечислителя — значение предыдущего перечислителя + 1.

*var*<br/>
(Необязательно) Имя переменной типа перечисления.

### <a name="remarks"></a>Remarks

Дополнительные сведения и примеры см. в разделе [Перечисления](../cppcx/enums-c-cx.md).

Обратите внимание, что компилятор выводит сообщения об ошибках, если константное выражение, задающее значение перечислителя, не может быть представлено *underlying-type*.  Однако компилятор не сообщает об ошибке для значения, недопустимого для базового типа. Пример:

- Если тип *underlying-type* числовой и перечислитель определяет максимальное значение для этого типа, то нельзя представить значение следующего неявно указанного перечисления.

- Если *базовый тип* — **bool**и более двух перечислителей определены неявно, то представить перечислители после первых двух невозможно.

- Если *underlying-type* является `char16`и значение перечисления в диапазоне от 0xD800 до 0xDFFF, то значение можно представить. Однако логически значение неверно, так как оно представляет половину пары символов-заместителей Юникода и не должно отображаться в изоляции.

### <a name="requirements"></a>Требования

Параметр компилятора: `/ZW`

## <a name="common-language-runtime"></a>Среда CLR

### <a name="syntax"></a>Синтаксис

```cpp
      access
      enum class
      name [:type] { enumerator-list } var;
accessenum structname [:type] { enumerator-list } var;
```

### <a name="parameters"></a>Параметры

*access*<br/>
Уровень доступа перечисления. Может быть **public** или **private**.

*enumerator-list*<br/>
Разделенный запятыми список идентификаторов (перечислителей) в перечислении.

*name*<br/>
Имя перечисления. Анонимные управляемые перечисления не допускаются.

*type*<br/>
(Необязательно) Базовый тип *identifiers*. Это может быть любой скалярный тип, например **int**, **short** или **long** со подписью или без.  **bool** или **char** также допустимы.

*var*<br/>
(Необязательно) Имя переменной типа перечисления.

### <a name="remarks"></a>Remarks

**enum class** и **enum struct** являются эквивалентными объявлениями.

Существуют два типа перечислений: управляемые (C++/CX) и стандартные.

Управляемые перечисления (или перечисления C++/CX) могут быть определены следующим образом:

```cpp
public enum class day {sun, mon };
```

Это семантически эквивалентно:

```cpp
ref class day {
public:
   static const int sun = 0;
   static const int mon = 1;
};
```

Стандартное перечисление может быть определено следующим образом:

```cpp
enum day2 { sun, mon };
```

Это семантически эквивалентно:

```cpp
static const int sun = 0;
static const int mon = 1;
```

Управляемые имена перечислителей (*identifiers*) не вводятся в область, в которой определяется перечисление; все ссылки на перечислители должны быть полными (*имя*`::`*идентификатор*).  По этой причине нельзя определить анонимное управляемое перечисление.

Перечислители стандартного перечисления строго вводятся во внешнюю область.  То есть, если есть другой символ с таким же именем, как у перечислителя во внешней области видимости, компилятор выдаст ошибку.

В Visual Studio 2002 и Visual Studio 2003 перечислители были нестрого вводимыми (видимыми во внешней области, если не было другого идентификатора с таким же именем).

Если определяется стандартное перечисление C++ (без ключевого слова **class** или **struct**), компиляция с параметром `/clr` будет приводить к компиляции перечисления как управляемого.  Перечисление по-прежнему имеет семантику неуправляемого перечисления.  Обратите внимание, что компилятор вводит атрибут `Microsoft::VisualC::NativeEnumAttribute` для определения намерения программиста сделать перечисление собственным.  Другие компиляторы просто увидят стандартное перечисление как управляемое перечисление.

Именованное стандартное перечисление, скомпилированное с параметром `/clr`, будет видимо в сборке как управляемое перечисление и может использоваться любым другим управляемым компилятором.   Однако безымянное стандартное перечисление не будет видимо из сборки.

В Visual Studio 2002 и Visual Studio 2003 стандартное перечисление используется в качестве типа в параметре функции.

```cpp
// mcppv2_enum.cpp
// compile with: /clr
enum E { a, b };
void f(E) {System::Console::WriteLine("hi");}

int main() {
   E myi = b;
   f(myi);
}
```

Этот код выдал бы в MSIL для сигнатуры функции следующее:

```cpp
void f(int32);
```

Однако в текущих версиях компилятора стандартное перечисление выдается как управляемое перечисление с [NativeEnumAttribute], а в MSIL для сигнатуры функции выдается следующее:

```cpp
void f(E)
```

Дополнительные сведения о неуправляемых перечислителях см. в разделе [Объявление перечислений C++](../cpp/enumerations-cpp.md).

Дополнительные сведения о перечислителях CLR см. в следующем разделе:

- [Базовый тип перечисления](../dotnet/how-to-define-and-consume-enums-in-cpp-cli.md)

### <a name="requirements"></a>Требования

Параметр компилятора: `/clr`

### <a name="examples"></a>Примеры

```cpp
// mcppv2_enum_2.cpp
// compile with: /clr
// managed enum
public enum class m { a, b };

// standard enum
public enum n { c, d };

// unnamed, standard enum
public enum { e, f } o;

int main()
{
   // consume managed enum
   m mym = m::b;
   System::Console::WriteLine("no automatic conversion to int: {0}", mym);
   System::Console::WriteLine("convert to int: {0}", (int)mym);

   // consume standard enum
   n myn = d;
   System::Console::WriteLine(myn);

   // consume standard, unnamed enum
   o = f;
   System::Console::WriteLine(o);
}
```

```Output
no automatic conversion to int: b

convert to int: 1

1

1
```

## <a name="see-also"></a>См. также раздел

[Расширения компонентов для .NET и UWP](component-extensions-for-runtime-platforms.md)
