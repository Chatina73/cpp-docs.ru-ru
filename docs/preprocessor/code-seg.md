---
title: code_seg
ms.date: 11/04/2016
f1_keywords:
- code_seg_CPP
- vc-pragma.code_seg
helpviewer_keywords:
- pragmas, code_seg
- code_seg pragma
ms.assetid: bf4faac1-a511-46a6-8d9e-456851d97d56
ms.openlocfilehash: e566fb01bf70b343b75254a10466bdda2bc7ce1b
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "59041245"
---
# <a name="codeseg"></a>code_seg
Определяет текстовый сегмент, в котором хранятся функции в OBJ-файле.

## <a name="syntax"></a>Синтаксис

```
#pragma code_seg( [ [ { push | pop }, ] [ identifier, ] ] [ "segment-name" [, "segment-class" ] )
```

### <a name="parameters"></a>Параметры

**push**<br/>
(Необязательно) Помещает запись во внутреннем стеке компилятора. Объект **принудительной** может иметь *идентификатор* и *имя сегмента*.

**pop**<br/>
(Необязательно) Удаление записи из верхней части внутреннего стека компилятора.

*identifier*<br/>
(Необязательно) При использовании с **принудительной**, назначает имя записи во внутреннем стеке компилятора. При использовании с **pop**, извлекает записи из внутреннего стека до *идентификатор* удаляется; Если *идентификатор* не найден во внутреннем стеке не выводятся.

*Идентификатор* позволяет вывести только с одним несколько записей **pop** команды.

"*имя сегмента*"<br/>
(Необязательно) Имя сегмента. При использовании с **pop**, стек выводится и *имя сегмента* становится активным именем текстового сегмента.

"*класс сегмента*"<br/>
(Необязательно) Игнорируется, но включается для совместимости с версиями C++ до версии 2.0.

## <a name="remarks"></a>Примечания

**Code_seg** директива pragma управляет размещением объектный код, созданный для шаблонов с созданными экземплярами, а также код, созданный неявно с помощью компилятора — например, специальных функций-членов. Мы рекомендуем использовать ["__declspec(code_seg(...))" ](../cpp/code-seg-declspec.md) вместо этого атрибут, поскольку она предоставляет управления размещением всего объектного кода. Сюда включается созданный компилятором код.

Объект *сегмент* в OBJ-файл представляет собой именованный блок данных, который загружается в память как одно целое. Объект *сегмент текста* сегмент, содержащий исполняемый код. В этой статье термины *сегмент* и *разделе* являются взаимозаменяемыми.

**Code_seg** директива pragma указывает компилятору поместить весь последующий объектный код из блока трансляции в сегмент текста с именем *имя сегмента*. По умолчанию для функций в obj-файле используется сегмент с именем .text.

Объект **code_seg** директиву pragma без параметров сбрасывает имя сегмента текста для последующего объектного кода на значение .text.

Можно использовать [(программа DUMPBIN). EXE](../build/reference/dumpbin-command-line.md) приложение для просмотра OBJ-файлы. Версии DUMPBIN для каждой поддерживаемой целевой архитектуры входят в состав Visual Studio.

## <a name="example"></a>Пример

В этом примере показано, как использовать **code_seg** директиву pragma, где объектный код помещается элемент управления:

```cpp
// pragma_directive_code_seg.cpp
void func1() {                  // stored in .text
}

#pragma code_seg(".my_data1")
void func2() {                  // stored in my_data1
}

#pragma code_seg(push, r1, ".my_data2")
void func3() {                  // stored in my_data2
}

#pragma code_seg(pop, r1)      // stored in my_data1
void func4() {
}

int main() {
}
```

Список имен, которые не должны использоваться для создания раздела, см. в разделе [/SECTION](../build/reference/section-specify-section-attributes.md).

Можно также указать разделы для инициализированных данных ([data_seg](../preprocessor/data-seg.md)), неинициализированных данных ([bss_seg](../preprocessor/bss-seg.md)) и переменных const ([const_seg](../preprocessor/const-seg.md)).

## <a name="see-also"></a>См. также

[code_seg (__declspec)](../cpp/code-seg-declspec.md)<br/>
[Директивы Pragma и ключевое слово __Pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md)