---
description: Дополнительные сведения о макросах (C/C++)
title: Макросы (C/C++)
ms.date: 08/29/2019
helpviewer_keywords:
- preprocessor
- preprocessor, macros
- Visual C++, preprocessor macros
ms.assetid: a7bfc5d4-2537-4fe0-bef0-70cec0b43388
ms.openlocfilehash: 460fd993ae27ab2603c3d2f832481c07713f4f98
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97333422"
---
# <a name="macros-cc"></a>Макросы (C/C++)

Препроцессор расширяет макросы во всех строках, за исключением *директив препроцессора*, строк, в которых в **#** качестве первого символа не пробела. Он расширяет макросы в части некоторых директив, которые не пропускаются как часть условной компиляции. *Директивы условной компиляции* позволяют подавлять компиляцию частей исходного файла. Они проверяют константное выражение или идентификатор, чтобы определить, какие текстовые блоки передать компилятору и какие из них нужно удалить из исходного файла во время предварительной обработки.

Директива `#define` обычно используется для связывания понятных идентификаторов с константами, ключевыми словами и часто используемыми операторами или выражениями. Идентификаторы, представляющие константы, иногда называют *символьными константами* или *константами манифеста*. Идентификаторы, представляющие операторы или выражения, называются *макросами*. В этой документации препроцессора используется только термин "макрос".

Если имя макроса распознается в исходном тексте программы или в аргументах некоторых других команд препроцессора, оно рассматривается как вызов этого макроса. Имя макроса заменяется копией тела макроса. Если макрос принимает аргументы, фактические аргументы после имени макроса заменяются на формальные параметры в теле макроса. Процесс замены вызова макроса с обработанной копией тела называется *расширением* вызова макроса.

На практике это означает, что существует два типа макросов. Макросы, *подобные объектам* , не имеют аргументов. Макросы, *подобные функциям* , можно определить для приема аргументов, чтобы они выглядели и действовали как вызовы функций. Поскольку макросы не создают фактические вызовы функций, вы иногда можете сделать программы быстрее, заменив вызовы функций на макросы. (В C++ часто используются встроенные функции.) Однако макросы могут создавать проблемы, если не определить их и использовать с осторожностью. Возможно, потребуется использовать круглые скобки в определениях макроса с аргументами, чтобы сохранить правильный приоритет в выражении. Кроме того, макросы могут неправильно обработать выражения с побочными эффектами. Дополнительные сведения см `getrandom` . в примере [директивы #define](../preprocessor/hash-define-directive-c-cpp.md).

После определения макроса его нельзя переопределить другим значением без предварительного удаления исходного определения. Однако макрос можно переопределить точно таким же определением. Поэтому одно и то же определение может появиться в программе несколько раз.

`#undef`Директива удаляет определение макроса. После удаления определения макроса можно переопределить другое значение. Директива [#define](../preprocessor/hash-define-directive-c-cpp.md) и [директива #undef](../preprocessor/hash-undef-directive-c-cpp.md) обсуждают `#define` `#undef` директивы и соответственно.

Дополнительные сведения см. в следующих разделах:

- [Макросы и C++](../preprocessor/macros-and-cpp.md)

- [Макрос со списками аргументов переменных](../preprocessor/variadic-macros.md)

- [Предустановленные макросы](../preprocessor/predefined-macros.md)

## <a name="see-also"></a>См. также раздел

[Справочник по препроцессору в C/C++](../preprocessor/c-cpp-preprocessor-reference.md)
