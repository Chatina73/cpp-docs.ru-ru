---
title: Макросы (C/C++)
ms.date: 08/29/2019
helpviewer_keywords:
- preprocessor
- preprocessor, macros
- Visual C++, preprocessor macros
ms.assetid: a7bfc5d4-2537-4fe0-bef0-70cec0b43388
ms.openlocfilehash: ba2c0f012974a528876219d00c61c0f31a6cd820
ms.sourcegitcommit: 6e1c1822e7bcf3d2ef23eb8fac6465f88743facf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2019
ms.locfileid: "70218859"
---
# <a name="macros-cc"></a>Макросы (C/C++)

Препроцессор расширяет макросы во всех строках, за исключением *директив*препроцессора, строк, **#** в которых в качестве первого символа не пробела. Он расширяет макросы в части некоторых директив, которые не пропускаются как часть условной компиляции. *Директивы условной компиляции* позволяют подавлять компиляцию частей исходного файла. Они проверяют константное выражение или идентификатор, чтобы определить, какие текстовые блоки передать компилятору и какие из них нужно удалить из исходного файла во время предварительной обработки.

Директива `#define` обычно используется для связывания понятных идентификаторов с константами, ключевыми словами и часто используемыми операторами или выражениями. Идентификаторы, представляющие константы, иногда называют символьными константами или *константами манифеста*. Идентификаторы, представляющие операторы или выражения,называются макросами. В этой документации препроцессора используется только термин "макрос".

Если имя макроса распознается в исходном тексте программы или в аргументах некоторых других команд препроцессора, оно рассматривается как вызов этого макроса. Имя макроса заменяется копией тела макроса. Если макрос принимает аргументы, фактические аргументы после имени макроса заменяются на формальные параметры в теле макроса. Процесс замены вызова макроса с обработанной копией тела называется *расширением* вызова макроса.

На практике это означает, что существует два типа макросов. Макросы, *подобные объектам* , не имеют аргументов. Макросы, *подобные функциям* , можно определить для приема аргументов, чтобы они выглядели и действовали как вызовы функций. Поскольку макросы не создают фактические вызовы функций, вы иногда можете сделать программы быстрее, заменив вызовы функций на макросы. (В C++ встраиваемые функции часто являются предпочтительным методом.) Однако макросы могут создавать проблемы, если не определить их и использовать с осторожностью. Возможно, потребуется использовать круглые скобки в определениях макроса с аргументами, чтобы сохранить правильный приоритет в выражении. Кроме того, макросы могут неправильно обработать выражения с побочными эффектами. Дополнительные сведения см `getrandom` . в примере директивы [#define](../preprocessor/hash-define-directive-c-cpp.md).

После определения макроса его нельзя переопределить другим значением без предварительного удаления исходного определения. Однако макрос можно переопределить точно таким же определением. Поэтому одно и то же определение может появиться в программе несколько раз.

`#undef` Директива удаляет определение макроса. После удаления определения макроса можно переопределить другое значение. Директива [#define](../preprocessor/hash-define-directive-c-cpp.md) и [директива #undef](../preprocessor/hash-undef-directive-c-cpp.md) обсуждают `#define` директивы и `#undef` соответственно.

Дополнительные сведения см. в следующих разделах:

- [Макросы и C++](../preprocessor/macros-and-cpp.md)

- [Макросы с переменным числом аргументов](../preprocessor/variadic-macros.md)

- [Предустановленные макросы](../preprocessor/predefined-macros.md)

## <a name="see-also"></a>См. также

[Справочник поC++ C/препроцессору](../preprocessor/c-cpp-preprocessor-reference.md)
