---
title: '#Директива import (C++)'
ms.date: 08/29/2019
f1_keywords:
- '#import'
helpviewer_keywords:
- .tlh files
- '#import directive'
- import directive (#import)
- tlh files
- tlbid switch
- preprocessor, directives
- COM, type library header file
ms.assetid: 787d1112-e543-40d7-ab15-a63d43f4030a
ms.openlocfilehash: afd05e7380ec3838fe9763be23ccfae338adb4fb
ms.sourcegitcommit: 6e1c1822e7bcf3d2ef23eb8fac6465f88743facf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2019
ms.locfileid: "70220261"
---
# <a name="import-directive-c"></a>Директива #importC++()

**C++Зависящ**

Используется для включения сведений из библиотеки типов. Содержимое библиотеки типов преобразовано в классы C++, в основном описывающие интерфейсы модели COM.

## <a name="syntax"></a>Синтаксис

> **#import** *атрибуты* *filename* \[] \
> **#import** *атрибуты имени файла*> ]\[ \<

### <a name="parameters"></a>Параметры

*файлов*\
Задает тип библиотеки для импорта. *Имя файла* может иметь один из следующих типов:

- Имя файла, содержащего библиотеку типов, например OLB-, TLB- или DLL-файла. Ключевое слово `file:`,, может предшествовать каждому имени файла.

- ИД программы элемента управления в библиотеке типов. Ключевое слово `progid:`,, может предшествовать каждому идентификатору ProgID. Например:

    ```cpp
    #import "progid:my.prog.id.1.5"
    ```

   Дополнительные сведения об идентификаторах ProgID см. [в разделе Указание идентификатора локализации и номера версии](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber).

   При использовании кросс-разрядного компилятора 32 в 64-разрядной операционной системе компилятор может только считывать 32-разрядный куст реестра. Может потребоваться использовать собственный 64-разрядный компилятор для создания и регистрации 64-разрядной библиотеки типов.

- Идентификатор библиотеки типов. Ключевое слово `libid:`,, может предшествовать каждому идентификатору библиотеки. Например:

    ```cpp
    #import "libid:12341234-1234-1234-1234-123412341234" version("4.0") lcid("9")
    ```

   `version` Если не указать или `lcid`, [правила](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber) , применяемые к `progid:` , также применяются к `libid:`.

- Исполняемый файл (.exe).

- Файл библиотеки (. dll), содержащий ресурс библиотеки типов (например, ocx).

- Составной документ, содержащую библиотеку типов.

- Любой другой формат файла, который может быть понят API **лоадтипелиб** .

*атрибута*\
Один или несколько [атрибутов #import](#_predir_the_23import_directive_import_attributes). Используйте в качестве разделителя атрибутов пробел или запятую. Например:

```cpp
#import "..\drawctl\drawctl.tlb" no_namespace, raw_interfaces_only
```

\-или-

```cpp
#import "..\drawctl\drawctl.tlb" no_namespace raw_interfaces_only
```

## <a name="remarks"></a>Примечания

### <a name="_predir_the_23import_directive_searchorderforfilename"></a>Порядок поиска для имени файла

*имя файла* при необходимости предшествует спецификации каталога. Имя файла должно указывать на существующий файл. Различие между двумя синтаксисами — это порядок, в котором препроцессор ищет файлы библиотеки типов, когда путь определен не полностью.

|Форма синтаксиса|Действие|
|-----------------|------------|
|Форма в кавычках|Предписывает препроцессору сначала искать файлы библиотеки типов в каталоге файла, содержащего инструкцию **#import** , а затем в каталогах любого файла (`#include`). Затем препроцессор выполняет поиск по путям, показанным ниже.|
|Форма с угловыми скобками|Указывает препроцессору искать файлы библиотеки типов по следующим путям.<br /><br /> 1.  Список путей к переменным среды `PATH`<br />2.  Список путей к переменным среды `LIB`<br />3.  Путь, указанный параметром компилятора [/i](../build/reference/i-additional-include-directories.md) , за исключением того, что компилятор выполняет поиск библиотеки типов, на которую имеется ссылка из другой библиотеки типов с атрибутом [no_registry](../preprocessor/no-registry.md) .|

### <a name="_predir_the_23import_directive_specifyingthelocalizationidandversionnumber"></a>Укажите идентификатор локализации и номер версии

При определении идентификатора программы можно также указать идентификатор программы локализации и номер версии. Например:

```cpp
#import "progid:my.prog.id" lcid("0") version("4.0)
```

Если идентификатор локализации не указан, то идентификатор ProgID выбирается в соответствии со следующими правилами.

- Если существует только один идентификатор локализации, он используется.

- Если существует несколько ИДЕНТИФИКАТОРов локализации, используется первый из них с номером версии 0, 9 или 409.

- Если существует несколько ИДЕНТИФИКАТОРов локализации, и ни один из них не равен 0, 9 или 409, то используется последний.

- Если номер версии не указан, используется самая последняя версия.

###  <a name="_predir_the_23import_directive_header_files_created_by_import"></a>Файлы заголовков, созданные при импорте

**#import** создает два файла заголовков, которые перестроят содержимое библиотеки C++ типов в исходном коде. Основной файл заголовка похож на тот, который был создан компилятором язык MIDL (MIDL), но с дополнительным кодом и данными, созданными компилятором. [Основной файл заголовка](#_predir_the_primary_type_library_header_file) имеет то же базовое имя, что и библиотека типов, а также. Расширение TLH. Вторичный файл заголовка имеет такое же базовое имя, что и библиотека типов, с расширением .TLI. Он содержит реализации созданных компилятором функций-членов и включен (`#include`) в соответствующий файл заголовка.

При импорте свойства DISP, использующего `byref` параметры, **#import** не создает инструкцию [__declspec (Property)](../cpp/property-cpp.md) для функции.

Оба файла заголовков помещаются в выходной каталог, заданный параметром [/FO (имя объектного файла)](../build/reference/fo-object-file-name.md) . Затем они считываются и компилируются компилятором так, как если бы основной файл заголовка был именован с помощью `#include` директивы.

Следующие оптимизации компилятора поставляются с директивой **#import** :

- Файл заголовка, когда создан, получает ту же отметку времени, что и библиотека типов.

- При обработке **#import** компилятор сначала проверяет существование и актуальность заголовка. Если да, то его не нужно создавать повторно.

Директива **#import** также участвует в минимальном перестроении и может быть помещена в файл предкомпилированного заголовка.  Дополнительные сведения см. в разделе [Создание предкомпилированных файлов](../build/creating-precompiled-header-files.md)заголовков.

### <a name="_predir_the_primary_type_library_header_file"></a>Файл заголовка основной библиотеки типов

Основной файл заголовка библиотеки типов состоит из 7 разделов:

- Шаблон заголовка: Состоит из комментариев, `#include` инструкции для comdef. H (который определяет некоторые стандартные макросы, используемые в заголовке) и другие прочие сведения о настройке.

- Пересылка ссылок и определений типов: Состоит из объявлений структуры, таких `struct IMyInterface` как и typedefs.

- Объявления интеллектуальных указателей: Класс `_com_ptr_t` шаблона является интеллектуальным указателем. Он инкапсулирует указатели интерфейса и устраняет необходимость в вызове `AddRef`функций, `Release`и. `QueryInterface` Он также скрывает `CoCreateInstance` вызов при создании нового COM-объекта. В этом разделе для определения определений `_COM_SMARTPTR_TYPEDEF` типов COM-интерфейсов в качестве специализаций шаблонов класса [_com_ptr_t](../cpp/com-ptr-t-class.md) используется инструкция Macro. Например, для interface интерфейс `IMyInterface`. Файл TLH будет содержать:

    ```TLH
    _COM_SMARTPTR_TYPEDEF(IMyInterface, __uuidof(IMyInterface));
    ```

   который будет развернут компилятором следующим образом.

    ```cpp
    typedef _com_ptr_t<_com_IIID<IMyInterface, __uuidof(IMyInterface)> > IMyInterfacePtr;
    ```

   Тип `IMyInterfacePtr` можно затем использовать вместо начального указателя интерфейса `IMyInterface*`. Следовательно, нет необходимости вызывать различные `IUnknown` функции элементов

- Объявления TypeInfo: В основном состоит из определений классов и других элементов, предоставляя отдельные элементы TypeInfo, `ITypeLib:GetTypeInfo`возвращаемые. В этом разделе каждый объект typeinfo из библиотеки типов отражается в заголовке в форме, которая определяется информацией `TYPEKIND`.

- Необязательное определение GUID старого стиля: Содержит инициализации именованных констант GUID. Эти имена имеют форму `CLSID_CoClass` и, как и `IID_Interface`те, что были созданы компилятором MIDL.

- Оператор `#include` для заголовка второстепенной библиотеки типов.

- Стандартный нижний колонтитул: В настоящее `#pragma pack(pop)`время включает.

Все разделы, кроме заголовков "Стандартный" и "нижний колонтитул", заключаются в пространство имен с именем `library` , указанным в инструкции в исходном IDL-файле. Имена из заголовка библиотеки типов можно использовать с помощью явной квалификации с использованием имени пространства имен. Можно также включить следующую инструкцию:

```cpp
using namespace MyLib;
```

сразу после оператора **#import** в исходном коде.

Пространство имен можно подавлять с помощью атрибута [no_namespace](no-namespace.md)директивы **#import** . Однако подавление пространства имен может привести к конфликтам имен. Пространство имен также может быть переименовано атрибутом [rename_namespace](rename-namespace.md) .

Компилятор предоставляет полный путь к любой зависимости библиотеки типов, необходимой для обработки в настоящее время библиотекой типов. Путь записывается в форме комментариев в заголовке библиотеки типов (.TLH), который компилятор создает для каждой обрабатываемой библиотеки типов.

Если библиотека типов содержит ссылки на типы, определенные в других библиотеках типов, TLH-файл включает комментарии следующей сортировки:

```TLH
//
// Cross-referenced type libraries:
//
//  #import "c:\path\typelib0.tlb"
//
```

Реальное имя файла в комментариях **#import** — это полный путь к библиотеке типов, на которую дана перекрестная ссылка, как сохранена в реестре. Если возникают ошибки, вызванные отсутствием определений типов, проверьте комментарии в заголовке. TLH, чтобы узнать, какие зависимые библиотеки типов должны быть импортированы первыми. Самыми вероятными ошибками являются синтаксические (например, C2143, C2146, C2321), C2501 (отсутствуют спецификаторы decl) и C2433 ("inline" не разрешается использовать в объявлении данных) при компиляции TLI-файла.

Чтобы устранить ошибки зависимостей, определите, какие комментарии зависимостей не предоставляются для системных заголовков, а затем предоставьте директиву **#import** в некоторый момент перед директивой **#import** зависимой библиотеки типов.

### <a name="_predir_the_23import_directive_import_attributes"></a>атрибуты #import

При необходимости **#import** может содержать один или несколько атрибутов. Эти атрибуты указывают, что компилятор изменяет содержимое заголовка библиотеки типов. Символ обратной **\\** косой черты () можно использовать для включения дополнительных строк в одну инструкцию **#import** . Например:

```cpp
#import "test.lib" no_namespace \
   rename("OldName", "NewName")
```

Дополнительные сведения см. в разделе [#import Attributes](../preprocessor/hash-import-attributes-cpp.md).

**КОНЕЦ C++ конкретного**

## <a name="see-also"></a>См. также

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)\
[Поддержка COM компилятором](../cpp/compiler-com-support.md)
