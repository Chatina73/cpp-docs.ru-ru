---
title: '#Импортировать директивы (C++)'
ms.date: 10/18/2018
f1_keywords:
- '#import'
helpviewer_keywords:
- .tlh files
- '#import directive'
- import directive (#import)
- tlh files
- tlbid switch
- preprocessor, directives
- COM, type library header file
ms.assetid: 787d1112-e543-40d7-ab15-a63d43f4030a
ms.openlocfilehash: a7dc30d3e5869e9b0f534a4769d4517a0514c144
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2019
ms.locfileid: "57822630"
---
# <a name="import-directive-c"></a>Директива #import (C++)

**Конкретных C++**

Используется для включения сведений из библиотеки типов. Содержимое библиотеки типов преобразовано в классы C++, в основном описывающие интерфейсы модели COM.

## <a name="syntax"></a>Синтаксис

```
#import "filename" [attributes]
#import <filename> [attributes]
```

### <a name="parameters"></a>Параметры

*filename*<br/>
Задает тип библиотеки для импорта. *Имя файла* может принимать одно из следующих:

- Имя файла, содержащего библиотеку типов, например OLB-, TLB- или DLL-файла. Ключевое слово **файл:**, может предшествовать имени каждого файла.

- ИД программы элемента управления в библиотеке типов. Ключевое слово **progid:**, может предшествовать каждому идентификатору программы. Пример:

    ```cpp
    #import "progid:my.prog.id.1.5"
    ```

   Дополнительные сведения об идентификаторах ProgID см. в разделе [задание ИД локализации и номер версии](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber).

   Обратите внимание, что при компилировании с использованием межкомпилятора в 64-разрядной операционной системе компилятор сможет прочитать только куст 32-разрядного реестра. Может потребоваться использовать собственный 64-разрядный компилятор для создания и регистрации 64-разрядной библиотеки типов.

- Идентификатор библиотеки типов. Ключевое слово **libid:**, может предшествовать каждому идентификатору библиотеки. Пример:

    ```cpp
    #import "libid:12341234-1234-1234-1234-123412341234" version("4.0") lcid("9")
    ```

   Если не указать версию или код языка, [правила](#_predir_the_23import_directive_specifyingthelocalizationidandversionnumber) , которые применяются к **progid:** также применяются к **libid:**.

- Исполняемый файл (.exe).

- Файл библиотеки (DLL), содержащий ресурс библиотеки типов (например, OCX).

- Составной документ, содержащую библиотеку типов.

- Любой другой формат файла, распознаваемые **LoadTypeLib** API.

*Атрибуты*<br/>
Один или несколько [атрибуты #import](#_predir_the_23import_directive_import_attributes). Используйте в качестве разделителя атрибутов пробел или запятую. Пример:

```cpp
#import "..\drawctl\drawctl.tlb" no_namespace, raw_interfaces_only
```

\-или-

```cpp
#import "..\drawctl\drawctl.tlb" no_namespace raw_interfaces_only
```

## <a name="remarks"></a>Примечания

## <a name="_predir_the_23import_directive_searchorderforfilename"></a> Порядок поиска имени файла

*Имя файла* при необходимости предваряется спецификацией каталога. Имя файла должно указывать на существующий файл. Различие между двумя синтаксисами — это порядок, в котором препроцессор ищет файлы библиотеки типов, когда путь определен не полностью.

|Форма синтаксиса|Действие|
|-----------------|------------|
|Форма в кавычках|Указывает препроцессору искать файлы библиотеки типов сначала в каталоге файла, содержащего **#import** инструкции, а затем в каталогах любых файлов, которые включают (`#include`) этого файла. Затем препроцессор выполняет поиск по путям, показанным ниже.|
|Форма с угловыми скобками|Указывает препроцессору искать файлы библиотеки типов по следующим путям.<br /><br /> 1.  `PATH` Список путей переменной среды<br />2.  `LIB` Список путей переменной среды<br />3.  Путь, указанный /I (Дополнительные каталоги включаемых файлов) параметр компилятора, за исключением его компилятор выполняет поиск библиотеки типов, на который была ссылка из другой библиотеки типов с [no_registry](../preprocessor/no-registry.md) атрибута.|

##  <a name="_predir_the_23import_directive_specifyingthelocalizationidandversionnumber"></a> Указание ИД локализации и номер версии

При определении идентификатора программы можно также указать идентификатор программы локализации и номер версии. Пример:

```cpp
#import "progid:my.prog.id" lcid("0") version("4.0)
```

Если не указать идентификатор локализации, идентификатор программы выбирается по следующим правилам.

- Если имеется только один ИД локализации, используется он.

- Если имеется несколько идентификаторов локализации, используется первый из них с номером версии 0, 9 или 409.

- Если имеется несколько идентификаторов локализации и ни один из них не равен 0, 9 или 409, используется последний.

- Если не указать номер версии, используется последняя версия.

##  <a name="_predir_the_23import_directive_header_files_created_by_import"></a> Файлы заголовков, созданные импортом

**#import** создает два файла заголовков, которые реконструируют содержимое библиотеки типов в исходном коде C++. Основной файл заголовка аналогичен файлу, создаваемому компилятором MIDL, но с дополнительными создаваемыми компилятором кодом и данными. [Основной файл заголовка](#_predir_the_primary_type_library_header_file) имеет такое же базовое имя, что в библиотеку типов, а также. TLH-расширение. Вторичный файл заголовка имеет такое же базовое имя, что и библиотека типов, с расширением .TLI. Он содержит реализации созданных компилятором функций-членов и включен (`#include`) в соответствующий файл заголовка.

Если импортировать свойство dispinterface, использующее параметры byref, #import не создает __declspec ([свойство](../cpp/property-cpp.md)) инструкции для функции.

Оба файла заголовка помещаются в выходной каталог, заданный параметром /Fo (имя объектного файла). Затем они считываются и компилируются компилятором, как если бы основной файл заголовка назывался директивой `#include`.

Следующие оптимизации компилятора поставляются с **#import** директивы:

- Файл заголовка, когда создан, получает ту же отметку времени, что и библиотека типов.

- Когда **#import** будет обработано, компилятор сначала проверяет, существует ли заголовок и в актуальном состоянии. Если да, повторно создавать его не требуется.

**#Import** директива также участвует в минимальном перестроении и может быть помещен в файл предкомпилированного заголовка. См. в разделе [Создание файлов предкомпилированных заголовков](../build/creating-precompiled-header-files.md) Дополнительные сведения.

###  <a name="_predir_the_primary_type_library_header_file"></a> Основной файл библиотеки типов заголовка
Основной файл заголовка библиотеки типов состоит из 7 разделов:

- Наименование заголовка: Состоит из комментариев, `#include` инструкции для COMDEF. H (который определяет некоторые стандартные макросы, используемые в заголовке) и других разнообразных сведений о настройке.

- Прямые ссылки и определения типов: Состоит из объявления структур, таких как `struct IMyInterface` и определения типов.

- Объявления интеллектуального указателя: Класс шаблона `_com_ptr_t` — это реализация интеллектуального указателя, которая инкапсулирует указатели интерфейса и исключает необходимость вызова `AddRef`, `Release`, `QueryInterface` функции. Кроме того, он скрывает вызов `CoCreateInstance` при создании нового COM-объекта. В этом разделе используется инструкция макрос `_COM_SMARTPTR_TYPEDEF` для установления интерфейсов модели COM, чтобы быть специализации шаблона [_com_ptr_t](../cpp/com-ptr-t-class.md) класс шаблона. Например, для интерфейса `IMyInterface`,. TLH-файл содержит:

    ```TLH
    _COM_SMARTPTR_TYPEDEF(IMyInterface, __uuidof(IMyInterface));
    ```

   который будет развернут компилятором следующим образом.

    ```cpp
    typedef _com_ptr_t<_com_IIID<IMyInterface, __uuidof(IMyInterface)> > IMyInterfacePtr;
    ```

   Тип `IMyInterfacePtr` можно затем использовать вместо начального указателя интерфейса `IMyInterface*`. Следовательно, нет необходимости вызывать различные `IUnknown` функции-члены

- Объявления typeInfo: В основном состоит из определений классов и других элементов, предоставляющих отдельные элементы typeinfo возвращаемый `ITypeLib:GetTypeInfo`. В этом разделе каждый объект typeinfo из библиотеки типов отражается в заголовке в форме, которая определяется информацией `TYPEKIND`.

- Необязательный определение старого стиля GUID: Содержит инициализации именованных констант GUID. Это имена вида `CLSID_CoClass` и `IID_Interface`, схожие с создаваемыми компилятором MIDL.

- Оператор `#include` для заголовка второстепенной библиотеки типов.

- Стандартный нижний колонтитул: В настоящее время включает в себя `#pragma pack(pop)`.

Все разделы, за исключением стандартного и нижний колонтитул стандартный колонтитула, заключены в пространстве имен, имя которого задается с `library` инструкции в исходном файле IDL. Можно использовать имена из заголовков библиотек типов путем явной квалификации с именем пространства имен или путем включения следующего оператора:

```cpp
using namespace MyLib;
```

сразу после **#import** инструкции в исходном коде.

Пространство имен можно подавить с помощью [no_namespace](#_predir_no_namespace) атрибут **#import** директива. Однако подавление пространства имен может привести к конфликтам имен. Пространство имен может быть переименовано [rename_namespace](#_predir_rename_namespace) атрибута.

Компилятор предоставляет полный путь к любой зависимости библиотеки типов, необходимой библиотеке типов, которая его в данный момент обрабатывает. Путь записывается в форме комментариев в заголовке библиотеки типов (.TLH), который компилятор создает для каждой обрабатываемой библиотеки типов.

Если библиотека типов содержит ссылки на типы, определенные в других библиотеках типов, TLH-файл включает комментарии следующей сортировки:

```TLH
//
// Cross-referenced type libraries:
//
//  #import "c:\path\typelib0.tlb"
//
```

Фактическое имя файла в **#import** комментарий — это полный путь к библиотеке типов, хранящихся в реестре. При возникновении ошибок, которые вызваны отсутствующими определения типа, проверьте комментарии в элементе .TLH, чтобы узнать, какие зависимые библиотеки типов может потребоваться импортировать в первую очередь. Самыми вероятными ошибками являются синтаксические (например, C2143, C2146, C2321), C2501 (отсутствуют спецификаторы decl) и C2433 ("inline" не разрешается использовать в объявлении данных) при компиляции TLI-файла.

Необходимо определить, какие зависимости комментарии, противном случае не предоставляются для заголовков системы, а затем укажите **#import** директив в некоторый момент перед **#import** директив зависимого объекта Библиотека типов для устранения ошибок.

## <a name="_predir_the_23import_directive_import_attributes"></a> атрибуты #import

**#import** при необходимости можно включить один или несколько атрибутов. Эти атрибуты указывают, что компилятор изменяет содержимое заголовка библиотеки типов. Обратная косая черта (**\\**) символ можно использовать для включения дополнительных строк в одном **#import** инструкции. Пример:

```cpp
#import "test.lib" no_namespace \
   rename("OldName", "NewName")
```

Дополнительные сведения см. в разделе [атрибуты #import](../preprocessor/hash-import-attributes-cpp.md).

**КОНЕЦ конкретных C++**

## <a name="see-also"></a>См. также

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)<br/>
[Поддержка COM компилятора](../cpp/compiler-com-support.md)