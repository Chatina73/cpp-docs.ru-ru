---
description: 'Дополнительные сведения о: после директивы pragma'
title: Прагма once
ms.date: 01/19/2021
f1_keywords:
- vc-pragma.once
- once_CPP
helpviewer_keywords:
- once pragma
- pragmas, once
ms.openlocfilehash: 87e3a87d8922868ce8ac3c48815c09de8727eba7
ms.sourcegitcommit: 3d9cfde85df33002e3b3d7f3509ff6a8dc4c0a21
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/21/2021
ms.locfileid: "98667224"
---
# <a name="once-pragma"></a>pragma `once`

Указывает, что компилятор включает файл заголовка только один раз при компиляции файла с исходным кодом.

## <a name="syntax"></a>Синтаксис

> **`#pragma once`**

## <a name="remarks"></a>Примечания

Использование `#pragma once` может сократить время сборки, так как компилятор не будет открывать и считывать файл снова после первого `#include` файла в записи преобразования. Он называется *оптимизацией с множественным включением*. Он действует аналогично параметру *include guard* , который использует определения макросов препроцессора для предотвращения множественного включения содержимого файла. Это также помогает предотвратить нарушения *правил одного определения*: требование, что все шаблоны, типы, функции и объекты содержат не более одного определения в коде.

Пример:

```cpp
// header.h
#pragma once
// Code placed here is included only once per translation unit
```

Мы рекомендуем директиву `#pragma once` для нового кода, так как она не засоряет глобальное пространство имен символами препроцессора. Она требует меньшего числа символов, она менее отвлекается от работы и не может привести к *конфликтам*. Конфликт символов — это ошибки, вызванные тем, что разные файлы заголовков используют один и тот же символ препроцессора, что и значение Guard. Он не является частью стандарта C++, но реализуется с помощью нескольких распространенных компиляторов.

В одном и том же файле нет преимуществ использования как набора условий, так и того и другого `#pragma once` . Компилятор распознает идиому include и реализует оптимизацию с множественным включением таким же образом, как и `#pragma once` директива, если код без комментария или директива препроцессора предшествует стандартной форме идиомы.

```cpp
// header.h
// Demonstration of the #include guard idiom.
// Note that the defined symbol can be arbitrary.
#ifndef HEADER_H_     // equivalently, #if !defined HEADER_H_
#define HEADER_H_
// Code placed here is included only once per translation unit
#endif // HEADER_H_
```

Мы рекомендуем использовать параметр include guard, если код должен быть переносимым на компиляторы, не реализующие `#pragma once` директиву, для поддержания согласованности с существующим кодом или при невозможности оптимизации с несколькими включаемыми данными. Это может произойти в сложных проектах, когда псевдонимы в файловой системе или пути включения псевдонимов не позволяют компилятору идентифицировать идентичные включаемые файлы по каноническому пути.

Будьте внимательны и не используйте `#pragma once` или включите в файлы заголовков параметр include guard, предназначенный для включения в несколько раз, который использует символы препроцессора для управления их эффектами. Пример такого дизайна см \<assert.h> . в файле заголовка. Также будьте внимательны при управлении путями include, чтобы избежать создания нескольких путей к включенным файлам, что может привести к невозможности одновременной оптимизации нескольких включаемых файлов `#pragma once` .

## <a name="see-also"></a>См. также раздел

[`pragma` директивы и `__pragma` ключевое слово](../preprocessor/pragma-directives-and-the-pragma-keyword.md)
