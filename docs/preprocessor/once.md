---
description: 'Дополнительные сведения: один раз pragma'
title: После pragma
ms.date: 01/22/2021
f1_keywords:
- vc-pragma.once
- once_CPP
helpviewer_keywords:
- once pragma
- pragma, once
no-loc:
- pragma
ms.openlocfilehash: 3edb5f88202ee783e587b1f886eddddf427f6133
ms.sourcegitcommit: a26a66a3cf479e0e827d549a9b850fad99b108d1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/22/2021
ms.locfileid: "98713484"
---
# <a name="once-no-locpragma"></a>`once` pragma

Указывает, что компилятор включает файл заголовка только один раз при компиляции файла с исходным кодом.

## <a name="syntax"></a>Синтаксис

> **`#pragma once`**

## <a name="remarks"></a>Примечания

Использование `#pragma once` может сократить время сборки, так как компилятор не будет открывать и считывать файл снова после первого `#include` файла в записи преобразования. Он называется *оптимизацией с множественным включением*. Он действует аналогично параметру *include guard* , который использует определения макросов препроцессора для предотвращения множественного включения содержимого файла. Это также помогает предотвратить нарушения *правил одного определения*: требование, что все шаблоны, типы, функции и объекты содержат не более одного определения в коде.

Например:

```cpp
// header.h
#pragma once
// Code placed here is included only once per translation unit
```

Мы рекомендуем директиву `#pragma once` для нового кода, так как она не засоряет глобальное пространство имен символами препроцессора. Она требует меньшего числа символов, она менее отвлекается от работы и не может привести к *конфликтам*. Конфликт символов — это ошибки, вызванные тем, что разные файлы заголовков используют один и тот же символ препроцессора, что и значение Guard. Он не является частью стандарта C++, но реализуется с помощью нескольких распространенных компиляторов.

В одном и том же файле нет преимуществ использования как набора условий, так и того и другого `#pragma once` . Компилятор распознает идиому include и реализует оптимизацию с множественным включением таким же образом, как и `#pragma once` директива, если код без комментария или директива препроцессора предшествует стандартной форме идиомы.

```cpp
// header.h
// Demonstration of the #include guard idiom.
// Note that the defined symbol can be arbitrary.
#ifndef HEADER_H_     // equivalently, #if !defined HEADER_H_
#define HEADER_H_
// Code placed here is included only once per translation unit
#endif // HEADER_H_
```

Мы рекомендуем использовать параметр include guard, если код должен быть переносимым на компиляторы, не реализующие `#pragma once` директиву, для поддержания согласованности с существующим кодом или при невозможности оптимизации с несколькими включаемыми данными. Это может произойти в сложных проектах, когда псевдонимы в файловой системе или пути включения псевдонимов не позволяют компилятору идентифицировать идентичные включаемые файлы по каноническому пути.

Будьте внимательны и не используйте `#pragma once` или включите в файлы заголовков параметр include guard, предназначенный для включения в несколько раз, который использует символы препроцессора для управления их эффектами. Пример такого дизайна см \<assert.h> . в файле заголовка. Также будьте внимательны при управлении путями include, чтобы избежать создания нескольких путей к включенным файлам, что может привести к невозможности одновременной оптимизации нескольких включаемых файлов `#pragma once` .

## <a name="see-also"></a>См. также раздел

[Директивы pragma и `__pragma` `_Pragma` Ключевые слова и](./pragma-directives-and-the-pragma-keyword.md)
