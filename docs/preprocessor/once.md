---
title: once
ms.date: 11/04/2016
f1_keywords:
- vc-pragma.once
- once_CPP
helpviewer_keywords:
- once pragma
- pragmas, once
ms.assetid: c7517556-6403-4b16-8898-f2aa0a6f685f
ms.openlocfilehash: 6061fe77960aa64e2dcb39db05897ef0e7fb5f2e
ms.sourcegitcommit: c7f90df497e6261764893f9cc04b5d1f1bf0b64b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/05/2019
ms.locfileid: "59039888"
---
# <a name="once"></a>once
Указывает, что при компилировании компилятором файла исходного кода данный файл будет включен (открыт) только один раз.

## <a name="syntax"></a>Синтаксис

```
#pragma once
```

## <a name="remarks"></a>Примечания

Использование `#pragma once` может сократить время сборки, так как компилятор не будет открыть и прочитать файл после первого `#include` файла в записи преобразования. Это называется *оптимизация множественного включения*. Он имеет эффекта, подобного действию `#include guard` идиому, которая использует определения макросов препроцессора для предотвращения множественных включений содержимого файла. Это также помогает предотвратить нарушение *правило одного определения*— требование, что все шаблоны, типы, функции и объекты имеют не более одного определения в коде.

Пример:

```
// header.h
#pragma once
// Code placed here is included only once per translation unit
```

Мы рекомендуем директиву `#pragma once` для нового кода, так как она не засоряет глобальное пространство имен символами препроцессора. Она требует меньше ввода кода, меньше отвлекает и не вызывает конфликтов символов — ошибок, возникающих, когда разные заголовочные файлы используют один и тот же символ препроцессора в качестве значения защиты. Она не входит в стандарт C++, но она переносимо реализована в нескольких популярных компиляторах.

Использование обеих директив, идиомы #include guard и `#pragma once`, в одном и том же файле не дает никаких преимуществ. Компилятор распознает идиому #include guard и выполняет оптимизацию множественного включения точно так же как и директива `#pragma once`, если исполняемый код или директива препроцессора располагаются до или после стандартной формы идиомы:

```
// header.h
// Demonstration of the #include guard idiom.
// Note that the defined symbol can be arbitrary.
#ifndef HEADER_H_     // equivalently, #if !defined HEADER_H_
#define HEADER_H_
// Code placed here is included only once per translation unit
#endif // HEADER_H_
```

Мы рекомендуем `#include guard` идиому, когда код должен быть переносимым для компиляторов, которые не реализуют `#pragma once` директива, для поддержания согласованности с существующим кодом или когда множественного включения оптимизация невозможна. Это может произойти в сложных проектах, когда использование псевдонимов в файловой системе или в путях включения не позволяет компилятору обнаруживать идентичные включаемые файлы с помощью канонического пути.

Не следует использовать `#pragma once` или `#include guard` идиому в файлах заголовков, которые призваны будет включена несколько раз с использованием символов препроцессора для управления их воздействие. Пример такой схемы, см. в разделе \<assert.h > файл заголовка. Также соблюдайте осторожность путей, чтобы избежать создания нескольких путей к включаемым файлам, что может свести на нет включения множественного включения оптимизации для обоих `#include guard`s и `#pragma once`.

## <a name="see-also"></a>См. также

[Директивы Pragma и ключевое слово __Pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md)