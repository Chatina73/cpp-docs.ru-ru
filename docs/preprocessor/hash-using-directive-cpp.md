---
title: '#Директива usingC++(/CLI)'
ms.date: 08/29/2019
f1_keywords:
- friend_as_cpp
- '#using'
- friend_as
- '#using_cpp'
helpviewer_keywords:
- using directive (#using)
- '#using directive'
- LIBPATH environment variable
- preprocessor, directives
ms.assetid: 870b15e5-f361-40a8-ba1c-c57d75c8809a
ms.openlocfilehash: 5dae5c277055157aef5451c19ee020fbbd2aaccb
ms.sourcegitcommit: 6e1c1822e7bcf3d2ef23eb8fac6465f88743facf
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2019
ms.locfileid: "70220198"
---
# <a name="using-directive-ccli"></a>Директива #usingC++(/CLI)

Импортирует метаданные в программу, скомпилированную с [параметром/CLR](../build/reference/clr-common-language-runtime-compilation.md).

## <a name="syntax"></a>Синтаксис

> **#using** *файл* [**as_friend**]

### <a name="parameters"></a>Параметры

*File*\
Файл MSIL .dll, .exe, .netmodule или .obj. Например, примененная к объекту директива

`#using <MyComponent.dll>`

**as_friend**\
Указывает, что все типы в *файле* доступны. Дополнительные сведения см. в разделе [дружественныеC++сборки ()](../dotnet/friend-assemblies-cpp.md).

## <a name="remarks"></a>Примечания

*файл* может представлять собой файл MSIL, который импортируется для управляемых данных и управляемых конструкций. Если DLL-файл содержит манифест сборки, то все библиотеки DLL, на которые имеются ссылки в манифесте, будут импортированы, а сборка, которую вы создаете, будет содержать *файл* в метаданных как ссылку на сборку.

Если *файл* не содержит сборку (если *файл* является модулем), и если вы не собираетесь использовать информацию о типах из модуля в текущем приложении (сборка), то можете просто указать, что модуль является частью сборки; Используйте [/ASSEMBLYMODULE](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md). После этого типы из этого модуля будут доступны любому приложению, ссылки на которые содержатся в этой сборке.

Альтернативой использованию **#using** является параметр компилятора [/Fu](../build/reference/fu-name-forced-hash-using-file.md) .

сборки. exe, передаваемые в **#using** , должны быть скомпилированы с помощью одного из компиляторов .NET Visual Studio ( C#например, Visual Basic или Visual).  При попытке импортировать метаданные из сборки файла .exe, скомпилированной с параметром `/clr`, возникнет исключение загрузки файла.

> [!NOTE]
> Компонент, на который имеется ссылка в **#using** , может выполняться с другой версией файла, импортированного во время компиляции, что приводит к непредсказуемым результатам в клиентском приложении.

Чтобы компилятор распознал тип в сборке (а не в модуле), необходимо принудительно разрешить тип. Например, можно принудительно определить экземпляр типа. Существуют и другие способы разрешения имен типов в сборке для компилятора. Например, при наследовании от типа в сборке имя типа будет называться компилятором.

При импорте метаданных, построенных на основе исходного кода, использующего [__declspec (thread)](../cpp/thread.md), семантика потока не сохраняется в метаданных. Например, переменная, объявленная с ключевым словом **__declspec (thread)** , скомпилированная в программу, созданную для .NET Framework среды CLR, а затем импортированная с помощью **#using**, не будет иметь семантику **__declspec (thread)** для переменной.

Все импортированные типы (управляемые и собственные) в файле, на который ссылаются **#using** , доступны, но компилятор обрабатывает собственные типы как объявления, а не определения.

При компиляции с параметром `/clr` ссылка на файл mscorlib.dll создается автоматически.

Переменная среды LIBPATH указывает каталоги для поиска, когда компилятор разрешает имена файлов, переданных в **#using**.

Компилятор ищет ссылки по следующему пути:

- Путь, указанный в операторе **#using** .

- Текущий каталог.

- Системный каталог .NET Framework.

- Каталоги, добавленные с помощью параметра компилятора [/AI](../build/reference/ai-specify-metadata-directories.md) .

- Каталоги, указанные в переменной среды LIBPATH.

## <a name="example"></a>Пример

Если вы создаете сборку (C) и ссылается на сборку (B), которая сама ссылается на другую сборку (A), вам не придется явно ссылаться на сборку A, если вы явно не используете один из типов в C.

```cpp
// using_assembly_A.cpp
// compile with: /clr /LD
public ref class A {};
```

## <a name="example"></a>Пример

```cpp
// using_assembly_B.cpp
// compile with: /clr /LD
#using "using_assembly_A.dll"
public ref class B {
public:
   void Test(A a) {}
   void Test() {}
};
```

## <a name="example"></a>Пример

В следующем примере отсутствует ошибка компилятора для отсутствия ссылок на *using_assembly_A. dll*, так как программа не использует типы, определенные в *using_assembly_A. cpp*.

```cpp
// using_assembly_C.cpp
// compile with: /clr
#using "using_assembly_B.dll"
int main() {
   B b;
   b.Test();
}
```

## <a name="see-also"></a>См. также

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)
