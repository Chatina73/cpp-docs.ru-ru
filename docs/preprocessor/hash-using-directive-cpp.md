---
title: '#Директива using (C + +/ CLI)'
ms.date: 10/18/2018
f1_keywords:
- friend_as_cpp
- '#using'
- friend_as
- '#using_cpp'
helpviewer_keywords:
- using directive (#using)
- '#using directive'
- LIBPATH environment variable
- preprocessor, directives
ms.assetid: 870b15e5-f361-40a8-ba1c-c57d75c8809a
ms.openlocfilehash: d69b06d29c366d0ff9c525421311001cab4e501c
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50501105"
---
# <a name="using-directive-ccli"></a># Директива using (C + +/ CLI)

Импортирует метаданные в программы, скомпилированной с [/CLR](../build/reference/clr-common-language-runtime-compilation.md).

## <a name="syntax"></a>Синтаксис

```
#using file [as_friend]
```

### <a name="parameters"></a>Параметры

*file*<br/>
Файл MSIL .dll, .exe, .netmodule или .obj. Например, примененная к объекту директива

`#using <MyComponent.dll>`

*as_friend*<br/>
Указывает, что все типы в *файл* доступны. Дополнительные сведения см. в разделе [дружественные сборки (C++)](../dotnet/friend-assemblies-cpp.md).

## <a name="remarks"></a>Примечания

*файл* может быть файлом промежуточного языка MSIL Microsoft, импортируемые в рамках своих управляемых данных и управляемых конструкций. Если DLL-файл содержит манифест сборки, то все библиотеки DLL, на которые ссылается манифест, импортируются и будут перечислены сборки, вы создаете *файл* в метаданных как ссылку на сборку.

Если *файл* не содержит сборку (если *файл* — это модуль) и если не планируется использовать сведения о типе из модуля в текущем приложении (сборке), вы можете просто указать, что Этот модуль является частью сборки; Используйте [добавившей](../build/reference/assemblymodule-add-a-msil-module-to-the-assembly.md). После этого типы из этого модуля будут доступны любому приложению, ссылки на которые содержатся в этой сборке.

Альтернатива использованию **#using** — [/FU](../build/reference/fu-name-forced-hash-using-file.md) параметр компилятора.

передаваемый сборок .exe **#using** должны быть скомпилированы с помощью одного из компиляторов .NET Visual Studio (Visual Basic или Visual C#, например).  При попытке импортировать метаданные из сборки файла .exe, скомпилированной с параметром `/clr`, возникнет исключение загрузки файла.

> [!NOTE]
> Это компонент, который связан с **#using** могут выполняться с помощью другой версии файла, импортируемого во время компиляции, в результате клиентское приложение может выдавать непрогнозируемый результат.

Для того чтобы компилятор мог распознавать тип в сборке (не в модуле), необходимо принудительно включить для него разрешение типа. К примеру, для этого можно определить экземпляр этого типа. Добиться того, чтобы компилятор разрешал имена типов в сборке, можно и другими способами. Например, если используется наследование от типа в сборке, то имя типа будет известно компилятору.

При импорте метаданных, созданных из исходного кода, который использован [__declspec(thread)](../cpp/thread.md), семантика потока не сохраняются в метаданных. Например, переменная, объявленная с **__declspec(thread)**, компилируется в программе, которая собирается для CLR .NET Framework, а затем импортируется через **#using**, больше не будет иметь **__declspec(thread)** семантики для переменной.

Все импортируемые типы (управляемый и машинный) в файле, который ссылается **#using** доступны, но компилятор обрабатывает собственные типы как объявления не определения.

При компиляции с параметром `/clr` ссылка на файл mscorlib.dll создается автоматически.

Переменной среды LIBPATH указывает каталоги, которые будут использоваться при попытке разрешения имен файлов, переданных компилятору **#using**.

Компилятор будет искать ссылки по следующим путям:

- Путь, указанный в **#using** инструкции.

- Текущий каталог.

- Системный каталог .NET Framework.

- Каталоги, добавленные с помощью [/AI](../build/reference/ai-specify-metadata-directories.md) параметр компилятора.

- Каталоги, указанные в переменной среды LIBPATH.

## <a name="example"></a>Пример

Если вы создаете сборку (C) и используете ссылку на сборку (B), которая сама содержит ссылки на другую сборку (A), то вам не придется создавать явную ссылку на сборку A, кроме случаев, когда вы явным образом используете один из типов сборки A в сборке C.

```cpp
// using_assembly_A.cpp
// compile with: /clr /LD
public ref class A {};
```

## <a name="example"></a>Пример

```cpp
// using_assembly_B.cpp
// compile with: /clr /LD
#using "using_assembly_A.dll"
public ref class B {
public:
   void Test(A a) {}
   void Test() {}
};
```

## <a name="example"></a>Пример

В следующем примере не создается ошибка компилятора, связанная с отсутствием ссылки "using_assembly_A.dll", поскольку в программе не используются типы, заданные в файле using_assembly_A.cpp.

```cpp
// using_assembly_C.cpp
// compile with: /clr
#using "using_assembly_B.dll"
int main() {
   B b;
   b.Test();
}
```

## <a name="see-also"></a>См. также

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)