---
title: '#Директива #define (C/C++)'
ms.date: 11/04/2016
f1_keywords:
- '#define'
helpviewer_keywords:
- define directive (#define), syntax
- preprocessor, directives
- define directive (#define)
- '#define directive, syntax'
- '#define directive'
ms.assetid: 33cf25c6-b24e-40bf-ab30-9008f0391710
ms.openlocfilehash: 8a0cc7e7836a0c82c72055fe8d9e7497995485d0
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62409906"
---
# <a name="define-directive-cc"></a>Директива #define (C/C++)

**#Define** создает *макрос*, представляющий собой ассоциацию обычного или параметризованного идентификатора со строкой токена. После определения макроса компилятор может подставить строку токена для каждого обнаруженного идентификатора в исходном файле.

## <a name="syntax"></a>Синтаксис

`#define` *Идентификатор* *строке токена*<sub>opt</sub>

`#define` *Идентификатор* `(` *идентификатор*<sub>opt</sub> `,` *...*  `,` *идентификатор*<sub>opt</sub> `)` *строке токена*<sub>opt</sub>

## <a name="remarks"></a>Примечания

**#Define** директива указывает компилятору заменить *строке токена* для каждого вхождения *идентификатор* в исходном файле. *Идентификатор* заменяется только в том случае, если он формирует токен. То есть *идентификатор* не заменяется, если он находится в комментарии, в строке, или как часть более длинного идентификатора. Дополнительные сведения см. в разделе [маркеры](../cpp/tokens-cpp.md).

*Строке токена* аргумент состоит из ряда токенов, например ключевых слов, констант или полных операторов. Один или несколько символов пробела необходимо отделить *строке токена* из *идентификатор*. Эти пробелы не считаются частью замененного текста, как и все остальные пробелы, следующие за последним токеном текста.

Объект `#define` без *строке токена* удаляет вхождения *идентификатор* из исходного файла. *Идентификатор* остается определенным и может быть проверен с помощью `#if defined` и `#ifdef` директивы.

Вторая форма синтаксиса определяет макрос, подобный функции, с параметрами. Эта форма допускает использование необязательного списка параметров, которые должны находиться в скобках. После макрос определен, каждое последующее вхождение *идентификатор*( *идентификатор*<sub>opt</sub>,..., *идентификатор* <sub>opt</sub> ) заменяется версией *строке токена* аргумент, который имеет вместо формальных параметров подставлены фактические аргументы.

Имена формальных параметров отображаются в *строке токена* чтобы пометить расположения, где подставляются фактические значения. Имя каждого параметра может встречаться несколько раз в *строке токена*, и имена могут размещаться в любом порядке. Число аргументов в вызове должно соответствовать числу параметров в определении макроса. Надлежащее использование скобок обеспечит правильную обработку сложных фактических аргументов.

Формальные параметры в списке разделяются запятыми. Все имена в списке должны быть уникальными, и список должен быть заключен в скобки. Не должно быть пробелов *идентификатор* и открывающую скобку. Используйте объединение строк — поместите обратную косую черту (`\`) непосредственно перед символом новой строки — для директив long в нескольких строках исходного кода. Область имени формального параметра распространяется на новую строку, оканчивающуюся *строке токена*.

Если макрос определен во второй форме синтаксиса, последующие текстовые экземпляры, за которыми находится список аргументов, указывают на вызов макроса. Фактические аргументы, следующие за экземпляром *идентификатор* в исходном файле сопоставляются с соответствующими формальными параметрами в определении макроса. Каждый формальный параметр в *строке токена* , не предшествует оператор создания строки (`#`), создания символа (`#@`), или вставки токена (`##`) оператор, или не следуют `##` оператор, заменяется соответствующим фактическим аргументом. Перед заменой директивой формального параметра все макросы в фактическом аргументе разворачиваются. (Операторы описаны в [операторы препроцессора](../preprocessor/preprocessor-operators.md).)

В следующих примерах макросов с аргументами показаны вторая форма **#define** синтаксис:

```C
// Macro to define cursor lines
#define CURSOR(top, bottom) (((top) << 8) | (bottom))

// Macro to get a random integer with a specified range
#define getrandom(min, max) \
    ((rand()%(int)(((max) + 1)-(min)))+ (min))
```

Аргументы с побочными эффектами иногда приводят к тому, что макросы дают непредвиденные результаты. Заданный формальный параметр появляется более одного раза в *строке токена*. Если этот формальный параметр заменяется выражением с побочными эффектами, выражение с такими эффектами может вычисляться несколько раз. (См. Примеры в разделе [оператор вставки токена (##)](../preprocessor/token-pasting-operator-hash-hash.md).)

Директива `#undef` приводит к тому, что определение препроцессора идентификатора забывается. См. в разделе [директива #undef](../preprocessor/hash-undef-directive-c-cpp.md) Дополнительные сведения.

Если имя определяемого макроса происходит в *строке токена* (даже в качестве результата расширения другого макроса), он не развернут.

Секунды **#define** для макроса с тем же именем выдает предупреждение, если вторая последовательность токенов идентичен первому.

**Блок, относящийся только к системам Microsoft**

Если новое определение синтаксически совпадает с исходным, Microsoft C и C++ позволяют переопределить макрос. Другими словами, два определения могут иметь разные имена параметров. Это поведение отличается от ANSI C, который требует лексической идентичности двух определений.

Например, следующие два макроса идентичны, за исключением имен параметров. ANSI C не допускает такое переопределение, но Microsoft C/C++ компилируют его без ошибок.

```C
#define multiply( f1, f2 ) ( f1 * f2 )
#define multiply( a1, a2 ) ( a1 * a2 )
```

С другой стороны, следующие два макроса неидентичны и приводят к выдаче предупреждения в Microsoft C и C++.

```C
#define multiply( f1, f2 ) ( f1 * f2 )
#define multiply( a1, a2 ) ( b1 * b2 )
```

**Завершение блока, относящегося только к системам Майкрософт**

Этот пример иллюстрирует **#define** директивы:

```C
#define WIDTH       80
#define LENGTH      ( WIDTH + 10 )
```

Первый оператор определяет идентификатор `WIDTH` как целочисленную константу 80, а затем `LENGTH` задается в виде `WIDTH` и целочисленной константы 10. Каждое вхождение `LENGTH` заменяется на (`WIDTH + 10`). В свою очередь, каждое вхождение `WIDTH + 10` заменяется выражением (`80 + 10`). Скобки вокруг `WIDTH + 10` имеют важное значение, поскольку управляют интерпретацией в операторах, например в следующем:

```C
var = LENGTH * 20;
```

После этапа предварительной обработки этот оператор принимает следующий вид:

```C
var = ( 80 + 10 ) * 20;
```

что равно 1800. Без скобок результат будет следующим:

```C
var = 80 + 10 * 20;
```

что дает в результате 280.

**Блок, относящийся только к системам Microsoft**

Определение макросов и констант с [/D](../build/reference/d-preprocessor-definitions.md) параметр компилятора действует так же, как с помощью **#define** директивы предварительной обработки в начале файла. С помощью параметра /D можно определить до 30 макросов.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)