---
title: pack
ms.date: 12/17/2018
f1_keywords:
- pack_CPP
- vc-pragma.pack
helpviewer_keywords:
- pragmas, pack
- pack pragma
ms.assetid: e4209cbb-5437-4b53-b3fe-ac264501d404
ms.openlocfilehash: da4484ec86d39c8fa55a741eadd53a1d614b20dc
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69510173"
---
# <a name="pack"></a>pack
Задает выравнивание упаковки для членов структуры, объединения и класса.

## <a name="syntax"></a>Синтаксис

```
#pragma pack( [ show ] | [ push | pop ] [, identifier ] , n  )
```

### <a name="parameters"></a>Параметры

**казывающи**<br/>
Используемых Отображает текущее значение байта для выравнивания упаковки. Значение отображается в предупреждении.

**push**<br/>
Используемых Помещает текущее значение выравнивания упаковки во внутренний стек компилятора и устанавливает для текущего значения выравнивания упаковки значение *n*. Если *n* не задано, то передается текущее значение выравнивания упаковки.

**pop**<br/>
Используемых Удаляет запись из верхнего внутреннего стека компилятора. Если параметр *n* не указан вместе с **POP**, то значение упаковки, связанное с результирующей записью в верхней части стека, — это новое значение выравнивания упаковки. Если указано значение *n* , то, например `#pragma pack(pop, 16)`, *n* становится новым значением выравнивания упаковки. Если вы открылис идентификатором, `#pragma pack(pop, r1)`например, то все записи в стеке будут извлечены до тех пор, пока не будет найдена запись с *идентификатором* . Эта запись извлекается из стека, и новым значением выравнивания упаковки становится значение упаковки, связанное с результирующей записью в вершине стека. Если точка с идентификатором не найдена ни в одной записи в стеке, то эта **точка** не учитывается.

*identifier*<br/>
Используемых При использовании с *Push*назначает имя записи во внутреннем стеке компилятора. При использовании с **POP**выводит запись из внутреннего стека до тех пор, пока *идентификатор* не будет удален. Если *идентификатор* не найден во внутреннем стеке, ничего не извлекается.

*n*<br/>
Используемых Указывает значение в байтах, используемое для упаковки. Если параметр компилятора [/Zp](../build/reference/zp-struct-member-alignment.md) не задан для модуля, значение по умолчанию для *n* равно 8. Допустимые значения: 1, 2, 4, 8 и 16. Выравнивание элемента будет на границе, кратной *n* , или кратном размеру элемента, в зависимости от того, что меньше.

`#pragma pack(pop, identifier, n)`не определено.

## <a name="remarks"></a>Примечания

Упаковать класс значит разместить его члены непосредственно друг за другом в памяти, что может привести к тому, что некоторые или все члены могут быть выровнены по границе меньшей, чем выравнивание целевой архитектуры, заданное по умолчанию. **Pack** предоставляет управление на уровне объявления данных. Это отличается от параметра компилятора [/Zp](../build/reference/zp-struct-member-alignment.md), который обеспечивает только управление на уровне модуля. **пакет** вступает в силу в первом объявлении **структуры**, **объединения**или **класса** после того, как будет показана директива pragma. **Pack** не влияет на определения. Вызов **Pack** без аргументов задает значение *n* , заданное в параметре `/Zp`компилятора. Если этот параметр компилятора не указан, по умолчанию используется значение 8.

При изменении выравнивания структуры она может занимать меньше места в памяти, но возможно снижение производительности или даже возникновение аппаратного исключения для невыровненного доступа.  Это поведение исключения можно изменить с помощью [функцию SetErrorMode](/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode).

Дополнительные сведения об изменении выравнивания см. в следующих разделах:

- [__alignof](../cpp/alignof-operator.md)

- [align](../cpp/align-cpp.md)

- [__unaligned](../cpp/unaligned.md)

- [Примеры выравнивания структуры](../build/x64-software-conventions.md#examples-of-structure-alignment) (только для x64)

   > [!WARNING]
   > Обратите внимание, что в Visual Studio 2015 и более поздних версиях можно использовать стандартные операторы alignas и alignof, которые в отличие от `__alignof` и `declspec( align )` могут переноситься между компиляторами. C++ Стандарт не поддерживает упаковку, поэтому необходимо по-прежнему использовать **Pack** (или соответствующее расширение в других компиляторах), чтобы указать выравнивание, размер которого меньше, чем длина слова целевой архитектуры.

## <a name="examples"></a>Примеры

В следующем примере показано, как использовать директиву pragma **Pack** для изменения выравнивания структуры.

```cpp
// pragma_directives_pack.cpp
#include <stddef.h>
#include <stdio.h>

struct S {
   int i;   // size 4
   short j;   // size 2
   double k;   // size 8
};

#pragma pack(2)
struct T {
   int i;
   short j;
   double k;
};

int main() {
   printf("%zu ", offsetof(S, i));
   printf("%zu ", offsetof(S, j));
   printf("%zu\n", offsetof(S, k));

   printf("%zu ", offsetof(T, i));
   printf("%zu ", offsetof(T, j));
   printf("%zu\n", offsetof(T, k));
}
```

```Output
0 4 8
0 4 6
```

В следующем примере показано, как использовать синтаксис *Push*, *POP*и *Показать* .

```cpp
// pragma_directives_pack_2.cpp
// compile with: /W1 /c
#pragma pack()   // n defaults to 8; equivalent to /Zp8
#pragma pack(show)   // C4810
#pragma pack(4)   // n = 4
#pragma pack(show)   // C4810
#pragma pack(push, r1, 16)   // n = 16, pushed to stack
#pragma pack(show)   // C4810
#pragma pack(pop, r1, 2)   // n = 2 , stack popped
#pragma pack(show)   // C4810
```

## <a name="see-also"></a>См. также

[Директивы Pragma и ключевое слово __Pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md)