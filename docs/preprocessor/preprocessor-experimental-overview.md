---
title: Экспериментальный предпроцессорный обзор MSVC
description: Препроцессор MSVC обновляется в соответствии со стандартами C/C.
ms.date: 02/09/2020
helpviewer_keywords:
- preprocessor, experimental
ms.openlocfilehash: 00c34ef75270e505d3781cf7eedf4d8aba95ee6e
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81337481"
---
# <a name="msvc-experimental-preprocessor-overview"></a>Экспериментальный предпроцессорный обзор MSVC

::: moniker range="vs-2015"

Visual Studio 2015 использует традиционный препроцессор, который не соответствует стандартному СЗ. Экспериментальный препроцессор доступен в Visual Studio 2017 и Visual Studio 2019 с помощью [/экспериментального:препроцессорного](../build/reference/experimental-preprocessor.md) компилятора компилятора. Более подробная информация об использовании нового препроцессора в Visual Studio 2017 и Visual Studio 2019 доступна. Чтобы просмотреть документацию для предпочтительной версии Visual Studio, используйте элемент управления селектора **версии.** Он находится в верхней части таблицы содержимого на этой странице.

::: moniker-end

::: moniker range=">=vs-2017"

Мы обновляем препроцессор Microsoft C, чтобы улучшить соответствие стандартам, исправить давние ошибки и изменить некоторые поведения, которые официально не определены. Мы также добавили новые диагностические данные, чтобы предупредить об ошибках в макроопределениях.

Эти изменения доступны с помощью [/экспериментального:препроцессорного](../build/reference/experimental-preprocessor.md) компилятора переключателя в Visual Studio 2017 или Visual Studio 2019. Предпроцессорное поведение по умолчанию остается таким же, как и в предыдущих версиях.

Начиная с версии Visual Studio 2019 16.5, экспериментальная предпроцессорная поддержка стандарта СЗ20 является полностью полной.

## <a name="new-predefined-macro"></a>Новый предопределенный макрос

Можно определить, какой препроцессор используется во время компилята. Проверьте значение предопределенного [ \_макроMSVC\_TRADITIONAL,](predefined-macros.md) чтобы успокоить традиционный препроцессор. Этот макрос устанавливается безоговорочно версиями компилятора, которые его поддерживают, независимо от которых вызывается препроцессор. Его значение составляет 1 для традиционного препроцессора. Это 0 для соответствующего препроцессора.

```cpp
#if defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL
// Logic using the traditional preprocessor
#else
// Logic using cross-platform compatible preprocessor
#endif
```

## <a name="behavior-changes-in-the-experimental-preprocessor"></a>Изменения поведения в экспериментальном препроцессоре

Первоначальная работа над экспериментальным препроцессором была сосредоточена на том, чтобы все макрорасширения соответствовали стандарту. Он позволяет использовать компилятор MSVC с библиотеками, которые в настоящее время заблокированы традиционным поведением. Мы протестировали обновленный препроцессор на реальных мировых проектах. Вот некоторые из наиболее распространенных изменений, которые мы обнаружили:

### <a name="macro-comments"></a>Макро комментарии

Традиционный препроцессор основан на буферах символов, а не на допроцессорных токенах. Это позволяет необычное поведение, такие как следующий препроцессор комментарий трюк, который не работает под соответствующим препроцессором:

```cpp
#if DISAPPEAR
#define DISAPPEARING_TYPE /##/
#else
#define DISAPPEARING_TYPE int
#endif

// myVal disappears when DISAPPEARING_TYPE is turned into a comment
DISAPPEARING_TYPE myVal;
```

Исправление, соответствующее стандартам, `int myVal` заключается `#ifdef/#endif` в декларирование мгновения в соответствующих директивах:

```cpp
#define MYVAL 1

#ifdef MYVAL
int myVal;
#endif
```

### <a name="lval"></a>Лёваль

Традиционный препроцессор неправильно сочетает строку префикс аттек с результатом [оператора струнного оператора:](stringizing-operator-hash.md)

```cpp
 #define DEBUG_INFO(val) L"debug prefix:" L#val
//                                       ^
//                                       this prefix

const wchar_t *info = DEBUG_INFO(hello world);
```

В этом случае `L` приставка не нужна, потому что смежные буквы строки объединяются после макрорасширения в любом случае. Исправление, совместимое в обратном направлении, заключается в изменении определения:

```cpp
#define DEBUG_INFO(val) L"debug prefix:" #val
//                                       ^
//                                       no prefix
```

Та же проблема также встречается в удобстве макросов, которые "струнят" аргумент в широкий буквальной строки:

```cpp
 // The traditional preprocessor creates a single wide string literal token
#define STRING(str) L#str
```

Вы можете решить проблему различными способами:

- Используйте строку `L""` concatenation и `#str` добавить префикс. Соседние строки буквальные комбинируются после макрорасширения:

   ```cpp
   #define STRING1(str) L""#str
   ```

- Добавить префикс после `#str` нанизаны с дополнительным макро расширением

   ```cpp
   #define WIDE(str) L##str
   #define STRING2(str) WIDE(#str)
   ```

- Используйте оператор `##` конкатации для объединения токенов. Порядок операций `##` `#` для и не определен, хотя все `#` компиляторы, кажется, оценивают оператора раньше `##` в этом случае.

   ```cpp
   #define STRING3(str) L## #str
   ```

### <a name="warning-on-invalid-"></a>Предупреждение о недействительном\#\#

Если [оператор вставки маркеров](token-pasting-operator-hash-hash.md) не приводит к попадеке в один допустимый токен предварительной обработки, поведение не определено. Традиционный препроцессор молча не удается объединить токены. Новый предварительный процессор соответствует поведению большинства других компиляторов и испускает диагностику.

```cpp
// The ## is unnecessary and does not result in a single preprocessing token.
#define ADD_STD(x) std::##x
// Declare a std::string
ADD_STD(string) s;
```

### <a name="comma-elision-in-variadic-macros"></a>Запятая элизион в вариадных макросах

Традиционный предпроцессор MSVC всегда удаляет `__VA_ARGS__` запятые перед пустыми заменами. Экспериментальный препроцессор более внимательно следит за поведением других популярных кроссплатформенных компиляторов. Для удаления запятой вариативный аргумент должен отсутствовать (а `##` не только пустой) и быть помечен оператором. Рассмотрим следующий пример:

```cpp
void func(int, int = 2, int = 3);
// This macro replacement list has a comma followed by __VA_ARGS__
#define FUNC(a, ...) func(a, __VA_ARGS__)
int main()
{
    // In the traditional preprocessor, the
    // following macro is replaced with:
    // func(10,20,30)
    FUNC(10, 20, 30);

    // A conforming preprocessor replaces the
    // following macro with: func(1, ), which
    // results in a syntax error.
    FUNC(1, );
}
```

В следующем примере в `FUNC2(1)` вызове к вариадной аргументу отсутствует в приводе макроса. В вызове `FUNC2(1, )` к вариативный аргумент пуст, но не отсутствует (обратите внимание на запятую в списке аргументов).

```cpp
#define FUNC2(a, ...) func(a , ## __VA_ARGS__)
int main()
{
   // Expands to func(1)
   FUNC2(1);

   // Expands to func(1, )
   FUNC2(1, );
}
```

В предстоящем стандарте СЗ20 эта проблема была `__VA_OPT__`решена путем добавления . Экспериментальная `__VA_OPT__` предпроцессорная поддержка доступна начиная с версии Visual Studio 2019 16.5.

### <a name="c20-variadic-macro-extension"></a>Вазиадное макрорасширение СЗ20

Экспериментальный препроцессор поддерживает вазиадный макроаргументный элизион:

```cpp
#define FUNC(a, ...) __VA_ARGS__ + a
int main()
  {
  int ret = FUNC(0);
  return ret;
  }
```

Этот код не соответствует стандарту СЗ20. В MSVC экспериментальный препроцессор расширяет это поведение с ИК-20**`/std:c++14`** **`/std:c++17`** до более низких языковых стандартных режимов (, ). Это расширение соответствует поведению других крупных кроссплатформенных компиляторов C'.

### <a name="macro-arguments-are-unpacked"></a>Макро аргументы "распакочены"

В традиционном препроцессоре, если макрос перенаправляет один из своих аргументов на другой зависимый макрос, то аргумент не «распаковывается» при вставке. Обычно эта оптимизация проходит незамеченным, но может привести к необычному поведению:

```cpp
// Create a string out of the first argument, and the rest of the arguments.
#define TWO_STRINGS( first, ... ) #first, #__VA_ARGS__
#define A( ... ) TWO_STRINGS(__VA_ARGS__)
const char* c[2] = { A(1, 2) };

// Conforming preprocessor results:
// const char c[2] = { "1", "2" };

// Traditional preprocessor results, all arguments are in the first string:
// const char c[2] = { "1, 2", };
```

При расширении `A()`, традиционный препроцессор препроцессор препровожствует все аргументы упакованы в `__VA_ARGS__` первый `TWO_STRINGS` аргумент TWO_STRINGS, который оставляет вариатный аргумент пустым. Это приводит `#first` к результату быть "1, 2", а не просто "1". Если вы внимательно следите за этим, то вы можете `#__VA_ARGS__` быть удивлены, что случилось с результатом в традиционном препроцессорном `""`расширении: если вариатиальный параметр пуст, это должно привести к пустой строке буквального . Отдельный выпуск удерживал от генерируемых пустых строк буквального маркера.

### <a name="rescanning-replacement-list-for-macros"></a>Список замены rescanning для макросов

После замены макроса полученные токены пересканируются для замены дополнительных идентификаторов макроса. Алгоритм, используемый традиционным препроцессором для выполнения повторного сканирования, не соответствует, как показано в этом примере, основанном на фактическом коде:

```cpp
#define CAT(a,b) a ## b
#define ECHO(...) __VA_ARGS__
// IMPL1 and IMPL2 are implementation details
#define IMPL1(prefix,value) do_thing_one( prefix, value)
#define IMPL2(prefix,value) do_thing_two( prefix, value)

// MACRO chooses the expansion behavior based on the value passed to macro_switch
#define DO_THING(macro_switch, b) CAT(IMPL, macro_switch) ECHO(( "Hello", b))
DO_THING(1, "World");

// Traditional preprocessor:
// do_thing_one( "Hello", "World");
// Conforming preprocessor:
// IMPL1 ( "Hello","World");
```

Хотя этот пример может показаться немного надуманным, мы видели его в реальном мире кода. Чтобы увидеть, что происходит, мы можем сломать `DO_THING`расширение, начиная с:

1. `DO_THING(1, "World")`расширяется до`CAT(IMPL, 1) ECHO(("Hello", "World"))`
1. `CAT(IMPL, 1)`расширяется `IMPL ## 1`до , который расширяется до`IMPL1`
1. Теперь токены находятся в таком состоянии:`IMPL1 ECHO(("Hello", "World"))`
1. Препроцессор находит функцион-подобный `IMPL1`макроификатор. Так как за ним `(`не следует, он не считается функциональным макровызовом.
1. Препроцессор переходит к следующим токенам. Он находит функции, `ECHO` как макрос вызывается: `ECHO(("Hello", "World"))`, который расширяется до`("Hello", "World")`
1. `IMPL1`никогда не рассматривается снова для расширения, так что полный результат расширения:`IMPL1("Hello", "World");`

Чтобы изменить макрос, чтобы вести себя одинаково как под экспериментальным препроцессором, так и при традиционном препроцессоре, добавьте еще один слой косвенного:

```cpp
#define CAT(a,b) a##b
#define ECHO(...) __VA_ARGS__
// IMPL1 and IMPL2 are macros implementation details
#define IMPL1(prefix,value) do_thing_one( prefix, value)
#define IMPL2(prefix,value) do_thing_two( prefix, value)
#define CALL(macroName, args) macroName args
#define DO_THING_FIXED(a,b) CALL( CAT(IMPL, a), ECHO(( "Hello",b)))
DO_THING_FIXED(1, "World");

// macro expands to:
// do_thing_one( "Hello", "World");
```

## <a name="incomplete-features"></a>Неполные функции

Начиная с версии Visual Studio 2019 16.5, экспериментальный препроцессор является полнофункциональным для C-20. В предыдущих версиях Visual Studio экспериментальный препроцессор в основном завершен, хотя некоторые допроцессорные директивные логики по-прежнему возвращается к традиционному поведению. Вот неполный список неполных функций в версиях Visual Studio до 16.5:

- Поддержка `_Pragma`
- Функции СЗ20
- Увеличьте блокировку ошибки: Логические операторы в постоянных выражениях препроцессора не полностью реализованы в новом препроцессоре перед версией 16.5. По `#if` некоторым директивам новый препроцессор может вернуться к традиционному препроцессору. Эффект заметен только тогда, когда макросы, несовместимые с традиционным препроцессором, расширяются. Это может произойти при создании слотов для препроцессора Boost.

::: moniker-end
