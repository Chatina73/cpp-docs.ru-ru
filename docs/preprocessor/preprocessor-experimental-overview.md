---
title: Обзор экспериментального препроцессора КОМПИЛЯТОРОМ MSVC
description: Препроцессор КОМПИЛЯТОРОМ MSVC обновляется для соответствия стандартам C/C++ Standard.
ms.date: 02/09/2020
helpviewer_keywords:
- preprocessor, experimental
ms.openlocfilehash: eb861b18a8d42c73429f6d00a3f47b35c9b198ca
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2020
ms.locfileid: "79090555"
---
# <a name="msvc-experimental-preprocessor-overview"></a>Обзор экспериментального препроцессора КОМПИЛЯТОРОМ MSVC

::: moniker range="vs-2015"

В Visual Studio 2015 используется традиционный препроцессор, который не соответствует стандарту C++. Экспериментальный препроцессор доступен в Visual Studio 2017 и Visual Studio 2019 с помощью параметра компилятора [/експериментал: препроцессора](../build/reference/experimental-preprocessor.md) . Дополнительные сведения об использовании нового препроцессора в Visual Studio 2017 и Visual Studio 2019 доступны. Чтобы увидеть его, используйте Селектор версии документации, чтобы выбрать одну из этих версий.

::: moniker-end

::: moniker range=">=vs-2017"

Мы обновляем препроцессор Майкрософт C++ для улучшения соответствия стандартам, устранения ошибок всегда и изменения некоторых поведений, которые официально не определены. Мы также добавили новые средства диагностики для предупреждения об ошибках в определениях макросов.

Эти изменения доступны с помощью переключателя компилятора [/експериментал: препроцессора](../build/reference/experimental-preprocessor.md) в visual Studio 2017 или visual Studio 2019. Поведение препроцессора по умолчанию остается таким же, как и в предыдущих версиях.

Начиная с Visual Studio 2019 версии 16,5, экспериментальная поддержка препроцессора для стандарта C++ 20 является полностью функциональной.

## <a name="new-predefined-macro"></a>Новый предопределенный макрос

Вы можете определить, какой препроцессор используется во время компиляции. Проверьте значение предопределенного макроса [\_компилятором msvc\_традиционный](predefined-macros.md) , чтобы узнать, используется ли традиционный препроцессор. Этот макрос задается в неусловном состоянии по версиям компилятора, поддерживающих его, независимо от того, какой препроцессор вызывается. Его значение равно 1 для традиционного препроцессора. Значение 0 для соответствия препроцессору.

```cpp
#if defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL
// Logic using the traditional preprocessor
#else
// Logic using cross-platform compatible preprocessor
#endif
```

## <a name="behavior-changes-in-the-experimental-preprocessor"></a>Изменения в поведении экспериментального препроцессора

Начальная работа в экспериментальной предварительной обработке посвящена обеспечению соответствия всех расширений макросов стандарту. Он позволяет использовать компилятор КОМПИЛЯТОРОМ MSVC с библиотеками, которые в настоящее время заблокированы традиционными поведениями. Мы тестировали обновленную предварительную обработку в реальных проектах. Ниже приведены некоторые из наиболее распространенных критических изменений:

### <a name="macro-comments"></a>Комментарии макроса

Традиционный препроцессор основан на символьных буферах, а не на маркерах препроцессора. Он обеспечивает необычное поведение, например следующий прием комментария препроцессора, который не работает в соответствии с препроцессором:

```cpp
#if DISAPPEAR
#define DISAPPEARING_TYPE /##/
#else
#define DISAPPEARING_TYPE int
#endif

// myVal disappears when DISAPPEARING_TYPE is turned into a comment
DISAPPEARING_TYPE myVal;
```

Исправление соответствия стандартам заключается в объявлении `int myVal` в соответствующих директивах `#ifdef/#endif`:

```cpp
#define MYVAL 1

#ifdef MYVAL
int myVal;
#endif
```

### <a name="lval"></a>L # Val

Традиционный препроцессор неправильно объединяет префикс строки в результат оператора [строковый operator (#)](stringizing-operator-hash.md) :

```cpp
 #define DEBUG_INFO(val) L"debug prefix:" L#val
//                                       ^
//                                       this prefix

const wchar_t *info = DEBUG_INFO(hello world);
```

В этом случае префикс `L` не нужен, так как соседние строковые литералы объединяются после расширения макроса. Исправление с обратной совместимостью — это изменение определения:

```cpp
#define DEBUG_INFO(val) L"debug prefix:" #val
//                                       ^
//                                       no prefix
```

Эта же ситуация также возникает в удобных макросах, которые «строчный» аргумент к расширенному строковому литералу:

```cpp
 // The traditional preprocessor creates a single wide string literal token
#define STRING(str) L#str
```

Устранить проблему можно различными способами.

- Для добавления префикса используйте объединение строк `L""` и `#str`. Смежные строковые литералы объединяются после расширения макроса:

   ```cpp
   #define STRING1(str) L""#str
   ```

- Добавление префикса после `#str` в виде строки с дополнительным расширением макроса

   ```cpp
   #define WIDE(str) L##str
   #define STRING2(str) WIDE(#str)
   ```

- Используйте оператор объединения `##`, чтобы объединить токены. Порядок операций для `##` и `#` не задан, хотя все компиляторы кажутся оценивать оператор `#` перед тем, как в этом случае `##`.

   ```cpp
   #define STRING3(str) L## #str
   ```

### <a name="warning-on-invalid-"></a>Предупреждение при недопустимом \#\#

Если оператор для создания [токена (# #)](token-pasting-operator-hash-hash.md) не приводит к созданию одного допустимого маркера предварительной обработки, поведение не определено. Традиционному препроцессору не удается автоматически объединить маркеры. Новый препроцессор соответствует поведению большинства других компиляторов и создает диагностику.

```cpp
// The ## is unnecessary and does not result in a single preprocessing token.
#define ADD_STD(x) std::##x
// Declare a std::string
ADD_STD(string) s;
```

### <a name="comma-elision-in-variadic-macros"></a>Элизии с запятыми в макросах Variadic

Традиционный препроцессор КОМПИЛЯТОРОМ MSVC всегда удаляет запятые перед пустыми `__VA_ARGS__` замены. Экспериментальный препроцессор более полно соответствует поведению других популярных межплатформенных компиляторов. Чтобы удалить запятую, аргумент Variadic должен быть пропущен (не просто пустой) и должен быть помечен оператором `##`. Рассмотрим следующий пример:

```cpp
void func(int, int = 2, int = 3);
// This macro replacement list has a comma followed by __VA_ARGS__
#define FUNC(a, ...) func(a, __VA_ARGS__)
int main()
{
    // In the traditional preprocessor, the
    // following macro is replaced with:
    // func(10,20,30)
    FUNC(10, 20, 30);

    // A conforming preprocessor replaces the
    // following macro with: func(1, ), which
    // results in a syntax error.
    FUNC(1, );
}
```

В следующем примере в вызове `FUNC2(1)` аргумент Variadic отсутствует в вызываемом макросе. В вызове `FUNC2(1, )` аргумент Variadic пуст, но отсутствует (Обратите внимание на запятую в списке аргументов).

```cpp
#define FUNC2(a, ...) func(a , ## __VA_ARGS__)
int main()
{
   // Expands to func(1)
   FUNC2(1);

   // Expands to func(1, )
   FUNC2(1, );
}
```

В предстоящем стандарте C++ 20 Эта проблема устранена путем добавления `__VA_OPT__`. Экспериментальная поддержка препроцессора для `__VA_OPT__` доступна начиная с Visual Studio 2019 версии 16,5.

### <a name="c20-variadic-macro-extension"></a>Расширение макроса c++ 20 Variadic

Экспериментальный препроцессор поддерживает C++ 20 Variadic элизии аргумента макроса:

```cpp
#define FUNC(a, ...) __VA_ARGS__ + a
int main()
  {
  int ret = FUNC(0);
  return ret;
  }
```

Этот код не соответствует стандарту C++ 20. В КОМПИЛЯТОРОМ MSVC экспериментальный препроцессор расширяет это поведение C++ 20 до стандартных режимов на более низком языке ( **`/std:c++14`** , **`/std:c++17`** ). Это расширение соответствует поведению других основных межплатформенных C++ компиляторов.

### <a name="macro-arguments-are-unpacked"></a>Аргументы макроса являются распакованными

В традиционном препроцессоре, если макрос пересылает один из своих аргументов другому зависимому макросу, аргумент не получает «распакованный» при вставке. Обычно такая оптимизация незаметна, но может привести к необычному поведению:

```cpp
// Create a string out of the first argument, and the rest of the arguments.
#define TWO_STRINGS( first, ... ) #first, #__VA_ARGS__
#define A( ... ) TWO_STRINGS(__VA_ARGS__)
const char* c[2] = { A(1, 2) };

// Conforming preprocessor results:
// const char c[2] = { "1", "2" };

// Traditional preprocessor results, all arguments are in the first string:
// const char c[2] = { "1, 2", };
```

При развертывании `A()`традиционный препроцессор пересылает все аргументы, Упакованные в `__VA_ARGS__`, в первый аргумент TWO_STRINGS, который оставляет аргумент Variadic `TWO_STRINGS` пустым. Это приводит к тому, что результатом `#first` будет "1, 2", а не просто "1". Если вы в точности подумываете, то можете узнать, что произошло с результатом `#__VA_ARGS__` в традиционном расширении препроцессора: Если параметр Variadic пуст, он должен привести к `""`у пустого строкового литерала. Не удается создать отдельную ошибку, которая сохранила токен пустого строкового литерала.

### <a name="rescanning-replacement-list-for-macros"></a>Повторное сканирование списка замен для макросов

После замены макроса полученные маркеры повторно проверяются на наличие дополнительных идентификаторов макросов для замены. Алгоритм, используемый традиционным препроцессором для выполнения повторного сканирования, не соответствует, как показано в этом примере на основе фактического кода:

```cpp
#define CAT(a,b) a ## b
#define ECHO(...) __VA_ARGS__
// IMPL1 and IMPL2 are implementation details
#define IMPL1(prefix,value) do_thing_one( prefix, value)
#define IMPL2(prefix,value) do_thing_two( prefix, value)

// MACRO chooses the expansion behavior based on the value passed to macro_switch
#define DO_THING(macro_switch, b) CAT(IMPL, macro_switch) ECHO(( "Hello", b))
DO_THING(1, "World");

// Traditional preprocessor:
// do_thing_one( "Hello", "World");
// Conforming preprocessor:
// IMPL1 ( "Hello","World");
```

Хотя этот пример может показаться немного надуманный, мы видели его в реальном мире кода. Чтобы увидеть, что происходит, можно разбить расширение на `DO_THING`:

1. `DO_THING(1, "World")` разворачивается в `CAT(IMPL, 1) ECHO(("Hello", "World"))`
1. `CAT(IMPL, 1)` разворачивается в `IMPL ## 1`, который разворачивается в `IMPL1`
1. Теперь маркеры находятся в этом состоянии: `IMPL1 ECHO(("Hello", "World"))`
1. Препроцессор находит идентификатор макроса, аналогичного функции, `IMPL1`. Поскольку за ним не следует `(`, он не считается вызовом макроса, аналогичного функции.
1. Препроцессор переходит к следующим маркерам. Он находит макрос, похожий на функцию, `ECHO` вызывается: `ECHO(("Hello", "World"))`, который разворачивается в `("Hello", "World")`
1. `IMPL1` не считается снова для расширения, поэтому полный результат расширения будет следующим: `IMPL1("Hello", "World");`

Чтобы изменить макрос так, чтобы он навести себя как в экспериментальной, так и в традиционной предварительной обработке, добавьте еще один уровень косвенного обращения:

```cpp
#define CAT(a,b) a##b
#define ECHO(...) __VA_ARGS__
// IMPL1 and IMPL2 are macros implementation details
#define IMPL1(prefix,value) do_thing_one( prefix, value)
#define IMPL2(prefix,value) do_thing_two( prefix, value)
#define CALL(macroName, args) macroName args
#define DO_THING_FIXED(a,b) CALL( CAT(IMPL, a), ECHO(( "Hello",b)))
DO_THING_FIXED(1, "World");

// macro expands to:
// do_thing_one( "Hello", "World");
```

## <a name="incomplete-features"></a>Незавершенные функции

Начиная с Visual Studio 2019 версии 16,5, экспериментальный предварительный препроцессор является полностью реализованным для C++ 20. В предыдущих версиях Visual Studio экспериментальный препроцессор в основном завершен, хотя часть логики директив препроцессора по-прежнему переходит к традиционному поведению. Ниже приведен частичный список незавершенных функций в версиях Visual Studio до 16,5:

- Поддержка `_Pragma`
- Функции c++ 20
- Устранение ошибки блокировки. логические операторы в выражениях констант препроцессора не полностью реализованы в новом препроцессоре до версии 16,5. В некоторых директивах `#if` новый препроцессор может вернуться к традиционному препроцессору. Этот результат заметен только в том случае, если макросы, несовместимые с традиционным препроцессором, развернуты. Это может произойти при создании слотов препроцессора для повышения.

::: moniker-end
