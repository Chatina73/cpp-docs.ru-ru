---
title: Обзор нового препроцессора КОМПИЛЯТОРОМ MSVC
description: Препроцессор КОМПИЛЯТОРОМ MSVC обновляется для соответствия стандартам C/C++.
ms.date: 09/10/2020
helpviewer_keywords:
- preprocessor, experimental
- preprocessor, new
ms.openlocfilehash: 5327a8148f78a07e222fae7fb92e6ed741d12011
ms.sourcegitcommit: 9c2b3df9b837879cd17932ae9f61cdd142078260
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2020
ms.locfileid: "92924579"
---
# <a name="msvc-new-preprocessor-overview"></a>Обзор нового препроцессора КОМПИЛЯТОРОМ MSVC

::: moniker range="msvc-140"

В Visual Studio 2015 используется традиционный препроцессор, который не соответствует стандарту C++ или C99. Начиная с Visual Studio 2019 версии 16,5, Новая поддержка препроцессора для стандарта C++ 20 является полностью функциональной. Эти изменения доступны с помощью параметра компилятора [/Zc: препроцессора](../build/reference/zc-preprocessor.md) . Экспериментальная версия нового препроцессора доступна начиная с Visual Studio 2017 версии 15,8 и более поздних версий с помощью параметра компилятора [/експериментал: препроцессора](../build/reference/experimental-preprocessor.md) . Дополнительные сведения об использовании нового препроцессора в Visual Studio 2017 и Visual Studio 2019 доступны. Чтобы ознакомиться с документацией по предпочтительной версии Visual Studio, используйте селектор **Версия** . Он находится в верхней части оглавления на этой странице.

::: moniker-end

::: moniker range=">=msvc-150"

Мы обновляем препроцессор Microsoft C++ для улучшения соответствия стандартам, устранения ошибок всегда и изменения некоторых поведений, которые официально не определены. Мы также добавили новые средства диагностики для предупреждения об ошибках в определениях макросов.

Начиная с Visual Studio 2019 версии 16,5, поддержка препроцессора для стандарта C++ 20 является полностью функциональной. Эти изменения доступны с помощью параметра компилятора [/Zc: препроцессора](../build/reference/zc-preprocessor.md) . Экспериментальная версия нового препроцессора доступна в более ранних версиях, начиная с Visual Studio 2017 версии 15,8. Его можно включить с помощью параметра компилятора [/експериментал: препроцессора](../build/reference/experimental-preprocessor.md) . Поведение препроцессора по умолчанию остается таким же, как и в предыдущих версиях.

## <a name="new-predefined-macro"></a>Новый предопределенный макрос

Вы можете определить, какой препроцессор используется во время компиляции. Проверьте значение предопределенного макроса [`_MSVC_TRADITIONAL`](predefined-macros.md) , чтобы определить, используется ли традиционный препроцессор. Этот макрос задается в неусловном состоянии по версиям компилятора, поддерживающих его, независимо от того, какой препроцессор вызывается. Его значение равно 1 для традиционного препроцессора. Значение 0 для соответствия препроцессору.

```cpp
#if defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL
// Logic using the traditional preprocessor
#else
// Logic using cross-platform compatible preprocessor
#endif
```

## <a name="behavior-changes-in-the-new-preprocessor"></a>Изменения в работе нового препроцессора

Начальная работа над новым препроцессором посвящена обеспечению соответствия всех расширений макросов стандарту. Он позволяет использовать компилятор КОМПИЛЯТОРОМ MSVC с библиотеками, которые в настоящее время заблокированы традиционными поведениями. Мы тестировали обновленную предварительную обработку в реальных проектах. Ниже приведены некоторые из наиболее распространенных критических изменений:

### <a name="macro-comments"></a>Комментарии макроса

Традиционный препроцессор основан на символьных буферах, а не на маркерах препроцессора. Он обеспечивает необычное поведение, например следующий прием комментария препроцессора, который не работает в соответствии с препроцессором:

```cpp
#if DISAPPEAR
#define DISAPPEARING_TYPE /##/
#else
#define DISAPPEARING_TYPE int
#endif

// myVal disappears when DISAPPEARING_TYPE is turned into a comment
DISAPPEARING_TYPE myVal;
```

Исправление соответствия стандартам заключается в объявлении в `int myVal` соответствующих `#ifdef/#endif` директивах:

```cpp
#define MYVAL 1

#ifdef MYVAL
int myVal;
#endif
```

### <a name="lval"></a>L # Val

Традиционный препроцессор неправильно объединяет префикс строки в результат оператора [строковый operator (#)](stringizing-operator-hash.md) :

```cpp
 #define DEBUG_INFO(val) L"debug prefix:" L#val
//                                       ^
//                                       this prefix

const wchar_t *info = DEBUG_INFO(hello world);
```

В этом случае `L` префикс не нужен, так как соседние строковые литералы объединяются после расширения макроса. Исправление с обратной совместимостью — это изменение определения:

```cpp
#define DEBUG_INFO(val) L"debug prefix:" #val
//                                       ^
//                                       no prefix
```

Эта же ситуация также возникает в удобных макросах, которые «строчный» аргумент к расширенному строковому литералу:

```cpp
 // The traditional preprocessor creates a single wide string literal token
#define STRING(str) L#str
```

Устранить проблему можно различными способами.

- `L""` `#str` Для добавления префикса используйте объединение строк и. Смежные строковые литералы объединяются после расширения макроса:

   ```cpp
   #define STRING1(str) L""#str
   ```

- Добавить префикс после `#str` в виде строки с дополнительным расширением макроса

   ```cpp
   #define WIDE(str) L##str
   #define STRING2(str) WIDE(#str)
   ```

- Используйте оператор объединения `##` для объединения токенов. Порядок операций для `##` и `#` не определен, хотя `#` в данном случае все компиляторы кажутся оценивать оператор `##` .

   ```cpp
   #define STRING3(str) L## #str
   ```

### <a name="warning-on-invalid-"></a>Предупреждение при недопустимом \#\#

Если оператор для создания [токена (# #)](token-pasting-operator-hash-hash.md) не приводит к созданию одного допустимого маркера предварительной обработки, поведение не определено. Традиционному препроцессору не удается автоматически объединить маркеры. Новый препроцессор соответствует поведению большинства других компиляторов и создает диагностику.

```cpp
// The ## is unnecessary and does not result in a single preprocessing token.
#define ADD_STD(x) std::##x
// Declare a std::string
ADD_STD(string) s;
```

### <a name="comma-elision-in-variadic-macros"></a>Элизии с запятыми в макросах Variadic

Традиционный препроцессор КОМПИЛЯТОРОМ MSVC всегда удаляет запятые перед пустыми `__VA_ARGS__` заменами. Новый препроцессор более полно соответствует поведению других популярных межплатформенных компиляторов. Чтобы удалить запятую, аргумент Variadic должен быть пропущен (не просто пустой) и должен быть помечен `##` оператором. Рассмотрим следующий пример.

```cpp
void func(int, int = 2, int = 3);
// This macro replacement list has a comma followed by __VA_ARGS__
#define FUNC(a, ...) func(a, __VA_ARGS__)
int main()
{
    // In the traditional preprocessor, the
    // following macro is replaced with:
    // func(10,20,30)
    FUNC(10, 20, 30);

    // A conforming preprocessor replaces the
    // following macro with: func(1, ), which
    // results in a syntax error.
    FUNC(1, );
}
```

В следующем примере в вызове `FUNC2(1)` аргумента Variadic отсутствует в вызываемом макросе. В вызове `FUNC2(1, )` аргумента Variadic пуст, но отсутствует (Обратите внимание на запятую в списке аргументов).

```cpp
#define FUNC2(a, ...) func(a , ## __VA_ARGS__)
int main()
{
   // Expands to func(1)
   FUNC2(1);

   // Expands to func(1, )
   FUNC2(1, );
}
```

В предстоящем стандарте C++ 20 Эта проблема устранена путем добавления `__VA_OPT__` . Новая поддержка препроцессора для  `__VA_OPT__` доступна начиная с Visual Studio 2019 версии 16,5.

### <a name="c20-variadic-macro-extension"></a>Расширение макроса c++ 20 Variadic

Новый препроцессор поддерживает variadicие аргументов макросов C++ 20.

```cpp
#define FUNC(a, ...) __VA_ARGS__ + a
int main()
  {
  int ret = FUNC(0);
  return ret;
  }
```

Этот код не соответствует стандарту C++ 20. В КОМПИЛЯТОРОМ MSVC новый препроцессор расширяет это поведение C++ 20 до стандартных режимов на более низком языке ( **`/std:c++14`** , **`/std:c++17`** ). Это расширение соответствует поведению других основных кросс-платформенных компиляторов C++.

### <a name="macro-arguments-are-unpacked"></a>Аргументы макроса являются распакованными

В традиционном препроцессоре, если макрос пересылает один из своих аргументов другому зависимому макросу, аргумент не получает «распакованный» при вставке. Обычно такая оптимизация незаметна, но может привести к необычному поведению:

```cpp
// Create a string out of the first argument, and the rest of the arguments.
#define TWO_STRINGS( first, ... ) #first, #__VA_ARGS__
#define A( ... ) TWO_STRINGS(__VA_ARGS__)
const char* c[2] = { A(1, 2) };

// Conforming preprocessor results:
// const char c[2] = { "1", "2" };

// Traditional preprocessor results, all arguments are in the first string:
// const char c[2] = { "1, 2", };
```

При развертывании `A()` традиционный препроцессор пересылает все аргументы, Упакованные в, в `__VA_ARGS__` первый аргумент TWO_STRINGS, который оставляет аргумент Variadic `TWO_STRINGS` пустым. Это приводит к тому, что результатом `#first` будет «1, 2», а не просто «1». Если вы в точности подумываете, то можете узнать, что случилось с результатом `#__VA_ARGS__` традиционного расширения препроцессора: Если параметр Variadic пуст, он должен привести к созданию пустого строкового литерала `""` . Не удается создать отдельную ошибку, которая сохранила токен пустого строкового литерала.

### <a name="rescanning-replacement-list-for-macros"></a>Повторное сканирование списка замен для макросов

После замены макроса полученные маркеры повторно проверяются на наличие дополнительных идентификаторов макросов для замены. Алгоритм, используемый традиционным препроцессором для выполнения повторного сканирования, не соответствует, как показано в этом примере на основе фактического кода:

```cpp
#define CAT(a,b) a ## b
#define ECHO(...) __VA_ARGS__
// IMPL1 and IMPL2 are implementation details
#define IMPL1(prefix,value) do_thing_one( prefix, value)
#define IMPL2(prefix,value) do_thing_two( prefix, value)

// MACRO chooses the expansion behavior based on the value passed to macro_switch
#define DO_THING(macro_switch, b) CAT(IMPL, macro_switch) ECHO(( "Hello", b))
DO_THING(1, "World");

// Traditional preprocessor:
// do_thing_one( "Hello", "World");
// Conforming preprocessor:
// IMPL1 ( "Hello","World");
```

Хотя этот пример может показаться немного надуманный, мы видели его в реальном коде.

Чтобы увидеть, что происходит, мы можем разбить расширение, начиная с `DO_THING` :

1. `DO_THING(1, "World")` разворачивается в `CAT(IMPL, 1) ECHO(("Hello", "World"))`
1. `CAT(IMPL, 1)` разворачивается до `IMPL ## 1` , который разворачивается в `IMPL1`
1. Теперь маркеры находятся в этом состоянии: `IMPL1 ECHO(("Hello", "World"))`
1. Препроцессор находит идентификатор макроса, аналогичного функции `IMPL1` . Поскольку за ним не следует `(` , он не считается вызовом макроса, аналогичного функции.
1. Препроцессор переходит к следующим маркерам. Он находит вызов макроса, похожего на функцию `ECHO` : `ECHO(("Hello", "World"))` , который разворачивается до `("Hello", "World")`
1. `IMPL1` не считается повторно для расширения, поэтому полный результат расширения будет следующим: `IMPL1("Hello", "World");`

Чтобы изменить поведение макроса так же, как в новом препроцессоре, так и в традиционном препроцессоре, добавьте еще один уровень косвенного обращения:

```cpp
#define CAT(a,b) a##b
#define ECHO(...) __VA_ARGS__
// IMPL1 and IMPL2 are macros implementation details
#define IMPL1(prefix,value) do_thing_one( prefix, value)
#define IMPL2(prefix,value) do_thing_two( prefix, value)
#define CALL(macroName, args) macroName args
#define DO_THING_FIXED(a,b) CALL( CAT(IMPL, a), ECHO(( "Hello",b)))
DO_THING_FIXED(1, "World");

// macro expands to:
// do_thing_one( "Hello", "World");
```

## <a name="incomplete-features-before-165"></a>Незавершенные функции до 16,5

Начиная с Visual Studio 2019 версии 16,5, новый препроцессор является полностью реализованным для C++ 20. В предыдущих версиях Visual Studio новый препроцессор в основном завершен, хотя часть логики директив препроцессора по-прежнему переходит к традиционному поведению. Ниже приведен частичный список незавершенных функций в версиях Visual Studio до 16,5:

- Поддержка `_Pragma`
- Функции c++ 20
- Устранение ошибки блокировки. логические операторы в выражениях констант препроцессора не полностью реализованы в новом препроцессоре до версии 16,5. В некоторых `#if` директивах новый препроцессор может вернуться к традиционному препроцессору. Этот результат заметен только в том случае, если макросы, несовместимые с традиционным препроцессором, развернуты. Это может произойти при создании слотов препроцессора для повышения.

::: moniker-end
