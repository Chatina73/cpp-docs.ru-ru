---
title: Предустановленные макросы
description: Содержит список и описание предопределенных макросов препроцессора Microsoft C++ Compiler.
ms.custom: update_every_version
ms.date: 11/20/2019
f1_keywords:
- _ATL_VER
- __ATOM__
- __AVX__
- __AVX2__
- __AVX512BW__
- __AVX512CD__
- __AVX512DQ__
- __AVX512F__
- __AVX512VL__
- _CHAR_UNSIGNED
- __CLR_VER
- _CONTROL_FLOW_GUARD
- __COUNTER__
- __cplusplus
- __cplusplus_cli
- __cplusplus_winrt
- _CPPRTTI
- _CPPUNWIND
- __DATE__
- _DEBUG
- _DLL
- __FILE__
- __FUNCDNAME__
- __FUNCSIG__
- __FUNCTION__
- _INTEGRAL_MAX_BITS
- _ISO_VOLATILE
- _KERNEL_MODE
- __LINE__
- _M_AMD64
- _M_ARM
- _M_ARM_ARMV7VE
- _M_ARM_FP
- _M_ARM64
- _M_CEE
- _M_CEE_PURE
- _M_CEE_SAFE
- _M_FP_EXCEPT
- _M_FP_FAST
- _M_FP_PRECISE
- _M_FP_STRICT
- _M_IX86
- _M_IX86_FP
- _M_X64
- _MANAGED
- _MFC_VER
- _MSC_BUILD
- _MSC_EXTENSIONS
- _MSC_FULL_VER
- _MSC_VER
- _MSVC_LANG
- __MSVC_RUNTIME_CHECKS
- _MT
- _NATIVE_WCHAR_T_DEFINED
- _NO_SIZED_DEALLOCATION
- _OPENMP
- _PREFAST_
- _RESUMABLE_FUNCTIONS_SUPPORTED
- _RTC_CONVERSION_CHECKS_ENABLED
- __STDC__
- __STDC_HOSTED__
- __STDCPP_THREADS__
- __TIME__
- __TIMESTAMP__
- __VA_ARGS__
- _VC_NODEFAULTLIB
- _WCHAR_T_DEFINED
- _WIN32
- _WIN64
- _WINRT_DLL
- __func__
helpviewer_keywords:
- timestamps, preprocessor macro
- cl.exe compiler, version number
- version numbers, C/C++ compiler (cl.exe)
- macros, predefined C++
- preprocessor, macros
- predefined macros
- _ATL_VER macro
- __ATOM__ macro
- __AVX__ macro
- __AVX2__ macro
- __AVX512BW__ macro
- __AVX512CD__ macro
- __AVX512DQ__ macro
- __AVX512F__ macro
- __AVX512VL__ macro
- _CHAR_UNSIGNED macro
- __CLR_VER macro
- _CONTROL_FLOW_GUARD macro
- __COUNTER__ macro
- __cplusplus macro
- __cplusplus_cli macro
- __cplusplus_winrt macro
- _CPPRTTI macro
- _CPPUNWIND macro
- __DATE__ macro
- _DEBUG macro
- _DLL macro
- __FILE__ macro
- __FUNCDNAME__ macro
- __FUNCSIG__ macro
- __FUNCTION__ macro
- _INTEGRAL_MAX_BITS macro
- _ISO_VOLATILE macro
- _KERNEL_MODE macro
- __LINE__ macro
- _M_AMD64 macro
- _M_ARM macro
- _M_ARM_ARMV7VE macro
- _M_ARM_FP macro
- _M_ARM64 macro
- _M_CEE macro
- _M_CEE_PURE macro
- _M_CEE_SAFE macro
- _M_FP_EXCEPT macro
- _M_FP_FAST macro
- _M_FP_PRECISE macro
- _M_FP_STRICT macro
- _M_IX86 macro
- _M_IX86_FP macro
- _M_X64 macro
- _MANAGED macro
- _MFC_VER macro
- _MSC_BUILD macro
- _MSC_EXTENSIONS macro
- _MSC_FULL_VER macro
- _MSC_VER macro
- _MSVC_LANG macro
- __MSVC_RUNTIME_CHECKS macro
- _MT macro
- _NATIVE_WCHAR_T_DEFINED macro
- _NO_SIZED_DEALLOCATION macro
- _OPENMP macro
- _PREFAST_ macro
- _RESUMABLE_FUNCTIONS_SUPPORTED macro
- _RTC_CONVERSION_CHECKS_ENABLED macro
- __STDC__ macro
- __STDC_HOSTED__ macro
- __STDCPP_THREADS__ macro
- __TIME__ macro
- __TIMESTAMP__ macro
- __VA_ARGS__ macro
- _VC_NODEFAULTLIB macro
- _WCHAR_T_DEFINED macro
- _WIN32 macro
- _WIN64 macro
- _WINRT_DLL macro
- __func__ identifier
ms.assetid: 1cc5f70a-a225-469c-aed0-fe766238e23f
no-loc:
- _ATL_VER
- __ATOM__
- __AVX__
- __AVX2__
- __AVX512BW__
- __AVX512CD__
- __AVX512DQ__
- __AVX512F__
- __AVX512VL__
- _CHAR_UNSIGNED
- __CLR_VER
- _CONTROL_FLOW_GUARD
- __COUNTER__
- __cplusplus
- __cplusplus_cli
- __cplusplus_winrt
- _CPPRTTI
- _CPPUNWIND
- __DATE__
- _DEBUG
- _DLL
- __FILE__
- __FUNCDNAME__
- __FUNCSIG__
- __FUNCTION__
- _INTEGRAL_MAX_BITS
- _ISO_VOLATILE
- _KERNEL_MODE
- __LINE__
- _M_AMD64
- _M_ARM
- _M_ARM_ARMV7VE
- _M_ARM_FP
- _M_ARM64
- _M_CEE
- _M_CEE_PURE
- _M_CEE_SAFE
- _M_FP_EXCEPT
- _M_FP_FAST
- _M_FP_PRECISE
- _M_FP_STRICT
- _M_IX86
- _M_IX86_FP
- _M_X64
- _MANAGED
- _MFC_VER
- _MSC_BUILD
- _MSC_EXTENSIONS
- _MSC_FULL_VER
- _MSC_VER
- _MSVC_LANG
- __MSVC_RUNTIME_CHECKS
- _MT
- _NATIVE_WCHAR_T_DEFINED
- _NO_SIZED_DEALLOCATION
- _OPENMP
- _PREFAST_
- _RESUMABLE_FUNCTIONS_SUPPORTED
- _RTC_CONVERSION_CHECKS_ENABLED
- __STDC__
- __STDC_HOSTED__
- __STDCPP_THREADS__
- __TIME__
- __TIMESTAMP__
- __VA_ARGS__
- _VC_NODEFAULTLIB
- _WCHAR_T_DEFINED
- _WIN32
- _WIN64
- _WINRT_DLL
- __func__
ms.openlocfilehash: 7d019b527abea89ab8337270fbd22abc9dbecc4e
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2019
ms.locfileid: "74305475"
---
# <a name="predefined-macros"></a>Предустановленные макросы

Microsoft C/C++ COMPILER (компилятором MSVC) предварительно определяет определенные макросы препроцессора в зависимости от языка (C или C++), цели компиляции и выбранных параметров компилятора.

КОМПИЛЯТОРОМ MSVC поддерживает предопределенные макросы препроцессора, требуемые стандартом ANSI/ISO C99, а также стандарты ISO C++ 14 и C++ 17. Реализация также поддерживает несколько дополнительных макросов препроцессора, характерных для Microsoft. Некоторые макросы определяются только для определенных сред сборки или параметров компилятора. За исключением указанных случаев, макросы определяются по всему блоку преобразования, как если бы они были указаны как аргументы параметра компилятора **/d** . При определении макросы развертываются до указанных значений препроцессором перед компиляцией. Предопределенные макросы не принимают аргументов и не могут быть переопределены.

## <a name="standard-predefined-identifier"></a>Стандартный предопределенный идентификатор

Компилятор поддерживает этот предопределенный идентификатор, заданный с помощью ISO C99 и C++ 11.

- `__func__` неквалифицированное и недекорированное имя включающей функции в качестве локального **статического массива константы** типа "функция" **.**

    ```cpp
    void example(){
        printf("%s\n", __func__);
    } // prints "example"
    ```

## <a name="standard-predefined-macros"></a>Стандартные стандартные макросы

Компилятор поддерживает эти предопределенные макросы, заданные стандартом ISO C99 и ISO C++ 17.

- `__cplusplus`, определенное как целочисленное литеральное значение, если запись преобразования компилируется как C++. В противном случае — не определяется.

- `__DATE__` дату компиляции текущего исходного файла. Дата — строковой литерал постоянной длины в формате *ммм дд гггг*. Название месяца *MMM* совпадает с сокращенным названием месяца, созданным функцией [asctime](../c-runtime-library/reference/asctime-wasctime.md) в библиотеке времени выполнения C (CRT). Первый символ даты *дд* — это пробел, если значение меньше 10. Этот макрос определяется всегда. Этот макрос определяется всегда.

- `__FILE__` имя текущего исходного файла. `__FILE__` расширяется до литерала символьной строки. Чтобы убедиться, что полный путь к файлу отображается, используйте [/FC (полный путь к файлу исходного кода в Diagnostics)](../build/reference/fc-full-path-of-source-code-file-in-diagnostics.md). Этот макрос определяется всегда.

- `__LINE__`, определенный как целочисленный номер строки в текущем исходном файле. Значение макроса `__LINE__` можно изменить с помощью директивы `#line`. Этот макрос определяется всегда.

- `__STDC__` определяется как 1 только при компиляции в формате C и при указании параметра компилятора [/Za](../build/reference/za-ze-disable-language-extensions.md) . В противном случае — не определяется.

- `__STDC_HOSTED__`, определенный как 1, если реализация является *размещенной реализацией*, одна из которых поддерживает всю необходимую стандартную библиотеку. В противном случае определяется как 0.

- `__STDCPP_THREADS__`, определенный как 1, только в том случае, если программа может иметь более одного потока выполнения и скомпилирована C++как. В противном случае — не определяется.

- `__TIME__` время перевода предварительно обработанной записи преобразования. Время представляет собой символьный строковый литерал в формате *чч: мм: СС*, то же, что и время, возвращенное функцией CRT [asctime](../c-runtime-library/reference/asctime-wasctime.md) . Этот макрос определяется всегда.

## <a name="microsoft-specific-predefined-macros"></a>Предварительно определенные макросы Майкрософт

КОМПИЛЯТОРОМ MSVC поддерживает эти дополнительные предопределенные макросы.

- `__ATOM__` определяется как 1, если задан параметр компилятора [/favor: Atom](../build/reference/favor-optimize-for-architecture-specifics.md) , а целевым объектом компилятора является x86 или x64. В противном случае — не определяется.

- `__AVX__` определяется как 1, если заданы параметры компилятора [/arch: AVX](../build/reference/arch-x86.md), [/arch: AVX2](../build/reference/arch-x86.md) или [/arch: AVX512](../build/reference/arch-x86.md) , а целью компилятора является x86 или x64. В противном случае — не определяется.

- `__AVX2__` определяется как 1, если задан параметр компилятора [/arch: AVX2](../build/reference/arch-x86.md) или [/arch: AVX512](../build/reference/arch-x86.md) , а целевым объектом компилятора является x86 или x64. В противном случае — не определяется.

- `__AVX512BW__` определяется как 1, если задан параметр компилятора [/arch: AVX512](../build/reference/arch-x86.md) , а целевым объектом компилятора является x86 или x64. В противном случае — не определяется.

- `__AVX512CD__` определяется как 1, если задан параметр компилятора [/arch: AVX512](../build/reference/arch-x86.md) , а целевым объектом компилятора является x86 или x64. В противном случае — не определяется.

- `__AVX512DQ__` определяется как 1, если задан параметр компилятора [/arch: AVX512](../build/reference/arch-x86.md) , а целевым объектом компилятора является x86 или x64. В противном случае — не определяется.

- `__AVX512F__` определяется как 1, если задан параметр компилятора [/arch: AVX512](../build/reference/arch-x86.md) , а целевым объектом компилятора является x86 или x64. В противном случае — не определяется.

- `__AVX512VL__` определяется как 1, если задан параметр компилятора [/arch: AVX512](../build/reference/arch-x86.md) , а целевым объектом компилятора является x86 или x64. В противном случае — не определяется.

- `_CHAR_UNSIGNED`, определенный как 1, если тип **char** по умолчанию не подписан. Это значение определяется, если задан параметр компилятора [/j (тип char по умолчанию — неподписанный)](../build/reference/j-default-char-type-is-unsigned.md) . В противном случае — не определяется.

- `__CLR_VER`, определенный как целочисленный литерал, представляющий версию среды CLR, используемую для компиляции приложения. Значение кодируется в виде `Mmmbbbbb`, где `M` является основным номером версии среды выполнения, `mm` — это дополнительный номер версии среды выполнения, а `bbbbb` — номер сборки. `__CLR_VER` определяется, если задан параметр компилятора [/CLR](../build/reference/clr-common-language-runtime-compilation.md) . В противном случае — не определяется.

    ```cpp
    // clr_ver.cpp
    // compile with: /clr
    using namespace System;
    int main() {
       Console::WriteLine(__CLR_VER);
    }
    ```

- `_CONTROL_FLOW_GUARD` определяется как 1, если задан параметр компилятора [/Guard: CF (Enable Control Flow Guard)](../build/reference/guard-enable-control-flow-guard.md) . В противном случае — не определяется.

- `__COUNTER__` расширяется до целочисленного литерала, начинающегося с 0. Значение увеличивается на 1 каждый раз, когда оно используется в исходном файле или в включенных заголовках исходного файла. При использовании предкомпилированных заголовков `__COUNTER__` запоминает его состояние. Этот макрос определяется всегда.

  В этом примере `__COUNTER__` используется для назначения уникальных идентификаторов трем различным объектам одного типа. Конструктор `exampleClass` принимает целое число в качестве параметра. В `main` приложение объявляет три объекта типа `exampleClass` с использованием `__COUNTER__` в качестве параметра уникального идентификатора:

    ```cpp
    // macro__COUNTER__.cpp
    // Demonstration of __COUNTER__, assigns unique identifiers to
    // different objects of the same type.
    // Compile by using: cl /EHsc /W4 macro__COUNTER__.cpp
    #include <stdio.h>

    class exampleClass {
        int m_nID;
    public:
        // initialize object with a read-only unique ID
        exampleClass(int nID) : m_nID(nID) {}
        int GetID(void) { return m_nID; }
    };

    int main()
    {
        // __COUNTER__ is initially defined as 0
        exampleClass e1(__COUNTER__);

        // On the second reference, __COUNTER__ is now defined as 1
        exampleClass e2(__COUNTER__);

        // __COUNTER__ is now defined as 2
        exampleClass e3(__COUNTER__);

        printf("e1 ID: %i\n", e1.GetID());
        printf("e2 ID: %i\n", e2.GetID());
        printf("e3 ID: %i\n", e3.GetID());

        // Output
        // ------------------------------
        // e1 ID: 0
        // e2 ID: 1
        // e3 ID: 2

        return 0;
    }
    ```

- `__cplusplus_cli`, определенное как целочисленное литеральное значение 200406 при C++ компиляции как, и задан параметр компилятора [/CLR](../build/reference/clr-common-language-runtime-compilation.md) . В противном случае — не определяется. При определении `__cplusplus_cli` действует на всю единицу трансляции.

    ```cpp
    // cplusplus_cli.cpp
    // compile by using /clr
    #include "stdio.h"
    int main() {
       #ifdef __cplusplus_cli
          printf("%d\n", __cplusplus_cli);
       #else
          printf("not defined\n");
       #endif
    }
    ```

- `__cplusplus_winrt`, определенное как целочисленное литеральное значение 201009 при C++ компиляции как, и параметр компилятора [/ZW (среда выполнения Windows compilation)](../build/reference/zw-windows-runtime-compilation.md) установлен. В противном случае — не определяется.

- `_CPPRTTI` определяется как 1, если задан параметр компилятора [/GR (включение сведений о типе времени выполнения)](../build/reference/gr-enable-run-time-type-information.md) . В противном случае — не определяется.

- `_CPPUNWIND` задается как 1, если заданы параметры компилятора [/GX (включить обработку исключений)](../build/reference/gx-enable-exception-handling.md), [/CLR (CLR compilation)](../build/reference/clr-common-language-runtime-compilation.md)или [/EH (модель обработки исключений)](../build/reference/eh-exception-handling-model.md) . В противном случае — не определяется.

- `_DEBUG` определяется как 1, если задан параметр компилятора [/LDD](../build/reference/md-mt-ld-use-run-time-library.md), [/MDD](../build/reference/md-mt-ld-use-run-time-library.md)или [/MTD](../build/reference/md-mt-ld-use-run-time-library.md) . В противном случае — не определяется.

- `_DLL` определяется как 1, если задан параметр компилятора [/MD](../build/reference/md-mt-ld-use-run-time-library.md) или [/MDD](../build/reference/md-mt-ld-use-run-time-library.md) (Многопоточная DLL). В противном случае — не определяется.

- `__FUNCDNAME__`, определенный как строковый литерал, содержащий [декорированное имя](../build/reference/decorated-names.md) включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCDNAME__` не разворачивается, если используется параметр компилятора [/EP](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [/p](../build/reference/p-preprocess-to-a-file.md) .

   В этом примере используются макросы `__FUNCDNAME__`, `__FUNCSIG__`и `__FUNCTION__` для вывода сведений о функции.

   [!code-cpp[NVC_Predefined_Macros_Examples#1](../preprocessor/codesnippet/CPP/predefined-macros_1.cpp)]

- `__FUNCSIG__`, определенный как строковый литерал, содержащий сигнатуру включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCSIG__` не разворачивается, если используется параметр компилятора [/EP](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [/p](../build/reference/p-preprocess-to-a-file.md) . При компиляции для 64-разрядных конечных вызовов — это `__cdecl` по умолчанию. Пример использования см. в разделе для макроса `__FUNCDNAME__`.

- `__FUNCTION__`, определенный как строковый литерал, содержащий недекорированное имя включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCTION__` не разворачивается, если используется параметр компилятора [/EP](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [/p](../build/reference/p-preprocess-to-a-file.md) . Пример использования см. в разделе для макроса `__FUNCDNAME__`.

- `_INTEGRAL_MAX_BITS`, определенное как целочисленное литеральное значение 64, максимальный размер (в битах) для целочисленного типа, не являющегося вектором. Этот макрос определяется всегда.

   ```cpp
   // integral_max_bits.cpp
   #include <stdio.h>
   int main() {
      printf("%d\n", _INTEGRAL_MAX_BITS);
   }
   ```

- `__INTELLISENSE__`, определенный как 1 во время прохода компилятора IntelliSense в интегрированной среде разработки Visual Studio. В противном случае — не определяется. Этот макрос можно использовать для защиты кода, который компилятор IntelliSense не понимает, или использовать для переключения между сборкой и компилятором IntelliSense. Дополнительные сведения см. в разделе [советы по устранению неполадок при медленной работе IntelliSense](https://devblogs.microsoft.com/cppblog/troubleshooting-tips-for-intellisense-slowness/).

- `_ISO_VOLATILE` определяется как 1, если задан параметр компилятора [/volatile: ISO](../build/reference/volatile-volatile-keyword-interpretation.md) . В противном случае — не определяется.

- `_KERNEL_MODE` определяется как 1, если задан параметр компилятора [/kernel (создание двоичного режима ядра)](../build/reference/kernel-create-kernel-mode-binary.md) . В противном случае — не определяется.

- `_M_AMD64`, определенное как целочисленное литеральное значение 100 для компиляций, предназначенных для процессоров x64. В противном случае — не определяется.

- `_M_ARM`, определенное как целочисленное литеральное значение 7 для компиляций, предназначенных для процессоров ARM. В противном случае — не определяется.

- `_M_ARM_ARMV7VE` определяется как 1, если для компиляций, предназначенных для процессоров ARM, задан параметр компилятора [/arch: ARMv7VE](../build/reference/arch-arm.md) . В противном случае — не определяется.

- `_M_ARM_FP`, определенное как целочисленное литеральное значение, указывающее, какой параметр компилятора [/Arch](../build/reference/arch-arm.md) был задан для целевых объектов процессора ARM. В противном случае — не определяется.

  - Значение в диапазоне 30-39, если не был указан параметр `/arch` ARM, указывающий архитектуру по умолчанию для ARM (`VFPv3`).

  - Значение в диапазоне 40-49, если было задано `/arch:VFPv4`.

  - Дополнительные сведения см. в разделе [/Arch (ARM)](../build/reference/arch-arm.md).

- `_M_ARM64` определяется как 1 для компиляций, предназначенных для 64-разрядных процессоров ARM. В противном случае — не определяется.

- `_M_CEE`, определенное как 001, если задан любой параметр компилятора [/CLR (CLR compilation)](../build/reference/clr-common-language-runtime-compilation.md) . В противном случае — не определяется.

- в Visual Studio 2015 `_M_CEE_PURE` не рекомендуется. Определяется как 001, если задан параметр компилятора [/CLR: pure](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- в Visual Studio 2015 `_M_CEE_SAFE` не рекомендуется. Определяется как 001, если задан параметр компилятора [/CLR: safe](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_M_FP_EXCEPT` определяется как 1, если задан параметр компилятора [/FP: except](../build/reference/fp-specify-floating-point-behavior.md) или [/FP:](../build/reference/fp-specify-floating-point-behavior.md) parallelism. В противном случае — не определяется.

- `_M_FP_FAST` определяется как 1, если задан параметр компилятора [/FP: Fast](../build/reference/fp-specify-floating-point-behavior.md) . В противном случае — не определяется.

- `_M_FP_PRECISE` определяется как 1, если задан параметр компилятора [/FP: точную](../build/reference/fp-specify-floating-point-behavior.md) . В противном случае — не определяется.

- `_M_FP_STRICT` определяется как 1, если задан параметр компилятора [/FP: Option](../build/reference/fp-specify-floating-point-behavior.md) . В противном случае — не определяется.

- `_M_IX86`, определенное как целочисленное литеральное значение 600 для компиляций, нацеленных на процессоры x86. Этот макрос не определен для целевых объектов компиляции x64 или ARM.

- `_M_IX86_FP`, определенное как целочисленное литеральное значение, указывающее параметр компилятора [/Arch](../build/reference/arch-arm.md) , который был установлен, или значение по умолчанию. Этот макрос всегда определяется, если целью компиляции является процессор x86. В противном случае — не определяется. Если определено, значение равно:

  - 0, если был задан параметр компилятора `/arch:IA32`.

  - 1, если был задан параметр компилятора `/arch:SSE`.

  - 2, если был задан параметр компилятора `/arch:SSE2`, `/arch:AVX`, `/arch:AVX2`или `/arch:AVX512`. Это значение используется по умолчанию, если не был указан параметр компилятора `/arch`. При указании `/arch:AVX` также определяется `__AVX__` макроса. Если указан `/arch:AVX2`, также определяются и `__AVX__`, и `__AVX2__`. Если указано `/arch:AVX512`, также определяются `__AVX__`, `__AVX2__`, `__AVX512BW__`, `__AVX512CD__`, `__AVX512DQ__`, `__AVX512F__` и `__AVX512VL__`.

  - Дополнительные сведения см. в разделе [/arch (x86)](../build/reference/arch-x86.md).

- `_M_X64`, определенное как целочисленное литеральное значение 100 для компиляций, предназначенных для процессоров x64. В противном случае — не определяется.

- `_MANAGED` определяется как 1, если задан параметр компилятора [/CLR](../build/reference/clr-common-language-runtime-compilation.md) . В противном случае — не определяется.

- `_MSC_BUILD`, определенный как целочисленный литерал, содержащий элемент номера редакции номера версии компилятора. Номер редакции — четвертый элемент номера версии с разделителями-точками. Например, если номер версии Microsoft C/C++ Compiler — 15.00.20706.01, макрос `_MSC_BUILD` возвращает значение 1. Этот макрос определяется всегда.

- `_MSC_EXTENSIONS` определяется как 1, если установлен параметр компилятора по умолчанию [(включить расширения языка)](../build/reference/za-ze-disable-language-extensions.md) . В противном случае — не определяется.

- `_MSC_FULL_VER`, определенный как целочисленный литерал, который кодирует основной, дополнительный номер и число элементов сборки номера версии компилятора. Основной номер — это первый элемент номера версии с разделителями точками, дополнительный номер — второй элемент, а номер сборки — третий. Например, если номер версии Microsoft C/C++ Compiler — 15.00.20706.01, макрос `_MSC_FULL_VER` вычисляется как 150020706. Введите `cl /?` в командной строке, чтобы просмотреть номер версии компилятора. Этот макрос определяется всегда.

- `_MSC_VER`, определенный как целочисленный литерал, который кодирует основные и вспомогательные элементы номера версии компилятора. Основной номер — это первый элемент в номере версии с разделителями-точками, а дополнительный номер — второй элемент. Например, если номер версии Microsoft C/C++ Compiler — 17.00.51106.1, макрос `_MSC_VER` вычисляется как 1700. Введите `cl /?` в командной строке, чтобы просмотреть номер версии компилятора. Этот макрос определяется всегда.

   |Версия Visual Studio|`_MSC_VER`|
   |-|-|
   |Visual Studio 6.0|1200|
   |Visual Studio .NET 2002 (7,0)|1300|
   |Visual Studio .NET 2003 (7,1)|1310|
   |Visual Studio 2005 (8,0)|1400|
   |Visual Studio 2008 (9,0)|1500|
   |Visual Studio 2010 (10,0)|1600|
   |Visual Studio 2012 (11,0)|1700|
   |Visual Studio 2013 (12,0)|1800|
   |Visual Studio 2015 (14,0)|1900|
   |Visual Studio 2017 RTW (15,0)|1910|
   |Visual Studio 2017 версия 15.3|1911|
   |Visual Studio 2017 версии 15.5|1912|
   |Visual Studio 2017 версии 15.6|1913|
   |Visual Studio 2017 версии 15.7|1914|
   |Visual Studio 2017 версии 15.8|1915|
   |Visual Studio 2017 версии 15,9|1916|
   |Visual Studio 2019 RTW (16,0)|1920|
   |Visual Studio 2019 версии 16.1|1921|
   |Visual Studio 2019 версии 16.2|1922|
   |Visual Studio 2019 версии 16,3|1923|

   Чтобы проверить наличие выпусков или обновлений компилятора в заданной версии Visual Studio или после, используйте оператор `>=`. Его можно использовать в условной директиве для сравнения `_MSC_VER` с этой известной версией. Если у вас есть несколько взаимоисключающих версий для сравнения, упорядочивайте сравнения в порядке убывания номера версии. Например, этот код проверяет наличие компиляторов, выпущенных в Visual Studio 2017 и более поздних версиях. Затем он проверяет наличие компиляторов, выпущенных в или после Visual Studio 2015. Затем он проверяет наличие всех компиляторов, выпущенных до Visual Studio 2015:

   ```cpp
   #if _MSC_VER >= 1910
   // . . .
   #elif _MSC_VER >= 1900
   // . . .
   #else
   // . . .
   #endif
   ```

   Дополнительные сведения см. в [разделе C++ версия визуального компилятора](https://devblogs.microsoft.com/cppblog/visual-c-compiler-version/) в C++ блоге Microsoft Team.

- `_MSVC_LANG`, определенный как целочисленный литерал, указывающий стандарт C++ языка, который используется компилятором. Он задается только в коде, C++скомпилированном как. Макрос представляет собой целочисленное литеральное значение, 201402L по умолчанию или при указании параметра компилятора [/std: c++ 14](../build/reference/std-specify-language-standard-version.md) . Для макроса задается значение 201703L, если указан параметр компилятора [/std: c++ 17](../build/reference/std-specify-language-standard-version.md) . Если указан параметр [/std: c + + Latest](../build/reference/std-specify-language-standard-version.md) , ему присваивается более высокое, неопределенное значение. В противном случае макрос не определен. Параметры компилятора `_MSVC_LANG` и [/std (указание языковой версии Standard)](../build/reference/std-specify-language-standard-version.md) доступны начиная с Visual Studio 2015 с обновлением 3.

- `__MSVC_RUNTIME_CHECKS`, определенный как 1, если задан один из параметров компилятора [/RTC](../build/reference/rtc-run-time-error-checks.md) . В противном случае — не определяется.

- `_MSVC_TRADITIONAL` задается как 0, если задан режим соответствия препроцессора [/експериментал: параметр компилятора препроцессора](../build/reference/experimental-preprocessor.md) . Определяется как 1 по умолчанию или, если задан параметр [/експериментал: препроцессор-](../build/reference/experimental-preprocessor.md) Compiler, который указывает на использование традиционного препроцессора. Макрос `_MSVC_TRADITIONAL` и [/експериментал: параметр компилятора (включить режим соответствия препроцессора)](../build/reference/experimental-preprocessor.md) доступен начиная с Visual Studio 2017 версии 15,8.

   ```cpp
   #if defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL
   // Logic using the traditional preprocessor
   #else
   // Logic using cross-platform compatible preprocessor
   #endif
   ```

- `_MT` определяется как 1, если задано [/MD или/MDd](../build/reference/md-mt-ld-use-run-time-library.md) (Многопоточная DLL) или [/MT или/MTD](../build/reference/md-mt-ld-use-run-time-library.md) (многопоточное). В противном случае — не определяется.

- `_NATIVE_WCHAR_T_DEFINED` определяется как 1, если задан параметр компилятора [/Zc: wchar_t](../build/reference/zc-wchar-t-wchar-t-is-native-type.md) . В противном случае — не определяется.

- `_OPENMP`, определенный как целочисленный литерал 200203, если установлен параметр компилятора [/OpenMP (включить поддержку openmp 2,0)](../build/reference/openmp-enable-openmp-2-0-support.md) . Это значение представляет дату спецификации OpenMP, реализуемой КОМПИЛЯТОРОМ MSVC. В противном случае — не определяется.

   ```cpp
   // _OPENMP_dir.cpp
   // compile with: /openmp
   #include <stdio.h>
   int main() {
      printf("%d\n", _OPENMP);
   }
   ```

- `_PREFAST_` определяется как 1, если задан параметр компилятора [/Analyze](../build/reference/analyze-code-analysis.md) . В противном случае — не определяется.

- `__TIMESTAMP__`, определенный как строковый литерал, содержащий дату и время последнего изменения текущего исходного файла, в сокращенной форме с постоянной длиной, возвращаемой функцией CRT [asctime](../c-runtime-library/reference/asctime-wasctime.md) , например `Fri 19 Aug 13:32:58 2016`. Этот макрос определяется всегда.

- `_VC_NODEFAULTLIB` задается как 1, если задан параметр компилятора [/Zl (опущено имя библиотеки по умолчанию)](../build/reference/zl-omit-default-library-name.md) . В противном случае — не определяется.

- `_WCHAR_T_DEFINED` определяется как 1, если установлен параметр компилятора [/Zc: wchar_t](../build/reference/zc-wchar-t-wchar-t-is-native-type.md) по умолчанию. Макрос `_WCHAR_T_DEFINED` определен, но не имеет значения, если задан параметр компилятора `/Zc:wchar_t-`, а **wchar_t** определен в файле заголовка системы, включенном в проект. В противном случае — не определяется.

- `_WIN32` определяется как 1, если целью компиляции является 32-разрядная ARM, 64-разрядная ARM, x86 или x64. В противном случае — не определяется.

- `_WIN64` определяется как 1, если целью компиляции является 64-разрядная ARM или x64. В противном случае — не определяется.

- `_WINRT_DLL` задается как 1 при C++ компиляции, как и параметры компилятора [/ZW (среда выполнения Windows compilation)](../build/reference/zw-windows-runtime-compilation.md) , [/LD или/LDD](../build/reference/md-mt-ld-use-run-time-library.md) . В противном случае — не определяется.

Нет макросов препроцессора, которые определяют версию библиотеки ATL или MFC, предопределенной компилятором. Заголовки библиотек ATL и MFC определяют эти макросы для внутренних целей. Они не определены в директивах препроцессора, выполняемых до включения обязательного заголовка.

- `_ATL_VER`, определенные в \<атлдеф. h > как целочисленный литерал, который кодирует номер версии ATL.

- `_MFC_VER`, определенные в \<afxver_. h > как целочисленный литерал, который кодирует номер версии MFC.

## <a name="see-also"></a>См. также:

[Макросы (C/C++)](../preprocessor/macros-c-cpp.md)<br/>
[Операторы препроцессора](../preprocessor/preprocessor-operators.md)<br/>
[Директивы препроцессора](../preprocessor/preprocessor-directives.md)
