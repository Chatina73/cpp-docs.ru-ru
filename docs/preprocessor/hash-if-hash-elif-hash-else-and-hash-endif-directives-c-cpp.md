---
title: '#IF, #elif, #else и #endif (C/C++)'
ms.date: 11/04/2016
f1_keywords:
- '#else'
- '#endif'
- '#if'
- '#elif'
- defined
- __has_include
helpviewer_keywords:
- '#elif directive'
- conditional compilation, directives
- endif directive (#endif)
- preprocessor, directives
- '#else directive'
- '#endif directive'
- if directive (#if)
- else directive (#else)
- '#if directive'
- elif directive (#elif)
- defined directive
ms.assetid: c77a175f-6ca8-47d4-8df9-7bac5943d01b
ms.openlocfilehash: 90fbab45c6408c30198c2a52a42545718002cc11
ms.sourcegitcommit: c7f90df497e6261764893f9cc04b5d1f1bf0b64b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/05/2019
ms.locfileid: "59028095"
---
# <a name="if-elif-else-and-endif-directives-cc"></a>Директивы #if, #elif, #else и #endif (C/C++)

**#If** директиву, **#elif**, **#else**, и **#endif** директивы, управляет компиляцией частей исходного файла. При написании выражения (после **#if**) имеет ненулевое значение, может быть введена сразу после **#if** директива сохраняется в записи преобразования.

## <a name="grammar"></a>Грамматика

*условный* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*IF часть elif части*<sub>opt</sub> *else часть*<sub>opt</sub> *endif строка*

*IF часть* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*текст строки If*

*строки IF* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**#if**  *constant-expression*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**#ifdef***идентификатор*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**#ifndef**  *identifier*

*elif части* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*elif строка текста*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*elif части elif строка текста*

*elif строка* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**#elif**  *constant-expression*

*Else часть* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*текст строки else*

*Else строка* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**#else**

*ENDIF строка* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**#endif**

Каждый **#if** директивы в исходном файле должна быть соответствующая закрывающая **#endif** директива. Любое количество **#elif** директивы могут появляться между **#if** и **#endif** директивы, но не более одного **#else** директива разрешено. **#Else** директива, если он присутствует, должна быть последней перед директивой **#endif**.

**#If**, **#elif**, **#else**, и **#endif** директивы могут быть вложены в другие текстовые части **#if**директивы. Каждая вложенная **#else**, **#elif**, или **#endif** относится к ближайшей предшествующей директива **#if** директива.

Все директивы условной компиляции, такие как **#if** и **#ifdef**, должны быть соответствующие закрывающие **#endif** директивы до конца файла; в противном случае — ошибка формируется сообщение. Если директивы условной компиляции содержатся в включаемых файлов, они должны удовлетворять одинаковым условиям: Должно существовать не несовпадающие директивы условной компиляции, в конце включаемого файла.

Выполняется подстановка макросов внутри той части командной строки, которая следует за **#elif** команды, поэтому вызовы макросов можно использовать в *константное_выражение*.

Препроцессор выбирает одно из заданных вхождений параметра *текст* для дальнейшей обработки. Блок, указанный в *текст* может быть любая текстовая последовательность. Он может занимать несколько строк. Обычно *текст* — это текст программы, которая имеет смысл для компилятора или препроцессора.

Препроцессор обрабатывает выделенный *текст* и передает его в компилятор. Если *текст* содержит директивы препроцессора, препроцессор выполняет эти директивы. Компилируются только текстовые блоки, выбранные препроцессором.

Препроцессор выбирает один *текст* элемента, оценивая константные выражения, следующие за каждой **#if** или **#elif** директива, пока не найдет константа true (ненулевое) выражение. Выделяется весь текст (включая другие директивы препроцессора, начиная с версии **#**) до соответствующей **#elif**, **#else**, или **#endif** .

Если все вхождения *константное_выражение* имеют значение false, или нет ни одной **#elif** отображается директивы, препроцессор выбирает блок текста после **#else** предложение. Если **#else** предложение опущено и все экземпляры *константное_выражение* в **#if** блок имеют значение false, выбран ни один текстовый блок.

*Константное_выражение* целочисленное константное выражение со следующими дополнительными ограничениями:

- Выражения должны иметь целочисленный тип и могут содержать только целочисленные константы, символьные константы и **определенные** оператор.

- В выражении не допускается использование оператора `sizeof` или оператора приведения типа.

- Целевая среда может быть не в состоянии представлять все диапазоны целых чисел.

- Преобразование представляет тип **int** совпадал с типом **long**, и **unsigned int** так же, как **unsigned long**.

- Транслятор может преобразовывать символьные константы в набор кодовых значений, отличающийся от набора для целевой среды. Для определения свойств целевой среды проверьте значения макросов из файла LIMITS.H в приложении, собранном для целевой среды.

- Выражение не должно выполнять никаких запросов среды и не должно зависеть от конкретной реализации на целевом компьютере.

## <a name="defined"></a>определенный

Оператор препроцессора **определенные** можно использовать в специальных константных выражениях, как показано в следующем синтаксисе:

defined( `identifier` )

определенный `identifier`

Это константное выражение считается true (ненулевое), если *идентификатор* определена; в противном случае условие равно false (0). Идентификатор, определенный как пустой текст, считается определенным. **Определенные** директива может использоваться в **#if** и **#elif** директива, но нигде больше.

В следующем примере **#if** и **#endif** директивы управления компиляции одного из трех вызовов функций:

```C
#if defined(CREDIT)
    credit();
#elif defined(DEBIT)
    debit();
#else
    printerror();
#endif
```

Вызов функции `credit` компилируется, если определен идентификатор `CREDIT`. Если определен идентификатор `DEBIT`, компилируется вызов функции `debit`. Если ни один из этих идентификаторов не определен, компилируется вызов функции `printerror`. Обратите внимание, что в C и C++ идентификаторы `CREDIT` и `credit` — это разные идентификаторы из-за различного регистра символов.

В следующем примере в операторах условной компиляции используется ранее определенная символьная константа с именем `DLEVEL`.

```C
#if DLEVEL > 5
    #define SIGNAL  1
    #if STACKUSE == 1
        #define STACK   200
    #else
        #define STACK   100
    #endif
#else
    #define SIGNAL  0
    #if STACKUSE == 1
        #define STACK   100
    #else
        #define STACK   50
    #endif
#endif
#if DLEVEL == 0
    #define STACK 0
#elif DLEVEL == 1
    #define STACK 100
#elif DLEVEL > 5
    display( debugptr );
#else
    #define STACK 200
#endif
```

Первый **#if** блок содержит 2 набора вложенных **#if**, **#else**, и **#endif** директивы. Первый набор директив обрабатывается только в том случае, если выполняется условие `DLEVEL > 5`. В противном случае операторы, расположенные после **#else** обрабатываются.

**#Elif** и **#else** директивы во втором примере используются для выбора одного из четырех вариантов, в зависимости от значения `DLEVEL`. Константе `STACK` присваивается значение 0, 100 или 200 в зависимости от определения константы `DLEVEL`. Если `DLEVEL` больше 5, то компилируется оператор

```C
#elif DLEVEL > 5
display(debugptr);
```

и константа `STACK` остается неопределенной.

Условная компиляция обычно используется для предотвращения нескольких включений одного и того же файла заголовка. В языке C++, в котором классы часто определяются в файлах заголовков, конструкции, подобные приведенным ниже, можно использовать для исключения многократных определений.

```cpp
/*  EXAMPLE.H - Example header file  */
#if !defined( EXAMPLE_H )
#define EXAMPLE_H

class Example
{
...
};

#endif // !defined( EXAMPLE_H )
```

Предыдущий код проверяет, определена ли символьная константа `EXAMPLE_H`. Если определена, файл уже включен и его повторная обработка не требуется. Если нет, константа `EXAMPLE_H` определяется, чтобы пометить файл EXAMPLE.H как уже обработанный.

## <a name="hasinclude"></a>__has_include

**Visual Studio 2017 версии 15.3 и выше**.  Определяет, доступен ли заголовок библиотеки для включения:

```cpp
#ifdef __has_include
#  if __has_include(<filesystem>)
#    include <filesystem>
#    define have_filesystem 1
#  elif __has_include(<experimental/filesystem>)
#    include <experimental/filesystem>
#    define have_filesystem 1
#    define experimental_filesystem
#  else
#    define have_filesystem 0
#  endif
#endif
```

## <a name="see-also"></a>См. также

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)