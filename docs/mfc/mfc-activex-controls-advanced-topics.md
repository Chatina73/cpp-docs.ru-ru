---
title: 'Элементы управления ActiveX в MFC: Дополнительные разделы'
ms.date: 09/12/2018
helpviewer_keywords:
- MFC ActiveX controls [MFC], error codes
- MFC ActiveX controls [MFC], accessing invisible dialog controls
- MFC ActiveX controls [MFC], advanced topics
- FireError method [MFC]
- MFC ActiveX controls [MFC], database classes
- MFC ActiveX controls [MFC], special keys
- PreTranslateMessage method [MFC]
- MFC ActiveX controls [MFC], parameterized property
- ThrowError method [MFC]
ms.assetid: e9e34abb-8e2d-461e-bb9c-a1aec5dcecbd
ms.openlocfilehash: e0daabf3d236eb7038f22c54ea76d616baf613a0
ms.sourcegitcommit: 2f96e2fda591d7b1b28842b2ea24e6297bcc3622
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/18/2019
ms.locfileid: "71096000"
---
# <a name="mfc-activex-controls-advanced-topics"></a>Элементы управления ActiveX в MFC: Дополнительные разделы

В этой статье рассматриваются дополнительные темы, связанные с разработкой элементов управления ActiveX. Сюда входит следующее.

- [Использование классов баз данных в элементах управления ActiveX](#_core_using_database_classes_in_activex_controls)

- [Реализация параметризованного свойства](#_core_implementing_a_parameterized_property)

- [Обработка ошибок в элементе управления ActiveX](#_core_handling_errors_in_your_activex_control)

- [Обработка специальных ключей в элементе управления](#_core_handling_special_keys_in_your_control)

- [Доступ к элементам управления диалогового окна, невидимым во время выполнения](#_core_accessing_dialog_controls_that_are_invisible_at_run_time)

>[!IMPORTANT]
> ActiveX — это устаревшая технология, которую не следует использовать для новой разработки. Дополнительные сведения о современных технологиях, которые заменяют ActiveX, см. в разделе [элементы управления ActiveX](activex-controls.md).

##  <a name="_core_using_database_classes_in_activex_controls"></a>Использование классов баз данных в элементах управления ActiveX

Поскольку классы элементов управления ActiveX являются частью библиотеки классов, можно применить те же процедуры и правила для использования классов баз данных в стандартном приложении MFC для разработки элементов управления ActiveX, использующих классы базы данных MFC.

Общие сведения о классах базы данных MFC см. в разделе [MFC Database Classes (DAO и ODBC)](../data/mfc-database-classes-odbc-and-dao.md). В статье рассматриваются классы ODBC MFC и MFC DAO, а также приводятся дополнительные сведения.

> [!NOTE]
>   DAO поддерживается в Office 2013. Версия DAO 3,6 является окончательной и считается устаревшей. Визуальная C++ среда и мастера не поддерживают DAO (хотя классы DAO включены и их все еще можно использовать). Корпорация Майкрософт рекомендует использовать [шаблоны OLE DB](../data/oledb/ole-db-programming.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только для поддержки существующих приложений.

##  <a name="_core_implementing_a_parameterized_property"></a>Реализация параметризованного свойства

Параметризованное свойство (иногда называемое массивом свойств) представляет собой метод предоставления однородной коллекции значений в виде одного свойства элемента управления. Например, можно использовать параметризованное свойство, чтобы предоставить массив или словарь в качестве свойства. В Visual Basic доступ к такому свойству осуществляется с помощью нотации массива:

[!code-vb[NVC_MFC_AxVb#1](../mfc/codesnippet/visualbasic/mfc-activex-controls-advanced-topics_1.vb)]

Используйте мастер добавления свойств для реализации параметризованного свойства. Мастер добавления свойств реализует свойство, добавляя пару функций Get/Set, которые позволяют пользователю элемента управления обращаться к свойству с помощью приведенной выше нотации или стандартного способа.

Как и методы и свойства, параметризованные свойства также имеют ограничение на количество допустимых параметров. В случае параметризованных свойств ограничение составляет 15 параметров (с одним параметром, зарезервированным для хранения значения свойства).

В следующей процедуре добавляется параметризованное свойство с именем Array, доступ к которому можно получить в виде двумерного массива целых чисел.

#### <a name="to-add-a-parameterized-property-using-the-add-property-wizard"></a>Добавление параметризованного свойства с помощью мастера добавления свойства

1. Загрузите проект элемента управления.

1. В представлении класса разверните узел библиотеки элемента управления.

1. Щелкните правой кнопкой мыши узел интерфейса для элемента управления (второй узел узла библиотеки), чтобы открыть контекстное меню.

1. В контекстном меню выберите **Добавить** , а затем — **Добавить свойство**.

1. В поле **имя свойства** введите `Array`.

1. В поле **тип свойства выберите значение** **Short**.

1. В качестве типа **реализации** щелкните **Get/Set методы**.

1. В полях **получить функцию** и **установить** функции введите уникальные имена для функций get и Set или примите имена по умолчанию.

9. Добавьте параметр с именем *Row* (тип *Short*), используя **имя параметра** и элементы управления **типа параметра** .

10. Добавьте второй параметр с именем *Column* (тип *Short*).

11. Нажмите кнопку **Готово**.

### <a name="changes-made-by-the-add-property-wizard"></a>Изменения, внесенные мастером добавления свойств

При добавлении пользовательского свойства мастер добавления свойств вносит изменения в заголовок класса элемента управления (. H) и реализацию (. CPP) файлы.

В класс Control добавляются следующие строки. H файл:

[!code-cpp[NVC_MFC_AxUI#35](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_2.h)]

Этот код объявляет две функции с именем `GetArray` и `SetArray` , позволяющие пользователю запрашивать определенную строку и столбец при доступе к свойству.

Кроме того, мастер добавления свойств добавляет следующие строки в карту диспетчеризации элемента управления, расположенную в реализации класса элемента управления (. Файл CPP):

[!code-cpp[NVC_MFC_AxUI#36](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_3.cpp)]

Наконец, реализации `GetArray` функций и `SetArray` добавляются в конец. Файл CPP. В большинстве случаев вы измените функцию Get, чтобы она возвращала значение свойства. Функция Set обычно содержит код, который должен выполняться до или после изменения свойства.

Чтобы это свойство было полезным, можно объявить в классе Control переменную-член двумерного массива типа **Short**, чтобы сохранить значения для параметризованного свойства. Затем можно изменить функцию Get, чтобы она возвращала значение, хранящееся в соответствующей строке и столбце, как указано в параметрах, и изменить функцию Set для обновления значения, на которое ссылаются параметры строки и столбца.

##  <a name="_core_handling_errors_in_your_activex_control"></a>Обработка ошибок в элементе управления ActiveX

Если в элементе управления возникают ошибки, может потребоваться сообщить об ошибке в контейнер элемента управления. Существует два способа сообщения об ошибках в зависимости от ситуации, в которой возникает ошибка. Если ошибка возникает в функции Get или Set свойства или в реализации метода OLE-автоматизации, элемент управления должен вызвать [COleControl:: ThrowError](../mfc/reference/colecontrol-class.md#throwerror), который сигнализирует пользователю элемента управления о том, что произошла ошибка. Если эта ошибка возникает в любое другое время, элемент управления должен вызвать [COleControl:: фириррор](../mfc/reference/colecontrol-class.md#fireerror), который вызывает событие ошибки акции.

Чтобы указать тип произошедшей ошибки, элемент управления должен передать код ошибки в `ThrowError` или. `FireError` Код ошибки — это код состояния OLE, который имеет 32-разрядное значение. По возможности выберите код ошибки из стандартного набора кодов, определенных в ОЛЕКТЛ. Файл заголовка H. В следующей таблице перечислены эти коды.

### <a name="activex-control-error-codes"></a>Коды ошибок элементов управления ActiveX

|Ошибка|Описание|
|-----------|-----------------|
|CTL_E_ILLEGALFUNCTIONCALL|Недопустимый вызов функции|
|CTL_E_OVERFLOW|Переполнение|
|CTL_E_OUTOFMEMORY|Нет памяти|
|CTL_E_DIVISIONBYZERO|Деление на ноль|
|CTL_E_OUTOFSTRINGSPACE|Недостаточно места для строки|
|CTL_E_OUTOFSTACKSPACE|Недостаточно места для стека|
|CTL_E_BADFILENAMEORNUMBER|Недопустимое имя файла или номер|
|CTL_E_FILENOTFOUND|Файл не найден|
|CTL_E_BADFILEMODE|Недопустимый режим файла|
|CTL_E_FILEALREADYOPEN|Файл уже открыт|
|CTL_E_DEVICEIOERROR|Ошибка ввода-вывода устройства|
|CTL_E_FILEALREADYEXISTS|Файл уже существует|
|CTL_E_BADRECORDLENGTH|Недопустимая длина записи|
|CTL_E_DISKFULL|Диск полон|
|CTL_E_BADRECORDNUMBER|Неверный номер записи|
|CTL_E_BADFILENAME|Неправильное имя файла|
|CTL_E_TOOMANYFILES|Слишком много файлов|
|CTL_E_DEVICEUNAVAILABLE|Устройство недоступно|
|CTL_E_PERMISSIONDENIED|В разрешении отказано|
|CTL_E_DISKNOTREADY|Диск не готов|
|CTL_E_PATHFILEACCESSERROR|Ошибка доступа к пути или файлу|
|CTL_E_PATHNOTFOUND|Путь не найден|
|CTL_E_INVALIDPATTERNSTRING|Недопустимая строка шаблона|
|CTL_E_INVALIDUSEOFNULL|Недопустимое использование значения NULL|
|CTL_E_INVALIDFILEFORMAT|Недопустимый формат файла|
|CTL_E_INVALIDPROPERTYVALUE|Недопустимое значение свойства|
|CTL_E_INVALIDPROPERTYARRAYINDEX|Недопустимый индекс массива свойств|
|CTL_E_SETNOTSUPPORTEDATRUNTIME|Установка не поддерживается во время выполнения|
|CTL_E_SETNOTSUPPORTED|Set не поддерживается (свойство доступно только для чтения)|
|CTL_E_NEEDPROPERTYARRAYINDEX|Требуется индекс массива свойства|
|CTL_E_SETNOTPERMITTED|Функция set запрещена|
|CTL_E_GETNOTSUPPORTEDATRUNTIME|Get не поддерживается во время выполнения|
|CTL_E_GETNOTSUPPORTED|Get не поддерживается (свойство доступно только для записи).|
|CTL_E_PROPERTYNOTFOUND|Свойство не найдено|
|CTL_E_INVALIDCLIPBOARDFORMAT|Недопустимый формат буфера обмена|
|CTL_E_INVALIDPICTURE|Недопустимое изображение|
|CTL_E_PRINTERERROR|Ошибка принтера|
|CTL_E_CANTSAVEFILETOTEMP|Не удается сохранить файл в TEMP|
|CTL_E_SEARCHTEXTNOTFOUND|Искомый текст не найден|
|CTL_E_REPLACEMENTSTOOLONG|Недопустимая длина замены|

При необходимости используйте макрос CUSTOM_CTL_SCODE, чтобы определить пользовательский код ошибки для условия, не охваченного одним из стандартных кодов. Параметр для этого макроса должен быть целым числом в диапазоне от 1000 до 32767 включительно. Например:

[!code-cpp[NVC_MFC_AxUI#37](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_4.cpp)]

Если вы создаете элемент управления ActiveX для замены существующего элемента управления VBX, определите коды ошибок элементов управления ActiveX с теми же числовыми значениями, которые элемент управления VBX использует для обеспечения совместимости кодов ошибок.

##  <a name="_core_handling_special_keys_in_your_control"></a>Обработка специальных ключей в элементе управления

В некоторых случаях может возникнуть необходимость в обработке определенных сочетаний клавиш особым образом. Например, вставьте новую строку при нажатии клавиши Ввод в многострочном элементе управления текстового поля или при перемещении между группой элементов управления редактированием при нажатии идентификатора направленного ключа.

Если базовым классом элемента управления ActiveX является `COleControl`, можно переопределить [CWnd::P ретранслатемессаже](../mfc/reference/cwnd-class.md#pretranslatemessage) для обработки сообщений до их обработки контейнером. При использовании этой методики всегда возвращают **значение true** , если обрабатывается сообщение в переопределении `PreTranslateMessage`.

В следующем примере кода показан возможный способ обработки любых сообщений, связанных с направленными клавишами.

[!code-cpp[NVC_MFC_AxUI#38](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_5.cpp)]

Дополнительные сведения об обработке интерфейсов клавиатуры для элемента управления ActiveX см. в документации по пакету SDK для ActiveX.

##  <a name="_core_accessing_dialog_controls_that_are_invisible_at_run_time"></a>Доступ к элементам управления диалогового окна, невидимым во время выполнения

Можно создавать диалоговые элементы управления, не имеющие пользовательского интерфейса и невидимые во время выполнения. Если добавить невидимый элемент управления ActiveX во время выполнения в диалоговое окно и использовать [CWnd:: жетдлгитем](../mfc/reference/cwnd-class.md#getdlgitem) для доступа к элементу управления, элемент управления будет работать неправильно. Вместо этого следует использовать один из следующих методов для получения объекта, представляющего элемент управления:

- С помощью мастера добавления переменной члена выберите **элемент управления переменная** и выберите идентификатор элемента управления. Введите имя переменной-члена и выберите класс-оболочку элемента управления в качестве **типа элемента управления**.

     -или-

- Объявите локальную переменную и подкласс в качестве элемента диалогового окна. Вставьте код, похожий на следующий (`CMyCtrl` это класс-оболочка, IDC_MYCTRL1 — идентификатор элемента управления):

   [!code-cpp[NVC_MFC_AxCont#19](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_6.cpp)]

## <a name="see-also"></a>См. также

[Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)
