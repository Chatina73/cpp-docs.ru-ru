---
title: 'Элементы ActiveX в MFC: Дополнительные разделы | Документация Майкрософт'
ms.custom: ''
ms.date: 09/12/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- MFC ActiveX controls [MFC], error codes
- MFC ActiveX controls [MFC], accessing invisible dialog controls
- MFC ActiveX controls [MFC], advanced topics
- FireError method [MFC]
- MFC ActiveX controls [MFC], database classes
- MFC ActiveX controls [MFC], special keys
- PreTranslateMessage method [MFC]
- MFC ActiveX controls [MFC], parameterized property
- ThrowError method [MFC]
ms.assetid: e9e34abb-8e2d-461e-bb9c-a1aec5dcecbd
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: defc160b2b45185031160e0ba3dd553f8896e372
ms.sourcegitcommit: a3c9e7888b8f437a170327c4c175733ad9eb0454
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2018
ms.locfileid: "50204695"
---
# <a name="mfc-activex-controls-advanced-topics"></a>Элементы управления ActiveX в MFC. Дополнительные разделы

В этой статье представлены дополнительные разделы, связанные с разработкой элементов управления ActiveX. Сюда входит следующее.

- [Использование классов базы данных в элементах управления ActiveX](#_core_using_database_classes_in_activex_controls)

- [Реализация свойства с параметрами](#_core_implementing_a_parameterized_property)

- [Обработка ошибок в элементе управления ActiveX](#_core_handling_errors_in_your_activex_control)

- [Обработка специальных клавиш в элементе управления](#_core_handling_special_keys_in_your_control)

- [Доступ к элементам управления диалогового окна, которые невидимы во время выполнения](#_core_accessing_dialog_controls_that_are_invisible_at_run_time)

>[!IMPORTANT]
> ActiveX — это устаревшая технология, которая не следует использовать для разработки новых приложений. Дополнительные сведения о современных технологий, заменяющие ActiveX, см. в разделе [элементы управления ActiveX](activex-controls.md).

##  <a name="_core_using_database_classes_in_activex_controls"></a> Использование классов базы данных в элементах управления ActiveX

Поскольку классы элементов управления ActiveX являются частью библиотеки классов, можно применить те же процедуры и правила для использование классов базы данных в приложении MFC standard для разработки элементов управления ActiveX, использующих классы базы данных MFC.

Общие классы MFC базы данных, см. в разделе [классы баз данных MFC (DAO и ODBC)](../data/mfc-database-classes-odbc-and-dao.md). В этой статье представлены классы MFC ODBC и классы MFC DAO, а также указаны дополнительные сведения о либо.

> [!NOTE]
>  Среды Visual C++ и мастерах не поддерживают DAO (хотя классы DAO включены и их по-прежнему можно использовать). Корпорация Майкрософт рекомендует использовать [шаблоны OLE DB](../data/oledb/ole-db-programming.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только для поддержки существующих приложений.

##  <a name="_core_implementing_a_parameterized_property"></a> Реализация свойства с параметрами

Свойства с параметрами (иногда называется массива свойств) — это метод для предоставления однородную коллекцию значений как одно свойство элемента управления. Например можно использовать свойства с параметрами для предоставления массив или словарь в виде свойства. В Visual Basic такое свойство осуществляется с помощью нотации массива:

[!code-vb[NVC_MFC_AxVb#1](../mfc/codesnippet/visualbasic/mfc-activex-controls-advanced-topics_1.vb)]

Используйте мастер добавления свойств для реализации свойства с параметрами. Мастер добавления свойств реализует свойство путем добавления пары функций Get и Set, позволяющие пользователю элемента управления для доступа к свойству, используя нотацию выше или обычным способом.

Как и методы и свойства, параметризованные свойства также предельное число разрешенных параметров. В случае параметризованные свойства ограничение составляет 15 параметров (с одним параметром, зарезервированных для хранения значения свойства).

В следующей процедуре добавляется параметризованного свойства вызывается массив, который может осуществляться как двумерный массив целых чисел.

#### <a name="to-add-a-parameterized-property-using-the-add-property-wizard"></a>Чтобы добавить параметризованные свойства с помощью мастера добавления свойства

1. Загрузите проект элемента управления.

1. В представлении класса разверните узел библиотеки элемента управления.

1. Щелкните правой кнопкой мыши узел интерфейса для элемента управления (второй узел узла библиотеки), чтобы открыть контекстное меню.

1. В контекстном меню, щелкните **добавить** и нажмите кнопку **добавить свойство**.

1. В **имя свойства** введите `Array`.

1. В **тип свойства** выберите **короткие**.

1. Для **реализации** типа, щелкните **методы Get и Set**.

1. В **функция Get** и **задать функцию** полях введите уникальные имена для вашей функций Get и Set или примите имена по умолчанию.

9. Добавьте параметр с именем *строки* (тип *короткие*), с использованием **имя параметра** и **тип параметра** элементов управления.

10. Добавьте второй параметр с именем *столбец* (тип *короткие*).

11. Нажмите кнопку **Готово**.

### <a name="changes-made-by-the-add-property-wizard"></a>Изменения, внесенные в мастер добавления свойства

При добавлении пользовательского свойства, мастер добавления свойств вносит изменения в заголовок класса элемента управления (. H) и реализации (. Файлы CPP).

Следующие строки добавляются в класс элемента управления. H-файл:

[!code-cpp[NVC_MFC_AxUI#35](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_2.h)]

Этот код объявляет две функции, вызываемые `GetArray` и `SetArray` , которые позволяют пользователю запрашивать указанной строке и столбце при доступе к свойству.

Кроме того, мастер добавления свойств добавляет следующие строки диспетчеризации на карту элементов управления, расположенных в реализации класса элемента управления (. Файл CPP):

[!code-cpp[NVC_MFC_AxUI#36](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_3.cpp)]

Наконец, реализации `GetArray` и `SetArray` функции добавляются в конец коллекции. CPP-файл. В большинстве случаев вы измените функцию Get для возврата значения свойства. Функция Set обычно будет содержать код, который должен выполняться до или после изменения свойств.

Для этого свойства быть полезным, вы можете объявить переменную-член двумерный массив в класс элемента управления типа **короткие**, чтобы хранить значения для параметризованного свойства. Можно затем изменить функция Get возвращает значение, хранящееся в соответствующие строки и столбца, как указано параметрами и измените функцию Set, чтобы обновить значение ссылается параметры строк и столбцов.

##  <a name="_core_handling_errors_in_your_activex_control"></a> Обработка ошибок в элементе управления ActiveX

Если произойдет ошибка в элементе управления, может потребоваться сообщить об ошибке в контейнер элемента управления. Существует два метода для сообщений об ошибках, в зависимости от ситуации, в котором произошла ошибка. Если эта ошибка возникает в свойства Get или Set, функция, или в реализации метода OLE-автоматизации, управления должны вызывать [COleControl::ThrowError](../mfc/reference/colecontrol-class.md#throwerror), какие сигналы для элемента управления пользователя, произошла ошибка. Если данная ошибка возникает в любое другое время, необходимо вызвать элемент управления [COleControl::FireError](../mfc/reference/colecontrol-class.md#fireerror), которое генерируется стандартное событие ошибки.

Чтобы указать тип возникшей ошибки, элемента управления необходимо передать код ошибки для `ThrowError` или `FireError`. Код ошибки, является код состояния OLE, который имеет 32-разрядное значение. По возможности выбирайте код ошибки из стандартного набора кодов, определенных в OLECTL. Файл заголовка. В следующей таблице перечислены эти коды.

### <a name="activex-control-error-codes"></a>Коды ошибок элементов управления ActiveX

|Error|Описание|
|-----------|-----------------|
|CTL_E_ILLEGALFUNCTIONCALL|Ошибочный вызов функции|
|CTL_E_OVERFLOW|Переполнение|
|CTL_E_OUTOFMEMORY|Нет памяти|
|CTL_E_DIVISIONBYZERO|Деление на ноль|
|CTL_E_OUTOFSTRINGSPACE|Недостаточно места для строки|
|CTL_E_OUTOFSTACKSPACE|Недостаточно места для стека|
|CTL_E_BADFILENAMEORNUMBER|Недопустимое имя файла или номер|
|CTL_E_FILENOTFOUND|Файл не найден|
|CTL_E_BADFILEMODE|Недопустимый режим файла|
|CTL_E_FILEALREADYOPEN|Файл уже открыт|
|CTL_E_DEVICEIOERROR|Ошибка ввода-вывода устройства|
|CTL_E_FILEALREADYEXISTS|Файл уже существует|
|CTL_E_BADRECORDLENGTH|Недопустимая длина записи|
|CTL_E_DISKFULL|Диск заполнен|
|CTL_E_BADRECORDNUMBER|Неверный номер записи|
|CTL_E_BADFILENAME|Недопустимое имя файла|
|CTL_E_TOOMANYFILES|Слишком много файлов|
|CTL_E_DEVICEUNAVAILABLE|Устройство недоступно|
|CTL_E_PERMISSIONDENIED|В разрешении отказано|
|CTL_E_DISKNOTREADY|Диск не готов|
|CTL_E_PATHFILEACCESSERROR|Ошибка доступа к пути/файлу|
|CTL_E_PATHNOTFOUND|Путь не найден|
|CTL_E_INVALIDPATTERNSTRING|Недопустимая строка шаблона|
|CTL_E_INVALIDUSEOFNULL|Недопустимое использование значения NULL|
|CTL_E_INVALIDFILEFORMAT|Недопустимый формат файла|
|CTL_E_INVALIDPROPERTYVALUE|Недопустимое значение свойства|
|CTL_E_INVALIDPROPERTYARRAYINDEX|Недопустимый индекс массива свойств|
|CTL_E_SETNOTSUPPORTEDATRUNTIME|Установка не поддерживается во время выполнения|
|CTL_E_SETNOTSUPPORTED|Set не поддерживается (свойство доступно только для чтения)|
|CTL_E_NEEDPROPERTYARRAYINDEX|Требуется индекс массива свойства|
|CTL_E_SETNOTPERMITTED|Функция set запрещена|
|CTL_E_GETNOTSUPPORTEDATRUNTIME|Get не поддерживается во время выполнения|
|CTL_E_GETNOTSUPPORTED|Get не поддерживается (свойство доступно только для записи).|
|CTL_E_PROPERTYNOTFOUND|Свойство не найдено|
|CTL_E_INVALIDCLIPBOARDFORMAT|Недопустимый формат буфера обмена|
|CTL_E_INVALIDPICTURE|Недопустимое изображение|
|CTL_E_PRINTERERROR|Ошибка принтера|
|CTL_E_CANTSAVEFILETOTEMP|Не удается сохранить файл в TEMP|
|CTL_E_SEARCHTEXTNOTFOUND|Искомый текст не найден|
|CTL_E_REPLACEMENTSTOOLONG|Недопустимая длина замены|

При необходимости используйте макрос CUSTOM_CTL_SCODE для определения пользовательским кодом ошибки условие, которое не соответствует ни один из стандартных кодов. Параметр этого макроса должен быть целым числом от 1000 до 32 767, включительно. Пример:

[!code-cpp[NVC_MFC_AxUI#37](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_4.cpp)]

При создании элемента управления ActiveX для замены существующего элемента управления VBX определите коды ошибок элементов управления ActiveX, с тем же числовые значения, которые VBX управления использует, чтобы убедиться в совместимости коды ошибок вашей.

##  <a name="_core_handling_special_keys_in_your_control"></a> Обработка специальных клавиш в элементе управления

В некоторых случаях может потребоваться обрабатывать определенные сочетания клавиш особым образом; Например, вставить новую строку при нажатии клавиши ВВОД в многострочном текстовом поле элемента управления или перемещать между группами редактирования контролирует при направленная нажата идентификатор ключа.

Если базовый класс элемента управления ActiveX `COleControl`, можно переопределить [CWnd::PreTranslateMessage](../mfc/reference/cwnd-class.md#pretranslatemessage) для обработки сообщений, прежде чем контейнера обрабатывает их. При использовании этого метода всегда возвращает **TRUE** при обработке сообщения в переопределении `PreTranslateMessage`.

В следующем примере кода демонстрируется возможных способов обработки всех сообщений, относящихся к стрелок.

[!code-cpp[NVC_MFC_AxUI#38](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_5.cpp)]

Дополнительные сведения об обработке интерфейсы клавиатуры для элемента управления ActiveX см. в документации пакета SDK ActiveX.

##  <a name="_core_accessing_dialog_controls_that_are_invisible_at_run_time"></a> Доступ к элементам управления диалогового окна, которые невидимы во время выполнения

Вы можете создать элементов управления диалоговых окон, которые не имеют пользовательского интерфейса и невидимы во время выполнения. При добавлении невидимым во время выполнения элемента управления ActiveX в диалоговое окно и используйте [CWnd::GetDlgItem](../mfc/reference/cwnd-class.md#getdlgitem) для доступа к элементу управления, элемент управления не будет работать правильно. Вместо этого для получения объекта, который представляет элемент управления следует использовать один из следующих способов:

- С помощью члена мастер добавления переменной, выберите **управления переменной** , а затем выберите идентификатор элемента управления. Введите имя переменной члена и выберите класс-оболочка элемента управления как **типа элемента управления**.

     - или -

- Объявите локальную переменную и подкласс как элемент диалоговое окно. Вставьте код, который имеет следующий вид (`CMyCtrl` — это класс-оболочку, IDC_MYCTRL1 — это идентификатор элемента управления):

   [!code-cpp[NVC_MFC_AxCont#19](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_6.cpp)]

## <a name="see-also"></a>См. также

[Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)

