---
title: Элементы управления ActiveX в MFC. Дополнительные разделы
ms.date: 09/12/2018
helpviewer_keywords:
- MFC ActiveX controls [MFC], error codes
- MFC ActiveX controls [MFC], accessing invisible dialog controls
- MFC ActiveX controls [MFC], advanced topics
- FireError method [MFC]
- MFC ActiveX controls [MFC], database classes
- MFC ActiveX controls [MFC], special keys
- PreTranslateMessage method [MFC]
- MFC ActiveX controls [MFC], parameterized property
- ThrowError method [MFC]
ms.assetid: e9e34abb-8e2d-461e-bb9c-a1aec5dcecbd
ms.openlocfilehash: c5e3be3915a0707f8df17d3c9ebe2eb0e4f623b2
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81364629"
---
# <a name="mfc-activex-controls-advanced-topics"></a>Элементы управления ActiveX в MFC. Дополнительные разделы

В этой статье рассматриваются расширенные темы, связанные с разработкой элементов управления ActiveX. Сюда входит следующее.

- [Использование классов баз данных в элементах управления ActiveX](#_core_using_database_classes_in_activex_controls)

- [Реализация параметризированного свойства](#_core_implementing_a_parameterized_property)

- [Обработка ошибок в вашем управлении ActiveX](#_core_handling_errors_in_your_activex_control)

- [Обработка специальных ключей в управлении](#_core_handling_special_keys_in_your_control)

- [Доступ к элементам управления Dialog, которые невидимы во время выполнения](#_core_accessing_dialog_controls_that_are_invisible_at_run_time)

>[!IMPORTANT]
> ActiveX является устаревшей технологией, которая не должна использоваться для новых разработок. Для получения дополнительной информации о современных технологиях, которые заменяли ActiveX, [см.](activex-controls.md)

## <a name="using-database-classes-in-activex-controls"></a><a name="_core_using_database_classes_in_activex_controls"></a>Использование классов баз данных в элементах управления ActiveX

Поскольку классы управления ActiveX являются частью библиотеки классов, можно применить те же процедуры и правила для использования классов баз данных в стандартном приложении MFC для разработки элементов управления ActiveX, использующих классы баз данных MFC.

Для общего обзора классов баз данных [MFC Database Classes (DAO and ODBC)](../data/mfc-database-classes-odbc-and-dao.md)MFC см. В статье представлены как классы MFC ODBC, так и классы DAO MFC и вам предписывается более подробная информация о любом из них.

> [!NOTE]
> DAO поддерживается через Office 2013. DAO 3.6 является окончательной версией, и он считается устаревшим. Среда Visual C и мастера не поддерживают DAO (хотя классы DAO включены, и вы все еще можете использовать их). Корпорация Майкрософт рекомендует использовать [шаблоны OLE DB](../data/oledb/ole-db-programming.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только при обслуживании существующих приложений.

## <a name="implementing-a-parameterized-property"></a><a name="_core_implementing_a_parameterized_property"></a>Реализация параметризированного свойства

Параметризированное свойство (иногда называемое массивом свойств) — это метод разоблачения однородной коллекции значений в качестве единого свойства элемента управления. Например, можно использовать параметризированное свойство для того, чтобы предоставить массив или словарь в качестве свойства. В Visual Basic такое свойство доступно с помощью обозначения массива:

[!code-vb[NVC_MFC_AxVb#1](../mfc/codesnippet/visualbasic/mfc-activex-controls-advanced-topics_1.vb)]

Используйте «Мастер свойств добавления» для реализации параметризированного свойства. Мастер свойств добавления реализует свойство, добавляя пару функций Get/Set, которые позволяют пользователю управления получить доступ к свойству, используя вышеупомянутую нотацию или стандартным способом.

Как и методы и свойства, параметризированные свойства также имеют ограничение на количество допустимых параметров. В случае параметризированных свойств предел составляет 15 параметров (с одним параметром, зарезервированным для хранения значения свойства).

Следующая процедура добавляет параметризированное свойство, называемое Array, к которому можно получить доступ в виде двухмерного массива целых чипов.

#### <a name="to-add-a-parameterized-property-using-the-add-property-wizard"></a>Добавление параметризированного свойства с помощью мастера свойств добавления

1. Загрузите проект элемента управления.

1. В представлении класса разверните узел библиотеки элемента управления.

1. Щелкните правой кнопкой мыши узел интерфейса для элемента управления (второй узел узла библиотеки), чтобы открыть контекстное меню.

1. Из меню ярлыка, нажмите **Добавить,** а затем нажмите **Добавить свойство**.

1. В поле **имени** свойства `Array`введите .

1. В поле **Типа свойства** выберите **короткий**.

1. Для **типа реализации** нажмите **Кнопка Получить / Установить методы**.

1. В коробках **Get Function** и **Set Function** введите уникальные имена для функций Get and Set или примите имена по умолчанию.

1. Добавьте параметр, называемый *строкой* (тип *короткий),* используя элементы **управления именем параметра** и **тип параметра.**

1. Добавить второй параметр, называемый *столбец* (тип *короткий*).

1. Нажмите кнопку **Готово**.

### <a name="changes-made-by-the-add-property-wizard"></a>Изменения, внесенные мастером свойств Добавления

При добавлении пользовательского свойства мастер свойств Добавления вносит изменения в заголовок класса управления (. H) и реализации (. CPP) файлы.

Следующие строки добавляются в класс управления. H файл:

[!code-cpp[NVC_MFC_AxUI#35](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_2.h)]

Этот код объявляет две `GetArray` `SetArray` функции, которые позволяют пользователю запросить определенную строку и столбец при доступе к свойству.

Кроме того, Мастер свойств добавления добавляет следующие строки в карту диспетчерской диспетчерской управления, расположенную в реализации класса управления (. CPP) файл:

[!code-cpp[NVC_MFC_AxUI#36](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_3.cpp)]

Наконец, реализации `GetArray` и `SetArray` функции добавляются к концу . Файл CPP. В большинстве случаев вы измените функцию Get, чтобы вернуть стоимость свойства. Функция Set обычно содержит код, который должен выполняться до или после изменения свойства.

Чтобы это свойство было полезным, можно объявить двухмерную переменную элемента массива в классе управления, **краткое**для хранения значений для параметризированного свойства. Затем можно изменить функцию Get, чтобы вернуть значение, хранящееся в соответствующем ряду и столбце, как указано параметрами, и изменить функцию Set для обновления значения, на который ссылаются параметры строки и столбца.

## <a name="handling-errors-in-your-activex-control"></a><a name="_core_handling_errors_in_your_activex_control"></a>Обработка ошибок в вашем управлении ActiveX

При возникновении условий ошибки в элементе управления может потребоваться сообщить об ошибке в контейнер управления. Существует два метода отчетности об ошибках, в зависимости от ситуации, в которой происходит ошибка. Если ошибка возникает в функции Get или Set объекта или в рамках реализации метода АВТОМАТИЗАЦИи OLE, элемент управления должен вызывать [COleControl:: ThrowError](../mfc/reference/colecontrol-class.md#throwerror), который сигнализирует пользователю управления о том, что ошибка произошла. Если ошибка происходит в любое другое время, элемент управления должен позвонить [cOleControl::FireError](../mfc/reference/colecontrol-class.md#fireerror), который запускает событие ошибки в запасе.

Чтобы указать тип ошибки, которая произошла, элемент `ThrowError` `FireError`управления должен передать код ошибки или . Код ошибки — это код состояния OLE, который имеет 32-битное значение. Когда это возможно, выберите код ошибки из стандартного набора кодов, определенных в OLECTL. H файл заголовка. В следующей таблице обобщаются эти коды.

### <a name="activex-control-error-codes"></a>Коды ошибки управления ActiveX

|Error|Описание|
|-----------|-----------------|
|CTL_E_ILLEGALFUNCTIONCALL|Незаконный вызов функции|
|CTL_E_OVERFLOW|Переполнение|
|CTL_E_OUTOFMEMORY|Недостаточно памяти|
|CTL_E_DIVISIONBYZERO|Разделение на ноль|
|CTL_E_OUTOFSTRINGSPACE|Недостаточно места для строки|
|CTL_E_OUTOFSTACKSPACE|Недостаточно места для стека|
|CTL_E_BADFILENAMEORNUMBER|Недопустимое имя файла или номер|
|CTL_E_FILENOTFOUND|Файл не найден|
|CTL_E_BADFILEMODE|Недопустимый режим файла|
|CTL_E_FILEALREADYOPEN|Файл уже открыт|
|CTL_E_DEVICEIOERROR|Ошибка ввода-вывода устройства|
|CTL_E_FILEALREADYEXISTS|Файл уже существует|
|CTL_E_BADRECORDLENGTH|Недопустимая длина записи|
|CTL_E_DISKFULL|Диск полный|
|CTL_E_BADRECORDNUMBER|Неверный номер записи|
|CTL_E_BADFILENAME|Плохое имя файла|
|CTL_E_TOOMANYFILES|Слишком много файлов|
|CTL_E_DEVICEUNAVAILABLE|Устройство недоступно|
|CTL_E_PERMISSIONDENIED|В разрешении отказано|
|CTL_E_DISKNOTREADY|Диск не готов|
|CTL_E_PATHFILEACCESSERROR|Ошибка доступа пути/файла|
|CTL_E_PATHNOTFOUND|Путь не найден|
|CTL_E_INVALIDPATTERNSTRING|Недопустимая строка шаблона|
|CTL_E_INVALIDUSEOFNULL|Недействительное использование NULL|
|CTL_E_INVALIDFILEFORMAT|Недействительный формат файла|
|CTL_E_INVALIDPROPERTYVALUE|Недействительное значение свойства|
|CTL_E_INVALIDPROPERTYARRAYINDEX|Недействительный индекс массива свойств|
|CTL_E_SETNOTSUPPORTEDATRUNTIME|Установка не поддерживается во время выполнения|
|CTL_E_SETNOTSUPPORTED|Set не поддерживается (свойство доступно только для чтения)|
|CTL_E_NEEDPROPERTYARRAYINDEX|Требуется индекс массива свойства|
|CTL_E_SETNOTPERMITTED|Функция set запрещена|
|CTL_E_GETNOTSUPPORTEDATRUNTIME|Get не поддерживается во время выполнения|
|CTL_E_GETNOTSUPPORTED|Get не поддерживается (свойство доступно только для записи).|
|CTL_E_PROPERTYNOTFOUND|Свойство не найдено|
|CTL_E_INVALIDCLIPBOARDFORMAT|Недействительный формат буфера обмена|
|CTL_E_INVALIDPICTURE|Недействительное изображение|
|CTL_E_PRINTERERROR|Ошибка принтера|
|CTL_E_CANTSAVEFILETOTEMP|Не успокоив файл в TEMP|
|CTL_E_SEARCHTEXTNOTFOUND|Искомый текст не найден|
|CTL_E_REPLACEMENTSTOOLONG|Недопустимая длина замены|

При необходимости используйте CUSTOM_CTL_SCODE макрос для определения пользовательского кода ошибки для условия, которое не покрывается одним из стандартных кодов. Параметр для этого макроса должен быть бесчисленно между 1000 и 32767, включительно. Пример:

[!code-cpp[NVC_MFC_AxUI#37](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_4.cpp)]

Если вы создаете элемент управления ActiveX для замены существующего элемента управления VBX, определите коды ошибок управления ActiveX с теми же числовыми значениями, которые использует элемент управления VBX для обеспечения совместимости кодов ошибок.

## <a name="handling-special-keys-in-the-control"></a><a name="_core_handling_special_keys_in_your_control"></a>Обработка специальных ключей в управлении

В некоторых случаях вы можете обрабатывать определенные комбинации нажатия клавиш особым образом; например, вставьте новую строку, когда ключ ENTER нажат в многолинейном управлении текстовым полем или перемещайтесь между группой элементов управления при нажатии идентификатора направленного ключа.

Если базовый класс вашего `COleControl`управления ActiveX, вы можете переопределить [CWnd::PreTranslateMessage](../mfc/reference/cwnd-class.md#pretranslatemessage) для обработки сообщений, прежде чем контейнер обрабатывает их. При использовании этого метода, `PreTranslateMessage`всегда **вернуться правда,** если вы обрабатываете сообщение в переопределение .

Следующий пример кода демонстрирует возможный способ обработки любых сообщений, связанных с направленными ключами.

[!code-cpp[NVC_MFC_AxUI#38](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_5.cpp)]

Для получения дополнительной информации об обработке интерфейсов клавиатуры для управления ActiveX, см.

## <a name="accessing-dialog-controls-that-are-invisible-at-run-time"></a><a name="_core_accessing_dialog_controls_that_are_invisible_at_run_time"></a>Доступ к элементам управления Dialog, невидимым во время выполнения

Можно создать элементы управления диалогом, которые не имеют пользовательского интерфейса и невидимы во время выполнения. Если вы добавите невидимый во время выполнения управления ActiveX в диалоговую коробку и использовать [CWnd::GetDlgItem](../mfc/reference/cwnd-class.md#getdlgitem) для доступа к элементу управления, управление не будет работать правильно. Вместо этого следует использовать один из следующих методов для получения объекта, представляющего элемент управления:

- Используя переменный мастер-элемент Андрейт, выберите **переменную управления,** а затем выберите идентификатор элемента управления. Введите имя переменной элемента и выберите класс обертки элемента управления в качестве **типа управления.**

     -или-

- Объявить локальную переменную и подкласс в качестве элемента диалога. Вставьте код, который`CMyCtrl` напоминает следующее (это класс обертки, IDC_MYCTRL1 является идентификатором управления):

   [!code-cpp[NVC_MFC_AxCont#19](../mfc/codesnippet/cpp/mfc-activex-controls-advanced-topics_6.cpp)]

## <a name="see-also"></a>См. также раздел

[Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)
