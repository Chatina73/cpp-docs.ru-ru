---
title: Сокеты Windows. Порядок байтов
ms.date: 11/04/2016
helpviewer_keywords:
- byte order issues in sockets programming
- sockets [MFC], byte order issues
- Windows Sockets [MFC], byte order issues
ms.assetid: 8a787a65-f9f4-4002-a02f-ac25a5dace5d
ms.openlocfilehash: 50548202483c4d9d4471ad2c600270c4df4503e7
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81371068"
---
# <a name="windows-sockets-byte-ordering"></a>Сокеты Windows. Порядок байтов

В этой статье и двух сопутствующих статьях объясняется несколько проблем в программировании Windows Sockets. Эта статья охватывает заказ байта. Другие вопросы описаны в статьях: [Windows Sockets: Блокировка](../mfc/windows-sockets-blocking.md) и [Розетки Windows: Преобразование строк](../mfc/windows-sockets-converting-strings.md).

Если вы используете или вытекают из класса [CAsyncSocket](../mfc/reference/casyncsocket-class.md), вам нужно будет управлять этими вопросами самостоятельно. Если вы используете или вытекают из класса [CSocket,](../mfc/reference/csocket-class.md)MFC управляет ими для вас.

## <a name="byte-ordering"></a>Порядок байтов

Различные архитектуры машин иногда хранят данные с помощью различных заказов байт. Например, машины intel хранят данные в обратном порядке машин Macintosh (Motorola). Заказ байта Intel, называемый «маленьким-Endian», также является обратным сетевым стандартом «большого эндианского» заказа. В следующей таблице разъясняются эти термины.

### <a name="big--and-little-endian-byte-ordering"></a>Большой и мало-Эндиан Байт Заказ

|Порядок байтов|Значение|
|-------------------|-------------|
|Биг-Эндиан|Наиболее значительный байт находится на левом конце слова.|
|Литл-Эндиан|Наиболее значительный байт находится на правом конце слова.|

Как правило, вам не придется беспокоиться о конверсии байт-заказа для данных, которые вы отправляете и получаете по сети, но есть ситуации, в которых необходимо конвертировать заказы байт.

## <a name="when-you-must-convert-byte-orders"></a>Когда вы должны конвертировать Заказы Байт

Вы должны конвертировать заказы байт в следующих ситуациях:

- Вы передаете информацию, которая должна быть интерпретирована сетью, в отличие от данных, которые вы отправляете на другую машину. Например, можно пройти порты и адреса, которые должна понимать сеть.

- Серверное приложение, с которым вы общаетесь, не является приложением MFC (и у вас нет исходного кода для него). Это требует конверсии заказов байт, если две машины не разделяют один и тот же заказ байт.

## <a name="when-you-do-not-have-to-convert-byte-orders"></a>Когда вам не нужно конвертировать заказы Байт

Вы можете избежать работы по преобразованию заказов байт в следующих ситуациях:

- Машины на обоих концах могут согласиться не менять байты, и обе машины используют один и тот же заказ байтов.

- Сервер, с помощью которого вы общаетесь, является приложением MFC.

- У вас есть исходный код для сервера, с которым вы общаетесь, так что вы можете прямо сказать, нужно ли конвертировать заказы байт или нет.

- Вы можете портировать сервер в MFC. Это довольно легко сделать, и результат, как правило, меньше, быстрее код.

Работая с [CAsyncSocket,](../mfc/reference/casyncsocket-class.md)вы должны управлять любыми необходимыми преобразованиями заказа байт самостоятельно. Windows Sockets стандартизирует модель байт-заказа "большой конец" и предоставляет функции для преобразования между этим заказом и другими. [CArchive](../mfc/reference/carchive-class.md), однако, который вы используете с [CSocket](../mfc/reference/csocket-class.md), использует `CArchive` противоположный ("маленький-Endian") порядок, но заботится о деталях байт-заказ конверсий для вас. Используя этот стандартный заказ в приложениях или используя функции преобразования Windows Sockets байт-заказа, вы можете сделать свой код более портативным.

Идеальный случай для использования разъемов MFC, когда вы пишете оба конца сообщения: с помощью MFC на обоих концах. Если вы пишете приложение, которое будет общаться с не-MFC приложений, таких как ftP-сервер, вы, вероятно, необходимо управлять байт-замена себя, прежде чем передавать данные на объект архива, используя Windows Sockets преобразования процедур **ntohs**, **ntohl**, **htons**, и **htonl**. Пример этих функций, используемых при общении с приложением, не входящих в МФЦ, появляется позже в этой статье.

> [!NOTE]
> Если другой конец сообщения не является приложением MFC, необходимо также избегать `CObject` потоковой передачи объектов C,', полученных из вашего архива, поскольку получатель не сможет с ними справиться. Смотрите заметку в [windows Sockets: Использование розеток с архивами](../mfc/windows-sockets-using-sockets-with-archives.md).

Для получения дополнительной информации о заказах байт см.

## <a name="a-byte-order-conversion-example"></a>Пример преобразования Байт-Ордера

В следующем примере показана `CSocket` функция сериализации для объекта, использующему архив. Он также иллюстрирует использование функций преобразования байт-заказа в API Sockets Windows.

В этом примере представлен сценарий, в котором вы пишете клиента, который общается с серверным приложением, не относящимся к MFC, для которого у вас нет доступа к исходному коду. В этом случае следует предположить, что сервер, не являющиеся MFC, использует стандартный заказ на байт сети. В отличие от этого, ваше `CArchive` клиентское `CSocket` приложение `CArchive` MFC использует объект с объектом и использует "маленький эндиан" байтов, противоположный сетевому стандарту.

Предположим, что сервер, не относявшийся к MFC, с которым вы планируете общаться, имеет установленный протокол для пакета сообщений, как:

[!code-cpp[NVC_MFCSimpleSocket#5](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_1.cpp)]

С точки зрения МФЦ это будет выражено следующим образом:

[!code-cpp[NVC_MFCSimpleSocket#6](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_2.cpp)]

В СЗ **структурка** по сути является тем же самым, что и класс. Структура `Message` может иметь функции члена, такие как функция `Serialize` члена, объявленная выше. Функция `Serialize` участника может выглядеть следующим образом:

[!code-cpp[NVC_MFCSimpleSocket#7](../mfc/codesnippet/cpp/windows-sockets-byte-ordering_3.cpp)]

Этот пример требует конверсии данных по принципу байт-заказа, поскольку существует явное несоответствие между `CArchive` заказом сервера сервера, не относящейся к MFC, на одном конце и используемым в клиентском приложении MFC на другом конце. Пример иллюстрирует несколько функций преобразования заказа байт, которые поставляет Windows Sockets. В следующей таблице описаны эти функции.

### <a name="windows-sockets-byte-order-conversion-functions"></a>Функции преобразования Оконных разрознетов Byte-Order

|Компонент|Цель|
|--------------|-------------|
|**ntohs**|Преобразуйте 16-битное количество из сетевого заказа байт для размещения заказа байта (big-Endian в мало-Endian).|
|**ntohl**|Преобразуйте 32-битное количество из сетевого заказа байт для размещения заказа байта (big-Endian в мало-Endian).|
|**Хтонс**|Преобразуйте 16-битное количество из заказа хоста байт в сетевой заказ байт (маленький эндиан в big-Endian).|
|**Хтонл**|Преобразуйте 32-битное количество из заказа хоста байт в сетевой заказ байт (маленький конец в big-Endian).|

Другой момент этого примера заключается в том, что, когда приложение розетки на другом конце сообщения является приложением, не являешься МФЦ, вы должны избегать выполнения чего-то вроде следующего:

`ar << pMsg;`

где `pMsg` указатель на объект СЗ, полученный `CObject`из класса. Это будет отправлять дополнительную информацию MFC, связанную с объектами, и сервер не поймет ее, как если бы это было приложение MFC.

Дополнительные сведения см. в разделе:

- [Сокеты Windows. Использование класса CAsyncSocket](../mfc/windows-sockets-using-class-casyncsocket.md)

- [Сокеты Windows. Фон](../mfc/windows-sockets-background.md)

- [Сокеты Windows. Сокеты потоков](../mfc/windows-sockets-stream-sockets.md)

- [Сокеты Windows. Сокеты датаграмм](../mfc/windows-sockets-datagram-sockets.md)

## <a name="see-also"></a>См. также раздел

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)
