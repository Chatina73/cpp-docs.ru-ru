---
title: TN053. Пользовательские процедуры DFX для классов баз данных DAO
ms.date: 09/17/2019
helpviewer_keywords:
- MFC, DAO and
- database classes [MFC], DAO
- DAO [MFC], MFC
- DFX (DAO record field exchange) [MFC], custom routines
- TN053
- DAO [MFC], classes
- DFX (DAO record field exchange) [MFC]
- custom DFX routines [MFC]
ms.assetid: fdcf3c51-4fa8-4517-9222-58aaa4f25cac
ms.openlocfilehash: 6dde96520d9472726da86f8da295770cccc5d42c
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303437"
---
# <a name="tn053-custom-dfx-routines-for-dao-database-classes"></a>TN053. Пользовательские процедуры DFX для классов баз данных DAO

> [!NOTE]
>  DAO используется с базами данных Access и поддерживается в Office 2013. Версия DAO 3,6 является окончательной и считается устаревшей. Визуальная C++ среда и мастера не поддерживают DAO (хотя классы DAO включены и их все еще можно использовать). Корпорация Майкрософт рекомендует использовать [шаблоны OLE DB](../data/oledb/ole-db-templates.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только для поддержки существующих приложений.

В этом техническом примечании описывается механизм обмена полями записей DAO (DFX). Чтобы понять, что происходит в процедурах DFX, в качестве примера подробно рассматривается функция `DFX_Text`. В качестве дополнительного источника информации для этой технической заметки можно изучить код для других отдельных функций DFX. Вам, вероятно, не придется использовать настраиваемую подпрограммы DFX, как часто, так как может потребоваться пользовательская подпрограммы RFX (используется с классами базы данных ODBC).

Это техническое примечание содержит:

- Общие сведения о DFX

- [Примеры](#_mfcnotes_tn053_examples) использования обмена ПОЛЯМИ записей DAO и динамической привязки

- [Как работает DFX](#_mfcnotes_tn053_how_dfx_works)

- [Что делает настраиваемый метод DFX](#_mfcnotes_tn053_what_your_custom_dfx_routine_does)

- [Сведения о DFX_Text](#_mfcnotes_tn053_details_of_dfx_text)

**Общие сведения о DFX**

Механизм обмена полями записей DAO (DFX) используется для упрощения процедуры извлечения и обновления данных при использовании класса `CDaoRecordset`. Процесс упрощен с помощью элементов данных класса `CDaoRecordset`. Производные от `CDaoRecordset`, можно добавлять элементы данных в производный класс, представляющий каждое поле в таблице или запросе. Этот механизм "статической привязки" прост, но он может не быть выбранным методом выборки и обновления данных для всех приложений. DFX извлекает каждое привязанное поле при каждом изменении текущей записи. При разработке приложения с учетом производительности, которое не требует выборки каждого поля при изменении валюты, "Динамическая привязка" через `CDaoRecordset::GetFieldValue` и `CDaoRecordset::SetFieldValue` может быть выбранным методом доступа к данным.

> [!NOTE]
>  DFX и динамическая привязка не являются взаимоисключающими, поэтому можно использовать гибридное использование статической и динамической привязки.

## <a name="_mfcnotes_tn053_examples"></a>Пример 1. использование только обмена полями записей DAO

(предполагается `CDaoRecordset` — производный класс `CMySet` уже открыт)

```
// Add a new record to the customers table
myset.AddNew();

myset.m_strCustID = _T("MSFT");

myset.m_strCustName = _T("Microsoft");

myset.Update();
```

**Пример 2 — Использование динамической привязки**

(предполагается использование класса `CDaoRecordset`, `rs`, и он уже открыт)

```
// Add a new record to the customers table
COleVariant  varFieldValue1 (_T("MSFT"),
    VT_BSTRT);

//Note: VT_BSTRT flags string type as ANSI,
    instead of UNICODE default
COleVariant  varFieldValue2  (_T("Microsoft"),
    VT_BSTRT);

rs.AddNew();

rs.SetFieldValue(_T("Customer_ID"),
    varFieldValue1);

rs.SetFieldValue(_T("Customer_Name"),
    varFieldValue2);

rs.Update();
```

**Пример 3. использование обмена полями записей DAO и динамической привязки**

(предполагает Просмотр данных о сотрудниках с помощью класса, производного от `CDaoRecordset``emp`)

```
// Get the employee's data so that it can be displayed
emp.MoveNext();

// If user wants to see employee's photograph,
// fetch it
COleVariant varPhoto;
if (bSeePicture)
    emp.GetFieldValue(_T("photo"),
    varPhoto);

// Display the data
PopUpEmployeeData(emp.m_strFirstName,
    emp.m_strLastName,
    varPhoto);
```

## <a name="_mfcnotes_tn053_how_dfx_works"></a>Как работает DFX

Механизм DFX работает аналогично механизму обмена полями записей (RFX), используемому классами ODBC MFC. Принципы DFX и RFX одинаковы, но существует множество внутренних различий. Структура функций DFX была таким, что практически весь код совместно используется отдельными подпрограммами DFX. На самом верхнем уровне DFX всего лишь несколько вещей.

- DFX при необходимости конструирует предложение SQL **SELECT** и предложение **Parameters** SQL.

- DFX конструирует структуру привязки, используемую функцией `GetRows` DAO (Подробнее об этом чуть позже).

- DFX управляет буфером данных, используемым для обнаружения «грязных» полей (если используется двойная буферизация).

- DFX управляет массивами состояния **null** и **Dirty** и задает значения при необходимости в обновлениях.

В сердце механизма DFX используется функция `DoFieldExchange` производного класса `CDaoRecordset`. Эта функция передает вызовы отдельным функциям DFX соответствующего типа операции. Перед вызовом `DoFieldExchange` внутренние функции MFC устанавливают тип операции. В следующем списке приведены различные типы операций и краткое описание.

|Операция|Описание|
|---------------|-----------------|
|`AddToParameterList`|Предложение параметров сборки|
|`AddToSelectList`|Предложение SELECT для сборок|
|`BindField`|Настройка структуры привязки|
|`BindParam`|Задает значения параметров|
|`Fixup`|Задает состояние NULL|
|`AllocCache`|Выделяет кэш для проверки "грязных"|
|`StoreField`|Сохраняет текущую запись в кэш|
|`LoadField`|Восстанавливает значения элементов кэша|
|`FreeCache`|Освобождение кэша|
|`SetFieldNull`|Задает для поля состояние & значение NULL|
|`MarkForAddNew`|Помечает поля как "грязные", если не является псевдо|
|`MarkForEdit`|Помечает поля как "грязные", если не учитывать кэш|
|`SetDirtyField`|Задает значения полей, помеченные как "грязные"|

В следующем разделе каждая операция будет объяснена более подробно для `DFX_Text`.

Самая важная особенность процесса обмена полями записей DAO заключается в том, что он использует функцию `GetRows` объекта `CDaoRecordset`. Функция DAO `GetRows` может работать несколькими способами. Это техническое примечание кратко описывает `GetRows`, так как оно выходит за рамки этой технической заметки.
`GetRows` DAO может работать несколькими способами.

- Он может одновременно получить несколько записей и несколько полей данных. Это обеспечивает более быстрый доступ к данным с усложнением работы с большой структурой данных и соответствующими смещениями для каждого поля и для каждой записи данных в структуре. MFC не использует этот механизм выборки нескольких записей.

- Другой способ `GetRows` может работать, чтобы позволить программистам указывать адреса привязки для извлеченных данных каждого поля для одной записи данных.

- DAO также будет "вызывать обратную передачу" в вызывающий столбец для столбцов переменной длины, чтобы позволить вызывающему объекту выделить память. Эта вторая функция имеет преимущество свести к минимуму количество копий данных, а также возможность прямого хранения данных в членах класса (`CDaoRecordset` производном классе). Второй механизм — это метод, используемый MFC для привязки к элементам данных в `CDaoRecordset` производных классах.

##  <a name="_mfcnotes_tn053_what_your_custom_dfx_routine_does"></a>Что делает настраиваемый метод DFX

Это очевидно из этого рассказа о том, что наиболее важной операцией, реализованной в любой функции DFX, должна быть возможность настройки необходимых структур данных для успешного вызова `GetRows`. Существует ряд других операций, которые не должны поддерживаться функцией DFX, но не так важны и не сложны, как правильная подготовка к вызову `GetRows`.

Использование параметра DFX описано в интерактивной документации. По сути, существует два требования. Во – первых, члены должны быть добавлены в `CDaoRecordset` производный класс для каждого привязанного поля и параметра. После этого `CDaoRecordset::DoFieldExchange` следует переопределить. Обратите внимание, что тип данных элемента важен. Он должен соответствовать данным из поля базы данных или как минимум преобразованным в этот тип. Например, числовое поле в базе данных, например длинное целое число, всегда может быть преобразовано в текст и привязано к `CString` элементу, но текстовое поле в базе данных может быть необязательно преобразовано в числовое представление, например длинное целое и которое привязано к длинному целому элементу. DAO и ядро СУБД Microsoft Jet отвечают за преобразование (а не MFC).

##  <a name="_mfcnotes_tn053_details_of_dfx_text"></a>Сведения о DFX_Text

Как упоминалось ранее, лучшим способом объяснить, как работает DFX, является работа с примером. Для этой цели все внутренние компоненты `DFX_Text` должны хорошо работать, чтобы обеспечить как минимум базовое понимание DFX.

- `AddToParameterList`

   Эта операция создает предложение **параметров** SQL ("`Parameters <param name>, <param type> ... ;`"), необходимое для Jet. Каждый параметр назван и типизирован (как указано в вызове RFX). Сведения об именах отдельных типов см. в описании функции `CDaoFieldExchange::AppendParamType` функции. В случае `DFX_Text`используется тип **Text**.

- `AddToSelectList`

   Создает предложение SQL **SELECT** . Это довольно просто, так как имя столбца, заданное с помощью метода DFX, является простым добавлением ("`SELECT <column name>, ...`").

- `BindField`

   Наиболее сложная операция. Как упоминалось ранее, структура привязки DAO, используемая `GetRows`, настроена. Как видно из кода в `DFX_Text` типы информации в структуре включают используемый тип DAO (**DAO_CHAR** или **DAO_WCHAR** в случае `DFX_Text`). Кроме того, также настраивается используемый тип привязки. В предыдущем разделе `GetRows` была описана только вкратце, но было достаточно объяснить, что тип привязки, используемый MFC, всегда является привязкой прямого адреса (**DAOBINDING_DIRECT**). Кроме привязки к столбцу переменной длины (например, `DFX_Text`) используется привязка обратного вызова, чтобы MFC мог управлять выделением памяти и указать адрес правильной длины. Это означает, что MFC всегда может сообщить DAO "Where", чтобы разместить данные, таким образом допуская привязку непосредственно к переменным-членам. Остальная часть структуры привязки заполняется такими же, как адрес функции обратного вызова выделения памяти и типа привязки столбца (привязка по имени столбца).

- `BindParam`

   Это простая операция, которая вызывает `SetParamValue` со значением параметра, указанным в члене параметра.

- `Fixup`

   Заполняет состояние **null** для каждого поля.

- `SetFieldNull`

   Эта операция помечает состояние каждого поля как **null** и задает для переменной члена значение **PSEUDO_NULL**.

- `SetDirtyField`

   Вызывает `SetFieldValue` для каждого поля, помеченного как "грязное".

Все остальные операции работают только с использованием кэша данных. Кэш данных — это дополнительный буфер данных в текущей записи, который используется для упрощения определенных задач. Например, поля "грязные" могут быть автоматически обнаружены. Как описано в интерактивной документации, ее можно полностью отключить или на уровне полей. Реализация буфера использует карту. Эта схема используется для сопоставления динамически выделяемых копий данных с адресом "привязанного" поля (или `CDaoRecordset` производным членом данных).

- `AllocCache`

   Динамически выделяет значение кэшированного поля и добавляет его в карту.

- `FreeCache`

   Удаляет значение кэшированного поля и удаляет его из схемы.

- `StoreField`

   Копирует текущее значение поля в кэш данных.

- `LoadField`

   Копирует кэшированное значение в элемент Field.

- `MarkForAddNew`

   Проверяет, имеет ли текущее значение поля, отличное от**null** , и помечает его как "грязное" при необходимости.

- `MarkForEdit`

   Сравнивает значение текущего поля с кэшем данных и помечает «грязный» при необходимости.

> [!TIP]
> Моделирование пользовательских подпрограмм DFX для существующих подпрограмм с DFX для стандартных типов данных.

## <a name="see-also"></a>См. также:

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
