---
title: TN053. Пользовательские процедуры DFX для классов баз данных DAO
ms.date: 09/17/2019
helpviewer_keywords:
- MFC, DAO and
- database classes [MFC], DAO
- DAO [MFC], MFC
- DFX (DAO record field exchange) [MFC], custom routines
- TN053
- DAO [MFC], classes
- DFX (DAO record field exchange) [MFC]
- custom DFX routines [MFC]
ms.assetid: fdcf3c51-4fa8-4517-9222-58aaa4f25cac
ms.openlocfilehash: f7ad854f4dbb4e90c09e886c69260e4e2eea3be2
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365265"
---
# <a name="tn053-custom-dfx-routines-for-dao-database-classes"></a>TN053. Пользовательские процедуры DFX для классов баз данных DAO

> [!NOTE]
> DAO используется с базами данных Access и поддерживается в Office 2013. DAO 3.6 является окончательной версией, и он считается устаревшим. Среда Visual C и мастера не поддерживают DAO (хотя классы DAO включены, и вы все еще можете использовать их). Корпорация Майкрософт рекомендует использовать [шаблоны OLE DB](../data/oledb/ole-db-templates.md) или [ODBC и MFC](../data/odbc/odbc-and-mfc.md) для новых проектов. DAO следует использовать только при обслуживании существующих приложений.

В этой технической записке описывается механизм обмена полями записей DAO (DFX). Чтобы помочь понять, что происходит в `DFX_Text` dFX процедур, функция будет объяснена подробно в качестве примера. В качестве дополнительного источника информации к этой технической заметке вы можете изучить код для других отдельных функций DFX. Вам, вероятно, не понадобится пользовательский режим DFX так часто, как вам может понадобиться пользовательский rfX рутины (используется с ODBC классов базы данных).

Эта техническая записка содержит:

- Обзор DFX

- [Примеры](#_mfcnotes_tn053_examples) использования DAO Record Field Exchange и динамической связывания

- [Как работает DFX](#_mfcnotes_tn053_how_dfx_works)

- [Что ваш пользовательский DFX Рутина делает](#_mfcnotes_tn053_what_your_custom_dfx_routine_does)

- [Подробности DFX_Text](#_mfcnotes_tn053_details_of_dfx_text)

**Обзор DFX**

Механизм обмена полями записи DAO (DFX) используется для упрощения процедуры `CDaoRecordset` извлечения и обновления данных при использовании класса. Процесс упрощается с использованием `CDaoRecordset` данных членов класса. Извлекая из `CDaoRecordset`этого, можно добавить члены данных в производный класс, представляющий каждое поле в таблице или запросе. Этот механизм "статического связывания" прост, но он не может быть методом получения/обновления данных по выбору для всех приложений. DFX получает каждое связанное поле каждый раз, когда изменяется текущая запись. Если вы разрабатываете приложение, чувствительное к производительности, которое не требует `CDaoRecordset::GetFieldValue` извлечения каждого поля при изменении валюты, "динамическая привязка" через и `CDaoRecordset::SetFieldValue` может быть методом доступа к данным выбора.

> [!NOTE]
> DFX и динамическая привязка не являются взаимоисключающими, поэтому можно использовать гибридное использование статического и динамического связывания.

## <a name="example-1--use-of-dao-record-field-exchange-only"></a><a name="_mfcnotes_tn053_examples"></a>Пример 1 - Использование только биржи записи DAO Record Field Exchange

(предполагает `CDaoRecordset` - производный класс `CMySet` уже открыт)

```
// Add a new record to the customers table
myset.AddNew();

myset.m_strCustID = _T("MSFT");

myset.m_strCustName = _T("Microsoft");

myset.Update();
```

**Пример 2 - Использование только динамической связывания**

(предполагает использование `CDaoRecordset` класса, `rs`и он уже открыт)

```
// Add a new record to the customers table
COleVariant  varFieldValue1 (_T("MSFT"),
    VT_BSTRT);

//Note: VT_BSTRT flags string type as ANSI,
    instead of UNICODE default
COleVariant  varFieldValue2  (_T("Microsoft"),
    VT_BSTRT);

rs.AddNew();

rs.SetFieldValue(_T("Customer_ID"),
    varFieldValue1);

rs.SetFieldValue(_T("Customer_Name"),
    varFieldValue2);

rs.Update();
```

**Пример 3 - Использование биржи поля записи DAO и динамического связывания**

(предполагает просмотр данных `CDaoRecordset`о сотрудниках с -выведенным классом) `emp`

```
// Get the employee's data so that it can be displayed
emp.MoveNext();

// If user wants to see employee's photograph,
// fetch it
COleVariant varPhoto;
if (bSeePicture)
    emp.GetFieldValue(_T("photo"),
    varPhoto);

// Display the data
PopUpEmployeeData(emp.m_strFirstName,
    emp.m_strLastName,
    varPhoto);
```

## <a name="how-dfx-works"></a><a name="_mfcnotes_tn053_how_dfx_works"></a>Как работает DFX

Механизм DFX работает по аналогии с механизмом обмена рекордными полями (RFX), используемым классами MFC ODBC. Принципы DFX и RFX одинаковы, но есть многочисленные внутренние различия. Конструкция функций DFX была такова, что практически весь код используется отдельными процедурами DFX. На самом высоком уровне DFX делает только несколько вещей.

- DFX при необходимости конструирует положение S'L **SELECT** и пункт «СЗЛ **ПАРАТТЕРС».**

- DFX строит связывающую структуру, используемую `GetRows` функцией DAO (подробнее об этом позже).

- DFX управляет буфером данных, используемым для обнаружения грязных полей (если используется двойное буферизация)

- DFX управляет массивами статусов **NULL** и **DIRTY** и при необходимости устанавливает значения в обновлениях.

В основе механизма DFX лежит `CDaoRecordset` `DoFieldExchange` функция производного класса. Эта функция отправляет вызовы на отдельные функции DFX соответствующего типа операции. Перед `DoFieldExchange` вызовом внутренних функций MFC установите тип операции. В следующем списке показаны различные типы операций и краткое описание.

|Операция|Описание|
|---------------|-----------------|
|`AddToParameterList`|Строит пункт PARAMETERS|
|`AddToSelectList`|Строит пункт SELECT|
|`BindField`|Настройка связывающей структуры|
|`BindParam`|Устанавливает значения параметров|
|`Fixup`|Устанавливает статус NULL|
|`AllocCache`|Выделяет кэш для грязной проверки|
|`StoreField`|Сохраняет текущую запись для кэша|
|`LoadField`|Восстановление кэша в значениях членов|
|`FreeCache`|Бесплатный кэш|
|`SetFieldNull`|Устанавливает статус поля & значение null|
|`MarkForAddNew`|Отметки поля грязные, если не PSEUDO NULL|
|`MarkForEdit`|Отметки поля грязные, если не совпадают с кэшом|
|`SetDirtyField`|Устанавливает значения полей, помеченные как грязные|

В следующем разделе, каждая операция будет `DFX_Text`объяснена более подробно для .

Наиболее важной особенностью для понимания процесса обмена полями `GetRows` записи `CDaoRecordset` DAO является то, что он использует функцию объекта. Функция DAO `GetRows` может работать несколькими способами. В настоящем техническом примечании будет лишь кратко описано, `GetRows` поскольку оно выходит за рамки настоящей технической записки.
DAO `GetRows` может работать несколькими способами.

- Он может получать несколько записей и несколько полей данных одновременно. Это обеспечивает более быстрый доступ к данным с осложнением работы с большой структурой данных и соответствующими компенсациями для каждой области и для каждой записи данных в структуре. MFC не использует этот многократный механизм извлечения записей.

- Другой `GetRows` способ работы заключается в том, чтобы позволить программистам указать обязательные адреса для извлеченных данных каждого поля для одной записи данных.

- DAO также "перезвонит" в вызыватель для столбцов переменной длины, чтобы позволить вызывающему выделить память. Эта вторая функция имеет преимущество минимизации количества копий данных, а также позволяет прямое `CDaoRecordset` хранение данных в членах класса (производный класс). Этот второй механизм является методом MFC использует `CDaoRecordset` для привязки к членам данных в полученных классах.

## <a name="what-your-custom-dfx-routine-does"></a><a name="_mfcnotes_tn053_what_your_custom_dfx_routine_does"></a>Что ваш пользовательский DFX Рутина делает

Из этого обсуждения видно, что наиболее важной операцией, реализованной в любой функции DFX, должна быть возможность настройки необходимых структур данных для успешного вызова. `GetRows` Есть ряд других операций, которые функция DFX должна поддерживать также, но ни одна `GetRows` из них не является важной или сложной, чем правильная подготовка к вызову.

Использование DFX описано в онлайн-документации. По сути, есть два требования. Во-первых, участники `CDaoRecordset` должны быть добавлены к производному классу для каждого связанного поля и параметра. После `CDaoRecordset::DoFieldExchange` этого должны быть отменены. Обратите внимание, что тип данных участника имеет важное значение. Он должен соответствовать данным с поля в базе данных или, по крайней мере, конвертироваться в этот тип. Например, числовое поле в базе данных, например, длинное целый `CString` ряд, всегда может быть преобразовано в текст и привязано к члену, но текстовое поле в базе данных не обязательно может быть преобразовано в числовое представление, такое как длинное целых число и связанное с длинным целым членом. DAO и движок базы данных Microsoft Jet отвечают за конверсию (а не MFC).

## <a name="details-of-dfx_text"></a><a name="_mfcnotes_tn053_details_of_dfx_text"></a>Подробности DFX_Text

Как упоминалось ранее, лучший способ объяснить, как работает DFX, это работать на примере. Для этой цели происходит через `DFX_Text` внутренности должны работать достаточно хорошо, чтобы помочь обеспечить по крайней мере базовое понимание DFX.

- `AddToParameterList`

   Эта операция создает положение S'L`Parameters <param name>, <param type> ... ;` **PARAMETERS** (""), требуемое Jet. Каждый параметр назван и набран (как указано в вызове RFX). Просмотрите `CDaoFieldExchange::AppendParamType` функцию функции, чтобы увидеть имена отдельных типов. В случае, `DFX_Text`используемый тип **является текстом.**

- `AddToSelectList`

   Создает положение S'L **SELECT.** Это довольно прямо вперед, как название столбца, указанное вызовом DFX просто приобщено ("").`SELECT <column name>, ...`

- `BindField`

   Самый сложный из операций. Как упоминалось ранее, здесь устанавливается привязывающая `GetRows` структура DAO. Как вы можете видеть `DFX_Text` из кода в типах информации в структуре включают тип DAO используется **(DAO_CHAR** или **DAO_WCHAR** в случае `DFX_Text`). Кроме того, также настраивается тип привязки. В предыдущем `GetRows` разделе было описано лишь кратко, но было достаточно объяснить, что тип связывания, используемый МФЦ, всегда является прямым связыванием адреса **(DAOBINDING_DIRECT).** Кроме того, используется привязка `DFX_Text`столбца с переменной длиной (например, привязка к обратным вызовам, так что MFC может контролировать распределение памяти и указывать адрес правильной длины. Это означает, что MFC всегда может сказать DAO "где" разместить данные, тем самым позволяя связывать сявок непосредственно переменным членов. Остальная часть связывающей структуры заполнена такими вещами, как адрес функции обратного вызова распределения памяти и тип связывания столбца (связывание по имени столбца).

- `BindParam`

   Это простая операция, `SetParamValue` которая вызывает с значением параметра, указанным в вашем параметре.

- `Fixup`

   Заполняет статус **NULL** для каждого поля.

- `SetFieldNull`

   Эта операция только помечает статус каждого поля как **NULL** и устанавливает значение переменной участника для **PSEUDO_NULL.**

- `SetDirtyField`

   Звонки `SetFieldValue` для каждого поля помечены грязными.

Все остальные операции касаются только использования кэша данных. Кэш данных — это дополнительный буфер данных в текущей записи, который используется для упрощения некоторых вещей. Например, "грязные" поля могут быть автоматически обнаружены. Как описано в онлайн-документации, его можно полностью отключить или на уровне поля. Реализация буфера использует карту. Эта карта используется для сопоставления динамически распределенных копий данных с `CDaoRecordset` адресом "связанного" поля (или производных данных).

- `AllocCache`

   Динамически распределяет значение кэшированного поля и добавляет его к карте.

- `FreeCache`

   Удаляет значение кэшированного поля и удаляет его с карты.

- `StoreField`

   Копирует текущее значение поля в кэш данных.

- `LoadField`

   Копирует кэшированное значение в полевой член.

- `MarkForAddNew`

   Проверяет, не является ли текущее значение поля**НЕдействительном,** и при необходимости маркирует его грязным.

- `MarkForEdit`

   Сравнивает текущее значение поля с кэшем данных и при необходимости маркирует сядки.

> [!TIP]
> Смоделируйте пользовательские процедуры DFX в существующих режимах DFX для стандартных типов данных.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
