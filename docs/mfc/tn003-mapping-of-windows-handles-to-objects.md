---
description: 'Дополнительные сведения о: TN003: Сопоставление дескрипторов Windows с объектами'
title: TN003. Сопоставление дескрипторов Windows с объектами
ms.date: 11/04/2016
f1_keywords:
- vc.mapping
helpviewer_keywords:
- TN003
- handle maps
- Windows handles to objects [MFC]
- mappings [MFC], Windows handles to objects
ms.assetid: fbea9f38-992c-4091-8dbc-f29e288617d6
ms.openlocfilehash: e4a0bfa2315ec2b9d67d884d4fdebe314599f454
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97216045"
---
# <a name="tn003-mapping-of-windows-handles-to-objects"></a>TN003. Сопоставление дескрипторов Windows с объектами

Это примечание описывает подпрограммы MFC, которые поддерживают сопоставление дескрипторов объектов Windows с объектами C++.

## <a name="the-problem"></a>Проблема

Объекты Windows обычно представлены различными объектами [обработки](/windows/win32/WinProg/windows-data-types) , которые классы MFC заключают в оболочку объектов Windows с объектами C++. Функции упаковки в оболочке библиотеки классов MFC позволяют найти объект C++, который является оболочкой для объекта Windows с определенным маркером. Однако иногда у объекта нет объекта-оболочки C++, и в это время система создает временный объект, который будет использоваться в качестве оболочки C++.

Объекты Windows, использующие карты Handle, выглядят следующим образом:

- HWND (классы[CWnd](../mfc/reference/cwnd-class.md) и `CWnd` -Derived)

- HDC ([](../mfc/reference/cdc-class.md) классы, `CDC` производные от CDC и-Derived)

- HMENU ([кмену](../mfc/reference/cmenu-class.md))

- ХПЕН ([кгдиобжект](../mfc/reference/cgdiobject-class.md))

- ХБРУШ ( `CGdiObject` )

- ХФОНТ ( `CGdiObject` )

- ХБИТМАП ( `CGdiObject` )

- ХПАЛЕТТЕ ( `CGdiObject` )

- ХРГН ( `CGdiObject` )

- ХИМАЖЕЛИСТ ([CImageList](../mfc/reference/cimagelist-class.md))

- СОКЕТ ([CSocket](../mfc/reference/csocket-class.md))

При наличии маркера для любого из этих объектов можно найти объект MFC, который упаковывает маркер, вызвав статический метод `FromHandle` . Например, при наличии HWND с именем *HWND* Следующая строка вернет указатель на объект `CWnd` , который упаковывает *HWND*:

```
CWnd::FromHandle(hWnd)
```

Если *HWND* не имеет определенного объекта-оболочки, создается временный объект `CWnd` для оболочки *HWND*. Это дает возможность получить допустимый объект C++ из любого маркера.

После создания объекта-оболочки его обработчик можно получить из общей переменной-члена класса-оболочки. В случае `CWnd` *M_HWND* содержит HWND для этого объекта.

## <a name="attaching-handles-to-mfc-objects"></a>Присоединение дескрипторов к объектам MFC

При наличии вновь созданного объекта-оболочки Handle и обработчика для объекта Windows можно связать эти два метода, вызвав `Attach` функцию, как в следующем примере:

```
CWnd myWnd;
myWnd.Attach(hWnd);
```

Это делает запись в постоянной карте, связывающую *мивнд* и *HWND*. `CWnd::FromHandle(hWnd)`Теперь вызов вернет указатель на *мивнд*. При удалении *мивнд* деструктор автоматически уничтожает *HWND* , вызывая функцию Windows [дестройвиндов](/windows/win32/api/winuser/nf-winuser-destroywindow) . Если это не требуется, *HWND* необходимо отсоединить от *мивнд* перед уничтожением *мивнд* (обычно при сохранении области, в которой определен *мивнд* ). `Detach`Метод делает это.

```
myWnd.Detach();
```

## <a name="more-about-temporary-objects"></a>Дополнительные сведения о временных объектах

Временные объекты создаются каждый раз, когда `FromHandle` ему присваивается обработчик, который еще не имеет объекта-оболочки. Эти временные объекты отсоединяются от своего обработчика и удаляются `DeleteTempMap` функциями. По умолчанию метод [CWinThread:: OnIdle](../mfc/reference/cwinthread-class.md#onidle) автоматически вызывает `DeleteTempMap` для каждого класса, поддерживающего карты временных маркеров. Это означает, что нельзя предположить, что указатель на временный объект будет действителен после точки выхода из функции, в которой был получен указатель.

## <a name="wrapper-objects-and-multiple-threads"></a>Объекты-оболочки и несколько потоков

Как временные, так и постоянные объекты поддерживаются отдельно для каждого потока. Это значит, что один поток не может получить доступ к объектам-оболочкам C++ другого потока, независимо от того, является ли он временным или постоянным.

Чтобы передать эти объекты из одного потока в другой, всегда отправляйте их как собственный `HANDLE` тип. Передача объекта-оболочки C++ из одного потока в другой часто приводит к непредвиденным результатам.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
