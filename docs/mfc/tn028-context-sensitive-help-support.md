---
title: TN028. Поддержка контекстной справки
ms.date: 11/04/2016
f1_keywords:
- vc.help
helpviewer_keywords:
- context-sensitive Help [MFC], MFC applications
- TN028
- resource identifiers, context-sensitive Help
ms.assetid: 884f1c55-fa27-4d4c-984f-30907d477484
ms.openlocfilehash: 502edc837d7886dd60ab5107fb194c1490a76928
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370330"
---
# <a name="tn028-context-sensitive-help-support"></a>TN028. Поддержка контекстной справки

В этой заметке описаны правила присвоения идентифицированных сведений о справках и другие проблемы справки в MFC. Чувствительная к контексту поддержка справки требует компилятора справки, которая доступна в Visual C.

> [!NOTE]
> В дополнение к реализации чувствительной к контексту помощи с помощью WinHelp, MFC также поддерживает использование HTML Help. Для получения дополнительной информации об этой поддержке и программировании с помощью HTML, [см.](../mfc/html-help-context-sensitive-help-for-your-programs.md)

## <a name="types-of-help-supported"></a>Типы поддержки

В приложениях Windows реализованы два типа чувствительной к контексту помощи. Первый, называемый "F1 Help", предполагает запуск WinHelp с соответствующим контекстом, основанным на действующем объекте. Второй - режим "Shift" F1. В этом режиме курсор мыши изменяется в курсор справки, и пользователь переходит к нажатию на объект. В этот момент, WinHelp запускается, чтобы дать помощь для объекта, что пользователь нажал на.

Классы Фонда Майкрософт реализуют обе эти формы помощи. Кроме того, фреймворк поддерживает две простые команды справки: «Индекс справки» и «Использование помощи».

## <a name="help-files"></a>Файлы справки

Классы Фонда Майкрософт предполагают выделение одного файла справки. Этот файл справки должен иметь то же имя и путь, что и приложение. Например, если исполняемым является C: «MyApplication»MyHelp.exe файл справки должен быть C:»MyApplication/MyHelp.hlp. Вы устанавливаете путь через *m_pszHelpFilePath* переменной члена [класса CWinApp.](../mfc/reference/cwinapp-class.md)

## <a name="help-context-ranges"></a>Справка Контекст Диапазоны

Реализация MFC по умолчанию требует, чтобы программа следовала некоторым правилам о назначении идотов контекста справки. Эти правила представляют собой ряд идов, отданных для конкретных элементов управления. Эти правила можно переопределить, предоставив различные реализации различных функций участника, связанных с справкой.

```
0x00000000 - 0x0000FFFF : user defined
0x00010000 - 0x0001FFFF : commands (menus/command buttons)
0x00010000 + ID_
(note: 0x18000-> 0x1FFFF is the practical range since command IDs are>=0x8000)
0x00020000 - 0x0002FFFF : windows and dialogs
0x00020000 + IDR_
(note: 0x20000-> 0x27FFF is the practical range since IDRs are <= 0x7FFF)
0x00030000 - 0x0003FFFF : error messages (based on error string ID)
0x00030000 + IDP_
0x00040000 - 0x0004FFFF : special purpose (non-client areas)
0x00040000 + HitTest area
0x00050000 - 0x0005FFFF : controls (those that are not commands)
0x00040000 + IDW_
```

## <a name="simple-help-commands"></a>Простые команды «Помощь»

Есть две простые команды справки, которые реализуются классами Фонда Майкрософт:

- ID_HELP_INDEX который реализуется [CWinApp::OnHelpIndex](../mfc/reference/cwinapp-class.md#onhelpindex)

- ID_HELP_USING который реализован [CWinApp::OnHelpUsing](../mfc/reference/cwinapp-class.md#onhelpusing)

Первая команда показывает индекс справки для приложения. Второй показывает помощь пользователя в использовании программы WinHelp.

## <a name="context-sensitive-help-f1-help"></a>Контекст-чувствительная справка (Справка F1)

Ключ F1 обычно переводится в команду с идентификатором ID_HELP ускорителем, помещенным в таблицу ускорителя основного окна. Команда ID_HELP также может быть сгенерирована кнопкой с идентификатором ID_HELP на главном окне или диалоговом окне.

Независимо от того, как генерируется ID_HELP команда, она передается как обычная команда до тех пор, пока не достигнет обработчика команд. Для получения дополнительной информации об архитектуре командного разгрома MFC обратитесь к [Technical Note 21](../mfc/tn021-command-and-message-routing.md). Если приложение включено, ID_HELP команда будет обработана [CWinApp::OnHelp](../mfc/reference/cwinapp-class.md#onhelp). Объект приложения получает сообщение справки, а затем направляет команду соответствующим образом. Это необходимо, поскольку маршрута команды по умолчанию не является адекватной для определения наиболее конкретного контекста.

`CWinApp::OnHelp`попытки запустить WinHelp в следующем порядке:

1. Проверка активного `AfxMessageBox` вызова с помощью идентификатора справки. Если в настоящее время окно сообщений активируется, WinHelp запускается с контекстом, подходящим для этого окна сообщений.

1. Отправляет WM_COMMANDHELP сообщение в активное окно. Если это окно не отвечает при запуске WinHelp, то одно и то же сообщение отправляется предкам этого окна до тех пор, пока сообщение не будет обработано или текущее окно не будет окном верхнего уровня.

1. Отправляет команду ID_DEFAULT_HELP в главное окно. Это вызывает справку по умолчанию. Эта команда обычно отображается на `CWinApp::OnHelpIndex`.

Чтобы глобально переопределить базовые значения идентификатора по умолчанию (например, 0x10000 для команд и 0x20000 для ресурсов, таких как диалоги), приложение должно переопределить [CWinApp::WinHelp](../mfc/reference/cwinapp-class.md#winhelp).

Чтобы переопределить эту функциональность и способ определения контекста справки, следует обрабатывать WM_COMMANDHELP сообщение. Возможно, вы захотите предоставить более конкретную систему справки, чем предусмотрено в фреймворке, так как она только глубока, как текущее окно ребенка MDI. Вы также можете предоставить более конкретную справку для конкретного окна или диалога, возможно, на основе текущего внутреннего состояния этого объекта или активного управления в диалоге.

## <a name="wm_commandhelp"></a>WM_COMMANDHELP

```

afx_msg LRESULT CWnd::OnCommandHelp(WPARAM wParam, LPARAM lParam)
```

WM_COMMANDHELP является личным сообщением MFC с Windows, которое получается активным окном при запросе справки. Когда окно получает это сообщение, `CWinApp::WinHelp` оно может вызвать контекст, который соответствует внутреннему состоянию окна.

*lParam*<br/>
Содержит доступный в настоящее время контекст справки. *lParam* равен нулю, если контекст справки не определен. Реализация `OnCommandHelp` может использовать идентификатор контекста в *lParam* для `CWinApp::WinHelp`определения другого контекста или может просто передать его .

*wParam*<br/>
Не используется и будет равна нулю.

Если `OnCommandHelp` функция `CWinApp::WinHelp`вызывает, он должен **вернуться TRUE**. Возвращение **TRUE** останавливает разгром этой команды в другие классы и в другие окна.

## <a name="help-mode-shiftf1-help"></a>Режим справки (Справка shift-F1)

Это вторая форма чувствительной к контексту справки. Как правило, этот режим вводится нажатием SHIFT-F1 или через меню / панели инструментов. Он реализуется как команда (ID_CONTEXT_HELP). Крюк фильтра сообщений не используется для перевода этой команды в то время как модальный диалоговый ящик или меню активен,`CWinApp::Run`поэтому эта команда доступна пользователю только тогда, когда приложение исполняет основной насос сообщения ( ).

После ввода этого режима курсор мыши Справка отображается во всех областях приложения, даже если приложение обычно отображает свой собственный курсор для этой области (например, граница размеров вокруг окна). Пользователь может использовать мышь или клавиатуру для выбора команды. Вместо выполнения команды отображается справка по этой команде. Кроме того, пользователь может нажать на видимый объект на экране, например кнопку на панели инструментов, и для этого объекта будет отображаться справка. Этот режим помощи `CWinApp::OnContextHelp`предоставляется .

Во время выполнения этого цикла все ввод клавиатуры неактивен, за исключением ключей, которые получают доступ к меню. Кроме того, перевод команды `PreTranslateMessage` по-прежнему выполняется с помощью, чтобы позволить пользователю нажать клавишу акселератора и получить помощь по этой команде.

Если в `PreTranslateMessage` функции, которая не должна происходить в режиме помощи SHIFT-F1, имеются определенные переводы или действия, которые должны выполняться в режиме помощи SHIFT-F1, необходимо проверить *m_bHelpMode* участника `CWinApp` перед выполнением этих операций. Реализация `CDialog` `PreTranslateMessage` проверяет это перед `IsDialogMessage`вызовом, например. Это отключает ключи «диалоговой навигации» в бесрежимных диалогах в режиме SHIFT-F1. Кроме того, `CWinApp::OnIdle` все еще вызывается во время этого цикла.

Если пользователь выбирает команду из меню, она обрабатывается как справка по этой команде (через WM_COMMANDHELP см. ниже). Если пользователь нажимает на видимую область окна приложений, делается определение того, является ли это неклиент ным кликом или щелчком клиента. `OnContextHelp`обрабатывает отображение неклиент кликов на кликов клиента автоматически. Если это клиент нажмите, то он посылает WM_HELPHITTEST в окно, которое было нажата. Если это окно возвращает ненулевое значение, это значение используется в качестве контекста для справки. Если он возвращается ноль, `OnContextHelp` пробует родительское окно (и не в том случае, если его родитель и так далее). Если контекст справки не может быть определен, по умолчанию должна быть отправлена ID_DEFAULT_HELP `CWinApp::OnHelpIndex`команда в основное окно, которое затем (обычно) отображается на .

## <a name="wm_helphittest"></a>WM_HELPHITTEST

```

afx_msg LRESULT CWnd::OnHelpHitTest(
WPARAM, LPARAM lParam)
```

WM_HELPHITTEST является сообщение мФС частных окон, которое получено активным окном, нажатым в режиме помощи SHIFT-F1. Когда окно получает это сообщение, оно возвращает идентификатор справки **DWORD** для использования WinHelp.

LOWORD (lParam) содержит координату устройства X-оси, где мышь была нажата относительно клиентской области окна.

HIWORD (lParam) содержит координаты Y-оси.

*wParam*<br/>
не используется и будет равен нулю. Если значение возврата ненулевое, WinHelp вызывается в этом контексте. Если значение возврата равен нулю, родительское окно запрашивается для справки.

Во многих случаях вы можете использовать код тестирования на удар, который у вас уже есть. Ознакомьтесь `CToolBar::OnHelpHitTest` с реализацией примера обработки WM_HELPHITTEST сообщения (код использует код hit-test, используемый на кнопках и наконечниках инструментов). `CControlBar`

## <a name="mfc-application-wizard-support-and-makehm"></a>Поддержка MFC Application Wizard и MAKEHM

Мастер приложения MFC создает необходимые файлы для создания файла справки (.cnt и .hpj файлы). Он также включает в себя ряд предварительно построенных файлов .rtf, которые принимаются компилятором помощи Майкрософт. Многие темы являются полными, но некоторые из них могут быть изменены для вашего конкретного приложения.

Автоматическое создание файла «помощь отображения» поддерживается утилитой под названием MAKEHM. Утилита MAKEHM может переводить РЕСУРС приложения. Файл H в файл отображения справки. Пример:

```
#define IDD_MY_DIALOG   2000
#define ID_MY_COMMAND   150
```

будут переведены на:

```
HIDD_MY_DIALOG    0x207d0
HID_MY_COMMAND    0x10096
```

Этот формат совместим с объектом компилятора Справки, который отображает идол контекста (цифры на правой стороне) с именами тем (символы на левой стороне).

Исходный код для MAKEHM доступен в примере MFC Programming Utilities [MAKEHM.](../overview/visual-cpp-samples.md)

## <a name="adding-help-support-after-running-the-mfc-application-wizard"></a>Добавление поддержки после запуска MFC Application Wizard

Лучший способ добавить Справку в приложение — проверить опцию «Контекст-чувствительная помощь» на странице Расширенных Функций Мастера приложения MFC перед созданием приложения. Таким образом, MFC Application Wizard автоматически добавляет необходимые записи на карту сообщений в ваш `CWinApp`класс, полученный в поддержку Справки.

## <a name="help-on-message-boxes"></a>Справка на почтовых ящиках

Справка на почтовых ящиках (иногда `AfxMessageBox` называемых оповещениями) `MessageBox` поддерживается через функцию, обертку для API Windows.

Есть две версии, `AfxMessageBox`одна для использования с идентификатором строки, а другая для использования с указателем на строку ():`LPCSTR`

```
int AFXAPI AfxMessageBox(LPCSTR lpszText,
    UINT nType,
    UINT nIDHelp);

int AFXAPI AfxMessageBox(UINT nIDPrompt,
    UINT nType,
    UINT nIDHelp);
```

В обоих случаях существует дополнительный идентификатор справки.

В первом случае значение для nIDHelp по умолчанию составляет 0, что не указывает на отсутствие справки для этого окна сообщений. Если пользователь нажимает F1, в то время как окно сообщений активен, пользователь не получит справку (даже если приложение поддерживает Справку). Если это нежелательно, идентификатор справки должен быть предоставлен для nIDHelp.

Во втором случае значение по умолчанию для nIDHelp составляет -1, что указывает на то, что идентификатор справки совпадает с nIDPrompt. Справка будет работать только в том случае, если приложение включено в справку, конечно). Вы должны предоставить 0 для nIDHelp, если вы хотите, чтобы окно сообщений не имеют поддержки. Если вы хотите, чтобы сообщение было включено справкой, но желаете другой идентификатор справки, чем nIDPrompt, просто предоставьте положительное значение для nIDHelp, отличающихся от nIDPrompt.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
