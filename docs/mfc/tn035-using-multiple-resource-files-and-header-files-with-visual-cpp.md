---
title: 'TN035: Использование нескольких файлов ресурсов и файлы заголовков в Visual C++'
ms.date: 11/04/2016
f1_keywords:
- vc.resources
helpviewer_keywords:
- resource files, multiple
- TN035
ms.assetid: 1f08ce5e-a912-44cc-ac56-7dd93ad73fb6
ms.openlocfilehash: 0493dd45caf5eb78da435987a4590442a908a5a3
ms.sourcegitcommit: 5cecccba0a96c1b4ccea1f7a1cfd91f259cc5bde
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2019
ms.locfileid: "58772768"
---
# <a name="tn035-using-multiple-resource-files-and-header-files-with-visual-c"></a>TN035: Использование нескольких файлов ресурсов и файлы заголовков в Visual C++

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает поддержку редактором ресурсов Visual C++ нескольких файлов ресурсов и файлов заголовков, совместно используемых в одном или нескольких проектах, а также рассказывает о том, как с выгодой для себя воспользоваться этой поддержкой. Эта заметка содержит ответы на следующие вопросы:

- Когда может быть необходимо разделить проект на несколько файлов ресурсов и(или) файлов заголовка, и как это сделать

- Как организовать совместное использование общих заголовков. H-файл между двумя. RC-файлы

- Как разделить ресурсы проекта на несколько. RC-файлы

- Как вы (и инструменты) управляют зависимостями сборок между. ВЕРСИЯ-КАНДИДАТ. CPP, и. H-файлов

Следует иметь в виду, что при добавлении дополнительного файла ресурсов в проект ClassWizard не распознает ресурсы в добавленном файле.

Эта заметка предоставляет ответы на вопросы выше в следующей последовательности:

- **Общие сведения о том, как Visual C++ управляет файлы ресурсов и файлы заголовков** Общие сведения о том, как команда Включение наборов в Visual C++ позволяет использовать несколько файлов ресурсов и файлами заголовков в том же проекте.

- **Анализ созданный мастером приложений. Версия-Кандидат и. Файлы H** рассматривает несколько файлов ресурсов и заголовков, которые используются приложением созданный мастером приложений. Эти файлы служат в качестве хорошей модели для создания дополнительных файлов ресурсов и файлов заголовка, которые может потребоваться добавить в проект.

- **Включение дополнительных файлов заголовков** описывает, где может потребоваться включить несколько файлов заголовка и предоставляет сведения о том, как сделать это.

- **Совместное использование файла заголовка между двумя. Версия-Кандидат файлы** показано, как можно совместно использовать один файл заголовка, между несколькими. RC-файлы в разных проектах или, в том же проекте.

- **Использование нескольких файлов ресурсов, в том же проекте** описывает, где может потребоваться разделить проект на несколько. Версия-Кандидат файлы и предоставляет сведения о том, как сделать это.

- **Применение нередактируемые файлы Visual C++** описывает, каким образом можно гарантировать Visual C++ не редактирование и случайное переформатирование пользовательского ресурса.

- **Управление символами, которые совместно используется несколькими Visual C++ редактировать. Версия-Кандидат файлы** описывается совместное использование и те же символы в нескольких. RC-файлы и как избежать назначения дублирующихся числовых идентификаторов.

- **Управление зависимостями между. ВЕРСИЯ-КАНДИДАТ. CPP, и. Файлы H** описывает, как Visual C++ позволяет избежать ненужных перекомпиляции. CPP-файлов, которые зависят от файлов с символами ресурсов.

- **Каким образом управляет набор включает в себя сведения о Visual C++** технические сведения о том, как Visual C++ следит за нескольких (вложенных). RC-файлов и несколько файлов заголовков, включенных # посредством команды #include. RC-файле.

**Общие сведения о том, как Visual C++ управляет файлами ресурсов и файлами заголовков**

Visual C++ управляет одним RC-файлом ресурсов и соответствующим H-файлом заголовка в тесной связи друг с другом. При редактировании и сохранении ресурсов в RC-файле косвенно вносятся изменения и сохраняются символы в соответствующем H-файле. Хотя можно открыть и отредактировать несколько RC-файлов за раз (с помощью пользовательского интерфейса MDI Visual C++), для любого заданного RC-файла косвенно редактируется ровно один соответствующий файл заголовка.

**Файл символов заголовков**

По умолчанию Visual C++ всегда называет соответствующий файл заголовка RESOURCE.H независимо от имени файла ресурсов (например, MYAPP.RC). С помощью **включения ресурсов** команду **представление** меню в Visual C++, можно изменить имя этого файла заголовка, обновив файл символов заголовка в **Включение наборов**диалоговое окно.

**Директивы символов только для чтения**

Хотя Visual C++ изменяет только один файл заголовка для любого заданного RC-файла, Visual C++ поддерживает ссылки на символы, определенные в дополнительных файлах заголовка только для чтения. С помощью **включения ресурсов** команду **представление** меню в Visual C++, можно указать любое количество дополнительных заголовка только для чтения файлов как директивы символов только для чтения. Ограничение "только для чтения" означает, что при добавлении нового ресурса в RC-файл можно использовать символ, определенный в файле заголовка только для чтения; но при удалении ресурса символ по-прежнему останется определенным в файле заголовка только для чтения. Невозможно изменить числовое значение, присвоенное символу только для чтения.

**Директивы времени компиляции**

Visual C++ также поддерживает вложение файлов ресурсов, где один RC-файл включается в другой посредством команды #include. При редактировании заданного RC-файла с помощью Visual C++ все ресурсы в файлах #include не видны. Однако при компиляции RC-файла включенные с помощью команды #include файлы также компилируются. С помощью **включения ресурсов** команду **представление** меню в Visual C++, можно указать любое количество # посредством оператора #include. RC-файлы в качестве директивы времени компиляции.

Обратите внимание на то, что происходит при чтении в Visual C++. Версия-Кандидат файла, который #include #include другой. RC-файл, который является *не* указан в качестве директивы времени компиляции. Такая ситуация может возникнуть при добавлении в Visual C++ RC-файла, который ранее обслуживался вручную с использованием текстового редактора. Когда Visual C++ считывает включенный с помощью команды #include RC-файл, он выполняет слияние включенных командой #include ресурсов в родительский RC-файл. При сохранении родительского RC-файла оператор #include, по сути, будет заменен включенными посредством команды #include ресурсами. Если вы не хотите это слияние, следует удалить # оператор include из родительского. RC-файле *предыдущего* он будет считан в Visual C++; затем с помощью Visual C++ добавить тот же # оператор include в качестве директивы времени компиляции.

Visual C++ сохраняет в. Версия-Кандидат файл три типа вышеперечисленных сведений (файл символов заголовка, директивы символов только для чтения и директивы времени компиляции) в # директив include *и* ресурсах TEXTINCLUDE. Ресурсы TEXTINCLUDE, деталь реализации, который обычно не нужен для обработки, описаны в [как Visual C++ управляет сведениями о](#_mfcnotes_tn035_set_includes).

**Анализ созданный мастером приложений. Версия-Кандидат и. H-файлов**

Анализ кода приложения, созданного мастером приложений AppWizard, дает представление о том, как осуществляется управление несколькими файлами ресурсов и файлами заголовков в Visual C++. Рассматриваемые ниже отрывки кода взяты из приложения MYAPP, созданного в мастере приложений с использованием параметров по умолчанию.

Как показано на схеме ниже, приложение, созданное мастером приложений, использует несколько файлов ресурсов и файлов заголовков.

```
RESOURCE.H     AFXRES.H
\       /
\     /
    MYAPP.RC
|
|
    RES\MYAPP.RC2
    AFXRES.RC
    AFXPRINT.RC
```

Просмотреть связи между этими файлами можно с помощью команды "Включение файлов/наборов" Visual C++.

MYAPP. Версия-Кандидат, с помощью Visual C++ для редактирования файл ресурсов приложения.

RESOURCE.H — это зависящий от приложения файл заголовка. Мастером создания приложений ему всегда присваивается имя RESOURCE.H, что соответствует именованию файла заголовка по умолчанию в Visual C++. Оператор #include для этого файла заголовка — это первый оператор в файле ресурсов (MYAPP.RC).

```
//Microsoft Visual C++ generated resource script
//
#include "resource.h"
```

RES\MYAPP. Версия-кандидат 2 содержит ресурсы, которые не будут изменены в Visual C++, но будет включаться в последней компиляции. EXE-файла. Мастер приложений не создает таких ресурсов по умолчанию, поскольку Visual C++ может изменить все стандартные ресурсы, в том числе ресурс версии (новая возможность в этом выпуске). Пустой файл создается мастером приложений AppWizard, если требуется добавить в этот файл собственные пользовательские форматированные ресурсы.

При использовании пользовательских форматированных ресурсов их можно добавить в файл RES\MYAPP.RC2 и редактировать их с помощью текстового редактора Visual C++.

AFXRES.RC и AFXPRINT.RC содержат стандартные ресурсы, требуемые некоторыми компонентами платформы. Подобно RES\MYAPP.RC2, эти два файла ресурсов, предоставленные платформой, включены посредством оператора #include в конец файла MYAPP.RC, они заданы в разделе "Директивы времени компиляции" диалогового окна "Включение наборов". Таким образом, при редактировании MYAPP.RC в Visual C++ не выполняется непосредственный просмотр или правка этих ресурсов платформы, однако они компилируются в двоичный RES-файл и окончательный EXE-файл приложения. Дополнительные сведения о стандартных ресурсах платформы, включая процедуры их изменения, см. в разделе [техническое Примечание 23](../mfc/tn023-standard-mfc-resources.md).

AFXRES.H определяет стандартные символы, такие как `ID_FILE_NEW`, которые используются платформой и, в частности, файлом AFXRES.RC. AFXRES.H также включает посредством оператора #include файл WINRES.H, содержащий подмножество файлов WINDOWS.H, которые требуются созданным Visual C++ RC-файлам и файлу AFXRES.RC. Символы, определенные в файле AFXRES.H, доступны при редактировании файла ресурсов приложения (MYAPP.RC). Например, `ID_FILE_NEW` используется для пункта меню "Создать файл" в ресурсе меню файла MYAPP.RC. Невозможно изменить или удалить определенные платформой символы.

## <a name="_mfcnotes_tn035_including"></a> Включение дополнительных файлов заголовков

Приложение, созданное мастером приложений включает только два файла заголовков: РЕСУРС. H и AFXRES. З. Только файл RESOURCE.H зависит от приложения. Может потребоваться включить дополнительные, доступные только для чтения файлы заголовка в следующих случаях:

Файл заголовка предоставляется внешним источником, либо требуется предоставить общий доступ к файлу заголовка из нескольких проектов или нескольких частей одного и того же проекта.

Файл заголовка имеет форматирование и комментарии, которые не нужно менять или отфильтровывать при сохранении файла в Visual C++. Возможно, к примеру, требуется сохранить оператор #define, использующий арифметические операции с символами:

```
#define RED 0
#define BLUE 1
#define GREEN 2
#define ID_COLOR_BUTTON 1001
#define ID_RED_BUTTON (ID_COLOR_BUTTON + RED)
#define ID_BLUE_BUTTON (ID_COLOR_BUTTON + BLUE)
#define ID_GREEN_BUTTON (ID_COLOR_BUTTON + GREEN)
```

Можно включить дополнительные доступные только для чтения файлы заголовка с помощью **включения ресурсов** команду, чтобы указать # оператор include в качестве второй директивы символов только для чтения, как в:

```
#include "afxres.h"
#include "second.h"
```

Новая схема связей файлов теперь выглядит следующим образом:

```
    AFXRES.H
RESOURCE.H     SECOND.H
\       /
\     /
    MYAPP.RC
|
|
    RES\MYAPP.RC2
    AFXRES.RC
    AFXPRINT.RC
```

**Совместное использование файла заголовка между двумя. RC-файлы**

Может потребоваться совместно использовать файл заголовка в двух RC-файлах разных проектов (или в масштабах одного проекта). Для этого необходимо применить технику директив только для чтения, описанную выше, к обоим RC-файлам. В случае, когда 2 RC-файла предназначены для разных приложений (разных проектов), результат показан на следующей схеме:

```
    RESOURCE.H AFXRES.H   RESOURCE.H
(for MYAPP1) SECOND.H   (for MYAPP2)
\       /     \       /
\     /       \     /
    MYAPP1.RC MYAPP2.RC */    \        /     \ */      \      /       \
RES\MYAPP1.RC2  AFXRES.RC     RES\MYAPP2.RC2
    AFXPRINT.RC
```

Ниже описывается случай, когда второй файл заголовка совместно используется двумя RC-файлами одного и того же приложения (проекта).

**Использование нескольких файлов ресурсов в одном проекте**

Visual C++ и компилятор ресурсов поддерживают несколько RC-файлов в том же проекте посредством включения одного RC-файла в другой с помощью оператора #include. Допускается множественное вложение. Разделить ресурсы проекта на несколько RC-файлов имеет смысл по нескольким причинам.

- Управлять большим количеством ресурсов, распределенных между многочисленными членами проектной команды, легче, если разделить ресурсы на несколько RC-файлов. Если для извлечения файлов и возврата изменений используется пакет управления системы управления версиями, разделение ресурсов на несколько RC-файлов обеспечит более полный контроль над управлением изменениями в ресурсах.

- Если требуется использовать директивы препроцессора, например #ifdef, #endif и #define, для частей ресурсов, необходимо изолировать их в доступных только для чтения ресурсах, которые будут компилироваться компилятором ресурсов.

- Компонентные RC-файлы загружаются и сохраняются в Visual C++ быстрее, чем один составной RC-файл.

- Если требуется поддержать ресурс с текстовым редактором в удобном для чтения формате, необходимо сохранить его в RC-файле отдельно от редактируемого Visual C++ файла.

- Если необходимо оставить определенный пользователем ресурс в двоичном или текстовом формате, который может быть интерпретирован другим специализированным редактором данных, необходимо оставить его в отдельном RC-файле, чтобы Visual C++ не меняла его формат на шестнадцатеричные данные. . Файловые ресурсы WAV (звук), в нем основные понятия Advanced MFC [SPEAKN](../overview/visual-cpp-samples.md) — хороший пример.

Можно включить посредством оператора #include файл SECOND.RC в директивы времени выполнения в диалоговом окне "Включение наборов".

```
#include "res\myapp.rc2"  // non-Visual C++ edited resources
#include "second.rc"  // THE SECOND .RC FILE

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
```

Результат показан на следующей схеме.

```
RESOURCE.H     AFXRES.H
\       /
\     /
    MYAPP.RC
|
|
    RES\MYAPP.RC2
    SECOND.RC
    AFXRES.RC
    AFXPRINT.RC
```

С помощью директив времени компиляции можно организовать редактируемые и нередактируемые в Visual C++ ресурсы в несколько RC-файлов, где "главный" файл MYAPP.RC не делает ничего, кроме включения других RC-файлов посредством оператора #include. При использовании MAK-файла проекта Visual C++ необходимо включить в проект "главный" RC-файл, чтобы все включенные посредством оператора #include ресурсы компилировались с приложением.

**Применение файлов реализация нередактируемых в Visual C++**

RES\MYAPP созданный мастером приложений. Файл RC2 — это пример файла, который содержит ресурсы, которые вы выполните *не* требуется случайно считывать в Visual C++, а затем записывать их обратно с потерей информации о форматировании. Чтобы избежать этого, поместите следующие строки в начало файла RES\MYAPP.RC2:

```
#ifdef APSTUDIO_INVOKED
#error this file is not editable by Visual C++
#endif //APSTUDIO_INVOKED
```

При компиляции Visual C++. RC-файле, он определяет `APSTUDIO_INVOKED` производительны `RC_INVOKED`. Если структура созданного мастером приложений файла повреждена и Visual C++ считывает строку #error выше, он сообщает о неустранимой ошибке и прерывает чтение RC-файла.

**Управление символами, которые совместно используется несколькими Visual C++ редактировать. RC-файлы**

При разделении ресурсов на несколько RC-файлов, которые требуется редактировать в Visual C++ по отдельности, возникает две проблемы:

- Может потребоваться использовать одни и те же символы в нескольких RC-файлах.

- Необходимо сделать так, чтобы Visual C++ не назначала одни и те же числовые идентификаторы разным ресурсам (символам).

На следующей схеме показана организация RC- и H-файлов, в которых решается первая проблема.

```
    MYAPP.RC */         \ */           \
MYSTRS.H   / MYSHARED.H  \  MYMENUS.H
\    /    /      \   \    \
\  /    /        \   \    \
    MYSTRS.RC MYMENUS.RC
```

В этом примере строковые ресурсы хранятся в одном файле ресурсов, MYSTRS.RC, а меню хранятся в другом — MYMENUS.RC. Некоторые символы, например, команды, нужно будет совместно использовать в обоих файлах. Например, ID_TOOLS_SPELL может являться идентификатором команды меню элемента "Правописание" в меню "Сервис" и одновременно строковым идентификатором командной строки, отображаемой платформой в строке статуса главного окна приложения.

Символ ID_TOOLS_SPELL хранится в общем файле заголовка, MYSHARED.H. Обслуживание этого общего файла заголовка осуществляется вручную в текстовом редакторе; Visual C++ не поддерживает его прямое редактирование. Два ресурса файлы MYSTRS. Версия-Кандидат и MYMENUS. Версия-КАНДИДАТ, укажите #include MYSHARED. H в только для чтения директивы для MYAPP. Версия-КАНДИДАТ, с помощью **включения ресурсов** команды, как описано выше.

Удобнее предугадать, какой символ будет использоваться совместно, прежде чем предпринимать попытки использовать его для идентификации ресурсов. Добавьте символ в общий файл заголовка и если общий файл заголовков еще не включен в доступные только для чтения директивы для RC-файла посредством оператора #include, сделайте это до начала использования символа. Если совместное использование символа подобным образом не предусматривалось, необходимо вручную (с помощью текстового редактора) переместить оператор #define для этого символа из файла MYMENUS.H в файл MYSHARED.H, прежде чем приступать к использованию символа в файле MYSTRS.RC.

При управлении символами в нескольких RC-файлах необходимо также запретить Visual C++ назначать одни и те же значения числового идентификатора разным ресурсам (символам). Для любого заданного RC-файла Visual C++ последовательно присваивает идентификаторы в каждом из четырех доменов ИД. Между сеансами редактирования Visual C++ отслеживает последний присвоенный идентификатор в каждом домене файла символов заголовков для RC-файла. Вот как выглядят значения APS_NEXT для пустого (нового) RC-файла:

```
#define _APS_NEXT_RESOURCE_VALUE  101
#define _APS_NEXT_COMMAND_VALUE   40001
#define _APS_NEXT_CONTROL_VALUE   1000
#define _APS_NEXT_SYMED_VALUE     101
```

`_APS_NEXT_RESOURCE_VALUE` — Это следующее значение символов, который будет использоваться для ресурса диалогового окна, меню ресурсов и т. д. Допустимый диапазон значений символов ресурсов — от 1 до 0x6FFF.

`_APS_NEXT_COMMAND_VALUE` — Это следующее значение символов, который будет использоваться для идентификации команды. Допустимый диапазон значений символов команд — от 0x8000 до 0xDFFF.

`_APS_NEXT_CONTROL_VALUE` — Это следующее значение символов, который будет использоваться для элемента управления диалогового окна. Допустимый диапазон значений символов элемента управления "диалоговое окно" — от 8 до 0xDFFF.

`_APS_NEXT_SYMED_VALUE` является следующее значение символов, которое будет выдаваться при присвоении значения символов вручную с помощью новой команды в обозревателе символов.

При создании нового RC-файла Visual C++ начинает с немного более высоких значений, чем наинизшее допустимое значение. AppWizard также инициализирует эти значения с использованием чего-либо более подходящего для приложений MFC. Дополнительные сведения о диапазонах значений Идентификаторов, см. в разделе [техническое Примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md).

Теперь каждый раз при создании нового файла ресурсов, даже в том же проекте, Visual C++ определяет же `_APS_NEXT_` значения. Это означает, что при добавлении, допустим, нескольких диалоговых окон в два разных RC-файла очень вероятно, что одно и то же значение #define будет назначено разным диалоговым окнам. Например, параметру IDD_MY_DLG1 в первом RC-файле может быть присвоено то же число (101), что и параметру IDD_MY_DLG2 во втором RC-файле.

Чтобы избежать этого, необходимо зарезервировать отдельный числовой диапазон для каждого из четырех доменов идентификаторов в соответствующих RC-файлах. Этого можно вручную обновить `_APS_NEXT` значений в каждом из. RC-файлы **перед** начать добавлять ресурсы. Например если первый. RC-файл использует значение по умолчанию `_APS_NEXT` значения, а затем можно назначить следующие `_APS_NEXT` значения до секунды. RC-файле:

```
#define _APS_NEXT_RESOURCE_VALUE  2000
#define _APS_NEXT_COMMAND_VALUE   42000
#define _APS_NEXT_CONTROL_VALUE   2000
#define _APS_NEXT_SYMED_VALUE     2000
```

Конечно, все еще возможно, что Visual C++ присвоит в первом RC-файле столько идентификаторов, что числовые значения начнут перекрывать зарезервированные для второго RC-файла. Необходимо зарезервировать достаточно крупные диапазоны, чтобы этого не произошло.

**Управление зависимостями между. ВЕРСИЯ-КАНДИДАТ. CPP, и. H-файлов**

Если Visual C++ сохраняет RC-файл, он также сохраняет изменения символов в соответствующем файле RESOURCE.H. Любой из CPP-файлов, ссылающихся на ресурсы в RC-файле, должен включать посредством оператора #include файл RESOURCE.H, обычно из главного файла заголовка проекта. Это приводит к нежелательному побочному эффекту: внутренняя система управления проектами среды разработки сканирует исходные файлы на наличие зависимостей заголовков. Каждый раз при добавлении нового символа в Visual C++ придется перекомпилировать весь CPP-файл, включающий файл RESOURCE.H с помощью директивы #include.

Visual C++ обходит зависимость от RESOURCE.H, включая следующий комментарий в качестве первой строки файла RESOURCE.H:

```
//{{NO_DEPENDENCIES}}
```

Среда разработки интерпретирует этот комментарий, игнорируя изменения файла RESOURCE.H таким образом, что CPP-файлам не потребуется повторная компиляция.

Visual C++ всегда добавляет строку комментариев //{{NO_DEPENDENCIES}} в RC-файл при сохранении. В некоторых случаях обход зависимости сборки от файла RESOURCE.H может вызвать ошибки во время выполнения, которые невозможно обнаружить во время компоновки. Например, если браузер символов используется для изменения числового значения, присвоенного символу для ресурса, ресурс не будет правильно найден и загружен во время выполнения приложения, если ссылающийся на этот ресурс CPP-файл не перекомпилирован. В таких случаях следует явно перекомпиляции любой. CPP-файлов, которые зависят от изменения символов в РЕСУРСЕ. H или выберите **перестроить все**. Если у вас есть необходимость часто менять значения символов для определенной группы ресурсов, вы вероятно найдут ее более удобнее и безопаснее разделить эти символы в файл отдельный заголовка только для чтения, как описано в предыдущем разделе [включая Дополнительные файлы заголовка](#_mfcnotes_tn035_including).

## <a name="_mfcnotes_tn035_set_includes"></a> Как Visual C++ управляет набор включает в себя сведения **

Как сказано выше, команда "Включение наборов" меню "Файл" позволяет задать три типа сведений.

- Файл символов заголовка

- Директивы символов только для чтения

- Директивы времени компиляции

Далее описывается обслуживание этой информации Visual C++ в RC-файле. Для работы с Visual C++ эта информация не является обязательной, однако она обеспечивает дополнительное понимание вопроса и позволяет использовать возможность "Включение наборов" более уверенно.

Каждый из описанных выше трех типов сведений, хранящихся в. RC-файле в двух формах: (1) как #include или другие директивы, интерпретируемые компилятором ресурсов, а (2) специальные ресурсы TEXTINCLUDE, интерпретируемые только в Visual C++.

Цель ресурсов TEXTINCLUDE — безопасно хранить значение включают сведения в форме, которая представлению в Visual C++ **Включение наборов** диалоговое окно. TEXTINCLUDE — *тип ресурса* определенный Visual C++. Visual C++ распознает три определенных ресурса TEXTINCLUDE с идентификационными номерами 1, 2 и 3.

|Идентификатор ресурса TEXTINCLUDE|Тип сведений "Включение наборов"|
|-----------------------------|--------------------------------------|
|1|Файл символов заголовка|
|2|Директивы символов только для чтения|
|3|Директивы времени компиляции|

Каждый из трех типов сведений "Включение наборов" иллюстрируется файлами по умолчанию MYAPP.RC и RESOURCE.H, созданными мастером приложений, как описано ниже. Дополнительные токены \0 и "" между блоками BEGIN и END требуются синтаксису RC для задания завершаемых нулем строк и символа двойных кавычек соответственно.

## <a name="symbol-header-file"></a>Файл символов заголовка

Форма данных файла символов заголовков, интерпретируемая компилятором ресурсов, — это просто оператор #include:

```
#include "resource.h"
```

Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:

```
1 TEXTINCLUDE DISCARDABLE
BEGIN
"resource.h\0"
END
```

## <a name="read-only-symbol-directives"></a>Директивы символов только для чтения

Доступные только для чтения директивы включены в начало файла MYAPP.RC в следующей форме, доступной для интерпретации компилятором ресурсов:

```
#include "afxres.h"
```

Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:

```
2 TEXTINCLUDE DISCARDABLE
BEGIN
   "#include ""afxres.h""\r\n"
   "\0"
END
```

## <a name="compile-time-directives"></a>Директивы времени компиляции

Директивы времени выполнения включены в конец файла MYAPP.RC в следующей форме, доступной для интерпретации компилятором ресурсов:

```
#ifndef APSTUDIO_INVOKED
///////////////////////
//
// From TEXTINCLUDE 3
//
#include "res\myapp.rc2"  // non-Visual C++ edited resources

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
#endif  // not APSTUDIO_INVOKED
```

Директива #ifndef APSTUDIO_INVOKED отправляет Visual C++ инструкцию о необходимости пропустить директивы времени выполнения.

Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:

```
3 TEXTINCLUDE DISCARDABLE
BEGIN
"#include ""res\myapp.rc2""  // non-Visual C++ edited resources\r\n"
"\r\n"
"#include ""afxres.rc""  // Standard components\r\n"
"#include ""afxprint.rc""  // printing/print preview resources\r\n"
"\0"
END
```

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
