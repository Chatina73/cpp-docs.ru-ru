---
title: TN035. Использование нескольких файлов ресурсов и файлов заголовков в Visual C++
ms.date: 11/04/2016
f1_keywords:
- vc.resources
helpviewer_keywords:
- resource files, multiple
- TN035
ms.assetid: 1f08ce5e-a912-44cc-ac56-7dd93ad73fb6
ms.openlocfilehash: 23d4fdeb82ed7eea97a104e111cd022a87626df4
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75302176"
---
# <a name="tn035-using-multiple-resource-files-and-header-files-with-visual-c"></a>TN035. Использование нескольких файлов ресурсов и файлов заголовков в Visual C++

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает поддержку редактором ресурсов Visual C++ нескольких файлов ресурсов и файлов заголовков, совместно используемых в одном или нескольких проектах, а также рассказывает о том, как с выгодой для себя воспользоваться этой поддержкой. Эта заметка содержит ответы на следующие вопросы:

- Когда может потребоваться разделить проект на несколько файлов ресурсов и/или файлов заголовков и как это сделать

- Как поделиться общим заголовком. H файл между двумя. RC-файлы

- Как разделить ресурсы проекта на несколько. RC-файлы

- Как вы (и средства) управляют зависимостями сборки между. ВЕРСИЯ-КАНДИДАТ,. CPP, и. H файлы

Следует иметь в виду, что при добавлении дополнительного файла ресурсов в проект ClassWizard не распознает ресурсы в добавленном файле.

Эта заметка предоставляет ответы на вопросы выше в следующей последовательности:

- **Общие сведения о том C++ , как визуальное управление файлами ресурсов и файлами заголовков** предоставляет общие сведения о том, C++ как набор ресурсов включает команду в Visual, позволяет использовать в одном проекте несколько файлов ресурсов и файлов заголовков.

- **Анализ созданного помощью мастера. Версия-кандидат и. H-файлы** просматривают несколько файлов ресурсов и заголовков, которые используются приложением, созданным помощью мастера. Эти файлы служат в качестве хорошей модели для создания дополнительных файлов ресурсов и файлов заголовка, которые может потребоваться добавить в проект.

- **Включение дополнительных файлов заголовков** описывает, где может потребоваться включить несколько файлов заголовков, и предоставляет подробные сведения о том, как это сделать.

- **Совместное использование файла заголовка между двумя. В RC-файлах** показано, как можно совместно использовать один файл заголовка между несколькими. RC-файлы в разных проектах или, возможно, в одном проекте.

- **Использование нескольких файлов ресурсов в одном проекте** описывает, где может потребоваться разбить проект на несколько. RC-файлы и предоставляет подробные сведения о том, как это сделать.

- **Принудительное применение нередактируемых C++ визуальных файлов** описывает, как можно убедиться C++ , что визуальный элемент не редактирует и случайно переформатирует настраиваемый ресурс.

- **Управление символами, совместно используемыми несколькими визуально C++редактируемыми. Файлы RC** описывают, как совместно использовать одни и те же символы в нескольких. RC-файлы и способы избежать назначения повторяющихся числовых значений ID.

- **Управление зависимостями между. ВЕРСИЯ-КАНДИДАТ,. CPP, и. H Files** описывает, C++ как визуальный элемент помогает избежать ненужной перекомпиляции. CPP файлы, зависящие от файлов символов ресурсов.

- **Сведения о C++ том, как визуальное управление элементами управления включает** в C++ себя технические сведения о том, как визуальный элемент отслеживает несколько (вложенных). RC-файлы и несколько файлов заголовков, #include с помощью. RC-файл.

## <a name="overview-of-how-visual-c-manages-resource-files-and-header-files"></a>Общие сведения об управлении файлами ресурсов и файлами заголовка в Visual C++

Visual C++ управляет одним RC-файлом ресурсов и соответствующим H-файлом заголовка в тесной связи друг с другом. При редактировании и сохранении ресурсов в RC-файле косвенно вносятся изменения и сохраняются символы в соответствующем H-файле. Хотя можно открыть и отредактировать несколько RC-файлов за раз (с помощью пользовательского интерфейса MDI Visual C++), для любого заданного RC-файла косвенно редактируется ровно один соответствующий файл заголовка.

### <a name="symbol-header-file"></a>Файл символов заголовка

По умолчанию Visual C++ всегда называет соответствующий файл заголовка RESOURCE.H независимо от имени файла ресурсов (например, MYAPP.RC). С помощью команды **ресурс включает** в меню **вид** в визуальном C++элементе можно изменить имя этого файла заголовка, обновив файл заголовка символов в диалоговом окне **набор включаемых** файлов.

### <a name="read-only-symbol-directives"></a>Директивы символов только для чтения

Хотя Visual C++ изменяет только один файл заголовка для любого заданного RC-файла, Visual C++ поддерживает ссылки на символы, определенные в дополнительных файлах заголовка только для чтения. С помощью команды **ресурс включает** в меню **вид** в визуальном C++элементе можно указать любое количество дополнительных файлов заголовков, доступное только для чтения, в виде директив с символами только для чтения. Ограничение "только для чтения" означает, что при добавлении нового ресурса в RC-файл можно использовать символ, определенный в файле заголовка только для чтения; но при удалении ресурса символ по-прежнему останется определенным в файле заголовка только для чтения. Невозможно изменить числовое значение, присвоенное символу только для чтения.

### <a name="compile-time-directives"></a>Директивы времени компиляции

Visual C++ также поддерживает вложение файлов ресурсов, где один RC-файл включается в другой посредством команды #include. При редактировании заданного RC-файла с помощью Visual C++ все ресурсы в файлах #include не видны. Однако при компиляции RC-файла включенные с помощью команды #include файлы также компилируются. С помощью команды **ресурс включает** в меню **вид** в визуальном C++элементе можно указать любое количество #include. RC-файлы как директивы времени компиляции.

Обратите внимание, что происходит при чтении в Visual C++ a. RC-файл, который #include другой. RC-файл, который *не* указан как директива времени компиляции. Такая ситуация может возникнуть при добавлении в Visual C++ RC-файла, который ранее обслуживался вручную с использованием текстового редактора. Когда Visual C++ считывает включенный с помощью команды #include RC-файл, он выполняет слияние включенных командой #include ресурсов в родительский RC-файл. При сохранении родительского RC-файла оператор #include, по сути, будет заменен включенными посредством команды #include ресурсами. Если вы не хотите, чтобы слияние происходило, следует удалить оператор #include из родительского элемента. RC-файл *до* его чтения в Visual C++; Затем с помощью C++визуального элемента добавьте ту же #include инструкцию, что и директива времени компиляции.

Визуальное C++ сохранение в. RC-файл три приведенных выше набора включают сведения (файл заголовков символов, директивы символов только для чтения и директивы времени компиляции) в директивах #include *и* в ресурсах ресурса TEXTINCLUDE. Ресурсы ресурса TEXTINCLUDE — сведения о реализации, которые обычно не нуждаются в работе, объясняются в [том, как визуальные C++ элементы управления включают информацию](#_mfcnotes_tn035_set_includes).

## <a name="analysis-of-appwizard-created-rc-and-h-files"></a>Анализ RC- и H-файлов, созданных с помощью мастера приложений

Анализ кода приложения, созданного мастером приложений AppWizard, дает представление о том, как осуществляется управление несколькими файлами ресурсов и файлами заголовков в Visual C++. Рассматриваемые ниже отрывки кода взяты из приложения MYAPP, созданного в мастере приложений с использованием параметров по умолчанию.

Как показано на схеме ниже, приложение, созданное мастером приложений, использует несколько файлов ресурсов и файлов заголовков.

```Diagram
   RESOURCE.H     AFXRES.H
          \       /
           \     /
          MYAPP.RC
              |
              |
        RES\MYAPP.RC2
        AFXRES.RC
        AFXPRINT.RC
```

Просмотреть связи между этими файлами можно с помощью команды "Включение файлов/наборов" Visual C++.

MyApp. RC
Файл ресурсов приложения, редактируемый с помощью Visual C++.

RESOURCE.H — это зависящий от приложения файл заголовка. Мастером создания приложений ему всегда присваивается имя RESOURCE.H, что соответствует именованию файла заголовка по умолчанию в Visual C++. Оператор #include для этого файла заголовка — это первый оператор в файле ресурсов (MYAPP.RC).

```rc
//Microsoft Visual C++ generated resource script
//
#include "resource.h"
```

рес\мяпп. RC2
Содержит ресурсы, которые не будут изменены Visual C++, однако будут включены в окончательный скомпилированный EXE-файл. Мастер приложений не создает таких ресурсов по умолчанию, поскольку Visual C++ может изменить все стандартные ресурсы, в том числе ресурс версии (новая возможность в этом выпуске). Пустой файл создается мастером приложений AppWizard, если требуется добавить в этот файл собственные пользовательские форматированные ресурсы.

При использовании пользовательских форматированных ресурсов их можно добавить в файл RES\MYAPP.RC2 и редактировать их с помощью текстового редактора Visual C++.

AFXRES.RC и AFXPRINT.RC содержат стандартные ресурсы, требуемые некоторыми компонентами платформы. Подобно RES\MYAPP.RC2, эти два файла ресурсов, предоставленные платформой, включены посредством оператора #include в конец файла MYAPP.RC, они заданы в разделе "Директивы времени компиляции" диалогового окна "Включение наборов". Таким образом, при редактировании MYAPP.RC в Visual C++ не выполняется непосредственный просмотр или правка этих ресурсов платформы, однако они компилируются в двоичный RES-файл и окончательный EXE-файл приложения. Дополнительные сведения о стандартных ресурсах платформы, включая процедуры их изменения, см. в [техническом примечании 23](../mfc/tn023-standard-mfc-resources.md).

AFXRES.H определяет стандартные символы, такие как `ID_FILE_NEW`, которые используются платформой и, в частности, файлом AFXRES.RC. AFXRES.H также включает посредством оператора #include файл WINRES.H, содержащий подмножество файлов WINDOWS.H, которые требуются созданным Visual C++ RC-файлам и файлу AFXRES.RC. Символы, определенные в файле AFXRES.H, доступны при редактировании файла ресурсов приложения (MYAPP.RC). Например, `ID_FILE_NEW` используется для пункта меню "Создать файл" в ресурсе меню файла MYAPP.RC. Невозможно изменить или удалить определенные платформой символы.

## <a name="_mfcnotes_tn035_including"></a>Включение дополнительных файлов заголовков

Приложение, созданное мастером приложений AppWizard, включает только два файла заголовков: RESOURCE.H и AFXRES.H. Только файл RESOURCE.H зависит от приложения. Может потребоваться включить дополнительные, доступные только для чтения файлы заголовка в следующих случаях:

Файл заголовка предоставляется внешним источником, либо требуется предоставить общий доступ к файлу заголовка из нескольких проектов или нескольких частей одного и того же проекта.

Файл заголовка имеет форматирование и комментарии, которые не нужно менять или отфильтровывать при сохранении файла в Visual C++. Возможно, к примеру, требуется сохранить оператор #define, использующий арифметические операции с символами:

```h
#define RED 0
#define BLUE 1
#define GREEN 2
#define ID_COLOR_BUTTON 1001
#define ID_RED_BUTTON (ID_COLOR_BUTTON + RED)
#define ID_BLUE_BUTTON (ID_COLOR_BUTTON + BLUE)
#define ID_GREEN_BUTTON (ID_COLOR_BUTTON + GREEN)
```

Можно включить дополнительные файлы заголовков, которые доступны только для чтения, с помощью команды **Resource включает** команду, чтобы указать #includeную инструкцию в качестве второй директивы с символами только для чтения, как в:

```rc
#include "afxres.h"
#include "second.h"
```

Новая схема связей файлов теперь выглядит следующим образом:

```Diagram
                   AFXRES.H
    RESOURCE.H     SECOND.H
          \       /
           \     /
          MYAPP.RC
              |
              |
        RES\MYAPP.RC2  
        AFXRES.RC
        AFXPRINT.RC
```

## <a name="sharing-a-header-file-between-two-rc-files"></a>Совместное использование файла заголовка двумя RC-файлами

Может потребоваться совместно использовать файл заголовка в двух RC-файлах разных проектов (или в масштабах одного проекта). Для этого необходимо применить технику директив только для чтения, описанную выше, к обоим RC-файлам. В случае, когда 2 RC-файла предназначены для разных приложений (разных проектов), результат показан на следующей схеме:

```Diagram
     RESOURCE.H   AFXRES.H   RESOURCE.H  
    (for MYAPP1)  SECOND.H   (for MYAPP2)
          \       /     \       /
           \     /       \     /
          MYAPP1.RC      MYAPP2.RC
           /    \        /     \
          /      \      /       \
RES\MYAPP1.RC2  AFXRES.RC     RES\MYAPP2.RC2
                AFXPRINT.RC
```

Ниже описывается случай, когда второй файл заголовка совместно используется двумя RC-файлами одного и того же приложения (проекта).

## <a name="using-multiple-resource-files-in-the-same-project"></a>Использование нескольких файлов ресурсов в одном проекте

Visual C++ и компилятор ресурсов поддерживают несколько RC-файлов в том же проекте посредством включения одного RC-файла в другой с помощью оператора #include. Допускается множественное вложение. Разделить ресурсы проекта на несколько RC-файлов имеет смысл по нескольким причинам.

- Управлять большим количеством ресурсов, распределенных между многочисленными членами проектной команды, легче, если разделить ресурсы на несколько RC-файлов. Если для извлечения файлов и возврата изменений используется пакет управления системы управления версиями, разделение ресурсов на несколько RC-файлов обеспечит более полный контроль над управлением изменениями в ресурсах.

- Если требуется использовать директивы препроцессора, например #ifdef, #endif и #define, для частей ресурсов, необходимо изолировать их в доступных только для чтения ресурсах, которые будут компилироваться компилятором ресурсов.

- Компонентные RC-файлы загружаются и сохраняются в Visual C++ быстрее, чем один составной RC-файл.

- Если требуется поддержать ресурс с текстовым редактором в удобном для чтения формате, необходимо сохранить его в RC-файле отдельно от редактируемого Visual C++ файла.

- Если необходимо оставить определенный пользователем ресурс в двоичном или текстовом формате, который может быть интерпретирован другим специализированным редактором данных, необходимо оставить его в отдельном RC-файле, чтобы Visual C++ не меняла его формат на шестнадцатеричные данные. Тот. Хороший пример — файловые ресурсы WAV (звуковые) в образце MFC с дополнительными концепциями [спеакн](../overview/visual-cpp-samples.md) .

Можно включить посредством оператора #include файл SECOND.RC в директивы времени выполнения в диалоговом окне "Включение наборов".

```h
#include "res\myapp.rc2"  // non-Visual C++ edited resources
#include "second.rc"  // THE SECOND .RC FILE

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
```

Результат показан на следующей схеме.

```Diagram
   RESOURCE.H     AFXRES.H
          \       /
           \     /
          MYAPP.RC
              |
              |
        RES\MYAPP.RC2
        SECOND.RC  
        AFXRES.RC
        AFXPRINT.RC
```

С помощью директив времени компиляции можно организовать редактируемые и нередактируемые в Visual C++ ресурсы в несколько RC-файлов, где "главный" файл MYAPP.RC не делает ничего, кроме включения других RC-файлов посредством оператора #include. Если вы используете проект Visual Studio C++ . Файл MAK, необходимо включить "Master". RC-файл в проекте, чтобы все #include ресурсы были скомпилированы вместе с приложением.

## <a name="enforcement-of-noneditable-visual-c-files"></a>Принудительная реализация нередактируемых в Visual C++ файлов

Созданный помощью мастера РЕС\МЯПП. RC2-файл — это пример файла, который содержит ресурсы, которые *не* нужно случайным образом читать в визуальном C++ элементе, а затем записывать их с потерей сведений о форматировании. Чтобы избежать этого, поместите следующие строки в начало файла RES\MYAPP.RC2:

```rc2
#ifdef APSTUDIO_INVOKED
    #error this file is not editable by Visual C++
#endif //APSTUDIO_INVOKED
```

Когда Visual C++ компилирует. RC-файл, он определяет `APSTUDIO_INVOKED`, а также `RC_INVOKED`. Если структура созданного мастером приложений файла повреждена и Visual C++ считывает строку #error выше, он сообщает о неустранимой ошибке и прерывает чтение RC-файла.

## <a name="managing-symbols-shared-by-multiple-visual-c-edited-rc-files"></a>Управление символами, которые совместно используются несколькими RC-файлами, редактируемыми в Visual C++

При разделении ресурсов на несколько RC-файлов, которые требуется редактировать в Visual C++ по отдельности, возникает две проблемы:

- Может потребоваться использовать одни и те же символы в нескольких RC-файлах.

- Необходимо сделать так, чтобы Visual C++ не назначала одни и те же числовые идентификаторы разным ресурсам (символам).

На следующей схеме показана организация RC- и H-файлов, в которых решается первая проблема.

```Diagram
              MYAPP.RC
             /         \
            /           \
MYSTRS.H   / MYSHARED.H  \  MYMENUS.H
     \    /    /      \   \    \
      \  /    /        \   \    \
      MYSTRS.RC         MYMENUS.RC
```

В этом примере строковые ресурсы хранятся в одном файле ресурсов, MYSTRS.RC, а меню хранятся в другом — MYMENUS.RC. Некоторые символы, например, команды, нужно будет совместно использовать в обоих файлах. Например, ID_TOOLS_SPELL может являться идентификатором команды меню элемента "Правописание" в меню "Сервис" и одновременно строковым идентификатором командной строки, отображаемой платформой в строке статуса главного окна приложения.

Символ ID_TOOLS_SPELL хранится в общем файле заголовка, MYSHARED.H. Обслуживание этого общего файла заголовка осуществляется вручную в текстовом редакторе; Visual C++ не поддерживает его прямое редактирование. В двух файлах ресурсов МИСТРС. Версии-кандидат и МИМЕНУС. RC, укажите #include МИШАРЕД. H в директивах только для чтения для MYAPP. Версия-кандидат с использованием команды **Resource включает** команду, как описано выше.

Перед тем как пытаться использовать его для распознавания любого ресурса, лучше всего предвидеть символ, который будет использоваться совместно. Добавьте символ в общий файл заголовка и если общий файл заголовков еще не включен в доступные только для чтения директивы для RC-файла посредством оператора #include, сделайте это до начала использования символа. Если совместное использование символа подобным образом не предусматривалось, необходимо вручную (с помощью текстового редактора) переместить оператор #define для этого символа из файла MYMENUS.H в файл MYSHARED.H, прежде чем приступать к использованию символа в файле MYSTRS.RC.

При управлении символами в нескольких RC-файлах необходимо также запретить Visual C++ назначать одни и те же значения числового идентификатора разным ресурсам (символам). Для любого заданного RC-файла Visual C++ последовательно присваивает идентификаторы в каждом из четырех доменов ИД. Между сеансами редактирования Visual C++ отслеживает последний присвоенный идентификатор в каждом домене файла символов заголовков для RC-файла. Вот как выглядят значения APS_NEXT для пустого (нового) RC-файла:

```rc
#define _APS_NEXT_RESOURCE_VALUE  101
#define _APS_NEXT_COMMAND_VALUE   40001
#define _APS_NEXT_CONTROL_VALUE   1000
#define _APS_NEXT_SYMED_VALUE     101
```

`_APS_NEXT_RESOURCE_VALUE` — это значение следующего символа, которое будет использоваться для ресурса диалогового окна, ресурса меню и т. д. Допустимый диапазон значений символов ресурсов — от 1 до 0x6FFF.

`_APS_NEXT_COMMAND_VALUE` — это значение следующего символа, которое будет использоваться для идентификации команды. Допустимый диапазон значений символов команд — от 0x8000 до 0xDFFF.

`_APS_NEXT_CONTROL_VALUE` — это значение следующего символа, которое будет использоваться для элемента управления диалогового окна. Допустимый диапазон значений символов элемента управления "диалоговое окно" — от 8 до 0xDFFF.

`_APS_NEXT_SYMED_VALUE` — это значение следующего символа, которое будет выдаваться при ручном назначении значения символа с помощью команды создать в обозревателе символов.

При создании нового RC-файла Visual C++ начинает с немного более высоких значений, чем наинизшее допустимое значение. AppWizard также инициализирует эти значения с использованием чего-либо более подходящего для приложений MFC. Дополнительные сведения о диапазонах значений ИДЕНТИФИКАТОРов см. в [техническом примечании 20](../mfc/tn020-id-naming-and-numbering-conventions.md).

Теперь каждый раз, когда вы создаете новый файл ресурсов, даже в том же проекте C++ , Visual определяет те же значения `_APS_NEXT_`. Это означает, что при добавлении, допустим, нескольких диалоговых окон в два разных RC-файла очень вероятно, что одно и то же значение #define будет назначено разным диалоговым окнам. Например, параметру IDD_MY_DLG1 в первом RC-файле может быть присвоено то же число (101), что и параметру IDD_MY_DLG2 во втором RC-файле.

Чтобы избежать этого, необходимо зарезервировать отдельный числовой диапазон для каждого из четырех доменов идентификаторов в соответствующих RC-файлах. Для этого вручную обновите значения `_APS_NEXT` в каждом из них. RC-файлы **перед** началом добавления ресурсов. Например, если первый. RC-файл использует значения `_APS_NEXT` по умолчанию. затем может потребоваться присвоить второму `_APS_NEXT` следующие значения. RC-файл:

```rc
#define _APS_NEXT_RESOURCE_VALUE  2000
#define _APS_NEXT_COMMAND_VALUE   42000
#define _APS_NEXT_CONTROL_VALUE   2000
#define _APS_NEXT_SYMED_VALUE     2000
```

Конечно, все еще возможно, что Visual C++ присвоит в первом RC-файле столько идентификаторов, что числовые значения начнут перекрывать зарезервированные для второго RC-файла. Необходимо зарезервировать достаточно крупные диапазоны, чтобы этого не произошло.

## <a name="managing-dependencies-between-rc-cpp-and-h-files"></a>Управление зависимостями между RC-, CPP- и H-файлами

Если Visual C++ сохраняет RC-файл, он также сохраняет изменения символов в соответствующем файле RESOURCE.H. Любой из CPP-файлов, ссылающихся на ресурсы в RC-файле, должен включать посредством оператора #include файл RESOURCE.H, обычно из главного файла заголовка проекта. Это приводит к нежелательному побочному эффекту: внутренняя система управления проектами среды разработки сканирует исходные файлы на наличие зависимостей заголовков. Каждый раз, когда вы добавляете новый символ C++в визуальный элемент, все. CPP файлы, #include ресурс. Необходимо перекомпилировать H.

Visual C++ обходит зависимость от RESOURCE.H, включая следующий комментарий в качестве первой строки файла RESOURCE.H:

```h
//{{NO_DEPENDENCIES}}
```

Среда разработки интерпретирует этот комментарий, игнорируя изменения файла RESOURCE.H таким образом, что CPP-файлам не потребуется повторная компиляция.

Visual C++ всегда добавляет строку комментариев //{{NO_DEPENDENCIES}} в RC-файл при сохранении. В некоторых случаях обход зависимости сборки от файла RESOURCE.H может вызвать ошибки во время выполнения, которые невозможно обнаружить во время компоновки. Например, если браузер символов используется для изменения числового значения, присвоенного символу для ресурса, ресурс не будет правильно найден и загружен во время выполнения приложения, если ссылающийся на этот ресурс CPP-файл не перекомпилирован. В таких случаях следует явно выполнить повторную компиляцию. Файлы CPP, на которые вы знакомы, зависят от изменений символов в РЕСУРСе. H или выберите **перестроить все**. Если есть необходимость часто изменять значения символов для определенной группы ресурсов, возможно, вам будет удобнее и безопасно разбивать эти символы в отдельный файл заголовка только для чтения, как описано в приведенном выше разделе, [включая дополнительные файлы заголовков](#_mfcnotes_tn035_including).

## <a name="_mfcnotes_tn035_set_includes"></a>Как визуальные элементы C++ управления включают сведения

Как сказано выше, команда "Включение наборов" меню "Файл" позволяет задать три типа сведений.

- Файл символов заголовка

- Директивы символов только для чтения

- Директивы времени компиляции

Далее описывается обслуживание этой информации Visual C++ в RC-файле. Для работы с Visual C++ эта информация не является обязательной, однако она обеспечивает дополнительное понимание вопроса и позволяет использовать возможность "Включение наборов" более уверенно.

Каждый из описанных выше трех типов сведений "Включение наборов" хранится в RC-файле в двух формах: (1) как оператор #include или другие директивы, интерпретируемые компилятором ресурсов, и как (2) специальные ресурсы TEXTINCLUDE, интерпретируемые только Visual C++.

Цель ресурса ресурса TEXTINCLUDE заключается в том, чтобы безопасно хранить набор данных в форме, которая доступна в диалоговом окне " C++ **набор включаемых** элементов". РЕСУРСА TEXTINCLUDE — это *тип ресурса* , определенный визуальным C++объектом. Visual C++ распознает три определенных ресурса TEXTINCLUDE с идентификационными номерами 1, 2 и 3.

|Идентификатор ресурса TEXTINCLUDE|Тип сведений "Включение наборов"|
|-----------------------------|--------------------------------------|
|1|Файл символов заголовка|
|2|Директивы символов только для чтения|
|3|Директивы времени компиляции|

Каждый из трех типов сведений "Включение наборов" иллюстрируется файлами по умолчанию MYAPP.RC и RESOURCE.H, созданными мастером приложений, как описано ниже. Дополнительные токены \0 и "" между блоками BEGIN и END требуются синтаксису RC для задания завершаемых нулем строк и символа двойных кавычек соответственно.

### <a name="symbol-header-file"></a>Файл символов заголовка

Форма данных файла символов заголовков, интерпретируемая компилятором ресурсов, — это просто оператор #include:

```rc
#include "resource.h"
```

Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:

```rc
1 TEXTINCLUDE DISCARDABLE
BEGIN
    "resource.h\0"
END
```

### <a name="read-only-symbol-directives"></a>Директивы символов только для чтения

Доступные только для чтения директивы включены в начало файла MYAPP.RC в следующей форме, доступной для интерпретации компилятором ресурсов:

```rc
#include "afxres.h"
```

Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:

```rc
2 TEXTINCLUDE DISCARDABLE
BEGIN
   "#include ""afxres.h""\r\n"
   "\0"
END
```

### <a name="compile-time-directives"></a>Директивы времени компиляции

Директивы времени выполнения включены в конец файла MYAPP.RC в следующей форме, доступной для интерпретации компилятором ресурсов:

```rc
#ifndef APSTUDIO_INVOKED
///////////////////////
//
// From TEXTINCLUDE 3
//
#include "res\myapp.rc2"  // non-Visual C++ edited resources

#include "afxres.rc"  // Standard components
#include "afxprint.rc"  // printing/print preview resources
#endif  // not APSTUDIO_INVOKED
```

Директива #ifndef APSTUDIO_INVOKED отправляет Visual C++ инструкцию о необходимости пропустить директивы времени выполнения.

Соответствующий ресурс TEXTINCLUDE выглядит следующим образом:

```rc
3 TEXTINCLUDE DISCARDABLE
BEGIN
"#include ""res\myapp.rc2""  // non-Visual C++ edited resources\r\n"
"\r\n"
"#include ""afxres.rc""  // Standard components\r\n"
"#include ""afxprint.rc""  // printing/print preview resources\r\n"
"\0"
END
```

## <a name="see-also"></a>См. также:

[Технические примечания по числу](../mfc/technical-notes-by-number.md)\
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
