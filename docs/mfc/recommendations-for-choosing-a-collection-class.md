---
title: Рекомендации по выбору класса коллекции
ms.date: 11/04/2016
helpviewer_keywords:
- type safety of collection classes [MFC]
- collection classes [MFC], serialization
- collection classes [MFC], speed
- collection classes [MFC], type safety
- collection classes [MFC], choosing
- collection classes [MFC], functionality
- shapes, collection
- collection classes [MFC], template-based
- MFC collection classes [MFC], characteristics
- collection classes [MFC], about collection classes [MFC]
- serialization [MFC], collection classes
- collection classes [MFC], duplicates allowed
- collection classes [MFC], shapes
ms.assetid: a82188cd-443f-40d8-a244-edf292a53db4
ms.openlocfilehash: c72a57385b0036d98629d1ee24111500b9d2f8ad
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57288042"
---
# <a name="recommendations-for-choosing-a-collection-class"></a>Рекомендации по выбору класса коллекции

Эта статья содержит подробные сведения, которые помогут вам выбрать класс коллекции для конкретного приложения.

Выбор класса коллекции зависит от ряда факторов, включая приведенные далее.

- Возможности формы класса: упорядочение, индексирование и производительность, как показано в таблице [Функции форм коллекции](#_core_collection_shape_features) далее в этом документе.

- Использует ли класс шаблоны C++

- Можно ли сериализовать элементы, хранящиеся в коллекции

- Можно ли поместить эти элементы в дамп для диагностики

- Является ли коллекция типобезопасной

В следующей таблице [Функции форм коллекции](#_core_collection_shape_features)приведены характеристики доступных форм коллекций.

- В столбцах 2 и 3 приведены характеристики упорядочения и доступа к каждой форме. В таблице термин "упорядочивается" означает, что порядок вставки и удаления элементов определяет их порядок в коллекции. Это не значит, что элементы сортируются по своему содержимому. Термин "индексируется" означает, что элементы в коллекции можно получать с помощью целочисленного индекса, как элементы в обычном массиве.

- В столбцах 4 и 5 описывается производительность каждой формы. В приложениях, требующих большого количества вставок в коллекцию, особое значение может иметь скорость вставки, тогда как в других приложениях наиболее важной может оказаться скорость поиска.

- В столбце 6 указывается допустимость повторяющихся элементов в форме.

### <a name="_core_collection_shape_features"></a>  Функции форм коллекции

|Фигура|Упорядоченного|Индексировать|Вставка элемента|Поиск указанного элемента|Повторяющиеся элементы|
|-----------|--------------|--------------|-----------------------|----------------------------------|-------------------------|
|Список|Да|Нет|Быстрый|Медленно|Да|
|Массив|Да|По целому числу|Медленно|Медленно|Да|
|Карта|Нет|По ключу|Быстрый|Быстрый|Нет (ключи) Да (значения)|

В следующей таблице [Характеристики классов коллекций MFC](#_core_characteristics_of_mfc_collection_classes)представлены другие важные характеристики определенных классов коллекций MFC. Их можно использовать в качестве руководства по выбору. Выбор зависит от следующих факторов: основан ли класс на шаблонах C++, могут ли его элементы быть сериализованы посредством механизма [сериализации](../mfc/serialization-in-mfc.md) документов MFC, могут ли его элементы быть помещены в дамп посредством механизма записи в дамп для диагностики, является ли класс типобезопасным (т. е. можно ли гарантировать тип элементов, хранящихся в коллекции и извлекаемых из нее, на основе класса).

### <a name="_core_characteristics_of_mfc_collection_classes"></a>  Характеристики классов коллекций MFC

|Класс|Использует C++<br /><br /> шаблоны|Может быть<br /><br /> Сериализуются|Может быть<br /><br /> помещен в дамп|Является<br /><br /> типобезопасный|
|-----------|------------------------------|---------------------------|-----------------------|-----------------------|
|`CArray`|Да|Да 1|Да 1|Нет|
|`CByteArray`|Нет|Да|Да|Да 3|
|`CDWordArray`|Нет|Да|Да|Да 3|
|`CList`|Да|Да 1|Да 1|Нет|
|`CMap`|Да|Да 1|Да 1|Нет|
|`CMapPtrToPtr`|Нет|Нет|Да|Нет|
|`CMapPtrToWord`|Нет|Нет|Да|Нет|
|`CMapStringToOb`|Нет|Да|Да|Нет|
|`CMapStringToPtr`|Нет|Нет|Да|Нет|
|`CMapStringToString`|Нет|Да|Да|Да 3|
|`CMapWordToOb`|Нет|Да|Да|Нет|
|`CMapWordToPtr`|Нет|Нет|Да|Нет|
|`CObArray`|Нет|Да|Да|Нет|
|`CObList`|Нет|Да|Да|Нет|
|`CPtrArray`|Нет|Нет|Да|Нет|
|`CPtrList`|Нет|Нет|Да|Нет|
|`CStringArray`|Нет|Да|Да|Да 3|
|`CStringList`|Нет|Да|Да|Да 3|
|`CTypedPtrArray`|Да|Зависит от обстоятельств 2|Да|Да|
|`CTypedPtrList`|Да|Зависит от обстоятельств 2|Да|Да|
|`CTypedPtrMap`|Да|Зависит от обстоятельств 2|Да|Да|
|`CUIntArray`|Нет|Нет|Да|Да 3|
|`CWordArray`|Нет|Да|Да|Да 3|

1. Для сериализации необходимо явным образом вызвать функцию `Serialize` объекта коллекции. Для помещения в дамп необходимо явным образом вызвать его функцию `Dump`. Для сериализации нельзя использовать форму `ar << collObj` , для помещения в дамп нельзя использовать форму `dmp` `<< collObj` .

2. Возможность сериализации зависит от базового типа коллекции. Например, если массив типизированных указателей основан на `CObArray`, он поддерживает сериализацию. Если он основан на `CPtrArray`, его нельзя сериализовать. В общем случае классы Ptr нельзя сериализовать.

3. Если в этом столбце указано значение "Да", нешаблонный класс коллекции является типобезопасным (при условии его использования надлежащим образом). Например, при сохранении байтов в `CByteArray`массив является типобезопасным. Однако если он используется для хранения символов, его типобезопасность не столь очевидна.

## <a name="see-also"></a>См. также

[Коллекции](../mfc/collections.md)<br/>
[Классы на основе шаблонов](../mfc/template-based-classes.md)<br/>
[Практическое руководство. Создание безопасных типов коллекций](../mfc/how-to-make-a-type-safe-collection.md)<br/>
[Доступ ко всем членам коллекции](../mfc/accessing-all-members-of-a-collection.md)
