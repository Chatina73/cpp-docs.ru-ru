---
title: TN002. Формат данных постоянного объекта
ms.date: 11/04/2016
helpviewer_keywords:
- VERSIONABLE_SCHEMA macro [MFC]
- persistent object data
- CArchive class [MFC], support for persistent data
- persistent C++ objects [MFC]
- TN002
ms.assetid: 553fe01d-c587-4c8d-a181-3244a15c2be9
ms.openlocfilehash: 1880d5d43055966dea8ab16dc4f26bd4e4602ec5
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79447125"
---
# <a name="tn002-persistent-object-data-format"></a>TN002. Формат данных постоянного объекта

Это примечание описывает подпрограммы MFC, которые поддерживают постоянные C++ объекты и формат данных объекта при хранении в файле. Это относится только к классам с макросами [DECLARE_SERIAL](../mfc/reference/run-time-object-model-services.md#declare_serial) и [IMPLEMENT_SERIAL](../mfc/reference/run-time-object-model-services.md#implement_serial) .

## <a name="the-problem"></a>Проблема

Реализация MFC для постоянных данных хранит данные для многих объектов в одной непрерывной части файла. Метод `Serialize` объекта преобразует данные объекта в компактный двоичный формат.

Реализация гарантирует, что все данные сохраняются в том же формате с помощью [класса CArchive](../mfc/reference/carchive-class.md). Он использует объект `CArchive` в качестве транслятора. Этот объект сохраняется с момента создания, пока не будет вызван метод [CArchive:: Close](../mfc/reference/carchive-class.md#close). Этот метод можно вызывать явным образом программистом или неявно с помощью деструктора, когда программа выходит из области, содержащей `CArchive`.

Это примечание описывает реализацию членов `CArchive` [CArchive:: вызове ReadObject](../mfc/reference/carchive-class.md#readobject) и [CArchive:: WriteObject](../mfc/reference/carchive-class.md#writeobject). Код для этих функций можно найти в Аркобж. cpp, а основная реализация для `CArchive` в Арккоре. cpp. Пользовательский код не вызывает `ReadObject` и `WriteObject` напрямую. Вместо этого эти объекты используются в строго определяемых классом операторах вставки и извлечения, которые создаются автоматически DECLARE_SERIAL и IMPLEMENT_SERIAL макросами. В следующем коде показано, как неявно вызываются `WriteObject` и `ReadObject`:

```
class CMyObject : public CObject
{
    DECLARE_SERIAL(CMyObject)
};

IMPLEMENT_SERIAL(CMyObj, CObject, 1)

// example usage (ar is a CArchive&)
CMyObject* pObj;
CArchive& ar;
ar <<pObj;        // calls ar.WriteObject(pObj)
ar>> pObj;        // calls ar.ReadObject(RUNTIME_CLASS(CObj))
```

## <a name="saving-objects-to-the-store-carchivewriteobject"></a>Сохранение объектов в хранилище (CArchive:: WriteObject)

Метод `CArchive::WriteObject` записывает данные заголовка, которые используются для восстановления объекта. Эти данные состоят из двух частей: типа объекта и состояния объекта. Этот метод также отвечает за поддержание идентификатора записываемого объекта, чтобы сохранялась только одна копия, независимо от числа указателей на этот объект (включая циклические указатели).

Сохранение (вставка) и восстановление (извлечение) объектов основано на нескольких "константах манифеста". Это значения, которые хранятся в двоичном файле и содержат важную информацию для архива (Обратите внимание, что префикс "w" означает 16-битные количества):

|Тег|Description|
|---------|-----------------|
|внуллтаг|Используется для указателей на объекты NULL (0).|
|вневкласстаг|Указывает, что следующее описание класса является новым для этого контекста архива (-1).|
|волдкласстаг|Указывает, что класс считываемого объекта показан в данном контексте (0x8000).|

При хранении объектов Архив поддерживает [кмапптртоптр](../mfc/reference/cmapptrtoptr-class.md) ( *m_pStoreMap*), который представляет собой сопоставление хранимого объекта с 32-битным постоянным идентификатором (PID). Идентификатор процесса назначается каждому уникальному объекту и каждому уникальному имени класса, сохраненному в контексте архива. Эти идентификаторы PID передаются последовательно, начиная с 1. Эти идентификаторы PID не имеют значимости за пределами области архива, и, в частности, не следует путать с номерами записей или другими элементами удостоверений.

В классе `CArchive` идентификаторы PID являются 32-разрядными, но они записываются как 16-разрядные, если они больше, чем 0x7FFE. Крупные идентификаторы процесса записываются как 0x7FFF, за которым следует 32-разрядный PID. Это обеспечивает совместимость с проектами, созданными в более ранних версиях.

При запросе на сохранение объекта в архиве (обычно с помощью оператора глобального вставки) выполняется проверка для неопределенного указателя [CObject](../mfc/reference/cobject-class.md) . Если указатель равен NULL, *внуллтаг* вставляется в поток архива.

Если указатель не имеет значение NULL и может быть сериализован (класс является `DECLARE_SERIAL`ным классом), код проверяет *m_pStoreMap* , чтобы увидеть, был ли уже сохранен объект. Если он есть, код вставляет 32-разрядный PID, связанный с этим объектом, в поток архива.

Если объект не был сохранен ранее, есть две возможности: как объект, так и точный тип (т. е. класс) объекта являются новыми для этого контекста архива, или объект имеет точный тип, который уже встречается. Чтобы определить, обнаружен ли тип, код запрашивает *m_pStoreMap* для объекта [крунтимекласс](../mfc/reference/cruntimeclass-structure.md) , соответствующего объекту `CRuntimeClass`, связанному с сохраняемым объектом. При совпадении `WriteObject` вставляет тег, который является побитовым `OR`ом *волдкласстаг* и этим индексом. Если `CRuntimeClass` является новым для этого контекста архива, `WriteObject` присваивает этому классу новый идентификатор процесса и вставляет его в архив, перед которым следует значение *вневкласстаг* .

Дескриптор для этого класса затем вставляется в архив с помощью метода `CRuntimeClass::Store`. `CRuntimeClass::Store` вставляет номер схемы класса (см. ниже) и текстовое имя в формате ASCII для класса. Обратите внимание, что использование текстового имени ASCII не гарантирует уникальность архива в разных приложениях. Поэтому следует пометить файлы данных, чтобы предотвратить повреждение. После вставки сведений о классе архив помещает объект в *m_pStoreMap* , а затем вызывает метод `Serialize` для вставки данных, относящихся к классу. Помещение объекта в *m_pStoreMap* перед вызовом `Serialize` предотвращает сохранение нескольких копий объекта в хранилище.

При возврате к первоначальному вызывающему объекту (обычно это корень сети объектов) необходимо вызвать [CArchive:: Close](../mfc/reference/carchive-class.md#close). Если вы планируете выполнять другие операции [кфиле](../mfc/reference/cfile-class.md), необходимо вызвать [Сброс](../mfc/reference/carchive-class.md#flush) метода `CArchive`, чтобы предотвратить повреждение архива.

> [!NOTE]
>  Эта реализация накладывает жесткое ограничение индексов 0x3FFFFFFE на контекст архива. Это число представляет максимальное число уникальных объектов и классов, которые могут быть сохранены в одном архиве, но один дисковый файл может иметь неограниченное количество контекстов архивации.

## <a name="loading-objects-from-the-store-carchivereadobject"></a>Загрузка объектов из хранилища (CArchive:: вызове ReadObject)

При загрузке (извлечении) объектов используется метод `CArchive::ReadObject`, который является обратным `WriteObject`. Как и в случае с `WriteObject`, `ReadObject` не вызывается напрямую кодом пользователя; Пользовательский код должен вызывать строго типизированный оператор извлечения, который вызывает `ReadObject` с ожидаемым `CRuntimeClass`. Это гарантирует целостность типа операции извлечения.

Так как реализация `WriteObject` назначила увеличение PID, начиная с 1 (определено значение 0 в качестве объекта NULL), реализация `ReadObject` может использовать массив для поддержания состояния контекста архива. Если идентификатор процесса считывается из хранилища, если идентификатор процесса больше, чем текущая верхняя граница *m_pLoadArray*, `ReadObject` знать, что следует новый объект (или описание класса).

## <a name="schema-numbers"></a>Номера схем

Номер схемы, который назначается классу при обнаружении метода `IMPLEMENT_SERIAL` класса, — это "версия" реализации класса. Схема относится к реализации класса, а не к числу случаев, когда данный объект был сделан постоянным (обычно называется версией объекта).

Если вы планируете поддерживать несколько различных реализаций одного и того же класса с течением времени, увеличение схемы при изменении реализации метода `Serialize` объекта позволит вам написать код, который может загружать объекты, хранящиеся с помощью старых версий реализации.

Метод `CArchive::ReadObject` вызовет исключение [карчивиксцептион](../mfc/reference/carchiveexception-class.md) при обнаружении номера схемы в постоянном хранилище, которое отличается от номера схемы в описании класса в памяти. Восстановление после этого исключения нелегко.

Вы можете использовать `VERSIONABLE_SCHEMA` в сочетании с (побитовой **или**) версией схемы, чтобы предотвратить возникновение этого исключения. С помощью `VERSIONABLE_SCHEMA`код может предпринять соответствующее действие в `Serialize`ной функции, проверив возвращаемое значение из [CArchive:: жетобжектсчема](../mfc/reference/carchive-class.md#getobjectschema).

## <a name="calling-serialize-directly"></a>Прямой вызов функции Serialize

Во многих случаях затраты на общую архивную схему объекта `WriteObject` и `ReadObject` не требуются. Это распространенный случай сериализации данных в [CDocument](../mfc/reference/cdocument-class.md). В этом случае метод `Serialize` `CDocument` вызывается напрямую, а не с помощью операторов Extract или INSERT. Содержимое документа, в свою очередь, может использовать более общую схему архива объектов.

Вызов `Serialize` напрямую имеет следующие преимущества и недостатки:

- Дополнительные байты не добавляются в архив до или после сериализации объекта. Это не только уменьшает размер сохраненных данных, но и позволяет реализовать `Serialize` подпрограммы, которые могут работать с любыми форматами файлов.

- Библиотека MFC настроена таким образом, что `WriteObject` и `ReadObject` реализации и связанные коллекции не будут связаны с вашим приложением, если вам не нужна более общая схема архивации объектов для какой-либо другой цели.

- Код не должен восстанавливаться из старых номеров схем. Это делает код сериализации документа ответственным за кодирование номеров схем, номеров версий форматов файлов или любых идентификационных номеров, используемых в начале файлов данных.

- Любой объект, сериализуемый с прямым вызовом `Serialize` не должен использовать `CArchive::GetObjectSchema` или должен поддерживать возвращаемое значение (UINT)-1, указывающее, что версия неизвестна.

Поскольку `Serialize` вызывается непосредственно в документе, для вложенных объектов документа нельзя архивировать ссылки на их родительский документ. Этим объектам необходимо явно предоставить указатель на документ контейнера или использовать функцию [CArchive:: мапобжект](../mfc/reference/carchive-class.md#mapobject) для отображения `CDocument` указателя на идентификатор процесса перед архивированием этих резервных указателей.

Как отмечалось ранее, необходимо кодировать сведения о версии и классе самостоятельно при вызове `Serialize` напрямую, что позволяет изменить формат позже, сохраняя при этом обратную совместимость со старыми файлами. Функцию `CArchive::SerializeClass` можно вызвать явным образом перед прямой сериализацией объекта или перед вызовом базового класса.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
