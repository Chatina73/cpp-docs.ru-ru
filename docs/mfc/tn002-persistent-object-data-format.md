---
description: 'Дополнительные сведения о: TN002: формат данных постоянного объекта'
title: TN002. Формат данных постоянного объекта
ms.date: 11/04/2016
helpviewer_keywords:
- VERSIONABLE_SCHEMA macro [MFC]
- persistent object data
- CArchive class [MFC], support for persistent data
- persistent C++ objects [MFC]
- TN002
ms.assetid: 553fe01d-c587-4c8d-a181-3244a15c2be9
ms.openlocfilehash: e99d54bd2624bffac4f5fea37c72bb7719e1e408
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97216084"
---
# <a name="tn002-persistent-object-data-format"></a>TN002. Формат данных постоянного объекта

Это примечание описывает подпрограммы MFC, поддерживающие постоянные объекты C++, и формат данных объекта, хранящихся в файле. Это относится только к классам с макросами [DECLARE_SERIAL](../mfc/reference/run-time-object-model-services.md#declare_serial) и [IMPLEMENT_SERIAL](../mfc/reference/run-time-object-model-services.md#implement_serial) .

## <a name="the-problem"></a>Проблема

Реализация MFC для постоянных данных хранит данные для многих объектов в одной непрерывной части файла. `Serialize`Метод объекта преобразует данные объекта в компактный двоичный формат.

Реализация гарантирует, что все данные сохраняются в том же формате с помощью [класса CArchive](../mfc/reference/carchive-class.md). Он использует `CArchive` объект в качестве транслятора. Этот объект сохраняется с момента создания, пока не будет вызван метод [CArchive:: Close](../mfc/reference/carchive-class.md#close). Этот метод можно вызывать явным образом программистом или неявно с помощью деструктора, когда программа выходит из области, содержащей `CArchive` .

Это примечание описывает реализацию `CArchive` членов [CArchive:: вызове ReadObject](../mfc/reference/carchive-class.md#readobject) и [CArchive:: WriteObject](../mfc/reference/carchive-class.md#writeobject). Код для этих функций можно найти в Аркобж. cpp, а основная реализация — `CArchive` в арккоре. cpp. Пользовательский код не вызывает `ReadObject` и `WriteObject` напрямую. Вместо этого эти объекты используются в строго определяемых классом операторах вставки и извлечения, которые создаются автоматически DECLARE_SERIAL и IMPLEMENT_SERIAL макросами. В следующем коде показано, как `WriteObject` и `ReadObject` неявно вызываются:

```
class CMyObject : public CObject
{
    DECLARE_SERIAL(CMyObject)
};

IMPLEMENT_SERIAL(CMyObj, CObject, 1)

// example usage (ar is a CArchive&)
CMyObject* pObj;
CArchive& ar;
ar <<pObj;        // calls ar.WriteObject(pObj)
ar>> pObj;        // calls ar.ReadObject(RUNTIME_CLASS(CObj))
```

## <a name="saving-objects-to-the-store-carchivewriteobject"></a>Сохранение объектов в хранилище (CArchive:: WriteObject)

Метод `CArchive::WriteObject` записывает данные заголовка, которые используются для восстановления объекта. Эти данные состоят из двух частей: типа объекта и состояния объекта. Этот метод также отвечает за поддержание идентификатора записываемого объекта, чтобы сохранялась только одна копия, независимо от числа указателей на этот объект (включая циклические указатели).

Сохранение (вставка) и восстановление (извлечение) объектов основано на нескольких "константах манифеста". Это значения, которые хранятся в двоичном файле и содержат важную информацию для архива (Обратите внимание, что префикс "w" означает 16-битные количества):

|Тег|Описание|
|---------|-----------------|
|внуллтаг|Используется для указателей на объекты NULL (0).|
|вневкласстаг|Указывает, что следующее описание класса является новым для этого контекста архива (-1).|
|волдкласстаг|Указывает, что класс считываемого объекта показан в данном контексте (0x8000).|

При хранении объектов Архив поддерживает [кмапптртоптр](../mfc/reference/cmapptrtoptr-class.md) ( *m_pStoreMap*), который представляет собой сопоставление хранимого объекта с 32-битным постоянным идентификатором (PID). Идентификатор процесса назначается каждому уникальному объекту и каждому уникальному имени класса, сохраненному в контексте архива. Эти идентификаторы PID передаются последовательно, начиная с 1. Эти идентификаторы PID не имеют значимости за пределами области архива, и, в частности, не следует путать с номерами записей или другими элементами удостоверений.

В классе идентификаторы `CArchive` PID являются 32-разрядными, но они записываются как 16-разрядные, если они больше 0x7FFE. Крупные идентификаторы процесса записываются как 0x7FFF, за которым следует 32-разрядный PID. Это обеспечивает совместимость с проектами, созданными в более ранних версиях.

При запросе на сохранение объекта в архиве (обычно с помощью оператора глобального вставки) выполняется проверка для неопределенного указателя [CObject](../mfc/reference/cobject-class.md) . Если указатель равен NULL, *внуллтаг* вставляется в поток архива.

Если указатель не имеет значение NULL и может быть сериализован (класс является `DECLARE_SERIAL` классом), код проверяет *m_pStoreMap* , чтобы увидеть, был ли уже сохранен объект. Если он есть, код вставляет 32-разрядный PID, связанный с этим объектом, в поток архива.

Если объект не был сохранен ранее, есть две возможности: как объект, так и точный тип (т. е. класс) объекта являются новыми для этого контекста архива, или объект имеет точный тип, который уже встречается. Чтобы определить, виден ли тип, код запрашивает *m_pStoreMap* для объекта [крунтимекласс](../mfc/reference/cruntimeclass-structure.md) , соответствующего `CRuntimeClass` объекту, связанному с сохраняемым объектом. Если имеется совпадение, `WriteObject` вставляет тег, который является побитовой `OR` *волдкласстаг* и этим индексом. Если вы `CRuntimeClass` не знакомы с этим контекстом архива, `WriteObject` назначает новый идентификатор процесса этому классу и вставляете его в архив, перед которым следует значение *вневкласстаг* .

Дескриптор для этого класса затем вставляется в архив с помощью `CRuntimeClass::Store` метода. `CRuntimeClass::Store` Вставляет номер схемы класса (см. ниже) и текстовое имя в формате ASCII для класса. Обратите внимание, что использование текстового имени ASCII не гарантирует уникальность архива в разных приложениях. Поэтому следует пометить файлы данных, чтобы предотвратить повреждение. После вставки сведений о классе архив помещает объект в *m_pStoreMap* , а затем вызывает `Serialize` метод для вставки данных, относящихся к классу. Помещение объекта в *m_pStoreMap* перед вызовом `Serialize` предотвращает сохранение нескольких копий объекта в хранилище.

При возврате к первоначальному вызывающему объекту (обычно это корень сети объектов) необходимо вызвать [CArchive:: Close](../mfc/reference/carchive-class.md#close). Если планируется выполнять другие операции [кфиле](../mfc/reference/cfile-class.md), необходимо вызвать `CArchive` [Сброс](../mfc/reference/carchive-class.md#flush) метода, чтобы предотвратить повреждение архива.

> [!NOTE]
> Эта реализация накладывает жесткое ограничение индексов 0x3FFFFFFE на контекст архива. Это число представляет максимальное число уникальных объектов и классов, которые могут быть сохранены в одном архиве, но один дисковый файл может иметь неограниченное количество контекстов архивации.

## <a name="loading-objects-from-the-store-carchivereadobject"></a>Загрузка объектов из хранилища (CArchive:: вызове ReadObject)

При загрузке (извлечении) объектов используется `CArchive::ReadObject` метод, а — обратная часть `WriteObject` . Как и в `WriteObject` , метод `ReadObject` не вызывается непосредственно пользовательским кодом; пользовательский код должен вызывать строго типизированный оператор извлечения, который вызывает `ReadObject` с ожидаемым `CRuntimeClass` . Это гарантирует целостность типа операции извлечения.

Так как `WriteObject` Реализация назначила увеличение PID, начиная с 1 (предопределена как объект null), `ReadObject` реализация может использовать массив для поддержания состояния контекста архива. Если идентификатор процесса считывается из хранилища, если идентификатор процесса больше, чем текущая верхняя граница *m_pLoadArray*, то `ReadObject` известно, что следует новый объект (или описание класса).

## <a name="schema-numbers"></a>Номера схем

Номер схемы, который назначается классу при `IMPLEMENT_SERIAL` обнаружении метода класса, является "версией" реализации класса. Схема относится к реализации класса, а не к числу случаев, когда данный объект был сделан постоянным (обычно называется версией объекта).

Если вы планируете поддерживать несколько различных реализаций одного и того же класса с течением времени, увеличение схемы при изменении `Serialize` реализации метода объекта позволит вам написать код, который может загружать объекты, хранящиеся с помощью старых версий реализации.

`CArchive::ReadObject`Метод вызовет исключение [карчивиксцептион](../mfc/reference/carchiveexception-class.md) при обнаружении номера схемы в постоянном хранилище, которое отличается от номера схемы в описании класса в памяти. Восстановление после этого исключения нелегко.

`VERSIONABLE_SCHEMA`Для предотвращения возникновения этого исключения можно использовать сочетание с (побитовой **или**) версией схемы. С помощью `VERSIONABLE_SCHEMA` код может принять соответствующее действие в своей `Serialize` функции, проверив возвращаемое значение из [CArchive:: жетобжектсчема](../mfc/reference/carchive-class.md#getobjectschema).

## <a name="calling-serialize-directly"></a>Прямой вызов функции Serialize

Во многих случаях затраты на общую архивную схему объекта `WriteObject` и `ReadObject` не являются обязательными. Это распространенный случай сериализации данных в [CDocument](../mfc/reference/cdocument-class.md). В этом случае `Serialize` метод `CDocument` вызывается напрямую, а не с помощью операторов Extract или INSERT. Содержимое документа, в свою очередь, может использовать более общую схему архива объектов.

`Serialize`Прямой вызов имеет следующие преимущества и недостатки:

- Дополнительные байты не добавляются в архив до или после сериализации объекта. Это не только уменьшает размер сохраненных данных, но и позволяет реализовать `Serialize` подпрограммы, которые могут работать с любыми форматами файлов.

- Библиотека MFC настроена таким образом, что `WriteObject` `ReadObject` реализации и связанные с ними коллекции не будут связаны с вашим приложением, если вам не нужна более общая схема архивации объектов для других целей.

- Код не должен восстанавливаться из старых номеров схем. Это делает код сериализации документа ответственным за кодирование номеров схем, номеров версий форматов файлов или любых идентификационных номеров, используемых в начале файлов данных.

- Любой объект, сериализуемый с прямым вызовом, `Serialize` не должен использовать `CArchive::GetObjectSchema` или должен поддерживать возвращаемое значение (UINT)-1, указывающее, что версия неизвестна.

Так как `Serialize` метод вызывается непосредственно в документе, вложенные объекты документа не могут архивировать ссылки на их родительский документ. Этим объектам необходимо явно предоставить указатель на документ контейнера или использовать функцию [CArchive:: мапобжект](../mfc/reference/carchive-class.md#mapobject) для отображения `CDocument` указателя на идентификатор процесса до архивирования этих резервных указателей.

Как отмечалось ранее, следует кодировать сведения о версии и классе самостоятельно при вызове `Serialize` напрямую, что позволяет изменить формат позже, сохраняя при этом обратную совместимость с устаревшими файлами. `CArchive::SerializeClass`Функцию можно вызвать явно перед прямой сериализацией объекта или перед вызовом базового класса.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
