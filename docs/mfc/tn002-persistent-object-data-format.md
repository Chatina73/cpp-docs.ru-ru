---
title: 'TN002: Формат данных постоянного объекта'
ms.date: 11/04/2016
f1_keywords:
- vc.data
helpviewer_keywords:
- VERSIONABLE_SCHEMA macro [MFC]
- persistent object data
- CArchive class [MFC], support for persistent data
- persistent C++ objects [MFC]
- TN002
ms.assetid: 553fe01d-c587-4c8d-a181-3244a15c2be9
ms.openlocfilehash: 6d64799dc17b4b3ddc5c455333b10282e4748b09
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62306198"
---
# <a name="tn002-persistent-object-data-format"></a>TN002: Формат данных постоянного объекта

Эта заметка описывает процедуры MFC, которые поддерживают постоянные объекты C++ и формат данных объекта, когда он хранится в файле. Это относится только к классам с [DECLARE_SERIAL](../mfc/reference/run-time-object-model-services.md#declare_serial) и [IMPLEMENT_SERIAL](../mfc/reference/run-time-object-model-services.md#implement_serial) макросы.

## <a name="the-problem"></a>Проблема

Реализация MFC для постоянных данных хранит данные для нескольких объектов в смежных часть файла. Объекта `Serialize` метод преобразует данные объекта в компактный двоичный формат.

Реализация гарантирует, что все данные сохраняются в том же формате, используя [класс CArchive](../mfc/reference/carchive-class.md). Она использует `CArchive` объект в качестве переводчика. Этот объект будет повторяться с момента его создания до вызова метода [CArchive::Close](../mfc/reference/carchive-class.md#close). Этот метод может вызываться явным образом программистом или неявно деструктором при выходе из программы области, содержащей `CArchive`.

Эта заметка описывает реализацию `CArchive` члены [CArchive::ReadObject](../mfc/reference/carchive-class.md#readobject) и [CArchive::WriteObject](../mfc/reference/carchive-class.md#writeobject). Вы найдете код для этих функций в Arcobj.cpp и реализации для `CArchive` в Arccore.cpp. Пользовательский код вызывает `ReadObject` и `WriteObject` напрямую. Вместо этого эти объекты используются определенного класса безопасных типов операторов вставки и извлечения, автоматически создаваемых DECLARE_SERIAL и IMPLEMENT_SERIAL макросы. В следующем коде показано, как `WriteObject` и `ReadObject` вызываются неявно:

```
class CMyObject : public CObject
{
    DECLARE_SERIAL(CMyObject)
};

IMPLEMENT_SERIAL(CMyObj, CObject, 1)

// example usage (ar is a CArchive&)
CMyObject* pObj;
CArchive& ar;
ar <<pObj;        // calls ar.WriteObject(pObj)
ar>> pObj;        // calls ar.ReadObject(RUNTIME_CLASS(CObj))
```

## <a name="saving-objects-to-the-store-carchivewriteobject"></a>Сохранение объектов Store (CArchive::WriteObject)

Метод `CArchive::WriteObject` записывает данные заголовка, который используется для восстановления объекта. Эти данные состоит из двух частей: тип объекта и состояние объекта. Этот метод также отвечает за обслуживание удостоверение объекта, которая записывается, чтобы иметь возможность сохранять только одну копию, независимо от количества указатели на этот объект (включая циклическая указатели).

Сохранение (Вставка) и восстановление объектов (извлечении) зависит от нескольких «констант манифеста.» Ниже приведены значения, которые хранятся в двоичном формате и содержащие важные сведения в архив (Обратите внимание, что префикс «w» указывает количества 16-разрядное).

|Тег|Описание|
|---------|-----------------|
|wNullTag|Используется для указателей объект NULL (0).|
|wNewClassTag|Указывает, что описание класса, который следует за является новой возможностью в этом контексте архива (-1).|
|wOldClassTag|Указывает, что класс считываемого объекта было показано выше в этом контексте (0x8000).|

Во время хранения объектов, архив сохраняет [CMapPtrToPtr](../mfc/reference/cmapptrtoptr-class.md) ( *m_pStoreMap*) это сопоставление сохраненный объект с 32-разрядных постоянный идентификатор (PID). Код продукта будет назначен каждый уникальный объект и каждого имени уникальным классом, который сохраняется в контексте архива. Эти PID их обработкой и отправкой out последовательно, начиная с 1. Эти PID не имеет значения выходит за рамки архива и, в частности, которые не следует путать с номера записей или других идентификаторов элементов.

В `CArchive` класса, PID являются 32-разрядными, но они записываются как 16-разрядное пока не будут больше, чем 0x7FFE. Большой PID записываются в виде 0x7FFF следуют PID 32-разрядной. Это позволяет поддерживать совместимость с проектами, которые были созданы в более ранних версиях.

При запросе для сохранения объекта в архив (обычно с помощью оператора глобальной вставки), то выполняется проверка значение NULL, [CObject](../mfc/reference/cobject-class.md) указатель. Если указатель имеет значение NULL, *wNullTag* вставляется в поток архива.

Если указатель не равен NULL и может быть сериализован (класс является `DECLARE_SERIAL` класс), этот код проверяет *m_pStoreMap* чтобы увидеть, является ли объект уже сохранен. Если Да, код вставляет 32-разрядных PID, связанные с этим объектом в поток архива.

Если объект ранее не сохранялся, существуют две возможности, которые следует учитывать: либо объект и точный тип объекта (то есть класс) появились к этому контексту архива, или объект имеет точный тип уже видели. Чтобы определить, является ли тип было показано выше, кода запросы *m_pStoreMap* для [CRuntimeClass](../mfc/reference/cruntimeclass-structure.md) объект, который соответствует `CRuntimeClass` объект, связанный с сохраняемый объект. Если есть совпадение имени, `WriteObject` вставляет тег, который является побитовое `OR` из *wOldClassTag* и этот индекс. Если `CRuntimeClass` является новой возможностью в этом контексте архив `WriteObject` назначает новый номер продукта этого класса и вставляет его в архив, предшествует *wNewClassTag* значение.

Дескриптор для данного класса затем вставляется в архив с помощью `CRuntimeClass::Store` метод. `CRuntimeClass::Store` Вставляет номер схемы класса (см. ниже) и ASCII текстовое имя класса. Обратите внимание на то, что использование имени текста ASCII не гарантирует уникальность архива в приложениях. Таким образом следует пометить файлы данных, чтобы предотвратить повреждение. После вставки сведения о классе, архив помещает объект в *m_pStoreMap* , а затем вызывает `Serialize` метод для вставки данных определенного класса. Поместив объект в *m_pStoreMap* перед вызовом `Serialize` предотвращает сохранение в хранилище несколько копий объекта.

Возвращаясь к изначальной вызывающей стороны (обычно корень сетевых объектов), необходимо вызвать метод [CArchive::Close](../mfc/reference/carchive-class.md#close). Если планируется для выполнения других [CFile](../mfc/reference/cfile-class.md)операций, необходимо вызвать `CArchive` метод [Flush](../mfc/reference/carchive-class.md#flush) во избежание повреждения архива.

> [!NOTE]
>  Эта реализация налагает жесткое ограничение 0x3FFFFFFE индексов в одной архив контекста. Это количество представляет собой максимальное количество уникальных объектов и классы, которые могут быть сохранены в один архив, но единственного файла диска может иметь неограниченное число контекстов архива.

## <a name="loading-objects-from-the-store-carchivereadobject"></a>Загрузка объектов из Store (CArchive::ReadObject)

Загрузка (извлечение) объектов использует `CArchive::ReadObject` метод и является противоположностью `WriteObject`. Как и в `WriteObject`, `ReadObject` не вызывается напрямую с помощью пользовательского кода; код пользователя должен вызывать оператор извлечения строго типизированным, который вызывает `ReadObject` с привычными `CRuntimeClass`. Это гарантирует целостность тип операции извлечения.

Так как `WriteObject` реализации назначенный возрастающий PID, начиная с 1 (0 заранее определены как пустой объект), `ReadObject` реализации можно использовать массив для сохранения состояния контекста архива. При считывании номера продукта в магазине, если идентификатор Процесса больше, чем текущий верхнюю границу *m_pLoadArray*, `ReadObject` знает, что соответствует новый объект (или описание класса).

## <a name="schema-numbers"></a>Номера схемы

Номер схемы, которое назначено типу класса при `IMPLEMENT_SERIAL` метод класса встречается, — это «версия» реализация класса. Схема относится к реализации класса, не для количество данного объекта стала постоянных (обычно называют версию объекта).

Если требуется постоянно поддерживать несколько разных реализаций того же класса, увеличивая схемы в исправленном объекта `Serialize` реализацию метода дает возможность писать код, который может загружать объекты, сохраненные с помощью более старых версий Реализация.

`CArchive::ReadObject` Метод вызывает исключение [CArchiveException](../mfc/reference/carchiveexception-class.md) при обнаружении несколько схем в постоянное хранилище, отличается от схемы числа Описание класса в памяти. Не просто для восстановления из этого исключения.

Можно использовать `VERSIONABLE_SCHEMA` в сочетании с (побитовое **или**) версию схемы для сохранения этого исключения. С помощью `VERSIONABLE_SCHEMA`, код может выполнять соответствующие действия его `Serialize` функция, установив значение, возвращаемое [CArchive::GetObjectSchema](../mfc/reference/carchive-class.md#getobjectschema).

## <a name="calling-serialize-directly"></a>Вызов непосредственно сериализации

Во многих случаях затраты на схему архив общих объектов `WriteObject` и `ReadObject` не требуется. Это распространенный случай сериализации данных в [CDocument](../mfc/reference/cdocument-class.md). В этом случае `Serialize` метод `CDocument` вызывается напрямую, не с помощью операторов извлечения или insert. Содержимое документа, в свою очередь может использовать более общую схему архив объекта.

Вызов `Serialize` непосредственно имеет следующие преимущества и недостатки:

- Дополнительные байты не будут добавлены в архиве до или после сериализации объекта. Это не только упрощает сохраненных данных меньшего размера, но позволяет реализовать `Serialize` подпрограммы, которые можно обрабатывать все форматы файлов.

- MFC настраивается таким образом `WriteObject` и `ReadObject` реализации и соответствующих коллекций не будут связаны в приложение Если вам не требуются более общую схему архив объекта для каких-либо других целей.

- Ваш код не имеет для восстановления из старых номеров схемы. Это делает код сериализации документа ответственность для кодирования схемы номеров, номера версий формат файлов, и любое определение номера можно использовать в начале файлы данных.

- Любой объект, который сериализуется с использованием непосредственного вызова `Serialize` не должны использовать `CArchive::GetObjectSchema` или необходимо дескриптор возвращаемое значение (целое число без знака) -1, указывающее, что версии неизвестно.

Так как `Serialize` вызывается непосредственно на ваш документ, это обычно невозможно для вложенных объектов документа, чтобы архивировать ссылки на их родительский документ. Эти объекты должны быть получает указатель на документе-контейнере явным образом или необходимо использовать [CArchive::MapObject](../mfc/reference/carchive-class.md#mapobject) функция, сопоставляющая `CDocument` указатель на идентификатор Процесса, прежде чем эти обратные указатели архивируются.

Как отмечалось ранее, необходимо закодировать версии и сведения о классов самостоятельно при вызове `Serialize` напрямую, что позволяет позже изменить формат, сохраняя при этом обратную совместимость с более старых файлов. `CArchive::SerializeClass` Функция может вызываться явным образом до непосредственно сериализации объекта или перед вызовом базового класса.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
