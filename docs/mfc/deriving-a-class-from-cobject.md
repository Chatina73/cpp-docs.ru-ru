---
title: Наследование класса от CObject
ms.date: 11/04/2016
f1_keywords:
- CObject
helpviewer_keywords:
- DECLARE_DYNCREATE macro [MFC]
- DECLARE_SERIAL macro [MFC]
- macros [MFC], serialization
- serialization [MFC], macros
- DECLARE_DYNAMIC macro [MFC]
- derived classes [MFC], from CObject
- CObject class [MFC], deriving serializable classes
- CObject class [MFC], deriving from
ms.assetid: 5ea4ea41-08b5-4bd8-b247-c5de8c152a27
ms.openlocfilehash: afaddfcb0a75b7e753897768d993df7ab5d876c0
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50566235"
---
# <a name="deriving-a-class-from-cobject"></a>Наследование класса от CObject

В этой статье описываются шаги, необходимо создать производный класс от [CObject](../mfc/reference/cobject-class.md). Другие `CObject` класс статьях описываются действия, необходимые для использования определенных `CObject` функции, такие как сериализация и диагностики поддержку отладки.

В обсуждении `CObject`, часто используются термины «интерфейс file» и «реализация file». В файле интерфейса (часто называют файл заголовка, или. H-файл) содержит объявление класса и другие сведения, необходимые для использования класса. Файл реализации (или). CPP-файл) содержит определение класса, а также код, который реализует функции-члены класса. Например, класс с именем `CPerson`, обычно создают файл интерфейса, с именем пользователя. H и файл реализации с именем пользователя. CPP. Тем не менее для некоторых небольших классов, которые не будут передаваться между приложениями, это иногда простоте в комбинировании интерфейс и реализация в один. CPP-файл.

Можно выбрать из четырех уровней функциональности при наследовании от класса `CObject`:

- Основные функциональные возможности: сведения о классе среды выполнения или сериализации не поддерживается, но содержит управления диагностики памяти.

- Сведения о классов основные функциональные возможности, а также поддержку времени выполнения.

- А также поддержку по сведениям о классе среды выполнения и динамическое создание основные функциональные возможности.

- Основные функциональные возможности, а также поддержку времени выполнения класса сведения, динамическое создание и сериализации.

Классы, предназначенные для повторного использования (те, которые позже будет использоваться в качестве базовых классов) стоит включить хотя бы поддержку класс времени выполнения и поддержка сериализации, если фактические результаты для любого необходимого будущих сериализации.

Выберите уровень функциональности с помощью определенного объявления и реализации макросов в объявлении и реализации классов, производных от `CObject`.

В следующей таблице показана взаимосвязь между макросы, используемые для поддержки сериализации и данных времени выполнения.

### <a name="macros-used-for-serialization-and-run-time-information"></a>Макросы, используемые для сериализации и данных времени выполнения

|Макросы используются|CObject::IsKindOf|CRuntimeClass::<br /><br /> CreateObject|CArchive::operator >><br /><br /> CArchive::operator <<|
|----------------|-----------------------|--------------------------------------|-------------------------------------------------------|
|Основные `CObject` функциональные возможности|Нет|Нет|Нет|
|`DECLARE_DYNAMIC`|Да|Нет|Нет|
|`DECLARE_DYNCREATE`|Да|Да|Нет|
|`DECLARE_SERIAL`|Да|Да|Да|

#### <a name="to-use-basic-cobject-functionality"></a>Чтобы использовать базовую функциональность в CObject

1. Использование обычного синтаксиса C++ ваш класс из `CObject` (или из класса, производного от `CObject`).

   В следующем примере показан простейший случай, производный от класса `CObject`:

   [!code-cpp[NVC_MFCCObjectSample#1](../mfc/codesnippet/cpp/deriving-a-class-from-cobject_1.h)]

Как правило, тем не менее, вы можете переопределить некоторые `CObject`в функции-члены для обработки особенности нового класса. Например, обычно можно переопределить `Dump` функции `CObject` для предоставления выходные данные отладки для содержимого вашего класса. Дополнительные сведения о том, как переопределить `Dump`, см. в статье [диагностики: формирование дампа объекта содержимое](/previous-versions/visualstudio/visual-studio-2010/sc15kz85). Может также потребоваться переопределить `AssertValid` функции `CObject` для предоставления настраиваемые тесты, чтобы проверить согласованность данных членов класса объектов. Описание того, как переопределить `AssertValid`, см. в разделе [MFC ASSERT_VALID и CObject::AssertValid](/previous-versions/visualstudio/visual-studio-2010/38z04tfa).

Статья [задание уровней функциональности](../mfc/specifying-levels-of-functionality.md) описывается, как указать другие уровни функциональные возможности, включая сведения о классе среды выполнения, динамическое создание объектов и сериализации.

## <a name="see-also"></a>См. также

[Использование CObject](../mfc/using-cobject.md)

