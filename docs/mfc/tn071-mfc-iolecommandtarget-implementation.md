---
title: 'TN071: Реализация IOleCommandTarget в MFC'
ms.date: 06/28/2018
f1_keywords:
- IOleCommandTarget
helpviewer_keywords:
- TN071 [MFC]
- IOleCommandTarget interface [MFC]
ms.assetid: 3eef571e-6357-444d-adbb-6f734a0c3161
ms.openlocfilehash: dca1183a17fe8f3022f517d1ad0c3932ea272417
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50522230"
---
# <a name="tn071-mfc-iolecommandtarget-implementation"></a>TN071: Реализация IOleCommandTarget в MFC

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

`IOleCommandTarget` Интерфейс позволяет объектов и контейнеров для отправки команд друг с другом. Например, в панели инструментов объекта может содержать кнопки для команд `Print`, `Print Preview`, `Save`, `New`, и `Zoom`. Если такой объект были внедрены в контейнер, который поддерживает `IOleCommandTarget`, объект для включения кнопки и пересылать команды в контейнер для обработки, когда пользователь щелкает их. Если внедренный объект для печати сам контейнер, его выполнения данного запроса, отправив команду через `IOleCommandTarget` интерфейс внедренного объекта.

`IOleCommandTarget` представляет собой интерфейс автоматизации стиле, в том, что он используется клиентом для вызова методов на сервере. Тем не менее, с помощью `IOleCommandTarget` экономит ресурсы выполнении вызовов через интерфейсы автоматизации, так как программистам не нужно использовать обычно самым дорогим `Invoke` метод `IDispatch`.

В MFC `IOleCommandTarget` интерфейс используется серверы активных документов чтобы разрешить контейнеры активных документов для отправки команд на сервер. Класс сервера активных документов, `CDocObjectServerItem`, использует схемы интерфейсов MFC (см. в разделе [TN038: реализация MFC/OLE IUnknown](../mfc/tn038-mfc-ole-iunknown-implementation.md)) для реализации `IOleCommandTarget` интерфейс.

`IOleCommandTarget` также реализована в `COleFrameHook` класса. `COleFrameHook` является классом недокументированные MFC, который реализует функциональные возможности окна фрейма редактирования контейнеров на месте. `COleFrameHook` также использует схемы интерфейсов MFC для реализации `IOleCommandTarget` интерфейс. `COleFrameHook`в реализации `IOleCommandTarget` перенаправляет команды OLE для `COleDocObjectItem`-производным контейнеры активных документов. Это позволяет любой MFC активный контейнер документа, для получения сообщений от серверов автономной активного документа.

## <a name="mfc-ole-command-maps"></a>Схемы команд MFC OLE

Разработчикам MFC можно воспользоваться преимуществами `IOleCommandTarget` с помощью MFC OLE команды карты. Схемы команд OLE подобны схемы сообщений, так как они могут использоваться для сопоставления функции-члены класса, содержащего схему команда команды OLE. Чтобы это работало, размещения макросов на карте команду, чтобы указать группу команды OLE команде, которая будет обрабатывать команды OLE и идентификатор команды [WM_COMMAND](/windows/desktop/menurc/wm-command) сообщение, которое будет отправляться при получении команды OLE. MFC также предоставляет ряд предварительно определенных макросов для стандартные команды OLE. Список стандартных OLE команд, которые изначально были разработаны для использования с приложениями Microsoft Office см OLECMDID перечисления, который определен в docobj.h.

При получении приложением MFC, который содержит карту команды OLE команду OLE MFC предпринимается попытка найти идентификатор команды и группы команд для запрашиваемую команду на карте команды OLE приложения. Если соответствие найдено, сообщение WM_COMMAND отправляется для приложения, содержащего карту команду с Идентификатором запрашиваемую команду. (См. в описании `ON_OLECMD` ниже.) Таким образом команды OLE, отправляется в приложение, преобразуются в сообщения WM_COMMAND классами MFC. WM_COMMAND-сообщения затем направляются через схемы сообщений приложения, используя стандартные MFC [маршрутизация команд](../mfc/command-routing.md) архитектуры.

В отличие от схемы сообщений схемы MFC OLE команд не поддерживаются ClassWizard. Разработчикам MFC необходимо добавить поддержки карт команды OLE и записи карты OLE команд вручную. Команда OLE, maps может быть добавлена к MFC активных серверов документ в любом классе, который находится в цепочку маршрутизации сообщений WM_COMMAND во время активного документа активен на месте в контейнере. Эти классы содержат приложения классы, производные от [CWinApp](../mfc/reference/cwinapp-class.md), [CView](../mfc/reference/cview-class.md), [CDocument](../mfc/reference/cdocument-class.md), и [COleIPFrameWnd](../mfc/reference/coleipframewnd-class.md). В контейнеры активных документов схемы OLE команд могут добавляться только к [COleDocObjectItem](../mfc/reference/coledocobjectitem-class.md)-производного класса. Кроме того, в контейнеры активных документов WM_COMMAND-сообщения будут только переданы в схеме сообщений в `COleDocObjectItem`-производного класса.

## <a name="ole-command-map-macros"></a>Макросы схемы команды OLE

Используйте следующие макросы Добавление функциональных возможностей карты команда класса:

```cpp
DECLARE_OLECMD_MAP ()
```

Этот макрос переходит в объявлении класса (обычно в файле заголовка) класса, содержащего схему команды.

```cpp
BEGIN_OLECMD_MAP(theClass, baseClass)
```

*theClass*<br/>
Имя класса, содержащего схему команды.

*baseClass*<br/>
Имя класса базового класса, содержащего схему команды.

Этот макрос отмечает начало карты команды. Используйте этот макрос в файле реализации для класса, содержащего схему команды.

```
END_OLECMD_MAP()
```

Этот макрос отмечает конец карты команды. Используйте этот макрос в файле реализации для класса, содержащего схему команды. Этот макрос должен всегда следуйте BEGIN_OLECMD_MAP макрос.

```
ON_OLECMD(pguid, olecmdid, id)
```

*pguid*<br/>
Указатель на идентификатор GUID группы команд команду OLE. Этот параметр является **NULL** для стандартной группы команды OLE.

*olecmdid*<br/>
Идентификатор команды OLE команды для вызова.

*id*<br/>
Идентификатор сообщения WM_COMMAND отправки на приложения, содержащего карту команды при вызове этой команды OLE.

On_olecmd-макрос в сопоставлении команду можно используйте для добавления записи для команды OLE, которые необходимо обработать. При получении команд OLE, они будут преобразованы в указанное сообщение WM_COMMAND и направляться через схему сообщений приложения, с помощью стандартной архитектуры маршрутизация команд MFC.

## <a name="example"></a>Пример

В следующем примере показано, как добавить возможность обработки команд OLE в MFC активный документ сервер для обработки [OLECMDID_PRINT](/windows/desktop/api/docobj/ne-docobj-olecmdid) команды OLE. В этом примере предполагается, что использовался мастером для создания приложения MFC, который служит сервером активного документа.

1. В вашей `CView`-производного класса заголовка добавьте макрос DECLARE_OLECMD_MAP к объявлению класса.

    > [!NOTE]
    > Используйте `CView`-производного класса, поскольку он является одним из классов в активный документ сервера, который находится в цепочку маршрутизации сообщений WM_COMMAND.

    ```cpp
    class CMyServerView : public CView
    {
    protected: // create from serialization only
        CMyServerView();
        DECLARE_DYNCREATE(CMyServerView)
        DECLARE_OLECMD_MAP()
        // . . .
    };
    ```

2. В файле реализации для `CView`-производного класса, добавить макросы BEGIN_OLECMD_MAP и END_OLECMD_MAP:

    ```cpp
    BEGIN_OLECMD_MAP(CMyServerView, CView)

    END_OLECMD_MAP()
    ```

3. Для обработки стандартную команду печати OLE, добавить [ON_OLECMD](reference/message-map-macros-mfc.md#on_olecmd) макрос карту команду, указав идентификатор команды OLE для стандартные команды печати и **ID_FILE_PRINT** для WM_COMMAND идентификатора. **ID_FILE_PRINT** — это стандарт, идентификатор команды печати, используемые приложениями MFC, созданные с помощью мастера:

    ```
    BEGIN_OLECMD_MAP(CMyServerView, CView)
        ON_OLECMD(NULL, OLECMDID_PRINT, ID_FILE_PRINT)
    END_OLECMD_MAP()
    ```

Обратите внимание, что один из макросов, стандартные команды OLE, определенных в afxdocob.h, может использоваться вместо on_olecmd-макрос поскольку **OLECMDID_PRINT** — это стандартный идентификатор команды OLE. On_olecmd_print-макрос предстоит выполнить ту же задачу, что on_olecmd-макрос, показанный выше.

Когда приложение-контейнер отправляет этот сервер **OLECMDID_PRINT** команду через сервер `IOleCommandTarget` интерфейса, печать обработчик команд MFC будет вызываться на сервере, приведшая печати приложения. Контейнер активного документа код для вызова команды печати, добавленного в шагах выше будет выглядеть примерно так:

```cpp
void CContainerCntrItem::DoOleCmd()
{
    IOleCommandTarget *pCmd = NULL;
    HRESULT hr = E_FAIL;
    OLECMD ocm={OLECMDID_PRINT, 0};

    hr = m_lpObject->QueryInterface(
        IID_IOleCommandTarget,reinterpret_cast<void**>(&pCmd));

    if (FAILED(hr))
        return;

    hr = pCmd->QueryStatus(NULL, 1, &ocm, NULL);

    if (SUCCEEDED(hr) && (ocm.cmdf& OLECMDF_ENABLED))
    {
        //Command is available and enabled so call it
        COleVariant vIn;
        COleVariant vOut;
        hr = pCmd->Exec(NULL, OLECMDID_PRINT,
            OLECMDEXECOPT_DODEFAULT, &vIn, &vOut);
        ASSERT(SUCCEEDED(hr));
    }
    pCmd->Release();
}
```

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
