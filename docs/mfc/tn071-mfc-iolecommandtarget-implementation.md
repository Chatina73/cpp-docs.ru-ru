---
description: 'Дополнительные сведения о: TN071: реализация MFC IOleCommandTarget'
title: 'TN071: Реализация IOleCommandTarget в MFC'
ms.date: 06/28/2018
helpviewer_keywords:
- TN071 [MFC]
- IOleCommandTarget interface [MFC]
ms.assetid: 3eef571e-6357-444d-adbb-6f734a0c3161
ms.openlocfilehash: 190dd64f6fd14d6231a6870bf6697a9a85182166
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97214511"
---
# <a name="tn071-mfc-iolecommandtarget-implementation"></a>TN071: Реализация IOleCommandTarget в MFC

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

`IOleCommandTarget`Интерфейс позволяет объектам и их контейнерам отправлять команды друг другу. Например, панели инструментов объекта могут содержать кнопки для таких команд, как,,, `Print` `Print Preview` `Save` `New` и `Zoom` . Если такой объект был внедрен в контейнер, поддерживающий `IOleCommandTarget` , объект может включить свои кнопки и переслать команды в контейнер для обработки, когда пользователь нащелкнул их. Если контейнер хочет, чтобы внедренный объект печатал сам себя, он может сделать этот запрос, отправив команду через `IOleCommandTarget` интерфейс внедренного объекта.

`IOleCommandTarget` — Это интерфейс, подобный автоматизации в том, что он используется клиентом для вызова методов на сервере. Однако использование `IOleCommandTarget` экономит издержки на вызов через интерфейсы автоматизации, поскольку программистам не нужно использовать часто дорогостоящий `Invoke` метод `IDispatch` .

В MFC `IOleCommandTarget` интерфейс используется серверами активных документов, чтобы разрешить контейнерам активных документов отправлять команды на сервер. Класс сервера активных документов, `CDocObjectServerItem` использует карты интерфейсов MFC (см. раздел [Реализация TN038: MFC/OLE IUnknown](../mfc/tn038-mfc-ole-iunknown-implementation.md)) для реализации `IOleCommandTarget` интерфейса.

`IOleCommandTarget` также реализуется в `COleFrameHook` классе. `COleFrameHook` — Это недокументированный класс MFC, реализующий функциональные возможности фреймового окна в контейнерах редактирования на месте. `COleFrameHook` также использует карты интерфейсов MFC для реализации `IOleCommandTarget` интерфейса. `COleFrameHook`Реализация `IOleCommandTarget` переадресации команд OLE на `COleDocObjectItem` производные контейнеры активных документов. Это позволяет любому контейнеру активного документа MFC принимать сообщения из автономных серверов документов.

## <a name="mfc-ole-command-maps"></a>Карты команд MFC OLE

Разработчики MFC могут использовать преимущества `IOleCommandTarget` с помощью карт команд MFC OLE. Схемы команд OLE подобны схемам сообщений, так как они могут использоваться для сопоставления команд OLE с функциями-членами класса, который содержит карту команд. Чтобы выполнить эту работу, поместите макросы на карте команд, чтобы указать группу команд OLE команды, которую требуется обрабатывать, команду OLE и идентификатор команды [WM_COMMAND](/windows/win32/menurc/wm-command) сообщения, которое будет отправлено при получении команды OLE. MFC также предоставляет ряд стандартных макросов для стандартных команд OLE. Список стандартных команд OLE, изначально предназначенных для использования с Microsoft Office приложениями, см. в разделе Перечисление ОЛЕКМДИД, которое определено в докобж. h.

При получении команды OLE приложением MFC, содержащим карту команд OLE, MFC пытается найти идентификатор команды и группу команд для запрошенной команды на карте команд OLE приложения. Если совпадение найдено, в приложение, содержащее сопоставление команд с ИДЕНТИФИКАТОРом запрошенной команды, отправляется сообщение WM_COMMAND. (См `ON_OLECMD` . описание ниже.) Таким образом, команды OLE, отправленные в приложение, преобразуются в WM_COMMAND сообщения MFC. Затем WM_COMMAND сообщения перенаправляются через схемы сообщений приложения с помощью стандартной архитектуры [маршрутизации команд](../mfc/command-routing.md) MFC.

В отличие от схем сообщений, карты команд MFC OLE не поддерживаются ClassWizard. Разработчики MFC должны добавить поддержку схемы команд OLE и записи схемы команд OLE вручную. Карты команд OLE можно добавлять в активные серверы документов MFC в любом классе, который находится в WM_COMMAND цепочке маршрутизации сообщений во время активного документа в контейнере. К этим классам относятся классы приложения, производные от [CWinApp](../mfc/reference/cwinapp-class.md), [CView](../mfc/reference/cview-class.md), [CDocument](../mfc/reference/cdocument-class.md)и [COleIPFrameWnd](../mfc/reference/coleipframewnd-class.md). В контейнерах активных документов сопоставления команд OLE можно добавлять только в класс, производный от [COleDocObjectItem](../mfc/reference/coledocobjectitem-class.md). Кроме того, в контейнерах активных документов WM_COMMAND сообщения будут отправлены только в схему сообщений `COleDocObjectItem` производного класса.

## <a name="ole-command-map-macros"></a>Макросы схемы команд OLE

Используйте следующие макросы для добавления функциональных возможностей схемы команд в класс:

```cpp
DECLARE_OLECMD_MAP ()
```

Этот макрос перемещается в объявление класса (обычно в файле заголовка) класса, содержащего карту команд.

```cpp
BEGIN_OLECMD_MAP(theClass, baseClass)
```

*секласс*<br/>
Имя класса, содержащего карту команд.

*baseClass*<br/>
Имя базового класса класса, содержащего карту команд.

Этот макрос отмечает начало схемы команды. Используйте этот макрос в файле реализации для класса, содержащего карту команд.

```
END_OLECMD_MAP()
```

Этот макрос отмечает конец схемы команд. Используйте этот макрос в файле реализации для класса, содержащего карту команд. Этот макрос всегда должен следовать за макросом BEGIN_OLECMD_MAP.

```
ON_OLECMD(pguid, olecmdid, id)
```

*пгуид*<br/>
Указатель на идентификатор GUID группы команд команды OLE. Этот параметр имеет **значение NULL** для стандартной группы команд OLE.

*олекмдид*<br/>
Идентификатор команды OLE для вызываемой команды.

*id*<br/>
Идентификатор сообщения WM_COMMAND, которое будет отправлено приложению, содержащему карту команд при вызове этой команды OLE.

Используйте макрос ON_OLECMD на карте команд, чтобы добавить записи для команд OLE, которые требуется обменять. При получении команд OLE они преобразуются в указанное сообщение WM_COMMAND и направляются через схему сообщений приложения с помощью стандартной архитектуры маршрутизации команд MFC.

## <a name="example"></a>Пример

В следующем примере показано, как добавить возможность обработки команд OLE на сервер активного документа MFC для обработки команды [OLECMDID_PRINT](/windows/win32/api/docobj/ne-docobj-olecmdid) OLE. В этом примере предполагается, что вы использовали помощью мастера для создания приложения MFC, которое является сервером активных документов.

1. В `CView` файле заголовка производного класса добавьте макрос DECLARE_OLECMD_MAP в объявление класса.

    > [!NOTE]
    > Используйте `CView` производный класс, так как он является одним из классов на сервере активного документа, который находится в WM_COMMAND цепочке маршрутизации сообщений.

    ```cpp
    class CMyServerView : public CView
    {
    protected: // create from serialization only
        CMyServerView();
        DECLARE_DYNCREATE(CMyServerView)
        DECLARE_OLECMD_MAP()
        // . . .
    };
    ```

2. В файле реализации `CView` класса, производного от, добавьте BEGIN_OLECMD_MAP и END_OLECMD_MAP макросы:

    ```cpp
    BEGIN_OLECMD_MAP(CMyServerView, CView)

    END_OLECMD_MAP()
    ```

3. Чтобы обрабатывалась стандартная команда OLE Print, добавьте [ON_OLECMDный](reference/message-map-macros-mfc.md#on_olecmd) макрос к карте команд, указав идентификатор команды OLE для стандартной команды print и **ID_FILE_PRINT** для идентификатора WM_COMMAND. **ID_FILE_PRINT** является СТАНДАРТным идентификатором команды печати, используемой приложениями MFC, созданными помощью мастера:

    ```
    BEGIN_OLECMD_MAP(CMyServerView, CView)
        ON_OLECMD(NULL, OLECMDID_PRINT, ID_FILE_PRINT)
    END_OLECMD_MAP()
    ```

Обратите внимание, что один из стандартных командных макросов OLE, определенных в афксдокоб. h, может использоваться вместо макроса ON_OLECMD, так как **OLECMDID_PRINT** является СТАНДАРТным идентификатором команды OLE. Макрос ON_OLECMD_PRINT будет выполнять ту же задачу, что и макрос ON_OLECMD, показанный выше.

Когда приложение-контейнер отправляет этот сервер с помощью команды **OLECMDID_PRINT** через интерфейс сервера `IOleCommandTarget` , обработчик команды печати MFC будет вызываться на сервере, что приведет к печати приложения на сервере. Код контейнера активного документа для вызова команды Print, добавленной в приведенных выше шагах, будет выглядеть примерно так:

```cpp
void CContainerCntrItem::DoOleCmd()
{
    IOleCommandTarget *pCmd = NULL;
    HRESULT hr = E_FAIL;
    OLECMD ocm={OLECMDID_PRINT, 0};

    hr = m_lpObject->QueryInterface(
        IID_IOleCommandTarget,reinterpret_cast<void**>(&pCmd));

    if (FAILED(hr))
        return;

    hr = pCmd->QueryStatus(NULL, 1, &ocm, NULL);

    if (SUCCEEDED(hr) && (ocm.cmdf& OLECMDF_ENABLED))
    {
        //Command is available and enabled so call it
        COleVariant vIn;
        COleVariant vOut;
        hr = pCmd->Exec(NULL, OLECMDID_PRINT,
            OLECMDEXECOPT_DODEFAULT, &vIn, &vOut);
        ASSERT(SUCCEEDED(hr));
    }
    pCmd->Release();
}
```

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
