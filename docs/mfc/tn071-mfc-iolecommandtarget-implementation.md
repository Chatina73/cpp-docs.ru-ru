---
title: 'TN071: Реализация MFC IOleCommandTarget'
ms.date: 06/28/2018
f1_keywords:
- IOleCommandTarget
helpviewer_keywords:
- TN071 [MFC]
- IOleCommandTarget interface [MFC]
ms.assetid: 3eef571e-6357-444d-adbb-6f734a0c3161
ms.openlocfilehash: 7077211396c68750d47b91c7b2bb113370990f62
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69511103"
---
# <a name="tn071-mfc-iolecommandtarget-implementation"></a>TN071: Реализация MFC IOleCommandTarget

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

`IOleCommandTarget` Интерфейс позволяет объектам и их контейнерам отправлять команды друг другу. Например, панели инструментов объекта могут содержать кнопки для таких команд `Print` `Save`, как, `Print Preview` `New`,, и `Zoom`. Если такой объект был внедрен в контейнер, поддерживающий `IOleCommandTarget`, объект может включить свои кнопки и переслать команды в контейнер для обработки, когда пользователь нащелкнул их. Если контейнер хочет, чтобы внедренный объект печатал сам себя, он может сделать этот запрос, отправив команду через `IOleCommandTarget` интерфейс внедренного объекта.

`IOleCommandTarget`— Это интерфейс, подобный автоматизации в том, что он используется клиентом для вызова методов на сервере. Однако использование `IOleCommandTarget` экономит издержки на вызов через интерфейсы автоматизации, поскольку программистам не нужно использовать часто дорогостоящий `Invoke` метод `IDispatch`.

В MFC `IOleCommandTarget` интерфейс используется серверами активных документов, чтобы разрешить контейнерам активных документов отправлять команды на сервер. Класс сервера активных документов, `CDocObjectServerItem`использует карты интерфейсов MFC (см [. TN038: Реализация](../mfc/tn038-mfc-ole-iunknown-implementation.md) `IOleCommandTarget` интерфейса MFC/OLE IUnknown) позволяет реализовать интерфейс.

`IOleCommandTarget`также реализуется в `COleFrameHook` классе. `COleFrameHook`— Это недокументированный класс MFC, реализующий функциональные возможности фреймового окна в контейнерах редактирования на месте. `COleFrameHook`также использует карты интерфейсов MFC для реализации `IOleCommandTarget` интерфейса. `COleFrameHook`Реализация `IOleCommandTarget` переадресации команд OLE на `COleDocObjectItem`производные контейнеры активных документов. Это позволяет любому контейнеру активного документа MFC принимать сообщения из автономных серверов документов.

## <a name="mfc-ole-command-maps"></a>Карты команд MFC OLE

Разработчики MFC могут использовать преимущества `IOleCommandTarget` с помощью карт команд MFC OLE. Схемы команд OLE подобны схемам сообщений, так как они могут использоваться для сопоставления команд OLE с функциями-членами класса, который содержит карту команд. Чтобы выполнить эту работу, поместите макросы на карте команд, чтобы указать группу команд OLE команды, которую требуется обрабатывать, команду OLE и идентификатор команды сообщения [WM_COMMAND](/windows/win32/menurc/wm-command) , которая будет отправлена при получении команды OLE. MFC также предоставляет ряд стандартных макросов для стандартных команд OLE. Список стандартных команд OLE, изначально предназначенных для использования с Microsoft Office приложениями, см. в разделе Перечисление ОЛЕКМДИД, которое определено в докобж. h.

При получении команды OLE приложением MFC, содержащим карту команд OLE, MFC пытается найти идентификатор команды и группу команд для запрошенной команды на карте команд OLE приложения. Если совпадение найдено, сообщение WM_COMMAND отправляется в приложение, содержащее сопоставление команд с ИДЕНТИФИКАТОРом запрошенной команды. (См. Описание `ON_OLECMD` ниже.) Таким образом, команды OLE, отправленные в приложение, преобразуются в WM_COMMAND сообщения MFC. Затем сообщения WM_COMMAND направляются через схемы сообщений приложения с помощью стандартной архитектуры [маршрутизации команд](../mfc/command-routing.md) MFC.

В отличие от схем сообщений, карты команд MFC OLE не поддерживаются ClassWizard. Разработчики MFC должны добавить поддержку схемы команд OLE и записи схемы команд OLE вручную. Карты команд OLE можно добавлять в активные серверы документов MFC в любом классе, который находится в цепочке маршрутизации сообщений WM_COMMAND во время активного документа в контейнере. К этим классам относятся классы приложения, производные от [CWinApp](../mfc/reference/cwinapp-class.md), [CView](../mfc/reference/cview-class.md), [CDocument](../mfc/reference/cdocument-class.md)и [COleIPFrameWnd](../mfc/reference/coleipframewnd-class.md). В контейнерах активных документов сопоставления команд OLE можно добавлять только в класс, производный от [COleDocObjectItem](../mfc/reference/coledocobjectitem-class.md). Кроме того, в контейнерах активных документов сообщения WM_COMMAND будут отправлены только в схему `COleDocObjectItem`сообщений производного класса.

## <a name="ole-command-map-macros"></a>Макросы схемы команд OLE

Используйте следующие макросы для добавления функциональных возможностей схемы команд в класс:

```cpp
DECLARE_OLECMD_MAP ()
```

Этот макрос перемещается в объявление класса (обычно в файле заголовка) класса, содержащего карту команд.

```cpp
BEGIN_OLECMD_MAP(theClass, baseClass)
```

*секласс*<br/>
Имя класса, содержащего карту команд.

*baseClass*<br/>
Имя базового класса класса, содержащего карту команд.

Этот макрос отмечает начало схемы команды. Используйте этот макрос в файле реализации для класса, содержащего карту команд.

```
END_OLECMD_MAP()
```

Этот макрос отмечает конец схемы команд. Используйте этот макрос в файле реализации для класса, содержащего карту команд. Этот макрос всегда должен следовать за макросом BEGIN_OLECMD_MAP.

```
ON_OLECMD(pguid, olecmdid, id)
```

*пгуид*<br/>
Указатель на идентификатор GUID группы команд команды OLE. Этот параметр имеет **значение NULL** для стандартной группы команд OLE.

*олекмдид*<br/>
Идентификатор команды OLE для вызываемой команды.

*id*<br/>
Идентификатор сообщения WM_COMMAND, которое будет отправлено приложению, содержащему карту команд при вызове этой команды OLE.

Используйте макрос ON_OLECMD в сопоставлении команд, чтобы добавить записи для команд OLE, которые требуется обменять. При получении команд OLE они преобразуются в указанное сообщение WM_COMMAND и направляются через схему сообщений приложения с помощью стандартной архитектуры маршрутизации команд MFC.

## <a name="example"></a>Пример

В следующем примере показано, как добавить возможность обработки команд OLE на сервер активного документа MFC для обработки команды [OLECMDID_PRINT](/windows/win32/api/docobj/ne-docobj-olecmdid) OLE. В этом примере предполагается, что вы использовали помощью мастера для создания приложения MFC, которое является сервером активных документов.

1. `CView`В файле заголовка производного класса добавьте макрос DECLARE_OLECMD_MAP в объявление класса.

    > [!NOTE]
    > `CView`Используйте производный класс, так как он является одним из классов на сервере активного документа, который находится в цепочке маршрутизации сообщений WM_COMMAND.

    ```cpp
    class CMyServerView : public CView
    {
    protected: // create from serialization only
        CMyServerView();
        DECLARE_DYNCREATE(CMyServerView)
        DECLARE_OLECMD_MAP()
        // . . .
    };
    ```

2. В файле реализации для `CView`класса, производного от, добавьте макросы BEGIN_OLECMD_MAP и END_OLECMD_MAP:

    ```cpp
    BEGIN_OLECMD_MAP(CMyServerView, CView)

    END_OLECMD_MAP()
    ```

3. Чтобы обрабатывалась стандартная команда OLE Print, добавьте в карту команд макрос [ON_OLECMD](reference/message-map-macros-mfc.md#on_olecmd) , указав идентификатор команды OLE для стандартной команды Print и **ID_FILE_PRINT** для идентификатора WM_COMMAND. **ID_FILE_PRINT** — это стандартный идентификатор команды печати, используемый приложениями MFC, созданными помощью мастера:

    ```
    BEGIN_OLECMD_MAP(CMyServerView, CView)
        ON_OLECMD(NULL, OLECMDID_PRINT, ID_FILE_PRINT)
    END_OLECMD_MAP()
    ```

Обратите внимание, что один из стандартных командных макросов OLE, определенных в афксдокоб. h, может использоваться вместо макроса ON_OLECMD, так как **OLECMDID_PRINT** является СТАНДАРТным идентификатором команды OLE. Макрос ON_OLECMD_PRINT будет выполнять ту же задачу, что и макрос ON_OLECMD, показанный выше.

Когда приложение-контейнер отправляет этому серверу команду **OLECMDID_PRINT** через `IOleCommandTarget` интерфейс сервера, обработчик команд печати MFC будет вызываться на сервере, что приведет к печати приложения на сервере. Код контейнера активного документа для вызова команды Print, добавленной в приведенных выше шагах, будет выглядеть примерно так:

```cpp
void CContainerCntrItem::DoOleCmd()
{
    IOleCommandTarget *pCmd = NULL;
    HRESULT hr = E_FAIL;
    OLECMD ocm={OLECMDID_PRINT, 0};

    hr = m_lpObject->QueryInterface(
        IID_IOleCommandTarget,reinterpret_cast<void**>(&pCmd));

    if (FAILED(hr))
        return;

    hr = pCmd->QueryStatus(NULL, 1, &ocm, NULL);

    if (SUCCEEDED(hr) && (ocm.cmdf& OLECMDF_ENABLED))
    {
        //Command is available and enabled so call it
        COleVariant vIn;
        COleVariant vOut;
        hr = pCmd->Exec(NULL, OLECMDID_PRINT,
            OLECMDEXECOPT_DODEFAULT, &vIn, &vOut);
        ASSERT(SUCCEEDED(hr));
    }
    pCmd->Release();
}
```

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
