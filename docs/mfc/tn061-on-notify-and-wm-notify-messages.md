---
title: TN061. Сообщения ON_NOTIFY и WM_NOTIFY
ms.date: 06/28/2018
helpviewer_keywords:
- ON_NOTIFY_EX message [MFC]
- TN061
- ON_NOTIFY message [MFC]
- ON_NOTIFY_EX_RANGE message [MFC]
- ON_NOTIFY_RANGE message [MFC]
- notification messages
- WM_NOTIFY message
ms.assetid: 04a96dde-7049-41df-9954-ad7bb5587caf
ms.openlocfilehash: 845558dad6b9f6e820c759cb83fce2c6cbceaa0c
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81366601"
---
# <a name="tn061-on_notify-and-wm_notify-messages"></a>TN061. Сообщения ON_NOTIFY и WM_NOTIFY

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой технической записке содержится справочная информация о новом WM_NOTIFY сообщении и описывается рекомендуемый (и наиболее распространенный) способ обработки WM_NOTIFY сообщений в приложении MFC.

**Сообщения уведомлений в Windows 3.x**

В Windows 3.x элементы управления уведомляют своих родителей о таких событиях, как клики в мыши, изменения в содержании и выборе, а также управляют фоновой росписью, отправив сообщение родителю. Простые уведомления отправляются в виде специальных сообщений WM_COMMAND, с кодом уведомления (например, BN_CLICKED) и идентификатором управления, упакованным в *wParam* и ручкой управления в *lParam.* Обратите внимание, что, поскольку *wParam* и *lParam* заполнены, нет никакого способа передать какие-либо дополнительные данные - эти сообщения могут быть только простым уведомлением. Например, в уведомлении BN_CLICKED нет возможности отправить информацию о местонахождении курсора мыши при нажатии кнопки.

Когда элементы управления в Windows 3.x должны отправлять сообщения уведомлений, включающие дополнительные данные, они используют различные специальные сообщения, в ключая WM_CTLCOLOR, WM_VSCROLL, WM_HSCROLL, WM_DRAWITEM, WM_MEASUREITEM, WM_COMPAREITEM, WM_DELETEITEM, WM_CHARTOITEM, WM_VKEYTOITEM и так далее. Эти сообщения могут быть отражены обратно в элемент управления, который их отправил. Для получения дополнительной информации [см.](../mfc/tn062-message-reflection-for-windows-controls.md)

**Сообщения уведомлений в Win32**

Для элементов управления, существовавших в Windows 3.1, API Win32 использует большинство сообщений уведомлений, которые использовались в Windows 3.x. Тем не менее, Win32 также добавляет ряд сложных, сложных элементов управления для тех, которые поддерживаются в Windows 3.x. Часто эти элементы управления должны отправлять дополнительные данные с их сообщениями уведомлений. Вместо добавления нового **WM_** <strong>\*</strong> сообщения для каждого нового уведомления, которое нуждается в дополнительных данных, дизайнеры API Win32 решили добавить только одно сообщение, WM_NOTIFY, которое может передавать любое количество дополнительных данных в стандартизированном виде.

WM_NOTIFY сообщения содержат идентификатор элемента управления, отправляющий сообщение в *wParam,* и указатель на структуру в *lParam.* Эта структура является либо структурой **NMHDR,** либо какой-либо более крупной структурой, которая имеет структуру **NMHDR** в качестве своего первого члена. Обратите внимание, что, поскольку член **NMHDR** является первым, указатель на эту структуру может быть использован как указатель на **NMHDR** или как указатель на большую структуру в зависимости от того, как вы ее разыгрываете.

В большинстве случаев указатель будет указывать на большую структуру, и вам нужно будет бросить его, когда вы используете его. Лишь в нескольких уведомлениях, таких как общие уведомления (названия которых начинаются с **NM_)** и TTN_SHOW и TTN_POP уведомлений управления наконечником инструмента, фактически используется структура **NMHDR.**

Структура Или первоначальный член **NMHDR** содержит ручку и идентификатор элемента управления, отправляющий сообщение, и код уведомлений (например, TTN_SHOW). Формат структуры **NMHDR** показан ниже:

```cpp
typedef struct tagNMHDR {
    HWND hwndFrom;
    UINT idFrom;
    UINT code;
} NMHDR;
```

Для TTN_SHOW сообщения член **кода** будет TTN_SHOW.

Большинство уведомлений передают указатель на более крупную структуру, которая содержит структуру **NMHDR** в качестве первого члена. Например, рассмотрим структуру, используемую LVN_KEYDOWN сообщением уведомления управления представления списка, которое отправляется при нажатии ключа в элементе управления представления мисена. Указатель указывает на **LV_KEYDOWN** структуру, которая определяется как показано ниже:

```cpp
typedef struct tagLV_KEYDOWN {
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} LV_KEYDOWN;
```

Обратите внимание, что, поскольку член **NMHDR** является первым в этой структуре, указатель, который вы передаете в уведомлении, может быть отлит либо указателем на **NMHDR,** либо указателю на **LV_KEYDOWN.**

**Уведомления, общие для всех новых элементов управления Windows**

Некоторые уведомления являются общими для всех новых элементов управления Windows. Эти уведомления передают указатель на структуру **NMHDR.**

|Код уведомления|Отправлено потому, что|
|-----------------------|------------------|
|NM_CLICK|Пользователь нажал левую кнопку мыши в управлении|
|NM_DBLCLK|Пользователь дважды нажал левую кнопку мыши в управлении|
|NM_RCLICK|Пользователь нажал правую кнопку мыши в управлении|
|NM_RDBLCLK|Пользователь дважды нажал кнопку правой мыши в управлении|
|NM_RETURN|Пользователь нажал на ключ ENTER, в то время как элемент управления имеет фокус ввода|
|NM_SETFOCUS|Контроль получил входиную фокус|
|NM_KILLFOCUS|Управление потеряло входную фокусировку|
|NM_OUTOFMEMORY|Управление не может завершить операцию, потому что не было достаточно памяти|

## <a name="on_notify-handling-wm_notify-messages-in-mfc-applications"></a><a name="_mfcnotes_on_notify.3a_.handling_wm_notify_messages_in_mfc_applications"></a>ON_NOTIFY: Обработка WM_NOTIFY сообщений в приложениях MFC

Функция `CWnd::OnNotify` обрабатывает сообщения уведомлений. Его реализация по умолчанию проверяет карту сообщений для обработчиков уведомлений для вызова. В общем, вы не `OnNotify`переопределить . Вместо этого вы предоставляете функцию обработчика и добавляете запись на карту сообщений для этого обработчика на карту сообщений класса окна вашего владельца.

ClassWizard, через лист свойства ClassWizard, может создать ON_NOTIFY входом в карту сообщений и предоставить вам функцию обработчика скелета. Для получения дополнительной информации об использовании ClassWizard, чтобы сделать это проще, [см.](../mfc/reference/mapping-messages-to-functions.md)

МакроON_NOTIFY карта сообщений имеет следующий синтаксис:

```cpp
ON_NOTIFY(wNotifyCode, id, memberFxn)
```

Используются следующие параметры.

*wNotifyCode*<br/>
Код для обработки сообщения уведомлений, например LVN_KEYDOWN.

*id*<br/>
Идентификатор элемента управления, для которого отправлено уведомление.

*memberFxn*<br/>
Функция участника, которая будет вызываться при отправке этого уведомления.

Функция вашего члена должна быть объявлена следующим прототипом:

```cpp
afx_msg void memberFxn(NMHDR* pNotifyStruct, LRESULT* result);
```

Используются следующие параметры.

*pNotifyStruct*<br/>
Указатель на структуру уведомлений, как описано в приведенном выше разделе.

*результат*<br/>
Указатель на код результата, который вы установите перед возвращением.

## <a name="example"></a>Пример

Чтобы указать, что `OnKeydownList1` функция участника обрабатывает `CListCtrl` LVN_KEYDOWN сообщения `IDC_LIST1`с идентификатора, вы будете использовать ClassWizard, чтобы добавить следующее на карту сообщений:

```cpp
ON_NOTIFY(LVN_KEYDOWN, IDC_LIST1, OnKeydownList1)
```

В приведенном выше примере функция ClassWizard:

```cpp
void CMessageReflectionDlg::OnKeydownList1(NMHDR* pNMHDR, LRESULT* pResult)
{
    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    // TODO: Add your control notification handler
    //       code here

    *pResult = 0;
}
```

Обратите внимание, что ClassWizard автоматически предоставляет указатель соответствующего типа. Вы можете получить доступ к структуре уведомлений через *pNMHDR* или *pLVKeyDow.*

## <a name="on_notify_range"></a><a name="_mfcnotes_on_notify_range"></a>ON_NOTIFY_RANGE

Если вам нужно обработать то же сообщение WM_NOTIFY для набора элементов управления, вы можете использовать ON_NOTIFY_RANGE, а не ON_NOTIFY. Например, у вас может быть набор кнопок, для которых вы хотите выполнить то же самое действие для определенного сообщения о уведомлении.

При использовании ON_NOTIFY_RANGE вы указываете смежный диапазон идентификаторов детей, для обработки сообщения уведомлений, указывая начальные и заканчивающиеся идентификаторы ребенка диапазона.

ClassWizard не обрабатывает ON_NOTIFY_RANGE; чтобы использовать его, вам нужно отобразить карту сообщений самостоятельно.

Прототип входа и функции в основе сообщения для ON_NOTIFY_RANGE:

```cpp
ON_NOTIFY_RANGE(wNotifyCode, id, idLast, memberFxn)
```

Используются следующие параметры.

*wNotifyCode*<br/>
Код для обработки сообщения уведомлений, например LVN_KEYDOWN.

*id*<br/>
Первый идентификатор в смежном диапазоне идентификаторов.

*idLast*<br/>
Последний идентификатор в смежном диапазоне идентификаторов.

*memberFxn*<br/>
Функция участника, которая будет вызываться при отправке этого уведомления.

Функция вашего члена должна быть объявлена следующим прототипом:

```cpp
afx_msg void memberFxn(UINT id, NMHDR* pNotifyStruct, LRESULT* result);
```

Используются следующие параметры.

*id*<br/>
Идентификатор элемента управления, отправивого уведомление.

*pNotifyStruct*<br/>
Указатель на структуру уведомлений, как описано выше.

*результат*<br/>
Указатель на код результата, который вы установите перед возвращением.

## <a name="on_notify_ex-on_notify_ex_range"></a><a name="_mfcnotes_tn061_on_notify_ex.2c_.on_notify_ex_range"></a>ON_NOTIFY_EX, ON_NOTIFY_EX_RANGE

Если в сообщении требуется несколько объектов в сообщении, можно использовать ON_NOTIFY_EX (или ON_NOTIFY_EX_RANGE), а не ON_NOTIFY (или ON_NOTIFY_RANGE). Единственное различие между версией **EX** и обычной версией состоит в том, что функция **участника,** вызванная для версии EX, возвращает **BOOL,** который указывает, следует ли продолжать обработку сообщений. Возвращение **FALSE** из этой функции позволяет обрабатывать одно и то же сообщение в нескольких объектах.

ClassWizard не обрабатывает ON_NOTIFY_EX или ON_NOTIFY_EX_RANGE; если вы хотите использовать любой из них, вам нужно отсеить карту сообщений самостоятельно.

Прототип входа и функции сообщения-карты для ON_NOTIFY_EX и ON_NOTIFY_EX_RANGE являются следующими. Значения параметров такие же, как и для**не-EX** версий.

```cpp
ON_NOTIFY_EX(nCode, id, memberFxn)
ON_NOTIFY_EX_RANGE(wNotifyCode, id, idLast, memberFxn)
```

Прототип для обоих из вышеперечисленных одинаков:

```cpp
afx_msg BOOL memberFxn(UINT id, NMHDR* pNotifyStruct, LRESULT* result);
```

В обоих случаях *идентификатор* удерживает идентификатор элемента управления, отправляемого из уведомления.

Ваша функция должна **вернуться,** если сообщение об уведомлении было полностью обработано или **FALSE,** если другие объекты в командной растерянии должны иметь возможность обрабатывать сообщение.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
