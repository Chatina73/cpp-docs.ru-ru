---
title: 'TN061: ON_NOTIFY и Wm_notify'
ms.date: 06/28/2018
f1_keywords:
- ON_NOTIFY
- WM_NOTIFY
helpviewer_keywords:
- ON_NOTIFY_EX message [MFC]
- TN061
- ON_NOTIFY message [MFC]
- ON_NOTIFY_EX_RANGE message [MFC]
- ON_NOTIFY_RANGE message [MFC]
- notification messages
- WM_NOTIFY message
ms.assetid: 04a96dde-7049-41df-9954-ad7bb5587caf
ms.openlocfilehash: 74eb39a855da3ff3e6da7f14a76bf0804919826d
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62399581"
---
# <a name="tn061-onnotify-and-wmnotify-messages"></a>TN061: ON_NOTIFY и Wm_notify

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Это техническое Примечание содержит общие сведения о новом сообщении WM_NOTIFY и описывает рекомендуемые (и наиболее распространенный) способ обработки сообщения WM_NOTIFY в приложении MFC.

**Уведомляющих сообщений в Windows 3.x**

В Windows 3.x, элементы управления уведомлять их родительские элементы событий, например на щелчки мыши, изменения в содержимое и выбора и рисования фона элемента управления путем отправки сообщения в родительский объект. Простой уведомления отправляются в виде специальных сообщений WM_COMMAND, кодом уведомления (например, BN_CLICKED) и упаковываются в идентификатор элемента управления *wParam* и дескриптор элемента управления в *lParam*. Обратите внимание, что поскольку *wParam* и *lParam* являются full, нет способа для передачи любых дополнительных данных, эти сообщения могут быть только простое уведомление. Например в уведомлении BN_CLICKED, нет способа для отправки сведений о расположение указателя мыши, когда была нажата кнопка.

Когда элементы управления в Windows, 3.x нужно отправить сообщение уведомления, которое содержит дополнительные данные, они используют различные сообщения специального назначения, включая WM_CTLCOLOR, WM_VSCROLL, сообщения WM_HSCROLL, WM_DRAWITEM, WM_MEASUREITEM, WM_COMPAREITEM, WM_DELETEITEM, WM_ CHARTOITEM WM_VKEYTOITEM и т. д. Эти сообщения могут быть отражены обратно в элемент управления, который отправил их. Дополнительные сведения см. в разделе [TN062: Сообщения отражение для элементов управления Windows](../mfc/tn062-message-reflection-for-windows-controls.md).

**Уведомляющих сообщений в Win32**

Для элементов управления, которые существовали в Windows 3.1, Win32 API использует большой объем сообщений уведомлений, которые были использованы в Windows 3.x. Тем не менее, Win32 также добавляет ряд сложных и сложных элементов управления со сценариями в Windows, используемыми 3.x. Часто эти элементы управления должны передавать дополнительные данные в сообщениях уведомлений. Вместо того, чтобы добавить новую **WM_** <strong>\*</strong> сообщения для каждого нового уведомления, ей требуются дополнительные данные, конструкторы интерфейса Win32 API было добавлено только одно сообщение WM_NOTIFY, который можно передать любой объем дополнительных данных в стандартизованном виде.

Сообщения WM_NOTIFY содержат идентификатор элемента управления, отправляющего сообщения *wParam* и указатель на структуру в *lParam*. Эта структура является либо **NMHDR** структуру или некоторые крупной структуры, имеющий **NMHDR** структуру, что ее первого элемента. Обратите внимание, что поскольку **NMHDR** член является первой, можно использовать как указатель на указатель на структуру **NMHDR** или как указатель на крупной структуры в зависимости от того, как привести его.

В большинстве случаев указатель указывает на структуру большего размера, и необходимо привести его при его использовании. В нескольких уведомлениях, например общих уведомлений (имена которых начинаются с **NM_**) и средство совет TTN_SHOW и TTN_POP уведомления элемента управления является **NMHDR** фактически используется структура.

**NMHDR** структуры или начального члена содержит дескриптор и идентификатор элемента управления, отправляющего сообщение и код уведомления (например, TTN_SHOW). Формат **NMHDR** структура приведена ниже:

```cpp
typedef struct tagNMHDR {
    HWND hwndFrom;
    UINT idFrom;
    UINT code;
} NMHDR;
```

Сообщения об TTN_SHOW **кода** TTN_SHOW будет иметь значение члена.

Большинство уведомления передать указатель на структуру большего размера, содержащую **NMHDR** структуру, что ее первого элемента. Например рассмотрим структуру, используемую сообщение уведомления LVN_KEYDOWN элемента управления представления списком, который отправляется при нажатии клавиши в элементе управления представления списка. Указатель указывает на **LV_KEYDOWN** структуру, которая определяется, как показано ниже:

```cpp
typedef struct tagLV_KEYDOWN {
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} LV_KEYDOWN;
```

Обратите внимание, что поскольку **NMHDR** член является первой в этой структуре, указатель, который Вы передали в сообщении может быть приведен к указателю на **NMHDR** или указатель на **LV_KEYDOWN** .

**Уведомления, общие для всех новых элементов управления Windows**

Некоторые уведомления являются общими для всех новых элементов управления Windows. Эти уведомления передать указатель на **NMHDR** структуры.

|Код уведомления|Отправлено, так как|
|-----------------------|------------------|
|NM_CLICK|Пользователь щелкнул левую кнопку мыши в элементе управления|
|NM_DBLCLK|Пользователя выполнен двойной щелчок левой кнопкой мыши в элементе управления|
|NM_RCLICK|Пользователь щелкнул правой кнопкой мыши в элементе управления|
|NM_RDBLCLK|Пользователя выполнен двойной щелчок правой кнопкой мыши в элементе управления|
|NM_RETURN|Пользователь нажал клавишу ВВОД, хотя элемент управления имеет фокус ввода|
|NM_SETFOCUS|Элемент управления получил фокус ввода|
|NM_KILLFOCUS|Элемент управления потерял фокус ввода|
|NM_OUTOFMEMORY|Элемент управления не удалось выполнить операцию, поскольку существует достаточный объем памяти|

##  <a name="_mfcnotes_on_notify.3a_.handling_wm_notify_messages_in_mfc_applications"></a> ON_NOTIFY: Обработка сообщения WM_NOTIFY в приложениях MFC

Функция `CWnd::OnNotify` обрабатывает сообщения уведомления. Его реализация по умолчанию проверяет сопоставление сообщений для обработчиков уведомлений для вызова. В общем случае не переопределить `OnNotify`. Вместо этого укажите функцию обработчика событий и добавить запись схемы сообщений для этого обработчика в схеме сообщений для окна-владельца класса.

ClassWizard через окно свойств классов, можно создать записи сопоставления сообщения ON_NOTIFY и предоставить вам функции каркас обработчика. Дополнительные сведения об использовании классов, чтобы облегчить эту задачу, см. в разделе [сопоставление сообщений с функциями](../mfc/reference/mapping-messages-to-functions.md).

On_notify-макрос схемы сообщений имеет следующий синтаксис:

```cpp
ON_NOTIFY(wNotifyCode, id, memberFxn)
```

Используются следующие параметры.

*wNotifyCode*<br/>
Код для сообщения уведомления для обработки, например LVN_KEYDOWN.

*id*<br/>
Идентификатор дочернего элемента элемента управления, для которого отправляется уведомление.

*memberFxn*<br/>
Функция-член вызывается в том случае, когда это уведомление отправляется.

Функция-член должен объявляться с использованием следующий прототип:

```cpp
afx_msg void memberFxn(NMHDR* pNotifyStruct, LRESULT* result);
```

Используются следующие параметры.

*pNotifyStruct*<br/>
Указатель на структуру уведомлений, как описано в предыдущем разделе.

*результат*<br/>
Указатель на код результата необходимо установить перед возвратом.

## <a name="example"></a>Пример

Чтобы указать, что функция-член `OnKeydownList1` для обработки сообщений LVN_KEYDOWN `CListCtrl` которого является идентификатор `IDC_LIST1`, позволяют ClassWizard добавьте следующий код в схеме сообщений:

```cpp
ON_NOTIFY(LVN_KEYDOWN, IDC_LIST1, OnKeydownList1)
```

В приведенном выше примере функции, предоставляемые ClassWizard является:

```cpp
void CMessageReflectionDlg::OnKeydownList1(NMHDR* pNMHDR, LRESULT* pResult)
{
    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    // TODO: Add your control notification handler
    //       code here

    *pResult = 0;
}
```

Обратите внимание на то, что ClassWizard автоматически предоставляет указатель соответствующего типа. Для доступа к структуре уведомления либо *pNMHDR* или *pLVKeyDow*.

##  <a name="_mfcnotes_on_notify_range"></a> ON_NOTIFY_RANGE

Если вам нужно обработать это сообщение WM_NOTIFY для набора элементов управления, можно использовать ON_NOTIFY_RANGE, а не ON_NOTIFY. Например имеется набор кнопок, для которого вы хотите выполнить то же действие для определенных сообщение уведомления.

При использовании ON_NOTIFY_RANGE вами непрерывный диапазон идентификаторов дочерних, для которого обрабатываются сообщения уведомления, указав начала и окончания идентификаторов дочерних диапазона.

ClassWizard не обрабатывает ON_NOTIFY_RANGE; Чтобы использовать его, необходимо изменить схему сообщения, в свою учетную запись.

Запись схемы сообщений и прототип функции для ON_NOTIFY_RANGE являются следующим образом:

```cpp
ON_NOTIFY_RANGE(wNotifyCode, id, idLast, memberFxn)
```

Используются следующие параметры.

*wNotifyCode*<br/>
Код для сообщения уведомления для обработки, например LVN_KEYDOWN.

*id*<br/>
Первый идентификатор в непрерывный диапазон идентификаторов.

*idLast*<br/>
Идентификатор последнего в непрерывный диапазон идентификаторов.

*memberFxn*<br/>
Функция-член вызывается в том случае, когда это уведомление отправляется.

Функция-член должен объявляться с использованием следующий прототип:

```cpp
afx_msg void memberFxn(UINT id, NMHDR* pNotifyStruct, LRESULT* result);
```

Используются следующие параметры.

*id*<br/>
Идентификатор дочернего элемента элемента управления, который отправил уведомление.

*pNotifyStruct*<br/>
Указатель на структуру уведомлений, как описано выше.

*результат*<br/>
Указатель на код результата необходимо установить перед возвратом.

##  <a name="_mfcnotes_tn061_on_notify_ex.2c_.on_notify_ex_range"></a> ON_NOTIFY_EX ON_NOTIFY_EX_RANGE

Если требуется более одного объекта в уведомлении о маршрутизации для обработки сообщения, можно использовать ON_NOTIFY_EX (или ON_NOTIFY_EX_RANGE) вместо ON_NOTIFY (или ON_NOTIFY_RANGE). Единственное различие между **EX** версии по обычной версии —, что функция-член вызывается для **EX** версия возвращает **BOOL** , указывает ли Обработка сообщений должна быть продолжена. Возвращение **FALSE** из этой функции позволяет обработать это сообщение в более одного объекта.

ClassWizard не обрабатывает ON_NOTIFY_EX или ON_NOTIFY_EX_RANGE; Если вы хотите использовать любую из них, необходимо изменить схему сообщения, в свою учетную запись.

Запись схемы сообщений и прототип функции для ON_NOTIFY_EX и ON_NOTIFY_EX_RANGE выглядят следующим образом. Значения параметров не отличаются от отличного**EX** версий.

```cpp
ON_NOTIFY_EX(nCode, id, memberFxn)
ON_NOTIFY_EX_RANGE(wNotifyCode, id, idLast, memberFxn)
```

Прототип для оба приведенных выше одинаков:

```cpp
afx_msg BOOL memberFxn(UINT id, NMHDR* pNotifyStruct, LRESULT* result);
```

В обоих случаях *идентификатор* содержит идентификатор дочернего элемента элемента управления, который отправил уведомление.

Ваша функция должна возвращать **TRUE** Если сообщение было обработано полностью или **FALSE** Если другие объекты в маршрутизации команд должны иметь возможность обработки сообщения.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
