---
title: Сокеты Windows. Пример сокетов с использованием архивов
ms.date: 11/04/2016
helpviewer_keywords:
- sockets [MFC], with archives
- examples [MFC], Windows Sockets
- Windows Sockets [MFC], with archives
ms.assetid: 2e3c9bb2-7e7b-4f28-8dc5-6cb7a484edac
ms.openlocfilehash: 4ea1e2911b156066360da09993fa7302db79f12b
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62305298"
---
# <a name="windows-sockets-example-of-sockets-using-archives"></a>Сокеты Windows. Пример сокетов с использованием архивов

В этой статье приводится пример использования класса [CSocket](../mfc/reference/csocket-class.md). Пример использует `CArchive` объектов для сериализации данных через сокет. Обратите внимание на то, что это не сериализации документа в или из файла.

В следующем примере показано, как использовать архив для отправки и получения данных через `CSocket` объектов. В этом образце таким образом, чтобы два экземпляра приложения (на одном компьютере или на разных компьютерах в сети) обмена данными. Один экземпляр отправляет данные, что другой экземпляр получает и подтверждает. Любое приложение может начать обмен и либо может выступать в качестве сервера или клиента в другое приложение. Следующая функция определяется в классе представления приложения:

[!code-cpp[NVC_MFCSimpleSocket#1](../mfc/codesnippet/cpp/windows-sockets-example-of-sockets-using-archives_1.cpp)]

— Это наиболее важный аспект в этом примере, что его структура является параллельной MFC `Serialize` функции. `PacketSerialize` Функция-член состоит из **Если** инструкции с **else** предложение. Функция получает два [CArchive](../mfc/reference/carchive-class.md) ссылки в качестве параметров: *arData* и *arAck*. Если *arData* архива имеет значение для хранения (отправка), **Если** ветви выполняется; в противном случае, если *arData* задается для загрузки (получение) функция принимает **else** ветви. Дополнительные сведения о сериализации в MFC, см. в разделе [сериализации](../mfc/how-to-make-a-type-safe-collection.md).

> [!NOTE]
>  *ArAck* предполагается, что объект архив является противоположностью *arData*. Если *arData* — возможность отправки, *arAck* получает, и верно обратное.

Для отправки, функцию циклов для указанное число раз и каждый раз, создавая некоторые случайные данные для демонстрационных целей. Приложение будет принимать реальные данные из какого-либо источника, например файл. *ArData* оператор вставки архива (**<<**) используется для отправки потока из трех последовательных фрагментов данных:

- «header», указывающий характер данных (в данном случае, значение *bValue* переменной и будет отправлен количество копий).

   Оба элемента генерируются случайным образом в этом примере.

- Указанное число копий данных.

   Внутренний **для** цикл отправляет *bValue* указанное число раз.

- Строка с именем *strText* , получатель отображает его пользователю.

Для получения, функция работает одинаково, за исключением того, что она использует оператор извлечения архива (**>>**) для получения данных из архива. Принимающее приложение проверяет его получает, отображает конечным сообщением «Received», а затем отправляет сообщение с текстом «Передано» для отправляющего приложения для отображения.

В этой модели взаимодействия, слово «Received», сообщение отправлено *strText* переменной, предназначена для отображения на другом конце связи, поэтому он для получателя указывает, что определенное число пакетов данных были Получено. Получатель отправляет ответ с аналогичной строкой, говорит: «Sent», для отображения на экране отправителя. Получение обе строки указывает, что произошло успешной связи.

> [!CAUTION]
>  При написании программы MFC клиента для взаимодействия с серверами установленного (не MFC), не отправляйте объектов C++ с помощью архива. Не является приложение MFC, распознаваемые типы объектов, которые вы хотите отправить, оно может принимать и десериализации объектов. Пример в этой статье [сокеты Windows: Порядок байтов](../mfc/windows-sockets-byte-ordering.md) приведена схема обмена данными этого типа.

Дополнительные сведения см. в разделе спецификации Windows Sockets: **htonl**, **htons**, **ntohl**, **ntohs**. Кроме того Дополнительные сведения см. в разделе:

- [Сокеты Windows. Наследование от классов сокета](../mfc/windows-sockets-deriving-from-socket-classes.md)

- [Сокеты Windows. Работа сокетов с архивами](../mfc/windows-sockets-how-sockets-with-archives-work.md)

- [Сокеты Windows. Фон](../mfc/windows-sockets-background.md)

## <a name="see-also"></a>См. также

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)<br/>
[CArchive::IsStoring](../mfc/reference/carchive-class.md#isstoring)<br/>
[CArchive::operator <<](../mfc/reference/carchive-class.md#operator_lt_lt)<br/>
[CArchive::operator >>](../mfc/reference/carchive-class.md#operator_lt_lt)<br/>
[CArchive::Flush](../mfc/reference/carchive-class.md#flush)<br/>
[CObject::Serialize](../mfc/reference/cobject-class.md#serialize)
