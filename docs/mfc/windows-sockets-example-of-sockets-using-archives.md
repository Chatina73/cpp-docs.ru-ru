---
title: Сокеты Windows. Пример сокетов с использованием архивов
ms.date: 11/04/2016
helpviewer_keywords:
- sockets [MFC], with archives
- examples [MFC], Windows Sockets
- Windows Sockets [MFC], with archives
ms.assetid: 2e3c9bb2-7e7b-4f28-8dc5-6cb7a484edac
ms.openlocfilehash: 253a65430ae230fbc4deeb9bd5288f28237310d2
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81371078"
---
# <a name="windows-sockets-example-of-sockets-using-archives"></a>Сокеты Windows. Пример сокетов с использованием архивов

В этой статье приводится пример использования класса [CSocket](../mfc/reference/csocket-class.md). В примере `CArchive` используются объекты для сериализации данных через розетку. Обратите внимание, что это не сериализация документа в файл или из нее.

Следующий пример иллюстрирует, как вы используете архив `CSocket` для отправки и получения данных через объекты. Пример разработан таким образом, что два экземпляра приложения (на одной машине или на разных машинах в сети) обмениваются данными. В одном экземпляре отправляются данные, которые другой экземпляр получает и признает. Любое приложение может инициировать обмен, и либо может выступать в качестве сервера или в качестве клиента к другому приложению. В классе представления приложения определена следующая функция:

[!code-cpp[NVC_MFCSimpleSocket#1](../mfc/codesnippet/cpp/windows-sockets-example-of-sockets-using-archives_1.cpp)]

Самое главное в этом примере то, что его `Serialize` структура совпадает с структурой функции MFC. Функция `PacketSerialize` члена состоит из оператора **if** с **другим** положением. Функция получает две ссылки [CArchive](../mfc/reference/carchive-class.md) в качестве параметров: *arData* и *arAck*. Если объект архива *arData* настроен для хранения (отправки), **если** ветвь выполняется; в противном случае, если *arData* настроен для загрузки (получения), функция занимает **еще ветку.** Для получения дополнительной информации о сериализации в МФЦ, [см.](../mfc/how-to-make-a-type-safe-collection.md)

> [!NOTE]
> Объект архива *arAck* считается противоположностью *arData.* Если *arData* предназначен для отправки, *arAck* получает, и обратное верно.

Для отправки пример функции циклов для определенного количества раз, каждый раз генерации некоторых случайных данных для демонстрационных целей. Ваше приложение будет получать реальные данные из некоторых источников, таких как файл. Оператор вставки архива *arData* ()**<<** используется для отправки потока из трех последовательных фрагментов данных:

- "Заголовок", который определяет характер данных (в данном случае значение переменной *bValue* и количество копий будет отправлено).

   Оба элемента генерируются случайным образом для этого примера.

- Указанное количество копий данных.

   Внутренний **для** цикла отправляет *bValue* указанное количество раз.

- Строка под названием *strText,* которую приемник отображает своему пользователю.

Для получения функция работает аналогичным образом, за исключением того,**>>** что она использует оператора извлечения архива () для получения данных из архива. Получающее приложение проверяет полученные данные, отображает окончательное сообщение "Полученное", а затем отправляет обратно сообщение с надписью "Отправлено" для отображения приложения для отправки.

В этой модели связи слово "Received", сообщение, отправленное в переменной *strText,* предназначено для отображения на другом конце сообщения, поэтому оно указывает принимающему пользователю, что получено определенное количество пакетов данных. Приемник отвечает с аналогичной строки, которая говорит "Отправлено", для отображения на экране исходного отправителя. Получение обеих строк указывает на то, что произошло успешное общение.

> [!CAUTION]
> Если вы пишете клиентскую программу MFC для связи с установленными (не МФЦ) серверами, не отправляйте объекты C-класса через архив. Если сервер не является приложением MFC, которое понимает виды объектов, которые вы хотите отправить, он не сможет получать и десериализировать ваши объекты. Пример в статье [Windows Sockets: Заказ байта](../mfc/windows-sockets-byte-ordering.md) показывает сообщение этого типа.

Для получения дополнительной информации, см Windows Розетки Спецификация: **htonl**, **htons**, **ntohl**, **ntohs**. Кроме того, для получения дополнительной информации, см.:

- [Сокеты Windows. Наследование от классов сокета](../mfc/windows-sockets-deriving-from-socket-classes.md)

- [Сокеты Windows. Работа сокетов с архивами](../mfc/windows-sockets-how-sockets-with-archives-work.md)

- [Сокеты Windows. Фон](../mfc/windows-sockets-background.md)

## <a name="see-also"></a>См. также раздел

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)<br/>
[CArchive::Istoring](../mfc/reference/carchive-class.md#isstoring)<br/>
[CArchive::оператор <<](../mfc/reference/carchive-class.md#operator_lt_lt)<br/>
[CArchive::оператор >>](../mfc/reference/carchive-class.md#operator_lt_lt)<br/>
[CArchive::Флеш](../mfc/reference/carchive-class.md#flush)<br/>
[CObject::Serialize](../mfc/reference/cobject-class.md#serialize)
