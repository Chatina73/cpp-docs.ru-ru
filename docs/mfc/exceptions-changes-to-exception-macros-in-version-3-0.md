---
title: 'Исключения: Изменения макроса исключений в версии 3.0'
ms.date: 11/04/2016
helpviewer_keywords:
- C++ exception handling [MFC], upgrade considerations
- CATCH macro [MFC]
- exceptions [MFC], what's changed
- THROW_LAST macro [MFC]
ms.assetid: 3aa20d8c-229e-449c-995c-ab879eac84bc
ms.openlocfilehash: fb51ad91e001f0ed153bf4fdb5aa598ab5ba5042
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62173285"
---
# <a name="exceptions-changes-to-exception-macros-in-version-30"></a>Исключения: Изменения макроса исключений в версии 3.0

Это довольно сложная тема.

В MFC 3.0 и более поздних версий Чтобы использовать исключения C++ были изменены макросы обработки исключений. В этой статье объясняется, как эти изменения могут повлиять на поведение существующего кода, использующего макросы.

В этой статье рассматриваются следующие темы:

- [Типы исключений и CATCH-макрос](#_core_exception_types_and_the_catch_macro)

- [Повторное создание исключений](#_core_re.2d.throwing_exceptions)

##  <a name="_core_exception_types_and_the_catch_macro"></a> Типы исключений и CATCH-макрос

В более ранних версиях MFC **CATCH** сведения о типе времени выполнения MFC использовать макрос для определения типа исключения; определить тип исключения, другими словами, на сайте получателя. С исключениями C++ Однако тип исключения всегда определяется на сайте throw тип объекта исключения, возникает исключение. Это приведет к несовместимости в тех редких случаях, где тип указатель на созданный объект отличается от типа созданного объекта.

В следующем примере демонстрируется результат этого различия между MFC версии 3.0 и более ранних версий:

[!code-cpp[NVC_MFCExceptions#1](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_1.cpp)]

Этот код работает по-разному в версии 3.0, так как управление всегда передается первому **catch** блок с соответствующим объявления исключения. Результат выражения throw

[!code-cpp[NVC_MFCExceptions#19](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_2.cpp)]

выбрасывается как `CException*`, несмотря на то, что он формируется как `CCustomException`. **CATCH** макрос в MFC версии 2.5 и более ранних версий использует `CObject::IsKindOf` проверяемый тип во время выполнения. Так как выражение

[!code-cpp[NVC_MFCExceptions#20](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_3.cpp)]

имеет значение true, первый блок catch перехватывает исключение. В версии 3.0, которая использует исключения C++ для реализации многих возможностей макросы обработки исключений, второй блок catch соответствует порождается `CException`.

Следующий код, редки. Обычно она отображается при передаче в другую функцию, которая принимает универсальный объект исключения `CException*`, выполняет обработку «предварительной throw» и наконец создает исключение.

Чтобы обойти эту проблему, переместите выражения throw из функции в вызывающий код и исключение известно компилятору во время генерации фактический тип.

##  <a name="_core_re.2d.throwing_exceptions"></a> Повторное создание исключений

Блок catch не может вызывать тот же указатель исключение, оно перехватывается.

Например, этот код является допустимым в предыдущих версиях, но будет иметь неожиданные результаты с версии 3.0:

[!code-cpp[NVC_MFCExceptions#2](../mfc/codesnippet/cpp/exceptions-changes-to-exception-macros-in-version-3-0_4.cpp)]

С помощью **THROW** catch блока приводят указатель `e` для удаления, так что сайте внешнего получателя будет получать недопустимый указатель. Используйте **THROW_LAST** для повторного создания `e`.

Дополнительные сведения см. в разделе [исключения: Перехват и удаление исключений](../mfc/exceptions-catching-and-deleting-exceptions.md).

## <a name="see-also"></a>См. также

[Обработка исключений](../mfc/exception-handling-in-mfc.md)
