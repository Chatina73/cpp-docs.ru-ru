---
title: 'TN059: Использование MFC MBCS-Unicode Преобразование Макрос'
ms.date: 11/04/2016
helpviewer_keywords:
- MFCANS32.DLL
- Unicode [MFC], conversion macros
- Unicode [MFC], OLE interfaces
- conversion macros [MFC]
- converting Unicode
- MBCS [MFC], conversion macros
- macros [MFC], MBCS conversion macros
- TN059
ms.assetid: a2aab748-94d0-4e2f-8447-3bd07112a705
ms.openlocfilehash: 657381d8247aef14b2c725996dfeb11d0e0535fe
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81749443"
---
# <a name="tn059-using-mfc-mbcsunicode-conversion-macros"></a>TN059. Использование макросов преобразования MFC из MBCS в Юникод

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой заметке описывается, как использовать макросы для преобразования MBCS/Unicode, которые определены в AFXPRIV. H. Эти макросы наиболее полезны, если ваше приложение имеет дело непосредственно с OL API или по какой-то причине часто необходимо конвертировать между Unicode и MBCS.

## <a name="overview"></a>Обзор

В MFC 3.x использовался специальный DLL (MFCANS32. DLL) для автоматической конвертации между Unicode и MBCS при вызове интерфейсов OLE. Этот DLL был почти прозрачным слоем, который позволял приложениям OLE писаться так, как будто AIS и интерфейсы OLE были MBCS, даже если они всегда являются Unicode (за исключением Macintosh). Хотя этот слой был удобен и позволял быстро портировать приложения с Win16 на Win32 (MFC, Microsoft Word, Microsoft Excel и VBA, это лишь некоторые из приложений Microsoft, которые использовали эту технологию), он иногда имел значительный удар по производительности. По этой причине MFC 4.x не использует этот DLL и вместо этого разговаривает непосредственно с интерфейсами Unicode OLE. Для этого MFC необходимо преобразовать в Unicode в MBCS при вызове интерфейса OLE, и часто необходимо преобразовать в MBCS из Unicode при реализации интерфейса OLE. Для того, чтобы справиться с этим эффективно и легко, ряд макросов были созданы, чтобы сделать это преобразование проще.

Одним из самых больших препятствий для создания такого набора макросов является распределение памяти. Поскольку строки не могут быть преобразованы на месте, необходимо выделить новую память для удержания преобразованных результатов. Это можно было бы сделать с помощью кода, похожего на следующее:

```
// we want to convert an MBCS string in lpszA
int nLen = MultiByteToWideChar(CP_ACP,
    0,
    lpszA, -1,
    NULL,
    NULL);

LPWSTR lpszW = new WCHAR[nLen];
MultiByteToWideChar(CP_ACP,
    0,
    lpszA, -1,
    lpszW,
    nLen);

// use it to call OLE here
pI->SomeFunctionThatNeedsUnicode(lpszW);

// free the string
delete[] lpszW;
```

Этот подход как ряд проблем. Основная проблема заключается в том, что это много кода для записи, тестирования и отладки. То, что было простой вызов функции, в настоящее время гораздо сложнее. Кроме того, при этом имеются значительные накладные расходы на время выполнения. Память должна быть распределена на куче и освобождена каждый раз, когда делается преобразование. Наконец, приведенный выше код `#ifdefs` должен быть добавлен соответствующим образом для сборок Unicode и Macintosh (которые не требуют этого преобразования).

Решение, которое мы придумали, заключается в создании некоторых макросов, которые 1) маскируют разницу между различными платформами, и 2) использовать эффективную схему распределения памяти, и 3) легко вставить в существующий исходный код. Вот пример одного из определений:

```
#define A2W(lpa) (\
((LPCSTR)lpa == NULL) NULL : (\
    _convert = (strnlen(lpa)+1),\
    AfxA2WHelper((LPWSTR) alloca(_convert*2),
    lpa,
    _convert)\)\)
```

Использование этого макроса вместо кода выше, и все гораздо проще:

```
// use it to call OLE here
USES_CONVERSION;
pI->SomeFunctionThatNeedsUnicode(T2OLE(lpszA));
```

Есть дополнительные вызовы, где преобразование необходимо, но с помощью макросов является простым и эффективным.

Реализация каждого макроса использует _alloca() функцию для выделения памяти из стека вместо кучи. Выделение памяти из стека происходит гораздо быстрее, чем распределение памяти на куче, и память автоматически освобождается при выходе функции. Кроме того, макросы `MultiByteToWideChar` избегают вызова (или) `WideCharToMultiByte`более одного раза. Это делается путем выделения немного больше памяти, чем это необходимо. Мы знаем, что MBC преобразуется в не более одного **WCHAR** и что для каждого **WCHAR** мы будем иметь максимум два Байта MBC. Выделяя немного больше, чем необходимо, но всегда достаточно, чтобы справиться с преобразованием второй вызов второй вызов функции преобразования избежать. Вызов к функции `AfxA2Whelper` помощника уменьшает количество толчков аргумента, которые необходимо сделать для выполнения преобразования (это `MultiByteToWideChar` приводит к меньшему коду, чем если бы он вызывался напрямую).

Для того, чтобы макросы имели пространство для хранения временной длины, необходимо объявить локальную переменную, называемую _convert, которая делает это в каждой функции, использующем макросы преобразования. Это делается путем сопозавачив USES_CONVERSION макрос, как указано выше в примере.

Есть как общие макросы преобразования и OLE конкретных макросов. Эти два различных макро-набора рассматриваются ниже. Все макросы находятся в AFXPRIV. H.

## <a name="generic-conversion-macros"></a>Общие макросы преобразования

Общие макросы преобразования образуют основной механизм. Пример макро- и реализации, показанный в предыдущем разделе, A2W, является одним из таких "общих" макросов. Это не связано с OLE конкретно. Набор общих макросов приведен ниже:

```
A2CW      (LPCSTR) -> (LPCWSTR)
A2W      (LPCSTR) -> (LPWSTR)
W2CA      (LPCWSTR) -> (LPCSTR)
W2A      (LPCWSTR) -> (LPSTR)
```

Помимо выполнения текстовых преобразований, есть также макросы и функции помощника для `TEXTMETRIC`преобразования, `DEVMODE` `BSTR`, и OLE выделенных строк. Эти макросы выходят за рамки данного обсуждения - обратитесь к AFXPRIV. H для получения дополнительной информации о тех макросов.

## <a name="ole-conversion-macros"></a>OLE Преобразование Макрос

Макросы преобразования OLE разработаны специально для обработки функций, которые ожидают символы **OLESTR.** Если вы изучите заголовки OLE, вы увидите много ссылок на **LPCOLESTR** и **OLECHAR.** Эти типы используются для обозначения типа символов, используемых в интерфейсах OLE таким образом, чтобы это не было характерно для платформы. **КАРТЫ OLECHAR** для **облика** в Платформах Win16 и Macintosh и **WCHAR** в Win32.

Для того, чтобы свести к минимуму количество **#ifdef** директив в коде MFC, у нас есть аналогичный макрос для каждого преобразования, в котором участвуют строки OLE. Следующие макросы наиболее часто используются:

```
T2COLE   (LPCTSTR) -> (LPCOLESTR)
T2OLE   (LPCTSTR) -> (LPOLESTR)
OLE2CT   (LPCOLESTR) -> (LPCTSTR)
OLE2T   (LPCOLESTR) -> (LPCSTR)
```

Опять же, Есть аналогичные макросы для выполнения TEXTMETRIC, DEVMODE, BSTR, и OLE выделенных строк. Обратитесь к AFXPRIV. H для получения дополнительной информации.

## <a name="other-considerations"></a>Другие вопросы

Не используйте макросы в плотном цикле. Например, вы не хотите писать следующий вид кода:

```cpp
void BadIterateCode(LPCTSTR lpsz)
{
    USES_CONVERSION;
    for (int ii = 0; ii <10000; ii++)
    pI->SomeMethod(ii, T2COLE(lpsz));

}
```

Приведенный выше код может привести к выделению мегабайт памяти на `lpsz` стек в зависимости от содержимого строки! Также требуется время, чтобы преобразовать строку для каждой итерации цикла. Вместо этого, переместить такие постоянные преобразования из цикла:

```cpp
void MuchBetterIterateCode(LPCTSTR lpsz)
{
    USES_CONVERSION;
    LPCOLESTR lpszT = T2COLE(lpsz);

    for (int ii = 0; ii <10000; ii++)
    pI->SomeMethod(ii, lpszT);

}
```

Если строка не является постоянной, затем инкапсулировать вызов метода в функцию. Это позволит каждый раз освобождать буфер преобразования. Пример:

```cpp
void CallSomeMethod(int ii, LPCTSTR lpsz)
{
    USES_CONVERSION;
    pI->SomeMethod(ii, T2COLE(lpsz));

}

void MuchBetterIterateCode2(LPCTSTR* lpszArray)
{
    for (int ii = 0; ii <10000; ii++)
    CallSomeMethod(ii, lpszArray[ii]);

}
```

Никогда не возвращайте результат одного из макросов, если только значение возврата не подразумевает копирование данных до возврата. Например, этот код является плохим:

```
LPTSTR BadConvert(ISomeInterface* pI)
{
    USES_CONVERSION;
    LPOLESTR lpsz = NULL;
    pI->GetFileName(&lpsz);

LPTSTR lpszT = OLE2T(lpsz);

    CoMemFree(lpsz);

return lpszT; // bad! returning alloca memory
}
```

Приведенный выше код может быть исправлен путем изменения значения возврата на что-то, что копирует значение:

```
CString BetterConvert(ISomeInterface* pI)
{
    USES_CONVERSION;
    LPOLESTR lpsz = NULL;
    pI->GetFileName(&lpsz);

LPTSTR lpszT = OLE2T(lpsz);

    CoMemFree(lpsz);

return lpszT; // CString makes copy
}
```

Макросы просты в использовании и просты в ставке в код, но, как вы можете сказать из оговорок выше, вы должны быть осторожны при их использовании.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
