---
title: 'TN059: Использование макросов преобразования MFC из MBCS в Юникод'
ms.date: 11/04/2016
helpviewer_keywords:
- MFCANS32.DLL
- Unicode [MFC], conversion macros
- Unicode [MFC], OLE interfaces
- conversion macros [MFC]
- converting Unicode
- MBCS [MFC], conversion macros
- macros [MFC], MBCS conversion macros
- TN059
ms.assetid: a2aab748-94d0-4e2f-8447-3bd07112a705
ms.openlocfilehash: 6c182ff584404fb91de8ff5e8020ec2e6ef9f950
ms.sourcegitcommit: 934cb53fa4cb59fea611bfeb9db110d8d6f7d165
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/14/2019
ms.locfileid: "65611857"
---
# <a name="tn059-using-mfc-mbcsunicode-conversion-macros"></a>TN059: Использование макросов MFC из MBCS в Юникод преобразование

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает используются макросы преобразования MBCS в Юникод, которые определяются в AFXPRIV. З. Эти макросы наиболее полезны в тех случаях, если сделками приложения непосредственно с OLE API или для какой-либо причине, часто требуется преобразование между Юникодом и многобайтовой Кодировки.

## <a name="overview"></a>Обзор

В MFC 3.x, специальные библиотеки DLL было использовать (MFCANS32. Библиотека DLL) для автоматического преобразования между Юникодом и многобайтовой Кодировкой, когда вызов интерфейсов OLE. Эта библиотека DLL было практически прозрачного слой, который разрешен OLE-приложения для записи так, будто API-интерфейсы OLE и интерфейсы MBCS, несмотря на то, что они всегда Юникода (за исключением на компьютерах Macintosh). Хотя этот уровень был удобным и разрешенные приложения быстрого переноса с Win16 на Win32 (MFC, Microsoft Word, Microsoft Excel и VBA, являются лишь некоторые из приложений Майкрософт, используется эта технология), существовавший иногда значительно снижают производительность попаданий. По этой причине MFC 4.x не использует эту библиотеку DLL и вместо этого напрямую обращается к интерфейсов OLE Юникода. Для этого MFC должен преобразовать в Юникод в MBCS, при вызовах к интерфейсу OLE и часто необходимо преобразовать в MBCS из Юникода, при реализации интерфейса OLE. Для обработки, это легко и эффективно, ряд макросов были созданы для облегчения данного преобразования.

Одним из самых серьезных препятствий создания такой набор макросов является выделение памяти. Поскольку эти строки невозможно преобразовать в месте, должен быть выделен новый объем памяти для хранения преобразованные результаты. Это могло быть сделано с кодом, аналогичную следующей:

```
// we want to convert an MBCS string in lpszA
int nLen = MultiByteToWideChar(CP_ACP,
    0,
    lpszA, -1,
    NULL,
    NULL);

LPWSTR lpszW = new WCHAR[nLen];
MultiByteToWideChar(CP_ACP,
    0,
    lpszA, -1,
    lpszW,
    nLen);

// use it to call OLE here
pI->SomeFunctionThatNeedsUnicode(lpszW);

// free the string
delete[] lpszW;
```

Этот подход, как ряд проблем. Основная проблема — это большой объем кода, чтобы создавать, тестировать и отлаживать. То, что был выполнен вызов простой функции, теперь намного сложнее. Кроме того есть значительные среду выполнения ресурсов на это. Памяти должно быть выделено в куче и освободить каждый раз, когда выполняется преобразование. Наконец, в приведенном выше коде необходимо иметь соответствующие `#ifdefs` добавлены для сборок Юникода и Macintosh (которых не требуется это преобразование должно выполняться).

У нас получилось решение — создать некоторые макросы, которые (1) маска разница между различными платформами и (2) используется схема распределения памяти для эффективной и 3) используются, можно легко вставить в существующий исходный код. Ниже приведен пример одного из определений:

```
#define A2W(lpa) (\
((LPCSTR)lpa == NULL) NULL : (\
    _convert = (strnlen(lpa)+1),\
    AfxA2WHelper((LPWSTR) alloca(_convert*2),
    lpa,
    _convert)\)\)
```

С помощью этого макроса вместо приведенного выше кода и вещи выглядят гораздо проще.

```
// use it to call OLE here
USES_CONVERSION;
pI->SomeFunctionThatNeedsUnicode(T2OLE(lpszA));
```

Существуют дополнительные вызовы, преобразование не требуется, когда использование макросов является простым и эффективным.

Реализация каждого макрос использует функцию _alloca() выделить память из стека вместо кучи. Выделение памяти из стека выполняется гораздо быстрее, чем выделение памяти в куче, а память автоматически освобождается при выходе из функции. Кроме того, макросы Избегайте вызова `MultiByteToWideChar` (или `WideCharToMultiByte`) более одного раза. Это делается путем выделения немного больше памяти, чем необходимо. Мы знаем, что MBC будет преобразовать в более одного **WCHAR** и что для каждой **WCHAR** у нас будет два MBC байт. Путем выделения немногим больше, чем необходимо, но достаточно всегда, сколько для обработки преобразования, второй вызов второй вызов функции преобразования исключается. Вызов вспомогательной функции `AfxA2Whelper` уменьшает количество аргумент Push-уведомлений, которые необходимо выполнить преобразование (в результате коде меньшего размера, чем при его вызове `MultiByteToWideChar` напрямую).

Чтобы макросы места для хранения временных длины, бывает необходимо объявить локальную переменную с именем _преобразовать, делающий это в каждой функции, которая использует макросы преобразования. Это делается путем вызова макроса определить USES_CONVERSION см. выше в примере.

Существуют макросов универсального преобразования и определенные макросы OLE. Эти два набора макрос, описаны ниже. AFXPRIV находятся все макросы. З.

## <a name="generic-conversion-macros"></a>Макросы преобразования универсального

Макросы преобразования универсального образуют базового механизма. Пример макроса и реализации, показанной в предыдущем разделе, A2W, — это один такой «generic» макрос. Она не связана с OLE специально. Набор универсальных макросов, перечисленных ниже:

```
A2CW      (LPCSTR) -> (LPCWSTR)
A2W      (LPCSTR) -> (LPWSTR)
W2CA      (LPCWSTR) -> (LPCSTR)
W2A      (LPCWSTR) -> (LPSTR)
```

Помимо выполнения преобразования текста, существуют также макросы и вспомогательные функции для преобразования `TEXTMETRIC`, `DEVMODE`, `BSTR`и выделенные строки OLE. Эти макросы выходят за рамки данной статьи — см. AFXPRIV. H описание работы с этими макросами.

## <a name="ole-conversion-macros"></a>Макросы преобразования OLE

Макросы преобразования OLE предназначены специально для функций, которые ожидают обработки **OLESTR** символов. Если посмотреть на заголовки OLE, вы увидите множество ссылок на **LPCOLESTR** и **olechar, которые ВОЗВРАЩАЮТСЯ**. Эти типы используются для ссылки на тип символов, используемые в интерфейсах OLE способом, который не относится к платформе. **Olechar, которые ВОЗВРАЩАЮТСЯ** сопоставляется **char** платформах Win16 и Macintosh и **WCHAR** в Win32.

Чтобы свести число **#ifdef** директивы в MFC кода к минимуму у нас есть аналогичные макрос для каждого преобразования, где используются строки OLE. Наиболее часто используются следующие макросы:

```
T2COLE   (LPCTSTR) -> (LPCOLESTR)
T2OLE   (LPCTSTR) -> (LPOLESTR)
OLE2CT   (LPCOLESTR) -> (LPCTSTR)
OLE2T   (LPCOLESTR) -> (LPCSTR)
```

Опять же существуют аналогичные макросы для выполнения TEXTMETRIC, DEVMODE, BSTR и OLE, выделенной строки. Обратитесь к AFXPRIV. H Дополнительные сведения.

## <a name="other-considerations"></a>Другие вопросы

Не используйте макросы в непрерывном цикле. Например не требуется писать код следующего вида:

```
void BadIterateCode(LPCTSTR lpsz)
{
    USES_CONVERSION;
    for (int ii = 0; ii <10000; ii++)
    pI->SomeMethod(ii, T2COLE(lpsz));

}
```

В приведенном выше коде может привести к выделение памяти в стеке в зависимости от того, какое содержимое строки в мегабайтах `lpsz` является! Также потребуется время, чтобы преобразовать строку для каждой итерации цикла. Вместо этого перенесите такие константы преобразования из цикла:

```
void MuchBetterIterateCode(LPCTSTR lpsz)
{
    USES_CONVERSION;
    LPCOLESTR lpszT = T2COLE(lpsz);

    for (int ii = 0; ii <10000; ii++)
    pI->SomeMethod(ii, lpszT);

}
```

Если строка не является константой, затем инкапсулировать вызов метода в функцию. Таким образом, преобразование буфера освобождаемой каждый раз. Пример:

```
void CallSomeMethod(int ii, LPCTSTR lpsz)
{
    USES_CONVERSION;
    pI->SomeMethod(ii, T2COLE(lpsz));

}

void MuchBetterIterateCode2(LPCTSTR* lpszArray)
{
    for (int ii = 0; ii <10000; ii++)
    CallSomeMethod(ii, lpszArray[ii]);

}
```

Возвращают результат этого один из макросов, никогда не в том случае, если возвращаемое значение подразумевает, что делает копию данных перед возвратом. Например этот код недопустим:

```
LPTSTR BadConvert(ISomeInterface* pI)
{
    USES_CONVERSION;
    LPOLESTR lpsz = NULL;
    pI->GetFileName(&lpsz);

LPTSTR lpszT = OLE2T(lpsz);

    CoMemFree(lpsz);

return lpszT; // bad! returning alloca memory
}
```

Приведенный выше код можно исправить, изменив возвращаемое значение к чему-то, чтобы скопировать значения:

```
CString BetterConvert(ISomeInterface* pI)
{
    USES_CONVERSION;
    LPOLESTR lpsz = NULL;
    pI->GetFileName(&lpsz);

LPTSTR lpszT = OLE2T(lpsz);

    CoMemFree(lpsz);

return lpszT; // CString makes copy
}
```

Они просты в использовании и легко вставить в код, но, как видно из выше предупреждения, необходимо соблюдать осторожность при их использовании.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
