---
title: TN059. Использование макросов преобразования с помощью MFC MBCS-Юникод
ms.date: 11/04/2016
helpviewer_keywords:
- MFCANS32.DLL
- Unicode [MFC], conversion macros
- Unicode [MFC], OLE interfaces
- conversion macros [MFC]
- converting Unicode
- MBCS [MFC], conversion macros
- macros [MFC], MBCS conversion macros
- TN059
ms.assetid: a2aab748-94d0-4e2f-8447-3bd07112a705
ms.openlocfilehash: d689e87b8f2804fe99804c6ca37a48bac01df263
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87182737"
---
# <a name="tn059-using-mfc-mbcsunicode-conversion-macros"></a>TN059. Использование макросов преобразования MFC из MBCS в Юникод

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этом заметке описывается использование макросов для преобразования MBCS/Unicode, определенных в АФКСПРИВ. Высоты. Эти макросы наиболее полезны, если приложение напрямую работает с OLE API или по какой-либо причине. часто требуется преобразование между Юникодом и MBCS.

## <a name="overview"></a>Обзор

В MFC 3. x используется специальная библиотека DLL (MFCANS32.DLL) для автоматического преобразования между Юникодом и MBCS при вызове интерфейсов OLE. Эта библиотека DLL была почти прозрачным слоем, в котором разрешено написание приложений OLE, как если бы интерфейсы API OLE и интерфейсы были многобайтовой кодировкой, хотя они всегда поддерживают Юникод (за исключением Macintosh). Хотя этот уровень был удобен и разрешено быстро перенести приложения из Win16 на Win32 (MFC, Microsoft Word, Microsoft Excel и VBA), это лишь часть приложений Майкрософт, исключающих эту технологию), но иногда существенно страдает производительность. По этой причине MFC 4. x не использует эту библиотеку DLL и вместо этого обращается непосредственно к интерфейсам OLE Юникода. Для этого MFC необходимо преобразовать в Юникод в MBCS при вызове OLE-интерфейса и часто требуется преобразовать в MBCS из Юникода при реализации интерфейса OLE. Для эффективного и простого выполнения этого преобразования было создано несколько макросов.

Одной из крупнейших трудностей при создании такого набора макросов является выделение памяти. Поскольку строки не могут быть преобразованы на месте, необходимо выделить новую память для хранения преобразованных результатов. Это можно было сделать с помощью кода, аналогичного приведенному ниже.

```
// we want to convert an MBCS string in lpszA
int nLen = MultiByteToWideChar(CP_ACP,
    0,
    lpszA, -1,
    NULL,
    NULL);

LPWSTR lpszW = new WCHAR[nLen];
MultiByteToWideChar(CP_ACP,
    0,
    lpszA, -1,
    lpszW,
    nLen);

// use it to call OLE here
pI->SomeFunctionThatNeedsUnicode(lpszW);

// free the string
delete[] lpszW;
```

Этот подход как ряд проблем. Основная проблема заключается в том, что это много кода для написания, тестирования и отладки. Нечто, что было простым вызовом функции, теперь гораздо более сложно. Кроме того, в этом случае возникают значительные издержки времени выполнения. Память должна выделяться в куче и освобождаться каждый раз, когда выполняется преобразование. Наконец, приведенный выше код должен был быть соответствующим образом `#ifdefs` добавлен для сборок в Юникоде и Macintosh (что не требует преобразования).

Решение, с которым мы поступили, заключается в создании макросов, которые 1) позволяют маскировать различия между различными платформами и 2) использовать эффективную схему выделения памяти, а 3) легко вставлять в существующий исходный код. Ниже приведен пример одного из определений:

```
#define A2W(lpa) (\
((LPCSTR)lpa == NULL) NULL : (\
    _convert = (strnlen(lpa)+1),\
    AfxA2WHelper((LPWSTR) alloca(_convert*2),
    lpa,
    _convert)\)\)
```

Использование этого макроса вместо приведенного выше кода значительно упрощает работу:

```
// use it to call OLE here
USES_CONVERSION;
pI->SomeFunctionThatNeedsUnicode(T2OLE(lpszA));
```

Существуют дополнительные вызовы, в которых требуется преобразование, но использование макросов является простым и эффективным.

Реализация каждого макроса использует функцию _alloca () для выделения памяти из стека вместо кучи. Выделение памяти из стека выполняется гораздо быстрее, чем выделение памяти в куче, и память автоматически освобождается при выходе из функции. Кроме того, макросы не вызывают `MultiByteToWideChar` (или `WideCharToMultiByte` ) более одного раза. Для этого выделяется немного больше памяти, чем требуется. Мы понимаем, что MBC будет преобразовывать не более чем на один **WCHAR** , а для каждого типа **WCHAR** будет иметь не более двух MBC байт. Выделяя немного больше, чем требуется, но достаточно всегда для обработки преобразования. второй вызов функции преобразования следует избегать. Вызов вспомогательной функции `AfxA2Whelper` сокращает количество push-уведомлений аргументов, которые должны быть выполнены для выполнения преобразования (это приводит к уменьшению объема кода, чем при вызове `MultiByteToWideChar` напрямую).

Чтобы макросы имели место для хранения временной длины, необходимо объявить локальную переменную с именем _convert, которая делает это в каждой функции, которая использует макросы преобразования. Это делается путем вызова макроса USES_CONVERSION, как показано выше в примере.

Существуют как универсальный макрос преобразования, так и специальные макросы для OLE. Эти два разных набора макросов обсуждаются ниже. Все макросы находятся в АФКСПРИВ. Высоты.

## <a name="generic-conversion-macros"></a>Универсальные макросы преобразования

Универсальный макрос преобразования формирует базовый механизм. Пример макроса и реализация, приведенные в предыдущем разделе A2W, — это один из таких «универсальных» макросов. Он не связан с OLE специально. Ниже приведен набор универсальных макросов.

```
A2CW      (LPCSTR) -> (LPCWSTR)
A2W      (LPCSTR) -> (LPWSTR)
W2CA      (LPCWSTR) -> (LPCSTR)
W2A      (LPCWSTR) -> (LPSTR)
```

Помимо преобразования текста, существуют также макросы и вспомогательные функции для преобразования `TEXTMETRIC` `DEVMODE` `BSTR` выделенных строк,, и OLE. Эти макросы выходят за рамки данного обсуждения — см. статью АФКСПРИВ. H. Дополнительные сведения об этих макросах.

## <a name="ole-conversion-macros"></a>Макросы преобразования OLE

Макросы преобразования OLE предназначены специально для обработки функций, которые должны **Олестр** символы. При изучении заголовков OLE вы увидите множество ссылок на **лпколестр** и **олечар**. Эти типы используются для обозначения типа символов, используемых в интерфейсах OLE, так, что не относится к платформе. **Олечар** сопоставляется с **`char`** платформами Win16 и Macintosh и **WCHAR** в Win32.

Чтобы число директив **#ifdef** в коде MFC было минимальным, у нас есть похожий макрос для каждого преобразования, в котором участвуют строки OLE. Чаще всего используются следующие макросы:

```
T2COLE   (LPCTSTR) -> (LPCOLESTR)
T2OLE   (LPCTSTR) -> (LPOLESTR)
OLE2CT   (LPCOLESTR) -> (LPCTSTR)
OLE2T   (LPCOLESTR) -> (LPCSTR)
```

Опять же, существуют похожие макросы для выполнения строк ТЕКСТМЕТРИК, DEVMODE, BSTR и OLE. См. АФКСПРИВ. H для получения дополнительных сведений.

## <a name="other-considerations"></a>Другие вопросы

Не используйте макросы в строгом цикле. Например, вы не хотите писать код следующего вида:

```cpp
void BadIterateCode(LPCTSTR lpsz)
{
    USES_CONVERSION;
    for (int ii = 0; ii <10000; ii++)
    pI->SomeMethod(ii, T2COLE(lpsz));

}
```

Приведенный выше код может привести к выделению мегабайтов памяти в стеке в зависимости от содержимого строки `lpsz` . Также требуется время для преобразования строки для каждой итерации цикла. Вместо этого перенесите такие преобразования констант из цикла:

```cpp
void MuchBetterIterateCode(LPCTSTR lpsz)
{
    USES_CONVERSION;
    LPCOLESTR lpszT = T2COLE(lpsz);

    for (int ii = 0; ii <10000; ii++)
    pI->SomeMethod(ii, lpszT);

}
```

Если строка не является константой, инкапсулирует вызов метода в функцию. Это позволит освободить буфер преобразования каждый раз. Пример:

```cpp
void CallSomeMethod(int ii, LPCTSTR lpsz)
{
    USES_CONVERSION;
    pI->SomeMethod(ii, T2COLE(lpsz));

}

void MuchBetterIterateCode2(LPCTSTR* lpszArray)
{
    for (int ii = 0; ii <10000; ii++)
    CallSomeMethod(ii, lpszArray[ii]);

}
```

Никогда не возвращают результат одного из макросов, если только возвращаемое значение не подразумевает создание копии данных перед возвратом. Например, этот код неисправен:

```
LPTSTR BadConvert(ISomeInterface* pI)
{
    USES_CONVERSION;
    LPOLESTR lpsz = NULL;
    pI->GetFileName(&lpsz);

LPTSTR lpszT = OLE2T(lpsz);

    CoMemFree(lpsz);

return lpszT; // bad! returning alloca memory
}
```

Приведенный выше код можно исправить, изменив возвращаемое значение на что-нибудь, которое копирует значение:

```
CString BetterConvert(ISomeInterface* pI)
{
    USES_CONVERSION;
    LPOLESTR lpsz = NULL;
    pI->GetFileName(&lpsz);

LPTSTR lpszT = OLE2T(lpsz);

    CoMemFree(lpsz);

return lpszT; // CString makes copy
}
```

Макросы просты в использовании и легко вставляются в код, но, как вы можете узнать из этих предостережений, необходимо соблюдать осторожность при их использовании.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
