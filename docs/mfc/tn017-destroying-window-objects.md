---
title: 'TN017: Уничтожение объектов окон'
ms.date: 11/04/2016
f1_keywords:
- vc.objects
helpviewer_keywords:
- destroying windows
- TN017
- PostNcDestroy method [MFC]
ms.assetid: 5bf208a5-5683-439b-92a1-547c5ded26cd
ms.openlocfilehash: 9e52112bed0f583a3f5652f9213bd5049d543a80
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57294115"
---
# <a name="tn017-destroying-window-objects"></a>TN017: Уничтожение объектов окон

Эта заметка описывает использование [CWnd::PostNcDestroy](../mfc/reference/cwnd-class.md#postncdestroy) метод. Используйте этот метод, если вы хотите сделать настраиваемые выделение `CWnd`-объекты, производные от. Эта заметка также объясняется, почему следует использовать [CWnd::DestroyWindow](../mfc/reference/cwnd-class.md#destroywindow) уничтожаемый объект Windows на C++, а не **удалить** оператор.

Если следовать указаниям, изложенным в этом разделе, вы получите несколько проблем очистки. Эти проблемы может быть результатом проблемы, например если забыть освободить памяти C++, если забыть освободить системных ресурсов, например/delete `HWND`s или освобождение объектов слишком много раз.

## <a name="the-problem"></a>Проблема

Каждый объект windows (объекта класса, производного от `CWnd`) представляет объект C++ и `HWND`. Объекты C++ выделяются в кучи приложения и `HWND`s выделяются в системных ресурсов, диспетчер окон. Так как существует несколько способов уничтожаемый объект window, необходимо предоставить набор правил, которые не позволяют системе утечки памяти или ресурсов. Эти правила следует также предотвратить объекты и дескрипторы Windows от уничтожения более одного раза.

## <a name="destroying-windows"></a>Уничтожение Windows

Ниже приведены два способа разрешенных уничтожаемый объект Windows:

- Вызов `CWnd::DestroyWindow` или Windows API `DestroyWindow`.

- Явное удаление с **удалить** оператор.

В первом случае это наиболее распространенных. Этот вариант применяется, даже если ваш код не вызывает `DestroyWindow` напрямую. Когда пользователь напрямую закрывает окно фрейма, это действие создает сообщения WM_CLOSE и ответ по умолчанию это сообщение является вызов `DestroyWindow.` при уничтожении родительского окна, Windows вызывает `DestroyWindow` для всех его дочерних узлов.

Второй случай, использование **удалить** оператор на объектах Windows, должна возникать редко. Ниже приведены некоторые случаи, когда использование **удалить** , является правильным выбором.

## <a name="auto-cleanup-with-cwndpostncdestroy"></a>Автоматическая очистка с CWnd::PostNcDestroy

Когда система уничтожает окно Windows, Windows сообщение отправлено последним в окно — WM_NCDESTROY. Значение по умолчанию `CWnd` обработчик для сообщения является [будет](../mfc/reference/cwnd-class.md#onncdestroy). `OnNcDestroy` отключает `HWND` из C++ объекта и вызвать виртуальную функцию `PostNcDestroy`. Некоторые классы переопределяют эту функцию для удаления объекта C++.

Реализация по умолчанию `CWnd::PostNcDestroy` не выполняет никаких действий, который подходит для объектов окон, которые распределены в кадре стека или внедрены в другие объекты. Это не подходит для объектов окон, которые предназначены для выделения в куче без другие объекты. Другими словами не подходит для объектов окон, которые не внедряются в остальных объектов C++.

Классы, которые предназначены для выделения в куче отдельно переопределить `PostNcDestroy` способ выполнения **удалить этот**. Эта инструкция будет освободить память, связанный с объектом C++. Несмотря на то что по умолчанию `CWnd` вызовы деструктора `DestroyWindow` Если *m_hWnd* — не NULL, это не приводит к бесконечной рекурсии, так как дескриптор будут отделены, а значение NULL во время фазы очистки.

> [!NOTE]
>  Система обычно вызывает `CWnd::PostNcDestroy` после обработки сообщений Windows WM_NCDESTROY и `HWND` и объектом окна C++ больше не подключены. Система также вызовет `CWnd::PostNcDestroy` в реализации большинство [CWnd::Create](../mfc/reference/cwnd-class.md#create) вызывает в случае сбоя. Далее в этом разделе описываются правила автоматической очистки.

## <a name="auto-cleanup-classes"></a>Классы автоматической очистки

Следующие классы не предназначены для автоматической очистки. Обычно они внедряются в остальных объектов C++ или в стеке.

- Все стандартные элементы управления Windows (`CStatic`, `CEdit`, `CListBox`, и так далее).

- Никакие из дочерних окон, полученных непосредственно из `CWnd` (например, пользовательские элементы управления).

- Окна разделителей (`CSplitterWnd`).

- По умолчанию панели элементов управления (классы, производные от `CControlBar`, см. в разделе [Технические примечания 31](../mfc/tn031-control-bars.md) для включения автоматическое удаление объекты панели элементов управления).

- Диалоговые окна (`CDialog`) предназначен для создания дочерних модальных диалогов в кадре стека.

- Стандартные диалоговые окна, за исключением `CFindReplaceDialog`.

- Диалоговые окна по умолчанию, созданных классов.

Следующие классы предназначены для автоматической очистки. Обычно они выделяются сами по себе в куче:

- Windows главного фрейма (прямо или косвенно производным `CFrameWnd`).

- Просмотреть windows (прямо или косвенно производным `CView`).

Если вы хотите прервать эти правила, необходимо переопределить `PostNcDestroy` метод в производном классе. Чтобы добавить класс автоматической очистки, вызов базового класса, а затем выполните **удалить этот**. Чтобы удалить автоматической очистки от этого класса, вызовите `CWnd::PostNcDestroy` напрямую вместо того `PostNcDestroy` метод прямого базового класса.

Чаще всего изменения поведения автоматической очистки используется для создания немодального диалогового окна, который может быть выделен в куче.

## <a name="when-to-call-delete"></a>Если для инструкции delete вызова

Мы рекомендуем вызывать `DestroyWindow` уничтожаемый объект Windows, или метод C++, или глобальным `DestroyWindow` API.

Не вызывайте глобальный `DestroyWindow` API для уничтожения окна дочерней MDI-формы. Следует использовать виртуальный метод `CWnd::DestroyWindow` вместо этого.

Для объектов окна C++ не требуют автоматической очистки с помощью **удалить** оператора может вызвать утечку памяти при попытке вызвать `DestroyWindow` в `CWnd::~CWnd` деструктор, если VTBL не указывает на правильно производного класса. Это происходит, так как системе не удается найти соответствующий метод для вызова destroy. С помощью `DestroyWindow` вместо **удалить** позволяет избежать этих проблем. Так как это может быть незначительные ошибки, компиляции в режиме отладки будет создавать следующее предупреждение, если существует риск.

```
Warning: calling DestroyWindow in CWnd::~CWnd
    OnDestroy or PostNcDestroy in derived class will not be called
```

В случае объектов C++ Windows, которые выполняют автоматической очистки, необходимо вызвать `DestroyWindow`. Если вы используете **удалить** оператор напрямую, MFC памяти с диагностикой сообщит, что при освобождении памяти два раза. Два слова являются вашей первой явный вызов и непрямого вызова **удалить этот** в реализации автоматической очистки `PostNcDestroy`.

После вызова метода `DestroyWindow` для автоматической очистки объекта, объект C++ по-прежнему будет, но *m_hWnd* будет иметь значение NULL. После вызова метода `DestroyWindow` для автоматической очистки объекта, объект C++ будут удалены, освобождается оператором delete C++ в реализации автоматической очистки `PostNcDestroy`.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
