---
title: TN017. Уничтожение объектов окон
ms.date: 11/04/2016
f1_keywords:
- vc.objects
helpviewer_keywords:
- destroying windows
- TN017
- PostNcDestroy method [MFC]
ms.assetid: 5bf208a5-5683-439b-92a1-547c5ded26cd
ms.openlocfilehash: 9802669468cbbba89f23b8ac127358d1fc15ec9f
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370425"
---
# <a name="tn017-destroying-window-objects"></a>TN017. Уничтожение объектов окон

В этой заметке описывается использование метода [CWnd::PostNcDestroy.](../mfc/reference/cwnd-class.md#postncdestroy) Используйте этот метод, если вы `CWnd`хотите сделать индивидуальное распределение объектов, полученных. В этой заметке также объясняется, почему следует использовать [CWnd::DestroyWindow](../mfc/reference/cwnd-class.md#destroywindow) для уничтожения объекта Windows вместо оператора **удаления.**

Если вы будете следовать рекомендациям в этой теме, у вас будет несколько проблем очистки. Эти проблемы могут возникнуть в результате таких проблем, как забыть об `HWND`удалении/бесплатной памяти СЗ, забвении свободных системных ресурсов, таких как s, или освобождении объектов слишком много раз.

## <a name="the-problem"></a>Проблема

Каждый объект окон (объект класса, полученный из `CWnd`) представляет `HWND`собой как объект СЗ, так и . Объекты СЗ распределяются в куче `HWND`приложения, а s распределяются в системных ресурсах менеджером окон. Поскольку существует несколько способов уничтожить объект окна, мы должны предоставить набор правил, которые предотвращают утечку системного ресурса или памяти. Эти правила также должны предотвращать более одного уничтожения объектов и ручек Windows.

## <a name="destroying-windows"></a>Уничтожение Windows

Ниже приведены два разрешенных способа уничтожения объекта Windows:

- Вызов `CWnd::DestroyWindow` или API `DestroyWindow`Windows .

- Явное удаление с помощью оператора **удаления.**

Первый случай на сегодняшний день является наиболее распространенным. Этот случай применяется даже в `DestroyWindow` том случае, если ваш код не звонит напрямую. Когда пользователь непосредственно закрывает окно кадра, это действие генерирует WM_CLOSE сообщение, и ответ `DestroyWindow.` по умолчанию на это `DestroyWindow` сообщение заключается в вызове При уничтожении родительского окна, Windows призывает всех своих детей.

Второй случай, использование оператора **удаления** на объектах Windows, должен быть редким. Ниже приведены некоторые случаи, когда использование **удаления** является правильным выбором.

## <a name="auto-cleanup-with-cwndpostncdestroy"></a>Автоочистка с CWnd::PostNcDestroy

Когда система уничтожает окно Windows, последнее сообщение Windows, отправленное в окно, WM_NCDESTROY. Обработчик по умолчанию `CWnd` для этого сообщения [CWnd::OnNcDestroy](../mfc/reference/cwnd-class.md#onncdestroy). `OnNcDestroy`отсоединит `HWND` объект с КЗ и вызовет `PostNcDestroy`виртуальную функцию. Некоторые классы переопределяют эту функцию, чтобы удалить объект C'.

Реализация по `CWnd::PostNcDestroy` умолчанию ничего не делает, что подходит для оконных объектов, которые выделены на раме стека или встроены в другие объекты. Это не подходит для оконных объектов, которые предназначены для выделения на куче без каких-либо других объектов. Другими словами, он не подходит для оконных объектов, которые не встроены в другие объекты КЗ.

Те классы, которые предназначены для выделения `PostNcDestroy` только на куче переопределить метод для выполнения **этого удаления.** Это утверждение освободит любую память, связанную с объектом C'. Несмотря на `CWnd` то, что `DestroyWindow` вызовы деструктора по умолчанию, если *m_hWnd* не являются NULL, это не приводит к бесконечной рекурсии, поскольку ручка будет отделена и небудет на этапе очистки.

> [!NOTE]
> Обычно система `CWnd::PostNcDestroy` вызывает сявра после обработки сообщения WM_NCDESTROY Windows, `HWND` а объект окна ИК больше не подключен. Система также вызовет `CWnd::PostNcDestroy` в реализации большинства [CWnd::Создание](../mfc/reference/cwnd-class.md#create) вызовов, если сбой происходит. Правила автоматической очистки описаны позже в этой теме.

## <a name="auto-cleanup-classes"></a>Авточистка Классы

Следующие классы не предназначены для автоматической очистки. Как правило, они встраиваются в другие объекты СЗз или в стек:

- Все стандартные`CStatic`элементы `CListBox`управления Windows (, `CEdit`и так далее).

- Любые детские окна, полученные непосредственно из `CWnd` (например, пользовательские элементы управления).

- Сплиттер`CSplitterWnd`окна ().

- Панели управления по умолчанию `CControlBar`(классы, полученные из, см. [Техническое примечание 31](../mfc/tn031-control-bars.md) для включения автоматического удаления для объектов панели управления).

- Диалоги (),`CDialog`предназначенные для модальных диалогов на кадре стека.

- Все стандартные диалоги, за исключением `CFindReplaceDialog`.

- Диалоги по умолчанию, созданные ClassWizard.

Следующие классы предназначены для автоматической очистки. Они, как правило, распределяются сами по себе на куче:

- Основные окна кадра (получены `CFrameWnd`прямо или косвенно из).

- Просмотр окон (полученных прямо `CView`или косвенно из).

Если вы хотите нарушить эти правила, `PostNcDestroy` необходимо переопределить метод в своем производном классе. Чтобы добавить автоочистку в свой класс, позвоните в базовый класс, а затем **удалите это.** Чтобы удалить автоочистку из класса, `CWnd::PostNcDestroy` позвоните `PostNcDestroy` непосредственно вместо метода вашего прямого базового класса.

Наиболее распространенным использованием изменения поведения автоматической очистки является создание безспособного диалога, который может быть выделен на куче.

## <a name="when-to-call-delete"></a>Когда звонить удалить

Мы рекомендуем вам `DestroyWindow` позвонить, чтобы уничтожить объект Windows, либо `DestroyWindow` метод СЗ, либо глобальный API.

Не вызывайте `DestroyWindow` глобальный API, чтобы уничтожить окно MDI Child. Вместо этого следует `CWnd::DestroyWindow` использовать виртуальный метод.

Для объектов окна СЗ, которые не выполняют автоочистку, использование оператора **удаления** может `DestroyWindow` привести `CWnd::~CWnd` к утечке памяти при попытке вызова в деструктор, если ВТБ не указывает на правильно полученный класс. Это происходит потому, что система не может найти подходящий способ уничтожить вызов. Использование `DestroyWindow` вместо **удаления** позволяет избежать этих проблем. Поскольку это может быть тонкой ошибкой, компиляция в режиме отладки будет генерировать следующее предупреждение, если вы находитесь в опасности.

```
Warning: calling DestroyWindow in CWnd::~CWnd
    OnDestroy or PostNcDestroy in derived class will not be called
```

В случае объектов Windows, которые выполняют автоочистку, необходимо `DestroyWindow`вызвать вызов. Если вы используете оператора **удаления** напрямую, разнозщик диагностической памяти MFC уведомит вас о том, что вы освобождаете память два раза. Эти два случая являются вашим первым явным вызовом и косвенным призывом **удалить это** в реализации автоматической очистки. `PostNcDestroy`

После `DestroyWindow` вызова объекта неавтоматической очистки объект СЗПо все равно будет рядом, но *m_hWnd* будет NULL. После `DestroyWindow` вызова объекта автоматической очистки объект СЗ исчез, освобожденный оператором удаления СЗ в реализации `PostNcDestroy`автоматической очистки .

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
