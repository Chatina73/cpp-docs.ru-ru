---
title: Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX
ms.date: 09/12/2018
helpviewer_keywords:
- MFC ActiveX controls [MFC], painting
- MFC ActiveX controls [MFC], optimizing
ms.assetid: 25fff9c0-4dab-4704-aaae-8dfb1065dee3
ms.openlocfilehash: fd98af90e86b6b98a856e633e50c5bf266cc466a
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81364583"
---
# <a name="mfc-activex-controls-painting-an-activex-control"></a>Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX

В этой статье описывается процесс покраски управления ActiveX и как можно изменить код краски для оптимизации процесса. (См. [Оптимизацию рисования управления](../mfc/optimizing-control-drawing.md) для методов оптимизации рисования, не имея элементов управления индивидуально восстановить ранее выбранные объекты GDI. После того, как все элементы управления были нарисованы, контейнер может автоматически восстановить исходные объекты.)

>[!IMPORTANT]
> ActiveX является устаревшей технологией, которая не должна использоваться для новых разработок. Для получения дополнительной информации о современных технологиях, которые заменяли ActiveX, [см.](activex-controls.md)

Примеры в этой статье взяты из элемента управления, созданного MFC ActiveX Control Wizard с настройками по умолчанию. Для получения дополнительной информации о создании приложения для управления скелетом [MFC ActiveX Control Wizard](../mfc/reference/mfc-activex-control-wizard.md)с помощью MFC ActiveX Control Wizard см.

Рассмотрены следующие вопросы:

- [Общий процесс покраски элемента управления и кода, созданного мастером управления ActiveX для поддержки живописи](#_core_the_painting_process_of_an_activex_control)

- [Как оптимизировать процесс покраски](#_core_optimizing_your_paint_code)

- [Как нарисовать элемент управления с помощью метафайлов](#_core_painting_your_control_using_metafiles)

## <a name="the-painting-process-of-an-activex-control"></a><a name="_core_the_painting_process_of_an_activex_control"></a>Процесс рисования ActiveX Control

Когда элементы управления ActiveX первоначально отображаются или перерисовываются, они следуют процессу покраски, аналогичному процессу покраски, разработанного с помощью MFC, с одним важным отличием: элементы управления ActiveX могут находиться в активном или неактивном состоянии.

Активный элемент управления представлен в контейнере управления ActiveX детским окном. Как и другие окна, он отвечает за саму живопись, когда WM_PAINT сообщение получено. Базовый класс элемента управления, [COleControl,](../mfc/reference/colecontrol-class.md)обрабатывает `OnPaint` это сообщение в своей функции. Эта реализация по `OnDraw` умолчанию вызывает функцию элемента управления.

Неактивный элемент управления окрашен по-разному. Когда элемент управления неактивен, его окно либо невидимо, либо отсутствует, поэтому оно не может получить сообщение о краске. Вместо этого контейнер управления `OnDraw` напрямую вызывает функцию управления. Это отличается от процесса окраски активного `OnPaint` элемента управления тем, что функция участника никогда не вызывается.

Как уже говорилось в предыдущих параграфах, обновление элемента управления ActiveX зависит от состояния элемента управления. Однако, поскольку `OnDraw` в обоих случаях фреймворк вызывает функцию участника, в эту функцию можно добавить большую часть кода живописи.

Функция `OnDraw` члена обрабатывает управляемую картину. Когда элемент управления неактивен, `OnDraw`контейнер управления вызывает, проходя контекст устройства контейнера управления и координаты прямоугольной области, занятой элементом управления.

Прямоугольник, пройденный рамкой к функции `OnDraw` члена, содержит область, занимаемую элементом управления. Если элемент управления активен, верхний левый угол (0, 0) и пройдено контекст устройства для окна ребенка, содержащего элемент управления. Если элемент управления неактивен, верхняя левая координата не обязательно (0, 0) и пройдено контекст устройства для контейнера управления, содержащего элемент управления.

> [!NOTE]
> Важно, чтобы `OnDraw` ваши изменения не зависели от верхней левой точки прямоугольника, равной (0, 0) и чтобы `OnDraw`вы рисовали только внутри прямоугольника, передаваемого к . Неожиданные результаты могут произойти, если вы рисуете за пределами прямоугольника области.

Реализация по умолчанию, предоставляемая MFC ActiveX Control Wizard в файле реализации управления (. CPP), показанный ниже, рисует прямоугольник белой щеткой и заполняет эллипс текущим цветом фона.

[!code-cpp[NVC_MFC_AxUI#1](../mfc/codesnippet/cpp/mfc-activex-controls-painting-an-activex-control_1.cpp)]

> [!NOTE]
> При рисовании элемента управления не следует делать предположения о состоянии контекста устройства, который передается в качестве параметра *pdc* в функцию. `OnDraw` Иногда контекст устройства подается контейнерным приложением и не обязательно будет инициализирован к состоянию по умолчанию. В частности, явно выберите ручки, кисти, цвета, шрифты и другие ресурсы, от которых зависит код рисования.

## <a name="optimizing-your-paint-code"></a><a name="_core_optimizing_your_paint_code"></a>Оптимизация кода краски

После того, как элемент управления успешно рисует `OnDraw` себя, следующим шагом является оптимизация функции.

Реализация управления ActiveX по умолчанию рисует всю область управления. Этого достаточно для простых элементов управления, но во многих случаях перекрашивание элемента управления было бы быстрее, если бы была перекрашена только часть, необходимая для обновления, а не весь элемент управления.

Функция `OnDraw` обеспечивает простой метод оптимизации путем передачи *rcInvalid,* прямоугольной области управления, которая нуждается в перерисовке. Используйте эту область, как правило, меньше, чем вся область управления, чтобы ускорить процесс покраски.

## <a name="painting-your-control-using-metafiles"></a><a name="_core_painting_your_control_using_metafiles"></a>Картина вашего управления с помощью metafiles

В большинстве случаев параметр *pdc* к функции `OnDraw` указывает на контекст экранного устройства (DC). Однако при печати изображений элемента управления или во время сеанса предварительного просмотра печати DC, полученный для рендеринга, представляет собой особый тип, называемый "метафилл DC". В отличие от экрана DC, который немедленно обрабатывает запросы, отправленные ему, метафилл DC хранит запросы, которые будут воспроизведены на более позднее время. Некоторые контейнерные приложения могут также выбрать визуализацию изображения управления с помощью метафайла DC, когда в режиме проектирования.

Запросы на рисование метафайлов могут быть `IViewObject::Draw` сделаны контейнером через две функции интерфейса: (эта функция также может быть вызвана для неметафайлного чертежа) и `IDataObject::GetData`. Когда метафилл DC передается в качестве одного из параметров, платформа MFC делает звонок в [COleControl::OnDrawMetafile](../mfc/reference/colecontrol-class.md#ondrawmetafile). Поскольку это виртуальная функция члена, переопределить эту функцию в классе управления, чтобы сделать любую специальную обработку. Вызовы `COleControl::OnDraw`поведения по умолчанию.

Чтобы убедиться, что элемент управления может быть нарисован как в контексте экрана, так и в метафиле устройства, необходимо использовать только функции членов, которые поддерживаются как на экране, так и в метафиле DC. Имейте в виду, что система координат не может быть измерена в пикселях.

Поскольку реализация `OnDrawMetafile` вызовов по `OnDraw` умолчанию вызывает функцию элемента управления, используйте только функции элемента, `OnDrawMetafile`которые подходят как для метафайла, так и для контекста экранного устройства, если только вы не переопределить. Ниже перечислены подмножество `CDC` функций членов, которые могут быть использованы как в метафайле, так и в контексте экранного устройства. Для получения дополнительной информации об этих *MFC Reference*функциях, см. [CDC](../mfc/reference/cdc-class.md)

|Arc|Бибблт|Хорда|
|---------|------------|-----------|
|`Ellipse`|`Escape`|`ExcludeClipRect`|
|`ExtTextOut`|`FloodFill`|`IntersectClipRect`|
|`LineTo`|`MoveTo`|`OffsetClipRgn`|
|`OffsetViewportOrg`|`OffsetWindowOrg`|`PatBlt`|
|`Pie`|`Polygon`|`Polyline`|
|`PolyPolygon`|`RealizePalette`|`RestoreDC`|
|`RoundRect`|`SaveDC`|`ScaleViewportExt`|
|`ScaleWindowExt`|`SelectClipRgn`|`SelectObject`|
|`SelectPalette`|`SetBkColor`|`SetBkMode`|
|`SetMapMode`|`SetMapperFlags`|`SetPixel`|
|`SetPolyFillMode`|`SetROP2`|`SetStretchBltMode`|
|`SetTextColor`|`SetTextJustification`|`SetViewportExt`|
|`SetViewportOrg`|`SetWindowExt`|`SetWindowORg`|
|`StretchBlt`|`TextOut`||

В дополнение `CDC` к функциям членов, есть несколько других функций, которые совместимы в метафайл е-кейд. К ним [относятся CPalette::AnimatePalette](../mfc/reference/cpalette-class.md#animatepalette), [CFont::CreateFontIndirect](../mfc/reference/cfont-class.md#createfontindirect), и три `CBrush`функции члена: [CreateBrushIndirect](../mfc/reference/cbrush-class.md#createbrushindirect), [CreateDIBPatternBrush](../mfc/reference/cbrush-class.md#createdibpatternbrush), и [CreatePatternBrush](../mfc/reference/cbrush-class.md#createpatternbrush).

Функции, которые не записаны в метафайле: [DrawFocusRect](../mfc/reference/cdc-class.md#drawfocusrect), [DrawIcon](../mfc/reference/cdc-class.md#drawicon), [DrawText](../mfc/reference/cdc-class.md#drawtext), [ExcludeUpdateRgn](../mfc/reference/cdc-class.md#excludeupdatergn), [FillRect](../mfc/reference/cdc-class.md#fillrect), [FrameRect](../mfc/reference/cdc-class.md#framerect), [GrayString](../mfc/reference/cdc-class.md#graystring), [InvertRect](../mfc/reference/cdc-class.md#invertrect), [ScrollDC](../mfc/reference/cdc-class.md#scrolldc), и [TabbedTextOut](../mfc/reference/cdc-class.md#tabbedtextout). Поскольку метафайл DC на самом деле не связан с устройством, вы не можете использовать SetDIBits, GetDIBits и CreateDIBitmap с метафайлом DC. Вы можете использовать SetDIBitsToDevice и StretchDIBits с метафайлом DC в качестве пункта назначения. [СозданиеCompatibleDC](../mfc/reference/cdc-class.md#createcompatibledc), [CreateCompatibleBitmap](../mfc/reference/cbitmap-class.md#createcompatiblebitmap)и [CreateDiscardableBitmap](../mfc/reference/cbitmap-class.md#creatediscardablebitmap) не имеют смысла с метафайлом DC.

Еще один момент, который следует учитывать при использовании метафайла DC, заключается в том, что система координат не может измеряться в пикселях. По этой причине весь код чертежа должен быть скорректирован `OnDraw` таким образом, чтобы он вписывался в прямоугольник, передаваемый в параметр *rcBounds.* Это предотвращает случайную покраску вне элемента управления, поскольку *rcBounds* представляет размер окна элемента управления.

После того как вы внедрили метафилл для управления, используйте Test Container для тестирования метафайла. Сведения о том, как получить доступ к Контейнеру для тестирования, см. в разделе [Тестирование свойств и событий в Контейнере для тестирования](../mfc/testing-properties-and-events-with-test-container.md) .

#### <a name="to-test-the-controls-metafile-using-test-container"></a>Для тестирования метафайла управления с помощью тестового контейнера

1. В меню **«Оторит контейнера** тестирования» щелкните **Вставьте новый элемент управления.**

1. В **вставьте новую** поле управления, выберите элемент управления и нажмите **OK**.

   Элемент управления будет отображаться в тестовом контейнере.

1. В меню **«Управление»** нажмите **«Нарисуйте метафил».**

   Появляется отдельное окно, в котором отображается метафайл. Можно изменить размер этого окна, чтобы увидеть, как масштабирование влияет на метафайл элемента управления. Вы можете закрыть это окно в любое время.

## <a name="see-also"></a>См. также раздел

[Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)
