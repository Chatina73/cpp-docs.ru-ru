---
title: 'Элементы ActiveX в MFC: Закраска элементов управления ActiveX | Документация Майкрософт'
ms.custom: ''
ms.date: 09/12/2018
ms.technology:
- cpp-mfc
ms.topic: conceptual
dev_langs:
- C++
helpviewer_keywords:
- MFC ActiveX controls [MFC], painting
- MFC ActiveX controls [MFC], optimizing
ms.assetid: 25fff9c0-4dab-4704-aaae-8dfb1065dee3
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 4e5b0f1b38e73523a476c83e19ab9bf812fdc2fa
ms.sourcegitcommit: a3c9e7888b8f437a170327c4c175733ad9eb0454
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2018
ms.locfileid: "50204539"
---
# <a name="mfc-activex-controls-painting-an-activex-control"></a>Элементы управления ActiveX в MFC. Закраска элементов управления ActiveX

В этой статье описывается процесс рисования элемента управления ActiveX и как его можно изменить код прорисовки для оптимизации процесса. (См. в разделе [оптимизация рисования элемента управления](../mfc/optimizing-control-drawing.md) для методики по оптимизации Рисование при отсутствии элементов управления по отдельности восстановить ранее выбранные объекты GDI. После рисования всех элементов управления контейнера можно автоматически восстановить исходные объекты.)

>[!IMPORTANT]
> ActiveX — это устаревшая технология, которая не следует использовать для разработки новых приложений. Дополнительные сведения о современных технологий, заменяющие ActiveX, см. в разделе [элементы управления ActiveX](activex-controls.md).

В этой статье относятся, например из элемента управления, созданного с помощью мастера управления MFC ActiveX с параметрами по умолчанию. Дополнительные сведения о создании приложений скелет элемента управления с помощью мастера элементов управления ActiveX MFC см. в статье [мастер элементов управления ActiveX MFC](../mfc/reference/mfc-activex-control-wizard.md).

Здесь представлены следующие разделы.

- [Общий процесс для закрашивания элемента управления и кода, созданного с помощью мастера управления ActiveX для поддержки рисования](#_core_the_painting_process_of_an_activex_control)

- [Как оптимизировать процесс рисования](#_core_optimizing_your_paint_code)

- [Способ закраски вашего элемента управления с помощью метафайлы](#_core_painting_your_control_using_metafiles)

##  <a name="_core_the_painting_process_of_an_activex_control"></a> Процесс рисования элемента управления ActiveX

Когда элементы управления ActiveX, изначально отображаются или перерисовываются, следуют процесс рисования, аналогичную других приложений, разработанных с использованием MFC, с важным отличием: элементы управления ActiveX можно в активное или неактивное состояние.

Активный элемент управления представлен в контейнере элементов управления ActiveX, дочернее окно. Как и другие окна он отвечает за рисование сам при получении сообщения WM_PAINT. Базовый класс элемента управления, [COleControl](../mfc/reference/colecontrol-class.md), обрабатывает это сообщение в его `OnPaint` функции. Эта реализация по умолчанию вызывает `OnDraw` функции элемента управления.

Неактивный элемент управления отрисовывается по-разному. Если элемент управления неактивна, его окна является существует, либо невидимым, поэтому не может получать сообщения рисования. Вместо этого контейнер элемента управления непосредственно вызывает `OnDraw` функции элемента управления. Это отличается от процесс рисования активный элемент управления, в который `OnPaint` никогда не вызывается функция-член.

Как было сказано выше, как обновляется элемент управления ActiveX зависит от состояния элемента управления. Тем не менее так как платформа вызывает `OnDraw` функция-член в обоих случаях добавьте большую часть вашего кода рисования в эту функцию-член.

`OnDraw` Функции-члена для обработки рисования элемента управления. Если элемент управления неактивен, контейнер элемента управления вызывает `OnDraw`, передавая контекст устройства контейнера элемента управления и координат прямоугольной области, элемент управления.

Прямоугольник, переданный платформой для `OnDraw` функция-член содержит область, занимаемая элемента управления. Если элемент управления активен, верхнего левого угла является (0, 0) и является переданный контекст устройства для дочернего окна, которое содержит элемент управления. Если элемент управления неактивным, верхней левой координатой не обязательно является (0, 0) и является переданный контекст устройства для контейнера элемента управления, содержащий элемент управления.

> [!NOTE]
>  Очень важно, изменения `OnDraw` не зависят от прямоугольника верхней левой точки равен (0, 0) и что можно рисовать только внутри прямоугольника, передаваемый `OnDraw`. Будет нарисована за пределы прямоугольника области может привести к непредвиденным результатам.

Реализация по умолчанию, мастер элементов управления MFC ActiveX в файле реализации элемента управления, предоставляемые (. CPP), показано ниже, рисует прямоугольник с белым кисти и выполняет заливку эллипса с текущим цветом фона.

[!code-cpp[NVC_MFC_AxUI#1](../mfc/codesnippet/cpp/mfc-activex-controls-painting-an-activex-control_1.cpp)]

> [!NOTE]
>  При рисовании элемента управления, нельзя делать предположения о состоянии контекст устройства, который передается в качестве *pdc* параметр `OnDraw` функции. Иногда контекст устройства предоставляется приложения-контейнера и не обязательно появится в состояние по умолчанию. В частности явно выберите перья, кисти, цвета, шрифты и другие ресурсы, от которых зависит ваш код рисования.

##  <a name="_core_optimizing_your_paint_code"></a> Оптимизация кода рисования

После элемента управления успешно прорисовке сам, следующим шагом является оптимизация `OnDraw` функции.

Реализация по умолчанию элемента управления ActiveX, рисование закрашивает область весь элемент управления. Этого достаточно для простых элементов управления, но во многих случаях перерисовки элемента управления будет быстрее, если только перерисована область, что требуется обновление, а не весь элемент управления.

`OnDraw` Функция обеспечивает легкий метод оптимизации, передав *rcInvalid*, прямоугольную область элемента управления, который требуется перерисовка. Эта область служит обычно меньше, чем область весь элемент управления, чтобы ускорить процесс рисования.

##  <a name="_core_painting_your_control_using_metafiles"></a> Рисование элемента управления с помощью метафайлы

В большинстве случаев *pdc* параметр `OnDraw` функциональных точек, экран контекста устройства (DC). Тем не менее при печати изображения элемента управления или во время предварительного просмотра сеанса, контроллер домена, полученных для подготовки к просмотру — это специальный тип с именем «метафайл контроллера домена». В отличие от на экран контроллера домена, который немедленно обрабатывает запросы, отправленные на него, метафайл контроллер домена хранит запросы для последующего воспроизведения в дальнейшем. Некоторые приложения-контейнеры также можно отобразить изображение элемента управления, с помощью метафайл контроллера домена в режиме разработки.

Метафайл, рисование запросы могут выполнять контейнера через две функции интерфейса: `IViewObject::Draw` (эта функция может также вызываться для рисования не метафайл) и `IDataObject::GetData`. Когда метафайл DC передается в качестве одного из параметров, платформы MFC вызывает [COleControl::OnDrawMetafile](../mfc/reference/colecontrol-class.md#ondrawmetafile). Так как это виртуальная функция-член, переопределите эту функцию в класс элемента управления для выполнения специальной обработки. Поведение по умолчанию вызывает `COleControl::OnDraw`.

Чтобы убедиться, что элемент управления, которые могут быть нарисованы в экран и метафайлов контексты устройств, необходимо использовать только функции-члены, которые поддерживаются в экран и метафайл контроллера домена. Имейте в виду, что система координат не может быть измеряется в пикселах.

Так как реализация по умолчанию `OnDrawMetafile` вызывает элемент управления `OnDraw` функции, используйте только функции-члены, которые подходят для метафайл и контекста экрана устройства, если не переопределено `OnDrawMetafile`. В следующих списках подмножество `CDC` функции-члены, которые могут использоваться в метафайл и контекста экрана устройства. Дополнительные сведения об этих функциях см. в разделе класса [CDC](../mfc/reference/cdc-class.md) в *Справочник по библиотеке MFC*.

|Дуги|BibBlt|Сочетание клавиш|
|---------|------------|-----------|
|`Ellipse`|`Escape`|`ExcludeClipRect`|
|`ExtTextOut`|`FloodFill`|`IntersectClipRect`|
|`LineTo`|`MoveTo`|`OffsetClipRgn`|
|`OffsetViewportOrg`|`OffsetWindowOrg`|`PatBlt`|
|`Pie`|`Polygon`|`Polyline`|
|`PolyPolygon`|`RealizePalette`|`RestoreDC`|
|`RoundRect`|`SaveDC`|`ScaleViewportExt`|
|`ScaleWindowExt`|`SelectClipRgn`|`SelectObject`|
|`SelectPalette`|`SetBkColor`|`SetBkMode`|
|`SetMapMode`|`SetMapperFlags`|`SetPixel`|
|`SetPolyFillMode`|`SetROP2`|`SetStretchBltMode`|
|`SetTextColor`|`SetTextJustification`|`SetViewportExt`|
|`SetViewportOrg`|`SetWindowExt`|`SetWindowORg`|
|`StretchBlt`|`TextOut`||

В дополнение к `CDC` функции-члены, существует несколько других функций, совместимых в метафайл контроллера домена. К ним относятся [CPalette::AnimatePalette](../mfc/reference/cpalette-class.md#animatepalette), [CFont::CreateFontIndirect](../mfc/reference/cfont-class.md#createfontindirect)и три функции-члены `CBrush`: [CreateBrushIndirect](../mfc/reference/cbrush-class.md#createbrushindirect), [CreateDIBPatternBrush](../mfc/reference/cbrush-class.md#createdibpatternbrush), и [CreatePatternBrush](../mfc/reference/cbrush-class.md#createpatternbrush).

Функции, которые не записываются в метафайл,: [DrawFocusRect](../mfc/reference/cdc-class.md#drawfocusrect), [DrawIcon](../mfc/reference/cdc-class.md#drawicon), [DrawText](../mfc/reference/cdc-class.md#drawtext), [ExcludeUpdateRgn](../mfc/reference/cdc-class.md#excludeupdatergn), [FillRect](../mfc/reference/cdc-class.md#fillrect), [FrameRect](../mfc/reference/cdc-class.md#framerect), [GrayString](../mfc/reference/cdc-class.md#graystring), [InvertRect](../mfc/reference/cdc-class.md#invertrect), [ScrollDC](../mfc/reference/cdc-class.md#scrolldc)и [TabbedTextOut](../mfc/reference/cdc-class.md#tabbedtextout). Так как метафайл контроллера домена не связаны с устройством, нельзя использовать SetDIBits GetDIBits и CreateDIBitmap с метафайлом контроллера домена. Можно использовать SetDIBitsToDevice и StretchDIBits с метафайлом контроллера домена в качестве цели. [Createcompatibledc; она](../mfc/reference/cdc-class.md#createcompatibledc), [CreateCompatibleBitmap](../mfc/reference/cbitmap-class.md#createcompatiblebitmap), и [CreateDiscardableBitmap](../mfc/reference/cbitmap-class.md#creatediscardablebitmap) не имеют смысла с метафайлом контроллера домена.

Другой следует учесть при использовании метафайл контроллера домена, что система координат не может быть измеряется в пикселах. По этой причине все код рисования должно быть настроено в соответствии в прямоугольнике, передаваемый `OnDraw` в *rcBounds* параметра. Это предотвращает случайное рисования вне элемента управления, так как *rcBounds* представляет размер окна элемента управления.

После реализации метафайла отрисовки для элемента управления, используйте контейнер для тестирования метафайла. Сведения о том, как получить доступ к Контейнеру для тестирования, см. в разделе [Тестирование свойств и событий в Контейнере для тестирования](../mfc/testing-properties-and-events-with-test-container.md) .

#### <a name="to-test-the-controls-metafile-using-test-container"></a>Для тестирования метафайла элемента управления с использованием тестового контейнера

1. На тестовый контейнер **изменить** меню, щелкните **вставить новый элемент управления**.

1. В **вставить новый элемент управления** поле, выберите элемент управления и нажмите кнопку **ОК**.

   Элемент управления будет отображаться в тестовом контейнере.

1. На **управления** меню, щелкните **рисования метафайла**.

   Отдельное окно отображается, в котором отображается метафайла. Можно изменить размер окна, чтобы увидеть, как Масштабирование влияет на метафайл элемента управления. Это окно можно закрыть в любое время.

## <a name="see-also"></a>См. также

[Элементы ActiveX библиотеки MFC](../mfc/mfc-activex-controls.md)

