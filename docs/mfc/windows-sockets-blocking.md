---
title: Сокеты Windows. Блокировки
ms.date: 11/04/2016
helpviewer_keywords:
- sockets [MFC], blocking mode
- Windows Sockets [MFC], Windows platforms
- Windows Sockets [MFC], blocking mode
- sockets [MFC], behavior on different Windows platforms
- blocking mode sockets
ms.assetid: 10aca9b1-bfba-41a8-9c55-ea8082181e63
ms.openlocfilehash: 26a361bc63da5f6e75144cc91fe837498a7f656b
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57272351"
---
# <a name="windows-sockets-blocking"></a>Сокеты Windows. Блокировки

В этой статье и в двух других статьях приведены некоторые проблемы в программировании сокетов Windows. В этой статье рассматриваются блокировки. Другие проблемы описанные в статьях: [Сокеты Windows. Порядок байтов](../mfc/windows-sockets-byte-ordering.md) и [сокеты Windows: Преобразование строк](../mfc/windows-sockets-converting-strings.md).

Если вы используете или являются производными от класса [CAsyncSocket](../mfc/reference/casyncsocket-class.md), вам потребуется самостоятельно управлять эти проблемы. Если вы используете или являются производными от класса [CSocket](../mfc/reference/csocket-class.md), MFC автоматически управляет ими.

## <a name="blocking"></a>Блокировки

Сокета может находиться в «режиме блокировки» или «неблокирующем режиме». Функции сокетов в режиме блокировки (или синхронный) не возвращают до их завершения их действия. Это называется блокировки, так как сокет, функция была вызвана не умеет делать — блокируется, до возвращения вызова. Вызов `Receive` функция-член, к примеру, может занять сколь угодно долго для завершения, так как оно ожидает отправляющего приложения для отправки (это происходит, если вы используете `CSocket`, или с помощью `CAsyncSocket` с периодами блокирования). Если `CAsyncSocket` объект находится в неблокирующем режиме (в асинхронном), то вызов возвращается немедленно и текущий код ошибки, извлекаемые с [GetLastError](../mfc/reference/casyncsocket-class.md#getlasterror) функцию-член, **WSAEWOULDBLOCK**, указывающее, что вызов может быть заблокирован был не возвращается немедленно из-за режима. (`CSocket` никогда не возвращает **WSAEWOULDBLOCK**. Этот класс управляет блокировки для вас.)

Поведение сокетов отличается в 32-разрядных и 64-разрядных операционных системах (например, Windows 95 или Windows 98) чем в 16-разрядных операционных системах (например, Windows 3.1). В отличие от 16-разрядных операционных системах 32-разрядных и 64-разрядных операционных систем используйте вытесняющую многозадачность и предоставить многопоточности. В 32-разрядных и 64-разрядных операционных системах можно поместить сокетов в отдельных рабочих потоков. Сокет в поток можно заблокировать, не конфликтуют с другими действиями в приложении и не тратить время вычислений на блокировку. Сведения о многопоточном программировании см. в статье [многопоточность](../parallel/multithreading-support-for-older-code-visual-cpp.md).

> [!NOTE]
>  В многопоточных приложениях можно использовать блокировки характер `CSocket` для упрощения разработки программы без влияния на скорость реагирования пользовательского интерфейса. Обрабатывая взаимодействия с пользователем в основном потоке и `CSocket` обработки в альтернативных потоков, можно отделить эти логические операции. В приложении, которое не является многопоточным, эти два действия необходимо следует объединить и обрабатывается как один поток, что обычно означает использование `CAsyncSocket` облегчит вам работу запросов связи по запросу или переопределение `CSocket::OnMessagePending` для обработки действий пользователя во время длительных синхронного действия.

Остальная часть данного обсуждения представляет для программистов, предназначенных для 16-разрядных операционных системах:

Как правило если вы используете `CAsyncSocket`, следует избегать использования операций блокировки и работать асинхронно вместо этого. В асинхронных операций, из точки, по которому вы получаете **WSAEWOULDBLOCK** код ошибки после вызова метода `Receive`, например, дождитесь вашей `OnReceive` функция-член вызывается для уведомления о том, что можно прочитать еще раз. Асинхронные вызовы выполняются от обратного вызова функции уведомления обратного вызова соответствующего сокета, такие как [OnReceive](../mfc/reference/casyncsocket-class.md#onreceive).

В группе Windows заблокированных вызовов считается неудачным вариантом. По умолчанию [CAsyncSocket](../mfc/reference/casyncsocket-class.md) поддерживает асинхронные вызовы и вам необходимо управлять блокирует самостоятельно с помощью обратного вызова уведомления. Класс [CSocket](../mfc/reference/csocket-class.md), с другой стороны, является синхронным. Он передает сообщения Windows и управляет блокировки для вас.

Дополнительные сведения о блокировке см. в спецификации Windows Sockets. Дополнительные сведения о функции «On», см. в разделе [сокеты Windows: Сокета уведомления](../mfc/windows-sockets-socket-notifications.md) и [сокеты Windows: Наследование от классов сокета](../mfc/windows-sockets-deriving-from-socket-classes.md).

Дополнительные сведения см. в следующих разделах.

- [Сокеты Windows. Использование класса CAsyncSocket](../mfc/windows-sockets-using-class-casyncsocket.md)

- [Сокеты Windows. Использование сокетов с архивами](../mfc/windows-sockets-using-sockets-with-archives.md)

- [Сокеты Windows. Фон](../mfc/windows-sockets-background.md)

- [Сокеты Windows. Сокеты Stream](../mfc/windows-sockets-stream-sockets.md)

- [Сокеты Windows. Сокеты датаграмм](../mfc/windows-sockets-datagram-sockets.md)

## <a name="see-also"></a>См. также

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)<br/>
[CAsyncSocket::OnSend](../mfc/reference/casyncsocket-class.md#onsend)
