---
description: 'Подробнее: сокеты Windows: блокировка'
title: Сокеты Windows. Блокировка
ms.date: 11/04/2016
helpviewer_keywords:
- sockets [MFC], blocking mode
- Windows Sockets [MFC], Windows platforms
- Windows Sockets [MFC], blocking mode
- sockets [MFC], behavior on different Windows platforms
- blocking mode sockets
ms.assetid: 10aca9b1-bfba-41a8-9c55-ea8082181e63
ms.openlocfilehash: 21d1a2fb635f3d45e639c950a7ad1748dc3dda74
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97197456"
---
# <a name="windows-sockets-blocking"></a>Сокеты Windows. Блокировка

В этой статье и двух сопутствующих статьях объясняются некоторые проблемы, связанные с программированием Windows Sockets. В этой статье рассматривается блокировка. Другие проблемы описаны в статьях: [сокеты Windows: порядок байтов](../mfc/windows-sockets-byte-ordering.md) и [сокеты Windows: преобразование строк](../mfc/windows-sockets-converting-strings.md).

Если вы используете или наследуете от класса [CAsyncSocket](../mfc/reference/casyncsocket-class.md), вам придется самостоятельно управлять этими проблемами. Если вы используете или наследуете от класса [CSocket](../mfc/reference/csocket-class.md), MFC управляет ими.

## <a name="blocking"></a>Блокировка

Сокет может находиться в режиме блокирования или в неблокирующем режиме. Функции сокетов в блокирующем (или синхронном) режиме не возвращают, пока они не смогут завершить действие. Это называется блокировкой, так как сокет, функция которого была вызвана, не может ничего делать — блокируется, пока вызов не вернет. Например, вызов `Receive` функции-члена может занять произвольное время, так как ожидает отправки отправляющего приложения (это происходит, если используется `CSocket` или используется `CAsyncSocket` with Block). Если `CAsyncSocket` объект находится в неблокирующем режиме (работает асинхронно), вызов возвращается немедленно, а текущий код ошибки, который может быть получен с помощью функции-члена [GetLastError](../mfc/reference/casyncsocket-class.md#getlasterror) , является **всаеваулдблокк**, указывающим, что вызов был заблокирован, так как он не был возвращен немедленно из-за режима. ( `CSocket` никогда не возвращает **всаеваулдблокк**. Класс управляет блокировкой.)

Поведение сокетов отличается от 32-разрядных и 64-разрядных операционных систем (например, Windows 95 или Windows 98), чем в 16-разрядных операционных системах (например, Windows 3,1). В отличие от 16-разрядных операционных систем, 32-разрядные и 64-разрядные операционные системы используют вытесненное многозадачность и обеспечивают многопоточность. В 32-разрядных и 64-разрядных операционных системах можно разместить сокеты в отдельных рабочих потоках. Сокет в потоке может блокироваться, не мешая другим действиям в приложении и не тратя время на блокировку. Сведения о многопоточном программировании см. в статье [многопоточность](../parallel/multithreading-support-for-older-code-visual-cpp.md).

> [!NOTE]
> В многопоточных приложениях можно использовать блокирующую природу, `CSocket` чтобы упростить структуру программы, не влияя на скорость реагирования пользовательского интерфейса. При обработке взаимодействия пользователя в основном потоке и `CSocket` обработке в других потоках эти логические операции можно разделить. В приложении, которое не является многопоточным, эти два действия должны быть объединены и обработаны как единый поток, что обычно означает использование, `CAsyncSocket` поэтому вы можете обрабатывать запросы на обмен сообщениями по требованию или переопределять `CSocket::OnMessagePending` их для обработки действий пользователя во время длительной синхронной активности.

Оставшаяся часть этого обсуждения предназначена для программистов, предназначенных для 16-разрядных операционных систем:

Обычно, если используется `CAsyncSocket` , не следует использовать блокирующие операции и выполнять асинхронную работу. В асинхронных операциях с момента, когда вы получаете код ошибки **всаеваулдблокк** после вызова `Receive` , например, вы ждете, пока не будет `OnReceive` вызвана функция-член, чтобы уведомить о возможности повторного чтения. Асинхронные вызовы выполняются путем вызова обратной функции уведомления о обратном вызове сокета, например [OnReceive](../mfc/reference/casyncsocket-class.md#onreceive).

В Windows блокирующие вызовы считаются неправильными. По умолчанию [CAsyncSocket](../mfc/reference/casyncsocket-class.md) поддерживает асинхронные вызовы, и вам необходимо самостоятельно управлять блокировкой с помощью уведомлений обратного вызова. Класс [CSocket](../mfc/reference/csocket-class.md), с другой стороны, является синхронным. Она переносит сообщения Windows и управляет блокировками.

Дополнительные сведения о блокировке см. в описании спецификации сокетов Windows. Дополнительные сведения о функциях "on" см. в разделе [сокеты Windows: уведомления сокетов](../mfc/windows-sockets-socket-notifications.md) и [сокеты Windows: производные от классов сокетов](../mfc/windows-sockets-deriving-from-socket-classes.md).

Дополнительные сведения см. в разделе:

- [Сокеты Windows: использование класса CAsyncSocket](../mfc/windows-sockets-using-class-casyncsocket.md)

- [Сокеты Windows: Использование сокетов с архивами](../mfc/windows-sockets-using-sockets-with-archives.md)

- [Сокеты Windows. Фон](../mfc/windows-sockets-background.md)

- [Сокеты Windows: сокеты потоков](../mfc/windows-sockets-stream-sockets.md)

- [Сокеты Windows: сокеты датаграммы](../mfc/windows-sockets-datagram-sockets.md)

## <a name="see-also"></a>См. также раздел

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)<br/>
[CAsyncSocket:: OnSend](../mfc/reference/casyncsocket-class.md#onsend)
