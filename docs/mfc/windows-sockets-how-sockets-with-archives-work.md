---
description: 'Дополнительные сведения: сокеты Windows: как работают сокеты с архивами'
title: Сокеты Windows. Работа сокетов с архивами
ms.date: 11/19/2018
helpviewer_keywords:
- Windows Sockets [MFC], synchronous
- sockets [MFC], synchronous operation
- sockets [MFC], with archives
- synchronous state socket
- Windows Sockets [MFC], with archives
- two-state socket object
ms.assetid: d8ae4039-391d-44f0-a19b-558817affcbb
ms.openlocfilehash: 19b24a9942b7405304c9037091266b4535bffbc3
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97263547"
---
# <a name="windows-sockets-how-sockets-with-archives-work"></a>Сокеты Windows. Работа сокетов с архивами

В этой статье объясняется, как объединяются объект [CSocket](../mfc/reference/csocket-class.md) , объект [CSocketFile](../mfc/reference/csocketfile-class.md) и объект [CArchive](../mfc/reference/carchive-class.md) , чтобы упростить отправку и получение данных через сокет Windows.

В статье [сокеты Windows: пример сокетов, использующих архивы](../mfc/windows-sockets-example-of-sockets-using-archives.md) , представляет `PacketSerialize` функцию. Объект архива в этом `PacketSerialize` примере работает во многом подобно архивному объекту, переданному в функцию [сериализации](../mfc/reference/cobject-class.md#serialize) MFC. Важное отличие заключается в том, что для сокетов Архив прикрепляется не к стандартному объекту [кфиле](../mfc/reference/cfile-class.md) (обычно связанному с дискового файла), а к `CSocketFile` объекту. Вместо соединения с дискового файла `CSocketFile` объект подключается к `CSocket` объекту.

`CArchive`Объект управляет буфером. При заполнении буфера хранения архива (отправка) связанный `CFile` объект записывает содержимое буфера. Очистка буфера архива, подключенного к сокету, эквивалентна отправке сообщения. Когда буфер архива (получение) заполнен, `CFile` объект прекращает чтение, пока буфер не будет снова доступен.

Класс `CSocketFile` является производным от `CFile` , но не поддерживает функции-члены [кфиле](../mfc/reference/cfile-class.md) , такие как функции позиционирования ( `Seek` , `GetLength` , `SetLength` и т. д.), функции блокировки ( `LockRange` , `UnlockRange` ) или `GetPosition` функции. Все объекты [CSocketFile](../mfc/reference/csocketfile-class.md) должны выполнять запись или чтение последовательности байтов в связанный объект или из него `CSocket` . Поскольку файл не участвует в работе, такие операции, как и, не имеют `Seek` `GetPosition` смысла. `CSocketFile` является производным от `CFile` , поэтому он обычно наследует все эти функции-члены. Чтобы избежать этого, неподдерживаемые функции- `CFile` члены переопределяются в `CSocketFile` для создания [кнотсуппортедексцептион](../mfc/reference/cnotsupportedexception-class.md).

`CSocketFile`Объект вызывает функции члена своего `CSocket` объекта для отправки или получения данных.

На следующем рисунке показаны связи между этими объектами на обеих сторонах связи.

![CArchive, CSocketFile и CSocket](../mfc/media/vc38ia1.gif "CArchive, CSocketFile и CSocket") <br/>
CArchive, CSocketFile и CSocket

Эта очевидная сложность заключается в том, чтобы защитить вас от необходимости самостоятельно управлять сведениями о сокете. Вы создадите сокет, файл и архив, а затем начнете отправлять или получать данные, вставив их в архив или извлекая из архива. [CArchive](../mfc/reference/carchive-class.md), [CSocketFile](../mfc/reference/csocketfile-class.md)и [CSocket](../mfc/reference/csocket-class.md) управляют деталями в фоновом режиме.

`CSocket`Объект на самом деле является объектом с двумя состояниями: иногда асинхронным (обычное состояние) и иногда синхронным. В асинхронном состоянии сокет может получать асинхронные уведомления от платформы. Однако во время таких операций, как получение или отправка данных, сокет получает синхронный режим. Это означает, что сокет не будет получать дополнительные асинхронные уведомления, пока не завершится синхронная операция. Так как он переключает режимы, можно, например, сделать что-то вроде следующего:

[!code-cpp[NVC_MFCSimpleSocket#2](../mfc/codesnippet/cpp/windows-sockets-how-sockets-with-archives-work_1.cpp)]

Если `CSocket` не были реализованы в виде объекта с двумя состояниями, при обработке предыдущего уведомления может быть возможно получение дополнительных уведомлений для одного и того же вида событий. Например, при обработке объекта может появиться `OnReceive` уведомление `OnReceive` . В приведенном выше фрагменте кода извлечение `str` из архива может привести к рекурсии. При переключении состояний `CSocket` предотвращается рекурсия, препятствуя дополнительным уведомлениям. Общее правило не является уведомлениями в уведомлениях.

> [!NOTE]
> `CSocketFile`Также можно использовать в качестве файла (с ограниченным доступом) без `CArchive` объекта. По умолчанию `CSocketFile` параметр *барчивекомпатибле* конструктора имеет **значение true**. Указывает, что файловый объект предназначен для использования с архивом. Чтобы использовать объект File без архива, передайте **значение false** в параметре *барчивекомпатибле* .

В режиме «архивный» `CSocketFile` объект обеспечивает лучшую производительность и снижает опасность «взаимоблокировки». Взаимоблокировка возникает, когда оба приема сокетов ожидают друг друга или ожидают общий ресурс. Такая ситуация может возникнуть, если `CArchive` объект работал так же, `CSocketFile` как и `CFile` объект. С помощью `CFile` архива можно предположить, что при получении меньшего количества байтов, чем запрошено, достигнут конец файла. `CSocketFile`Тем не менее, данные основаны на сообщениях; буфер может содержать несколько сообщений, поэтому получение меньшего числа запрошенных байтов не подразумевает конца файла. Приложение не блокируется в этом случае, как это возможно `CFile` , и может продолжать чтение сообщений из буфера до тех пор, пока буфер не будет пустым. Функция [исбуфферемпти](../mfc/reference/carchive-class.md#isbufferempty) в полезна `CArchive` для мониторинга состояния буфера архива в таком случае.

Дополнительные сведения см. в разделе [сокеты Windows: Использование сокетов с архивами](../mfc/windows-sockets-using-sockets-with-archives.md)

## <a name="see-also"></a>См. также раздел

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)<br/>
[CObject:: Serialize](../mfc/reference/cobject-class.md#serialize)
