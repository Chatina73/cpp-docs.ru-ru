---
title: Элементы управления ActiveX в MFC. Создание подкласса элемента управления Windows
ms.date: 09/12/2018
f1_keywords:
- precreatewindow
- IsSubclassed
helpviewer_keywords:
- OnDraw method, MFC ActiveX controls
- subclassing
- DoSuperclassPaint method [MFC]
- subclassing Windows controls
- subclassing, Windows controls
- reflected messages, in ActiveX controls
- PreCreateWindow method, overriding
- MFC ActiveX controls [MFC], subclassed controls
- MFC ActiveX controls [MFC], creating
- IsSubclassed method [MFC]
ms.assetid: 3236d4de-401f-49b7-918d-c84559ecc426
ms.openlocfilehash: c68a7c9764e7f52131a90d38db22d2645eed9a4f
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84625411"
---
# <a name="mfc-activex-controls-subclassing-a-windows-control"></a>Элементы управления ActiveX в MFC. Создание подкласса элемента управления Windows

В этой статье описывается процесс создания подклассов для обычного элемента управления Windows, который создает элемент управления ActiveX. Создание подкласса существующего элемента управления Windows — это быстрый способ разработки элемента управления ActiveX. Новый элемент управления будет иметь возможности элемента управления Windows с подклассом, такого как рисование и реагирование на щелчки мыши. Пример [кнопки "](../overview/visual-cpp-samples.md) элементы управления ActiveX MFC" является примером подкласса элемента управления Windows.

>[!IMPORTANT]
> ActiveX — это устаревшая технология, которую не следует использовать для новой разработки. Дополнительные сведения о современных технологиях, которые заменяют ActiveX, см. в разделе [элементы управления ActiveX](activex-controls.md).

Чтобы создать подкласс элемента управления Windows, выполните следующие задачи.

- [Переопределение функций IsSubclassedControl и PreCreateWindow элементов COleControl](#_core_overriding_issubclassedcontrol_and_precreatewindow)

- [Изменение функции члена OnDraw](#_core_modifying_the_ondraw_member_function)

- [Обрабатывает все управляющие сообщения ActiveX (OCM), отраженные в элементе управления](#_core_handling_reflected_window_messages)

   > [!NOTE]
   > Большая часть этой работы выполняется мастером элементов управления ActiveX при выборе элемента управления для создания подклассов с помощью раскрывающегося списка **выберите класс родительского окна** на странице **Параметры управления** .

## <a name="overriding-issubclassedcontrol-and-precreatewindow"></a><a name="_core_overriding_issubclassedcontrol_and_precreatewindow"></a>Переопределение IsSubclassedControl и PreCreateWindow

Чтобы переопределить `PreCreateWindow` и `IsSubclassedControl` , добавьте следующие строки кода в **защищенный** раздел объявления класса элемента управления:

[!code-cpp[NVC_MFC_AxSub#1](codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_1.h)]

В файле реализации элемента управления (. CPP) добавьте следующие строки кода для реализации двух переопределяемых функций:

[!code-cpp[NVC_MFC_AxSub#2](codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_2.cpp)]

Обратите внимание, что в этом примере элемент управления Windows Button указан в `PreCreateWindow` . Однако все стандартные элементы управления Windows могут быть подклассами. Дополнительные сведения о стандартных элементах управления Windows см. в разделе [элементы управления](controls-mfc.md).

При создании подкласса элемента управления Windows может потребоваться указать определенные флаги (WS_) или расширенный стиль окна (WS_EX_), которые будут использоваться для создания окна элемента управления. Значения этих параметров можно задать в `PreCreateWindow` функции – члене, изменив `cs.style` `cs.dwExStyle` поля и структуры. Изменения в этих полях следует вносить с помощью операции **или** , чтобы сохранить флаги по умолчанию, заданные классом `COleControl` . Например, если элемент управления является подклассом элемента управления BUTTON и требуется, чтобы элемент управления отображался как флажок, вставьте следующую строку кода в реализацию `CSampleCtrl::PreCreateWindow` перед оператором Return:

[!code-cpp[NVC_MFC_AxSub#3](codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_3.cpp)]

Эта операция добавляет флаг стиля BS_CHECKBOX, при этом не изменяется флаг стиля по умолчанию (WS_CHILD) класса `COleControl` .

## <a name="modifying-the-ondraw-member-function"></a><a name="_core_modifying_the_ondraw_member_function"></a>Изменение функции члена OnDraw

Если необходимо, чтобы элемент управления подкласса оставался таким же, как и соответствующий элемент управления Windows, `OnDraw` функция-член элемента управления должна содержать только вызов `DoSuperclassPaint` функции-члена, как показано в следующем примере:

[!code-cpp[NVC_MFC_AxSub#4](codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_4.cpp)]

`DoSuperclassPaint`Функция члена, реализованная `COleControl` , использует процедуру окна элемента управления Windows для рисования элемента управления в заданном контексте устройства в пределах ограничивающего прямоугольника. Это делает элемент управления видимым даже в том случае, если он неактивен.

> [!NOTE]
> `DoSuperclassPaint`Функция-член будет работать только с типами элементов управления, которые позволяют передавать контекст устройства в качестве параметра *wParam* WM_PAINT сообщения. Сюда входят некоторые стандартные элементы управления Windows, такие как SCROLLBAR и BUTTON, а также все общие элементы управления. Для элементов управления, которые не поддерживают такое поведение, необходимо предоставить собственный код для правильного вывода неактивного элемента управления.

## <a name="handling-reflected-window-messages"></a><a name="_core_handling_reflected_window_messages"></a>Обработка отраженных сообщений окна

Элементы управления Windows обычно отправляют определенные окна сообщений в родительское окно. Некоторые из этих сообщений, например WM_COMMAND, предоставляют пользователю уведомление о действии. Другие, такие как WM_CTLCOLOR, используются для получения сведений из родительского окна. Элемент управления ActiveX обычно взаимодействует с родительским окном другими способами. Уведомления передаются посредством инициирования событий (отправка уведомлений о событиях), а сведения о контейнере элемента управления получаются путем доступа к внешним свойствам контейнера. Поскольку эти методы связи существуют, контейнеры элементов управления ActiveX не должны обрабатывать сообщения окон, отправленные элементом управления.

Чтобы контейнер не получал сообщения окна, отправленные подклассом Windows Control, `COleControl` создает дополнительное окно, служащее родительским для элемента управления. Это дополнительное окно, называемое «Reflector», создается только для элементов управления ActiveX, которые подклассируют элемент управления Windows и имеют тот же размер и расположение, что и окно управления. Окно Reflector перехватывает определенные сообщения окна и отправляет их обратно в элемент управления. Затем элемент управления в его процедуре Window может обработать эти отраженные сообщения, выполнив действия, подходящие для элемента управления ActiveX (например, для срабатывания события). Список перехваченных сообщений Windows и соответствующих отраженных сообщений см. в разделе [идентификаторы сообщений с отражением окна](reflected-window-message-ids.md) .

Контейнер элементов управления ActiveX может быть разработан таким образом, чтобы выполнять отражение сообщений, устраняя необходимость `COleControl` в создании окна Reflector и сокращении затрат времени выполнения для элемента управления Windows с подклассом. `COleControl`Определяет, поддерживает ли контейнер эту возможность, проверяя внешнее свойство Мессажерефлект со значением **true**.

Для обработки отраженного сообщения окна Добавьте запись в схему управляющих сообщений и реализуйте функцию обработчика. Поскольку отраженные сообщения не являются частью стандартного набора сообщений, определенных Windows, представление классов не поддерживает добавление таких обработчиков сообщений. Однако добавлять обработчик вручную не сложно.

Чтобы добавить обработчик сообщений для сообщения с отражением окна вручную, выполните следующие действия.

- В классе Control. H-файл, объявите функцию обработчика. Функция должна иметь тип возвращаемого значения **lResult** и два параметра с типами **wParam** и **lParam**соответственно. Пример.

   [!code-cpp[NVC_MFC_AxSub#5](codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_5.h)]
    [!code-cpp[NVC_MFC_AxSub#6](codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_6.h)]

- В классе Control. CPP, добавьте запись ON_MESSAGE в схему сообщений. Параметры этой записи должны быть идентификатором сообщения и именем функции обработчика. Пример.

   [!code-cpp[NVC_MFC_AxSub#7](codesnippet/cpp/mfc-activex-controls-subclassing-a-windows-control_7.cpp)]

- Кроме того, в. CPP, реализуйте `OnOcmCommand` функцию члена для обработки отраженного сообщения. Параметры *wParam* и *lParam* аналогичны параметрам исходного сообщения окна.

Пример того, как обрабатываются отраженные сообщения, см. в разделе пример [кнопки](../overview/visual-cpp-samples.md)элементов управления ACTIVEX в MFC. В нем демонстрируется `OnOcmCommand` обработчик, который обнаруживает BN_CLICKEDный код уведомления и отвечает за счет срабатывания (отправки) `Click` события.

## <a name="see-also"></a>См. также раздел

[Элементы ActiveX библиотеки MFC](mfc-activex-controls.md)
