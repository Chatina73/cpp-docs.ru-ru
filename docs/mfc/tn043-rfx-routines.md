---
description: 'Дополнительные сведения о: TN043: подпрограммы RFX'
title: TN043. Процедуры RFX
ms.date: 06/28/2018
f1_keywords:
- RFX
helpviewer_keywords:
- RFX (record field exchange), architecture
- TN043
- RFX (record field exchange)
ms.assetid: f552d0c1-2c83-4389-b472-42c9940aa713
ms.openlocfilehash: 6e5ac8271739e5cab80b79cb915b07e7d25622cf
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97215226"
---
# <a name="tn043-rfx-routines"></a>TN043. Процедуры RFX

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Это примечание описывает архитектуру обмена полями записей (RFX). В нем также описывается Написание процедуры **RFX_** .

## <a name="overview-of-record-field-exchange"></a>Общие сведения об обмене полями записей

Все функции полей набора записей выполняются с помощью кода C++. Специальных ресурсов или волшебных макросов нет. Основой механизма является виртуальная функция, которая должна быть переопределена в каждом производном классе набора записей. Он всегда находится в следующем виде:

```cpp
void CMySet::DoFieldExchange(CFieldExchange* pFX)
{
    //{{AFX_FIELD_MAP(CMySet)
        <recordset exchange field type call>
        <recordset exchange function call>
    //}}AFX_FIELD_MAP
}
```

Специальный формат комментариев AFX позволяет ClassWizard размещать и редактировать код в этой функции. Код, несовместимый с ClassWizard, должен размещаться за пределами специального формата комментариев.

В приведенном выше примере \<recordset_exchange_field_type_call> имеет вид:

```cpp
pFX->SetFieldType(CFieldExchange::outputColumn);
```

и \<recordset_exchange_function_call> имеет вид:

```cpp
RFX_Custom(pFX, "Col2", m_Col2);
```

Большинство функций **RFX_** имеют три аргумента, как показано выше, но некоторые (например `RFX_Text` , и `RFX_Binary` ) имеют дополнительные необязательные аргументы.

В каждую функцию может входить более одного **RFX_** `DoDataExchange` .

Список всех подпрограмм обмена полями набора записей, предоставляемых MFC, см. в разделе "афксдб. h".

Вызовы полей набора записей — это способ регистрации расположений в памяти (обычно элементы данных) для хранения данных полей для `CMySet` класса.

## <a name="notes"></a>Примечания

Функции полей набора записей предназначены для работы только с `CRecordset` классами. Они обычно не используются другими классами MFC.

Начальные значения данных задаются в стандартном конструкторе C++, обычно в блоке с `//{{AFX_FIELD_INIT(CMylSet)` `//}}AFX_FIELD_INIT` комментариями и.

Каждая функция **RFX_** должна поддерживать различные операции, от возврата состояния "грязного" поля до архивирования поля в процессе подготовки к редактированию поля.

Каждая функция, которая вызывает `DoFieldExchange` (например `SetFieldNull` , `IsFieldDirty` ), выполняет собственную инициализацию вокруг вызова `DoFieldExchange` .

## <a name="how-does-it-work"></a>Как это работает

Для использования обмена полями записи не нужно понимать следующее. Тем не менее, понимание того, как это работает в фоновом режиме, поможет вам написать собственную процедуру Exchange.

`DoFieldExchange`Функция-член во многом похожа на `Serialize` функцию-член — она отвечает за получение или установку данных во внешнюю форму (в данном случае столбцы из результата запроса ODBC) от/до данных элемента в классе. Параметр *pFX* является контекстом для обмена данными и аналогичен параметру *CArchive* в `CObject::Serialize` . *PFX* ( `CFieldExchange` объект) имеет индикатор операции, аналогичный, но обобщение флага направления *CArchive* . Функция RFX может поддерживать следующие операции:

- `BindParam` — Укажите, где ODBC должен извлекать данные параметров

- `BindFieldToColumn` — Укажите, где ODBC должен извлекать данные Аутпутколумн

- `Fixup` — Установка `CString/CByteArray` длины, Установка бита состояния null

- `MarkForAddNew` — Отметить "грязное", если значение изменилось с момента вызова AddNew

- `MarkForUpdate` — Пометить "грязный", если значение изменилось с момента вызова Edit

- `Name` — Добавлять имена полей для полей, помеченных как «грязные»

- `NameValue` — Добавление " \<column name> =" для полей, помеченных как "грязные"

- `Value` — Добавление "", за которым следует разделитель, например "," или ""

- `SetFieldDirty` — Задать битовое поле состояния "грязный" (т. е. изменено).

- `SetFieldNull` — Задать бит состояния, указывающий значение NULL для поля

- `IsFieldDirty` — Возвращаемое значение бита "грязного" состояния

- `IsFieldNull` — Возвращаемое значение бита состояния null

- `IsFieldNullable` — Возвращает значение TRUE, если поле может содержать значения NULL

- `StoreField` — Значение поля архива

- `LoadField` — Перезагрузка значения архивированного поля

- `GetFieldInfoValue` — Возвращает общие сведения о поле

- `GetFieldInfoOrdinal` — Возвращает общие сведения о поле

## <a name="user-extensions"></a>Пользовательские расширения

Существует несколько способов расширить механизм RFX по умолчанию. Вы можете выполнить следующие действия:

- Добавление новых типов данных. Пример:

    ```cpp
    CBookmark
    ```

- Добавьте новые процедуры Exchange (RFX_).

    ```cpp
    void AFXAPI RFX_Bigint(CFieldExchange* pFX,
        const char *szName,
        BIGINT& value);
    ```

- `DoFieldExchange`Функция члена имеет условно включенные дополнительные вызовы RFX или любые другие допустимые инструкции C++.

    ```cpp
    while (posExtraFields != NULL)
    {
        RFX_Text(pFX,
        m_listName.GetNext(posExtraFields),
        m_listValue.GetNext(posExtraValues));
    }
    ```

> [!NOTE]
> Такой код не может быть отредактирован ClassWizard и должен использоваться только за пределами специального формата комментариев.

## <a name="writing-a-custom-rfx"></a>Написание пользовательских RFX

Чтобы написать собственную пользовательскую функцию RFX, рекомендуется скопировать существующую функцию RFX и изменить ее в своих целях. Выбор подходящего RFX для копирования может значительно упростить задание. Некоторые функции RFX имеют некоторые уникальные свойства, которые следует учитывать при принятии решения о копировании.

`RFX_Long` и `RFX_Int` : это самые простые функции RFX. Значение данных не требует специальной интерпретации, а размер данных фиксирован.

`RFX_Single` и `RFX_Double` : как и в RFX_Long и RFX_Int, эти функции просты и могут использовать реализацию по умолчанию. Однако они хранятся в дбфлт. cpp вместо дбрфкс. cpp, чтобы включить загрузку библиотеки с плавающей запятой среды выполнения только при явной ссылке.

`RFX_Text` и `RFX_Binary` . Эти две функции предварительно выделяют статический буфер для хранения строковых или двоичных данных и должны зарегистрировать эти буферы с помощью ODBC SQLBindCol вместо регистрации значения &. По этой причине эти две функции имеют множество специальных кодов.

`RFX_Date`: ODBC возвращает сведения о дате и времени в собственной TIMESTAMP_STRUCT структуре данных. Эта функция динамически выделяет TIMESTAMP_STRUCT как прокси-сервер для отправки и получения данных даты и времени. Различные операции должны передавать сведения о дате и времени между объектом C++ `CTime` и прокси-сервером TIMESTAMP_STRUCT. Это значительно усложняет эту функцию, но это хороший пример использования прокси-сервера для обмена данными.

`RFX_LongBinary`: Это единственная функция RFX библиотеки классов, которая не использует привязку столбцов для получения и отправки данных. Эта функция игнорирует операцию Биндфиелдтоколумн, а во время операции исправления выделяет хранилище для хранения входящих SQL_LONGVARCHAR или SQL_LONGVARBINARY данных, а затем выполняет вызов SQLGetData для получения значения в выделенное хранилище. При подготовке к отправке значений данных обратно в источник данных (например, операции пару имя и Value) Эта функция использует функции DATA_AT_EXEC ODBC. Дополнительные сведения о работе с SQL_LONGVARBINARY и SQL_LONGVARCHARs см. в [техническом примечании 45](../mfc/tn045-mfc-database-support-for-long-varchar-varbinary.md) .

При написании собственной функции **RFX_** вы часто сможете использовать `CFieldExchange::Default` для реализации данной операции. Взгляните на реализацию по умолчанию для рассматриваемой операции. Если выполняется операция, которую вы запишете в функцию **RFX_** , можно делегировать в `CFieldExchange::Default` . Вы можете увидеть примеры вызова `CFieldExchange::Default` в дбрфкс. cpp.

Важно вызывать `IsFieldType` в начале функции RFX и возвращаться немедленно, если возвращает значение false. Этот механизм обеспечивает выполнение операций с параметрами в *аутпутколумнс* и наоборот (например `BindParam` , вызов в *аутпутколумн*). Кроме того, `IsFieldType` автоматически отслеживает количество *аутпутколумнс* (*m_nFields*) и params (*m_nParams*).

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
