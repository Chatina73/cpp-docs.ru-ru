---
title: Пошаговое руководство. С помощью новых элементов управления оболочки MFC
ms.date: 09/20/2018
helpviewer_keywords:
- shell controls (MFC)
ms.assetid: f0015caa-199d-4aaf-9501-5a239fce9095
ms.openlocfilehash: ef0e4856a844503f8d13b7b6ed37318b76b6af69
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "58772154"
---
# <a name="walkthrough-using-the-new-mfc-shell-controls"></a>Пошаговое руководство. С помощью новых элементов управления оболочки MFC

В этом пошаговом руководстве вы создадите приложение, которое проводнику Windows. Вы создадите окно, которое делится на две области. Слева будет содержать [CMFCShellTreeCtrl](../mfc/reference/cmfcshelltreectrl-class.md) объекта, который отображает рабочий стол в иерархическом представлении. Справа будет содержать [CMFCShellListCtrl](../mfc/reference/cmfcshelllistctrl-class.md) , отображение файлов в папке, выбранной в левой области.

## <a name="prerequisites"></a>Предварительные требования

В этом пошаговом руководстве предполагается, что вы настроили Visual Studio для использования **обычные параметры разработки**. Если вы используете параметр разработки, некоторые окна Visual Studio, которые мы используем в этом пошаговом руководстве не может отображаться по умолчанию.

### <a name="to-create-a-new-mfc-application-by-using-the-mfc-application-wizard"></a>Чтобы создать новое приложение MFC с помощью мастера приложений MFC

1. Используйте **мастер приложений MFC** для создания нового приложения MFC. Для запуска мастера из **файл** меню выберите **New**, а затем выберите **проекта**. **Новый проект** отображается диалоговое окно.

1. В **новый проект** диалогового окна разверните узел **Visual C++** узел в **типы проектов** области и выберите **MFC**. Затем в **шаблоны** области выберите **приложения MFC**. Введите имя проекта, например `MFCShellControls` и нажмите кнопку **ОК**. После **мастер приложений MFC** отображает, используйте следующие параметры:

    1. На **тип приложения** панели в разделе **тип приложения**снимите **документы с вкладками** параметр. Затем выберите **одного документа** и выберите **поддержка архитектуры Document/View**. В разделе **проекта стиля**выберите **Visual Studio**и из **визуальный стиль и цвета** раскрывающегося списка выберите **Office 2007 (синяя тема)**.

    1. На **поддержка составных документов** области выберите **None**.

    1. Не вносите никаких изменений в **строки шаблонов документов** области.

    1. На **Поддержка баз данных** (Visual Studio 2015 и более ранних версий), выбрать команду **None** так, как приложение не использует базу данных.

    1. На **возможностей пользовательского интерфейса** области, убедитесь, что **использовать строку меню и панель инструментов** выбран параметр. Оставьте все остальные параметры, они являются.

    1. На **дополнительные функции** панели в разделе **дополнительные функции**, выберите только **элементы управления ActiveX** и **распространенных манифеста управления**. В разделе **дополнительные области фреймов**, выберите только **редактируемую** параметр. Это приведет к мастеру создать область слева от окна с `CMFCShellTreeCtrl` внедренных.

    1. Мы не собираемся внести изменения в **классы, создаваемые** панели, нажмите кнопку **Готово** для создания нового проекта MFC.

1. Убедитесь, что приложение успешно создан путем создания и выполнения его. Для построения приложения, из **построения** меню выберите **построить решение**. Если сборка приложения прошла успешно, запустите приложение, выбрав **начать отладку** из **Отладка** меню.

   Мастер автоматически создаст приложение, имеющее стандартных меню, стандартная панель инструментов, строка состояния standard и панель Outlook слева от окна с **папки** представление и **календаря** представление .

### <a name="to-add-the-shell-list-control-to-the-document-view"></a>Добавление элемента управления списка оболочки представление документа

1. В этом разделе вы добавите экземпляр `CMFCShellListCtrl` в представление, созданная мастером. Откройте файл заголовка представления, дважды щелкнув **MFCShellControlsView.h** в **обозревателе решений**.

   Найдите `#pragma once` директив в верхней части файла заголовка. Сразу же под его добавьте следующий код в файл заголовка для `CMFCShellListCtrl`:

   ```cpp
   #include <afxShellListCtrl.h>
   ```

   Теперь добавьте переменную-член типа `CMFCShellListCtrl`. Во-первых найдите следующий комментарий в файле заголовка:

   ```cpp
   // Generated message map functions
   ```

   Немедленно выше этого комментария, добавьте следующий код:

   ```cpp
   private:
   CMFCShellListCtrl m_wndList;
   ```

1. **Мастер приложений MFC** уже создан `CMFCShellTreeCtrl` объекта в `CMainFrame` класса, но в защищенный член. Мы будем доступ к объекту более поздней версии, поэтому теперь следует создать метод доступа для него. Откройте файл заголовка MainFrm.h, дважды щелкнув его в **обозревателе решений**. Найдите следующий комментарий:

   ```cpp
   // Attributes
   ```

   Сразу же под ней добавьте следующее объявление метода:

   ```cpp
   public:
       CMFCShellTreeCtrl& GetShellTreeCtrl();
   ```

   Далее, откройте исходный файл MainFrm.cpp, дважды щелкнув его в **обозревателе решений**. В нижней части этого файла добавьте следующее определение метода:

   ```cpp
   CMFCShellTreeCtrl& CMainFrame::GetShellTreeCtrl()
   {
        return m_wndTree;
   }
   ```

1. Теперь мы обновляем `CMFCShellControlsView` класс для обработки `WM_CREATE` сообщение windows. Откройте **представление классов** и выберите `CMFCShellControlsView` класса. Щелкните правой кнопкой мыши и выберите **свойства**.

    Затем в **свойства** окно, нажмите кнопку **сообщений** значок. Прокрутите вниз, пока не найдете `WM_CREATE` сообщения. В раскрывающемся списке рядом `WM_CREATE`выберите  **\<Добавить > OnCreate**. Команда создает обработчик сообщений для нас и автоматически обновляет схемы сообщений MFC.

   В `OnCreate` метод, теперь мы создадим наш `CMFCShellListCtrl` объекта. Найти `OnCreate` определения метода в MFCShellControlsView.cpp исходный файл и замените его реализацию следующим кодом:

    ```cpp
    int CMFCShellControlsView::OnCreate(LPCREATESTRUCT lpCreateStruct)
    {
        if (CView::OnCreate(lpCreateStruct) == -1)
            return -1;

        CRect rectDummy (0, 0, 0, 0);

        m_wndList.Create(WS_CHILD | WS_VISIBLE | LVS_REPORT,
            rectDummy, this, 1);

        return 0;
    }
    ```

1. Повторите предыдущий шаг, но для `WM_SIZE` сообщения. Это вызовет представления приложений перерисовку всякий раз, когда пользователь изменяет размер окна приложения. Замените определение `OnSize` метод следующим кодом:

    ```cpp
    void CMFCShellControlsView::OnSize(UINT nType, int cx, int cy)
    {
        CView::OnSize(nType, cx, cy);

        m_wndList.SetWindowPos(NULL, -1, -1, cx, cy,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
    ```

1. Последним шагом является подключение `CMFCShellTreeCtrl` и `CMFCShellListCtrl` объектов с помощью [CMFCShellTreeCtrl::SetRelatedList](../mfc/reference/cmfcshelltreectrl-class.md#setrelatedlist) метод. После вызова метода `CMFCShellTreeCtrl::SetRelatedList`, `CMFCShellListCtrl` автоматически отображает содержимое элемента, выбранного в `CMFCShellTreeCtrl`. Мы подключаемся объекты в `OnActivateView` метод, который переопределяется из [CView::OnActivateView](../mfc/reference/cview-class.md#onactivateview).

   В файле заголовка MFCShellControlsView.h внутри `CMFCShellControlsView` объявление класса, добавьте следующее объявление метода:

    ```cpp
    protected:
    virtual void OnActivateView(BOOL bActivate,
        CView* pActivateView,
        CView* pDeactiveView);
    ```

   Затем добавьте определение для метода в исходном файле MFCShellControlsView.cpp:

    ```cpp
    void CMFCShellControlsView::OnActivateView(BOOL bActivate,
        CView* pActivateView,
        CView* pDeactiveView)
    {
        if (bActivate&& AfxGetMainWnd() != NULL)
        {
            ((CMainFrame*)AfxGetMainWnd())->GetShellTreeCtrl().SetRelatedList(&m_wndList);
        }

        CView::OnActivateView(bActivate,
            pActivateView,
            pDeactiveView);
    }
    ```

   Так как выполняется вызов методов из `CMainFrame` класса, необходимо добавить `#include` директив в верхней части исходного файла MFCShellControlsView.cpp:

    ```cpp
    #include "MainFrm.h"
    ```

1. Убедитесь, что приложение успешно создан путем создания и выполнения его. Для построения приложения, из **построения** меню выберите **построить решение**. Если сборка приложения прошла успешно, запустите его, выбрав **начать отладку** из **Отладка** меню.

   Теперь вы увидите сведения для элемента, выбранного в `CMFCShellTreeCtrl` в области представления. Если щелкнуть узел в `CMFCShellTreeCtrl`, `CMFCShellListCtrl` будут обновляться автоматически. Аналогично Если дважды щелкнуть папку в `CMFCShellListCtrl`, `CMFCShellTreeCtrl` должны обновляться автоматически.

   Щелкните правой кнопкой мыши любой элемент в элементе управления иерархического или в элементе управления списком. Получение этого же контекстного меню, как при использовании реальной **проводнике**.

## <a name="next-steps"></a>Следующие шаги

- Мастер создал панель Outlook с обоими **папки** области и **календаря** области. Вероятно, нет смысла иметь **календаря** области в **Explorer** окно, поэтому теперь удалите этой области.

- `CMFCShellListCtrl` Поддерживает просмотр файлов в различных режимах, таких как **крупные значки**, **мелкие значки**, **списка**, и **сведения**. Обновите приложение, чтобы реализовать эту функциональность. Подсказка: см. в разделе [примеры Visual C++](../overview/visual-cpp-samples.md).

## <a name="see-also"></a>См. также

[Пошаговые руководства](../mfc/walkthroughs-mfc.md)
