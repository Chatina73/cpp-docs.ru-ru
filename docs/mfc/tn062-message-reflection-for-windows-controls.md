---
title: TN062. Отражение сообщений для элементов управления окнами
ms.date: 06/28/2018
f1_keywords:
- vc.controls.messages
helpviewer_keywords:
- ON_WM_VKEYTOITEM_REFLECT macro [MFC]
- ON_WM_DRAWITEM_REFLECT macro [MFC]
- ON_WM_VSCROLL_REFLECT macro [MFC]
- ON_NOTIFY_REFLECT message [MFC]
- ON_CONTROL_REFLECT_EX macro [MFC]
- ON_UPDATE_COMMAND_UI_REFLECT macro [MFC]
- ON_NOTIFY_REFLECT_EX message [MFC]
- ON_WM_HSCROLL_REFLECT macro [MFC]
- message reflection [MFC]
- ON_WM_COMPAREITEM_REFLECT macro [MFC]
- ON_WM_MEASUREITEM_REFLECT macro [MFC]
- ON_NOTIFY message [MFC]
- WM_COMMAND [MFC]
- WM_CTLCOLOR message [MFC]
- TN062 [MFC]
- ON_WM_CHARTOITEM_REFLECT macro [MFC]
- ON_WM_CTLCOLOR_REFLECT macro [MFC]
- ON_WM_DELETEITEM_REFLECT macro [MFC]
- notification messages [MFC]
- ON_WM_PARENTNOTIFY_REFLECT macro [MFC]
- WM_NOTIFY message [MFC]
- ON_CONTROL_REFLECT macro
ms.assetid: 53efb0ba-fcda-4fa0-a3c7-14e0b78fb494
ms.openlocfilehash: aa189eec430d72bef753fef7ebbe9ad929d76c87
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50677504"
---
# <a name="tn062-message-reflection-for-windows-controls"></a>TN062. Отражение сообщений для элементов управления окнами

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Это техническое Примечание описывает отражение сообщений, новая функция в MFC 4.0. Он также содержит инструкции по созданию простого управления для повторного использования, который использует отражение сообщения.

Это техническое Примечание не рассматривается отражение сообщений применительно к элементам управления ActiveX (ранее называвшихся элементов управления OLE). См. в статье [элементы управления ActiveX: Создание подкласса элемента управления Windows](../mfc/mfc-activex-controls-subclassing-a-windows-control.md).

**Что такое отражение сообщений**

Элементы управления Windows часто отправки уведомлений родительским окнам. Например многие элементы управления отправить сообщение уведомления цвет элемента управления (WM_CTLCOLOR или одного из его вариантов) к родительскому, чтобы разрешить его для предоставления кисть для закраски фона элемента управления.

В Windows и в MFC до версии 4.0 родительского окна, часто в диалоговом окне, отвечает за обработку этих сообщений. Это означает, что код для обработки сообщения должен быть в классе родительского окна, и оно должно дублироваться в каждом классе, который должен обработать это сообщение. В приведенном выше случае каждый диалоговое окно, которое было элементов управления с помощью внешнего пришлось бы обрабатывать сообщения уведомления цвет элемента управления. Было бы гораздо проще повторно использовать код, если класс элемента управления может быть записан, который будет обрабатывать собственный цвет фона.

В MFC 4.0, по-прежнему работает старый механизм — родительские окна может обрабатывать сообщения уведомления. Кроме того, тем не менее, 4.0, MFC упрощает повторное использование, предоставляя функцию, называемую «message отражение», позволяющий обработку в окне управления дочернего или родительского окна, или в обоих этих сообщений уведомления. В примере цвет фона элемента управления, теперь можно написать класс элемента управления, который устанавливает собственный цвет фона путем обработки отраженный wm_ctlcolor-сообщение, не полагаясь на родительский. (Обратите внимание, что так как отражение сообщений реализуется классами MFC, не с Windows, родительский класс окна должен быть производным от `CWnd` для отражение сообщений для работы.)

Более старые версии MFC где-то есть аналогичную отражение сообщений, предоставляя виртуальные функции для некоторых сообщений, например сообщений для определяемых владельцем списков (WM_DRAWITEM и т. д.). Новый механизм отражения сообщение обобщенной и согласованность.

Отражение сообщений имеет обратную совместимость с кода, написанного для версии MFC до 4.0.

Если предоставленный обработчик для определенного сообщения, или для диапазона сообщения в классе родительского окна, то он будет переопределять отражаются обработчики сообщений для одного сообщения, если вы не вызываете функцию-обработчик базового класса в собственный обработчик. Например если вы обрабатываете WM_CTLCOLOR в классе диалогового окна, собственной обработки переопределит все обработчики для отраженного сообщения.

Если в классе родительского окна, вы предоставляете обработчик для конкретного сообщения WM_NOTIFY или сообщения WM_NOTIFY из диапазона, ваш обработчик будет вызываться только в том случае, если дочерний элемент управления для отправки этих сообщений не имеет обработчик отраженного сообщения через `ON_NOTIFY_REFLECT()`. Если вы используете `ON_NOTIFY_REFLECT_EX()` в схему сообщения, ваш обработчик сообщений может или не должен позволять родительского окна для обработки сообщения. Если обработчик возвращает **FALSE**, сообщение будет обрабатываться в родительском, во время вызова, который возвращает **TRUE** не допускает родительского его обработать. Обратите внимание на то, что отраженного сообщения обрабатываются перед сообщения уведомления.

При отправке сообщения WM_NOTIFY, элемент управления предлагается первый сможет обработать его. Если отправляется отраженного сообщения, родительское окно имеет первый сможет обработать его, и элемент управления будет получать отраженного сообщения. Чтобы сделать это, ему понадобится функцию обработчика событий и соответствующей записи в схеме сообщений для класса элемента управления.

Макрос схемы сообщений для отраженного сообщения несколько отличаются от обычных уведомления: он имеет *_REFLECT* к ее обычного имени добавляется. К примеру для обработки сообщения WM_NOTIFY в родительском объекте, используйте макрос ON_NOTIFY в схеме сообщений родительского элемента. Чтобы обработать сообщение, отраженные в дочерний элемент управления, используйте макрос ON_NOTIFY_REFLECT в схеме сообщений дочернего элемента управления. В некоторых случаях параметры, также отличаются. Обратите внимание, что ClassWizard можно обычно добавьте записи схемы сообщений для вас и предоставляют реализации ее основа, с правильными параметрами.

См. в разделе [tn061 сообщения: ON_NOTIFY и Wm_notify](../mfc/tn061-on-notify-and-wm-notify-messages.md) сведения о новом сообщении WM_NOTIFY.

**Записей карты и прототипы обработчика для отраженного сообщения**

Чтобы управлять уведомлениями отраженного элемента управления, используйте макросы схемы сообщений и прототипы функций, перечисленных в следующей таблице.

ClassWizard обычно можно добавить записи схемы сообщений для вас и предоставить ее основа реализации. См. в разделе [определение обработчика сообщений для сообщения отражены](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md) сведения о том, как определять обработчики для отраженного сообщения.

Чтобы преобразовать имя сообщения к имени макроса отраженный, можно добавить в начало *ON_* и добавьте *_REFLECT*. Например WM_CTLCOLOR становится ON_WM_CTLCOLOR_REFLECT. (Чтобы увидеть, какие сообщения могут быть отражены, выполняющие обратное преобразование в операциях макрос в следующей таблице).

Ниже приведены три исключения из правила выше.

- Макрос для уведомлений WM_COMMAND — ON_CONTROL_REFLECT.

- Макрос для отражения WM_NOTIFY — ON_NOTIFY_REFLECT.

- Макрос для отражения ON_UPDATE_COMMAND_UI — ON_UPDATE_COMMAND_UI_REFLECT.

В каждом из вышеперечисленных специальных случаев необходимо указать имя функции-члена обработчика. В других случаях необходимо использовать стандартное имя функции обработчика.

Значения параметров и возвращаемых значений функций приведен в имя функции или имени функции с *на* префиксом. Например `CtlColor` описан в `OnCtlColor`. Несколько обработчиков для отраженного сообщения требуется меньше параметров, чем аналогичные обработчиков в родительское окно. Просто совпадают с именами в таблице ниже имена формальных параметров в документации.

|Запись сопоставления|Прототип функции|
|---------------|------------------------|
|**ON_CONTROL_REFLECT (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **();**|
|**ON_NOTIFY_REFLECT (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **(NMHDR** <strong>\*</strong> `pNotifyStruct` **, LRESULT** <strong>\*</strong> *результат* **);**|
|**ON_UPDATE_COMMAND_UI_REFLECT (** `memberFxn` **)**|**afx_msg void** `memberFxn` **(CCmdUI** <strong>\*</strong> `pCmdUI` **);**|
|**ON_WM_CTLCOLOR_REFLECT)**|**afx_msg HBRUSH CtlColor (CDC** <strong>\*</strong> `pDC` **, целое число без знака** `nCtlColor` **);**|
|**ON_WM_DRAWITEM_REFLECT)**|**afx_msg void DrawItem (LPDRAWITEMSTRUCT** `lpDrawItemStruct` **);**|
|**ON_WM_MEASUREITEM_REFLECT)**|**afx_msg void MeasureItem (LPMEASUREITEMSTRUCT** `lpMeasureItemStruct` **);**|
|**ON_WM_DELETEITEM_REFLECT)**|**afx_msg void DeleteItem (LPDELETEITEMSTRUCT** `lpDeleteItemStruct` **);**|
|**ON_WM_COMPAREITEM_REFLECT)**|**afx_msg int CompareItem (LPCOMPAREITEMSTRUCT** `lpCompareItemStruct` **);**|
|**ON_WM_CHARTOITEM_REFLECT)**|**afx_msg int CharToItem (целое число без знака** `nKey` **, целое число без знака** `nIndex` **);**|
|**ON_WM_VKEYTOITEM_REFLECT)**|**afx_msg int VKeyToItem (целое число без знака** `nKey` **, целое число без знака** `nIndex` **);**|
|**ON_WM_HSCROLL_REFLECT)**|**afx_msg void HScroll (целое число без знака** `nSBCode` **, целое число без знака** `nPos` **);**|
|**ON_WM_VSCROLL_REFLECT)**|**afx_msg void VScroll (целое число без знака** `nSBCode` **, целое число без знака** `nPos` **);**|
|**ON_WM_PARENTNOTIFY_REFLECT)**|**afx_msg void ParentNotify (целое число без знака** `message` **, LPARAM** `lParam` **);**|

Встречаются различные версии ON_NOTIFY_REFLECT и ON_CONTROL_REFLECT макросы, которые позволяют более одного объекта (например, элемент управления и его родительским элементом) для обработки данного сообщения.

|Запись сопоставления|Прототип функции|
|---------------|------------------------|
|**ON_NOTIFY_REFLECT_EX (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg BOOL** `memberFxn` **(NMHDR** <strong>\*</strong> `pNotifyStruct` **, LRESULT** <strong>\*</strong> *результат* **);**|
|**ON_CONTROL_REFLECT_EX (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg BOOL** `memberFxn` **();**|

## <a name="handling-reflected-messages-an-example-of-a-reusable-control"></a>Обработка сообщений отражен: Пример управления для повторного использования

В этом простом примере создает повторно используемый элемент управления вызывается `CYellowEdit`. Элемент управления работает так же, как элемент управления редактирования регулярных, за исключением того, что отображается черный текст на желтом фоне. Было бы легко добавлять функции-члены, которые могут допустить `CYellowEdit` управления для отображения различных цветов.

### <a name="to-try-the-example-that-creates-a-reusable-control"></a>Чтобы выполнить этот пример, который создает повторно используемый элемент управления

1. Создайте новое диалоговое окно в существующем приложении. Дополнительные сведения см. в разделе [редактор диалоговых окон](../windows/dialog-editor.md) раздела.

   Необходимо иметь приложения, в котором для разработки управления для повторного использования. Если у вас нет существующего приложения для использования, создайте диалоговое приложение с помощью мастером приложений.

2. Использовать ClassWizard ваш проект, загруженный в Visual C++, чтобы создать новый класс с именем `CYellowEdit` на основе `CEdit`.

3. Добавьте три переменные-члены вашей `CYellowEdit` класса. Первые два будет *COLORREF* переменные для хранения цвета текста и цвет фона. Третий будет `CBrush` объект, который будет содержать кисть для закрашивания фона. `CBrush` Объекта позволяет создать кисть, один раз, просто ссылающихся на него после этого и для уничтожения кисть, которая автоматически при `CYellowEdit` управления уничтожается.

4. Инициализируйте переменные-члены, написав конструктор следующим образом:

    ```cpp
    CYellowEdit::CYellowEdit()
    {
        m_clrText = RGB(0, 0, 0);
        m_clrBkgnd = RGB(255, 255, 0);
        m_brBkgnd.CreateSolidBrush(m_clrBkgnd);
    }
    ```

5. С помощью классов, добавьте обработчик для отраженного wm_ctlcolor-сообщение для вашей `CYellowEdit` класса. Обратите внимание, что знак равенства перед именем сообщение в списке сообщений, которыми может справиться показывает, что отображается сообщение. Это описывается в [определение обработчика сообщений для сообщения отражены](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md).

   ClassWizard добавляет следующую функцию макрос и структуру схемы сообщений для вас:

    ```cpp
    ON_WM_CTLCOLOR_REFLECT()
    // Note: other code will be in between....

    HBRUSH CYellowEdit::CtlColor(CDC* pDC, UINT nCtlColor)
    {
        // TODO: Change any attributes of the DC here
        // TODO: Return a non-NULL brush if the
        //       parent's handler should not be called
        return NULL;
    }
    ```

6. Замените следующий код тела функции. Код определяет цвет текста, цвет фона текста и цвет фона для остальной части элемента управления.

    ```cpp
    pDC->SetTextColor(m_clrText);   // text
    pDC->SetBkColor(m_clrBkgnd);    // text bkgnd
    return m_brBkgnd;               // ctl bkgnd
    ```

7. Создать элемент управления редактированием в диалоговое окно, а затем присоединить его к переменной-члена, дважды щелкнув элемент управления при нажатой клавиши управления. В диалоговом окне добавления переменной-члена Готово имя переменной и выберите «Control» для категории, затем «CYellowEdit» для типа переменной. Не забудьте установить табуляции в диалоговом окне. Кроме того, не забудьте включить файл заголовка для `CYellowEdit` элемента управления в файле заголовка диалогового окна.

8. Скомпонуйте и запустите приложение. Поле ввода будет желтым фоном.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
