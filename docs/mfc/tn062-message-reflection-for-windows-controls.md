---
description: 'Дополнительные сведения о: TN062: отражение сообщений для элементов управления Windows'
title: TN062. Отражение сообщений для элементов управления окнами
ms.date: 06/28/2018
f1_keywords:
- vc.controls.messages
helpviewer_keywords:
- ON_WM_VKEYTOITEM_REFLECT macro [MFC]
- ON_WM_DRAWITEM_REFLECT macro [MFC]
- ON_WM_VSCROLL_REFLECT macro [MFC]
- ON_NOTIFY_REFLECT message [MFC]
- ON_CONTROL_REFLECT_EX macro [MFC]
- ON_UPDATE_COMMAND_UI_REFLECT macro [MFC]
- ON_NOTIFY_REFLECT_EX message [MFC]
- ON_WM_HSCROLL_REFLECT macro [MFC]
- message reflection [MFC]
- ON_WM_COMPAREITEM_REFLECT macro [MFC]
- ON_WM_MEASUREITEM_REFLECT macro [MFC]
- ON_NOTIFY message [MFC]
- WM_COMMAND [MFC]
- WM_CTLCOLOR message [MFC]
- TN062 [MFC]
- ON_WM_CHARTOITEM_REFLECT macro [MFC]
- ON_WM_CTLCOLOR_REFLECT macro [MFC]
- ON_WM_DELETEITEM_REFLECT macro [MFC]
- notification messages [MFC]
- ON_WM_PARENTNOTIFY_REFLECT macro [MFC]
- WM_NOTIFY message [MFC]
- ON_CONTROL_REFLECT macro
ms.assetid: 53efb0ba-fcda-4fa0-a3c7-14e0b78fb494
ms.openlocfilehash: 9dc106c1513032e654acfc2c4b86b8eb3b939578
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97214732"
---
# <a name="tn062-message-reflection-for-windows-controls"></a>TN062. Отражение сообщений для элементов управления окнами

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этом техническом примечании описывается отражение сообщений, Новая функция MFC 4,0. Он также содержит указания по созданию простого многократно используемого элемента управления, использующего отражение сообщений.

В этом техническом примечании не рассматривается отражение сообщений, так как оно применяется к элементам управления ActiveX (ранее — элементы управления OLE). См. статью [элементы управления ActiveX: подклассировать элемент управления Windows](../mfc/mfc-activex-controls-subclassing-a-windows-control.md).

**Что такое отражение сообщений**

Элементы управления Windows часто отправляют сообщения уведомления в родительские окна. Например, многие элементы управления отправляют сообщение об изменении цвета элемента управления (WM_CTLCOLOR или одно из его разновидностей) в родительский элемент, чтобы разрешить родительскому элементу предоставлять кисть для рисования фона элемента управления.

В Windows и MFC до версии 4,0 родительское окно, часто это диалоговое окно, отвечает за обработку этих сообщений. Это означает, что код для обработки сообщения должен находиться в классе родительского окна и должен дублироваться в каждом классе, который должен обрабатывать это сообщение. В приведенном выше случае каждое диалоговое окно, для которого требуются элементы управления с пользовательским фоном, должно будет обработано сообщение с уведомлением об изменении цвета элемента управления. Было бы гораздо проще повторно использовать код, если класс элемента управления может быть написан, который будет обрабатывать собственный цвет фона.

В MFC 4,0 старый механизм по-прежнему работает — родительские окна могут управлять сообщениями с уведомлениями. Кроме того, MFC 4,0 упрощает повторное использование, предоставляя функцию «отражение сообщения», которая позволяет обрабатывать эти сообщения уведомлений либо в окне дочернего элемента управления, либо в родительском окне, либо в обоих случаях. В примере цвет фона элемента управления теперь можно написать класс элемента управления, который задает собственный цвет фона, обрабатывая отраженное WM_CTLCOLOR сообщение — все, не полагаясь на родительский элемент. (Обратите внимание, что поскольку отражение сообщений реализовано в MFC, а не в Windows, класс родительского окна должен быть производным от класса `CWnd` для работы отражения сообщений.)

Более старые версии MFC похожи на отражение сообщений, предоставляя виртуальные функции для нескольких сообщений, таких как сообщения для списков, рисуемых владельцем (WM_DRAWITEM и т. д.). Новый механизм отражения сообщений является обобщенным и последовательным.

Отражение сообщений обратно совместимо с кодом, написанным для версий MFC до 4,0.

Если вы указали обработчик для конкретного сообщения или диапазон сообщений в классе родительского окна, он переопределит отраженные обработчики сообщений для того же сообщения, если вы не вызовете функцию обработчика базового класса в собственном обработчике. Например, при обработке WM_CTLCOLOR в классе диалогового окна Обработка переопределит все отраженные обработчики сообщений.

Если в классе родительского окна вы предоставляете обработчик для конкретного WM_NOTIFY сообщения или диапазона WM_NOTIFY сообщений, обработчик будет вызываться только в том случае, если дочерний элемент управления, отправляющий эти сообщения, не имеет отраженного обработчика сообщений с помощью `ON_NOTIFY_REFLECT()` . При использовании `ON_NOTIFY_REFLECT_EX()` в схеме сообщений обработчик сообщений может разрешить или запретить родительскому окну обработку сообщения. Если обработчик возвращает **значение false**, сообщение будет обрабатываться родительским объектом, а вызов, возвращающий **значение true** , не позволит родительскому элементу обработать его. Обратите внимание, что отраженное сообщение обрабатывается перед сообщением уведомления.

При отправке сообщения WM_NOTIFY элемент управления предлагает первый шанс его обработки. Если отправляется любое другое отраженное сообщение, родительское окно имеет первую возможность его обработки, и элемент управления получит отраженное сообщение. Для этого потребуется функция обработчика и соответствующая запись в схеме сообщений класса элемента управления.

Макрос схемы сообщений для отраженных сообщений немного отличается от обычного уведомления: он *_REFLECT* добавлен к обычному имени. Например, чтобы обрабатывал сообщение WM_NOTIFY в родительском элементе, используйте макрос ON_NOTIFY в родительской схеме сообщений. Чтобы выполнить обработку отраженного сообщения в дочернем элементе управления, используйте макрос ON_NOTIFY_REFLECT в схеме сообщений дочернего элемента управления. В некоторых случаях параметры также отличаются. Обратите внимание, что ClassWizard обычно добавляет записи схемы сообщений и предоставляет скелет реализации функций с правильными параметрами.

Сведения о новом сообщении WM_NOTIFY см. в разделе [TN061: ON_NOTIFY и WM_NOTIFY сообщения](../mfc/tn061-on-notify-and-wm-notify-messages.md) .

**Записи схемы сообщений и прототипы функций обработчика для отраженных сообщений**

Чтобы обрабатывалось сообщение уведомления элемента управления, используйте макросы схемы сообщений и прототипы функций, перечисленные в следующей таблице.

ClassWizard, как правило, могут добавлять эти записи схемы сообщений для вас и предоставлять скелет реализации функций. Сведения о том, как определить обработчики для отраженных сообщений, см. [в разделе Определение обработчика сообщений для отраженного сообщения](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md) .

Чтобы преобразовать имя сообщения в отображаемое имя макроса, добавьте в начало *ON_* и *_REFLECT* Append. Например, WM_CTLCOLOR преобразуется в ON_WM_CTLCOLOR_REFLECT. (Чтобы узнать, какие сообщения можно отразить, выполните обратное преобразование для записей макросов в таблице ниже.)

Ниже приведены три исключения из приведенного выше правила.

- Макрос для WM_COMMAND уведомлений ON_CONTROL_REFLECT.

- Макрос для отражения WM_NOTIFY ON_NOTIFY_REFLECT.

- Макрос для отражения ON_UPDATE_COMMAND_UI ON_UPDATE_COMMAND_UI_REFLECT.

В каждом из этих особых случаев необходимо указать имя функции члена обработчика. В других случаях необходимо использовать стандартное имя для функции обработчика.

Значения параметров и возвращаемых значений функций задокументированы как *в начале,* так и в имени функции. Например, `CtlColor` описан в статье `OnCtlColor` . Несколько отраженных обработчиков сообщений требуют меньше параметров, чем аналогичные обработчики в родительском окне. Просто сопоставьте имена в таблице ниже с именами формальных параметров в документации.

|Запись Map|Прототип функции|
|---------------|------------------------|
|**ON_CONTROL_REFLECT (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **( );**|
|**ON_NOTIFY_REFLECT (** `wNotifyCode` **,** `memberFxn` **)**|**afx_msg void** `memberFxn` **(NMHDR** <strong>\*</strong> `pNotifyStruct` **, LRESULT** <strong>\*</strong> *результат* **);**|
|**ON_UPDATE_COMMAND_UI_REFLECT (** `memberFxn` **)**|**afx_msg void** `memberFxn` **(Поддержка CCmdUI** <strong>\*</strong> `pCmdUI` **);**|
|**ON_WM_CTLCOLOR_REFLECT ()**|**AFX_MSG Хбруш ктлколор (CDC** <strong>\*</strong> `pDC` **, Uint** `nCtlColor` **);**|
|**ON_WM_DRAWITEM_REFLECT ()**|**afx_msg void DrawItem (лпдравитемструкт** `lpDrawItemStruct` **);**|
|**ON_WM_MEASUREITEM_REFLECT ()**|**afx_msg void меасуреитем (лпмеасуреитемструкт** `lpMeasureItemStruct` **);**|
|**ON_WM_DELETEITEM_REFLECT ()**|**afx_msg void DeleteItem (лпделетеитемструкт** `lpDeleteItemStruct` **);**|
|**ON_WM_COMPAREITEM_REFLECT ()**|**afx_msg int компареитем (лпкомпареитемструкт** `lpCompareItemStruct` **);**|
|**ON_WM_CHARTOITEM_REFLECT ()**|**afx_msg int чартоитем (uint** `nKey` **, uint** `nIndex` **);**|
|**ON_WM_VKEYTOITEM_REFLECT ()**|**afx_msg int вкэйтоитем (uint** `nKey` **, uint** `nIndex` **);**|
|**ON_WM_HSCROLL_REFLECT ()**|**afx_msg void HScroll (uint** `nSBCode` **, uint** `nPos` **);**|
|**ON_WM_VSCROLL_REFLECT ()**|**afx_msg void VScroll (uint** `nSBCode` **, uint** `nPos` **);**|
|**ON_WM_PARENTNOTIFY_REFLECT ()**|**afx_msg void парентнотифи (uint** `message` **, lParam** `lParam` **);**|

Макросы ON_NOTIFY_REFLECT и ON_CONTROL_REFLECT имеют вариации, которые позволяют нескольким объектам (например, элементу управления и его родителю) обрабатывали данное сообщение.

|Запись Map|Прототип функции|
|---------------|------------------------|
|**ON_NOTIFY_REFLECT_EX (** `wNotifyCode` **,** `memberFxn` **)**|**AFX_MSG bool** `memberFxn` **(NMHDR** <strong>\*</strong> `pNotifyStruct` **, LRESULT** <strong>\*</strong> *результат* **);**|
|**ON_CONTROL_REFLECT_EX (** `wNotifyCode` **,** `memberFxn` **)**|**AFX_MSG bool** `memberFxn` **( );**|

## <a name="handling-reflected-messages-an-example-of-a-reusable-control"></a>Обработка отраженных сообщений: пример многократно используемого элемента управления

В этом простом примере создается многократно используемый элемент управления с именем `CYellowEdit` . Элемент управления работает так же, как обычный элемент управления "поле ввода", за исключением того, что он отображает черный текст на желтом фоне. Было бы легко добавить функции-члены, позволяющие `CYellowEdit` элементу управления отображать различные цвета.

### <a name="to-try-the-example-that-creates-a-reusable-control"></a>Чтобы попробовать пример, который создает многократно используемый элемент управления

1. Создание нового диалогового окна в существующем приложении. Дополнительные сведения см. в разделе [Редактор диалоговых окон](../windows/dialog-editor.md) .

   Необходимо иметь приложение, в котором будет разрабатываться элемент управления для повторного использования. Если у вас нет приложения для использования, создайте приложение на основе диалогового окна с помощью помощью мастера.

2. Загрузив проект в Visual C++, используйте ClassWizard для создания нового класса с именем на `CYellowEdit` основе `CEdit` .

3. Добавьте три переменные члена в `CYellowEdit` класс. Первые два будут *COLORREF* переменными для хранения цвета текста и цвета фона. Третий будет `CBrush` объектом, который будет содержать кисть для рисования фона. `CBrush`Объект позволяет создать кисть один раз, просто ссылаясь на нее после этого, а также для автоматического уничтожения кисти при `CYellowEdit` уничтожении элемента управления.

4. Инициализируйте переменные члена, написав конструктор следующим образом:

    ```cpp
    CYellowEdit::CYellowEdit()
    {
        m_clrText = RGB(0, 0, 0);
        m_clrBkgnd = RGB(255, 255, 0);
        m_brBkgnd.CreateSolidBrush(m_clrBkgnd);
    }
    ```

5. С помощью ClassWizard добавьте обработчик для отраженного WM_CTLCOLOR сообщения в `CYellowEdit` класс. Обратите внимание, что знак равенства перед именем сообщения в списке сообщений, которые вы можете обменять, указывает на то, что сообщение отображается. Это описано в разделе [Определение обработчика сообщений для отраженного сообщения](../mfc/reference/defining-a-message-handler-for-a-reflected-message.md).

   ClassWizard добавляет следующий макрос схемы и функцию скелета для вас:

    ```cpp
    ON_WM_CTLCOLOR_REFLECT()
    // Note: other code will be in between....

    HBRUSH CYellowEdit::CtlColor(CDC* pDC, UINT nCtlColor)
    {
        // TODO: Change any attributes of the DC here
        // TODO: Return a non-NULL brush if the
        //       parent's handler should not be called
        return NULL;
    }
    ```

6. Замените текст функции следующим кодом. Код задает цвет текста, цвет фона текста и цвет фона для остальной части элемента управления.

    ```cpp
    pDC->SetTextColor(m_clrText);   // text
    pDC->SetBkColor(m_clrBkgnd);    // text bkgnd
    return m_brBkgnd;               // ctl bkgnd
    ```

7. Создайте элемент управления "поле ввода" в диалоговом окне, а затем присоедините его к переменной-члену, дважды щелкнув элемент управления Edit, удерживая нажатой клавишу Control. В диалоговом окне Добавление переменной члена завершите имя переменной и выберите "Управление" для категории, а затем "Циелловедит" для типа переменной. Не забудьте задать порядок табуляции в диалоговом окне. Кроме того, обязательно включите в `CYellowEdit` файл заголовка диалогового окна заголовочный файл для элемента управления.

8. Скомпонуйте и запустите приложение. Элемент управления "поле ввода" будет иметь желтый фон.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
