---
title: Практическое руководство. Создание типобезопасных коллекций
ms.date: 11/04/2016
helpviewer_keywords:
- type-safe collections [MFC]
- serializing collection-class elements [MFC]
- collection classes [MFC], type safety
- SerializeElements function [MFC]
- collection classes [MFC], template-based
- serialization [MFC], collection classes
- collection classes [MFC], deriving from nontemplate
ms.assetid: 7230b2db-4283-4083-b098-eb231bf5b89e
ms.openlocfilehash: 6ee4603f03ef8a95c218b0fe040e9606aab99ebb
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84620015"
---
# <a name="how-to-make-a-type-safe-collection"></a>Практическое руководство. Создание типобезопасных коллекций

В этой статье объясняется, как создать строго типизированные коллекции для собственных типов данных. Будут рассмотрены следующие задачи:

- [Использование классов на основе шаблонов для обеспечения безопасности типов](#_core_using_template.2d.based_classes_for_type_safety)

- [Реализация вспомогательных функций](#_core_implementing_helper_functions)

- [Использование классов нешаблонной коллекции](#_core_using_nontemplate_collection_classes)

Библиотека Microsoft Foundation Class предоставляет стандартные строго типизированные коллекции на основе шаблонов C++. Поскольку они являются шаблонами, эти классы помогают обеспечить безопасность типов и простоту использования без приведения типов и других дополнительных операций, связанных с использованием нешаблонного класса для этой цели. Пример [сбора](../overview/visual-cpp-samples.md) данных MFC демонстрирует использование классов коллекций на основе шаблонов в приложении MFC. Как правило, эти классы следует использовать каждый раз при написании нового кода коллекций.

## <a name="using-template-based-classes-for-type-safety"></a><a name="_core_using_template.2d.based_classes_for_type_safety"></a>Использование классов на основе шаблонов для обеспечения безопасности типов

#### <a name="to-use-template-based-classes"></a>Использование классов, основанных на шаблонах

1. Объявите переменную типа класса коллекции. Пример.

   [!code-cpp[NVC_MFCCollections#7](codesnippet/cpp/how-to-make-a-type-safe-collection_1.cpp)]

1. Вызовите функции члена объекта Collection. Пример.

   [!code-cpp[NVC_MFCCollections#8](codesnippet/cpp/how-to-make-a-type-safe-collection_2.cpp)]

1. При необходимости реализуйте [вспомогательные функции](reference/collection-class-helpers.md) и [сериализилементс](reference/collection-class-helpers.md#serializeelements). Дополнительные сведения о реализации этих функций см. в разделе [реализация вспомогательных функций](#_core_implementing_helper_functions).

В этом примере показано объявление списка целых чисел. Первый параметр на шаге 1 — это тип данных, хранящихся в виде элементов списка. Второй параметр указывает, каким образом данные передаются и возвращаются из функций-членов класса коллекции, например `Add` и `GetAt` .

## <a name="implementing-helper-functions"></a><a name="_core_implementing_helper_functions"></a>Реализация вспомогательных функций

Классы коллекций на основе шаблонов `CArray` , `CList` и `CMap` используют пять глобальных вспомогательных функций, которые можно настроить по мере необходимости для класса производной коллекции. Сведения об этих вспомогательных функциях см. в разделе [вспомогательные методы класса Collection](reference/collection-class-helpers.md) в *справочнике по MFC*. Реализация функции сериализации необходима для большинства случаев использования классов коллекций на основе шаблонов.

### <a name="serializing-elements"></a><a name="_core_serializing_elements"></a>Сериализация элементов

`CArray`Классы, `CList` и `CMap` вызывают `SerializeElements` для хранения элементов коллекции или их чтения из архива.

Реализация `SerializeElements` вспомогательной функции по умолчанию выполняет побитовую операцию записи из объектов в архив или побитовую операцию чтения из архива в объекты в зависимости от того, хранятся ли объекты в архиве или извлекаются из него. Переопределите `SerializeElements` , если это действие не подходит.

Если в коллекции хранятся объекты, производные от `CObject` , и в `IMPLEMENT_SERIAL` реализации класса элементов коллекции используется макрос, можно воспользоваться преимуществами функций сериализации, встроенных в `CArchive` и `CObject` :

[!code-cpp[NVC_MFCCollections#9](codesnippet/cpp/how-to-make-a-type-safe-collection_3.cpp)]

Перегруженные операторы вставки для `CArchive` вызова `CObject::Serialize` (или переопределение этой функции) для каждого `CPerson` объекта.

## <a name="using-nontemplate-collection-classes"></a><a name="_core_using_nontemplate_collection_classes"></a>Использование классов нешаблонной коллекции

MFC также поддерживает классы коллекций, появившиеся в MFC версии 1,0. Эти классы не основаны на шаблонах. Они могут использоваться для хранения данных поддерживаемых типов `CObject*` ,, `UINT` `DWORD` и `CString` . Эти предопределенные коллекции (например,) можно использовать `CObList` для хранения коллекций всех объектов, производных от `CObject` . MFC также предоставляет другие Предопределенные коллекции для хранения примитивных типов, таких как `UINT` и пустые указатели ( `void` *). В общем случае, однако, часто бывает полезно определить собственные строго типизированные коллекции для хранения объектов более конкретного класса и его производных. Обратите внимание, что делать это с классами коллекций, не основанными на шаблонах, больше работы, чем использовать классы на основе шаблонов.

Существует два способа создания строго типизированных коллекций с нешаблонными коллекциями:

1. При необходимости используйте нешаблонные коллекции с приведением типов. Это более простой подход.

1. Наследование от и расширение нешаблонной строго типизированной коллекции.

#### <a name="to-use-the-nontemplate-collections-with-type-casting"></a>Использование нешаблонных коллекций с приведением типов

1. Используйте один из нешаблонных классов, например `CWordArray` , напрямую.

   Например, можно создать `CWordArray` и добавить в него любые 32-разрядные значения, а затем извлечь их. Больше ничего делать не нужно. Вы используете только предопределенные функции.

   Можно также использовать предопределенную коллекцию, например `CObList` , для хранения любых объектов, производных от `CObject` . `CObList`Коллекция определяется для хранения указателей на `CObject` . При извлечении объекта из списка может потребоваться привести результат к нужному типу, так как `CObList` функции возвращают указатели на `CObject` . Например, при хранении `CPerson` объектов в коллекции необходимо `CObList` привести извлеченный элемент в качестве указателя на `CPerson` объект. В следующем примере `CObList` для хранения объектов используется коллекция `CPerson` :

   [!code-cpp[NVC_MFCCollections#10](codesnippet/cpp/how-to-make-a-type-safe-collection_4.cpp)]

   Эта методика использования предопределенного типа коллекции и приведения к необходимости может быть достаточной для многих задач коллекции. Если требуются дополнительные функции или безопасность типов, используйте класс на основе шаблона или выполните следующую процедуру.

#### <a name="to-derive-and-extend-a-nontemplate-type-safe-collection"></a>Получение и расширение нешаблонной строго типизированной коллекции

1. Создайте собственный класс коллекции на основе одного из предопределенных нешаблонных классов.

   При наследовании класса можно добавить типобезопасные функции-оболочки для предоставления строго типизированного интерфейса существующим функциям.

   Например, если был получен список из `CObList` для хранения `CPerson` объектов, можно добавить функции-оболочки `AddHeadPerson` и `GetHeadPerson` , как показано ниже.

   [!code-cpp[NVC_MFCCollections#11](codesnippet/cpp/how-to-make-a-type-safe-collection_5.h)]

   Эти функции-оболочки предоставляют строго типизированный способ добавления и извлечения `CPerson` объектов из производного списка. Вы видите, что для `GetHeadPerson` функции вы просто инкапсулируете приведение типов.

   Кроме того, можно добавлять новые функции, расширяя возможности коллекции, а не просто упаковывать существующие функциональные возможности в потокобезопасные оболочки. Например, статья [Удаление всех объектов в коллекции CObject](deleting-all-objects-in-a-cobject-collection.md) описывает функцию удаления всех объектов, содержащихся в списке. Эту функцию можно добавить в производный класс как функцию-член.

## <a name="see-also"></a>См. также раздел

[Коллекции](collections.md)
