---
title: Практическое руководство. Создание типобезопасных коллекций
ms.date: 11/04/2016
helpviewer_keywords:
- type-safe collections [MFC]
- serializing collection-class elements [MFC]
- collection classes [MFC], type safety
- SerializeElements function [MFC]
- collection classes [MFC], template-based
- serialization [MFC], collection classes
- collection classes [MFC], deriving from nontemplate
ms.assetid: 7230b2db-4283-4083-b098-eb231bf5b89e
ms.openlocfilehash: 1901100996a776244b57efe0951795ceec3c630a
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81377260"
---
# <a name="how-to-make-a-type-safe-collection"></a>Практическое руководство. Создание типобезопасных коллекций

В этой статье объясняется, как сделать коллекции, безопасные для типов данных. Будут рассмотрены следующие задачи:

- [Использование классов на основе шаблонов для обеспечения безопасности типов](#_core_using_template.2d.based_classes_for_type_safety)

- [Реализация функций помощника](#_core_implementing_helper_functions)

- [Использование классов нешаблонного сбора](#_core_using_nontemplate_collection_classes)

Библиотека класса Фонда Майкрософт предоставляет предопределенные коллекции, безопасные для типов, основанные на шаблонах СЗ. Поскольку они являются шаблонами, эти классы помогают обеспечить безопасность типа и простоту использования без литья типов и другой дополнительной работы, связанной с использованием класса nontemplate для этой цели. Образец MFC [COLLECT](../overview/visual-cpp-samples.md) демонстрирует использование классов сбора на основе шаблонов в приложении MFC. Как правило, используйте эти классы каждый раз, когда вы пишете новый код коллекций.

## <a name="using-template-based-classes-for-type-safety"></a><a name="_core_using_template.2d.based_classes_for_type_safety"></a>Использование классов на основе шаблонов для безопасности типов

#### <a name="to-use-template-based-classes"></a>Использовать классы, основанные на шаблонах

1. Объявить переменную типа класса коллекции. Пример:

   [!code-cpp[NVC_MFCCollections#7](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_1.cpp)]

1. Вызовите функции участника объекта сбора. Пример:

   [!code-cpp[NVC_MFCCollections#8](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_2.cpp)]

1. При необходимости реализуем [функции помощника](../mfc/reference/collection-class-helpers.md) и [SerializeElements.](../mfc/reference/collection-class-helpers.md#serializeelements) Для получения информации о реализации этих функций [см.](#_core_implementing_helper_functions)

Этот пример показывает объявление списка рядов. Первым параметром в шаге 1 является тип данных, хранящихся в качестве элементов списка. Второй параметр определяет, как данные должны передаваться и возвращаться из функций `Add` `GetAt`членов класса коллекции, таких как и .

## <a name="implementing-helper-functions"></a><a name="_core_implementing_helper_functions"></a>Реализация функций помощника

Классы `CArray` `CList`сбора на основе `CMap` шаблонов и используйте пять глобальных функций помощника, которые можно настроить по мере необходимости для вашего класса производных коллекций. Для получения информации об этих функциях помощника, *MFC Reference*см. [Collection Class Helpers](../mfc/reference/collection-class-helpers.md) Реализация функции сериализации необходима для большинства видов использования классов коллекции на основе шаблонов.

### <a name="serializing-elements"></a><a name="_core_serializing_elements"></a>Сериализация элементов

`CArray`Элементы `CList`сбора `CMap` или `SerializeElements` чтения из архива требуют сохранить элементы коллекции или прочитать их.

Выполнение функции `SerializeElements` помощника по умолчанию делает битное запись с объектов в архив или битное чтение из архива в объекты, в зависимости от того, хранятся объекты или извлекаются из архива. Переопределение, `SerializeElements` если это действие не подходит.

Если коллекция хранит объекты, `CObject` полученные `IMPLEMENT_SERIAL` из и вы используете макрос в реализации класса элементов `CArchive` `CObject`коллекции, вы можете воспользоваться функциональностью сериализации, встроенной в и:

[!code-cpp[NVC_MFCCollections#9](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_3.cpp)]

Перезагруженные операторы вставки для `CArchive` вызова `CObject::Serialize` (или переопределения `CPerson` этой функции) для каждого объекта.

## <a name="using-nontemplate-collection-classes"></a><a name="_core_using_nontemplate_collection_classes"></a>Использование классов коллекций Nontemplate

MFC также поддерживает классы коллекции, введенные с версией MFC 1.0. Эти классы не основаны на шаблонах. Они могут быть использованы для `CObject*`хранения `UINT` `DWORD`данных `CString`поддерживаемых типов, и . Вы можете использовать эти предопределенные коллекции `CObList`(например), `CObject`чтобы держать коллекции любых объектов, полученных из. MFC также предоставляет другие предопределенные `UINT` коллекции для`void`хранения примитивных типов, таких как и пустые указатели ( q). Однако в целом часто полезно определить собственные коллекции, безопасные для типов, для хранения объектов более конкретного класса и его производных. Обратите внимание, что делать это с классами коллекций, не основанными на шаблонах, это больше работы, чем использование классов, основанных на шаблонах.

Существует два способа создания коллекций, безопасных для типов, с нешаблонными коллекциями:

1. При необходимости используйте нешаблонные коллекции с литьем типов. Это более простой подход.

1. Извлекайте из и расширяйте нешаблонную коллекцию, безопасную для типов.

#### <a name="to-use-the-nontemplate-collections-with-type-casting"></a>Использовать нешаблонные коллекции с типовым литьем

1. Используйте один из нешаблонных `CWordArray`классов, таких как, непосредственно.

   Например, можно создать `CWordArray` и добавить к нему любые 32-битные значения, а затем получить их. Больше нечего делать. Вы просто используете предопределенную функциональность.

   Вы также можете использовать предопределенную `CObList`коллекцию, например, `CObject`для хранения любых объектов, полученных из. Коллекция `CObList` определяется для удержания `CObject`указателей на . При извлечении объекта из списка, возможно, придется отбросить результат `CObList` в правильный `CObject`тип, так как указатели возврата функций должны быть. Например, если `CPerson` вы храните объекты в `CObList` коллекции, необходимо отбросить извлеченный элемент, чтобы быть указателем `CPerson` на объект. В следующем примере `CObList` используется `CPerson` коллекция для хранения объектов:

   [!code-cpp[NVC_MFCCollections#10](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_4.cpp)]

   Этот метод использования предопределенного типа сбора и литья по мере необходимости может быть достаточным для многих ваших потребностей коллекции. Если вам нужна дополнительная функциональность или более безопасность типа, используйте класс на основе шаблонов или следуйте следующей процедуре.

#### <a name="to-derive-and-extend-a-nontemplate-type-safe-collection"></a>Получение и расширение нешаблонной коллекции для безопасного типа

1. Вывежьте свой собственный класс коллекции из одного из предопределенных нешаблонных классов.

   Когда вы получаете свой класс, можно добавить функции обертки для обеспечения безопасного для типа интерфейса существующих функций.

   Например, если вы вывели `CObList` список из для удержания `CPerson` `AddHeadPerson` объектов, можно добавить функции обертки и, `GetHeadPerson`как показано ниже.

   [!code-cpp[NVC_MFCCollections#11](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_5.h)]

   Эти функции обертки обеспечивают безопасный `CPerson` для типа способ добавления и извлечения объектов из производного списка. Вы можете видеть, `GetHeadPerson` что для функции, вы просто инкапсулировать тип литья.

   Вы также можете добавить новую функциональность, определив новые функции, которые расширяют возможности коллекции, а не просто обертывания существующих функций в обертки для типов. Например, статья [«Удаление всех объектов в коллекции CObject»](../mfc/deleting-all-objects-in-a-cobject-collection.md) описывает функцию удаления всех объектов, содержащихся в списке. Эта функция может быть добавлена к производному классу в качестве функции члена.

## <a name="see-also"></a>См. также раздел

[Коллекции](../mfc/collections.md)
