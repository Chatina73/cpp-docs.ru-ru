---
title: Практическое руководство. Создание типобезопасных коллекций
ms.date: 11/04/2016
helpviewer_keywords:
- type-safe collections [MFC]
- serializing collection-class elements [MFC]
- collection classes [MFC], type safety
- SerializeElements function [MFC]
- collection classes [MFC], template-based
- serialization [MFC], collection classes
- collection classes [MFC], deriving from nontemplate
ms.assetid: 7230b2db-4283-4083-b098-eb231bf5b89e
ms.openlocfilehash: 12ecec7562a9241fab30b859727a22e467e6eeb0
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50581796"
---
# <a name="how-to-make-a-type-safe-collection"></a>Практическое руководство. Создание типобезопасных коллекций

В этой статье объясняется, как осуществлять типобезопасные коллекции для собственных типов данных. Ниже приведен список разделов.

- [С помощью классов на основе шаблона для безопасности типов](#_core_using_template.2d.based_classes_for_type_safety)

- [Реализация вспомогательных функций](#_core_implementing_helper_functions)

- [С помощью классов коллекций нешаблонных](#_core_using_nontemplate_collection_classes)

Библиотеки Microsoft Foundation Class предоставляет предопределенные типобезопасный коллекциях, основанных на шаблонах C++. Так как они являются шаблонами, эти классы помогают обеспечить безопасность типов и простоту использования без приведение типов и других дополнительной работы, связанные с использованием класса нешаблонных для этой цели. Пример MFC [СОБИРАТЬ](../visual-cpp-samples.md) демонстрирует использование классов коллекции на основе шаблона в приложении MFC. Как правило, эти классы используйте каждый раз при написании нового кода коллекции.

##  <a name="_core_using_template.2d.based_classes_for_type_safety"></a> С помощью классов на основе шаблона для безопасности типов

#### <a name="to-use-template-based-classes"></a>Чтобы использовать классы на основе шаблона

1. Объявите переменную типа класса коллекции. Пример:

   [!code-cpp[NVC_MFCCollections#7](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_1.cpp)]

1. Вызовите член функции объекта коллекции. Пример:

   [!code-cpp[NVC_MFCCollections#8](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_2.cpp)]

1. При необходимости реализовать [вспомогательные функции](../mfc/reference/collection-class-helpers.md) и [SerializeElements](../mfc/reference/collection-class-helpers.md#serializeelements). Сведения о реализации этих функций см. в разделе [реализации вспомогательные функции](#_core_implementing_helper_functions).

В этом примере показано объявление списка целых чисел. Первый параметр в шаге 1 — это тип данных, сохраняются в виде элементов списка. Второй параметр определяет, как данные передаваемые и возвращаемые из функций-членов класса коллекции, такие как `Add` и `GetAt`.

##  <a name="_core_implementing_helper_functions"></a> Реализация вспомогательных функций

Классы коллекций, основанных на шаблонах `CArray`, `CList`, и `CMap` использовать пять глобального вспомогательные функции, которые можно настраивать при необходимости для класса производной коллекции. Сведения об этих вспомогательных функций, см. в разделе [вспомогательные функции классов коллекции](../mfc/reference/collection-class-helpers.md) в *Справочник по библиотеке MFC*. Реализация функции сериализации необходима для большинства случаев классов коллекции на основе шаблона.

###  <a name="_core_serializing_elements"></a> Сериализация элементов

`CArray`, `CList`, И `CMap` классы вызов `SerializeElements` для хранения элементов коллекции или для их чтения из архива.

Реализация по умолчанию `SerializeElements` вспомогательная функция не побитовое записи из объектов в архив или побитовую операцию чтения из архива к объектам, в зависимости от того, является ли объекты, хранящиеся в или извлекаемое из архива. Переопределить `SerializeElements` Если это действие не подходит.

Если ваша коллекция хранит объекты, производные от `CObject` и использовании `IMPLEMENT_SERIAL` макрос в реализации классом элемента коллекции, можно воспользоваться преимуществами функций сериализации, встроенных в `CArchive` и `CObject`:

[!code-cpp[NVC_MFCCollections#9](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_3.cpp)]

Операторы перегруженных вставки для `CArchive` вызвать `CObject::Serialize` (или переопределение этой функции) для каждого `CPerson` объекта.

##  <a name="_core_using_nontemplate_collection_classes"></a> С помощью классов коллекций нешаблонных

MFC также поддерживает классы коллекций, представленные с MFC версии 1.0. Эти классы не на основе шаблонов. Они могут использоваться для размещения данных из поддерживаемых типов `CObject*`, `UINT`, `DWORD`, и `CString`. Можно использовать этих коллекций (такие как `CObList`) для хранения коллекций объектов, производных от `CObject`. MFC также предоставляет другие стандартные коллекции для хранения типов-примитивов, таких как `UINT` и указателей void (`void`*). Как правило тем не менее, часто полезно для определения собственных типобезопасные коллекции для хранения объектов более специфичного класса и его производными. Обратите внимание, что это с классами коллекций не на основе шаблонов больше работы, чем при использовании классов на основе шаблона.

Создание безопасных типов коллекций с коллекциями нешаблонных двумя способами:

1. Использование коллекций нешаблонных, приведение типа, при необходимости. Этот подход проще.

1. Наследование от и расширить типобезопасных коллекций нешаблонных.

#### <a name="to-use-the-nontemplate-collections-with-type-casting"></a>Для использования коллекций нешаблонных приведения типа

1. Использование одного из нешаблонных классов, таких как `CWordArray`, напрямую.

   Например, можно создать `CWordArray` и добавить в него любой 32-разрядных значений, а затем извлекать их. Больше нечего делать. Просто используйте стандартные функциональные возможности.

   Также можно использовать предопределенные коллекции, такие как `CObList`, для хранения любого объектов, производных от `CObject`. Объект `CObList` определена коллекция для хранения указателей на `CObject`. При извлечении объекта из списка, может потребоваться привести результат к соответствующему типу с момента `CObList` функции возвращают указатели на `CObject`. Например, если вы храните `CPerson` объекты в `CObList` коллекции необходимо приведение полученного элемента указатель на `CPerson` объект. В следующем примере используется `CObList` коллекция, содержащая `CPerson` объектов:

   [!code-cpp[NVC_MFCCollections#10](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_4.cpp)]

   Этот способ, с помощью типа предопределенные коллекции и приведение при необходимости может быть достаточно для большинства из ваших потребностей в коллекциях. Если требуется дополнительные функциональные возможности или дополнительные безопасность типов, использование классов на основе шаблона или выполните следующую процедуру.

#### <a name="to-derive-and-extend-a-nontemplate-type-safe-collection"></a>Наследовать и расширять нешаблонных типобезопасных коллекций

1. Создать собственный класс коллекции из одного из нешаблонных предопределенных классов.

   При наследовании класса, можно добавить функции-оболочки строго типизированным и предоставляет строго типизированный интерфейс к существующим функциям.

   Например, если производные список из `CObList` для хранения `CPerson` объектов, можно добавить функции-оболочки `AddHeadPerson` и `GetHeadPerson`, как показано ниже.

   [!code-cpp[NVC_MFCCollections#11](../mfc/codesnippet/cpp/how-to-make-a-type-safe-collection_5.h)]

   Эти функции-оболочки предоставляют типобезопасный способ добавления и получения `CPerson` объектов из списка производный. Можно заметить, что для `GetHeadPerson` функцию, просто инкапсуляции приведение типов.

   Можно также добавить новые функциональные возможности определения новых функций, которые расширяют возможности коллекции, а не простое создание оболочки для существующих функций в строго типизированные оболочки. Например, статьи [удаление всех объектов из коллекции CObject](../mfc/deleting-all-objects-in-a-cobject-collection.md) описывает функцию, для удаления всех объектов, содержащихся в списке. Эта функция может добавляться производного класса как функция-член.

## <a name="see-also"></a>См. также

[Коллекции](../mfc/collections.md)

