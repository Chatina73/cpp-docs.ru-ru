---
title: 'TN064: Модели в элементах управления ActiveX'
ms.date: 11/04/2016
f1_keywords:
- vc.controls.activex
helpviewer_keywords:
- OLE controls [MFC], container support
- containers [MFC], multithreaded
- TN064 [MFC]
- multithread container [MFC]
- apartment model threading [MFC]
ms.assetid: b2ab4c88-6954-48e2-9a74-01d4a60df073
ms.openlocfilehash: d6f02b2106693226f6380e935a54e04e10d5b4f8
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57261171"
---
# <a name="tn064-apartment-model-threading-in-activex-controls"></a>TN064: Модели в элементах управления ActiveX

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Это техническое Примечание объясняется как включить потоковая модель с подразделением в элементе управления ActiveX. Обратите внимание на то, что потоковая модель с подразделением поддерживается только в версиях Visual C++ 4.2 или более поздней версии.

## <a name="what-is-apartment-model-threading"></a>Что такое потоковая модель с подразделением

Потоковая модель является подходом к поддержки встроенных объектов, таких как элементы управления ActiveX, в приложении многопоточных контейнера. Несмотря на то, что приложение может иметь несколько потоков, каждый экземпляр внедренного объекта будет назначен один «подразделения,» которой будет выполняться только в одном потоке. Другими словами все вызовы в экземпляр элемента управления будет происходить в одном потоке.

Тем не менее разные экземпляры одного типа элемента управления может быть назначен разных подразделениях. Таким образом Если несколько экземпляров элемента управления совместно используют все данные в общее (например, статическая или глобальная данных), доступ к этим данным общего потребуется Защищаемая объект синхронизации, например критической секции.

Полные подробные сведения о потоковых модель подразделений, см. в разделе [процессы и потоки](/windows/desktop/ProcThread/processes-and-threads) в *справочнике программиста OLE*.

## <a name="why-support-apartment-model-threading"></a>Почему поддерживает замкнутой модели потоков

Элементы управления, поддерживающие потоковая модель с подразделением можно использовать в многопоточных контейнеров приложений, поддерживающих модель с подразделением. Если не включить потоковая модель с подразделением, будет ограничена потенциальный набор контейнеров, в которых может использоваться элемент управления.

Включение потоковая модель с подразделением прост для большинства элементов управления, особенно в том случае, если они имеют почти или совсем нет общих данных.

## <a name="protecting-shared-data"></a>Защита общих данных

Если элемент управления использует общие данные, такие как статическая переменная-член, доступ к данные должны быть защищены с критической секции для предотвращения изменения данных в то же время более одного потока. Чтобы настроить критическую секцию для этой цели, объявите статическую переменную-член класса `CCriticalSection` в классе элемента управления. Используйте `Lock` и `Unlock` функций-членов это критический раздел объекта везде, где код обращается к общим данным.

Рассмотрим, например, класс элемента управления, который должен поддерживать строку, которая совместно используется всеми экземплярами. Эта строка может в статическую переменную-член и защищены критической секции. Объявление класса элемента управления будет содержать следующие элементы:

```
class CSampleCtrl : public COleControl
{
...
    static CString _strShared;
    static CCriticalSection _critSect;
};
```

Реализация класса включить определения для этих переменных:

```
int CString CSampleCtrl::_strShared;
CCriticalSection CSampleCtrl::_critSect;
```

Доступ к `_strShared` статический член затем могут быть защищены критического раздела:

```
void CSampleCtrl::SomeMethod()
{
    _critSect.Lock();
if (_strShared.Empty())
    _strShared = "<text>";
    _critSect.Unlock();

...
}
```

## <a name="registering-an-apartment-model-aware-control"></a>Регистрации элемента подразделения-с поддержкой модели

Элементы управления, поддерживающие модель с подразделением потоков должно быть указано, эта возможность в реестре, путем добавления именованное значение «ThreadingModel» со значением «Apartment» в их класс идентификатор запись реестра *идентификатор класса* \\ **InprocServer32** ключ. Чтобы вызвать этот ключ должен быть автоматически регистрируется для элемента управления, передайте *afxRegApartmentThreading* флага в параметре шестой `AfxOleRegisterControlClass`:

```
BOOL CSampleCtrl::CSampleCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    if (bRegister)
    return AfxOleRegisterControlClass(
    AfxGetInstanceHandle(),
    m_clsid,
    m_lpszProgID,
    IDS_SAMPLE,
    IDB_SAMPLE,
    afxRegApartmentThreading,
    _dwSampleOleMisc,
    _tlid,
    _wVerMajor,
    _wVerMinor);

else
    return AfxOleUnregisterClass(m_clsid,
    m_lpszProgID);

}
```

Если проект элемента управления был создан автоматически в Visual C++ 4.1 или более поздней версии, этот флаг, уже будут присутствовать в коде. Изменения не требуются для регистрации модели потоков.

Если проект был создан с помощью более ранней версии, существующий код будет иметь логическое значение как шестой параметр. Если необходимый параметр имеет значение TRUE, измените его на *afxRegInsertable | afxRegApartmentThreading*. Если необходимый параметр имеет значение FALSE, измените его на *afxRegApartmentThreading*.

Если элемент управления не соответствует правилам для управления потоками модель с подразделением, нельзя передавать *afxRegApartmentThreading* в этом параметре.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
