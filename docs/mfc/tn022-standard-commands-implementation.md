---
title: TN022. Реализация стандартных команд
ms.date: 11/04/2016
f1_keywords:
- vc.commands
helpviewer_keywords:
- ID_PREV_PANE command [MFC]
- ID_APP_EXIT command [MFC]
- ID_NEXT_PANE command [MFC]
- ID_INDICATOR_REC command [MFC]
- ID_WINDOW_SPLIT command [MFC]
- ID_FILE_PRINT_PREVIEW command [MFC]
- ID_WINDOW_CASCADE command [MFC]
- ID_FILE_CLOSE command [MFC]
- ID_FILE_SAVE_COPY_AS command [MFC]
- ID_WINDOW_ARRANGE command [MFC]
- ID_EDIT_FIND command [MFC]
- ID_FILE_OPEN command [MFC]
- ID_FILE_PAGE_SETUP command [MFC]
- ID_OLE_VERB_FIRST command [MFC]
- ID_EDIT_UNDO command [MFC]
- ID_EDIT_CLEAR command [MFC]
- ID_INDICATOR_CAPS command [MFC]
- ID_HELP_INDEX command [MFC]
- commands [MFC], standard
- ID_FILE_PRINT_SETUP command [MFC]
- ID_DEFAULT_HELP command [MFC]
- ID_INDICATOR_SCRL command [MFC]
- ID_FILE_PRINT command [MFC]
- ID_INDICATOR_OVR command [MFC]
- ID_INDICATOR_KANA command [MFC]
- ID_EDIT_COPY command [MFC]
- ID_EDIT_REDO command [MFC]
- ID_EDIT_PASTE command [MFC]
- ID_OLE_INSERT_NEW command [MFC]
- ID_OLE_EDIT_LINKS command [MFC]
- ID_EDIT_PASTE_SPECIAL command [MFC]
- ID_INDICATOR_EXT command [MFC]
- ID_HELP_USING command [MFC]
- standard commands
- ID_VIEW_STATUS_BAR command [MFC]
- ID_FILE_SAVE_AS command [MFC]
- ID_EDIT_CLEAR_ALL command [MFC]
- ID_WINDOW_NEW command [MFC]
- ID_CONTEXT_HELP command [MFC]
- ID_EDIT_REPLACE command [MFC]
- ID_WINDOW_TILE_HORZ command [MFC]
- ID_APP_ABOUT command [MFC]
- TN022
- ID_VIEW_TOOLBAR command [MFC]
- ID_HELP command [MFC]
- ID_WINDOW_TILE_VERT command [MFC]
- ID_EDIT_CUT command [MFC]
- ID_FILE_UPDATE command [MFC]
- ID_EDIT_REPEAT command [MFC]
- ID_FILE_SAVE command [MFC]
- ID_EDIT_PASTE_LINK command [MFC]
- ID_EDIT_SELECT_ALL command [MFC]
- ID_FILE_NEW command [MFC]
- ID_INDICATOR_NUM command
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
ms.openlocfilehash: 5c7041f40c7e30592f642d29d9d02812a9596864
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370395"
---
# <a name="tn022-standard-commands-implementation"></a>TN022. Реализация стандартных команд

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой заметке описаны стандартные командные реализации, предоставляемые MFC 2.0. Сначала прочитайте [Техническое Примечание 21,](../mfc/tn021-command-and-message-routing.md) поскольку в нем описаны механизмы, используемые для реализации многих стандартных команд.

Это описание предполагает знание архитектур MFC, AA и общей практики программирования. Описаны документированные, а также незарегистрированные AAP "только для реализации". Это не место, чтобы начать узнавать об особенностях или как программировать в МФЦ. Для получения более подробной информации и подробной информации о задокументированных AIS обратитесь к Visual C е.

## <a name="the-problem"></a>Проблема

MFC определяет множество стандартных идовини команд в файле заголовка AFXRES. H. Рамочная поддержка этих команд различна. Понимание того, где и как классы фреймворков обрабатывают эти команды, не только покажет вам, как фреймворк работает внутри них, но и предоставит полезную информацию о том, как настроить стандартные реализации, и научит вас нескольким методам реализации собственных обработчиков команд.

## <a name="contents-of-this-technical-note"></a>Содержание этой технической записки

Каждый идентификатор команды описан в двух разделах:

- Название: символическое название идентификатора команды (например, ID_FILE_SAVE), за которым следует назначение команды (например, "сохраняет текущий документ"), разделенной толстой кишка.

- Один или несколько абзацев, описывающих, какие классы реализуют команду, и что делает реализация по умолчанию

Большинство реализаций команд по умолчанию предварительно замыкаются на карте сообщений базового класса. Есть некоторые командные реализации, которые требуют явной проводки в вашем производном классе. Они описаны в "Примечание". Если вы выбрали правильные варианты в AppWizard, эти обработчики по умолчанию будут подключены для вас в сгенерированном приложении скелета.

## <a name="naming-convention"></a>Соглашение об именовании

Стандартные команды следуют простой конвенции именования, которую мы рекомендуем вам использовать, если это возможно. Большинство стандартных команд расположены в стандартных местах в меню приложения. Символическое название команды начинается с "ID_", за которым следует стандартное название всплывающее меню, а затем имя элемента меню. Символическое название в верхнем случае с подчеркивать слово-брейки. Для команд, не имеющих стандартных названий элементов меню, определяется логическое имя команды, начиная с "ID_" (например, ID_NEXT_PANE).

Мы используем префикс "ID_" для обозначения команд, которые предназначены для привязки к элементам меню, кнопкам панели инструментов или другим объектам пользовательского интерфейса команды. Обработчики команд, обрабатываемые командами "ID_", должны использовать ON_COMMAND и ON_UPDATE_COMMAND_UI механизмы архитектуры команд MFC.

Мы рекомендуем использовать стандартную префикс "IDM_" для элементов меню, которые не соответствуют архитектуре команды и нуждаются в коде, предназначенном для включения и отключаемого. Конечно, количество команд меню должно быть небольшим, так как следования за архитектурой команд MFC не только делает обработчики команд более мощными (поскольку они будут работать с инструментами), но и делает код обработчика команд многоразовым.

## <a name="id-ranges"></a>Диапазоны идентификаторов

Для получения более подробной информации об использовании id-диапазонов в MFC обратитесь к [Technical Note 20.](../mfc/tn020-id-naming-and-numbering-conventions.md)

Стандартные команды MFC относятся в диапазоне от 0xE000 до 0xEFFF. Пожалуйста, не полагайтесь на конкретные значения этих идовинов, поскольку они могут быть изменены в будущих версиях библиотеки.

Приложение должно определить свои команды в диапазоне от 0x8000 до 0xDFFF.

## <a name="standard-command-ids"></a>Стандартные иди командования

Для каждого идентификатора команды имеется стандартная строка запроса строки сообщения, которую можно найти в файле PROMPTS. Rc. Идентификатор строки для этого запроса меню должен быть таким же, как и для идентификатора команды.

- ID_FILE_NEW создает новый/пустой документ.

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   `CWinApp::OnFileNew`реализует эту команду по-разному в зависимости от количества шаблонов документов в приложении. Если есть только `CDocTemplate` `CWinApp::OnFileNew` один, создаст новый документ такого типа, а также правильный кадр и класс представления.

   Если существует `CDocTemplate`несколько, `CWinApp::OnFileNew` он подскажет пользователю диалог (AFX_IDD_NEWTYPEDLG), позволяя ему выбрать тип документа для использования. Выбранный `CDocTemplate` используется для создания документа.

   Одной из распространенных ID_FILE_NEW является предоставление другого и более графического выбора типов документов. В этом случае вы `CMyApp::OnFileNew` можете реализовать свой собственный `CWinApp::OnFileNew`и поместить его в вашей карте сообщений, а не . Нет необходимости вызывать реализацию базового класса.

   Другой распространенной настройкой ID_FILE_NEW является предоставление отдельной команды для создания документа каждого типа. В этом случае следует определить новые идентифицированные данные команд, например, ID_FILE_NEW_CHART и ID_FILE_NEW_SHEET.

- ID_FILE_OPEN открывает существующий документ.

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   `CWinApp::OnFileOpen`имеет очень простую `CWinApp::DoPromptFileName` реализацию `CWinApp::OpenDocumentFile` вызова, за которым следует файл или имя пути файла, чтобы открыть. Режим `CWinApp` `DoPromptFileName` реализации поднимает стандартный диалог FileOpen и заполняет его расширениями файлов, полученными из текущих шаблонов документов.

   Одной из распространенных ID_FILE_OPEN является настройка диалога FileOpen или добавление дополнительных фильтров файлов. Рекомендуемый способ настройки — заменить реализацию по умолчанию собственным диалогом FileOpen и вызов `CWinApp::OpenDocumentFile` с файлом или именем пути документа. Нет необходимости вызывать базовый класс.

- ID_FILE_CLOSE закрывает открытый документ.

   `CDocument::OnFileClose`требует `CDocument::SaveModified` вызвать пользователя, чтобы сохранить документ, если он `OnCloseDocument`был изменен, а затем звонки. Вся заключительная логика, включая `OnCloseDocument` уничтожение документа, выполняется в обычном режиме.

    > [!NOTE]
    >  ID_FILE_CLOSE действует иначе, чем WM_CLOSE сообщение или команда SC_CLOSE системы, отправленная в окно кадра документов. Закрытие окна закроет документ только в том случае, если это последнее окно кадра, отображающее документ. Закрытие документа с ID_FILE_CLOSE не только закроет документ, но и закроет все окна кадра с указанием документа.

- ID_FILE_SAVE сохраняет текущий документ.

   Реализация использует процедуру `CDocument::DoSave` помощника, которая `OnFileSave` используется `OnFileSaveAs`как для. Если вы сохраните документ, который не был сохранен ранее (т.е. у него нет имени пути, как в случае `OnFileSave` СfileNew) или прочитанном из документа, прочитанном только для чтения, логика будет действовать как ID_FILE_SAVE_AS команду и попросит пользователя предоставить новое имя файла. Фактический процесс открытия файла и выполнения экономии `OnSaveDocument`осуществляется через виртуальную функцию.

   Есть две общие причины для настройки ID_FILE_SAVE. Для документов, которые не сохраняют, просто удалите ID_FILE_SAVE пунктов меню и кнопки панели инструментов из пользовательского интерфейса. Также убедитесь, что вы никогда не `CDocument::SetModifiedFlag`пачкаете документ (т.е. никогда не звоните) и что фреймворк никогда не приведет к сохранению документа. Для документов, которые сохраняют в другом месте, кроме дискового файла, определите новую команду для этой операции.

   В случае `COleServerDoc`ID_FILE_SAVE используется как для сохранения файла (для обычных документов), так и для обновления файлов (для встроенных документов).

   Если данные документа хранятся в отдельных файлах диска, `CDocument` но вы не хотите `CDocument::OnSaveDocument` использовать `OnFileSave`реализацию сериализации по умолчанию, следует переопределить вместо :

- ID_FILE_SAVE_AS сохраняет текущий документ под другим именем файла.

   Реализация `CDocument::OnFileSaveAs` использует ту `CDocument::DoSave` же процедуру помощника, что `OnFileSave`и . Команда `OnFileSaveAs` обрабатывается так же, как ID_FILE_SAVE если документы не имели имя файла до сохранения. `COleServerDoc::OnFileSaveAs`реализует логику для сохранения обычного файла данных документа или для сохранения серверного документа, представляющего объект OLE, встроенный в какое-либо другое приложение в качестве отдельного файла.

   Если настроить логику ID_FILE_SAVE, вероятно, вы хотите настроить ID_FILE_SAVE_AS аналогичным образом или операция "Сохранить As" не может применяться к документу. Вы можете удалить пункт меню из панели меню, если он не нужен.

- ID_FILE_SAVE_COPY_AS сохраняет копию текущего документа под новым именем.

   Реализация `COleServerDoc::OnFileSaveCopyAs` очень похожа `CDocument::OnFileSaveAs`на, за исключением того, что объект документа не "присоединен" к базовому файлу после сохранения. То есть, если документ в памяти был "изменен" до сохранения, он все равно "модифицирован". Кроме того, эта команда не влияет на имя или название пути, хранящееся в документе.

- ID_FILE_UPDATE уведомляет контейнер для сохранения встроенного документа.

   Реализация `COleServerDoc::OnUpdateDocument` просто уведомляет контейнер о том, что встраивание должно быть сохранено. Контейнер затем вызывает соответствующие AIS OLE для того, чтобы сохранить встроенный объект.

- ID_FILE_PAGE_SETUP вызывает диалог о настройке/макете конкретной страницы приложения.

   В настоящее время нет стандарта для этого диалога, и в фреймворке нет выполнения этой команды по умолчанию.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_FILE_PRINT_SETUP вызвать стандартный диалог print Setup.

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   Эта команда ссылается на стандартный диалог настройки печати, который позволяет пользователю настроить настройки принтера и печати, по крайней мере, для этого документа или, по крайней мере, всех документов в этом приложении. Необходимо использовать панель управления для изменения настроек принтера по умолчанию для всей системы.

   `CWinApp::OnFilePrintSetup`имеет очень простую `CPrintDialog` реализацию, создавая объект и вызывая функцию реализации. `CWinApp::DoPrintDialog` Это устанавливает настройки принтера по умолчанию приложения.

   Общей потребностью в настройке этой команды является создание параметров принтера для одного документа, которые должны храниться вместе с документом при сохранении. Для этого следует добавить обработчик `CDocument` карты сообщений `CPrintDialog` в своем классе, который создает объект, инициализирует его с `CPrintDialog::DoModal`соответствующими атрибутами принтера (обычно *hDevMode* и *hDevNames),* вызовите и сохраните измененные настройки принтера. Для надежной реализации следует посмотреть `CWinApp::DoPrintDialog` на реализацию `CWinApp::UpdatePrinterSelection` для обнаружения ошибок и для решения разумных по умолчанию и отслеживания общесистемных изменений принтера.

- ID_FILE_PRINT стандартная печать текущего документа

    > [!NOTE]
    >  Чтобы включить эту `CView`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   Эта команда печатает текущий документ, или, вернее, запускает процесс печати, который включает в себя ссылаясь на стандартный диалог печати и запуск печатного движка.

   `CView::OnFilePrint`реализует эту команду и основной цикл печати. Он вызывает `CView::OnPreparePrinting` виртуальный, чтобы подсказать пользователю с диалогом печати. Затем он готовит выходный dc, чтобы перейти к принтеру, поднимает диалог `StartDoc` о прогрессе печати (AFX_IDD_PRINTDLG) и отправляет побег на принтер. `CView::OnFilePrint`также содержит основной цикл печати, ориентированный на страницу. Для каждой страницы, `CView::OnPrepareDC` он `StartPage` называет виртуальные `CView::OnPrint` следуют побега и вызова виртуальных для этой страницы. При завершении `CView::OnEndPrinting` называется виртуальный, а диалог о прогрессе печати закрывается.

   Архитектура печати MFC предназначена для подключения различными способами для печати и предварительного просмотра печати. Обычно вы найдете `CView` различные переизлики функции, адекватные для любых задач печати, ориентированных на страницы. Только в случае приложения, использующемпринтер для вывода, не ориентированного на страницу, вы найдете необходимость заменить ID_FILE_PRINT реализации.

- ID_FILE_PRINT_PREVIEW Введите режим предварительного просмотра печати для текущего документа.

    > [!NOTE]
    >  Чтобы включить эту `CView`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   `CView::OnFilePrintPreview`запускает режим предварительного просмотра печати, `CView::DoPrintPreview`позвонив в задокументированную функцию помощника. `CView::DoPrintPreview`является основным движком для цикла предварительного просмотра печати, так же, как `OnFilePrint` это основной движок для печатной петли.

   Операция предварительного просмотра печати может быть настроена различными `DoPrintPreview`способами, передавая различные параметры. Пожалуйста, обратитесь к [Техническому примечанию 30](../mfc/tn030-customizing-printing-and-print-preview.md), в котором обсуждаются некоторые детали предварительного просмотра печати и как настроить его.

- ID_FILE_MRU_FILE1... FILE16 Диапазон идовини команд для **списка**файлов MRU .

   `CWinApp::OnUpdateRecentFileMenu`— это обработчик управления утилитой обновления, который является одним из наиболее продвинутых видов использования механизма ON_UPDATE_COMMAND_UI. В ресурсе меню вам нужно определить только один пункт меню с id ID_FILE_MRU_FILE1. Этот элемент меню остается первоначально отключенным.

   По мере роста списка MRU в список добавляются дополнительные элементы меню. Стандартная `CWinApp` реализация по умолчанию не связана со стандартным пределом четырех последних используемых файлов. Вы можете изменить значение `CWinApp::LoadStdProfileSettings` по умолчанию, вызывая большее или меньшее значение. Список MRU хранится в приложении. Файл INI. Список загружается в `InitInstance` функцию приложения, если вы звоните, `LoadStdProfileSettings`и сохраняется при выходе приложения. Обработчик управления uI обновления MRU также преобразует абсолютные пути в относительные пути для отображения в меню файлов.

   `CWinApp::OnOpenRecentFile`— это обработчик ON_COMMAND, выполняющий фактическую команду. Он просто получает имя файла из `CWinApp::OpenDocumentFile`списка MRU и звонки , который делает всю работу по открытию файла и обновлению списка MRU.

   Настройка этого обработчика команд не рекомендуется.

- ID_EDIT_CLEAR очищает текущий выбор

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды `CEdit::Clear`с помощью . Команда отключена, если нет текущего выбора.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_CLEAR_ALL очищает весь документ.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды. Пример учебника MFC [SCRIBBLE](../overview/visual-cpp-samples.md) можно овести.

- ID_EDIT_COPY Копирует текущий выбор в Clipboard.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды, которая копирует выбранный в настоящее `CEdit::Copy`время текст на Clipboard в качестве CF_TEXT с помощью . Команда отключена, если нет текущего выбора.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_CUT сокращает текущий выбор в Clipboard.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды, которая сокращает выбранный в настоящее `CEdit::Cut`время текст для Clipboard как CF_TEXT использованием . Команда отключена, если нет текущего выбора.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_FIND начинает работу находки, воспитывает бесрежимный диалог поиска.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды, которая вызывает функцию `OnEditFindReplace` помощника реализации для использования и хранения предыдущих параметров поиска/замены в частных переменных реализации. Класс `CFindReplaceDialog` используется для управления безрежимным диалогом для побуждения пользователя.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_PASTE вставляет текущее содержимое Clipboard.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды, которая копирует текущие данные Clipboard, заменяющие выбранный текст с помощью `CEdit::Paste`. Команда отключена, если в Clipboard нет **CF_TEXT.**

   `COleClientDoc`просто предоставляет обработчик управления утилитой обновления для этой команды. Если Clipboard не содержит встраиваемого элемента/объекта OLE, команда будет отключена. Вы несете ответственность за написание обработчика для фактической команды, чтобы сделать фактическую вставку. Если ваше приложение OLE также может вставить другие форматы, вы должны предоставить свой собственный `COleClientDoc` обработчик утилиты обновления в вашем представлении или документе (то есть где-то раньше в речной реучной реучной реучной версии команды).

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

   Для замены стандартной реализации OLE используйте `COleClientItem::CanPaste`.

- ID_EDIT_PASTE_LINK вставляет ссылку из текущего содержимого Clipboard.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `COleDocument`просто предоставляет обработчик управления утилитой обновления для этой команды. Если Clipboard не содержит связываемый элемент/объект OLE, команда будет отключена. Вы несете ответственность за написание обработчика для фактической команды, чтобы сделать фактическую вставку. Если ваше приложение OLE также может вставить другие форматы, вы должны предоставить свой собственный `COleDocument` обработчик утилиты обновления в вашем представлении или документе (то есть где-то раньше в речной реучной реучной реучной версии команды).

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

   Для замены стандартной реализации OLE используйте `COleClientItem::CanPasteLink`.

- ID_EDIT_PASTE_SPECIAL вставляет текущее содержимое Clipboard с опциями.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного. MFC не предоставляет этот диалог.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_REPEAT повторяет последнюю операцию.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды для повторения последней операции поиска. Используются частные переменные реализации для последней находки. Команда отключена, если находка не может быть предпринята.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_REPLACE начинает заменить работу, поднимает безмерный диалог замены.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды, которая вызывает функцию `OnEditFindReplace` помощника реализации для использования и хранения предыдущих параметров поиска/замены в частных переменных реализации. Класс `CFindReplaceDialog` используется для управления безрежимным диалогом, который подсказывает пользователю.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_SELECT_ALL выбирает весь документ.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды, которая выбирает весь текст в документе. Команда отключена, если нет текста для выбора.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_UNDO отменяет последнюю операцию.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   `CEditView`обеспечивает реализацию этой команды, `CEdit::Undo`используя . Команда отключена, `CEdit::CanUndo` если возвращает FALSE.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_EDIT_REDO перевыполняет последнюю операцию.

   В настоящее время нет стандартной реализации для этой команды. Вы должны реализовать `CView`это для каждого класса, полученного.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_WINDOW_NEW открывает еще одно окно в активном документе.

   `CMDIFrameWnd::OnWindowNew`реализует эту мощную функцию, используя шаблон документа текущего документа для создания другой кадра, содержащего другое представление текущего документа.

   Как и большинство команд меню интерфейса мультитледочных документов (MDI) Window, команда отключена, если нет активного окна mDI ребенка.

   Настройка этого обработчика команд не рекомендуется. Если вы хотите предоставить команду, которая создает дополнительные представления или окна кадра, вам, вероятно, будет лучше изобретать свою собственную команду. Вы можете клонировать `CMDIFrameWnd::OnWindowNew` код от и изменить его в определенный кадр и просматривать классы по своему вкусу.

- ID_WINDOW_ARRANGE упорядочить значки в нижней части окна MDI.

   `CMDIFrameWnd`реализует эту стандартную команду MDI в `OnMDIWindowCmd`функции помощника реализации. Этот помощник карты команды идентизаций для MDI Windows сообщений и, следовательно, может поделиться большим количеством кода.

   Как и большинство команд меню MDI Window, команда отключена, если нет активного окна mDI ребенка.

   Настройка этого обработчика команд не рекомендуется.

- ID_WINDOW_CASCADE окна Каскады, чтобы они перекрывались.

   `CMDIFrameWnd`реализует эту стандартную команду MDI в `OnMDIWindowCmd`функции помощника реализации. Этот помощник карты команды идентизаций для MDI Windows сообщений и, следовательно, может поделиться большим количеством кода.

   Как и большинство команд меню MDI Window, команда отключена, если нет активного окна mDI ребенка.

   Настройка этого обработчика команд не рекомендуется.

- ID_WINDOW_TILE_HORZ окна плитки горизонтально.

   Эта команда реализована в `CMDIFrameWnd` таком же ID_WINDOW_CASCADE, за исключением другого сообщения MDI Windows, используемого для операции.

   Для приложения следует выбрать ориентацию плитки по умолчанию. Это можно сделать, изменив идентификатор для элемента меню «Плитка» на ID_WINDOW_TILE_HORZ или ID_WINDOW_TILE_VERT.

- ID_WINDOW_TILE_VERT плитки окна вертикально.

   Эта команда реализована в `CMDIFrameWnd` таком же ID_WINDOW_CASCADE, за исключением другого сообщения MDI Windows, используемого для операции.

   Для приложения следует выбрать ориентацию плитки по умолчанию. Это можно сделать, изменив идентификатор для элемента меню «Плитка» на ID_WINDOW_TILE_HORZ или ID_WINDOW_TILE_VERT.

- ID_WINDOW_SPLIT интерфейс клавиатуры для сплиттера.

   `CView`обрабатывает эту команду `CSplitterWnd` для реализации. Если представление является частью окна сплитера, эта `CSplitterWnd::DoKeyboardSplit`команда делегирует функции реализации. Это позволит поместить сплиттер в режим, который позволит пользователям клавиатуры разделить или разделит окно сплиттера.

   Эта команда отключена, если представление не находится в сплиттере.

   Настройка этого обработчика команд не рекомендуется.

- ID_APP_ABOUT вызывает диалоговую будку.

   Стандартная реализация приложения About box отсутствует. Созданное по умолчанию приложение AppWizard создаст пользовательский класс диалогов для вашего приложения и будет использовать его в качестве коробки About. AppWizard также напишет тривиальный обработчик команды, который обрабатывает эту команду и вызывает диалог.

   Вы почти всегда будете выполнять эту команду.

- ID_APP_EXIT Выйдите из приложения.

   `CWinApp::OnAppExit`обрабатывает эту команду, отправляя WM_CLOSE сообщение в основное окно приложения. Стандартное завершение приложения (подсказка для грязных файлов и `CFrameWnd` т.д.) обрабатывается реализацией.

   Настройка этого обработчика команд не рекомендуется. Рекомендуется `CWinApp::SaveAllModified` переопределение или логика `CFrameWnd` закрытия.

   Если вы решите реализовать эту команду, мы рекомендуем вам использовать этот идентификатор команды.

- ID_HELP_INDEX списки Справка темы из . Файл HLP.

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   `CWinApp::OnHelpIndex`обрабатывает эту команду тривиально вызывая `CWinApp::WinHelp`.

   Настройка этого обработчика команд не рекомендуется.

- ID_HELP_USING отображает помощь в использовании Справки.

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   `CWinApp::OnHelpUsing`обрабатывает эту команду тривиально вызывая `CWinApp::WinHelp`.

   Настройка этого обработчика команд не рекомендуется.

- ID_CONTEXT_HELP вводит режим помощи SHIFT-F1.

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   `CWinApp::OnContextHelp`обрабатывает эту команду, устанавливая курсор режима справки, ввод ямного цикла и ожидая, пока пользователь выберет окно, чтобы получить помощь. Для получения более подробной информации об реализации программы Помощи MFC обратитесь к [Technical Note 28.](../mfc/tn028-context-sensitive-help-support.md)

   Настройка этого обработчика команд не рекомендуется.

- ID_HELP оказывает помощь в текущем контексте

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   `CWinApp::OnHelp`обрабатывает эту команду, получив правильный контекст справки для текущего контекста приложения. Это обрабатывает простую помощь F1, помощь на ящиках сообщений и так далее. Пожалуйста, обратитесь к [Техническому примечанию 28](../mfc/tn028-context-sensitive-help-support.md) для получения более подробной информации о реализации справки MFC.

   Настройка этого обработчика команд не рекомендуется.

- ID_DEFAULT_HELP отображает справку по умолчанию для контекста

    > [!NOTE]
    >  Чтобы включить эту `CWinApp`функциональность, необходимо подключить это к карте сообщений класса вашего класса.

   Эта команда обычно отображается на `CWinApp::OnHelpIndex`.

   При желании провести различие между справкой по умолчанию и индексом справки может быть предоставлен другой обработчик команд.

- ID_NEXT_PANE переходит к следующему стеку

   `CView`обрабатывает эту команду `CSplitterWnd` для реализации. Если представление является частью окна сплитера, эта `CSplitterWnd::OnNextPaneCmd`команда делегирует функции реализации. Это позволит переместить активное представление к следующему стеку в сплиттере.

   Эта команда отключена, если представление не находится в сплиттере или нет следующего панели, чтобы перейти к.

   Настройка этого обработчика команд не рекомендуется.

- ID_PREV_PANE переходит к предыдущему стеку

   `CView`обрабатывает эту команду `CSplitterWnd` для реализации. Если представление является частью окна сплитера, эта `CSplitterWnd::OnNextPaneCmd`команда делегирует функции реализации. Это приведет к перемещению активного представления к предыдущему сплиттеру.

   Эта команда отключена, если представление не находится в сплиттере или нет предыдущего панели, чтобы перейти к.

   Настройка этого обработчика команд не рекомендуется.

- ID_OLE_INSERT_NEW вставляет новый объект OLE

   В настоящее время нет стандартной реализации для этой команды. Необходимо реализовать это `CView`для вашего класса, полученного, чтобы вставить новый элемент/объект OLE в текущий выбор.

   Все клиентские приложения OLE должны реализовать эту команду. AppWizard, с опцией OLE, создаст `OnInsertObject` реализацию скелета в вашем классе представления, который вам придется завершить.

   Для полной реализации этой команды можно ознакомиться на примере MFC OLE [OCLIENT.](../overview/visual-cpp-samples.md)

- ID_OLE_EDIT_LINKS отсравливается OLE ссылки

   `COleDocument`обрабатывает эту команду с помощью mFC при условии реализации стандартного диалога ссылок OLE. Реализация этого диалога доступна через `COleLinksDialog` класс. Если текущий документ не содержит ссылок, команда отключена.

   Настройка этого обработчика команд не рекомендуется.

- ID_OLE_VERB_FIRST... LAST Диапазон ID для глаголов OLE

   `COleDocument`использует этот диапазон идентификатора команд для глаголов, поддерживаемых выбранным в настоящее время элементом/объектом OLE. Это должен быть диапазон, так как данный тип элемента/объекта OLE может поддерживать нулевые или более пользовательские глаголы. В меню приложения должен быть один пункт меню с идентификатором ID_OLE_VERB_FIRST. Когда программа запущена, меню будет обновляться с соответствующим описанием глагола меню (или всплывающее меню с большим количеством глаголов). Управление меню OLE обрабатывается, `AfxOleSetEditMenu`сделанным в обработчике управления утилитой обновления для этой команды.

   В этом диапазоне нет явных обработчиков команд для обработки каждого идентификатора команды. `COleDocument::OnCmdMsg`переопределяется, чтобы заманить все идентиматы команд в этом диапазоне, превратить `COleClientItem::DoVerb`их в номера глагола на нулевой основе и запустить сервер для этого глагола (с помощью).

   Не рекомендуется настройка или другое использование этого диапазона идентификаторов команд.

- ID_VIEW_TOOLBAR переключает панель инструментов и выключается

   `CFrameWnd`обрабатывает эту команду и обработчик овсяного управления обновлениями для переключения видимого состояния панели инструментов. Панель инструментов должна быть детским окном кадра с идентификатором окна ребенка AFX_IDW_TOOLBAR. Обработчик команды фактически переключает видимость окна панели инструментов. `CFrameWnd::RecalcLayout`используется для перерисовки окна кадра с помощью панели инструментов в новом состоянии. Обработчик управления утилитой обновления проверяет элемент меню, когда панель инструментов видна.

   Настройка этого обработчика команд не рекомендуется. Если вы хотите добавить дополнительные панели инструментов, необходимо клонировать и модифицировать обработчик команд и обработчик управления обновлениями для этой команды.

- ID_VIEW_STATUS_BAR переключает планку статуса и выключается

   Эта команда реализуется в `CFrameWnd` так же, как ID_VIEW_TOOLBAR, за исключением другого идентификатора окна ребенка (AFX_IDW_STATUS_BAR) используется.

## <a name="update-only-command-handlers"></a>Обработчики только для обновления

Несколько стандартных идовини команд используются в качестве индикаторов в полосках состояния. Они используют тот же механизм обработки uI управления обновлениями для отображения их текущего визуального состояния во время простоя приложения. Поскольку они не могут быть выбраны пользователем (т.е. вы не можете нажать панель статуса панели), то нет смысла иметь ON_COMMAND обработчик для этих идопэй команды.

- ID_INDICATOR_CAPS : Индикатор блокировки CAP.

- ID_INDICATOR_NUM : индикатор блокировки NUM.

- ID_INDICATOR_SCRL : индикатор блокировки SCRL.

- ID_INDICATOR_KANA : индикатор блокировки KANA (применяется только к японским системам).

Все три из них `CFrameWnd::OnUpdateKeyIndicator`реализованы в, помощник реализации, который использует идентификатор команды для отображения соответствующего виртуального ключа. Общая реализация позволяет или отключает (для отключенных стекол состояния и нет текста) `CCmdUI` объект в зависимости от того, является ли соответствующий Виртуальный ключ в настоящее время заблокирован.

Настройка этого обработчика команд не рекомендуется.

- ID_INDICATOR_EXT : EXTended выберите индикатор.

- ID_INDICATOR_OVR : Индикатор OVeRstrike.

- ID_INDICATOR_REC : Индикатор RECording.

В настоящее время стандартная реализация этих показателей отсутствует.

Если вы решите реализовать эти индикаторы, мы рекомендуем вам использовать эти идентификаторы индикаторов и поддерживать порядок индикаторов в вашей адвокатской конторе статуса (то есть в этом порядке: EXT, CAP, NUM, SCRL, OVR, REC).

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
