---
title: 'TN022: Реализация стандартных команд'
ms.date: 11/04/2016
f1_keywords:
- vc.commands
helpviewer_keywords:
- ID_PREV_PANE command [MFC]
- ID_APP_EXIT command [MFC]
- ID_NEXT_PANE command [MFC]
- ID_INDICATOR_REC command [MFC]
- ID_WINDOW_SPLIT command [MFC]
- ID_FILE_PRINT_PREVIEW command [MFC]
- ID_WINDOW_CASCADE command [MFC]
- ID_FILE_CLOSE command [MFC]
- ID_FILE_SAVE_COPY_AS command [MFC]
- ID_WINDOW_ARRANGE command [MFC]
- ID_EDIT_FIND command [MFC]
- ID_FILE_OPEN command [MFC]
- ID_FILE_PAGE_SETUP command [MFC]
- ID_OLE_VERB_FIRST command [MFC]
- ID_EDIT_UNDO command [MFC]
- ID_EDIT_CLEAR command [MFC]
- ID_INDICATOR_CAPS command [MFC]
- ID_HELP_INDEX command [MFC]
- commands [MFC], standard
- ID_FILE_PRINT_SETUP command [MFC]
- ID_DEFAULT_HELP command [MFC]
- ID_INDICATOR_SCRL command [MFC]
- ID_FILE_PRINT command [MFC]
- ID_INDICATOR_OVR command [MFC]
- ID_INDICATOR_KANA command [MFC]
- ID_EDIT_COPY command [MFC]
- ID_EDIT_REDO command [MFC]
- ID_EDIT_PASTE command [MFC]
- ID_OLE_INSERT_NEW command [MFC]
- ID_OLE_EDIT_LINKS command [MFC]
- ID_EDIT_PASTE_SPECIAL command [MFC]
- ID_INDICATOR_EXT command [MFC]
- ID_HELP_USING command [MFC]
- standard commands
- ID_VIEW_STATUS_BAR command [MFC]
- ID_FILE_SAVE_AS command [MFC]
- ID_EDIT_CLEAR_ALL command [MFC]
- ID_WINDOW_NEW command [MFC]
- ID_CONTEXT_HELP command [MFC]
- ID_EDIT_REPLACE command [MFC]
- ID_WINDOW_TILE_HORZ command [MFC]
- ID_APP_ABOUT command [MFC]
- TN022
- ID_VIEW_TOOLBAR command [MFC]
- ID_HELP command [MFC]
- ID_WINDOW_TILE_VERT command [MFC]
- ID_EDIT_CUT command [MFC]
- ID_FILE_UPDATE command [MFC]
- ID_EDIT_REPEAT command [MFC]
- ID_FILE_SAVE command [MFC]
- ID_EDIT_PASTE_LINK command [MFC]
- ID_EDIT_SELECT_ALL command [MFC]
- ID_FILE_NEW command [MFC]
- ID_INDICATOR_NUM command
ms.assetid: a7883b46-23f7-4870-ac3a-804aed9258b5
ms.openlocfilehash: 4c066521ba2b5be9ac24a8abaece42e57b8ad85f
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57279376"
---
# <a name="tn022-standard-commands-implementation"></a>TN022: Реализация стандартных команд

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает реализации стандартных команд, предоставляемых MFC 2.0. Чтение [технические 21 Примечание](../mfc/tn021-command-and-message-routing.md) первый так как он описывает механизмы, используемые для реализации многих стандартных команд.

Это описание предполагает архитектуры MFC, интерфейсы API и программирования принято. Документированные, а также недокументированные «реализация только» описаны интерфейсы API. Это не место для начала изучения возможностей или как программировать в MFC. Ссылаться на Visual C++, общие сведения и подробности документированных интерфейсов API.

## <a name="the-problem"></a>Проблема

MFC определяет многие стандартные идентификаторы команд в файле заголовка AFXRES. З. Поддержка платформы для этих команд зависит. Понимание того, где и как классы платформы обрабатывать эти команды не только отображается как внутренний механизм работы платформы, но позволяют получить полезную информацию о том, как настроить стандартные реализации и изучаются нескольких методов для реализации собственные обработчики команд.

## <a name="contents-of-this-technical-note"></a>Содержимое этого техническое Примечание

В двух разделах описан каждый идентификатор команды:

- Заголовок: символическое имя идентификатора команды (например, ID_FILE_SAVE) следуют цели команды (например, «сохранение текущего документа»), разделенные двоеточием.

- Один или несколько абзацев, описывающий, какие классы реализуют команда, и что делает реализацию по умолчанию

Большинство реализаций команду по умолчанию являются prewired в схеме сообщений базового класса платформы. Существуют некоторые реализации команд, требующих явной, написанного в производном классе. Они описаны в разделе «Примечания». Если вы выбрали подходящие параметры в мастере приложений, эти обработчики по умолчанию будет подключена в созданного скелет приложения для вас.

## <a name="naming-convention"></a>Соглашение об именовании

Стандартные команды выполните простой соглашение об именовании, мы рекомендуем использовать, если это возможно. Большинство стандартных команд, находятся в стандартных местах в строке меню приложения. Символическое имя команды начинается с «ID_», за которым следует имя стандартного всплывающего меню, за которым следует имя элемента меню. Символическое имя находится в верхнем регистре с подчеркивания слов. Для команд, которые не имеют имен стандартного меню элемента имени логического команды определяется начиная с «ID_» (например, ID_NEXT_PANE).

Мы используем префикс «ID_» для указания команд, предназначенных для привязки к пунктов меню, кнопки панели инструментов или других объектов пользовательского интерфейса команды. Обработчики команд, обработка команд «ID_» следует использовать механизмы ON_COMMAND и ON_UPDATE_COMMAND_UI архитектуры команды MFC.

Мы рекомендуем использовать стандартный префикс «IDM_» для пунктов меню, которые не выполните команду архитектуры и не нужен код для включения и отключения их меню. Само собой количество определенных команд меню должно быть небольшой, поскольку следующие команды архитектуры MFC не только делает обработчики команд более мощные (так как они будут работать с панелями инструментов) но код обработчика команд для повторного использования.

## <a name="id-ranges"></a>Диапазоны Идентификаторов

Обратитесь к [техническое Примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md) Дополнительные сведения по использованию диапазонов Идентификаторов в MFC.

Стандартные команды MFC попадает в диапазон 0xE000 для 0xEFFF. Пожалуйста не следует полагаться на конкретные значения из этих кодов, так как они могут меняться в будущих версиях библиотеки.

Приложение должно определить команд в диапазоне от 0x8000 до 0xDFFF.

## <a name="standard-command-ids"></a>Стандартные идентификаторы команд

Для каждого идентификатора команды имеется стандартное сообщение запроса строки, можно найти в файле ЗАПРОСАХ. ВЕРСИЯ-КАНДИДАТ. Идентификатор строки для этой строки меню должен быть же, как и идентификатор команды.

- ID_FILE_NEW создает новый и пустой документ.

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   `CWinApp::OnFileNew` реализует эта команда по-разному в зависимости от количества шаблонов документов в приложении. Если имеется только один `CDocTemplate`, `CWinApp::OnFileNew` создаст новый документ этого типа, а также соответствующий класс фрейма и представления.

   Если имеется более одного `CDocTemplate`, `CWinApp::OnFileNew` , пользователь получит запрос с помощью диалогового окна (AFX_IDD_NEWTYPEDLG), оповещающие их, укажите, какие типа для использования документа. Выбранный `CDocTemplate` используется для создания документа.

   Один Общие настройки ID_FILE_NEW — предоставить другой и более широкий выбор графических типов документов. В этом случае можно реализовать собственный `CMyApp::OnFileNew` и поместите его на карте сообщения вместо `CWinApp::OnFileNew`. Нет необходимости вызывать реализацию базового класса.

   Другой Общие настройки ID_FILE_NEW заключается в предоставлении отдельную команду для создания документа каждого типа. В этом случае следует определить новую команду идентификаторы, например ID_FILE_NEW_CHART и ID_FILE_NEW_SHEET.

- ID_FILE_OPEN открывает существующий документ.

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   `CWinApp::OnFileOpen` имеет очень простую реализацию, вызывающего `CWinApp::DoPromptFileName` следуют `CWinApp::OpenDocumentFile` с пути к файлу или имя файла, чтобы открыть. `CWinApp` Подпрограмма реализации `DoPromptFileName` появится стандартное диалоговое окно FileOpen и заполняет его расширения файлов, полученный из текущего шаблонов документов.

   Один Общие настройки ID_FILE_OPEN — настроить FileOpen диалогового окна или добавить дополнительные фильтры файлов. Чтобы настроить это действие рекомендуется заменить реализацию по умолчанию FileOpen диалоговое окно, и вызов `CWinApp::OpenDocumentFile` с именем файла или путь документа. Нет необходимости вызывать базовый класс.

- ID_FILE_CLOSE закрывает открытый документ.

   `CDocument::OnFileClose` вызовы `CDocument::SaveModified` пользователю сохранить документ в том случае, если он был изменен, а затем вызывает `OnCloseDocument`. Всю необходимую логику закрытия, включая удаления самого документа выполняется в `OnCloseDocument` подпрограммы.

    > [!NOTE]
    >  ID_FILE_CLOSE работает по-разному из сообщения WM_CLOSE или команды системы SC_CLOSE отправляемые фрейм окна документов. Закрытие окна будет закрыть документ, только в том случае, если это последнее окно фрейма, отображение документа. Закрытие документа с ID_FILE_CLOSE только не закроет документ, но завершает работу всех окон фрейма, отображение документа.

- ID_FILE_SAVE Сохранение текущего документа.

   Реализация использует вспомогательная подпрограмма `CDocument::DoSave` — используется для обоих `OnFileSave` и `OnFileSaveAs`. Если вы сохраните документ, который ранее не сохранялся (то есть он не имеет имени пути в случае FileNew) или который был прочитан из документа только для чтения, `OnFileSave` логики будет выполнять роль ID_FILE_SAVE_AS команды и попросите пользователя указать новое имя файла . Процесс открытия файла и выполнив сохранение осуществляется с помощью виртуальной функции `OnSaveDocument`.

   Существуют две распространенные причины для настройки ID_FILE_SAVE. Для документов, не будет сохранена просто удалите "ID_FILE_SAVE пункты меню и кнопки панели инструментов" из интерфейса пользователя ". Также убедитесь, что никогда не измененные документа (то есть, никогда не вызывать `CDocument::SetModifiedFlag`) и платформа не вызовет сохраняемый документ. Для документов, куда-нибудь сохранить файл на диске определение новые команды для этой операции.

   В случае использования `COleServerDoc`, ID_FILE_SAVE служит для сохранения файла (для обычных документов) и файл обновления (для embedded документов).

   Если данные документа хранятся в отдельные файлы, но вы не хотите использовать значение по умолчанию `CDocument` сериализовать реализации, следует переопределить `CDocument::OnSaveDocument` вместо `OnFileSave`.

- ID_FILE_SAVE_AS сохраняет текущий документ в другое имя файла.

   `CDocument::OnFileSaveAs` Реализация использует тот же `CDocument::DoSave` вспомогательная подпрограмма как `OnFileSave`. `OnFileSaveAs` Команда обрабатывается так же, как ID_FILE_SAVE, если имя файла не до сохранения документов. `COleServerDoc::OnFileSaveAs` реализует логику для сохранения файла данных документа в обычном или сохранить серверный документ, представляющий объект OLE, внедренных в другое приложение в отдельный файл.

   Если настроить логику ID_FILE_SAVE, может потребоваться настроить ID_FILE_SAVE_AS таким же образом или операцию «Сохранить как» не могут применяться в документ. Пункт меню можно удалить из меню, если он не является обязательным.

- ID_FILE_SAVE_COPY_AS сохраняет копии текущего документа под новым именем.

   `COleServerDoc::OnFileSaveCopyAs` Очень похожа на реализацию `CDocument::OnFileSaveAs`, за исключением того, что объект "документ" не «подключен» в базовый файл после сохранения. То есть если документ в памяти «изменена» до сохранения, он является по-прежнему «modified». Кроме того эта команда не влияет на имя пути или заголовок, хранящийся в документе.

- ID_FILE_UPDATE уведомляет контейнер, чтобы сохранить внедренный документ.

   `COleServerDoc::OnUpdateDocument` Реализации просто notifiies контейнер, который должен быть сохранен внедрение. Контейнер, затем вызывает соответствующие API-интерфейсы OLE для сохранения внедренного объекта.

- ID_FILE_PAGE_SETUP вызывает диалоговое окно установки/макета страницы приложения.

   В настоящее время отсутствует стандарт для этого диалога, а платформа не имеет значение по умолчанию реализации этой команды.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_FILE_PRINT_SETUP вызова стандартное диалоговое окно настройки печати.

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   Эта команда вызывает стандартные настройки печати диалоговое окно, позволяющее пользователю настроить принтер и параметры печати для по крайней мере в этом документе, или не более на все документы в этом приложении. Чтобы изменить такие настройки принтера по умолчанию для всей системы, необходимо использовать панель управления.

   `CWinApp::OnFilePrintSetup` имеет очень простую реализацию создания `CPrintDialog` объекта и вызывая метод `CWinApp::DoPrintDialog` реализации функции. Этот параметр задает принтера и параметров приложения.

   Требуется настройка Эта команда является разрешение для параметры принтера на уровне документа, которые должны быть сохранены вместе с документом при сохранении. Для этого следует добавить обработчик схемы сообщений в вашей `CDocument` класс, который создает `CPrintDialog` объекта, инициализирует его с атрибутами принтера (обычно *hDevMode* и *hDevNames*), вызовите `CPrintDialog::DoModal`и сохраните параметры измененные принтера. Для надежной реализации, следует обратить внимание на реализацию `CWinApp::DoPrintDialog` для обнаружения ошибок и `CWinApp::UpdatePrinterSelection` дело допустимые значения по умолчанию и отслеживание изменений принтера всей системы.

- Стандартная ID_FILE_PRINT Печать текущего документа

    > [!NOTE]
    >  Необходимо подключить это для вашей `CView`-производного класса схемы сообщений для включения этой функции.

   Эта команда выводит текущий документ или точнее, запускает процесс печати, который включает в себя вызова стандартное диалоговое окно печати и запуска печати механизма.

   `CView::OnFilePrint` реализует эту команду и основного цикла печати. Он вызывает виртуальный `CView::OnPreparePrinting` запрос пользователя с помощью диалогового окна печати. Затем он подготавливает выходные данные контроллера домена для принтера по, можно открыть диалоговое окно печати хода выполнения (AFX_IDD_PRINTDLG) и отправляет `StartDoc` escape-последовательности для принтера. `CView::OnFilePrint` также содержит основной цикл печати печати. Для каждой страницы, он вызывает виртуальный `CView::OnPrepareDC` следуют `StartPage` escape и вызов виртуальной `CView::OnPrint` для этой страницы. По завершении, виртуальный `CView::OnEndPrinting` вызывается, и закрытии диалогового окна печати хода выполнения.

   Архитектура печати MFC позволяет подключить множеством разных способов для печати и предварительного просмотра. Вы найдете обычно различных `CView` переопределяемые функции достаточен для любого печати задания печати. Только в случае приложения, использующего принтера для отличных от страниц готовится выходных данных следует действовать необходимость замены ID_FILE_PRINT реализации.

- Введите ID_FILE_PRINT_PREVIEW-режиме предварительного просмотра для текущего документа.

    > [!NOTE]
    >  Необходимо подключить это для вашей `CView`-производного класса схемы сообщений для включения этой функции.

   `CView::OnFilePrintPreview` запускает режим предварительного просмотра, вызывая функцию документированных `CView::DoPrintPreview`. `CView::DoPrintPreview` является основным механизмом для предварительного просмотра цикла, так же, как `OnFilePrint` является основным механизмом для печати цикла.

   Операция печати предварительной версии можно настраивать различными способами путем передачи разных параметров для `DoPrintPreview`. Обратитесь к [технические 30 Примечание](../mfc/tn030-customizing-printing-and-print-preview.md), которой рассматриваются некоторые сведения о режиме предварительного просмотра и как его настроить.

- ID_FILE_MRU_FILE1... FILE16 Диапазон идентификаторов команд для файла MRU **списка**.

   `CWinApp::OnUpdateRecentFileMenu` — Это обработчик пользовательского интерфейса команды обновления, который является одним из более сложных вариантов использования механизма ON_UPDATE_COMMAND_UI. В меню ресурса необходимо только определить отдельный элемент меню с ID_FILE_MRU_FILE1 идентификатор. Этот элемент меню остается в изначально отключенном.

   По мере MRU списка освоения, дополнительные меню, элементы добавляются в список. Стандартный `CWinApp` реализации по умолчанию используется стандартная ограничение в четыре самых последних использовавшихся файлов. Значение по умолчанию можно изменить, вызвав `CWinApp::LoadStdProfileSettings` со значением больше или меньше. Список последних выбиравшихся файлов хранится в приложения. INI-файл. Загрузить список в вашем приложении `InitInstance` функции при вызове метода `LoadStdProfileSettings`и сохраняется при выходе из приложения. Обработчик пользовательского интерфейса команды MRU обновлений также преобразует абсолютные пути для относительных путей для отображения в меню "файл".

   `CWinApp::OnOpenRecentFile` — ON_COMMAND обработчик, который выполняет фактическое команды. Он просто получает имя файла в списке последних выбиравшихся файлов и вызовы `CWinApp::OpenDocumentFile`, который выполняет всю работу при открытии файла и обновления в списке последних выбиравшихся файлов.

   Настройки этого обработчика команды не рекомендуется.

- ID_EDIT_CLEAR очищает текущее выделение

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этого используется команда `CEdit::Clear`. Команда отключена, если нет текущего выделенного фрагмента.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_CLEAR_ALL очищает весь документ.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды. См. пример для руководства MFC [SCRIBBLE](../visual-cpp-samples.md) пример реализации.

- ID_EDIT_COPY копирует текущее выделение в буфер обмена.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этой команды, которая копирует текущий выделенный текст в буфер обмена как с помощью CF_TEXT `CEdit::Copy`. Команда отключена, если нет текущего выделенного фрагмента.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_CUT Вырезание текущего выделения в буфер обмена.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этой команды, которая вырезает выделенный текст в буфер обмена, как с помощью CF_TEXT `CEdit::Cut`. Команда отключена, если нет текущего выделенного фрагмента.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_FIND начинается операция поиска, можно открыть диалоговое окно поиска немодальное.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этой команды, которая вызывается вспомогательная функция реализации `OnEditFindReplace` и сохранить предыдущие параметры поиска и замены в закрытой реализации переменных. `CFindReplaceDialog` Класс используется для управления немодальное диалоговое окно для подтверждения пользователя.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_PASTE вставляет текущее содержимое буфера обмена.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этой команды, которая копирует текущие данные буфера обмена, замена выделенный текст с использованием `CEdit::Paste`. Команда отключена, если не **CF_TEXT** в буфер обмена.

   `COleClientDoc` просто предоставляет обработчик пользовательского интерфейса команды обновления для этой команды. Если буфер обмена не содержит встраиваемый элемент или объект OLE, команда будет отключена. Вы несете ответственность за написание обработчика для фактического команду, чтобы сделать фактический вставки. Если приложения OLE также можно вставить в другие форматы, необходимо предоставить свои собственные обновления обработчик пользовательского интерфейса команды в представлении или документа (т. е где-нибудь перед `COleClientDoc` в целевой маршрутизации команд).

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

   Для замены стандартной реализации OLE, использовать `COleClientItem::CanPaste`.

- ID_EDIT_PASTE_LINK Вставка ссылки из текущее содержимое буфера обмена.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `COleDocument` просто предоставляет обработчик пользовательского интерфейса команды обновления для этой команды. Если буфер обмена не содержит ссылок на основе элемента/объект OLE, команда будет отключена. Вы несете ответственность за написание обработчика для фактического команду, чтобы сделать фактический вставки. Если приложения OLE также можно вставить в другие форматы, необходимо предоставить свои собственные обновления обработчик пользовательского интерфейса команды в представлении или документа (т. е где-нибудь перед `COleDocument` в целевой маршрутизации команд).

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

   Для замены стандартной реализации OLE, использовать `COleClientItem::CanPasteLink`.

- ID_EDIT_PASTE_SPECIAL вставляет текущее содержимое буфера обмена с параметрами.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса. MFC не поддерживает это диалоговое окно.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_REPEAT повторяет последнюю операцию.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этой команды повторите последнюю операцию поиска. Используются переменные закрытой реализации для поиска. Команда отключена, если поиск не может выполняться.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_REPLACE начинает операции замены, можно открыть диалоговое окно замены немодальное.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этой команды, которая вызывается вспомогательная функция реализации `OnEditFindReplace` и сохранить предыдущие параметры поиска и замены в закрытой реализации переменных. `CFindReplaceDialog` Класс используется для управления немодального диалогового окна, который запрашивает у пользователя.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_SELECT_ALL выделяет весь документ.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этой команды, которая выделяет весь текст в документе. Команда отключена, если отсутствует текст для выбора.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_UNDO отменяет последнюю операцию.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   `CEditView` предоставляет реализацию этого команду, используя `CEdit::Undo`. Команда отключена, если `CEdit::CanUndo` возвращает значение FALSE.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_EDIT_REDO Повтор последней операции.

   В настоящее время отсутствует Стандартная реализация для этой команды. Это необходимо реализовать для каждого `CView`-производного класса.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_WINDOW_NEW Открытие другого окна в активном документе.

   `CMDIFrameWnd::OnWindowNew` реализует эту существенную возможность с помощью шаблона документа текущего документа, чтобы создать другой кадр, содержащий другое представление текущего документа.

   Как и большинство нескольких документов интерфейса (MDI) окна команд меню команда будет отключен, если нет active дочернего окна MDI.

   Настройки этого обработчика команды не рекомендуется. Если вы хотите указать команду, которая создает дополнительные представления или окна фрейма, изобретать свои собственные команды, вероятно, лучше. Вы можете клонировать его из `CMDIFrameWnd::OnWindowNew` и изменить для определенного кадра и представление классов предпочтениям.

- ID_WINDOW_ARRANGE упорядочивает значки в нижней части окна интерфейса MDI.

   `CMDIFrameWnd` реализует этот стандартную команду MDI в реализации вспомогательная функция `OnMDIWindowCmd`. Этот вспомогательный метод сопоставляет идентификаторы команд для сообщений Windows MDI и таким образом, могут совместно использовать большой объем кода.

   Как и большинство команд меню окна интерфейса MDI команда будет отключен, если нет active дочернего окна MDI.

   Настройки этого обработчика команды не рекомендуется.

- Каскадные ID_WINDOW_CASCADE windows, поэтому они перекрываются.

   `CMDIFrameWnd` реализует этот стандартную команду MDI в реализации вспомогательная функция `OnMDIWindowCmd`. Этот вспомогательный метод сопоставляет идентификаторы команд для сообщений Windows MDI и таким образом, могут совместно использовать большой объем кода.

   Как и большинство команд меню окна интерфейса MDI команда будет отключен, если нет active дочернего окна MDI.

   Настройки этого обработчика команды не рекомендуется.

- ID_WINDOW_TILE_HORZ плитки windows по горизонтали.

   Эта команда реализуется в `CMDIFrameWnd` так же, как ID_WINDOW_CASCADE, за исключением того, на другое сообщение Windows MDI, используемый для операции.

   Следует выбрать ориентацию плитки по умолчанию для приложения. Это можно сделать, изменив идентификатор для пункта меню «Плитка» окно ID_WINDOW_TILE_HORZ или ID_WINDOW_TILE_VERT.

- ID_WINDOW_TILE_VERT плитки windows по вертикали.

   Эта команда реализуется в `CMDIFrameWnd` так же, как ID_WINDOW_CASCADE, за исключением того, на другое сообщение Windows MDI, используемый для операции.

   Следует выбрать ориентацию плитки по умолчанию для приложения. Это можно сделать, изменив идентификатор для пункта меню «Плитка» окно ID_WINDOW_TILE_HORZ или ID_WINDOW_TILE_VERT.

- Интерфейс клавиатуры ID_WINDOW_SPLIT разделителя.

   `CView` обрабатывает эту команду для `CSplitterWnd` реализации. Если представление является частью окна разделителя, эта команда делегирует реализацию функции `CSplitterWnd::DoKeyboardSplit`. Это будет поместите разделитель в режиме, который позволит пользователям клавиатуры разбивать или отменить Разделение окна разделителя.

   Эта команда будет отключен, если представление не в разделитель.

   Настройки этого обработчика команды не рекомендуется.

- ID_APP_ABOUT вызывает диалоговое окно About.

   Отсутствует Стандартная реализация для приложения о поле. Приложение, созданное мастером приложений по умолчанию будет создание класса пользовательского диалогового окна для приложения и использовать его в качестве о среде. AppWizard также напишем обработчик команд тривиальные обрабатывает эту команду, и вызов диалогового окна.

   Эта команда почти всегда будет реализовано.

- ID_APP_EXIT выйти из приложения.

   `CWinApp::OnAppExit` Эта команда обрабатывает путем отправки сообщения WM_CLOSE главное окно приложения. Standard, завершение работы приложения (ожидает ввода измененных файлов и т. д) обрабатывается `CFrameWnd` реализации.

   Настройки этого обработчика команды не рекомендуется. Переопределение `CWinApp::SaveAllModified` или `CFrameWnd` мягкой логики закрытия, рекомендуется.

   Если вы решили реализовать эту команду, мы рекомендуем использовать этот идентификатор команды.

- ID_HELP_INDEX перечислены справок из. HLP-файл.

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   `CWinApp::OnHelpIndex` обрабатывает эту команду, просто вызвав `CWinApp::WinHelp`.

   Настройки этого обработчика команды не рекомендуется.

- ID_HELP_USING Отображение справки по использованию справки.

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   `CWinApp::OnHelpUsing` обрабатывает эту команду, просто вызвав `CWinApp::WinHelp`.

   Настройки этого обработчика команды не рекомендуется.

- Режим справки F1-ID_CONTEXT_HELP вводит SHIFT.

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   `CWinApp::OnContextHelp` Эта команда обрабатывает путем установки режима курсор справки, введя модальный цикл и ожидание пользователю выбрать окно, чтобы получить справку по. Обратитесь к [Технические замечания 28](../mfc/tn028-context-sensitive-help-support.md) Дополнительные сведения о реализации MFC справки.

   Настройки этого обработчика команды не рекомендуется.

- ID_HELP предоставляет помощь в текущем контексте

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   `CWinApp::OnHelp` Эта команда обрабатывает, получение контекста справки для текущего контекста приложения. Это обрабатывает простой справки F1, получить справку в окнах сообщений и т. д. Обратитесь к [Технические замечания 28](../mfc/tn028-context-sensitive-help-support.md) для получения дополнительных сведений о MFC устранения проблем реализации.

   Настройки этого обработчика команды не рекомендуется.

- Справка по умолчанию отображает ID_DEFAULT_HELP для контекста

    > [!NOTE]
    >  Необходимо подключить это для вашей `CWinApp`-производного класса схемы сообщений для включения этой функции.

   Эта команда обычно сопоставляется с `CWinApp::OnHelpIndex`.

   Обработчик разные команды можно указать при необходимости различие между справки по умолчанию и указателя справки.

- ID_NEXT_PANE переходит к следующей панели

   `CView` обрабатывает эту команду для `CSplitterWnd` реализации. Если представление является частью окна разделителя, эта команда делегирует реализацию функции `CSplitterWnd::OnNextPaneCmd`. Перемещение к следующей панели в разделителе активное представление.

   Эта команда недоступна, если представление не в разделитель или нет Следующая область, чтобы перейти к.

   Настройки этого обработчика команды не рекомендуется.

- ID_PREV_PANE переходит к предыдущей панели

   `CView` обрабатывает эту команду для `CSplitterWnd` реализации. Если представление является частью окна разделителя, эта команда делегирует реализацию функции `CSplitterWnd::OnNextPaneCmd`. Перемещение на предыдущую панель в разделителе активное представление.

   Эта команда недоступна, если представление не в разделитель или нет предыдущей области, чтобы перейти к.

   Настройки этого обработчика команды не рекомендуется.

- ID_OLE_INSERT_NEW вставляет новый объект OLE

   В настоящее время отсутствует Стандартная реализация для этой команды. Необходимо реализовать это для вашей `CView`-производный класс для вставки нового элемента OLE-объекта в текущее выделение.

   Все клиентские приложения с поддержкой OLE, должны применять эту команду. Мастером приложений, с помощью параметра OLE создаст схему реализации `OnInsertObject` в классе представления, которые необходимо выполнить.

   См. в разделе примера MFC OLE [OCLIENT](../visual-cpp-samples.md) пример полную реализацию этой команды.

- ID_OLE_EDIT_LINKS редактирует каналов OLE

   `COleDocument` обрабатывает эту команду с помощью MFC-предоставляемой реализации стандартное диалоговое окно ссылок OLE. Реализация этого диалогового окна осуществляется через `COleLinksDialog` класса. Если текущий документ не содержит все ссылки, команда отключена.

   Настройки этого обработчика команды не рекомендуется.

- ID_OLE_VERB_FIRST... Последний диапазон Идентификаторов для команды OLE

   `COleDocument` использует этот диапазон Идентификаторов команд для команд, поддерживаемых элемент текущего выбранного OLE-объекта /. Это должно быть диапазоном, поскольку заданного типа объекта или элемента OLE может поддерживать ноль или более пользовательских команд. В меню приложения должен быть один элемент меню с Идентификатором ID_OLE_VERB_FIRST. При запуске программы, меню будет добавлено в описание команды соответствующего меню (или всплывающего меню со множества команд). Управление меню OLE обрабатывается `AfxOleSetEditMenu`, делать обработчик пользовательского интерфейса команды обновления для этой команды.

   Существуют обработчики нет явной команды для обработки каждого из идентификатор команды в этом диапазоне. `COleDocument::OnCmdMsg` переопределяется, чтобы перехватить все идентификаторы команд в этом диапазоне, включить их в числа (с нуля) команды и запустить сервер для этой команды (с помощью `COleClientItem::DoVerb`).

   Настройки или другого использования этой команды диапазон Идентификаторов не рекомендуется.

- События ID_VIEW_TOOLBAR включает панели инструментов и выключает

   `CFrameWnd` обрабатывает эту команду и обработчик пользовательского интерфейса команды update, чтобы переключить режим отображения панели инструментов. Панели инструментов должен быть дочернее окно рамки с дочернего окна идентификатор из AFX_IDW_TOOLBAR. Обработчик команд фактически переключает видимость окна инструментов. `CFrameWnd::RecalcLayout` используется для перерисовки фрейма окна с помощью панели инструментов в состоянии новый. Обработчик пользовательского интерфейса команды update проверяет пункта меню, панели инструментов отображается, когда.

   Настройки этого обработчика команды не рекомендуется. Если вы хотите добавить дополнительные панели инструментов, необходимо клонировать и изменять обработчик команд и обработчик пользовательского интерфейса команды update для этой команды.

- ID_VIEW_STATUS_BAR включает строку состояния и выключает

   Эта команда реализуется в `CFrameWnd` так же, как события ID_VIEW_TOOLBAR, за исключением разных дочернее окно, используется идентификатор (AFX_IDW_STATUS_BAR).

## <a name="update-only-command-handlers"></a>Обработчики команд только для обновления

Несколько ИД стандартных команд используются в качестве индикаторов в строке состояния. Эти используйте команду обновления пользовательского интерфейса, механизм обработки для отображения их текущее визуальное состояние во время простоя приложения. Так как они не могут быть выбраны пользователем (то есть невозможно принудительно отправить панель строки состояния), то нет смысла иметь обработчик ON_COMMAND эти идентификаторы команд.

- ID_INDICATOR_CAPS : Индикатор блокировки CAP.

- ID_INDICATOR_NUM: Индикатор NUM lock.

- ID_INDICATOR_SCRL: Индикатор SCRL блокировки.

- ID_INDICATOR_KANA: КАНА блокировки индикатор (применимо только к системам на японском языке).

Все три из них реализованы в `CFrameWnd::OnUpdateKeyIndicator`, использует идентификатор команды для сопоставления с ключом виртуального вспомогательную функцию реализации. Общая Реализация включает или отключает (панелями состояния отключена = нет текста) `CCmdUI` объект, зависящий от ли в данный момент заблокирована соответствующие виртуальная клавиша.

Настройки этого обработчика команды не рекомендуется.

- ID_INDICATOR_EXT : Расширенный выбор индикатора.

- ID_INDICATOR_OVR : Индикатор замены.

- ID_INDICATOR_REC : Индикатор записи.

В настоящее время отсутствует Стандартная реализация для этих индикаторов.

Если вы решили реализовать эти индикаторы, мы рекомендуем использовать эти индикатор идентификаторы и сохранению порядка индикаторы в строке состояния (то есть в следующем порядке: EXT, CAP, NUM, SCRL, ЗАМ, РЕК.).

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
