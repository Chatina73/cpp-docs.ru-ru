---
title: 'TN045: MFC-База данных поддержка длинных Варчар-Варбинар'
ms.date: 11/04/2016
helpviewer_keywords:
- TN045
- Varbinary data type
- Varchar data type
ms.assetid: cf572c35-5275-45b5-83df-5f0e36114f40
ms.openlocfilehash: f67d159fb600dcacd8eedd40e672edf18bddee9a
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365507"
---
# <a name="tn045-mfcdatabase-support-for-long-varcharvarbinary"></a>TN045. Поддержка MFC и баз данных для типов Long Varchar и Varbinary

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой заметке описывается, как получить и отправить ODBC **SQL_LONGVARCHAR** и **SQL_LONGVARBINARY** типов данных с помощью классов баз данных MFC.

## <a name="overview-of-long-varcharvarbinary-support"></a>Обзор поддержки Long Varchar/Varbinary

SQL_LONG_VARCHAR **ODBC** и **SQL_LONGBINARY** типов данных (именуемых здесь как длинные столбцы данных) может содержать огромные объемы данных. Существует 3 способа обработки этих данных:

- Привязать его `CString` / `CByteArray`к .

- Привязать его `CLongBinary`к .

- Не связывайте его вообще и получить и отправить длинное значение данных вручную, независимо от классов базы данных.

Каждый из трех методов имеет свои преимущества и недостатки.

Длинные столбцы данных не поддерживаются для параметров запроса. Они поддерживаются только для outputColumns.

## <a name="binding-a-long-data-column-to-a-cstringcbytearray"></a>Привязка колонки длинных данных к CString/CByteArray

Преимущества:

Этот подход прост для понимания, и вы работаете со знакомыми классами. Рамки обеспечивают `CFormView` поддержку `DDX_Text`с `CString` . У вас есть много общей функциональности `CString` `CByteArray` строки или сбора с классами, и вы можете контролировать объем памяти, выделенной локально для удержания значения данных. Платформа поддерживает старую копию полевых данных во время `Edit` или `AddNew` функциональных вызовов, и фреймворк может автоматически обнаруживать для вас изменения в данных.

> [!NOTE]
> Так `CString` как предназначен для работы `CByteArray` с данными о персонажах, и для работы с `CString`двоичными данными, рекомендуется поместить данные о персонажах **(SQL_LONGVARCHAR)** в , и двоичные данные **(SQL_LONGVARBINARY**) в `CByteArray`.

ФУНКЦИи RFX `CString` `CByteArray` для и имеют дополнительный аргумент, который позволяет переопределить размер выделенной памяти по умолчанию для удержания извлеченного значения для столбца данных. Обратите внимание на аргумент nMaxLength в следующих декларациях функций:

```
void AFXAPI RFX_Text(CFieldExchange* pFX,
    const char *szName,
    CString& value,
    int nMaxLength = 255,
    int nColumnType =
    SQL_VARCHAR);

void AFXAPI RFX_Binary(CFieldExchange* pFX,
    const char *szName,
    CByteArray& value,
    int nMaxLength = 255);
```

При извлечении длинного столбца данных в `CString` `CByteArray`или, максимальный возвращенный объем данных, по умолчанию, 255 байтов. Все, что выходит за рамки этого, игнорируется. В этом случае фреймворк будет AFX_SQL_ERROR_DATA_TRUNCATED **исключением.** К счастью, вы можете явно увеличить nMaxLength до больших значений, вплоть до **MAXINT**.

> [!NOTE]
> Значение nMaxLength используется MFC для установки локального `SQLBindColumn` буфера функции. Это локальный буфер для хранения данных и на самом деле не влияет на объем данных, возвращенных драйвером ODBC. `RFX_Text`и `RFX_Binary` только один `SQLFetch` звонок, используя для извлечения данных из базы данных бэк-энда. Каждый драйвер ODBC имеет различное ограничение на объем данных, которые они могут вернуть в одном извлечении. Этот предел может быть гораздо меньше значения, установленного в nMaxLength, и в этом случае будет брошено исключение **AFX_SQL_ERROR_DATA_TRUNCATED.** В этих условиях, `RFX_LongBinary` переключиться на использование, а не `RFX_Text` или `RFX_Binary` так, что все данные могут быть извлечены.

ClassWizard привяжет `CString` **SQL_LONGVARCHAR** к, `CByteArray` или **SQL_LONGVARBINARY** для вас. Если вы хотите выделить более 255 байтов, в которые вы получаете длинную колонку данных, вы можете предоставить явное значение для nMaxLength.

Когда длинный столбец данных `CString` `CByteArray`привязан к или, обновление поля работает так же, как когда он связан с SQL_**VARCHAR** или SQL_**VARBINARY.** Во `Edit`время, значение данных кэшируется прочь, а затем сравнивается, когда `Update` называется для обнаружения изменений в значении данных и установить значения грязных и null для столбца надлежащим образом.

## <a name="binding-a-long-data-column-to-a-clongbinary"></a>Привязка колонки длинных данных к CLongBinary

Если ваш длинный столбец данных может содержать больше байтов **MAXINT** данных, вы, вероятно, следует рассмотреть вопрос о его извлечении в `CLongBinary`.

Преимущества:

Это извлекает весь длинный столбец данных, вплоть до доступной памяти.

Недостатки:

Данные хранятся в памяти. Этот подход также является непомерно дорогим для очень больших объемов данных. Необходимо вызвать `SetFieldDirty` связанного участника данных, чтобы `Update` убедиться, что поле включено в операцию.

При извлечении длинных столбцов данных в `CLongBinary`классы базы данных проверят `HGLOBAL` общий размер длинного столбца данных, а затем выделите сегмент памяти, достаточно большой, чтобы удерживать его на все значение данных. Классы базы данных затем извлекают `HGLOBAL`все значение данных в выделенное значение.

Если источник данных не может вернуть ожидаемый размер длинного столбца данных, фреймворк выбросит **AFX_SQL_ERROR_SQL_NO_TOTAL**исключения. При попытке выделения `HGLOBAL` сбоев выбрасывается стандартное исключение памяти.

ClassWizard привяжет **SQL_LONGVARCHAR** или **SQL_LONGVARBINARY** `CLongBinary` к вам. Выберите `CLongBinary` в качестве переменного типа в диалоге переменных участников Add. ClassWizard затем добавит `RFX_LongBinary` вызов `DoFieldExchange` к вашему вызову и прибавит общее количество связанных полей.

Чтобы обновить длинные значения столбца данных, сначала убедитесь, что `HGLOBAL` выделенное достаточно большое, чтобы удерживать новые данные, позвонив по **телефону:GlobalSize** на *m_hData* членом `CLongBinary`. Если он слишком мал, отпустите `HGLOBAL` и выделите один соответствующий размер. Затем установите *m_dwDataLength,* чтобы отразить новый размер.

В противном случае, если *m_dwDataLength* больше, чем размер данных, которые вы `HGLOBAL`заменяете, вы можете либо освободить и перераспределить, или оставить его выделенным. Убедитесь в том, чтобы указать количество байтов на самом деле используется в *m_dwDataLength*.

## <a name="how-updating-a-clongbinary-works"></a>Как обновление CLongBinary работ

Нет необходимости понимать, как `CLongBinary` обновление работает, но это может быть полезно в качестве примера о том, как отправить длинные значения данных в источник данных, если вы выбираете этот третий метод, описанный ниже.

> [!NOTE]
> Для включения `CLongBinary` поля в обновление необходимо явно призвать `SetFieldDirty` поле. Если вы внесете какие-либо изменения в поле, включая установку его Null, вы должны позвонить `SetFieldDirty`в поле. Вы также `SetFieldNull`должны вызвать, со вторым параметром время **FALSE**, чтобы отметить поле как имеющие значение.

При обновлении `CLongBinary` поля классы баз данных используют **DATA_AT_EXEC** механизм `SQLSetPos`ODBC (см. документацию ODBC по аргументу rgbValue). Когда фреймворк готовит заявление о вставке или обновлении вместо того, чтобы указывать на `HGLOBAL` содержащий данные, *адрес* `CLongBinary` столбца устанавливается как *значение* столбца, а индикатор длины установлен для **SQL_DATA_AT_EXEC.** Позже, когда заявление об обновлении `SQLExecDirect` будет отправлено в источник данных, вернется **SQL_NEED_DATA**. Это предупреждает фреймворк о том, что значение парадля `CLongBinary`этого столбца на самом деле является адресом . Рамочная `SQLGetData` система вызывает один раз с небольшим буфером, ожидая, что драйвер вернет фактическую длину данных. Если водитель возвращает фактическую длину двоичного крупного объекта (BLOB), MFC перераспределяет столько места, сколько необходимо для получения BLOB. Если источник данных **возвращается SQL_NO_TOTAL,** указывая, что он не может определить размер BLOB, MFC создаст меньшие блоки. Первоначальный размер по умолчанию составляет 64K, а последующие блоки будут в два раза больше; например, второй будет 128K, третий 256K, и так далее. Первоначальный размер настраивается.

## <a name="not-binding-retrievingsending-data-directly-from-odbc-with-sqlgetdata"></a>Не связываясь: Получение/отправка данных непосредственно из ODBC с помощью S'LGetData

С помощью этого метода вы полностью обходят классы баз данных и сами справляетесь с длинным столбцом данных.

Преимущества:

При необходимости можно кэшировать данные на диск или динамически решать, сколько данных нужно для извлечения.

Недостатки:

Вы не получаете платформу `Edit` `AddNew` или поддержку, и вы должны написать`Delete` код самостоятельно для выполнения основных функций (работает, хотя, так как это не операция уровня столбцов).

В этом случае длинный столбец данных должен быть в выбранном списке набора записей, но не должен быть привязан к системе. Один из способов сделать это заключается `GetDefaultSQL` в предоставлении вашей собственной `CRecordset`выписки с помощью или в качестве аргумента lpszS'L к `Open` функции', а не связывать дополнительный столбец с вызовом функции RFX_. ODBC требует, чтобы несвязанные поля отображались справа от связанных полей, поэтому добавьте несвязанные столбцы или столбцы в конец списка выбора.

> [!NOTE]
> Поскольку ваш длинный столбец данных не связан с платформой, изменения в ней не будут обрабатываться с `CRecordset::Update` помощью вызовов. Вы должны создать и отправить необходимые заявления S'L **INSERT** и **UPDATE** самостоятельно.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
