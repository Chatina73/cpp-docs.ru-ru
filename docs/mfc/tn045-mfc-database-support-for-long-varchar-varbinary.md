---
description: 'Дополнительные сведения о: TN045: Поддержка MFC/базы данных для Long varchar/varbinary'
title: 'TN045: MFC-Database поддержка длинных Varchar-Varbinary'
ms.date: 11/04/2016
helpviewer_keywords:
- TN045
- Varbinary data type
- Varchar data type
ms.assetid: cf572c35-5275-45b5-83df-5f0e36114f40
ms.openlocfilehash: 4e19147ab5ca392307f331b12d3cf24eb5fcc06f
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97215187"
---
# <a name="tn045-mfcdatabase-support-for-long-varcharvarbinary"></a>TN045. Поддержка MFC и баз данных для типов Long Varchar и Varbinary

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Это примечание описывает получение и отправку типов данных ODBC **SQL_LONGVARCHAR** и **SQL_LONGVARBINARY** с помощью классов баз данных MFC.

## <a name="overview-of-long-varcharvarbinary-support"></a>Общие сведения о поддержке Long varchar/varbinary

Типы данных ODBC **SQL_LONG_VARCHAR** и **SQL_LONGBINARY** (называемые здесь длинными столбцами данных) могут содержать огромные объемы данных. Существует три способа для работы с этими данными:

- Привяжите его к `CString` / `CByteArray` .

- Привяжите его к `CLongBinary` .

- Не привяжите его вообще и извлеките и отправляйте значение типа Long данных вручную независимо от классов базы данных.

У каждого из трех методов есть преимущества и недостатки.

Столбцы данных типа Long не поддерживаются для параметров запроса. Они поддерживаются только для Аутпутколумнс.

## <a name="binding-a-long-data-column-to-a-cstringcbytearray"></a>Привязка столбца данных типа long к столбцу CString/CByteArray

Преимущества:

Этот подход прост в понимании, и вы работаете с привычными классами. Платформа обеспечивает `CFormView` поддержку `CString` с помощью `DDX_Text` . У вас есть множество общих функций строк или коллекций с `CString` `CByteArray` классами и, и вы можете управлять объемом памяти, выделенной локально для хранения значения данных. Платформа поддерживает старую копию данных поля во время `Edit` или `AddNew` вызовах функций, и платформа может автоматически обнаруживать изменения данных.

> [!NOTE]
> Поскольку `CString` предназначен для работы с символьными данными и `CByteArray` для работы с двоичными данными, рекомендуется помещают символьные данные (**SQL_LONGVARCHAR**) в `CString` , а двоичные данные (**SQL_LONGVARBINARY**) в `CByteArray` .

Функции RFX для `CString` и `CByteArray` имеют дополнительный аргумент, который позволяет переопределить размер выделенной памяти по умолчанию для хранения полученного значения для столбца данных. Обратите внимание на аргумент Нмаксленгс в следующих объявлениях функций:

```cpp
void AFXAPI RFX_Text(CFieldExchange* pFX,
    const char *szName,
    CString& value,
    int nMaxLength = 255,
    int nColumnType =
    SQL_VARCHAR);

void AFXAPI RFX_Binary(CFieldExchange* pFX,
    const char *szName,
    CByteArray& value,
    int nMaxLength = 255);
```

Если вы получаете столбец данных типа long в `CString` или `CByteArray` , максимальный возвращаемый объем данных по умолчанию равен 255 байт. Все, Кроме этого, игнорируется. В этом случае платформа выдаст исключение **AFX_SQL_ERROR_DATA_TRUNCATED**. К счастью, можно явно увеличить Нмаксленгс до более высоких значений, вплоть до **максинт**.

> [!NOTE]
> Значение Нмаксленгс используется MFC для задания локального буфера `SQLBindColumn` функции. Это локальный буфер для хранения данных, который на самом деле не влияет на объем данных, возвращаемых драйвером ODBC. `RFX_Text` и `RFX_Binary` только один вызов, используя `SQLFetch` для получения данных из серверной базы данных. Каждый драйвер ODBC имеет другое ограничение на объем данных, которые они могут вернуть в одной выборке. Это ограничение может быть намного меньше, чем значение, заданное в Нмаксленгс. в этом случае будет выдано исключение **AFX_SQL_ERROR_DATA_TRUNCATED** . В этих обстоятельствах переключитесь на использование `RFX_LongBinary` вместо `RFX_Text` или `RFX_Binary` , чтобы можно было получить все данные.

ClassWizard привязывает **SQL_LONGVARCHAR** к `CString` или **SQL_LONGVARBINARY** для `CByteArray` вас. Если вы хотите выделить более 255 байт, в которые вы получаете столбец данных Long, можно указать явное значение для Нмаксленгс.

Если столбец данных типа Long привязан к `CString` или `CByteArray` , обновление поля работает так же, как при привязке к SQL_ **varchar** или SQL_ **varbinary**. Во время `Edit` кэширования значение данных кэшируется и затем сравнивается, когда `Update` вызывается для обнаружения изменений в значении данных и для правильного задания значений «грязных» и «NULL» для столбца.

## <a name="binding-a-long-data-column-to-a-clongbinary"></a>Привязка столбца данных типа long к CLongBinary

Если столбец с длинными данными может содержать больше **максинт** байт данных, вы, вероятно, рассмотрите возможность его извлечения в `CLongBinary` .

Преимущества:

В результате получается весь столбец данных типа Long, до объема доступной памяти.

Недостатки:

Данные хранятся в памяти. Этот подход также является чрезмерно дорогостоящим для очень больших объемов данных. Необходимо вызвать `SetFieldDirty` для привязанного элемента данных, чтобы убедиться, что поле включено в `Update` операцию.

При извлечении столбцов длинных данных в объект `CLongBinary` классы базы данных будут проверять общий размер столбца данных Long, а затем выделить `HGLOBAL` сегмент памяти, достаточно большой для хранения всего значения данных. Затем классы базы данных получают все значения данных в выделенном виде `HGLOBAL` .

Если источник данных не может вернуть ожидаемый размер столбца данных типа Long, платформа выдаст исключение **AFX_SQL_ERROR_SQL_NO_TOTAL**. Если попытка выделить `HGLOBAL` ошибку не удается, выдается исключение стандартного объема памяти.

ClassWizard будет привязывать **SQL_LONGVARCHAR** или **SQL_LONGVARBINARY** к `CLongBinary` пользователю. Выберите в `CLongBinary` качестве типа переменной в диалоговом окне Добавление переменной члена. Затем ClassWizard добавит `RFX_LongBinary` вызов в `DoFieldExchange` вызов и увеличит общее число связанных полей.

Чтобы обновить значения столбцов большого объема данных, сначала убедитесь, что выделенное пространство `HGLOBAL` достаточно велико для хранения новых данных, вызвав **:: глобалсизе** на *m_hData* члене `CLongBinary` . Если он слишком мал, освободите `HGLOBAL` и выделите один из соответствующих размеров. Затем установите *m_dwDataLength* в соответствии с новым размером.

В противном случае, если *m_dwDataLength* больше размера заменяемых данных, можно освободить и перераспределить `HGLOBAL` , или оставить выделенным. Обязательно укажите число байтов, фактически используемых в *m_dwDataLength*.

## <a name="how-updating-a-clongbinary-works"></a>Как работает обновление CLongBinary

Не нужно понимать `CLongBinary` , как работает обновление, но может быть полезным в качестве примера отправки длинных значений данных в источник данных, если выбрать третий метод, описанный ниже.

> [!NOTE]
> Чтобы `CLongBinary` поле включалось в обновление, необходимо явным образом вызвать `SetFieldDirty` поле. При внесении каких-либо изменений в поле, в том числе при установке значения NULL, необходимо вызвать `SetFieldDirty` . Также необходимо вызвать `SetFieldNull` , а второй параметр — **false**, чтобы пометить поле как имеющее значение.

При обновлении `CLongBinary` поля классы баз данных используют механизм **DATA_AT_EXEC** ODBC (см. документацию по ODBC в `SQLSetPos` аргументе ргбвалуе). Когда платформа готовит инструкцию INSERT или Update, вместо того чтобы указывать на объект `HGLOBAL` , содержащий данные, *адрес* `CLongBinary` задается в качестве *значения* столбца, а индикатор длины устанавливается в значение **SQL_DATA_AT_EXEC**. Позже, когда инструкция UPDATE будет отправлена в источник данных, `SQLExecDirect` возвратит **SQL_NEED_DATA**. Это предупреждает платформу о том, что значение параметра для этого столбца фактически является адресом `CLongBinary` . Платформа вызывает `SQLGetData` один раз с небольшим буфером, ожидая, что драйвер возвращает фактическую длину данных. Если драйвер возвращает фактическую длину большого двоичного объекта (BLOB), MFC перераспределяет столько дискового пространства, сколько необходимо для выборки больших двоичных объектов. Если источник данных возвращает **SQL_NO_TOTAL**, указывающий, что он не может определить размер большого двоичного объекта, MFC создаст блоки меньшего размера. По умолчанию используется начальный размер 64 КБ, а последующие блоки будут иметь двойной размер. Например, вторым будет 128 КБ, третье — 256 КБ и т. д. Начальный размер можно настроить.

## <a name="not-binding-retrievingsending-data-directly-from-odbc-with-sqlgetdata"></a>Не привязка: извлечение и отправка данных непосредственно из ODBC с помощью SQLGetData

С помощью этого метода вы полностью обходите классы базы данных и можете самостоятельно работать с столбцом Long Data.

Преимущества:

При необходимости можно кэшировать данные на диск или выбрать динамическое количество получаемых данных.

Недостатки:

Вы не получаете платформу `Edit` или `AddNew` поддержку, и вам необходимо написать код самостоятельно для выполнения базовой функциональности (это `Delete` работает, так как это не операция уровня столбца).

В этом случае столбец данных Long должен находиться в списке выбора набора записей, но не должен быть привязан к платформе. Один из способов сделать это — предоставить собственную инструкцию SQL с помощью `GetDefaultSQL` или в качестве аргумента lpszSQL `CRecordset` `Open` , а не привязывать дополнительный столбец к вызову функции RFX_. ODBC требует, чтобы несвязанные поля появлялись справа от связанных полей, поэтому добавьте Непривязанный столбец или столбцы в конец списка выбора.

> [!NOTE]
> Поскольку столбец данных Long не привязан к платформе, изменения в нем не будут обрабатываться с помощью `CRecordset::Update` вызовов. Необходимо самостоятельно создать и отправить необходимые инструкции SQL **INSERT** и **Update** .

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
