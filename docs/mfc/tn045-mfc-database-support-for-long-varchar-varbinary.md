---
title: 'TN045: Поддержка MFC и баз данных Long Varchar и Varbinary'
ms.date: 11/04/2016
f1_keywords:
- vc.mfc.data
helpviewer_keywords:
- TN045
- Varbinary data type
- Varchar data type
ms.assetid: cf572c35-5275-45b5-83df-5f0e36114f40
ms.openlocfilehash: d356f094759775f709838de149769b1671fdf9ba
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57260118"
---
# <a name="tn045-mfcdatabase-support-for-long-varcharvarbinary"></a>TN045: Поддержка MFC и баз данных для типов Long Varchar и Varbinary

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает способ получения и отправки ODBC **SQL_LONGVARCHAR** и **SQL_LONGVARBINARY** типов данных с помощью MFC базы данных классов.

## <a name="overview-of-long-varcharvarbinary-support"></a>Общие сведения о поддержке Long Varchar и Varbinary

ODBC **SQL_LONG_VARCHAR** и **SQL_LONGBINARY** (Далее как длинные столбцы данных) типы данных могут содержать огромные объемы данных. Существует 3 способа, можно обрабатывать эти данные.

- Привяжите его к `CString` / `CByteArray`.

- Привяжите его к `CLongBinary`.

- Не привязать его вообще и извлечь и отправить данные большой длины значение вручную, зависит от классов базы данных.

Каждый из трех методов имеет преимущества и недостатки.

Столбцы данных большой длины не поддерживаются для параметров запроса. Они поддерживаются только для outputColumns.

## <a name="binding-a-long-data-column-to-a-cstringcbytearray"></a>Привязка данных большой длины столбца к CString/CByteArray

Преимущества:

Этот подход прост для понимания и работы с знакомые классы. Платформа предоставляет `CFormView` поддержка `CString` с `DDX_Text`. У вас есть множество общих функциональных возможностях строки или коллекции с `CString` и `CByteArray` классов и можно управлять объемом памяти, выделенной локально, для хранения значения данных. Платформа поддерживает старую копию данных поля во время `Edit` или `AddNew` вызовы функций и framework может автоматически обнаруживать изменения в данных для вас.

> [!NOTE]
>  Так как `CString` предназначен для работы в символьные данные и `CByteArray` для работы на двоичные данные, рекомендуется поместить символьных данных (**SQL_LONGVARCHAR**) в `CString`и двоичные данные ( **SQL_LONGVARBINARY**) в `CByteArray`.

Функции RFX для `CString` и `CByteArray` имеют дополнительный аргумент, который позволяет переопределить размер выделенной памяти для хранения извлеченных значения для столбца данных по умолчанию. Примечание nMaxLength аргумент в следующих объявлениях функций.

```
void AFXAPI RFX_Text(CFieldExchange* pFX,
    const char *szName,
    CString& value,
    int nMaxLength = 255,
    int nColumnType =
    SQL_VARCHAR);

void AFXAPI RFX_Binary(CFieldExchange* pFX,
    const char *szName,
    CByteArray& value,
    int nMaxLength = 255);
```

При получении данных большой длины столбца в `CString` или `CByteArray`, возвращается максимальный объем данных, по умолчанию, 255 байт. Все остальное это учитывается. В этом случае платформа вызовет исключение **AFX_SQL_ERROR_DATA_TRUNCATED**. К счастью, можно явным образом увеличить nMaxLength больше значения, до **MAXINT**.

> [!NOTE]
>  Значение nMaxLength используется классами MFC для задания локального буфера для `SQLBindColumn` функции. Это локального буфера для хранения данных и действительности не влияют на объем данных, возвращаемых драйвером ODBC. `RFX_Text` и `RFX_Binary` сделать только один вызов с использованием `SQLFetch` для получения данных из базы данных в серверной части. Драйверу ODBC имеет разные ограничение на объем данных, которые могут возвращать в одну операцию выборки. Это ограничение может быть намного меньше, чем значение nMaxLength, в этом случае исключение **AFX_SQL_ERROR_DATA_TRUNCATED** будет создано. В этих обстоятельствах перейти на использование `RFX_LongBinary` вместо `RFX_Text` или `RFX_Binary` , чтобы можно было получить все данные.

ClassWizard привяжет **SQL_LONGVARCHAR** для `CString`, или **SQL_LONGVARBINARY** для `CByteArray` для вас. Если вы хотите выделить более 255 байт, в которые получения длинных данных столбца, можно затем предоставить явное значение nMaxLength.

Когда данные большой длины столбец связан с `CString` или `CByteArray`, обновив поле работает практически так же, как при привязке к SQL_**VARCHAR** или SQL_**VARBINARY**. Во время `Edit`, значение кэшируется немедленно и более поздних версиях при сравнении `Update` вызывается для обнаружения изменения данных, значение и задайте Dirty и значения Null для столбца соответствующим образом.

## <a name="binding-a-long-data-column-to-a-clongbinary"></a>Привязка данных большой длины столбца к CLongBinary

Если данные большой длины столбца может содержать несколько **MAXINT** байтов данных, возможно, рассмотрите возможность извлечения его в `CLongBinary`.

Преимущества:

Это возвращает столбец всей данные большой длины до доступной памяти.

Недостатки:

Данные хранятся в памяти. Этот подход также является слишком высока для очень больших объемов данных. Необходимо вызвать `SetFieldDirty` для связанных данных члена, чтобы убедиться в поле включается в `Update` операции.

При получении данных большой длины столбцов в `CLongBinary`, классы баз данных будет проверить общий объем данных большой длины столбца, а затем выделить `HGLOBAL` сегмента памяти недостаточно велик для хранения его значения типа данных. Классы баз данных извлекают значения типа данных в этот выделенный `HGLOBAL`.

Если источник данных не возвращает ожидаемый размер столбца данных long, платформа вызовет исключение **AFX_SQL_ERROR_SQL_NO_TOTAL**. Если выделить `HGLOBAL` завершается ошибкой, создается стандартная памяти исключение.

ClassWizard привяжет **SQL_LONGVARCHAR** или **SQL_LONGVARBINARY** для `CLongBinary` для вас. Выберите `CLongBinary` как тип переменной, в диалоговом окне Добавление переменной-члена. Затем добавит ClassWizard `RFX_LongBinary` вызов вашей `DoFieldExchange` вызова и увеличить общее количество связанных полей.

Чтобы обновить длинные значения столбцов данных, сначала убедитесь, что выделенное `HGLOBAL` достаточно велик для хранения новых данных, вызвав **:: GlobalSize** на *m_hData* членом `CLongBinary`. Если он слишком мал, выпуск `HGLOBAL` и выделить один соответствующий размер. Затем установите *m_dwDataLength* в соответствии с новым размером.

В противном случае, если *m_dwDataLength* больше, чем размер данных, замене, может освободить и перераспределении `HGLOBAL`, или оставить его выделить. Убедитесь в том указать число байтов, фактически использовались в *m_dwDataLength*.

## <a name="how-updating-a-clongbinary-works"></a>Работает как обновление CLongBinary

Нет необходимости понять, как обновление `CLongBinary` работает, но его можно использовать в качестве примера о том, как отправлять данные большого к источнику данных, если выбран этот третий способ, описанных ниже.

> [!NOTE]
>  Чтобы `CLongBinary` поля должны быть включены в обновление, необходимо явно вызывать `SetFieldDirty` для поля. Если при внесении изменений в поле, включая задание значения Null, необходимо вызвать `SetFieldDirty`. Необходимо также вызвать `SetFieldNull`, второй параметр — **FALSE**, чтобы пометить поле как имеющие значение.

При обновлении `CLongBinary` поле, классы баз данных используйте ODBC **DATA_AT_EXEC** механизм (см. в разделе документации по ODBC на `SQLSetPos`в rgbValue аргумент). Когда платформа готовится инструкции insert или update, а не указывает на `HGLOBAL` данными, *адрес* из `CLongBinary` задается как *значение* столбца Вместо этого и признак длины, равным **значение SQL_DATA_AT_EXEC**. Позже, когда инструкция update отправляется к источнику данных, `SQLExecDirect` вернет **SQL_NEED_DATA**. Это предупреждение о структуре что param для этого столбца значение фактически адрес `CLongBinary`. Платформа вызывает `SQLGetData` один раз с небольшим буфером, ожидается драйвер возвращает фактическую длину данных. Если драйвер возвращает фактическую длину большой двоичный объект (BLOB), MFC перераспределяет столько же места, при необходимости для получения большого двоичного ОБЪЕКТА. Если источник данных возвращает **SQL_NO_TOTAL**, указывающее, что он не может определить размер большого двоичного ОБЪЕКТА, MFC создаст небольших блоков. Исходный размер по умолчанию составляет 64 КБ, а последующие блоки будут два раза больше; Например второй будет равен 128 КБ, третий — 256 КБ и т. д. Настраивается исходный размер.

## <a name="not-binding-retrievingsending-data-directly-from-odbc-with-sqlgetdata"></a>Не привязки: Получение или отправка данных непосредственно из ODBC с SQLGetData

С помощью этого метода вы полностью обойти классы баз данных и работать со столбцом данных большой длины.

Преимущества:

Можно кэшировать данные на диск при необходимости, или определить динамически объем данных для извлечения.

Недостатки:

Вы не получаете платформы `Edit` или `AddNew` поддержки и вам необходимо написать кода, чтобы выполнять основные функциональные возможности (`Delete` система работала, так как он не является операцией уровня столбца).

В этом случае столбец данные большого формата должны находиться в списке выбора набора записей, но не должны быть привязаны к платформой. Один из способов сделать это для предоставления собственных инструкций SQL с помощью `GetDefaultSQL` или как аргумент lpszSQL `CRecordset`в `Open` функцию и дополнительный столбец с помощью вызова функции RFX_ обеспечивает и привязку. ODBC требует, что несвязанный поля отображаются справа от связанных полей, поэтому добавьте несвязанного столбца или столбцов в конец списка выбора.

> [!NOTE]
>  Поскольку данные большой длины столбца не привязан платформой, изменения не будут обрабатываться с `CRecordset::Update` вызовов. Необходимо создать и отправить требуется SQL **вставить** и **обновления** инструкций самостоятельно.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
