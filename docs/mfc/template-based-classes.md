---
title: Классы на основе шаблонов
ms.date: 11/04/2016
helpviewer_keywords:
- type-safe collections
- CTypedPtrList class [MFC], template-based classes
- arrays [MFC], classes
- arrays [MFC], pointers
- typed pointers, collections of
- arrays [MFC], template-based
- CArray class [MFC], template-based classes
- simple template-based collections
- simple array collection classes [MFC]
- typed pointers
- collections, typed-pointer
- CList class [MFC], template-based classes
- collection classes [MFC], template-based
- CTypedPtrMap class [MFC], template-based classes
- pointers, collections of typed
- CTypedPtrArray class [MFC], template-based classes
- MFC collection classes [MFC], template-based
- template-based collection classes [MFC]
- simple list collection classes [MFC]
ms.assetid: c69fc95b-c8f6-4a99-abed-517c9898ef0c
ms.openlocfilehash: 40633c8b2b09d27e97443364ed3ce711ee217e18
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62306396"
---
# <a name="template-based-classes"></a>Классы на основе шаблонов

В этой статье объясняется классы типобезопасных коллекций, основанных на шаблонах MFC версии 3.0 и более поздних. С помощью этих шаблонов для создания строго типизированные коллекции является более удобным и помогает обеспечить безопасность типов, более эффективно, чем использование классов коллекции, не на основе шаблонов.

MFC предопределяет два типа коллекций на основе шаблона:

- [Простой массивов, списков и классы сопоставления](#_core_using_simple_array.2c_.list.2c_.and_map_templates)

   `CArray`, `CList`, `CMap`

- [Массивов, списков и схем типизированных указателей](#_core_using_typed.2d.pointer_collection_templates)

   `CTypedPtrArray`, `CTypedPtrList`, `CTypedPtrMap`

Простой коллекции классы являются производными от класса `CObject`, поэтому они наследуют сериализации, динамическое создание и другие свойства `CObject`. Требуют указания класс производным от классов коллекций типизированных указателей, который должен быть одной из коллекций нешаблонных указатель, предопределенных в MFC, такие как `CPtrList` или `CPtrArray`. Новый класс коллекции, наследует от указанного базового класса и функции-члены новый класс использовать инкапсулированный вызовы к членам базового класса для обеспечения безопасности типа.

Дополнительные сведения о шаблонах C++ см. в разделе [шаблоны](../cpp/templates-cpp.md) в *Справочник по языку C++*.

##  <a name="_core_using_simple_array.2c_.list.2c_.and_map_templates"></a> С помощью простого массива, списка и сопоставления шаблонов

Использование простой коллекции шаблонов, вы должны знать, какие данные можно хранить в этих коллекциях и параметры, используемые в объявлениях коллекции.

###  <a name="_core_simple_array_and_list_usage"></a> Простого массива и использование списка

Простого массива и классы списков [CArray](../mfc/reference/carray-class.md) и [CList](../mfc/reference/clist-class.md), принимают два параметра: *Тип* и `ARG_TYPE`. Эти классы можно хранить любой тип данных, которая задается в *тип* параметр:

- Типы основных данных C++, такие как **int**, **char**, и **число с плавающей запятой**

- Классы и структуры C++

- Другие типы, определяемые

Для удобства и эффективность, можно использовать *ARG_TYPE* параметр для указания типа аргументов функции. Обычно можно задать *ARG_TYPE* как ссылку на тип, имя которого задано в *ТИПА* параметра. Пример:

[!code-cpp[NVC_MFCCollections#1](../mfc/codesnippet/cpp/template-based-classes_1.cpp)]

В первом примере объявляется массив-коллекцию, `myArray`, который содержит **int**s. Во втором примере объявляется коллекции-списка, `myList`, хранящий `CPerson` объектов. Некоторые функции-члены классов коллекций принимают аргументы, тип которого определяется *ARG_TYPE* параметр шаблона. Например `Add` функция-член класса `CArray` принимает *ARG_TYPE* аргумент:

[!code-cpp[NVC_MFCCollections#2](../mfc/codesnippet/cpp/template-based-classes_2.cpp)]

###  <a name="_core_simple_map_usage"></a> Использование простой схемы

Класс простую карту [CMap](../mfc/reference/cmap-class.md), принимает четыре параметра: *КЛЮЧ*, *ARG_KEY*, *значение*, и *ARG_VALUE*. Как и классы array и list классы сопоставления можно хранить любые типы данных. В отличие от массивов и списков, которые можно индексировать и упорядочивания данных, которые они хранят, карт связывание ключи и значения: Доступ к значения, хранящегося в сопоставлении путем указания значения соответствующего ключа. *Ключ* параметр указывает тип данных ключи, используемые для доступа к данным на карте. Если тип *ключ* — это структура или класс, *ARG_KEY* параметр обычно является ссылкой на тип, заданный в *ключ*. *Значение* параметр указывает тип элементов, хранящихся в сопоставлении. Если тип *ARG_VALUE* — это структура или класс, *ARG_VALUE* параметр обычно является ссылкой на тип, заданный в *значение*. Пример:

[!code-cpp[NVC_MFCCollections#3](../mfc/codesnippet/cpp/template-based-classes_3.cpp)]

Первый пример сохраняет `MY_STRUCT` значений, получает доступ к ним по **int** ключи и получить доступ к возвращает `MY_STRUCT` элементы по ссылке. Второй пример сохраняет `CPerson` значений, получает доступ к ним по `CString` ключей и возвращает ссылки на использовавшихся элементов. В этом примере может представлять простой адресную книгу, в котором можно поиск менеджеров по фамилии в.

Так как *ключ* принадлежит к типу `CString` и *KEY_TYPE* принадлежит к типу `LPCSTR`, ключи хранятся в схеме как элементы типа `CString` , но на которые ссылается функции, такие как `SetAt` через указатели типа `LPCSTR`. Пример:

[!code-cpp[NVC_MFCCollections#4](../mfc/codesnippet/cpp/template-based-classes_4.cpp)]

##  <a name="_core_using_typed.2d.pointer_collection_templates"></a> С помощью шаблонов коллекции типизированных указателей

С помощью шаблонов коллекции типизированных указателей, вы должны знать, какие виды данных можно хранить в этих коллекциях и параметры, используемые в объявлениях коллекции.

###  <a name="_core_typed.2d.pointer_array_and_list_usage"></a> Массив типизированных указателей и использование списка

Массив типизированных указателей и классы списков [CTypedPtrArray](../mfc/reference/ctypedptrarray-class.md) и [CTypedPtrList](../mfc/reference/ctypedptrlist-class.md), принимают два параметра: *BASE_CLASS* и *тип*. Эти классы можно хранить любой тип данных, которая задается в *ТИПА* параметра. Они являются производными от одного из нешаблонных классов коллекций, которые хранит указатели; Укажите этот базовый класс в *BASE_CLASS*. Для массивов, использование `CObArray` или `CPtrArray`. Для списков используйте `CObList` или `CPtrList`.

По сути, скажем при объявлении в коллекции на основе `CObList`, не только в новый класс наследует члены базового класса, но он также объявляет ряд дополнительных типобезопасный член, функций и операторов, которые помогают обеспечить безопасность типов, инкапсулируя вызовы к членам базового класса. Эти межсетевые экраны управлять все необходимое преобразование типа. Пример:

[!code-cpp[NVC_MFCCollections#5](../mfc/codesnippet/cpp/template-based-classes_5.cpp)]

В первом примере объявляется массив типизированных указателей, `myArray`, который является производным от `CObArray`. Хранит массив и возвращает указатели на `CPerson` объектов (где `CPerson` является класс, производный от `CObject`). Можно вызывать любые `CObArray` функция-член, либо вызвать новый типобезопасный `GetAt` и `ElementAt` функции или используйте строго типизированным **[]** оператор.

Во втором примере объявляется список типизированных указателей, `myList`, который является производным от `CPtrList`. Хранит список и возвращает указатели на `MY_STRUCT` объектов. На основе класса `CPtrList` используется для хранения указателей на объекты, не являющиеся производными `CObject`. `CTypedPtrList` имеется ряд функций-членов типобезопасный: `GetHead`, `GetTail`, `RemoveHead`, `RemoveTail`, `GetNext`, `GetPrev`, и `GetAt`.

###  <a name="_core_typed.2d.pointer_map_usage"></a> Использование типизированных указателей карты

Класс map типизированных указателей, [CTypedPtrMap](../mfc/reference/ctypedptrmap-class.md), принимает три параметра: *BASE_CLASS*, *ключ*, и *значение*. *BASE_CLASS* параметр указывает класс, от которого новый класс: `CMapPtrToWord`, `CMapPtrToPtr`, `CMapStringToPtr`, `CMapWordToPtr`, `CMapStringToOb`, и т. д. *КЛЮЧ* является аналогом *ключ* в `CMap`: Указывает тип ключа, используемого для уточняющих запросов. *ЗНАЧЕНИЕ* является аналогом *значение* в `CMap`: Указывает тип объекта, который хранится в сопоставлении. Пример:

[!code-cpp[NVC_MFCCollections#6](../mfc/codesnippet/cpp/template-based-classes_6.cpp)]

Первый пример выполняется на основе карты `CMapPtrToPtr` — он использует `CString` клавиш, назначенных указатели на `MY_STRUCT`. Можно выполнять поиск сохраненного указателя, вызвав типобезопасную `Lookup` функция-член. Можно использовать **[]** оператор, чтобы найти сохраненный указатель и добавьте его, если не найден. Можно пройти сопоставления с помощью типобезопасного `GetNextAssoc` функции. Можно также вызвать другой член функции класса `CMapPtrToPtr`.

Во втором примере — это сопоставление, на основе `CMapStringToOb` — он использует ключи строка сопоставляется с хранимой указатели на `CMyObject` объектов. Вы можете использовать те же строго типизированные элементы, описанные в предыдущем абзаце, или можно вызывать члены класса `CMapStringToOb`.

> [!NOTE]
>  Если указать **класс** или **структуры** введите *значение* параметра, а не указатель или ссылку на тип класса или структуры, должен иметь конструктор копирования.

Дополнительные сведения см. в разделе [как осуществлять типобезопасных коллекций](../mfc/how-to-make-a-type-safe-collection.md).

## <a name="see-also"></a>См. также

[Коллекции](../mfc/collections.md)
