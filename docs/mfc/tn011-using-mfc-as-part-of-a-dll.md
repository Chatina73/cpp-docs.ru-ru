---
title: TN011. Использование MFC как часть библиотеки DLL
ms.date: 11/04/2016
helpviewer_keywords:
- _USRDLL symbol
- USRDLLs, compiler switches
- TN011
- DLLs [MFC], linking
- MFC DLLs [MFC], linking regular MFC DLLs to MFC
ms.assetid: 76753e9c-59dc-40f6-b6a7-f6bb9a7c4190
ms.openlocfilehash: 0f4d4e2ed76a0fa5f8f775345fc672a1df055a39
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370428"
---
# <a name="tn011-using-mfc-as-part-of-a-dll"></a>TN011. Использование MFC как часть библиотеки DLL

В этой заметке описаны регулярные DLL MFC, которые позволяют использовать библиотеку MFC как часть библиотеки динамических ссылок Windows (DLL). Предполагается, что вы знакомы с Windows DLLs и как их создавать. Для получения информации о расширении MFC DLL, с помощью [которого](../mfc/tn033-dll-version-of-mfc.md)можно создать расширения для библиотеки MFC, см.

## <a name="dll-interfaces"></a>Интерфейсы DLL

регулярные DLL MFC предполагают, что интерфейсы между приложением и DLL указаны в C-подобных функциях или явно экспортированных классах. Интерфейсы класса MFC не могут быть экспортированы.

Если и DLL, и приложение хотят использовать MFC, у обоих есть выбор: либо использовать общую версию библиотек MFC, либо статически ссылаться на копию библиотек. Приложение и DLL могут использовать одну из стандартных версий библиотеки MFC.

регулярные DLLs MFC имеют ряд преимуществ:

- Приложение, использующее DLL, не должно использовать MFC и не должно быть приложением Visual C.

- С регулярными MFC DLLs, которые статически ссылку на MFC, размер DLL зависит только от MFC и C время выполнения процедур, которые используются и связаны.

- С регулярными MFC DLLs, которые динамически ссылку на МФЦ, экономия памяти от использования общей версии МФЦ может быть значительным. Тем не менее, вы должны распространять\<общие DLLs,*версии* \<Mfc>.dll и версии Msvvcrt*version*>.dll, с вашим DLL.

- Дизайн DLL не зависит от того, как классы реализуются. Ваш dLL дизайн экспортирует только для AI вы хотите. В результате, если реализация изменяется, регулярные DLL MFC по-прежнему действительны.

- С регулярными MFC DLLs, которые статически ссылку на MFC, если и DLL и приложение использовать MFC, Есть никаких проблем с приложением, которое хочет другой версии MFC, чем DLL или наоборот. Поскольку библиотека MFC статически связана с каждой DLL или EXE, нет никаких сомнений в том, какая версия у вас есть.

## <a name="api-limitations"></a>Ограничения API

Некоторые функциональные возможности MFC не применяются к версии DLL либо из-за технических ограничений, либо из-за того, что эти услуги обычно предоставляются приложением. С текущей версией МФЦ, единственная `CWinApp::SetDialogBkColor`функция, которая не применима.

## <a name="building-your-dll"></a>Создание DLL

При составлении регулярных DLL MFC, которые `_USRDLL` статически ссылаются на МФЦ, символы и `_WINDLL` должны быть определены. Ваш DLL-код также должен быть составлен со следующими компиляторными переключателими:

- **/D_WINDLL** означает, что компиляция предназначена для DLL

- **/D_USRDLL** указывает, что вы строите регулярный MFC DLL

Необходимо также определить эти символы и использовать эти компиляторы при компиляции регулярных DLL MFC, которые динамически ссылаются на MFC. Кроме того, `_AFXDLL` символ должен быть определен, а код DLL должен быть составлен с:

- **/D_AFXDLL** указывает, что вы строите регулярный MFC DLL, который динамически ссылки на MFC

Интерфейсы (AIS) между приложением и DLL должны быть явно экспортированы. Мы рекомендуем определить, что ваши интерфейсы с низкой пропускной способностью, и использовать только C интерфейсы, если вы можете. Прямые интерфейсы C легче поддерживать, чем более сложные классы СЗ.

Поместите AA в отдельный заголовок, который может быть включен файлами C и C. Например, смотрите заголовок ScreenCap.h в примере [DLLScreenCap,](../overview/visual-cpp-samples.md) например, в примере можно ознакомиться с заголовком ScreenCap.h. Чтобы экспортировать свои функции, введите их в `EXPORTS` разделе файла определения модуля (. DEF) или `__declspec(dllexport)` включить в определения функции. Используйте `__declspec(dllimport)` для импорта этих функций в исполняемый клиент.

Вы должны добавить AFX_MANAGE_STATE макрос в начале всех экспортированных функций в регулярных DLL MFC, которые динамически связаны с MFC. Этот макрос устанавливает текущее состояние модуля к состоянию DLL. Чтобы использовать этот макрос, добавьте следующую строку кода к началу функций, экспортированных из DLL:

`AFX_MANAGE_STATE(AfxGetStaticModuleState( ))`

## <a name="winmain---dllmain"></a>Винмейн - > Длмейн

Библиотека MFC определяет стандартную точку входа Win32, `DllMain` которая инициализирует ваш объект [cWinApp](../mfc/reference/cwinapp-class.md) как в типичном приложении MFC. Поместите все Инициализации DLL в метод [InitInstance,](../mfc/reference/cwinapp-class.md#initinstance) как в типичном приложении MFC.

Обратите внимание, что механизм [CWinApp:Run](../mfc/reference/cwinapp-class.md#run) не применяется к DLL, так как приложение владеет основным насосом сообщения. Если ваш DLL отображает бесрежимные диалоги или имеет собственное окно основного кадра, основной насос сообщения приложения должен вызвать dLL-экспортируемую рутину, которая вызывает [CWinApp: :PreTranslateMessage.](../mfc/reference/cwinapp-class.md#pretranslatemessage)

Для использования этой функции можно ознакомиться с образцом DLLScreenCap.

Функция, `DllMain` предоставляемая MFC, вызовет [CWinApp::ExitInstance](../mfc/reference/cwinapp-class.md#exitinstance) метод вашего `CWinApp` класса, который получен до того, как DLL будет выгружен.

## <a name="linking-your-dll"></a>Связывание Вашего DLL

С регулярными MFC DLLs, которые статически ссылку на MFC, вы должны связать ваш DLL с Nafxcwd.lib или Nafxcw.lib и с версией C runtimes имени Libcmt.lib. Эти библиотеки предварительно построены и могут быть установлены, указав их при запуске установки Visual C.

## <a name="sample-code"></a>Пример кода

Полный образец программы MFC Advanced Concepts DLLScreenCap можно осмотреть. Несколько интересных вещей, чтобы отметить в этом примере являются следующими:

- Флаги компилятора DLL и флаги приложения различны.

- Линии связи и . ФАЙЛы DEF для DLL и файлы для приложения различны.

- Приложение, использующее DLL, не должно находиться в СЗ.

- Интерфейс между приложением и DLL является API, который может быть пригоден к удоведенкам C или C и экспортируется с помощью DLLScreenCap.def.

Следующий пример иллюстрирует API, который определяется в обычном MFC DLL, который статично связывается с MFC. В этом примере декларация заключена в `extern "C" { }` блок для пользователей СЗ. Это имеет ряд преимуществ. Во-первых, это делает ваши DLL-AIS пригодными для удовена клиентскими приложениями, не относясь к СЗЗ. Во-вторых, это уменьшает накладные расходы на DLL, поскольку mangling имени C'' не будет применяться к экспортируемому имени. Наконец, это упрощает явное добавление в . ФАЙЛ DEF (для экспорта по ординатору) без необходимости беспокоиться о том, что имя mangling.

```cpp
#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

struct TracerData
{
    BOOL bEnabled;
    UINT flags;
};

BOOL PromptTraceFlags(TracerData FAR* lpData);

#ifdef __cplusplus
}
#endif
```

Структуры, используемые API, не являются производными от классов MFC и определяются в заголовке API. Это уменьшает сложность интерфейса между DLL и приложением и делает DLL пригодным для удовена программами C.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
