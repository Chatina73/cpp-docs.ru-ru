---
title: Сокеты Windows. Использование сокетов с архивами
ms.date: 11/04/2016
helpviewer_keywords:
- Windows Sockets [MFC], archives
- sockets [MFC], with archives
- archives [MFC], and Windows Sockets
- CSocket class [MFC], programming model
ms.assetid: 17e71a99-a09e-4e1a-9fda-13d62805c824
ms.openlocfilehash: 55b4f9a5412c1447fe2b3bde10cb934b91abf008
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81359950"
---
# <a name="windows-sockets-using-sockets-with-archives"></a>Сокеты Windows. Использование сокетов с архивами

В этой статье описывается [модель программирования CSocket](#_core_the_csocket_programming_model). Класс [CSocket](../mfc/reference/csocket-class.md) поставляет поддержку розетки на более высоком уровне абстракции, чем класс [CAsyncSocket.](../mfc/reference/casyncsocket-class.md) `CSocket`использует версию протокола сериализации MFC для передачи данных на объект розетки и из нее через объект MFC [CArchive.](../mfc/reference/carchive-class.md) `CSocket`обеспечивает блокировку (при управлении фоновой обработкой `CArchive`сообщений Windows) и дает вам доступ к , который управляет многими аспектами связи, что вам придется делать самостоятельно, используя либо сырой API или класса. `CAsyncSocket`

> [!TIP]
> Вы можете `CSocket` использовать класс сам по себе, как более удобная `CAsyncSocket`версия `CSocket` , `CArchive` но простейшая модель программирования заключается в использовании с объектом.

Для получения дополнительной информации о том, как работает [Windows Sockets: How Sockets with Archives Work](../mfc/windows-sockets-how-sockets-with-archives-work.md)реализация розеток с архивами, см. Например, код, [см. Windows Розетки: Последовательность операций](../mfc/windows-sockets-sequence-of-operations.md) и [Windows розетки: Пример разъемов с использованием архивов.](../mfc/windows-sockets-example-of-sockets-using-archives.md) Для получения информации о некоторых функциональных возможностях, которые вы можете [Windows Sockets: Deriving from Socket Classes](../mfc/windows-sockets-deriving-from-socket-classes.md)получить, выражая свои собственные классы из классов розеток, см.

> [!NOTE]
> Если вы пишете клиентскую программу MFC для связи с установленными (не МФЦ) серверами, не отправляйте объекты C-класса через архив. Если сервер не является приложением MFC, которое понимает виды объектов, которые вы хотите отправить, он не сможет получать и десериализировать ваши объекты. Для соответствующих материалов на тему общения с приложениями, не входящих в МФЦ, также смотрите статью [Windows Sockets: Byte Ordering](../mfc/windows-sockets-byte-ordering.md).

## <a name="the-csocket-programming-model"></a><a name="_core_the_csocket_programming_model"></a>Модель программирования CSocket

Использование `CSocket` объекта предполагает создание и объединение нескольких объектов класса MFC. В общей процедуре ниже, каждый шаг принимается как серверной розетки и клиентском гнездо, за исключением шага 3, в котором каждый тип розетки требует различных действий.

> [!TIP]
> Во время выполнения, сервер приложение обычно начинает сначала быть готовым и "слушать", когда клиентское приложение ищет соединение. Если сервер не готов, когда клиент пытается подключиться, обычно требуется, чтобы пользовательское приложение попыталось подключиться позже.

#### <a name="to-set-up-communication-between-a-server-socket-and-a-client-socket"></a>Настройка связи между разъемом сервера и клиентской розеткой

1. Построить объект [CSocket.](../mfc/reference/csocket-class.md)

1. Используйте объект для создания основной ручки **SOCKET.**

   Для `CSocket` объекта клиента обычно следует использовать параметры по умолчанию для [создания,](../mfc/reference/casyncsocket-class.md#create)если только вам не нужна разъем для грамма данных. Для `CSocket` объекта сервера необходимо указать `Create` порт в вызове.

    > [!NOTE]
    >  `CArchive`не работает с разъемами datagram. Если вы хотите `CSocket` использовать для разъема datagram, вы должны `CAsyncSocket`использовать класс, как вы бы использовать, то есть, без архива. Поскольку данные являются ненадежными (не гарантируется прибытие и могут быть повторены или из последовательности), они не совместимы с сериализации через архив. Ожидается, что операция сериализации будет завершена надежно и последовательно. Если вы попытаетесь использовать `CSocket` объект `CArchive` для datagram, утверждение MFC не удается.

1. Если розетка является клиентом, позвоните [cAsyncSocket::Connect](../mfc/reference/casyncsocket-class.md#connect) для подключения объекта розетки к разъему сервера.

     -или-

   Если розетка является сервером, позвоните [cAsyncSocket::Слушайте,](../mfc/reference/casyncsocket-class.md#listen) чтобы начать прослушивание попыток подключения от клиента. После получения запроса на подключение, примите его, позвонив [cAsyncSocket::Accept](../mfc/reference/casyncsocket-class.md#accept).

    > [!NOTE]
    >  Функция `Accept` члена берет в качестве параметра ссылку на новый пустой `CSocket` объект. Вы должны построить этот `Accept`объект, прежде чем вы звоните. Если этот объект розетки выходит за рамки, соединение закрывается. Не вызывайте `Create` этот новый объект розетки.

1. Создайте объект [CSocketFile,](../mfc/reference/csocketfile-class.md) связывая `CSocket` объект с ним.

1. Создание объекта [CArchive](../mfc/reference/carchive-class.md) для загрузки (получения) или хранения (отправки) данных. Архив связан с `CSocketFile` объектом.

   Имейте в `CArchive` виду, что не работает с разъемами datagram.

1. Используйте `CArchive` объект для передачи данных между разъемами клиента и сервера.

   Имейте в виду, что данный `CArchive` объект перемещает данные только в одном направлении: либо для загрузки (получения), либо для хранения (отправки). В некоторых случаях вы `CArchive` будете использовать два объекта: один для отправки данных, другой для получения подтверждений.

   После принятия соединения и настройки архива можно выполнить такие задачи, как проверка паролей.

1. Уничтожьте архив, файл розетки и объекты розетки.

    > [!NOTE]
    >  Класс `CArchive` поставляет `IsBufferEmpty` функцию участника специально `CSocket`для использования с классом. Например, если буфер содержит несколько сообщений данных, необходимо циклизироваться до тех пор, пока все они не будут прочитаны и буфер не будет очищен. В противном случае следующее уведомление о том, что данные будут получены, может быть отложено на неопределенный срок. Используйте `IsBufferEmpty` для обеспечения того, чтобы вы извлекли все данные.

Статья [Windows Sockets: Sequence of Operations](../mfc/windows-sockets-sequence-of-operations.md) иллюстрирует обе стороны этого процесса примером кода.

Дополнительные сведения см. в разделе:

- [Сокеты Windows. Сокеты потоков](../mfc/windows-sockets-stream-sockets.md)

- [Сокеты Windows. Сокеты датаграмм](../mfc/windows-sockets-datagram-sockets.md)

## <a name="see-also"></a>См. также раздел

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)<br/>
[CSocket::Создание](../mfc/reference/csocket-class.md#create)
