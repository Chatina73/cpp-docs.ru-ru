---
title: Сокеты Windows. Использование сокетов с архивами
ms.date: 11/04/2016
helpviewer_keywords:
- Windows Sockets [MFC], archives
- sockets [MFC], with archives
- archives [MFC], and Windows Sockets
- CSocket class [MFC], programming model
ms.assetid: 17e71a99-a09e-4e1a-9fda-13d62805c824
ms.openlocfilehash: 71a7ed1f1b67bed157805328679a18ceabf201d3
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57261509"
---
# <a name="windows-sockets-using-sockets-with-archives"></a>Сокеты Windows. Использование сокетов с архивами

В этой статье описывается [модель программирования CSocket](#_core_the_csocket_programming_model). Класс [CSocket](../mfc/reference/csocket-class.md) предоставляет поддержку сокета на более высоком уровне абстракции, чем класс [CAsyncSocket](../mfc/reference/casyncsocket-class.md). `CSocket` использует версию протокола сериализации MFC для передачи данных из сокета объектом посредством MFC [CArchive](../mfc/reference/carchive-class.md) объекта. `CSocket` предоставляет блокировки (а также управляет фоновой обработки сообщений Windows) и дает доступ к `CArchive`, который управляет многими аспектами обмен данными, пришлось бы сделать самостоятельно с помощью необработанных API или класс `CAsyncSocket`.

> [!TIP]
>  Можно использовать класс `CSocket` сама по себе как более удобным версия `CAsyncSocket`, но самая простая модель программирования является использование `CSocket` с `CArchive` объекта.

Дополнительные сведения о том, как работает реализации сокетов с архивами, см. в разделе [сокеты Windows: Работа сокетов с архивами](../mfc/windows-sockets-how-sockets-with-archives-work.md). Пример кода, см. в разделе [сокеты Windows: Последовательность операций](../mfc/windows-sockets-sequence-of-operations.md) и [сокеты Windows: Пример сокетов с использованием архивов](../mfc/windows-sockets-example-of-sockets-using-archives.md). Сведения о некоторых функций можно получить путем наследования от классов сокета собственных классов, см. в разделе [сокеты Windows: Наследование от классов сокета](../mfc/windows-sockets-deriving-from-socket-classes.md).

> [!NOTE]
>  При написании программы MFC клиента для взаимодействия с серверами установленного (не MFC), не отправляйте объектов C++ с помощью архива. Не является приложение MFC, распознаваемые типы объектов, которые вы хотите отправить, он не будет возможность получения и десериализации объектов. Связанные материалы по вопросам взаимодействия с приложениями, не являющихся MFC также см. в статье [сокеты Windows: Порядок байтов](../mfc/windows-sockets-byte-ordering.md).

##  <a name="_core_the_csocket_programming_model"></a> Модель программирования CSocket

С помощью `CSocket` объект включает в себя, создании и связывании друг с другом несколько объектов классов MFC. В следующей процедуре общие каждый шаг принимается узлом сокета сервера и сокета клиента, за исключением шаг 3, в котором каждый тип сокета требуется другое действие.

> [!TIP]
>  Во время выполнения серверное приложение обычно начинает сначала быть готовы и «прослушивание», когда клиентское приложение ищет соединения. Если сервер не будет готово, когда клиент пытается подключиться, обычно требуется приложению пользователя, повторите попытку позже.

#### <a name="to-set-up-communication-between-a-server-socket-and-a-client-socket"></a>Настройка обмена данными между сокета сервера и сокета клиента

1. Создать [CSocket](../mfc/reference/csocket-class.md) объекта.

1. Использовать объект для создания базового **СОКЕТА** обработки.

   Для `CSocket` объекта клиента, обычно следует использовать параметры по умолчанию для [создать](../mfc/reference/casyncsocket-class.md#create), если вам не требуются сокета датаграмм. Для `CSocket` объект сервера, необходимо указать порт в `Create` вызова.

    > [!NOTE]
    >  `CArchive` не работает с сокеты датаграмм. Если вы хотите использовать `CSocket` для сокета датаграмм, так же, как необходимо использовать класс `CAsyncSocket`, то есть без архив. Поскольку датаграммы не гарантируется (не прибывают и повторно или не по порядку), они не совместимы с сериализацией через архив. Предполагается, что операция сериализации для завершения надежно и в последовательности. Если вы попытаетесь использовать `CSocket` с `CArchive` объекта датаграммы, ошибке утверждения MFC.

1. Если сокет клиента, вызовите [CAsyncSocket::Connect](../mfc/reference/casyncsocket-class.md#connect) для подключения к сокету сервера объект сокета.

     - или -

   Если сокет является сервером, вызовите [CAsyncSocket::Listen](../mfc/reference/casyncsocket-class.md#listen) чтобы начать прослушивать подключения от клиента. При получении запроса на подключение, примите его путем вызова [CAsyncSocket::Accept](../mfc/reference/casyncsocket-class.md#accept).

    > [!NOTE]
    >  `Accept` Функция-член принимает ссылку на новую, пустую `CSocket` объект в качестве параметра. Этот объект необходимо создать перед вызовом метода `Accept`. Если этот объект сокета выходит за пределы области, закрывает соединение. Не вызывайте `Create` для этого нового объекта сокета.

1. Создание [CSocketFile](../mfc/reference/csocketfile-class.md) объекта, связав `CSocket` объекта с ним.

1. Создание [CArchive](../mfc/reference/carchive-class.md) объект для загрузки (получение) или хранения данных (отправка). Архив, связанные с `CSocketFile` объекта.

   Имейте в виду, что `CArchive` не работает с сокеты датаграмм.

1. Используйте `CArchive` объект для передачи данных между клиентом и сервером сокетов.

   Имейте в виду, что заданный `CArchive` объект перемещает данные только в одном направлении: для загрузки (получение) или для хранения (отправка). В некоторых случаях будут использоваться два `CArchive` объектов: один для отправки данных, другой — для получения уведомления о доставке.

   После принятия запроса на подключение и настройка архива, можно выполнить такие задачи, как проверки паролей.

1. Уничтожить архива, файл сокетов и объекты сокета.

    > [!NOTE]
    >  Класс `CArchive` предоставляет `IsBufferEmpty` функция-член специально для использования с классом `CSocket`. Если буфер содержит несколько сообщений данных, к примеру, необходимо, пока все они доступны для чтения и буфер очищается. В противном случае ваши Далее уведомление о наличии получения данных неограниченное время с задержкой. Используйте `IsBufferEmpty` гарантировать, что можно получить все данные.

Статья [сокеты Windows: Последовательность операций](../mfc/windows-sockets-sequence-of-operations.md) иллюстрирует обе части этого процесса с примерами кода.

Дополнительные сведения:

- [Сокеты Windows. Сокеты Stream](../mfc/windows-sockets-stream-sockets.md)

- [Сокеты Windows. Сокеты датаграмм](../mfc/windows-sockets-datagram-sockets.md)

## <a name="see-also"></a>См. также

[Сокеты Windows в MFC](../mfc/windows-sockets-in-mfc.md)<br/>
[CSocket::Create](../mfc/reference/csocket-class.md#create)
