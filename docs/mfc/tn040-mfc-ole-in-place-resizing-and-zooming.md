---
title: 'TN040: MFC-OLE В-Место Изображивание и масштабирование'
ms.date: 11/04/2016
helpviewer_keywords:
- resizing in-place
- TN040
- zooming and in-place activation
- in-place activation, zooming and resizing
ms.assetid: 4d7859bd-0b2e-4254-be62-2735cecf02c6
ms.openlocfilehash: 65f9ef04c9740e8e6f0a8e72d9d6c39008198755
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81372163"
---
# <a name="tn040-mfcole-in-place-resizing-and-zooming"></a>TN040. Изменение размеров и масштабирование MFC/OLE по месту

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой заметке будут обсуждаться вопросы, связанные с редактированием на месте, и как сервер должен выполнять правильное масштабирование и реразмерное состояние на месте. С активацией на месте, концепция WYSIWYG сделана еще один шаг вперед в том, что контейнеры и серверы сотрудничают друг с другом, и, в частности, интерпретировать спецификацию OLE во многом таким же образом.

Из-за тесного взаимодействия между контейнером и сервером, поддерживающим активацию на месте, следует поддерживать ряд ожиданий от конечного пользователя:

- Дисплей презентации (метафайл, нарисованный в `COleServerItem::OnDraw` переизбытке) должен выглядеть точно так же, как при его рисовании для редактирования (за исключением того, что инструменты редактирования не видны).

- При увеличении контейнера окно сервера должно быть!

- Контейнер и сервер должны отображать объекты для редактирования с использованием одних и тех же метрик. Это означает использование картографии на основе количества *логических* пикселей на дюйм , а не физических пикселей на дюйм, при визуализации на дисплее устройства.

> [!NOTE]
> Поскольку активация на месте применяется только к элементам, которые встроены (не связаны), масштабирование применяется только к встроенным объектам. Вы увидите AIS `COleServerDoc` `COleServerItem` в обоих и которые используются для масштабирования. Причина этой дихотомии заключается в `COleServerItem` том, что в `COleServerDoc` классе находятся только функции, действительные как для связанных, так и для встроенных элементов (это позволяет иметь общую реализацию), а функции, действительные только для встроенных объектов, находятся в классе (с точки зрения сервера, это **встроенный документ).**

Большая часть нагрузки ложится на серверный реалистер, поскольку сервер должен быть в курсе фактора масштабирования контейнера и соответствующим образом изменять интерфейс редактирования. Но как сервер определяет фактор масштабирования, который использует контейнер

## <a name="mfc-support-for-zooming"></a>Поддержка MFC для масштабирования

Текущий коэффициент масштабирования можно `COleServerDoc::GetZoomFactor`определить по вызову. Вызов этого, когда документ не находится на месте активной всегда приводит к 100% коэффициент масштабирования (или 1:1 соотношение). Вызов его в то время как в месте активных может вернуть что-то другое, чем 100%.

Для примера правильного увеличения см. [HIERSVR](../overview/visual-cpp-samples.md) Масштабирование в HIERSVR осложняется тем, что он отображает текст, а текст, в общем-то, не масштабируется линейным образом (подсказки, типографские условности, ширина дизайна и высоты все усложняют дело). Тем не менее, HIERSVR является разумной ссылкой для реализации масштабирования правильно, и поэтому MFC Tutorial [SCRIBBLE](../overview/visual-cpp-samples.md) (шаг 7).

`COleServerDoc::GetZoomFactor`определяет коэффициент масштабирования на основе ряда различных метрик, доступных либо `COleServerItem` `COleServerDoc` из контейнера, либо из реализации вашего и классов. Короче говоря, текущий коэффициент масштабирования определяется следующей формулой:

```
Position Rectangle (PR) / Container Extent (CE)
```

POSITION RECTANGLE определяется контейнером. Он возвращается на сервер во время `COleClientItem::OnGetItemPosition` активации на месте, когда вызывается `COleServerDoc::OnSetItemRects` и обновляется, когда контейнер вызывает сервера (с `COleClientItem::SetItemRects`вызовом).

CONTAINER EXTENT немного сложнее для расчета. Если контейнер вызвал `COleServerItem::OnSetExtent` (с вызовом к), `COleClientItem::SetExtent`то CONTAINER EXTENT это значение преобразуется в пиксели в зависимости от количества пикселей на логический дюйм. Если контейнер не называется SetExtent (что, как правило, так), `COleServerItem::OnGetExtent`то CONTAINER EXTENT является размер вернулся из . Таким образом, если контейнер не называется SetExtent, фреймворк предполагает, что если бы он сделал контейнер `COleServerItem::GetExtent`назвал бы его со 100% естественной степени (значение возвращается из ). Заявленный другим способом, фреймворк предполагает, что контейнер отображает 100% (не больше, не меньше) элемента.

Важно отметить, что, `COleServerItem::OnSetExtent` `COleServerItem::OnGetExtent` хотя и имеют похожие имена, они не манипулируют одним и тем же атрибутом элемента. `OnSetExtent`называется, чтобы сервер знал, сколько объекта отображается в контейнере (независимо `OnGetExtent` от фактора масштабирования) и вызывается контейнером для определения идеального размера объекта.

Посмотрев на каждый из AIS участие, вы можете получить более четкое представление:

## <a name="coleserveritemongetextent"></a>ColeServeritem::Ongetextent

Эта функция должна вернуть "естественный размер" в HIMETRIC единиц элемента. Лучший способ думать о "естественный размер" заключается в том, чтобы определить его как размер может появиться при печати. Возвращается размер для конкретного содержимого элемента (так же, как метафайл, который является постоянным для конкретного элемента). Этот размер не изменяется при нанесении масштабирования на элемент. Обычно он не меняется, когда контейнер дает элементу более или менее место, позвонив. `OnSetExtent` Примером изменения может служить простой текстовый редактор без возможности "маржинальный", который заворачивает текст на основе последней степени, отправленной контейнером. Если сервер действительно изменяется, серверу, вероятно, следует установить OLEMISC_RECOMPOSEONRESIZE бит в системном реестре (см. документацию OLE SDK для получения дополнительной информации об этой опции).

## <a name="coleserveritemonsetextent"></a>ColeServeritem::Onsetextent

Эта функция вызывается, когда контейнер показывает "более или менее" объекта. Большинство контейнеров не будет называть это вообще. Реализация по умолчанию хранит последнее значение, полученное из `COleServerDoc::GetZoomFactor` контейнера в "m_sizeExtent", которое используется при вычислении описанного выше значения CONTAINER EXTENT.

## <a name="coleserverdoconsetitemrects"></a>ColeServerDoc::OnSetItemRects

Эта функция вызывается только тогда, когда документ находится в месте действия. Он вызывается, когда контейнер обновляет положение элемента или отсечение, примененное к элементу. POSITION RECTANGLE, как уже говорилось выше, обеспечивает числовый расчет фактора масштабирования. Сервер может запросить изменение позиции элемента, позвонив по телефону `COleServerDoc::RequestPositionChange`. Контейнер может или не может ответить `OnSetItemRects` на этот `COleServerItem::SetItemRects`запрос, позвонив (с вызовом).

## <a name="coleserverdocondraw"></a>ColeServerDoc::OnDraw

Важно понимать, что метафайл, созданный путем переопределения `COleServerItem::OnDraw` производит точно такой же метафайл, независимо от текущего фактора масштабирования. Контейнер будет масштабировать метафайл по мере необходимости. Это важное различие между представлением `OnDraw` и элементом `OnDraw`сервера. Представление обрабатывает масштабирование, элемент просто создает *масштабируемый* метафайл и оставляет его до контейнера, чтобы сделать соответствующее масштабирование.

Лучший способ гарантировать, что ваш сервер ведет себя правильно, `COleServerDoc::GetZoomFactor` это использовать реализацию, если ваш документ находится на месте активной.

## <a name="mfc-support-for-in-place-resizing"></a>Поддержка MFC для реразмерного размера в местах

MFC полностью реализует интерфейс изменения размера, как описано в спецификации OLE 2. Пользовательский интерфейс поддерживается `COleResizeBar` классом, пользовательским сообщением WM_SIZECHILD и `COleIPFrameWnd`специальной обработкой этого сообщения в.

Возможно, вы захотите реализовать иную обработку этого сообщения, чем та, которая предусмотрена инфраструктурой. Как описано выше, фреймворк оставляет результаты изменения размера на месте до контейнера - сервер реагирует на изменение фактора масштабирования. Если контейнер реагирует, установив как CONTAINER EXTENT, так и POSITION `COleClientItem::OnChangeItemPosition` RECTANGLE во время `COleServerDoc::RequestPositionChange`обработки его (называемого в результате вызова к ), то в месте изгабаритных приведет к показу "более или менее" элемента в окне редактирования. Если контейнер реагирует, просто установив POSITION RECTANGLE `COleClientItem::OnChangeItemPosition`во время обработки, коэффициент масштабирования изменится, и элемент будет показан "увеличенный или выходящий".

Сервер может контролировать (в некоторой степени), что происходит во время этих переговоров. Например, электронная таблица может выбрать для отобрагивания большего или меньшего количества ячеек при изобрачив окно при редактировании элемента на месте. Текстовый процессор может избрать изменить "страницы поля", чтобы они были такими же, как окно и перевернуть текст на новую маржу. Серверы реализуют это, изменяя `COleServerItem::OnGetExtent`естественный размер (размер, возвращенный из) при изменении размера. Это приведет к изменению как POSITION RECTANGLE, так и CONTAINER EXTENT на одну и ту же сумму, что приведет к тому же фактору масштабирования, но больше или меньше области просмотра. Кроме того, более или менее документ будет виден в `OnDraw`метафайле, генерируемом . В этом случае сам документ изменяется, когда пользователь изменяет размер элемента, а не только область просмотра.

Можно реализовать пользовательское изменения размера и при `COleResizeBar` этом использовать пользовательский интерфейс, предоставляемый путем переопределения WM_SIZECHILD сообщения в вашем `COleIPFrameWnd` классе. Для получения дополнительной информации о специфике WM_SIZECHILD [см.](../mfc/tn024-mfc-defined-messages-and-resources.md)

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
