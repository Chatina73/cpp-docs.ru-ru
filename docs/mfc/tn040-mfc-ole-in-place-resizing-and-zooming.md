---
description: 'Дополнительные сведения о: TN040: MFC/OLE In-Place изменение размера и масштабирование'
title: 'TN040: MFC-OLE In-Place изменение размера и масштабирование'
ms.date: 11/04/2016
helpviewer_keywords:
- resizing in-place
- TN040
- zooming and in-place activation
- in-place activation, zooming and resizing
ms.assetid: 4d7859bd-0b2e-4254-be62-2735cecf02c6
ms.openlocfilehash: e21b70dc10ee467f94386880255287218a3b6e99
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97215395"
---
# <a name="tn040-mfcole-in-place-resizing-and-zooming"></a>TN040. Изменение размеров и масштабирование MFC/OLE по месту

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этом примечании обсуждаются вопросы, связанные с редактированием на месте, а также объясняется, как сервер должен выполнить правильное масштабирование и изменение размера на месте. При использовании встроенной активации Концепция WYSIWYG принимает один шаг дальше в этом контейнерах и серверах взаимодействуют друг с другом, а в частности, в конкретной интерпретации спецификации OLE аналогичным образом.

Из-за взаимодействия между контейнером и сервером, поддерживающим активацию на месте, существует ряд ожидаемых конечных пользователей.

- Отображение презентации (метафайл, отображаемый в `COleServerItem::OnDraw` переопределении) должен выглядеть точно так же, как при его прорисовке (за исключением того, что средства редактирования не видны).

- При уменьшении размера контейнера окно сервера должно быть слишком большим.

- Как контейнер, так и сервер должны отображать объекты для редактирования с помощью одних и тех же метрик. Это означает использование режима сопоставления на основе числа *логических* пикселей на дюйм, а не физических точек на дюйм при отрисовке на устройстве отображения.

> [!NOTE]
> Поскольку активация на месте применяется только к элементам, которые являются встроенными (не связаны), то масштаб применяется только к внедренным объектам. Вы увидите интерфейсы API `COleServerDoc` и `COleServerItem` , которые используются для масштабирования. Причина этого дичотоми в том, что только функции, которые являются допустимыми для связанных и внедренных элементов, входят в `COleServerItem` (это позволяет реализовать общую реализацию) и функции, допустимые только для внедренных объектов, находятся в `COleServerDoc` классе (с точки зрения сервера это внедренный **документ** ).

Большая часть нагрузки размещается на сервере-исполнителе, в том, что сервер должен знать масштабный коэффициент контейнера и при необходимости изменить его интерфейс редактирования. Но как сервер определяет коэффициент масштабирования, который использует контейнер

## <a name="mfc-support-for-zooming"></a>Поддержка масштабирования в MFC

Текущий коэффициент масштабирования можно определить с помощью вызова метода `COleServerDoc::GetZoomFactor` . Вызов этого метода в случае, если документ не находится в активном месте, всегда приводит к значению коэффициента масштабирования 100% (или соотношения 1:1). Вызов метода во время активности на месте может вернуть нечто, отличное от 100%.

Пример правильного масштабирования см. в разделе пример MFC OLE [HIERSVR](../overview/visual-cpp-samples.md). Увеличение в HIERSVR осложняется тем, что в нем отображается текст, а текст в целом не масштабируется в линейном режиме (указания, типографские соглашения, ширина и высота структуры, все усложняется). Тем не менее, HIERSVR является разумной ссылкой для правильной реализации масштабирования, поэтому [в учебнике](../overview/visual-cpp-samples.md) по MFC используется план (шаг 7).

`COleServerDoc::GetZoomFactor` Определяет коэффициент масштабирования на основе ряда различных метрик, доступных из контейнера или из реализации `COleServerItem` `COleServerDoc` классов и. Вкратце, текущий коэффициент масштабирования определяется следующей формулой:

```
Position Rectangle (PR) / Container Extent (CE)
```

ПРЯМОУГОЛЬНИК расположения определяется контейнером. Он возвращается серверу во время активации на месте, когда `COleClientItem::OnGetItemPosition` вызывается и обновляется, когда контейнер вызывает сервер `COleServerDoc::OnSetItemRects` (с вызовом `COleClientItem::SetItemRects` ).

ОБЛАСТЬ контейнера немного сложнее для вычисления. Если контейнер вызывается `COleServerItem::OnSetExtent` (с вызовом `COleClientItem::SetExtent` ), экстент контейнера представляет это значение в пикселях в зависимости от числа пикселов на логический дюйм. Если контейнер не назывался Сетекстент (обычно это), то ЭКСТЕНТом контейнера является размер, возвращенный из `COleServerItem::OnGetExtent` . Таким образом, если контейнер не вызывал Сетекстент, платформа предполагает, что если бы контейнер вызывал его с 100% от естественного экстента (значение, возвращаемое из `COleServerItem::GetExtent` ). Другими словами, платформа предполагает, что в контейнере отображается 100% (нет ничего, не меньше) элемента.

Важно отметить, что хотя `COleServerItem::OnSetExtent` и `COleServerItem::OnGetExtent` имеют похожие имена, они не управляют одним и тем же атрибутом элемента. `OnSetExtent` метод вызывается, чтобы позволить серверу определить, какая часть объекта видна в контейнере (независимо от коэффициента масштабирования) и `OnGetExtent` вызывается контейнером для определения идеального размера объекта.

Взглянув на каждый из используемых API, можно получить более четкое изображение:

## <a name="coleserveritemongetextent"></a>COleServerItem:: OnGetExtent

Эта функция должна возвращать "натуральный размер" в единицах HIMETRIC элемента. Лучший способ представить «естественный размер» — определить его как размер, который может выглядеть при печати. Возвращаемый размер является константой для определенного содержимого элемента (подобно метафайлу, который является константой для конкретного элемента). Этот размер не изменяется, когда к элементу применяется изменение масштаба. Обычно он не изменяется, когда контейнер предоставляет элементу больше или меньше пространства путем вызова `OnSetExtent` . Примером изменения может быть простой текстовый редактор без возможности «Margin», который переносит текст на основе последнего экстента, отправленного контейнером. Если сервер изменится, то, скорее всего, сервер должен установить бит OLEMISC_RECOMPOSEONRESIZE в системном реестре (Дополнительные сведения об этом параметре см. в документации по пакету SDK для OLE).

## <a name="coleserveritemonsetextent"></a>COleServerItem:: Онсетекстент

Эта функция вызывается, когда контейнер показывает "больше или меньше" объекта. Большинство контейнеров не будут вызывать этот метод вообще. Реализация по умолчанию сохраняет последнее значение, полученное из контейнера в "m_sizeExtent", которое используется в `COleServerDoc::GetZoomFactor` при вычислении значения экстента контейнера, описанного выше.

## <a name="coleserverdoconsetitemrects"></a>Колесервердок:: Онсетитемректс

Эта функция вызывается только в том случае, если документ находится в активном месте. Он вызывается, когда контейнер обновляет либо позицию элемента, либо обрезку, примененную к элементу. ПРЯМОУГОЛЬНИК расположения, как описано выше, предоставляет числитель для вычисления коэффициента масштабирования. Сервер может запросить изменение позиции элемента путем вызова метода `COleServerDoc::RequestPositionChange` . Контейнер может или не отвечать на этот запрос путем вызова `OnSetItemRects` (с вызовом `COleServerItem::SetItemRects` ).

## <a name="coleserverdocondraw"></a>Колесервердок:: OnDraw

Важно понимать, что метафайл, созданный при переопределении, `COleServerItem::OnDraw` создает точно такой же метафайл, независимо от текущего коэффициента масштабирования. Контейнер будет масштабировать метафайл соответствующим образом. Это важное различие между представлением `OnDraw` и элементом сервера `OnDraw` . При изменении размера дескрипторов представления элемент просто создает метафайл *масштабируемый* и оставляет его в контейнере для соответствующего масштабирования.

Лучший способ убедиться, что сервер работает правильно, — использовать реализацию, `COleServerDoc::GetZoomFactor` Если документ находится в активном месте.

## <a name="mfc-support-for-in-place-resizing"></a>Поддержка MFC для изменения размера In-Place

MFC полностью реализует интерфейс изменения размера на месте, как описано в спецификации OLE 2. Пользовательский интерфейс поддерживается `COleResizeBar` классом, настраиваемым сообщением WM_SIZECHILD и специальной обработкой этого сообщения в `COleIPFrameWnd` .

Может потребоваться реализовать другую обработку этого сообщения по сравнению с предоставляемыми платформой. Как описано выше, платформа оставляет результаты изменения размера на месте в контейнере — сервер отвечает на изменение масштаба. Если контейнер переведет себя, установив как ЭКСТЕНТ контейнера, так и прямоугольник позиции во время обработки его `COleClientItem::OnChangeItemPosition` (вызываемого в результате вызова `COleServerDoc::RequestPositionChange` ), изменение размера на месте приведет к тому, что элемент будет отображаться в окне редактирования как "больше или меньше". Если контейнер передается, просто настроив прямоугольник позиции во время обработки `COleClientItem::OnChangeItemPosition` , коэффициент масштабирования изменится, и элемент будет отображаться как «уменьшено или мельче».

Сервер может контролировать (в некоторой степени) то, что происходит во время этого согласования. Например, электронная таблица может показывать больше или меньше ячеек, когда пользователь изменяет размер окна при редактировании элемента на месте. Текстовый процессор может изменить «поля страницы», чтобы они совпадали с окном и переносить текст в новое поле. Серверы реализуют это путем изменения естественного экстента (размер, возвращенный из `COleServerItem::OnGetExtent` ) при изменении размера. Это приведет к изменению ПРЯМОУГОЛЬНИКа расположения и ЭКСТЕНТа контейнера на один и тот же объем, что приведет к тому же масштабу, но к области просмотра большего или меньшего размера. Кроме того, в метафайле, созданном, будет отображаться больше или меньше документа `OnDraw` . В этом случае сам документ изменяется, когда пользователь изменяет размер элемента, а не только область просмотра.

Можно реализовать пользовательское изменение размера и по-прежнему использовать пользовательский интерфейс, предоставляемый путем `COleResizeBar` переопределения WM_SIZECHILD сообщения в `COleIPFrameWnd` классе. Дополнительные сведения об особенностях WM_SIZECHILD см. в [техническом примечании 24](../mfc/tn024-mfc-defined-messages-and-resources.md).

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
