---
title: 'TN040: Изменение размеров по месту MFC-OLE и масштабирование'
ms.date: 11/04/2016
f1_keywords:
- vc.mfc.ole
helpviewer_keywords:
- resizing in-place
- TN040
- zooming and in-place activation
- in-place activation, zooming and resizing
ms.assetid: 4d7859bd-0b2e-4254-be62-2735cecf02c6
ms.openlocfilehash: c2cb25388184ac969bec7c01d8077a458c03a03a
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "58775287"
---
# <a name="tn040-mfcole-in-place-resizing-and-zooming"></a>TN040: Изменение размеров по месту MFC/OLE и масштабирование

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка будут рассмотрены вопросы, относящиеся к редактирование на месте и как сервер необходимо добиться правильного масштабирования и изменения размера на месте. С помощью встроенной активации WYSIWYG концепции берется один шаг вперед в контейнерах, и серверы взаимодействовать друг с другом и в частности интерпретировать спецификации OLE во многом так же, как.

Из-за тесного общения между контейнером и сервер, поддерживающий встроенной активации существует ряд из конечного пользователя, которое должно сохраняться, ожидаемых от:

- Отображение представления (метафайла, содержащейся в `COleServerItem::OnDraw` переопределить) должно выглядеть точно так же, как его рисованием для редактирования (за исключением того, что средства редактирования не отображаются).

- Когда контейнер увеличивает, окне сервера следует слишком!

- Отображать объекты для редактирования, используя те же метрики сервера и контейнера. Это означает, что с помощью режима сопоставления, в зависимости от числа *логических* пикселей на дюйм, не физических пикселей на дюйм, при подготовке к просмотру на устройстве отображения.

> [!NOTE]
>  Так как встроенной активации применяется только к элементам, которые внедряются (не связанные), масштабирование применяется только к внедренные объекты. Вы увидите API-интерфейсы в обеих `COleServerDoc` и `COleServerItem` , которые используются для масштабирования. Для этого описанная дихотомия происходит потому что только те функции, которые являются допустимыми для связанных и внедренных элементов в `COleServerItem` (Это позволяет иметь общую реализацию) и функций, которые доступны только для внедренные объекты находятся в папке `COleServerDoc` класс (с точки зрения сервера, это **документа** которого внедрен).

Большую часть нагрузки помещается в реализации сервера, в том, что сервер должен учитывать коэффициент масштабирования контейнера и его интерфейс редактирования соответствующим образом изменить. Но как сервер определяет, значения масштаба, используя контейнер

## <a name="mfc-support-for-zooming"></a>Поддержка MFC для масштабирования

Текущий коэффициент масштабирования можно определить путем вызова `COleServerDoc::GetZoomFactor`. При вызове этой функции при документ не является активным на месте приведет к всегда в масштабе 100% фактор (или соотношение 1:1). Вызов ее, когда активный на месте могут возвращать что-то отличного от 100%.

Пример масштабирования правильно см. Пример MFC OLE [HIERSVR](../overview/visual-cpp-samples.md). Увеличение HIERSVR усложняется тем фактом, что отображается текст, и текст, в общем случае не подходит в линейном порядке (подсказки, обозначения, проектирования ширины и высоты усложнить заключается в). Тем не менее, HIERSVR является разумным ссылку для реализации масштабирования правильно, и в учебнике MFC [SCRIBBLE](../overview/visual-cpp-samples.md) (шаг 7).

`COleServerDoc::GetZoomFactor` Определяет значения масштаба на основе количества различных метрик, доступных из контейнера или от реализации вашей `COleServerItem` и `COleServerDoc` классы. Короче говоря текущий коэффициент масштабирования определяется по следующей формуле:

```
Position Rectangle (PR) / Container Extent (CE)
```

ПОЗИЦИЯ ПРЯМОУГОЛЬНИКА определяется контейнера. Он возвращается на сервер во время активации на месте при `COleClientItem::OnGetItemPosition` вызывается и обновляется, когда контейнер вызывает сервера `COleServerDoc::OnSetItemRects` (с помощью вызова `COleClientItem::SetItemRects`).

ЭКСТЕНТ КОНТЕЙНЕРА немного более сложна, для которого требуется вычислить. Если контейнер называется `COleServerItem::OnSetExtent` (с помощью вызова `COleClientItem::SetExtent`), то ЭКСТЕНТ КОНТЕЙНЕР — это значение, преобразуются в пиксели на основе числа пикселей на логический дюйм по оси. Если контейнер не вызван SetExtent (это обычно в случае), то ЭКСТЕНТ КОНТЕЙНЕР размером, возвращенным из `COleServerItem::OnGetExtent`. Таким образом, если контейнер не вызван SetExtent, framework предполагает, что если было контейнера бы назвал его со 100% области естественным (значение, возвращаемое из `COleServerItem::GetExtent`). Другим способом, указанным framework предполагает, что контейнер отображает 100% (не более того, не меньше) элемента.

Важно отметить, что хотя `COleServerItem::OnSetExtent` и `COleServerItem::OnGetExtent` имеют одинаковые имена, они не управляют тот же атрибут элемента. `OnSetExtent` вызывается, чтобы разрешить серверу знать, какой объем объект является видимым в контейнере (вне зависимости от значения масштаба) и `OnGetExtent` вызывается контейнером для определения идеального размера объекта.

Взглянув на каждый из используемых API, вы можете получить более четкую картину:

## <a name="coleserveritemongetextent"></a>COleServerItem::OnGetExtent

Эта функция должна возвращать «размеру» в HIMETRIC единиц товара. Лучший способ представить «размеру» является определение его как размер, он может отображаться при печати. Размер, возвращаемый здесь является константой для определенного элемента содержимое (наподобие метафайл, который является константой для определенного элемента). Этот размер не изменяется, когда масштабирование применяется к элементу. Он обычно не меняется при ему элемент более или менее пространство путем вызова `OnSetExtent`. Пример изменения может быть простым текстовым редактором, с помощью отсутствует возможность «margin», текст, основанный на последнюю область, отправленных в контейнер в оболочку. Если изменить сервер, сервер, возможно, следует задать OLEMISC_RECOMPOSEONRESIZE бит в системном реестре (см. в документации OLE SDK, Дополнительные сведения об этом параметре).

## <a name="coleserveritemonsetextent"></a>COleServerItem::OnSetExtent

Эта функция вызывается, когда «больше или меньше» объекта отображается контейнер. Большинство контейнеров будет вызывает его вообще. Реализация по умолчанию сохраняет последнее значение, полученное из контейнера в «m_sizeExtent», который используется в `COleServerDoc::GetZoomFactor` при вычислении значение СТЕПЕНИ КОНТЕЙНЕРА, описанных выше.

## <a name="coleserverdoconsetitemrects"></a>COleServerDoc::OnSetItemRects

Эта функция вызывается только в том случае, если документ является активным на месте. Он вызывается, когда контейнер обновляет расположением элемента или обрезки, применяемый к элементам. ПРЯМОУГОЛЬНИК ПОЗИЦИИ, как было описано выше, предоставляет числитель для расчета коэффициента масштабирования. Сервер может запросить изменить положение элемента, вызвав `COleServerDoc::RequestPositionChange`. Контейнер может или не может ответить на него, вызвав `OnSetItemRects` (с помощью вызова `COleServerItem::SetItemRects`).

## <a name="coleserverdocondraw"></a>COleServerDoc::OnDraw

Важно понимать, что метафайла созданных переопределение `COleServerItem::OnDraw` создает точно тем же метафайл, независимо от того, текущий коэффициент масштабирования. Контейнер будет масштабироваться метафайла соответствующим образом. Это важное различие между представлением `OnDraw` и элементом сервера `OnDraw`. Элемент представления дескрипторов масштабирование, просто создает *масштабируемым* метафайла и оставляет его к контейнеру сделать соответствующие изменение масштаба.

Лучший способ убедиться, что сервер работает правильно, — использовать реализацию `COleServerDoc::GetZoomFactor` Если документ является активным на месте.

## <a name="mfc-support-for-in-place-resizing"></a>Поддержка MFC для изменения размера на месте

MFC полностью реализует интерфейс изменения размера на месте, как описано в спецификации OLE 2. Пользовательский интерфейс поддерживается `COleResizeBar` класс, пользовательское сообщение WM_SIZECHILD и специальной обработки этого сообщения в `COleIPFrameWnd`.

Вы можете реализовать различной обработки этого сообщения, чем доступно платформой. Как описано выше, платформа оставляет результаты изменения размера на месте, к контейнеру, сервер отвечает на изменение значения масштаба. Если контейнер реагирует оба КОНТЕЙНЕРА ЭКСТЕНТА и ПРЯМОУГОЛЬНИК ПОЗИЦИИ во время обработки его `COleClientItem::OnChangeItemPosition` (вызывается в результате обращения к `COleServerDoc::RequestPositionChange`), а затем изменения размера на месте будет привести к отображению «больше или меньше» элемента в редактирования окно. Если контейнер реагирует, просто задав ПРЯМОУГОЛЬНИК ПОЗИЦИИ во время обработки `COleClientItem::OnChangeItemPosition`, приведет к изменению значения масштаба и элемент будет отображаться «увеличении и уменьшении out.»

Сервер можно управлять (до некоторой степени), что происходит в процессе согласования. Например, электронной таблице, могут выбрать для отображения количества ячеек при изменении размера окна во время редактирования элемента на месте. Текстовых процессоров, могут выбрать Изменение «полей страницы», чтобы они отличаются от окна и повторно упаковывать текст до нового поля. Серверы реализовать это, изменив естественным экстента (размером, возвращенным из `COleServerItem::OnGetExtent`) после завершения изменения размера. В результате ПРЯМОУГОЛЬНИК ПОЗИЦИЮ и ЭКСТЕНТ КОНТЕЙНЕР для изменения на величину, приводит к же коэффициент масштабирования, но больше или меньше области просмотра. Кроме того, больше или меньше документа будет отображаться в метафайл, создаваемые `OnDraw`. В этом случае сам документ изменяется при изменении размера элемента, а не просто области просмотра.

Можно реализовать пользовательские изменения размеров и по-прежнему использовать пользовательский интерфейс, предоставляемый `COleResizeBar` путем переопределения WM_SIZECHILD сообщение в ваш `COleIPFrameWnd` класса. Дополнительные сведения об особенностях WM_SIZECHILD см. в разделе [техническом примечании 24](../mfc/tn024-mfc-defined-messages-and-resources.md).

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
