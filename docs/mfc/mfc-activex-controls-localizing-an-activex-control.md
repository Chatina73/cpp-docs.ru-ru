---
title: Элементы управления ActiveX в MFC. Локализация элемента управления ActiveX
ms.date: 09/12/2018
f1_keywords:
- LocaleID
- AfxOleRegisterTypeLib
helpviewer_keywords:
- localization, ActiveX controls
- MFC ActiveX controls [MFC], localizing
- LocaleID ambient property [MFC]
- LOCALIZE sample [MFC]
ms.assetid: a44b839a-c652-4ec5-b824-04392708a5f9
ms.openlocfilehash: a85ec5cbed797b756afd93cd8423c58d138a0625
ms.sourcegitcommit: c21b05042debc97d14875e019ee9d698691ffc0b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84615426"
---
# <a name="mfc-activex-controls-localizing-an-activex-control"></a>Элементы управления ActiveX в MFC. Локализация элемента управления ActiveX

В этой статье обсуждаются процедуры локализации интерфейсов элементов управления ActiveX.

>[!IMPORTANT]
> ActiveX — это устаревшая технология, которую не следует использовать для новой разработки. Дополнительные сведения о современных технологиях, которые заменяют ActiveX, см. в разделе [элементы управления ActiveX](activex-controls.md).

Если вы хотите адаптировать элемент управления ActiveX на международном рынке, вам может потребоваться локализовать элемент управления. Windows поддерживает множество языков в дополнение к английскому по умолчанию, включая немецкий, французский и шведский. Это может представлять проблемы для элемента управления, если его интерфейс доступен только на английском языке.

Как правило, элементы управления ActiveX всегда должны основывать свой языковой стандарт на внешнем свойстве LocaleID. Это можно сделать тремя способами:

- Загрузка ресурсов (по запросу Always on) на основе текущего значения свойства LocaleID окружения. Пример [локализации](../overview/visual-cpp-samples.md) для элементов управления ACTIVEX в MFC использует эту стратегию.

- Загрузка ресурсов при экземпляре первого элемента управления на основе свойства LocaleID окружения и использования этих ресурсов для всех остальных экземпляров. Эта стратегия показана в этой статье.

    > [!NOTE]
    >  В некоторых случаях это не будет работать правильно, если будущие экземпляры имеют разные языковые стандарты.

- Используйте `OnAmbientChanged` функцию уведомления для динамической загрузки нужных ресурсов для языкового стандарта контейнера.

    > [!NOTE]
    >  Это будет работать для элемента управления, но библиотека DLL времени выполнения не будет динамически обновлять свои собственные ресурсы при изменении свойства окружения. Кроме того, библиотеки времени выполнения для элементов управления ActiveX используют языковой стандарт потока для определения языкового стандарта для своих ресурсов.

В оставшейся части этой статьи описываются две стратегии локализации. Первая стратегия обеспечивает [локализацию интерфейса программирования элемента управления](#_core_localizing_your_control.92.s_programmability_interface) (имен свойств, методов и событий). Вторая стратегия [локализуется пользовательский интерфейс элемента управления](#_core_localizing_the_control.92.s_user_interface), используя внешнее свойство LocaleID контейнера. Демонстрацию локализации элементов управления см. в разделе пример [локализации](../overview/visual-cpp-samples.md)элементов управления ACTIVEX в MFC.

## <a name="localizing-the-controls-programmability-interface"></a><a name="_core_localizing_your_control.92.s_programmability_interface"></a>Локализация интерфейса программирования элемента управления

При локализации интерфейса программирования элемента управления (интерфейс, используемый программистами для создания приложений, использующих ваш элемент управления), необходимо создать измененную версию элемента управления. IDL-файл (скрипт для создания библиотеки типов элементов управления) для каждого поддерживаемого языка. Это единственное место, необходимое для локализации имен свойств элемента управления.

При разработке локализованного элемента управления включите код локали в качестве атрибута на уровне библиотеки типов. Например, если вы хотите предоставить библиотеку типов с локализованными именами свойств на французском языке, создайте копию примера. IDL-файл и вызовите его САМПЛЕФР. IDL. Добавьте атрибут идентификатора локали в файл (код локали для французского языка — 0x040C), как показано ниже:

[!code-cpp[NVC_MFC_AxLoc#1](codesnippet/cpp/mfc-activex-controls-localizing-an-activex-control_1.idl)]

Измените имена свойств в САМПЛЕФР. IDL в эквивалентные им французские, а затем используйте MKTYPLIB. EXE для создания французской библиотеки типов САМПЛЕФР. TLB.

Чтобы создать несколько локализованных библиотек типов, можно добавить локализованные. IDL-файлы в проект, и они будут созданы автоматически.

#### <a name="to-add-an-idl-file-to-your-activex-control-project"></a>Для добавления. IDL-файл для проекта элемента управления ActiveX

1. Откройте проект элемента управления и в меню **проект** выберите команду **Добавить существующий элемент**.

   Откроется диалоговое окно **Добавление существующего элемента**.

1. При необходимости выберите диск и каталог для просмотра.

1. В поле **тип файлов** выберите **все файлы ( \* . \* )**.

1. В поле Список файлов дважды щелкните. IDL-файл, который необходимо вставить в проект.

1. Нажмите кнопку **Открыть** , когда вы добавите все необходимое. IDL-файлы.

Поскольку файлы были добавлены в проект, они будут построены при построении остальной части проекта. Локализованные библиотеки типов находятся в текущем каталоге проекта элемента управления ActiveX.

Внутри кода внутренние имена свойств (обычно на английском языке) всегда используются и никогда не локализуются. Это включает карту диспетчеризации элемента управления, функции обмена свойствами и код обмена данными страницы свойств.

Только одна библиотека типов (. TLB) файл может быть привязан к ресурсам реализации элемента управления (. OCX). Обычно это версия со стандартными (как правило, английским) именами. Чтобы отправить локализованную версию элемента управления, необходимо отправить. OCX (который уже привязан к параметру по умолчанию. Версия TLB) и. TLB для соответствующего языкового стандарта. Это означает, что только. OCX требуется для английских версий, так как это верно. TLB уже привязана к нему. Для других языков локализованная библиотека типов также должна поставляться вместе с. OCX.

Чтобы убедиться, что клиенты элемента управления могут найти локализованную библиотеку типов, зарегистрируйте свой языковой стандарт. TLB-файлы в разделе TypeLib системного реестра Windows. Третий параметр (обычно необязательный) функции [афксолерегистертипелиб](reference/registering-ole-controls.md#afxoleregistertypelib) предоставляется для этой цели. В следующем примере регистрируется Французская библиотека типов для элемента управления ActiveX:

[!code-cpp[NVC_MFC_AxLoc#2](codesnippet/cpp/mfc-activex-controls-localizing-an-activex-control_2.cpp)]

При регистрации элемента управления `AfxOleRegisterTypeLib` функция автоматически ищет указанный объект. TLB в том же каталоге, что и элемент управления, и регистрирует его в базе данных регистрации Windows. Если. TLB-файл не найден, функция не действует.

## <a name="localizing-the-controls-user-interface"></a><a name="_core_localizing_the_control.92.s_user_interface"></a>Локализация пользовательского интерфейса элемента управления

Чтобы локализовать пользовательский интерфейс элемента управления, поместите все видимые пользователю ресурсы элемента управления (например, страницы свойств и сообщения об ошибках) в библиотеки ресурсов, зависящие от языка. Затем можно использовать внешнее свойство LocaleID контейнера, чтобы выбрать соответствующую библиотеку DLL для языкового стандарта пользователя.

В следующем примере кода демонстрируется один из подходов к поиску и загрузке библиотеки DLL ресурсов для определенного языкового стандарта. Эта функция-член, вызываемая `GetLocalizedResourceHandle` для этого примера, может быть функцией-членом класса элемента управления ActiveX:

[!code-cpp[NVC_MFC_AxLoc#3](codesnippet/cpp/mfc-activex-controls-localizing-an-activex-control_3.cpp)]

Обратите внимание, что идентификатор подязыка можно проверить в каждом случае оператора switch, чтобы обеспечить более специализированную локализацию. Демонстрацию этой функции см. в описании `GetResourceHandle` функции в примере [локализации](../overview/visual-cpp-samples.md)элементов управления ActiveX в MFC.

Когда элемент управления впервые загружается в контейнер, он может вызвать [COleControl:: амбиентлокалеид](reference/colecontrol-class.md#ambientlocaleid) , чтобы получить код локали. Элемент управления может затем передать возвращенное значение идентификатора локали `GetLocalizedResourceHandle` функции, которая загружает соответствующую библиотеку ресурсов. Элемент управления должен передать результирующий обработчик, если таковой имеется, в [афкссетресаурцехандле](reference/application-information-and-management.md#afxsetresourcehandle):

[!code-cpp[NVC_MFC_AxLoc#4](codesnippet/cpp/mfc-activex-controls-localizing-an-activex-control_4.cpp)]

Поместите приведенный выше пример кода в функцию-член элемента управления, например переопределение [COleControl:: OnSetClientSite](reference/colecontrol-class.md#onsetclientsite). Кроме того, *m_hResDLL* должен быть переменной-членом класса Control.

Аналогичную логику можно использовать для локализации страницы свойств элемента управления. Чтобы локализовать страницу свойств, добавьте код, аналогичный приведенному ниже, в файл реализации страницы свойств (в переопределении [COlePropertyPage:: онсетпажесите](reference/colepropertypage-class.md#onsetpagesite)):

[!code-cpp[NVC_MFC_AxLoc#5](codesnippet/cpp/mfc-activex-controls-localizing-an-activex-control_5.cpp)]

## <a name="see-also"></a>См. также раздел

[Элементы ActiveX библиотеки MFC](mfc-activex-controls.md)
