---
description: 'Дополнительные сведения о: TN058: реализация состояния модуля MFC'
title: TN058. Реализация состояния модуля MFC
ms.date: 06/28/2018
helpviewer_keywords:
- thread state [MFC]
- module states [MFC], managing state data
- TN058
- MFC, managing state data
- module states [MFC], switching
- DLLs [MFC], module states
- process state [MFC]
ms.assetid: 72f5b36f-b3da-4009-a144-24258dcd2b2f
ms.openlocfilehash: c4b300b9aa184e9fa1c6cfd5a8cf668d163d85ef
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97214784"
---
# <a name="tn058-mfc-module-state-implementation"></a>TN058. Реализация состояния модуля MFC

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этом техническом примечании описывается реализация конструкций "состояние модуля" MFC. Понимание реализации состояния модуля крайне важно для использования общих библиотек DLL MFC из библиотеки DLL (или сервера обработки данных OLE).

Прежде чем читать это Примечание, ознакомьтесь со статьей "Управление данными о состоянии модулей MFC" раздела [Создание новых документов, окон и представлений](../mfc/creating-new-documents-windows-and-views.md). Эта статья содержит важные сведения об использовании и общие сведения по этой теме.

## <a name="overview"></a>Общие сведения

Существует три вида сведений о состоянии MFC: состояние модуля, состояние процесса и состояние потока. Иногда эти типы состояний можно объединять. Например, карты обработки в MFC — это локальные и локальные потоки. Это позволяет двум различным модулям иметь разные карты в каждом из своих потоков.

Состояние процесса и состояние потока похожи. Эти элементы данных являются объектами, которые традиционно были глобальными переменными, но они должны быть специфичны для конкретного процесса или потока для обеспечения правильной поддержки Win32 или для правильной поддержки многопоточности. Категория, в которой размещается данный элемент данных, зависит от этого элемента и его требуемой семантики в отношении границ процессов и потоков.

Состояние модуля является уникальным в том, что оно может содержать либо действительно глобальное состояние, либо состояние, которое является локальным локальным или потоком локального процесса. Кроме того, его можно быстро переключить.

## <a name="module-state-switching"></a>Переключение состояния модуля

Каждый поток содержит указатель на состояние модуля "Current" или "Active" (не удивительно, что указатель является частью локального состояния потока MFC). Этот указатель изменяется, когда поток выполнения передает границу модуля, например приложение, вызывающее вызов OLE-элемента управления или DLL, или элемент управления OLE, вызывающий обратную передачу в приложение.

Текущее состояние модуля переключается вызовом метода `AfxSetModuleState` . В большинстве случаев вы не будете напрямую работать с API. MFC, во многих случаях, будет вызывать его для вас (по WinMain, точки входа OLE и `AfxWndProc` т. д.). Это делается в любом компоненте, который вы пишете статическим связыванием в специальной `WndProc` области, и специальным `WinMain` (или `DllMain` ), который знает, какое состояние модуля должно быть текущим. Этот код можно увидеть по адресу ДЛЛМОДУЛ. CPP или АППМОДУЛ. CPP в каталоге МФК\СРК.

В редких случаях необходимо задать состояние модуля, а затем не задавать его обратно. В большинстве случаев необходимо «отправить» собственное состояние модуля в качестве текущего, а затем, после завершения, вернуть исходный контекст. Это делается с помощью макроса [AFX_MANAGE_STATE](reference/extension-dll-macros.md#afx_manage_state) и специального класса `AFX_MAINTAIN_STATE` .

`CCmdTarget` содержит специальные функции для поддержки переключения состояния модуля. В частности, `CCmdTarget` — это корневой класс, используемый для OLE-автоматизации и точек входа OLE COM. Как и любая другая точка входа, предоставляемая системе, эти точки входа должны задавать правильное состояние модуля. Как это `CCmdTarget` знает, что именно должно быть "правильным" состояние модуля — это то, что оно "запоминает" состояние модуля "Current", когда оно создается, что позволяет ему установить текущее состояние модуля на это "сохраненное" значение при последующем вызове. В результате состояние модуля, `CCmdTarget` с которым связан данный объект, — это состояние модуля, которое было текущим при создании объекта. Возьмем простой пример загрузки сервера INPROC, создания объекта и вызова его методов.

1. Библиотека DLL загружается OLE с помощью `LoadLibrary` .

1. `RawDllMain` вызывается первым. Он устанавливает состояние модуля в состояние известного статического модуля для библиотеки DLL. По этой причине `RawDllMain` статически связывается с библиотекой DLL.

1. Вызывается конструктор для фабрики класса, связанной с нашим объектом. `COleObjectFactory` является производным от `CCmdTarget` , и в результате он запоминает состояние модуля, для которого он был создан. Это важно — когда фабрика класса запрашивает создание объектов, теперь он знает, какое состояние модуля следует сделать текущим.

1. `DllGetClassObject` вызывается для получения фабрики класса. MFC выполняет поиск в списке фабрики класса, связанном с этим модулем, и возвращает его.

1. вызывается метод `COleObjectFactory::XClassFactory2::CreateInstance`; Перед созданием объекта и его возвратом эта функция устанавливает состояние модуля в состояние модуля, которое было текущим в шаге 3 (то есть в текущем `COleObjectFactory` экземпляре при создании экземпляра). Это выполняется в [METHOD_PROLOGUE](com-interface-entry-points.md).

1. При создании объекта он также является `CCmdTarget` производным и точно так же, как `COleObjectFactory` было указано, какое состояние модуля было активным, поэтому выполняет этот новый объект. Теперь объект знает, какое состояние модуля следует переключать при каждом вызове.

1. Клиент вызывает функцию для объекта OLE COM, полученного при `CoCreateInstance` вызове. При вызове объекта он использует `METHOD_PROLOGUE` для переключения состояния модуля так же, как и `COleObjectFactory` .

Как видите, состояние модуля распространяется от объекта к объекту по мере их создания. Важно правильно задать состояние модуля. Если она не задана, то библиотека DLL или COM-объект может плохо взаимодействовать с приложением MFC, которое вызывает его, или не может найти собственные ресурсы или может завершиться ошибкой другими мисерабле способами.

Обратите внимание, что определенные виды библиотек DLL, в частности библиотеки DLL расширения MFC, не переключают состояние модуля в их `RawDllMain` (фактически, обычно они даже не имеют `RawDllMain` ). Это обусловлено тем, что они должны вести себя так, как если бы они присутствовали в приложении, которое их использует. Они являются очень частью выполняемого приложения, и их намерение изменить глобальное состояние приложения.

Элементы управления OLE и другие библиотеки DLL сильно отличаются. Они не хотят изменять состояние вызывающего приложения; приложение, вызывающее их, может даже не быть приложением MFC, поэтому изменение состояния может быть невозможным. Это причина, по которой переключение состояния модуля было вымышлено.

Для экспортированных функций из библиотеки DLL, например, запуска в библиотеке DLL диалогового окна, необходимо добавить в начало функции следующий код:

```cpp
AFX_MANAGE_STATE(AfxGetStaticModuleState())
```

Это меняет местами текущее состояние модуля на состояние, возвращенное из [афксжетстатикмодулестате](reference/extension-dll-macros.md#afxgetstaticmodulestate) , до конца текущей области.

Если макрос AFX_MODULE_STATE не используется, возникнут проблемы с ресурсами в библиотеках DLL. По умолчанию MFC использует для загрузки шаблона ресурса обработчик ресурсов основного приложения. Фактически этот шаблон хранится в библиотеке DLL. Основная причина заключается в том, что сведения о состоянии модуля MFC не были переключены с помощью макроса AFX_MODULE_STATE. Маркер ресурса восстанавливается из состояния модуля MFC. Отсутствие переключения состояния модуля приводит к тому, что используется неправильный маркер ресурса.

AFX_MODULE_STATE не нужно размещать в каждой функции в библиотеке DLL. Например, `InitInstance` можно вызвать код MFC в приложении без AFX_MODULE_STATE, так как MFC автоматически сдвигает состояние модуля, `InitInstance` а затем снова переключается после `InitInstance` возврата. Это справедливо и для всех обработчиков схемы сообщений. Фактические библиотеки DLL MFC имеют специальную процедуру главного окна, которая автоматически переключает состояние модуля перед маршрутизацией любого сообщения.

## <a name="process-local-data"></a>Обработка локальных данных

Обработка локальных данных может быть не так важна для работы с моделью DLL Win32s. В Win32s все библиотеки DLL совместно используют свои глобальные данные, даже если они загружены несколькими приложениями. Это сильно отличается от "реальной" модели данных DLL Win32, где каждая библиотека DLL получает отдельную копию пространства данных в каждом процессе, который подключается к библиотеке DLL. Для повышения сложности данные, выделенные в куче в библиотеке DLL Win32s, фактически обрабатываются в определенном процессе (по крайней мере, когда происходит владение). Рассмотрим следующие данные и код:

```cpp
static CString strGlobal; // at file scope

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, strGlobal);
}
```

Рассмотрим, что произойдет, если приведенный выше код находится в библиотеке DLL и что библиотека DLL загружена двумя процессами A и B (на самом деле, это может быть два экземпляра одного и того же приложения). Вызов `SetGlobalString("Hello from A")` . В результате память выделяется для `CString` данных в контексте процесса а. Помните, что `CString` сам является глобальным и является видимым как для, так и для B. Теперь вызовы `GetGlobalString(sz, sizeof(sz))` . B сможет просматривать данные, которые набор. Это обусловлено тем, что Win32s не обеспечивает защиту между процессами, такими как Win32. Это первая проблема; во многих случаях нежелательно, чтобы одно приложение влияло на глобальные данные, которые считаются принадлежащими другому приложению.

Существуют и другие проблемы. Предположим, что теперь завершается. Когда происходит выход, память, используемая `strGlobal` строкой "", становится доступной для системы, то есть вся память, выделенная процессом, автоматически освобождается операционной системой. Он не освобождается, поскольку `CString` вызывается деструктор; он еще не был вызван. Он освобождается просто потому, что приложение, которое его выделило, покинуло сцену. Теперь при вызове B `GetGlobalString(sz, sizeof(sz))` не допускается получение допустимых данных. Другие приложения могли использовать эту память для чего-то другого.

Очевидно, что проблема существует. В MFC 3. x использовался метод, называемый локальным хранилищем потока (TLS). MFC 3. x будет выделять TLS-индекс, который в Win32 фактически выступает в качестве индекса локальной памяти процесса, даже если он не вызывается, а затем ссылается на все данные, основанные на этом индексе TLS. Это аналогично индексу TLS, который использовался для хранения локальных данных потока в Win32 (Дополнительные сведения об этой теме см. ниже). Это привело к тому, что каждая библиотека DLL MFC использует по крайней мере два индекса TLS для каждого процесса. При учете загрузки многих DLL-библиотек элементов управления OLE (Окксс) вы быстро запускаете индексы TLS (доступно только 64). Кроме того, в одной структуре MFC пришлось размещать все эти данные в одном месте. Он был не очень расширяемым и не был идеальным в отношении использования индексов TLS.

MFC 4. x решает это с помощью набора шаблонов классов, которые можно "переносить" вокруг данных, которые должны быть локальными для обработки. Например, описанная выше проблема может быть исправлена путем написания:

```cpp
struct CMyGlobalData : public CNoTrackObject
{
    CString strGlobal;
};
CProcessLocal<CMyGlobalData> globalData;

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    globalData->strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, globalData->strGlobal);
}
```

MFC реализует это в двух шагах. Во-первых, имеется слой поверх API-интерфейсов Win32 __TLS \*__ (**TlsAlloc**, **тлссетвалуе**, **тлсжетвалуе** и т. д.), которые используют только два индекса TLS для каждого процесса независимо от того, сколько библиотек DLL имеется. Во-вторых, `CProcessLocal` для доступа к этим данным используется шаблон. Он переопределяет оператор, > который позволяет интуитивно понятный синтаксис, который вы видите выше. Все объекты, заключенные в оболочку, `CProcessLocal` должны быть производными от `CNoTrackObject` . `CNoTrackObject`предоставляет распределитель низкого уровня (**локалаллок** / **функции LocalFree**) и виртуальный деструктор, позволяющий MFC автоматически уничтожить локальные объекты процесса после завершения процесса. Такие объекты могут иметь пользовательский деструктор, если требуется дополнительная очистка. В приведенном выше примере не требуется один, поскольку компилятор создаст деструктор по умолчанию для уничтожения внедренного `CString` объекта.

Существуют и другие интересные преимущества этого подхода. Не только все `CProcessLocal` объекты уничтожаются автоматически, они не создаются до тех пор, пока они не понадобятся. `CProcessLocal::operator->` будет создавать экземпляр связанного объекта при первом его вызове, а не более ранних. В приведенном выше примере это означает, что `strGlobal` строка "" не будет создана до первого `SetGlobalString` `GetGlobalString` вызова метода или. В некоторых случаях это может снизить время запуска библиотеки DLL.

## <a name="thread-local-data"></a>Локальные данные потока

Как и для локальных данных обработки, локальные данные потока используются, когда данные должны быть локальными для данного потока. То есть необходим отдельный экземпляр данных для каждого потока, который обращается к этим данным. Это несколько раз используется вместо обширных механизмов синхронизации. Если данные не должны совместно использоваться несколькими потоками, такие механизмы могут быть дорогостоящими и ненужными. Предположим, что у нас есть `CString` объект (похожий на пример выше). Мы можем сделать этот поток локальным, заключив его в `CThreadLocal` шаблон:

```cpp
struct CMyThreadData : public CNoTrackObject
{
    CString strThread;
};
CThreadLocal<CMyThreadData> threadData;

void MakeRandomString()
{
    // a kind of card shuffle (not a great one)
    CString& str = threadData->strThread;
    str.Empty();
    while (str.GetLength() != 52)
    {
        unsigned int randomNumber;
        errno_t randErr;
        randErr = rand_s(&randomNumber);

        if (randErr == 0)
        {
            TCHAR ch = randomNumber % 52 + 1;
            if (str.Find(ch) <0)
            str += ch; // not found, add it
        }
    }
}
```

Если `MakeRandomString` был вызван из двух разных потоков, каждый из них получит «передвинуть» строку различными способами, не мешая другим. Это обусловлено тем, что на самом деле существует `strThread` экземпляр для каждого потока, а не только один глобальный экземпляр.

Обратите внимание, что ссылка используется для записи `CString` адреса однократно, а не один раз в итерации цикла. Код цикла может `threadData->strThread` быть написан везде, где используется " `str` ", но код был бы намного более медленным при выполнении. Рекомендуется кэшировать ссылку на данные, если такие ссылки происходят в циклах.

`CThreadLocal`Шаблон класса использует те же механизмы, что `CProcessLocal` и те же методы реализации.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
