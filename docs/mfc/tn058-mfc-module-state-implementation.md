---
title: 'TN058: Реализация состояния модуля MFC'
ms.date: 06/28/2018
f1_keywords:
- vc.mfc.implementation
helpviewer_keywords:
- thread state [MFC]
- module states [MFC], managing state data
- TN058
- MFC, managing state data
- module states [MFC], switching
- DLLs [MFC], module states
- process state [MFC]
ms.assetid: 72f5b36f-b3da-4009-a144-24258dcd2b2f
ms.openlocfilehash: db34f528e70a7dcc437836684656b3ce8a4078fd
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62399607"
---
# <a name="tn058-mfc-module-state-implementation"></a>TN058: Реализация состояния модуля MFC

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Это техническое Примечание описывает реализацию конструкции «Состояния модуля MFC». Понимание реализация состояния модуля является критически важным для с помощью MFC общих библиотек DLL из библиотеки DLL (или внутрипроцессный OLE-сервер).

Перед чтением этой заметке, ссылаться на «Управление данными о состоянии модулей MFC» в [создание новых документов, Windows и представления](../mfc/creating-new-documents-windows-and-views.md). Эта статья содержит важные сведения по использованию и общие сведения по этой теме.

## <a name="overview"></a>Обзор

Существует три вида сведения о состоянии MFC: Состояние модуля, состояние процесса и состояние потока. Иногда можно объединить эти типы состояния. Например MFC дескриптор карты являются локального модуля и локального потока. Это позволяет двух разных модулях иметь разные карты в каждой из своих потоков.

Состояние процесса и состояние потока похожи. Эти элементы данных – это вещи, которые традиционно глобальные переменные, но они имеют должны различаться для каждого процесса или потока для поддержки правильной Win32s или для правильного многопоточности. Какие категории элемента данных помещается в зависит от этого элемента и его семантику относительно границы процессов и потоков.

Состояние модуля является уникальным, в том, что он может содержать, по-настоящему глобальное состояние или состояние, которое является локальный процесс или локального потока. Кроме того его можно быстро переключаться.

## <a name="module-state-switching"></a>Переключение состояния модуля

Каждый поток содержит указатель на состояние «текущая» или «активный» модуль (не удивительно, что указатель является частью локальное состояние потока MFC). Этот указатель меняется в том случае, когда поток выполнения передает границе модуля, например приложения, вызывающего элемента OLE или библиотеки DLL или элемента управления OLE обратного вызова в приложение.

Текущее состояние модуля переключается путем вызова `AfxSetModuleState`. В большинстве случаев никогда не будет работать непосредственно с API. MFC, во многих случаях будет вызывать его для вас (в WinMain, точки входа OLE, `AfxWndProc`и т. д.). Это можно сделать в любой компонент, который выполняется запись, статическая компоновка библиотеки на специальном `WndProc`и специальный `WinMain` (или `DllMain`), знает, какие состояния модуля должно быть текущей. Этот код можно увидеть, просмотрев DLLMODUL. CPP или APPMODUL. CPP в каталоге MFC\SRC.

Маловероятно, что вы хотите установить состояния модуля и затем не снова задать его. В большинстве случаев требуется собственный модуль «push» состоянии, что и текущий и затем, когда закончите, «выскакивали» исходного контекста обратно. Это можно сделать, макрос [AFX_MANAGE_STATE](reference/extension-dll-macros.md#afx_manage_state) и специального класса `AFX_MAINTAIN_STATE`.

`CCmdTarget` имеет специальные средства для поддержки переключения состояния модуля. В частности `CCmdTarget` является корневой класс использовать для автоматизации OLE и OLE COM точки входа. Любые другие точки входа, например через системы, эти точки входа ее состояние необходимо установить правильный модуль. Как does заданного `CCmdTarget` знать, что модуль «правильный» состояние должно быть ответ — что он «запоминаются» что такое «current» состояние модуля при построении, таким образом, что его можно задать текущее состояние модуля, «запоминается» вызывается значения, находящегося в более поздней версии. В результате модуль указано, что заданный `CCmdTarget` объект связан с находится в состоянии модуля, который был текущим в том случае, когда объект был создан. Рассмотрим простой пример загрузки серверу INPROC, создание объекта и вызова его методов.

1. Библиотека DLL загружается с OLE с помощью `LoadLibrary`.

2. `RawDllMain` Сначала вызывается. Он устанавливает состояние модуля в состояние известного статического модуля для библиотеки DLL. По этой причине `RawDllMain` статически компонуемые библиотеки DLL.

1. Вызывается конструктор для класса фабрики, связанный с нашего объекта. `COleObjectFactory` является производным от `CCmdTarget` и таким образом, программа запоминает в определенном состоянии модуль был создан. Это важно, когда фабрика класса является запрос на создание объектов, он знает, теперь какое состояние модуля, необходимо сделать текущим.

4. `DllGetClassObject` вызывается для получения фабрики класса. MFC в списке класс фабрики, связанный с данным модулем и возвращает его.

5. вызывается метод `COleObjectFactory::XClassFactory2::CreateInstance`; Перед созданием объекта и возвращением, эта функция задает состояние модуля в состояние модуля, которая была текущей на шаге 3 (которая была текущей при `COleObjectFactory` был создан). Это выполняется внутри [METHOD_PROLOGUE](com-interface-entry-points.md).

1. При создании объекта слишком бывает `CCmdTarget` класс, производный от и таким же образом `COleObjectFactory` запоминать, какие состояния модуля был активен, проявляется этого нового объекта. Теперь объект знает, какие состояния модуля переключиться на каждый раз, когда он вызывается.

1. Клиент вызывает функцию для OLE COM-объект, полученный от его `CoCreateInstance` вызова. При вызове объекта он использует `METHOD_PROLOGUE` так же, как переключиться в состоянии модуля `COleObjectFactory` does.

Как вы видите, состояние модуля распространяется от объекта к объекту при их создании. Очень важно иметь состояние модуля, укажите соответствующее значение. Если не указано, DLL или COM-объект может плохо взаимодействовать с приложение MFC, вызывает его, или не удается найти собственные ресурсы, может произойти сбой другими способами плохо.

Обратите внимание, что некоторые виды библиотек DLL, специально «MFC расширение» DLL не переключения состояния модуля в их `RawDllMain` (на самом деле, они обычно даже не `RawDllMain`). Это так, как они предназначены для функционируют «как» фактически они существовали в приложении, которое их использует. Они являются очень частью приложения, на котором выполняется, и это выполняемое Изменение глобального состояния данного приложения.

Элементы управления OLE и других библиотек DLL сильно отличаются. Они не нужно изменять состояние вызывающего приложения; приложения, которое вызывает их могут даже не приложения MFC, и поэтому может существовать ни одно состояние для изменения. Это причина, что переключение состояния модуля была изобретена.

Для экспортированных функций из библиотеки DLL, например, запускает диалоговое окно в вашей библиотеке DLL необходимо добавить следующий код в начале функции:

```cpp
AFX_MANAGE_STATE(AfxGetStaticModuleState())
```

Это меняет местами текущее состояние модуля с состоянием, возвращенные [AfxGetStaticModuleState](reference/extension-dll-macros.md#afxgetstaticmodulestate) до конца текущей области.

Проблемы с ресурсами в библиотеках DLL происходит, если макрос AFX_MODULE_STATE не используется. По умолчанию MFC использует дескриптор ресурсов основного приложения для загрузки шаблона ресурсов. Этот шаблон хранится в библиотеке DLL. Основной причиной является то, что сведения о состоянии модуля MFC не была переключена в макросе AFX_MODULE_STATE. Дескриптор ресурса будет восстановлена из состояния модуля MFC. Не меняет состояние модуля вызывает дескриптор неправильный ресурс для использования.

AFX_MODULE_STATE не требуется помещать в каждой функции в DLL. Например `InitInstance` может вызываться кодом MFC в приложения без AFX_MODULE_STATE, так как MFC автоматически переключается в состояние модуля перед `InitInstance` и затем коммутаторов, его обратно после `InitInstance` возвращает. То же самое верно для всех обработчиков сообщений карты. Обычные библиотеки DLL MFC фактически имеют специальное окно главную процедуру, которая автоматически переключается в состояние модуля перед отправкой сообщения.

## <a name="process-local-data"></a>Процесс локальных данных

Локальные данные процесса будет такой большую важность не было для сложность модели Win32s DLL. Даже в том случае, при загрузке нескольких приложений в Win32s все DLL-библиотеки совместно использовать их глобальных данных. Это сильно отличается от «настоящих» DLL-Библиотеки Win32 модели данных, где каждой библиотеки DLL, получает отдельную копию пространства данных в каждом процессе, который подключает к библиотеке DLL. Чтобы добавить к сложности, данных, размещенный в куче в библиотеке DLL Win32s — на самом деле процесс определенного (по крайней мере насколько владения переходит). Рассмотрим следующие данные и код.

```cpp
static CString strGlobal; // at file scope

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, strGlobal);
}
```

Рассмотрим, что произойдет, если приведенный выше код в находится в библиотеке DLL, и что библиотека DLL загружается двумя процессами A и B, (на самом деле, возможно два экземпляра одного приложения). Вызовы `SetGlobalString("Hello from A")`. Таким образом, память, выделенная для `CString` данные в контексте процесса, а. Имейте в виду, что `CString` сам является глобальным и является видимым для обоих A и B. B вызывает `GetGlobalString(sz, sizeof(sz))`. B сможет см. в разделе, набор данных. Это обусловлено Win32s не обеспечивает защиту между процессами, как Win32. Это первая проблема; Во многих случаях это не важно иметь одного приложения, которые влияют на глобальных данных, который считается владельцем другое приложение.

Существуют также дополнительные проблемы. Предположим, что теперь завершает работу. Когда объект завершается, память, занятая "`strGlobal`" строка становится доступным для системы, то есть всей памяти, выделенной с помощью процесса A освобождается автоматически операционной системой. Он не будет освобожден, так как `CString` вызывается деструктор; он не был вызван. Освобождения, просто потому что приложение, которое выделяет покинул сцены. Теперь, если вызывается B `GetGlobalString(sz, sizeof(sz))`, он не может получить допустимые данные. Возможно, некоторые другие приложения использовали эту память для других целей.

Очевидно, что проблема. MFC 3.x используемый называемую локальное хранилище потока (TLS). MFC 3.x выделит индекс TLS, что в Win32s действует как в индексе, процесс локальной памяти, несмотря на то, что он не вызывается и затем будет ссылаться на все данные, на основе этого индекса TLS. Это похоже на индекс TLS, который был использован для хранения локальных данных потока на Win32 (см. ниже дополнительные сведения по этой теме). Это вызвано каждой библиотеки DLL MFC использовать по крайней мере два TLS индексы каждого процесса. Когда вы учесть множество OLE управления библиотеки DLL, загружаемые (OCX), быстро хватает индексов TLS (доступны только 64). Кроме того MFC пришлось поместить все эти данные в одном месте, в единую структуру. Он не очень легко расширяется и не оптимально по отношению к его использование индексов TLS.

MFC 4.x решает эту проблему с набором шаблонов классов, вы можете «оборачивается» вокруг данных, который должен быть локальный процесс. Например упомянутых выше проблему можно исправить путем написания:

```cpp
struct CMyGlobalData : public CNoTrackObject
{
    CString strGlobal;
};
CProcessLocal<CMyGlobalData> globalData;

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    globalData->strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, globalData->strGlobal);
}
```

Это реализация MFC в два этапа. Во-первых, это слой, на основе Win32 __Tls\*__  API-интерфейсы (**TlsAlloc**, **TlsSetValue**, **TlsGetValue**т. д.) что Используйте только два индекса TLS на процесс, независимо от того, сколько библиотек DLL. Во-вторых, `CProcessLocal` шаблон предоставляется доступ к этим данным. Этот параметр переопределяет оператор "->", который является то, что позволяет интуитивно понятный синтаксис вы см. в разделе выше. Все объекты, упакованные в `CProcessLocal` должен быть производным от `CNoTrackObject`. `CNoTrackObject` предоставляет распределитель более низкого уровня (**LocalAlloc**/**LocalFree**) и виртуальный деструктор таким образом, что MFC автоматически может уничтожить локальных объектов процесса, когда процесс завершается. Такие объекты могут иметь пользовательский деструктор, если перед вызовом базового класса не требуется. Приведенный выше пример не требуется, так как компилятор создает деструктор по умолчанию для уничтожения внедренный `CString` объекта.

Существуют другие интересные преимущества этого подхода. Не только имеют все `CProcessLocal` объекты уничтожаются автоматически, не они построены, пока они потребуются. `CProcessLocal::operator->` Создает экземпляр связанного объекта в первый раз он вызывается и не может быть выполнено. В приведенном выше примере, это означает, что "`strGlobal`" строка не создается до момента первого `SetGlobalString` или `GetGlobalString` вызывается. В некоторых случаях это может снизить время запуска библиотеки DLL.

## <a name="thread-local-data"></a>Данных "thread"

Как и для обработки локальных данных, данных "thread" используется при данных должен быть локальным для данного потока. То есть вам потребуется отдельный экземпляр данных для каждого потока, который обращается к этим данным. Это можно многократно использовать вместо механизмов обширной синхронизации. Если данные не требуется для совместного использования несколькими потоками, такие механизмы может быть дорогостоящим и ненужные. Предположим, что у нас было `CString` объекта (так как в приведенном выше примере). Сделать ее потоков локального путем упаковывания их с `CThreadLocal` шаблона:

```cpp
struct CMyThreadData : public CNoTrackObject
{
    CString strThread;
};
CThreadLocal<CMyThreadData> threadData;

void MakeRandomString()
{
    // a kind of card shuffle (not a great one)
    CString& str = threadData->strThread;
    str.Empty();
    while (str.GetLength() != 52)
    {
        unsigned int randomNumber;
        errno_t randErr;
        randErr = rand_s(&randomNumber);

        if (randErr == 0)
        {
            TCHAR ch = randomNumber % 52 + 1;
            if (str.Find(ch) <0)
            str += ch; // not found, add it
        }
    }
}
```

Если `MakeRandomString` был вызван из двух разных потоков, каждый будет «в случайном порядке» строка по-разному без влияния другой. Это связано с фактически `strThread` экземпляр каждого потока, а не только один глобальный экземпляр.

Обратите внимание на то, как ссылка используется для сбора данных `CString` адрес один раз вместо после каждой итерации цикла. Код цикла можно было бы записать с `threadData->strThread` everywhere "`str`" используется, но код будет работать намного медленнее при выполнении. Лучше кэшировать ссылку на данные, такие ссылки, возникающие в циклах.

`CThreadLocal` Класс-шаблон использует такие же механизмы, `CProcessLocal` не, а также те же способы реализации.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
