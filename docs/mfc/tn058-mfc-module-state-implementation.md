---
title: TN058. Реализация состояния модуля MFC
ms.date: 06/28/2018
helpviewer_keywords:
- thread state [MFC]
- module states [MFC], managing state data
- TN058
- MFC, managing state data
- module states [MFC], switching
- DLLs [MFC], module states
- process state [MFC]
ms.assetid: 72f5b36f-b3da-4009-a144-24258dcd2b2f
ms.openlocfilehash: b64fb6b97474007c44a2124315e83e1ac119f9ec
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81366611"
---
# <a name="tn058-mfc-module-state-implementation"></a>TN058. Реализация состояния модуля MFC

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой технической записке описывается реализация конструкций МФЦ "модульное состояние". Понимание реализации состояния модуля имеет решающее значение для использования общих DLL MFC с DLL (или сервера OLE в процессе).

Прежде чем читать эту заметку, обратитесь к "Управление государственными данными модулей MFC" в [создании новых документов, Windows и просмотров](../mfc/creating-new-documents-windows-and-views.md). Эта статья содержит важную информацию об использовании и обзорную информацию по этому вопросу.

## <a name="overview"></a>Обзор

Существует три вида информации о состоянии МФЦ: состояние модуля, состояние процесса и состояние нити. Иногда эти типы состояния могут быть объединены. Например, карты обработки MFC являются локальными модульными и локальными потоками. Это позволяет двум различным модулям иметь разные карты в каждой из своих потоков.

Состояние процесса и состояние потока похожи. Эти элементы данных являются вещами, которые традиционно были глобальными переменными, но должны быть специфичны для данного процесса или потока для надлежащей поддержки Win32s или для надлежащей поддержки многопоточности. В какой категории помещается данный элемент данных, зависит от этого элемента и его желаемой семантики в отношении границ процесса и потока.

Состояние модуля уникально тем, что оно может содержать либо действительно глобальное состояние, либо состояние, которое является локальным процессом или локальным потоком. Кроме того, его можно быстро переключить.

## <a name="module-state-switching"></a>Переключение состояния модуля

Каждый поток содержит указатель на состояние "текущего" или "активного" модуля (не удивительно, что указатель является частью локального состояния потока MFC). Этот указатель изменяется, когда поток выполнения проходит границу модуля, например, вызов приложения в OLE Control или DLL или OL Control, возвращающееся в приложение.

Текущее состояние модуля `AfxSetModuleState`переключается по вызову. По большей части, вы никогда не будете иметь дело непосредственно с API. MFC, во многих случаях, будет называть его для вас (на WinMain, OLE входных точек, `AfxWndProc`и т.д.). Это делается в любом компоненте, который `WndProc`вы пишете, статически связывая в специальном, и специальный `WinMain` (или), `DllMain`который знает, какой модуль состояние должно быть текущим. Вы можете увидеть этот код, взглянув на DLLMODUL. CPP или APPMODUL. CPP в каталоге MFC-SRC.

Редко бывает, что вы хотите установить состояние модуля, а затем не установить его обратно. Большую часть времени вы хотите, чтобы "нажать" свой собственный модуль государства, как текущий, а затем, после того как вы сделали, "поп" исходный контекст обратно. Это делается [макроAFX_MANAGE_STATE](reference/extension-dll-macros.md#afx_manage_state) и специального класса. `AFX_MAINTAIN_STATE`

`CCmdTarget`имеет специальные функции для поддержки переключения состояния модуля. В частности, a `CCmdTarget` — это корневой класс, используемый для автоматизации OLE и точек входа OLE COM. Как и любая другая точка входа, подверженная воздействию системы, эти точки входа должны установить правильное состояние модуля. Как данный `CCmdTarget` данный способ узнать, что "правильное" состояние модуля должно быть Ответ омичет, что он "помнит", что "текущий" модуль состояние, когда он построен, таким образом, что он может установить текущее состояние модуля, что "запоминается" значение, когда он позже называется. В результате модуль заявляет, что `CCmdTarget` данный объект связан с состоянием модуля, которое было током, когда объект был построен. Возьмем простой пример загрузки сервера INPROC, создания объекта и вызова его методов.

1. DLL загружается OLE `LoadLibrary`с помощью .

1. `RawDllMain`называется первым. Он устанавливает состояние модуля в известное состояние статического модуля для DLL. По этой `RawDllMain` причине статично связан атак с DLL.

1. Называется конструктор для фабрики класса, связанной с нашим объектом. `COleObjectFactory`является производным от `CCmdTarget` и, как результат, он помнит, в каком состоянии модуля он был мгновенно. Это важно - когда фабрике класса предлагается создавать объекты, теперь она знает, какое состояние модуля сделать током.

1. `DllGetClassObject`называется для получения класса завода. MFC выполняет поиск по заводскому списку класса, связанного с этим модулем, и возвращает его.

1. Вызывается метод `COleObjectFactory::XClassFactory2::CreateInstance`. Перед созданием объекта и его возвратом эта функция устанавливает состояние модуля в состояние модуля, которое было текущим в шаге 3 (то, что было током, когда `COleObjectFactory` оно было мгновенно). Это делается внутри [METHOD_PROLOGUE](com-interface-entry-points.md).

1. Когда объект создается, он `CCmdTarget` тоже является производным и таким же образом `COleObjectFactory` вспомнил, какой модуль состояние было активным, так же это новый объект. Теперь объект знает, к какому состоянию модуля переключиться всякий раз, когда он вызывается.

1. Клиент вызывает функцию на объекте OLE `CoCreateInstance` COM, который он получил от своего вызова. Когда объект называется `METHOD_PROLOGUE` он использует для переключения состояния модуля так же, как `COleObjectFactory` делает.

Как вы можете видеть, состояние модуля распространяется от объекта к объекту по мере их создания. Важно, чтобы состояние модуля было настроено надлежащим образом. Если он не установлен, ваш объект DLL или COM может плохо взаимодействовать с приложением MFC, которое вызывает его, или может быть не в состоянии найти свои собственные ресурсы, или может потерпеть неудачу другими несчастными способами.

Обратите внимание, что некоторые виды DLLs, в частности" MFC расширение `RawDllMain` "DLLs не переключать `RawDllMain`состояние модуля в их (на самом деле, они, как правило, даже не имеют ). Это потому, что они предназначены для себя "как если бы" они на самом деле присутствовали в приложении, которое использует их. Они являются частью запущенного приложения, и это их намерение изменить глобальное состояние этого приложения.

OLE Управления и другие DLLs очень разные. Они не хотят изменять состояние приложения вызова; приложение, которое вызывает их не может быть даже приложение МФЦ и поэтому не может быть никакого состояния для изменения. Именно по этой причине было изобретено переключение состояния модуля.

Для экспортированных функций из DLL, таких как тот, который запускает диалоговое окно в DLL, необходимо добавить следующий код к началу функции:

```cpp
AFX_MANAGE_STATE(AfxGetStaticModuleState())
```

Это сменяет текущее состояние модуля с состоянием, возвращенным из [AfxGetStaticModuleState](reference/extension-dll-macros.md#afxgetstaticmodulestate) до конца текущего объема.

Проблемы с ресурсами в DLL возникнут, если AFX_MODULE_STATE макрос не используется. По умолчанию MFC использует ручку ресурсов основного приложения для загрузки шаблона ресурса. Этот шаблон фактически хранится в DLL. Основной причиной является то, что информация о состоянии модуля MFC не была переключена на AFX_MODULE_STATE макрос. Ручка ресурса восстанавливается из состояния модуля MFC. Не переключение состояния модуля приводит к неправильному использованию ручки ресурса.

AFX_MODULE_STATE не должны быть помещены в каждой функции в DLL. Например, `InitInstance` можно вызвать код MFC в приложении без AFX_MODULE_STATE, потому `InitInstance` что MFC автоматически `InitInstance` переключает состояние модуля раньше, а затем переключает его обратно после возврата. То же самое верно для всех обработчиков карты сообщений. Регулярные DLL MFC фактически имеют специальную процедуру мастер-окна, которая автоматически переключает состояние модуля перед тем, как отправить любое сообщение.

## <a name="process-local-data"></a>Обработка локальных данных

Процесс локальных данных не был бы настолько серьезной проблемой, если бы не сложность модели Win32s DLL. В Win32s все DLL делятся своими глобальными данными, даже при загрузке несколькими приложениями. Это очень отличается от "реальной" модели данных Win32 DLL, где каждый DLL получает отдельную копию своего пространства данных в каждом процессе, который прикрепляется к DLL. Чтобы добавить к сложности, данные, выделенные на кучу в Win32s DLL на самом деле процесс конкретных (по крайней мере, насколько собственности идет). Рассмотрим следующие данные и код:

```cpp
static CString strGlobal; // at file scope

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, strGlobal);
}
```

Рассмотрим, что происходит, если приведенный выше код находится в DLL и что DLL загружается двумя процессами A и B (на самом деле это могут быть два экземпляра одного и того же приложения). Звонки `SetGlobalString("Hello from A")`. В результате память выделяется `CString` для данных в контексте процесса A. Имейте в виду, что `CString` сама по себе является глобальной и видна как A, так и B. Теперь `GetGlobalString(sz, sizeof(sz))`B звонки . B сможет видеть данные, которые набор A. Это потому, что Win32s не предлагает никакой защиты между процессами, как Win32 делает. Это первая проблема; во многих случаях нежелательно, чтобы одно приложение повлияло на глобальные данные, которые, как считается, принадлежат другому приложению.

Есть и дополнительные проблемы. Допустим, что A теперь выходит. При выходе из системы доступность`strGlobal`памяти, используемой строкой ' ' - то есть, вся память, выделенная по процессу А, автоматически освобождается операционной системой. Он не освобождается, `CString` потому что диструктор называется; он не был вызван еще. Он освобождается просто потому, что приложение, которое выделило его покинул сцену. Теперь, `GetGlobalString(sz, sizeof(sz))`если B называется, он не может получить действительные данные. Некоторые другие приложения, возможно, использовали эту память для чего-то еще.

Очевидно, что проблема существует. MFC 3.x использовал метод, называемый хранилищем потоков-локальных (TLS). MFC 3.x выделит индекс TLS, который в соответствии с Win32s действительно выступает в качестве процесс-локальный индекс хранения, даже если это не называется, а затем будет ссылаться на все данные, основанные на этом индексе TLS. Это похоже на индекс TLS, который использовался для хранения локальных данных на Win32 (см. ниже для получения дополнительной информации по этому вопросу). Это заставило каждый MFC DLL использовать по крайней мере два индекса TLS за процесс. При загрузке многих DLL-управлений OLE Control (OCXs) быстро иссякнут индексы TLS (доступно всего 64). Кроме того, МФЦ пришлось разместить все эти данные в одном месте, в одной структуре. Он не очень различен и не идеален в том, что касается использования индексов TLS.

MFC 4.x обращается к этому с набором шаблонов классов, которые можно «обернуть» вокруг данных, которые должны быть локальными. Например, упомянутая выше проблема может быть исправлена путем написания:

```cpp
struct CMyGlobalData : public CNoTrackObject
{
    CString strGlobal;
};
CProcessLocal<CMyGlobalData> globalData;

__declspec(dllexport)
void SetGlobalString(LPCTSTR lpsz)
{
    globalData->strGlobal = lpsz;
}

__declspec(dllexport)
void GetGlobalString(LPCTSTR lpsz, size_t cb)
{
    StringCbCopy(lpsz, cb, globalData->strGlobal);
}
```

МФЦ реализует это в два этапа. Во-первых, есть слой поверх Win32 __\* Tls__ AIs **(TlsAlloc**, **TlsSetValue**, **TlsGetValue**и т.д.), которые используют только два индекса TLS за процесс, независимо от того, сколько DLLs у вас есть. Во-вторых, `CProcessLocal` для доступа к этим данным предоставляется шаблон. Он перекрывает оператор-> который является то, что позволяет интуитивно понятный синтаксис вы видите выше. Все объекты, `CProcessLocal` которые обернуты должны быть получены из `CNoTrackObject`. `CNoTrackObject`обеспечивает более низкий уровень аллигатора **(LocalAlloc**/**LocalFree**) и виртуальный деструктор, такой, что MFC может автоматически уничтожить процесс локальных объектов, когда процесс завершается. Такие объекты могут иметь пользовательский деструктор, если требуется дополнительная очистка. Приведенный выше пример не требует его, так как компилятор будет `CString` генерировать деструктор по умолчанию для уничтожения встроенного объекта.

Есть и другие интересные преимущества этого подхода. Не только `CProcessLocal` все объекты уничтожаются автоматически, они не строятся до тех пор, пока они необходимы. `CProcessLocal::operator->`мгновенно горит связанный объект при первом вызове, и не раньше. В приведенном выше примере`strGlobal`это означает, что строка ' `SetGlobalString` `GetGlobalString` не будет построена до первого раза или называется. В некоторых случаях это может помочь сократить время запуска DLL.

## <a name="thread-local-data"></a>Локальные данные потока

Подобно локальным данным обработки, локальные данные потока используются, когда данные должны быть локальными для данного потока. То есть, вам нужен отдельный экземпляр данных для каждого потока, который получает доступ к этим данным. Это может быть использовано во много раз вместо обширных механизмов синхронизации. Если данные не должны быть общими несколькими потоками, такие механизмы могут быть дорогими и ненужными. Предположим, `CString` у нас был объект (так же, как образец выше). Мы можем сделать его локальным `CThreadLocal` потоком, обернув его шаблоном:

```cpp
struct CMyThreadData : public CNoTrackObject
{
    CString strThread;
};
CThreadLocal<CMyThreadData> threadData;

void MakeRandomString()
{
    // a kind of card shuffle (not a great one)
    CString& str = threadData->strThread;
    str.Empty();
    while (str.GetLength() != 52)
    {
        unsigned int randomNumber;
        errno_t randErr;
        randErr = rand_s(&randomNumber);

        if (randErr == 0)
        {
            TCHAR ch = randomNumber % 52 + 1;
            if (str.Find(ch) <0)
            str += ch; // not found, add it
        }
    }
}
```

Если `MakeRandomString` бы он вызывался из двух разных потоков, каждый из них «перетасовал» строку по-разному, не мешая другому. Это связано с `strThread` тем, что на самом деле на поток ею есть экземпляр, а не только один глобальный экземпляр.

Обратите внимание, как ссылка `CString` используется для захвата адреса один раз, а не один раз за цикл итерации. Код цикла мог быть `threadData->strThread` написан`str`везде ' используется, но код был бы гораздо медленнее в исполнении. Лучше всего кэшировать ссылку на данные, когда такие ссылки происходят в циклах.

Шаблон `CThreadLocal` класса использует те же `CProcessLocal` механизмы, что и те же методы реализации.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
