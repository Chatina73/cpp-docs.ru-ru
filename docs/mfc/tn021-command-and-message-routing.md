---
title: TN021. Маршрутизация команд и сообщений
ms.date: 06/28/2018
f1_keywords:
- vc.routing
helpviewer_keywords:
- TN021
- command routing [MFC], technical note TN021
- Windows messages [MFC], routing
ms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307
ms.openlocfilehash: bdd405bda5c0af9e04a50eee4ef5738f3a53259e
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370411"
---
# <a name="tn021-command-and-message-routing"></a>TN021. Маршрутизация команд и сообщений

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой заметке описывается архитектура командной рассылки и диспетчеризации, а также расширенные темы в общей области направления сообщений окон.

Пожалуйста, обратитесь к Visual C, чтобы получить общие сведения об описанных здесь архитектурах, особенно о различии между сообщениями Windows, уведомлениями управления и командами. В этой записке предполагается, что вы хорошо знакомы с проблемами, описанными в печатной документации, и рассматриваются только очень продвинутые темы.

## <a name="command-routing-and-dispatch-mfc-10-functionality-evolves-to-mfc-20-architecture"></a>Командование Повышания и отправки MFC 1.0 Функциональность эволюционирует к MFC 2.0 Архитектура

Windows имеет WM_COMMAND сообщение, которое перегружено для предоставления уведомлений о командах меню, клавишах акселератора и уведомлениях управления диалогом.

MFC 1.0 построен на том, что немного, позволяя обработчик `CWnd` команды (например, "OnFileNew") в производных класса, чтобы получить вызов в ответ на конкретные WM_COMMAND. Это склеивается со структурой данных, называемой картой сообщений, и приводит к очень пространственно-эффективному командованию.

MFC 1.0 также предоставил дополнительную функциональность для отделения уведомлений управления от командных сообщений. Команды представлены 16-битным идентификатором, иногда известным как идентификатор команды. Команды обычно начинаются `CFrameWnd` с (т.е. выбора меню или переведенного ускорителя) и направляются в различные другие окна.

MFC 1.0 использовал командную разгромвию в ограниченном смысле для реализации интерфейса multiple Document Interface (MDI). (Делегат окна окна кадра MDI командует в свое активное окно MDI Child.)

Эта функциональность была обобщена и расширена в MFC 2.0, чтобы позволить командам обрабатываться более широким кругом объектов (а не только оконными объектами). Он обеспечивает более формальную и расширяемую архитектуру для реаутирования сообщений и повторно использует целевую настройку команды не только для обработки команд, но и для обновления объектов uI (например, элементов меню и кнопок панели инструментов), чтобы отразить текущую доступность команды.

## <a name="command-ids"></a>Идентификаторы команд

См визуального СЗ для объяснения процесса командной и связывания. [Техническое примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md) содержит информацию о именованиях идентификаторов.

Мы используем общий префикс "ID_" для идов команд. Иди ими командования являются >0x8000. Строка сообщений или строка состояния будет отображать строку описания команд, если есть ресурс STRINGTABLE с теми же идентификаторами, что и идентификатор команды.

В ресурсах приложения идентификатор команды может отосваться в нескольких местах:

- В одном ресурсе STRINGTABLE, который имеет тот же идентификатор, что и запрос строки сообщений.

- Возможно, во многих ресурсах MENU, которые прикрепляются к элементам меню, которые вызывают ту же команду.

- (ADVANCED) в кнопке диалога для команды GOSUB.

В исходном коде приложения идентификатор команды может отосваться в нескольких местах:

- В вашем РЕСУРСе. H (или другой файл заголовка основного символа) для определения идотов командных данных, относясь к конкретному приложению.

- PERHAPS В массиве идентификаторов, используемом для создания панели инструментов.

- В ON_COMMAND макросе.

- PERHAPS В ON_UPDATE_COMMAND_UI макросе.

В настоящее время единственной реализацией в MFC, которая требует итогов команд, является >0x8000 является реализация диалогов/команд GOSUB.

## <a name="gosub-commands-using-command-architecture-in-dialogs"></a>Команды GOSUB, использующие командную архитектуру в диалогах

Архитектура команд маршрутизаторов и включения команд хорошо работает с окнами кадров, элементами меню, кнопками панели инструментов, кнопками диалоговой панели, другими барами управления и другими элементами пользовательского интерфейса, предназначенными для обновления команд по требованию и маршруту или идентипов управления основной целью команды (обычно основное окно кадра). Эта основная цель команды может по мере необходимости направлять уведомления командования или управления на другие объекты цели командования.

Диалог (модальный или безрежимный) может воспользоваться некоторыми функциями архитектуры команд, если назначить идентификатор управления диалогом соответствующему идентификатору команды. Поддержка диалогов не является автоматической, поэтому, возможно, вам придется написать дополнительный код.

Обратите внимание, что для правильной работы всех этих функций идолдля итоговые идолотки команд должны быть >0x8000. Поскольку многие диалоги могут быть направлены в один и тот же кадр, общие команды должны быть >0x8000, в то время как неразделенные IDCs в определенном диалоге должны быть <0x7FFF.

Вы можете поместить обычную кнопку в обычном модальном диалоге с IDC кнопки, установленной на соответствующий идентификатор команды. Когда пользователь выбирает кнопку, владелец диалога (обычно основное окно кадра) получает команду так же, как и любая другая команда. Это называется командой GOSUB, так как она обычно используется для создания другого диалога (GOSUB первого диалога).

Вы также можете `CWnd::UpdateDialogControls` вызвать функцию в диалоге и передать ее адрес вашего окна основной рамы. Эта функция позволит или отключить элементы управления диалогом в зависимости от того, есть ли у них обработчики команд в кадре. Эта функция автоматически вызывается для баров управления в цикле простоя приложения, но вы должны позвонить ей непосредственно для обычных диалогов, которые вы хотите иметь эту функцию.

## <a name="when-on_update_command_ui-is-called"></a>Когда ON_UPDATE_COMMAND_UI называется

Поддержание включенного/проверенного состояния всех элементов меню программы все время может быть вычислительно дорогостоящей проблемой. Распространенным методом является включение/проверка элементов меню только тогда, когда пользователь выбирает POPUP. Реализация MFC 2.0 `CFrameWnd` обрабатывает сообщение WM_INITMENUPOPUP и использует архитектуру командной routing для определения состояния меню с помощью ON_UPDATE_COMMAND_UI обработчиков.

`CFrameWnd`также обрабатывает сообщение WM_ENTERIDLE для описания текущего элемента меню, выбранного в строке состояния (также известной как строка сообщений).

Структура меню приложения, отредактированная Visual C, используется для представления потенциальных команд, доступных в WM_INITMENUPOPUP время. ON_UPDATE_COMMAND_UI обработчики могут изменить состояние или текст меню, или для продвинутых применений (например, список Файлов MRU или всплывающее меню OLE Verbs), на самом деле изменить структуру меню до того, как меню будет нарисовано.

Такая же обработка ON_UPDATE_COMMAND_UI выполняется для панели инструментов (и других баров управления), когда приложение входит в цикл простоя. Дополнительную информацию о контрольных батончиках можно узнать в *справочнике класса Библиотеки* и [Техническом примечании 31.](../mfc/tn031-control-bars.md)

## <a name="nested-pop-up-menus"></a>Вложенное всплывающее меню

Если вы используете вложенную структуру меню, вы заметите, что обработчик ON_UPDATE_COMMAND_UI для первого элемента меню в всплывающем меню вызывается в двух разных случаях.

Во-первых, он называется для всплывающих меню себя. Это необходимо, потому что всплывающие меню не имеют идентификаторов, и мы используем идентификатор первого пункта меню всплывающее меню для обозначения всего всплывающих меню. В этом случае m_pSubMenu переменной `CCmdUI` *элемента* объекта будет не null и будет указывать на всплывающее меню.

Во-вторых, это называется как раз перед пунктов меню в всплывающем меню должны быть обращены. В этом случае идентификатор относится только к первому пункту меню, а m_pSubMenu переменной *элемента* `CCmdUI` объекта будет NULL.

Это позволяет включить всплывающее меню отличается от его элементов меню, но требует, чтобы вы написали некоторые меню известно код. Например, в вложенном меню со следующей структурой:

```Output
File>
    New>
    Sheet (ID_NEW_SHEET)
    Chart (ID_NEW_CHART)
```

Команды ID_NEW_SHEET и ID_NEW_CHART могут быть независимо включены или отключены. **Новое** всплывающее меню должно быть включено, если включен один из двух.

Обработчик команды для ID_NEW_SHEET (первая команда во всплывающем всплывающем центре) будет выглядеть примерно так:

```cpp
void CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_pSubMenu != NULL)
    {
        // enable entire pop-up for "New" sheet and chart
        BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;
        // CCmdUI::Enable is a no-op for this case, so we
        // must do what it would have done.
        pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex,
            MF_BYPOSITION |
            (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));

        return;
    }
    // otherwise just the New Sheet command
    pCmdUI->Enable(m_bCanCreateSheet);
}
```

Обработчик команды для ID_NEW_CHART будет обычным обработчиком команд обновления и будет выглядеть примерно так:

```cpp
void CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bCanCreateChart);
}
```

## <a name="on_command-and-on_bn_clicked"></a>ON_COMMAND и ON_BN_CLICKED

Макросы карты сообщений для **ON_COMMAND** и **ON_BN_CLICKED** одинаковы. Механизм маршрутирования команд и диспетчеров MFC использует только идентификатор команды, чтобы решить, куда направиться. Уведомления управления с кодом уведомления управления нулю **(BN_CLICKED)** интерпретируются как команды.

> [!NOTE]
> Фактически все сообщения об уведомлении управления проходят через цепочку обработчиков команд. Например, технически возможно написать обработчик уведомлений управления для **EN_CHANGE** в классе документов. Это обычно не целесообразно, потому что практические приложения этой функции немногочисленны, функция не поддерживается ClassWizard, и использование функции может привести к хрупкому коду.

## <a name="disabling-the-automatic-disabling-of-button-controls"></a>Отключение автоматического отключения элементов управления кнопками

Если вы разместите управление кнопкой в диалоговой панели или в диалоге, используя, где вы звоните **CWnd::UpdateDialogControls** самостоятельно, вы заметите, что кнопки, которые не имеют **ON_COMMAND** или **ON_UPDATE_COMMAND_UI** обработчики будут автоматически отключены для вас инфраструктурой. В некоторых случаях вам не нужно будет иметь обработчика, но вы хотите, чтобы кнопка оставалась включенной. Самый простой способ достичь этого — добавить обработчик команды (легко сделать с ClassWizard) и ничего не делать в нем.

## <a name="window-message-routing"></a>Перехивание оконных сообщений

Ниже описаны некоторые более продвинутые темы на классах MFC и как разгром сообщений Windows и другие темы влияют на них. Информация здесь описана лишь кратко. Для получения подробной информации об публичных AIS обратитесь в *Справочник библиотеки класса.* Пожалуйста, обратитесь к исходному коду библиотеки MFC для получения дополнительной информации о деталях реализации.

Пожалуйста, обратитесь к [Техническому примечанию 17](../mfc/tn017-destroying-window-objects.md) для получения подробной информации об очистке окна, очень важной теме для всех классов, полученных **cWnd..**

## <a name="cwnd-issues"></a>CWnd вопросы

Функция члена реализации **CWnd::OnChildNotify** обеспечивает мощную и расширяемую архитектуру для детских окон (также известных как элементы управления), чтобы зацепить или иным образом быть информированным о сообщениях, командах и уведомлениях управления, которые идут их родителю (или «владельцу»). Если окне ребенка (/управление) является самим объектом **C-CWnd,** виртуальная функция **OnChildNotify** называется сначала параметрами исходного сообщения (т.е. структурой **MSG).** Окно ребенка может оставить сообщение в покое, съесть его или изменить сообщение для родителя (редко).

Реализация **CWnd** по умолчанию обрабатывает следующие сообщения и использует крючок **OnChildNotify,** чтобы позволить детским окнам (управлениям) получить первый доступ к сообщению:

- **WM_MEASUREITEM** и **WM_DRAWITEM** (для самостоятельной рисования)

- **WM_COMPAREITEM** и **WM_DELETEITEM** (для самостоятельной рисования)

- **WM_HSCROLL** и **WM_VSCROLL**

- **WM_CTLCOLOR**

- **WM_PARENTNOTIFY**

Вы заметите, что крюк **OnChildNotify** используется для изменения сообщений владельца в саморисованые сообщения.

В дополнение к крючку **OnChildNotify,** сообщения прокрутки имеют дальнейшее поведение по вымысну. Пожалуйста, смотрите ниже для получения более подробной информации о прокрутках баров и источников **WM_HSCROLL** и **WM_VSCROLL** сообщений.

## <a name="cframewnd-issues"></a>CFrameWnd проблемы

Класс **CFrameWnd** обеспечивает большую часть реализации командной передачи и обновления пользовательского интерфейса. Это в первую очередь используется для основного окна кадра приложения **(CWinApp::m_pMainWnd),** но относится ко всем окнам кадра.

Основное окно кадра — это окно с баром меню и является родителем строки состояния или строки сообщений. Пожалуйста, обратитесь к вышеупомянутому обсуждению по командной разгрому и **WM_INITMENUPOPUP.**

Класс **CFrameWnd** обеспечивает управление активным представлением. Следующие сообщения направляются через активное представление:

- Все командные сообщения (активное представление получает первый доступ к ним).

- **WM_HSCROLL** и **WM_VSCROLL** сообщения от баров прокрутки брата (см. ниже).

- **WM_ACTIVATE** (и **WM_MDIACTIVATE** для MDI) превращаются в вызовы в виртуальную функцию **CView::OnActivateView**.

## <a name="cmdiframewndcmdichildwnd-issues"></a>CMDIFrameWnd/CMDIChildWnd Проблемы

Оба класса окон mDI являются выходом из **CFrameWnd** и, следовательно, включены для одного и того же вида командной равения и обновления пользовательского интерфейса, предусмотренного в **CFrameWnd.** В типичном приложении MDI только в окне основной рамы (т.е. **объектCMCM)** содержится панель меню и панель статуса и поэтому является основным источником реализации командной разогнательности.

Общая схема разгрома заключается в том, что активное окно ребенка MDI получает первый доступ к командам. Функции **PreTranslateMessage** по умолчанию обрабатывают таблицы акселераторов как для детских окон MDI (первый) и mDI кадр (второй), а также стандартных ускорителей системы MDI, обычно обрабатываемых **TranslateMDISysAccel** (последний).

## <a name="scroll-bar-issues"></a>Вопросы прокрутки бара

При обработке прокрутки-сообщения **(WM_HSCROLL**/**OnHScroll** и/или **WM_VSCROLL**/**OnVScroll),** следует попытаться написать код обработчика, чтобы он не полагался на то, откуда пришло сообщение панели прокрутки. Это не только общая проблема Windows, так как сообщения прокрутки могут поступать из истинных элементов управления прокрутки или от **WS_HSCROLL**/**WS_VSCROLL** прокрутки баров, которые не являются элементами управления полосой прокрутки.

MFC расширяет это, чтобы прокрутка управления бар будет либо ребенка или братьев и сестер окна прокручивается (на самом деле, родитель / ребенок отношения между прокруткой панели прокрутки и окна прокручивается может быть что угодно). Это особенно важно для общих баров прокрутки с сплиттерокнами. Пожалуйста, обратитесь к [Техническому примечанию 29](../mfc/tn029-splitter-windows.md) для получения подробной информации о реализации **CSplitterWnd,** включая более подробную информацию об общих проблемах панели прокрутки.

На боковой ноте, Есть два **CWnd** производных классов, где стили прокрутки бар, указанные в момент создания в ловушке и не передается в Windows. При перегоне к обычному **творению, WS_HSCROLL** и **WS_VSCROLL** могут быть самостоятельно установлены, но после создания не могут быть изменены. Конечно, вы не должны непосредственно тестировать или устанавливать WS_SCROLL типе биты окна, которые они создали.

Для **CMDIFrameWnd** стили панели прокрутки, которые вы проходите в **create** или **LoadFrame,** используются для создания MDICLIENT. Если вы хотите иметь прокрутки MDICLIENT области (например, менеджер программы Windows) не забудьте установить оба стиля прокрутки бар **(WS_HSCROLL** &#124; **WS_VSCROLL)** для стиля, используемого для создания **CMDIFrameWnd**.

Для **CSplitterWnd** стили прокрутки для сплиттера применяются к специальным общим баркам прокрутки для сплиттерных областей. Для статических окон сплиттера, как правило, не будет устанавливать ни стиль прокрутки бар. Для динамических окон сплиттера, вы, как правило, имеют набор стилей панели прокрутки для направления, которое вы разделите, то есть, **WS_HSCROLL** если вы можете разделить строки, **WS_VSCROLL** если вы можете разделить столбцы.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
