---
description: 'Дополнительные сведения о: TN021. Маршрутизация команд и сообщений'
title: TN021. Маршрутизация команд и сообщений
ms.date: 06/28/2018
f1_keywords:
- vc.routing
helpviewer_keywords:
- TN021
- command routing [MFC], technical note TN021
- Windows messages [MFC], routing
ms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307
ms.openlocfilehash: 3cc481585fa2f1eacc3deb575e163d5a1644002c
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97215850"
---
# <a name="tn021-command-and-message-routing"></a>TN021. Маршрутизация команд и сообщений

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этом заметке описывается архитектура маршрутизации команд и диспетчеризации, а также дополнительные разделы, посвященные маршрутизации сообщений окна общего характера.

Общие сведения об описанных здесь архитектурах см. в Visual C++, особенно в различиях между сообщениями Windows, уведомлениями об управлении и командами. В этом заметке предполагается, что вы знакомы с проблемами, описанными в печатной документации, и решаете только самые сложные темы.

## <a name="command-routing-and-dispatch-mfc-10-functionality-evolves-to-mfc-20-architecture"></a>Маршрутизация команд и отправка функциональных возможностей MFC 1,0 в архитектуру MFC 2,0

В Windows имеется WM_COMMAND сообщение, которое перегружается для предоставления уведомлений о командах меню, сочетаний клавиш и уведомлений элементов управления диалоговых окон.

MFC 1,0 построена немного, позволяя обработчику команд (например, "Онфиленев") в `CWnd` производном классе вызывать метод в ответ на определенные WM_COMMAND. Это происходит вместе со структурой данных, называемой схемой сообщений, и приводит к использованию механизма команд с очень экономным пространством.

В MFC 1,0 также предоставлены дополнительные функции для разделения управляющих уведомлений от командных сообщений. Команды представлены 16-битным ИДЕНТИФИКАТОРом, который иногда называют ИДЕНТИФИКАТОРом команды. Обычно команды запускаются из `CFrameWnd` (т. е. меню выбора или переведенного ускорителя) и направляются в различные окна.

В MFC 1,0 использовалась маршрутизация команд в ограниченном смысле для реализации многодокументного интерфейса (MDI). (Окно фрейма MDI-команд делегирует команды в активное дочернее окно MDI.)

Эта функция была обобщенна и расширена в MFC 2,0, чтобы команды были обработаны с помощью более широкого диапазона объектов (не просто объектов окна). Она предоставляет более формальную и расширяемую архитектуру для маршрутизации сообщений и повторно использует маршрутизацию целевой цели для не только обработки команд, но и для обновления объектов пользовательского интерфейса (например, элементов меню и кнопок панели инструментов) для отражения текущей доступности команды.

## <a name="command-ids"></a>Идентификаторы команд

Описание процесса маршрутизации команд и привязки см. в разделе Visual C++. [Техническое примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md) содержит сведения об ИМЕНОВАНии идентификаторов.

Для идентификаторов команд используется универсальный префикс "ID_". Идентификаторы команд >= 0x8000. Строка сообщения или строка состояния будут содержать строку описания команды, если имеется ресурс STRINGTABLE с теми же идентификаторами, что и у идентификатора команды.

В ресурсах приложения идентификатор команды может отображаться в нескольких местах:

- В одном ресурсе STRINGTABLE с таким же ИДЕНТИФИКАТОРом, как и в строке сообщения.

- В возможно много ресурсов меню, присоединенных к пунктам меню, которые вызывают одну и ту же команду.

- (Дополнительно) в диалоговой кнопке для команды GOSUB.

В исходном коде приложения идентификатор команды может отображаться в нескольких местах:

- В РЕСУРСе. H (или другой основной заголовочный файл символов) для определения идентификаторов команд, зависящих от приложения.

- ВОЗМОЖНО, в массиве ИДЕНТИФИКАТОРов, который используется для создания панели инструментов.

- В макросе ON_COMMAND.

- ВОЗМОЖНО, в макросе ON_UPDATE_COMMAND_UI.

В настоящее время единственной реализацией в MFC, требующей идентификаторы команд, является >= 0x8000 — это реализация методов и команд GOSUB.

## <a name="gosub-commands-using-command-architecture-in-dialogs"></a>Команды GOSUB, использование архитектуры команд в диалоговых окнах

Архитектура команд маршрутизации и включения команд хорошо работает с окнами фрейма, элементами меню, кнопками панели инструментов, кнопками диалогового окна, другими панелями управления и другими элементами пользовательского интерфейса, предназначенными для обновления по запросу и команд маршрутизации или идентификаторов элементов управления на основной целевой объект команды (обычно это главное окно фрейма). Эта основная цель команды может маршрутизировать команду или элемент управления уведомлениями к другим целевым объектам команды, если это уместно.

Диалоговое окно (модальное или немодальное) может воспользоваться некоторыми из функций архитектуры команд, если назначить идентификатор элемента управления диалогового окна соответствующему ИДЕНТИФИКАТОРу команды. Поддержка диалоговых окон не является автоматическим, поэтому может потребоваться написать дополнительный код.

Обратите внимание, что для правильной работы всех этих функций идентификаторы команд должны быть >= 0x8000. Так как многие диалоговые окна могут направляться в один и тот же кадр, общие команды должны быть >= 0x8000, а несовместное Идкс в определенном диалоговом окне — <= 0x7FFF.

Обычную кнопку можно поместить в нормальном модальном диалоговом окне, в котором для кнопки задан соответствующий идентификатор команды. Когда пользователь нажимает кнопку, владелец диалогового окна (обычно это окно главного фрейма) получает команду, как и любую другую команду. Это называется командой GOSUB, так как обычно используется для открытия другого диалогового окна (GOSUB первого диалогового окна).

Вы также можете вызвать функцию `CWnd::UpdateDialogControls` в диалоговом окне и передать ей адрес главного окна фрейма. Эта функция включит или отключит элементы управления диалогового окна в зависимости от того, есть ли у них обработчики команд в кадре. Эта функция вызывается автоматически для панелей управления в цикле бездействия приложения, но ее необходимо вызывать непосредственно для обычных диалоговых окон, для которых требуется эта функция.

## <a name="when-on_update_command_ui-is-called"></a>При вызове ON_UPDATE_COMMAND_UI

Поддержание включенного или отмеченного состояния всех пунктов меню программы все время может быть ресурсоемкой проблемой. Распространенный прием заключается в включении или проверке пунктов меню, только когда пользователь выбирает всплывающее окно. Реализация MFC 2,0 `CFrameWnd` обрабатывает сообщение WM_INITMENUPOPUP и использует архитектуру маршрутизации команд для определения состояний меню с помощью обработчиков ON_UPDATE_COMMAND_UI.

`CFrameWnd` также обрабатывает сообщение WM_ENTERIDLE, описывающее текущий пункт меню, выбранный в строке состояния (также называемой строкой сообщения).

Структура меню приложения, измененная Visual C++, используется для представления потенциальных команд, доступных во время WM_INITMENUPOPUP. Обработчики ON_UPDATE_COMMAND_UI могут изменять состояние или текст меню, а также для расширенного использования (например, списка MRU-файлов или всплывающего меню «команды OLE»), фактически изменяют структуру меню перед прорисовкой меню.

Та же сортировка ON_UPDATE_COMMAND_UI выполняется для панелей инструментов (и других панелей элементов управления), когда приложение переходит в цикл бездействия. Дополнительные сведения о панелях управления см. в *справочнике по библиотеке классов* и в [технической заметке 31](../mfc/tn031-control-bars.md) .

## <a name="nested-pop-up-menus"></a>Вложенные всплывающие меню

При использовании вложенной структуры меню можно заметить, что обработчик ON_UPDATE_COMMAND_UI для первого пункта меню во всплывающем меню вызывается в двух разных случаях.

Во-первых, он вызывается для всплывающего меню. Это необходимо, так как всплывающие меню не имеют идентификаторов, и мы используем идентификатор первого пункта меню во всплывающем меню для ссылки на все всплывающее меню. В этом случае переменная-член *m_pSubMenu* `CCmdUI` объекта будет иметь значение, отличное от NULL, и будет указывать на всплывающее меню.

Во-вторых, он вызывается непосредственно перед прорисовкой пунктов меню во всплывающем меню. В этом случае идентификатор ссылается только на первый элемент меню, а переменная члена *m_pSubMenu* `CCmdUI` объекта будет иметь значение null.

Это позволяет включать всплывающее меню, отличающееся от пунктов меню, но требует написания какого-либо кода, поддерживающего меню. Например, во вложенном меню со следующей структурой:

```Output
File>
    New>
    Sheet (ID_NEW_SHEET)
    Chart (ID_NEW_CHART)
```

Команды ID_NEW_SHEET и ID_NEW_CHART могут быть независимо включены или отключены. **Новое** всплывающее меню должно быть включено, если одно из этих двух включено.

Обработчик команд для ID_NEW_SHEET (первая команда во всплывающем окне) будет выглядеть примерно следующим образом:

```cpp
void CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_pSubMenu != NULL)
    {
        // enable entire pop-up for "New" sheet and chart
        BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;
        // CCmdUI::Enable is a no-op for this case, so we
        // must do what it would have done.
        pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex,
            MF_BYPOSITION |
            (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));

        return;
    }
    // otherwise just the New Sheet command
    pCmdUI->Enable(m_bCanCreateSheet);
}
```

Обработчик команд для ID_NEW_CHART будет обычным обработчиком команды обновления и выглядеть примерно так:

```cpp
void CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bCanCreateChart);
}
```

## <a name="on_command-and-on_bn_clicked"></a>ON_COMMAND и ON_BN_CLICKED

Макросы схемы сообщений для **ON_COMMAND** и **ON_BN_CLICKED** одинаковы. Механизм маршрутизации уведомлений и команд MFC использует только идентификатор команды для принятия решения о том, куда следует направлять. Уведомления об элементах управления с нулевым кодом уведомления (**BN_CLICKED**) обрабатываются как команды.

> [!NOTE]
> Фактически все контрольные сообщения управления проходят через цепочку обработчиков команд. Например, технически можно написать обработчик уведомлений элемента управления для **EN_CHANGE** в классе документа. Обычно это не рекомендуется, так как практические приложения этой функции не поддерживаются ClassWizard, и использование этой функции может привести к нежелательному коду.

## <a name="disabling-the-automatic-disabling-of-button-controls"></a>Отключение автоматического отключения элементов управления "Кнопка"

При помещении элемента управления Button на панель диалогового окна или в диалоговом окне, в котором вы вызываете **CWnd:: упдатедиалогконтролс** , вы заметите, что кнопки, которые не имеют обработчиков **ON_COMMAND** или **ON_UPDATE_COMMAND_UI** , будут автоматически отключены платформой. В некоторых случаях обработчик не нужен, но вы хотите, чтобы кнопка оставалась включенной. Самый простой способ добиться этого — добавить фиктивный обработчик команд (простая задача с ClassWizard) и ничего делать не нужно.

## <a name="window-message-routing"></a>Маршрутизация сообщений окна

Ниже описаны некоторые более сложные разделы о классах MFC, а также влияние маршрутизации сообщений Windows и других тем. Эти сведения кратко описаны только в этой статье. Дополнительные сведения об общедоступных API см. в *справочнике по библиотеке классов* . Дополнительные сведения о реализации см. в исходном коде библиотеки MFC.

Дополнительные сведения об очистке окон см. в [техническом примечании 17](../mfc/tn017-destroying-window-objects.md) . это очень важный раздел для всех классов, производных от **CWnd**.

## <a name="cwnd-issues"></a>Проблемы CWnd

Функция-член **CWnd:: ончилднотифи** предоставляет мощную и расширяемую архитектуру для дочерних окон (также известных как элементы управления) для обработки сообщений, команд и управления уведомлениями, которые переходят к их родителю (или владельцу). Если дочернее окно (/контрол) представляет собой объект C++ **CWnd** , то виртуальная функция **ончилднотифи** вызывается сначала с параметрами исходного сообщения (то есть структуры **MSG** ). Дочернее окно может оставить только сообщение, EAT или изменить сообщение для родителя (редко).

Реализация **CWnd** по умолчанию обрабатывает следующие сообщения и использует обработчик **ончилднотифи** , чтобы разрешить дочерним окнам (элементам управления) первый доступ к сообщению:

- **WM_MEASUREITEM** и **WM_DRAWITEM** (для самостоятельного рисования)

- **WM_COMPAREITEM** и **WM_DELETEITEM** (для самостоятельного рисования)

- **WM_HSCROLL** и **WM_VSCROLL**

- **WM_CTLCOLOR**

- **WM_PARENTNOTIFY**

Обратите внимание, что обработчик **ончилднотифи** используется для изменения прорисовки сообщений, рисуемых владельцем, в сообщениях с саморисованием.

Помимо обработчика **ончилднотифи** , сообщения прокрутки имеют дальнейшие действия по маршрутизации. Дополнительные сведения о столбцах прокрутки и источниках **WM_HSCROLL** и **WM_VSCROLL** сообщений см. ниже.

## <a name="cframewnd-issues"></a>Проблемы с CFrameWnd

Класс **CFrameWnd** обеспечивает большую часть маршрутизации команд и реализации обновления пользовательского интерфейса. Это в основном используется для основного окна фрейма приложения (**CWinApp:: m_pMainWnd**), но применяется ко всем окнам фрейма.

Главное окно фрейма — это окно с строкой меню, которое является родительским по отношению к строке состояния или строке сообщения. См. описанное выше обсуждение маршрутизации команд и **WM_INITMENUPOPUP.**

Класс **CFrameWnd** обеспечивает управление активным представлением. Следующие сообщения направляются через активное представление:

- Все командные сообщения (активное представление получает первый доступ к ним).

- **WM_HSCROLL** и **WM_VSCROLL** сообщения от родственных полос прокрутки (см. ниже).

- **WM_ACTIVATE** (и **WM_MDIACTIVATE** для MDI) преобразуются в вызовы виртуальной функции **CView:: онактиватевиев**.

## <a name="cmdiframewndcmdichildwnd-issues"></a>Проблемы CMDIFrameWnd и CMDIChildWnd

Оба класса окон фрейма MDI являются производными от **CFrameWnd** и, следовательно, включены для одинакового рода маршрутизации команд и обновления пользовательского интерфейса, предоставляемого в классе **CFrameWnd**. В типичном приложении MDI только главное окно фрейма (то есть объект **CMDIFrameWnd** ) содержит строку меню и строку состояния, а значит основной источник реализации маршрутизации команд.

Общая схема маршрутизации заключается в том, что активное дочернее окно MDI получает первый доступ к командам. Функции **претранслатемессаже** по умолчанию обрабатывают таблицы ускорителя как для дочерних окон MDI (First), так и для фрейма MDI (второй), а также стандартные системные ускорители интерфейса MDI, обычно обрабатываемые **транслатемдисисакцел** (Last).

## <a name="scroll-bar-issues"></a>Проблемы с полосой прокрутки

При обработке сообщения Scroll (**WM_HSCROLL** / **онхскролл** и (или) **WM_VSCROLL** / **онвскролл**) следует попытаться написать код обработчика, чтобы он не повисел от того, откуда поступило сообщение с полосой прокрутки. Это не только общая проблема Windows, так как сообщения прокрутки могут поступать из элементов управления "полоса прокрутки" или из **WS_HSCROLL** / **WS_VSCROLL** полос прокрутки, не являющихся элементами управления "полоса прокрутки

MFC расширяет это, позволяя элементам управления "полоса прокрутки" быть либо дочерними, либо одноуровневыми элементами перемещаемого окна (на самом деле, между полосой прокрутки и окном может быть что-то другое). Это особенно важно для общих полос прокрутки с окнами-разделителями. Дополнительные сведения о реализации **CSplitterWnd** , включая дополнительную информацию о проблемах с общей полосой прокрутки, см. в [техническом примечании 29](../mfc/tn029-splitter-windows.md) .

Обратите внимание, что существует два производных класса **CWnd** , где стили полосы прокрутки, заданные во время создания, перехватываются и не передаются в Windows. При передаче в подпрограммы создания **WS_HSCROLL** и **WS_VSCROLL** могут быть заданы независимо, но после создания изменить нельзя. Конечно, не следует напрямую тестировать или задавать WS_SCROLLные биты стиля окна, которые они создали.

Для **CMDIFrameWnd** стили полосы прокрутки, передаваемые в **CREATE** или **ЛОАДФРАМЕ** , используются для создания мдиклиент. Если вы хотите иметь прокручиваемую область МДИКЛИЕНТ (например, диспетчер программ Windows), убедитесь, что для стиля, используемого для создания **CMDIFrameWnd**, заданы оба стиля полосы прокрутки (**WS_HSCROLL** &#124; **WS_VSCROLL**).

Для **CSplitterWnd** стили полосы прокрутки применяются к Специальным общим полосам прокрутки для областей разделителя. Для статических окон разделителей обычно не устанавливается ни один из стилей полосы прокрутки. Для динамических окон-разделителей обычно используется стиль полосы прокрутки, установленный для направления, которое будет разбито, то есть **WS_HSCROLL** , если можно разбить строки, **WS_VSCROLL** если можно разбить столбцы.

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
