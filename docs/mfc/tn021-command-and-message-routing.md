---
title: TN021. Маршрутизация команд и сообщений
ms.date: 06/28/2018
f1_keywords:
- vc.routing
helpviewer_keywords:
- TN021
- command routing [MFC], technical note TN021
- Windows messages [MFC], routing
ms.assetid: b5952c8b-123e-406c-a36d-a6ac7c6df307
ms.openlocfilehash: 4a0774234e6314ff6811bbeafa11403f19cf568e
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50635712"
---
# <a name="tn021-command-and-message-routing"></a>TN021. Маршрутизация команд и сообщений

> [!NOTE]
>  Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Эта заметка описывает архитектура маршрутизации и диспетчеризации команд, а также дополнительные разделы в общие окно маршрутизации сообщений.

Обратитесь к Visual C++ для Общие сведения об архитектурах, описанные здесь, особенно различие между сообщения, уведомления элементов управления и команд Windows. Эта заметка предполагается, что вы уже знакомы с проблемы, описанные в печатной документации и рассматриваются только очень сложные темы.

## <a name="command-routing-and-dispatch-mfc-10-functionality-evolves-to-mfc-20-architecture"></a>Маршрутизация команд и диспетчеризации MFC 1.0 функциональные возможности развития с MFC 2.0 архитектуры

Windows имеет сообщение WM_COMMAND, которое перегружен, чтобы рассылать уведомления об команды меню, сочетания клавиш и уведомлений элементов управления диалогового окна.

1.0 с MFC на основе, немного, позволяя обработчик команд (например, «OnFileNew») `CWnd` производного класса, чтобы получить вызывается в ответ на определенные WM_COMMAND. Это клееных вместе со структурой данных, именем схемы сообщений и приводит к очень экономящую команда механизм.

1.0 с MFC также предоставляются дополнительные возможности для разделения уведомления элементов управления из командных сообщений. Команды представлены по Идентификатору 16-разрядное, которую иногда называют ИД команды. Запуск команды `CFrameWnd` (то есть меню выберите пункт или переведенных accelerator) и будут направляться на ряд других окон.

MFC 1.0 используется маршрутизация команд в ограниченной степени для реализации из многодокументного интерфейса (MDI). (В окне фрейма MDI делегировать команды, чтобы его активного окна дочерней MDI-формы).

Эта функциональность была универсальных и расширено в MFC 2.0, чтобы разрешить команды будут обрабатываться более широкий набор объектов (не только окно). Он предоставляет более формальном и расширяемую архитектуру для маршрутизации сообщений и повторно использует целевой маршрутизации команд не только обработки команд, но и для обновления объектов пользовательского интерфейса (например, пункты меню и кнопки панели инструментов) в соответствии с текущей доступности команды .

## <a name="command-ids"></a>Идентификаторы команд

См. в разделе Visual C++ описание команды маршрутизации и процесс привязки. [Техническое Примечание 20](../mfc/tn020-id-naming-and-numbering-conventions.md) содержит сведения об именовании Идентификаторов.

Мы используем универсальные префикс «ID_» ИД команд. Идентификаторы команд, > = 0x8000. Линия "или" состояние панели сообщений отобразит строку описание команды имеется ли STRINGTABLE ресурс с тем же идентификатором как идентификатор команды.

В ресурсы приложения команды могут идентификатор отображается в нескольких местах:

- В один ресурс STRINGTABLE, имеет тот же идентификатор, как строки сообщения.

- В возможно множество меню ресурсов, подключенных к пунктам меню, которые вызывают ту же команду.

- (ДОПОЛНИТЕЛЬНО) в диалоговое окно кнопку GOSUB команды.

В исходном коде приложения команды могут идентификатор отображается в нескольких местах:

- В РЕСУРСЕ. H (или других главного файла символов заголовков) для определения идентификаторов команд для конкретного приложения.

- ВОЗМОЖНО, в массив идентификатор, используемый для создания панели инструментов.

- В ON_COMMAND-макрос.

- ВОЗМОЖНО в макрос ON_UPDATE_COMMAND_UI.

В настоящее время единственной реализацией в MFC, которая требует идентификаторы команд быть > = 0x8000 является реализацией GOSUB диалоговые окна и команды.

## <a name="gosub-commands-using-command-architecture-in-dialogs"></a>GOSUB команды, с помощью команды архитектуры в диалоговых окнах

Команда архитектура маршрутизации и разрешающее команды хорошо работает с окна фрейма, пункты меню, кнопки панели инструментов, кнопки диалоговой панели, других панелей элементов управления и других элементов пользовательского интерфейса, предназначенных для обновления по запросу и маршрут, командам или идентификаторов элементов управления в главное целевой объект команды (обычно фрейма главного окна). Предназначенных основную команду может направить уведомления команды или элемента управления другие целевые объекты команды, соответствующим образом.

Диалоговое окно (модальное или немодальное) могут использовать преимущества некоторых функций архитектуры команда идентификатор элемента управления диалогового окна управления назначается идентификатор соответствующие команды. Поддержка диалоговых окон не происходит автоматически, поэтому необходимо написать дополнительный код.

Обратите внимание, что для всех этих функций для правильной работы вашей команды должен быть > = 0x8000. Поскольку многие диалоговые окна может перенаправляться в рамке, общих команд должно быть > = 0x8000, хотя должен быть не совместно IDCs в конкретном диалоговом окне < = 0x7FFF.

Можно поместить обычную кнопку в обычном модальное диалоговое окно с компанией IDC, кнопки, присваивается идентификатор соответствующие команды. Когда пользователь выбирает кнопку, владельца диалогового окна (обычно фрейма главного окна) получает команду, так же, как и любые другие команды. Это называется GOSUB команды, так как он обычно используется откроется другое диалоговое окно (GOSUB первое диалоговое окно).

Можно также вызвать функцию `CWnd::UpdateDialogControls` на диалоговое окно и передать ему адрес фрейма главного окна. Эта функция будет включение или отключение элементов управления диалоговых окон, в зависимости от наличия у них обработчики команд в кадре. Эта функция вызывается автоматически для вас для панелей элементов управления в цикл простоя приложения, но вы должны вызывать непосредственно для обычного диалоговых окон, которые вы хотите добавить эту функцию.

## <a name="when-onupdatecommandui-is-called"></a>При вызове ON_UPDATE_COMMAND_UI

Поддержание состояния включена проверка пунктов меню программы постоянно может быть ресурсоемкую проблемой. Это распространенный способ — включить/проверку элементов меню только в том случае, когда пользователь выбирает всплывающего ОКНА. Реализация MFC 2.0 `CFrameWnd` обрабатывает сообщение WM_INITMENUPOPUP и используется архитектура маршрутизации команды для определения состояния меню посредством ON_UPDATE_COMMAND_UI обработчиков.

`CFrameWnd` обрабатывает сообщение WM_ENTERIDLE для описания текущего меню выбранного элемента на строки состояния (также известный как сообщение).

Структура приложения меню, изменить с помощью Visual C++ используется для представления потенциальных команд, доступных во время WM_INITMENUPOPUP. ON_UPDATE_COMMAND_UI обработчики можно изменить состояние или текст меню или для сложных вариантов использования (например, список последних Использованных файлов или всплывающего меню команд OLE), фактически следует изменить структуру меню перед рисованием меню.

Такого же рода ON_UPDATE_COMMAND_UI обработки выполняется для панели инструментов (и других панелей элементов управления) при приложение входит в цикл его простоя. См. в разделе *Справочник по библиотеке классов* и [Технические примечания 31](../mfc/tn031-control-bars.md) Дополнительные сведения о панели элементов управления.

## <a name="nested-pop-up-menus"></a>Вложенные всплывающих меню

При использовании структуры вложенных меню, можно заметить, что в двух разных случаях вызывается обработчик ON_UPDATE_COMMAND_UI для первого элемента меню в контекстном меню.

Во-первых он вызывается для самого всплывающего меню. Это необходимо, так как всплывающее меню не имеют идентификаторов, и мы используем идентификатор первого элемента меню из контекстного меню для ссылки на весь во всплывающем меню. В этом случае *m_pSubMenu* переменной-члена `CCmdUI` объект будет иметь значение NULL и будет указывать во всплывающем меню.

Во-вторых он вызывается непосредственно перед должны быть изображены пунктов контекстного меню. В этом случае идентификатор относится только к первому элементу меню и *m_pSubMenu* переменной-члена `CCmdUI` объект будет иметь значение NULL.

Это позволяет включить в раскрывающемся меню, отличающийся от его элементами меню, но требует написания кода виду меню. Например в вложенных меню со следующей структурой:

```Output
File>
    New>
    Sheet (ID_NEW_SHEET)
    Chart (ID_NEW_CHART)
```

Команды ID_NEW_SHEET и ID_NEW_CHART можно независимо друг от друга включается и отключается. **New** во всплывающем меню должен быть включен, при любой из двух включен.

Обработчик команд для ID_NEW_SHEET (первая команда во всплывающем окне) будет выглядеть следующим образом:

```cpp
void CMyApp::OnUpdateNewSheet(CCmdUI* pCmdUI)
{
    if (pCmdUI->m_pSubMenu != NULL)
    {
        // enable entire pop-up for "New" sheet and chart
        BOOL bEnable = m_bCanCreateSheet || m_bCanCreateChart;
        // CCmdUI::Enable is a no-op for this case, so we
        // must do what it would have done.
        pCmdUI->m_pMenu->EnableMenuItem(pCmdUI->m_nIndex,
            MF_BYPOSITION |
            (bEnable  MF_ENABLED : (MF_DISABLED | MF_GRAYED)));

        return;
    }
    // otherwise just the New Sheet command
    pCmdUI->Enable(m_bCanCreateSheet);
}
```

Обработчик команд для ID_NEW_CHART будет обычного обновления обработчик команд и внешний вид, что-то наподобие:

```cpp
void CMyApp::OnUpdateNewChart(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bCanCreateChart);
}
```

## <a name="oncommand-and-onbnclicked"></a>ON_COMMAND и ON_BN_CLICKED

Макросы схемы сообщений для **ON_COMMAND** и **ON_BN_CLICKED** одинаковы. Идентификатор команды использует MFC команды и управление маршрутизации механизм уведомлений только выбрать место для маршрутизации. Управлять уведомлениями нулевым кодом уведомление элемента управления (**BN_CLICKED**) интерпретируются как команды.

> [!NOTE]
> На самом деле все уведомляющих сообщений элемента управления перейдите по цепочке обработчика команды. Например, это технически возможно написание обработчика уведомлений элемента управления **EN_CHANGE** в классе документа. Это не обычно рекомендуется, так как несколько Практическое применение этой функции, функция не поддерживается в ClassWizard и использования функции может привести к уязвимости кода.

## <a name="disabling-the-automatic-disabling-of-button-controls"></a>Отключение автоматическое отключение элемента управления Button

Если вы поместили элемент управления "Кнопка" на панели диалогового окна, или в диалоговом окне Использование предложения where вы вызываете **CWnd::UpdateDialogControls** самостоятельно, вы заметите, что кнопки, которые не имеют **ON_COMMAND** или **ON_UPDATE_COMMAND_UI** обработчики автоматически отключаются для вас платформой. В некоторых случаях не требуется иметь обработчик, но требуется кнопку, чтобы оставаться включенными. Для этого проще всего добавить обработчик фиктивный команд (легко сделать с помощью ClassWizard) и не выполнять никаких действий, в нем.

## <a name="window-message-routing"></a>Маршрутизация сообщений окна

Ниже описываются некоторые более сложные темы на классы MFC и маршрутизации сообщений Windows и другим темам влияние их. Приведенные здесь сведения только кратко описана. Ссылаться на *Справочник по библиотеке классов* Дополнительные сведения об общедоступных интерфейсов API. См. исходный код библиотеки MFC, Дополнительные сведения о реализации.

Обратитесь к [технические 17 Примечание](../mfc/tn017-destroying-window-objects.md) для сведения при очистке окна "," раздел очень важно для всех **CWnd**-производные классы.

## <a name="cwnd-issues"></a>Проблемы CWnd

Функция-член реализации **CWnd::OnChildNotify** предоставляет мощный и расширяемый язык архитектуру для дочерних окон (также известный как элементы управления) для подключения или в противном случае следует сообщить всем сообщения, команд и управления уведомления, которые необходимо выполнить их родительский (или «владелец»). Если дочернее окно (элемент управления /) является языка C++ **CWnd** объекта, виртуальная функция **OnChildNotify** сначала вызывается с параметрами из исходного сообщения (то есть **MSG**структуры). Дочернее окно может переключать сообщение, он есть или измените текст сообщения для родительского элемента (такие случаи редки).

Значение по умолчанию **CWnd** реализация обрабатывает следующие сообщения и использует **OnChildNotify** обработчик, необходимо разрешить дочернего окна (элементы управления) для первого доступ, сообщение:

- **WM_MEASUREITEM** и **WM_DRAWITEM** (для самостоятельно нарисовать)

- **WM_COMPAREITEM** и **WM_DELETEITEM** (для самостоятельно нарисовать)

- **Сообщения WM_HSCROLL** и **WM_VSCROLL**

- **WM_CTLCOLOR**

- **WM_PARENTNOTIFY**

Обратите внимание, **OnChildNotify** ловушка служит для изменения сообщения рисования владельцем в самостоятельно нарисовать сообщения.

В дополнение к **OnChildNotify** перехватчик прокрутки сообщения имеют дополнительной маршрутизации поведение. Дополнительные сведения см. ниже дополнительные сведения о полосы прокрутки и источники **сообщения WM_HSCROLL** и **WM_VSCROLL** сообщений.

## <a name="cframewnd-issues"></a>Проблемы CFrameWnd

**CFrameWnd** класс предоставляет большинство маршрутизация команд и пользовательского интерфейса обновления реализации. Это в основном используется для фрейма главного окна приложения (**CWinApp::m_pMainWnd**), но применяется для всех окон фрейма.

Главное окно является окном с меню и является родителем строки состояния или сообщений строки. См. выше обсуждение маршрутизация команд и **WM_INITMENUPOPUP.**

**CFrameWnd** класс обеспечивает управление активное представление. Следующие сообщения направляются через активное представление:

- Все сообщения команды (активное представление получает первый доступ к ним).

- **Сообщения WM_HSCROLL** и **WM_VSCROLL** полосы (см. ниже) отображаются сообщения из того же уровня.

- **WM_ACTIVATE** (и **WM_MDIACTIVATE** для MDI) получить преобразуются в вызовы виртуальной функции **CView::OnActivateView**.

## <a name="cmdiframewndcmdichildwnd-issues"></a>Проблемы CMDIFrameWnd/CMDIChildWnd

Оба классы окна фрейма MDI являются производными от **CFrameWnd** и поэтому включены для такого же рода маршрутизация команд и обновление пользовательского интерфейса в **CFrameWnd**. В типичном приложении MDI, только окно главного фрейма (то есть **CMDIFrameWnd** объекта) содержит меню и строка состояния и поэтому является основным источником реализации маршрутизации команды.

Общая схема маршрутизации —, передадим первый доступ к командам в активную дочернюю MDI. Значение по умолчанию **PreTranslateMessage** функции обрабатывают таблицы сочетаний клавиш для обоих дочерних окон интерфейса MDI (first) и рамку MDI (второго), а также стандартные ускорители системная команда MDI, обычно обрабатываются с  **TranslateMDISysAccel** (последней).

## <a name="scroll-bar-issues"></a>Проблемы полосы прокрутки

При обработке сообщения прокрутки (**сообщения WM_HSCROLL**/**OnHScroll** и/или **WM_VSCROLL**/**OnVScroll**), следует написать код обработчика, поэтому он не зависит от происхождения прокрутки панели сообщения. Это не только общие Windows проблема, так как сообщения прокрутки могут поступать из true прокрутки, панель элементов управления или из **WS_HSCROLL**/**WS_VSCROLL** не являющиеся элементов управления полосы прокрутки полосы прокрутки.

Расширяет MFC, чтобы разрешить для элементов управления полосы прокрутки дочерние или одноуровневые элементы окна с возможностью прокрутки (на самом деле, иерархическое отношение между полосы прокрутки и возможностью прокрутки окна может быть что-либо). Это особенно важно для полос прокрутки общего с окна разделителей. Обратитесь к [технические 29 Примечание](../mfc/tn029-splitter-windows.md) Дополнительные сведения о реализации **CSplitterWnd** Включение Дополнительные сведения на общих проблем панель прокрутки.

Кстати, существует два **CWnd** производных классов, где стили полосы прокрутки, указанного во время создания перехват и не передаются в Windows. При передаче в процедуре создания **WS_HSCROLL** и **WS_VSCROLL** может устанавливаться независимо друг от друга, но после создания не может быть изменено. Само собой следует не напрямую тестирования или набор битов стиля WS_SCROLL окна, которое они созданы.

Для **CMDIFrameWnd** стили полосы прокрутки, переданного **создать** или **LoadFrame** используются для создания MDICLIENT. Если вы хотите иметь прокручиваемой MDICLIENT области (такие как Windows программа Manager) не забудьте задать оба полоса прокрутки стили (**WS_HSCROLL** &#124; **WS_VSCROLL**) для стиль, используемый для создания **CMDIFrameWnd**.

Для **CSplitterWnd** применить стили полосы прокрутки для полосы прокрутки специальные общей для разделения областей. Для windows со статическим разделителем обычно не будет устанавливать любой стиль строки прокрутки. Для окна с динамическими разделителями, обычно имеет прокрутка набор стилей для направления, вы разделите, то есть **WS_HSCROLL** возможность распределения строк, **WS_VSCROLL** Если можно разделить столбцы.

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
