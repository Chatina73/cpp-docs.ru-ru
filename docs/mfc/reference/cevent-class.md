---
title: Класс CEvent
ms.date: 11/04/2016
f1_keywords:
- CEvent
- AFXMT/CEvent
- AFXMT/CEvent::CEvent
- AFXMT/CEvent::PulseEvent
- AFXMT/CEvent::ResetEvent
- AFXMT/CEvent::SetEvent
- AFXMT/CEvent::Unlock
helpviewer_keywords:
- CEvent [MFC], CEvent
- CEvent [MFC], PulseEvent
- CEvent [MFC], ResetEvent
- CEvent [MFC], SetEvent
- CEvent [MFC], Unlock
ms.assetid: df676042-ce27-4702-800a-e73ff4f44395
ms.openlocfilehash: 883f3065c9d15ad793e6c0d548b911f10d166c0a
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50667904"
---
# <a name="cevent-class"></a>Класс CEvent

Представляет событие, которое — объект синхронизации, позволяющий одному потоку известить другой, что произошло событие поток.

## <a name="syntax"></a>Синтаксис

```
class CEvent : public CSyncObject
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CEvent::CEvent](#cevent)|Создает объект `CEvent`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CEvent::PulseEvent](#pulseevent)|Наборы события доступны (сигнал), освобождает потоков в состоянии ожидания и задает событие в состояние недоступности (несигнальное).|
|[CEvent::ResetEvent](#resetevent)|Задает событие в состояние недоступности (несигнальное).|
|[CEvent::SetEvent](#setevent)|Задает событие недоступен (сигнальное) и освобождает все ожидающие потоки.|
|[CEvent::Unlock](#unlock)|Освобождает объект события.|

## <a name="remarks"></a>Примечания

События полезны в тех случаях, когда поток должны знать, что для выполнения задачи. Например поток, в котором данные копируются в архив данных необходимо быть уведомление о наличии новых данных. С помощью `CEvent` объекту уведомлять копирования поток, когда новые данные доступны, поток мог выполнить свою задачу, как можно скорее.

`CEvent` объекты имеют два типа: ручная и автоматическая.

Автоматическое `CEvent` объект автоматически возвращает несигнальное состояние (недоступно) после выпуска по крайней мере один поток. По умолчанию `CEvent` объекта выполняется автоматически только при проведении `TRUE` для *bManualReset* параметра во время построения.

Вручную `CEvent` остается в состоянии, установленном [выполнить SetEvent](#setevent) или [ResetEvent](#resetevent) до вызова другой функции. Для создания вручную `CEvent` , передать `TRUE` для `bManualReset` параметра во время построения.

Чтобы использовать `CEvent` объекта, создания `CEvent` объекта при необходимости. Укажите имя события для ожидания, а также указать, что приложение должно изначально он принадлежит. Вы можете обращаться к событие во время завершения работы конструктор возвращает. Вызовите [выполнить SetEvent](#setevent) сигнал (предоставлять доступ) объект события, а затем вызовите метод [Unlock](#unlock) после получения доступа к управляемой ресурсу.

Альтернативный метод с помощью `CEvent` объектов заключается в добавлении переменной типа `CEvent` как элемент данных, к классу, который вы хотите управлять. Во время создания управляемого объекта, вызовите конструктор `CEvent` элемент данных и укажите ли изначально сигнала события, а также specifythe тип добавляемого события объекта, имя события (если он будет использоваться всех этапах процесса границы) и другие атрибуты безопасности, требуется.

Для доступа к ресурсу, контролируются `CEvent` объекта таким образом, сначала создайте переменную типа [CSingleLock](../../mfc/reference/csinglelock-class.md) или тип [CMultiLock](../../mfc/reference/cmultilock-class.md) в методе доступа ресурса. Затем вызовите `Lock` метод объекта блокировок (например, [CMultiLock::Lock](../../mfc/reference/cmultilock-class.md#lock)). На этом этапе поток будет либо получить доступ к ресурсу, ожидания ресурса для освобождаться и получить доступ или ожидания освобождения ресурса, время ожидания и не смогут получить доступ к ресурсу. В любом случае ресурс уже был осуществлен потокобезопасным способом. Для освобождения ресурса, вызовите `SetEvent` сигнала объект события, а затем использовать `Unlock` метод объекта блокировок (например, [CMultiLock::Unlock](../../mfc/reference/cmultilock-class.md#unlock)), или позволить блокировок объекта блокировок само выходит из области.

Дополнительные сведения об использовании `CEvent` объектов, см. в разделе [Многопоточность: Практическое использование классов синхронизации](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).

## <a name="example"></a>Пример

[!code-cpp[NVC_MFC_Utilities#45](../../mfc/codesnippet/cpp/cevent-class_1.cpp)]

[!code-cpp[NVC_MFC_Utilities#46](../../mfc/codesnippet/cpp/cevent-class_2.cpp)]

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

[CSyncObject](../../mfc/reference/csyncobject-class.md)

`CEvent`

## <a name="requirements"></a>Требования

**Заголовок:** afxmt.h

##  <a name="cevent"></a>  CEvent::CEvent

Создает именованную или неименованную `CEvent` объекта.

```
CEvent(
    BOOL bInitiallyOwn = FALSE,
    BOOL bManualReset = FALSE,
    LPCTSTR lpszName = NULL,
    LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);
```

### <a name="parameters"></a>Параметры

*bInitiallyOwn*<br/>
Значение TRUE, если поток для `CMultilock` или `CSingleLock` включен объект. В противном случае необходимо подождать все потоки, желающих получить доступ к ресурсу.

*bManualReset*<br/>
Если значение равно TRUE, указывает, что объект события является событием вручную, в противном случае — объект события автоматического события.

*lpszName*<br/>
Имя объекта `CEvent`. Необходимо указать, если объект будет использоваться через границы процессов. Если имя совпадает с существующего события, конструктор создает новый `CEvent` объект, который ссылается на событие этим именем. Если имя совпадает с существующий объект синхронизации, не является событием, построение завершится ошибкой. Если значение равно NULL, имя будет иметь значение null.

*lpsaAttribute*<br/>
Атрибуты безопасности для объекта события. Полное описание этой структуры, см. в разделе [SECURITY_ATTRIBUTES](https://msdn.microsoft.com/library/windows/desktop/aa379560) в пакете Windows SDK.

### <a name="remarks"></a>Примечания

Для доступа к или выпуска `CEvent` следует создать [CMultiLock](../../mfc/reference/cmultilock-class.md) или [CSingleLock](../../mfc/reference/csinglelock-class.md) и вызовите его [блокировки](../../mfc/reference/csinglelock-class.md#lock) и [Unlock](../../mfc/reference/csinglelock-class.md#unlock) функции-члены.

Чтобы изменить состояние `CEvent` объект сигнальным (потоки не имеют ожидания), вызовите [выполнить SetEvent](#setevent) или [PulseEvent](#pulseevent). Чтобы задать состояние `CEvent` объекта несигнальное (потоки должны ждать), вызовите [ResetEvent](#resetevent).

> [!IMPORTANT]
>  После создания `CEvent` , используйте [GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360) для проверки того, что мьютекс не существует. Если мьютексом существовала неожиданно, это может указывать нелегальные процессы — занятие и может вы собираетесь использовать мьютекс злоумышленником. В этом случае соображениям безопасности рекомендуется закрыть дескриптор и продолжить как, если произошел сбой при создании объекта.

##  <a name="pulseevent"></a>  CEvent::PulseEvent

Задает состояние события сигнальным (доступно), освобождает все ожидающие потоки и сбрасывает ее несигнальное (недоступно) автоматически.

```
BOOL PulseEvent();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае 0.

### <a name="remarks"></a>Примечания

Если событие выполняется вручную, все ожидающие потоки освобождаются, событие используется на несигнальное и `PulseEvent` возвращает. Если событие является автоматическим, освобождается один поток, события используется для несигнальное и `PulseEvent` возвращает.

Если нет ожидающих потоков или потоки не могут быть сняты немедленно, `PulseEvent` Задает несигнальное состояние события и возвращает.

`PulseEvent` использует базовый Win32 `PulseEvent` функцию, которую можно моментально удалить из состояния ожидания путем вызова асинхронных процедур в режиме ядра. Таким образом `PulseEvent` ненадежный и не следует использовать в новых приложениях. Дополнительные сведения см. в разделе [PulseEvent функция](/windows/desktop/api/winbase/nf-winbase-pulseevent).

##  <a name="resetevent"></a>  CEvent::ResetEvent

Задает состояние события несигнальное до явным образом задать в сигнальное, [выполнить SetEvent](#setevent) функция-член.

```
BOOL ResetEvent();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае 0.

### <a name="remarks"></a>Примечания

В результате все потоки, желающих получить доступ к это событие ожидания.

Эта функция-член не используется автоматическое событиями.

##  <a name="setevent"></a>  CEvent::SetEvent

Задает состояние события, получает сигнал, освобождения потоков в состоянии ожидания.

```
BOOL SetEvent();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно, иначе — 0.

### <a name="remarks"></a>Примечания

Если событие вручную, событие будет оставаться сигнал до [ResetEvent](#resetevent) вызывается. В этом случае может быть освобожден только один поток. Если событие является автоматическим, событие будет оставаться сигнальное до снятия одного потока. Система затем установит несигнальное состояние события. Если нет ожидающих потоков, состояние остается сигнальным до снятия один поток.

##  <a name="unlock"></a>  CEvent::Unlock

Освобождает объект события.

```
BOOL Unlock();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если поток принадлежит объект события и событие автоматического события; в противном случае 0.

### <a name="remarks"></a>Примечания

Эта функция-член вызывается потоков, которые в настоящее время принадлежат событие автоматического освобождения после они выполняются, если их объект блокировки для повторного использования. Если объект блокировки не для повторного использования, эта функция вызывается деструктор объекта блокировки.

## <a name="see-also"></a>См. также

[Класс CSyncObject](../../mfc/reference/csyncobject-class.md)<br/>
[Диаграмма иерархии](../../mfc/hierarchy-chart.md)

