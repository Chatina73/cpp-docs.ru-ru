---
title: Класс CDialog
ms.date: 09/07/2019
f1_keywords:
- CDialog
- AFXWIN/CDialog
- AFXWIN/CDialog::CDialog
- AFXWIN/CDialog::Create
- AFXWIN/CDialog::CreateIndirect
- AFXWIN/CDialog::DoModal
- AFXWIN/CDialog::EndDialog
- AFXWIN/CDialog::GetDefID
- AFXWIN/CDialog::GotoDlgCtrl
- AFXWIN/CDialog::InitModalIndirect
- AFXWIN/CDialog::MapDialogRect
- AFXWIN/CDialog::NextDlgCtrl
- AFXWIN/CDialog::OnInitDialog
- AFXWIN/CDialog::OnSetFont
- AFXWIN/CDialog::PrevDlgCtrl
- AFXWIN/CDialog::SetDefID
- AFXWIN/CDialog::SetHelpID
- AFXWIN/CDialog::OnCancel
- AFXWIN/CDialog::OnOK
helpviewer_keywords:
- CDialog [MFC], CDialog
- CDialog [MFC], Create
- CDialog [MFC], CreateIndirect
- CDialog [MFC], DoModal
- CDialog [MFC], EndDialog
- CDialog [MFC], GetDefID
- CDialog [MFC], GotoDlgCtrl
- CDialog [MFC], InitModalIndirect
- CDialog [MFC], MapDialogRect
- CDialog [MFC], NextDlgCtrl
- CDialog [MFC], OnInitDialog
- CDialog [MFC], OnSetFont
- CDialog [MFC], PrevDlgCtrl
- CDialog [MFC], SetDefID
- CDialog [MFC], SetHelpID
- CDialog [MFC], OnCancel
- CDialog [MFC], OnOK
ms.assetid: ca64b77e-2cd2-47e3-8eff-c2645ad578f9
ms.openlocfilehash: cad762f426012d9d1931b96d54d8a53c9bab465d
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375649"
---
# <a name="cdialog-class"></a>Класс CDialog

Базовый класс, используемый для отображения диалоговых коробок на экране.

## <a name="syntax"></a>Синтаксис

```
class CDialog : public CWnd
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CDialog::CDialog](#cdialog)|Формирует объект `CDialog`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CDialog::Создание](#create)|Инициализирует объект `CDialog`. Создает бесрежимный диалоговый ящик `CDialog` и прикрепляет его к объекту.|
|[CDialog:CreateIndirect](#createindirect)|Создает бесрежимный диалоговый ящик из шаблона диалогового ящика в памяти (не основанного на ресурсах).|
|[CDialog::DoModal](#domodal)|Вызывает модальный диалоговые окна и возвращается, когда сделано.|
|[CDialog::EndDialog](#enddialog)|Закрывает модальный диалоговый ящик.|
|[CDialog:GetDefID](#getdefid)|Получает идентификатор управления кнопкой по умолчанию для диалогового окна.|
|[CDialog::GotoDlgCtrl](#gotodlgctrl)|Перемещает фокус на указанный элемент управления диалоговые окна в диалоговом поле.|
|[CDialog:InitModalIndirect](#initmodalindirect)|Создает модальный диалоговый ящик из шаблона диалогового ящика в памяти (не основанного на ресурсах). Параметры сохраняются до тех `DoModal` пор, пока функция не будет вызвана.|
|[CDialog:MapDialogRect](#mapdialogrect)|Преобразует единицы диалогового ящика прямоугольника в экранные блоки.|
|[CDialog::NextDlgCtrl](#nextdlgctrl)|Перемещает фокус на следующий элемент управления диалоговые окна в диалоговом поле.|
|[CDialog::OnInitDialog](#oninitdialog)|Переопределение для увеличения инициализации диалогового ящика.|
|[CDialog::OnSetFont](#onsetfont)|Переуряднетесь, чтобы указать шрифт, который элемент управления диалогового ящика должен использоваться при нарисовывании текста.|
|[CDialog::PrevDlgCtrl](#prevdlgctrl)|Перемещает фокус на предыдущее управление диалог-боксом в диалоговом поле.|
|[CDialog::SetDefID](#setdefid)|Изменяет элемент управления кнопкой по умолчанию для диалогового окна на указанную кнопку.|
|[CDialog::SetHelpID](#sethelpid)|Устанавливает идентификатор справки, чувствительный к контексту, для диалогового окна.|

### <a name="protected-methods"></a>Защищенные методы

|Имя|Описание|
|----------|-----------------|
|[CDialog::OnCancel](#oncancel)|Переопределение для выполнения кнопки Отмена или ключевое действие ESC. По умолчанию закрывает диалоговую коробку и `DoModal` возвращает IDCANCEL.|
|[CDialog::OnOK](#onok)|Переопределение для выполнения действия кнопки OK в модальном диалоговом поле. По умолчанию закрывает диалоговую коробку и `DoModal` возвращает IDOK.|

## <a name="remarks"></a>Remarks

Коробки Dialog имеют два типа: модальные и бесрежимные. Модальный диалоговый ящик должен быть закрыт пользователем до продолжения приложения. Безрежимное диалоговое окно позволяет пользователю отображать диалоговую будку и возвращаться к другой задаче без отмены или удаления диалогового окна.

Объект `CDialog` представляет собой комбинацию шаблона `CDialog`диалога и класса a-derived. Используйте редактор диалогов для создания шаблона диалогов и его хранения в ресурсе, а `CDialog`затем используйте мастер-класс Add Class для создания класса, полученного из.

Диалоговая коробка, как и любое другое окно, получает сообщения из Windows. В диалоговом окне вы особенно заинтересованы в обработке сообщений уведомлений из элементов управления диалогового окна, так как пользователь взаимодействует с вашим диалоговому ящику. Используйте [Класс Мастер,](mfc-class-wizard.md) чтобы выбрать, какие сообщения вы хотите обрабатывать, и он добавит соответствующие записи на карту сообщений и функции члена-обработчика сообщений в класс для вас. Вам нужно только написать код для конкретного приложения в функциях-обработчиках.

Если вы предпочитаете, вы всегда можете написать запись на карту сообщений и функции членов вручную.

Во всех, кроме самого тривиального диалогового окна, вы добавляете переменные членов в свой производный класс диалогов для хранения данных, введенных пользователем в диалоговую будку, или для отображения данных для пользователя. Можно использовать мастер-разноску Добавить переменную для создания переменных членов и связывать их с элементами управления. В то же время вы выбираете переменный тип и допустимый диапазон значений для каждой переменной. Мастер кода добавляет переменные участника в ваш производный класс диалогов.

Карта данных генерируется для автоматической обработки обмена данными между переменными-членами и элементами управления диалогового окна. Карта данных содержит функции, которые инициализируют элементы управления в диалоговом поле с соответствующими значениями, извлекают данные и проверяют данные.

Чтобы создать модульное диалоговое окно, создайте объект в стеке, используя `DoModal` конструктор для производного класса диалогов, а затем позвоните для создания окна диалога и его элементов управления. Если вы хотите создать бесрежимный `Create` диалог, позвоните в конструктор вашего класса диалогов.

Вы также можете создать шаблон в памяти, используя структуру данных [DLGTEMPLATE,](/windows/win32/api/winuser/ns-winuser-dlgtemplate) как описано в SDK Windows. После создания `CDialog` объекта позвоните [CreateIndirect](#createindirect) для создания безспособного диалогового окна или позвоните [initModalIndirect](#initmodalindirect) и [DoModal](#domodal) для создания модального диалогового окна.

Карта данных об обмене и проверке `CWnd::DoDataExchange` записана в переопределение, которое добавляется в ваш новый класс диалогов. Подробнее о функции `CWnd` обмена и проверки читайте в функции участника [DoDataExchange.](../../mfc/reference/cwnd-class.md#dodataexchange)

И программист, и `DoDataExchange` фреймворк звонят косвенно через вызов на [CWnd::UpdateData](../../mfc/reference/cwnd-class.md#updatedata).

Рамочная `UpdateData` система вызывает, когда пользователь нажимает кнопку OK, чтобы закрыть модальный диалоговый ящик. (Данные не извлекаются при нажатии кнопки «Отмена».) Реализация [OnInitDialog](#oninitdialog) по умолчанию также требует `UpdateData` установить начальные значения элементов управления. Обычно переопределяется `OnInitDialog` для дальнейшей инициализации элементов управления. `OnInitDialog`называется после того, как все элементы управления диалогом создаются и непосредственно перед отображением диалогового окна.

Вы можете `CWnd::UpdateData` позвонить в любое время во время выполнения модального или бесрежимного диалогового окна.

Если вы разрабатываете диалоговый ящик вручную, вы сами добавляете необходимые переменные членов в класс диалоговых коробок и добавляете функции членов для настройки или получения этих значений.

Модальный диалоговый ящик закрывается автоматически, когда пользователь нажимает кнопки OK или Cancel или когда ваш код вызывает функцию `EndDialog` участника.

При реализации безспособного диалогового окна `OnCancel` всегда переопределяют функцию участника и вызывайте `DestroyWindow` из нее. Не звоните в `CDialog::OnCancel`базовый класс, потому что он вызывает, `EndDialog`что сделает диалоговый ящик невидимым, но не уничтожит его. Вы также должны `PostNcDestroy` переопределить для безмерных диалоговые ящики для того, чтобы удалить **это,** так как безмерные диалоговые коробки обычно выделяются с **новым**. Модальные диалоговые ящики обычно строятся `PostNcDestroy` на раме и не нуждаются в очистке.

Для получения `CDialog`дополнительной информации о , см. [Dialog Boxes](../../mfc/dialog-boxes.md)

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

`CDialog`

## <a name="requirements"></a>Требования

**Заголовок:** afxwin.h

## <a name="cdialogcdialog"></a><a name="cdialog"></a>CDialog::CDialog

Чтобы построить ресурсо-ориентированный модульный диалоговый ящик, позвоните либо в общедоступную форму конструктора.

```
explicit CDialog(
    LPCTSTR lpszTemplateName,
    CWnd* pParentWnd = NULL);

explicit CDialog(
    UINT nIDTemplate,
    CWnd* pParentWnd = NULL);

CDialog();
```

### <a name="parameters"></a>Параметры

*lpszTemplateName*<br/>
Содержит строку с нулевым завершением, которая является названием ресурса шаблона диалогового ящика.

*nIDTemplate*<br/>
Содержит идентификационный номер ресурса шаблона диалогового ящика.

*pParentWnd*<br/>
Указывает на объект окна родителя или владельца (типа [CWnd),](../../mfc/reference/cwnd-class.md)к которому принадлежит объект диалога. Если это NULL, родительское окно объекта диалога устанавливается на основное окно приложения.

### <a name="remarks"></a>Remarks

Одна из форм конструктора обеспечивает доступ к диалоговому ресурсу по имени шаблона. Другой конструктор предоставляет доступ по идентификационному номеру шаблона, обычно с **IDD_** префиксом (например, IDD_DIALOG1).

Чтобы построить модальный диалоговый ящик из шаблона в памяти, сначала `InitModalIndirect`вызовите безпаралист, защищенный конструктор, а затем вызов .

После создания модального диалогового окна с одним из `DoModal`вышеуказанных методов позвоните .

Чтобы построить бесрежимную диалоговую коробку, используйте защищенную форму `CDialog` конструктора. Конструктор защищен, потому что вы должны получить свой собственный диалоговый ящик класса для реализации безрежима диалоговая коробка. Строительство безспособной диалоговой коробки – это двухэтапный процесс. Первый вызов конструктора; затем вызов `Create` функции участника для создания ресурсо-ориентированного диалогового окна или вызова `CreateIndirect` для создания диалогового окна из шаблона в памяти.

## <a name="cdialogcreate"></a><a name="create"></a>CDialog::Создание

Вызов `Create` для создания бесрежимного диалогового окна с помощью шаблона диалогового ящика из ресурса.

```
virtual BOOL Create(
    LPCTSTR lpszTemplateName,
    CWnd* pParentWnd = NULL);

virtual BOOL Create(
    UINT nIDTemplate,
    CWnd* pParentWnd = NULL);
```

### <a name="parameters"></a>Параметры

*lpszTemplateName*<br/>
Содержит строку с нулевым завершением, которая является названием ресурса шаблона диалогового ящика.

*pParentWnd*<br/>
Указывает на объект родительского окна (типа [CWnd),](../../mfc/reference/cwnd-class.md)к которому принадлежит объект диалога. Если это NULL, родительское окно объекта диалога устанавливается на основное окно приложения.

*nIDTemplate*<br/>
Содержит идентификационный номер ресурса шаблона диалогового ящика.

### <a name="return-value"></a>Возвращаемое значение

Обе формы возвращаются ненулево, если создание диалогового ящика и инициализация были успешными; в противном случае 0.

### <a name="remarks"></a>Remarks

Вы можете поместить `Create` вызов внутри конструктора или вызвать его после вызова конструктора.

`Create` Для доступа к шаблонному ресурсу диалогового ящика предусмотрены либо название шаблона, либо идентификационный номер шаблона (например, IDD_DIALOG1).

Для любой формы передайте указатель объекту родительского окна. Если *pParentWnd* является NULL, диалоговая коробка будет создана с его родителем или владельцем окна, установленного на основное окно приложения.

Функция `Create` участника возвращается сразу после того, как создает диалоговую коробку.

Используйте WS_VISIBLE стиль в шаблоне диалог-бокса, если при создании родительского окна должно появиться поле диалога. В противном `ShowWindow`случае, вы должны позвонить . Для получения дальнейших стилей диалоговых [DLGTEMPLATE](/windows/win32/api/winuser/ns-winuser-dlgtemplate) коробок и их применения см. [Window Styles](../../mfc/reference/styles-used-by-mfc.md#window-styles) *MFC Reference*

Используйте `CWnd::DestroyWindow` функцию, чтобы уничтожить диалоговую коробку, созданную функцией. `Create`

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCControlLadenDialog#62](../../mfc/codesnippet/cpp/cdialog-class_1.cpp)]

## <a name="cdialogcreateindirect"></a><a name="createindirect"></a>CDialog:CreateIndirect

Вызовите эту функцию участника, чтобы создать нережимную диалоговую коробку из шаблона диалогового ящика в памяти.

```
virtual BOOL CreateIndirect(
    LPCDLGTEMPLATE lpDialogTemplate,
    CWnd* pParentWnd = NULL,
    void* lpDialogInit = NULL);

virtual BOOL CreateIndirect(
    HGLOBAL hDialogTemplate,
    CWnd* pParentWnd = NULL);
```

### <a name="parameters"></a>Параметры

*lpDialogTemplate*<br/>
Указывает на память, содержащую шаблон диалог-бокс, используемый для создания диалогового окна. Этот шаблон в виде структуры [DLGTEMPLATE](/windows/win32/api/winuser/ns-winuser-dlgtemplate) и информации управления, как описано в Windows SDK.

*pParentWnd*<br/>
Указывает на родительский объект окна объекта диалогового объекта (типа [CWnd).](../../mfc/reference/cwnd-class.md) Если это NULL, родительское окно объекта диалога устанавливается на основное окно приложения.

*lpDialogInit*<br/>
Указывает на ресурс DLGINIT.

*hDialogTemplate*<br/>
Содержит ручку глобальной памяти, содержащую шаблон диалог-бокс. Этот шаблон в виде `DLGTEMPLATE` структуры и данных для каждого элемента управления в диалоговом поле.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если диалоговая коробка была создана и инициализирована успешно; в противном случае 0.

### <a name="remarks"></a>Remarks

Функция `CreateIndirect` участника возвращается сразу после того, как создает диалоговую коробку.

Используйте WS_VISIBLE стиль в шаблоне диалог-бокса, если при создании родительского окна должно появиться поле диалога. В противном `ShowWindow` случае необходимо позвонить, чтобы вызвать его. Для получения дополнительной информации о том, как можно указать [DLGTEMPLATE](/windows/win32/api/winuser/ns-winuser-dlgtemplate) другие стили диалоговых коробок в шаблоне, см.

Используйте `CWnd::DestroyWindow` функцию, чтобы уничтожить диалоговую коробку, созданную функцией. `CreateIndirect`

Коробки Dialog, содержащие элементы управления ActiveX, требуют дополнительной информации, представленной на ресурсе DLGINIT.

## <a name="cdialogdomodal"></a><a name="domodal"></a>CDialog::DoModal

Вызов эту функцию участника, чтобы вызвать модульный диалоговый ящик и вернуть результат диалогового ящика при завершении.

```
virtual INT_PTR DoModal();
```

### <a name="return-value"></a>Возвращаемое значение

**Значение int,** которое определяет значение параметра *nResult,* который был передан функции [cDialog::EndDialog,](#enddialog) которая используется для закрытия диалогового окна. Значение возврата -1, если функция не может создать поле диалога, или IDABORT, если произошла какая-то другая ошибка, и в этом случае выходное окно будет содержать информацию об ошибке от [GetLastError.](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror)

### <a name="remarks"></a>Remarks

Эта функция члена обрабатывает все взаимодействие с пользователем в то время как диалоговое окно активен. Это то, что делает диалоговую коробку модальной; то есть пользователь не может взаимодействовать с другими окнами до тех пор, пока диалоговая шкатулка не будет закрыта.

Если пользователь нажимает одну из кнопок в поле диалога, например OK или Cancel, для закрытия окна диалоговой службы вызывается функция обработчика сообщений, например [OnOK](#onok) или [OnCancel.](#oncancel) Функция `OnOK` участника по умолчанию будет проверять и обновлять данные диалогового ящика `OnCancel` и закрывать диалоговое окно с результатом IDOK, а функция участника по умолчанию закроет диалоговое поле с результатом IDCANCEL без проверки или обновления данных диалогового ящика. Вы можете переопределить эти функции обработчика сообщений, чтобы изменить их поведение.

> [!NOTE]
> `PreTranslateMessage`в настоящее время требуется для обработки сообщений модульного диалогового окна.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCControlLadenDialog#63](../../mfc/codesnippet/cpp/cdialog-class_2.cpp)]

## <a name="cdialogenddialog"></a><a name="enddialog"></a>CDialog::EndDialog

Вызовите эту функцию участника, чтобы завершить модульное поле диалогов.

```
void EndDialog(int nResult);
```

### <a name="parameters"></a>Параметры

*nResult*<br/>
Содержит значение, необходимое для возврата из окна `DoModal`диалога вызывающему абоненту.

### <a name="remarks"></a>Remarks

Эта функция участника возвращает *nResult* `DoModal`как значение возврата . Функция должна `EndDialog` выполняться при создании модального диалогового окна.

Вы можете `EndDialog` позвонить в любое время, даже в [OnInitDialog](#oninitdialog), и в этом случае вы должны закрыть диалоговое окно до его отображаемого или до установки ввода.

`EndDialog`не закрывает диалоговую будку немедленно. Вместо этого он устанавливает флаг, который направляет диалоговое окно на закрытие, как только текущий обработчик сообщений возвращается.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCControlLadenDialog#64](../../mfc/codesnippet/cpp/cdialog-class_3.cpp)]

[!code-cpp[NVC_MFCControlLadenDialog#65](../../mfc/codesnippet/cpp/cdialog-class_4.cpp)]

## <a name="cdialoggetdefid"></a><a name="getdefid"></a>CDialog:GetDefID

Вызов `GetDefID` функции участника, чтобы получить идентификатор управления кнопкой по умолчанию для диалогового окна.

```
DWORD GetDefID() const;
```

### <a name="return-value"></a>Возвращаемое значение

32-битное `DWORD`значение (). Если кнопка по умолчанию имеет значение идентификатора, слово высокого порядка содержит DC_HASDEFID и слово низкого порядка содержит значение идентификатора. Если кнопка по умолчанию не имеет значения идентификатора, значение возврата составляет 0.

### <a name="remarks"></a>Remarks

Обычно это кнопка ОК.

## <a name="cdialoggotodlgctrl"></a><a name="gotodlgctrl"></a>CDialog:GotoDlgCtrl

Перемещает фокус к указанному элементу управления в диалоговом поле.

```
void GotoDlgCtrl(CWnd* pWndCtrl);
```

### <a name="parameters"></a>Параметры

*pWndCtrl*<br/>
Определяет окно (управление), то есть для получения фокуса.

### <a name="remarks"></a>Remarks

Чтобы получить указатель на элемент управления (детское окно), чтобы пройти `CWnd::GetDlgItem` как *pWndCtrl,* позвоните функции участника, которая возвращает указатель на объект [CWnd.](../../mfc/reference/cwnd-class.md)

### <a name="example"></a>Пример

  Смотрите пример [для CWnd::GetDlgItem](../../mfc/reference/cwnd-class.md#getdlgitem).

## <a name="cdialoginitmodalindirect"></a><a name="initmodalindirect"></a>CDialog:InitModalIndirect

Вызовите эту функцию участника, чтобы инициализировать модульный диалоговой объект с помощью шаблона диалогового ящика, который вы строите в памяти.

```
BOOL InitModalIndirect(
    LPCDLGTEMPLATE lpDialogTemplate,
    CWnd* pParentWnd = NULL,
    void* lpDialogInit = NULL);

    BOOL InitModalIndirect(
    HGLOBAL hDialogTemplate,
    CWnd* pParentWnd = NULL);
```

### <a name="parameters"></a>Параметры

*lpDialogTemplate*<br/>
Указывает на память, содержащую шаблон диалог-бокс, используемый для создания диалогового окна. Этот шаблон в виде структуры [DLGTEMPLATE](/windows/win32/api/winuser/ns-winuser-dlgtemplate) и информации управления, как описано в Windows SDK.

*hDialogTemplate*<br/>
Содержит ручку глобальной памяти, содержащую шаблон диалог-бокс. Этот шаблон в виде `DLGTEMPLATE` структуры и данных для каждого элемента управления в диалоговом поле.

*pParentWnd*<br/>
Указывает на объект окна родителя или владельца (типа [CWnd),](../../mfc/reference/cwnd-class.md)к которому принадлежит объект диалога. Если это NULL, родительское окно объекта диалога устанавливается на основное окно приложения.

*lpDialogInit*<br/>
Указывает на ресурс DLGINIT.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если объект диалога был создан и инициализирован успешно; в противном случае 0.

### <a name="remarks"></a>Remarks

Чтобы создать модульное диалоговое окно косвенно, сначала выделите глобальный блок памяти и заполните его шаблоном диалогового окна. Затем позвоните `CDialog` пустому конструктору, чтобы построить объект диалог-коробка. Далее `InitModalIndirect` звоните, чтобы сохранить ручку в шаблоне диалогового ящика в памяти. Окно диалога Windows создается и отображается позже, когда вызывается функция члена [DoModal.](#domodal)

Коробки Dialog, содержащие элементы управления ActiveX, требуют дополнительной информации, представленной на ресурсе DLGINIT.

## <a name="cdialogmapdialogrect"></a><a name="mapdialogrect"></a>CDialog:MapDialogRect

Призыв к преобразованию единиц диалогового ящика прямоугольника в экранные единицы.

```
void MapDialogRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) содержащий координаты диалогового ящика, которые должны быть преобразованы.

### <a name="remarks"></a>Remarks

Единицы Dialog-box указаны с точки зрения текущего базового блока диалог-бокса, полученного из средней ширины и высоты символов шрифта, используемого для текста диалог-бокса. Одна горизонтальная единица составляет одну четвертую часть базового блока-ширины диалог-бокса, а одна вертикальная единица — одна восьмая единицы базовой высоты диалогового ящика.

Функция `GetDialogBaseUnits` Windows возвращает информацию о размере для системного шрифта, но можно указать другой шрифт для каждого диалогового окна, если вы используете DS_SETFONT стиль в файле определения ресурсов. Функция `MapDialogRect` Windows использует соответствующий шрифт для этого диалогового окна.

Функция `MapDialogRect` члена заменяет единицы диалогового ящика в *lpRect* единицами экрана (пикселей), так что прямоугольник может быть использован для создания диалогового окна или расположения элемента управления в коробке.

## <a name="cdialognextdlgctrl"></a><a name="nextdlgctrl"></a>CDialog::NextDlgCtrl

Перемещает фокус на следующий элемент управления в диалоговом поле.

```
void NextDlgCtrl() const;
```

### <a name="remarks"></a>Remarks

Если фокус находится на последнем элементе управления в диалоговом поле, он перемещается к первому элементу управления.

## <a name="cdialogoncancel"></a><a name="oncancel"></a>CDialog::OnCancel

Рамочная система вызывает этот метод, когда пользователь нажимает **Отменить** или нажимает клавишу ESC в модальном или бесрежимном диалоговом поле.

```
virtual void OnCancel();
```

### <a name="remarks"></a>Remarks

Переопределить этот метод для выполнения действий (например, восстановления старых данных), когда пользователь закрывает диалоговое окно, нажав **На кнопку «Отмена»** или нажав клавишу ESC. По умолчанию закрывает модальный диалоговый ящик, позвонив [в EndDialog](#enddialog) и заставив [DoModal](#domodal) вернуть IDCANCEL.

При реализации кнопки **«Отмена»** в безспособном `OnCancel` диалоговом поле необходимо переопределить метод и вызвать в нем [DestroyWindow.](../../mfc/reference/cwnd-class.md#destroywindow) Не вызывайте метод базового класса, `EndDialog`потому что он вызывает, что сделает диалоговый ящик невидимым, но не уничтожит его.

> [!NOTE]
> Вы не можете переопределить этот `CFileDialog` метод, когда вы используете объект в программе, которая компилируется под Windows XP. Для получения `CFileDialog`дополнительной информации о , см. [CFileDialog Class](../../mfc/reference/cfiledialog-class.md)

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCControlLadenDialog#66](../../mfc/codesnippet/cpp/cdialog-class_5.cpp)]

## <a name="cdialogoninitdialog"></a><a name="oninitdialog"></a>CDialog::OnInitDialog

Этот метод называется в `WM_INITDIALOG` ответ на сообщение.

```
virtual BOOL OnInitDialog();
```

### <a name="return-value"></a>Возвращаемое значение

Уточняется, установило ли приложение входной фокус на один из элементов управления в диалоговом поле. Если `OnInitDialog` возвращается ненулевой, Windows устанавливает фокус ввода на место по умолчанию, первый элемент управления в диалоговом поле. Приложение может вернуть 0 только в том случае, если оно явно установило фокус ввода на один из элементов управления в диалоговом поле.

### <a name="remarks"></a>Remarks

Windows отправляет `WM_INITDIALOG` сообщение в поле диалога во время [создания,](#create) [CreateIndirect](#createindirect)или [DoModal-звонков,](#domodal) которые возникают непосредственно перед отображением диалогового окна.

Переопределить этот метод, если вы хотите выполнить специальную обработку, когда диалоговый ящик инициализирован. В перевернутой версии сначала `OnInitDialog` позвоните в базовый класс, но проигнорируйте его значение возврата. Обычно вы `TRUE` возвращаетесь из перезавереденного метода.

Windows называет `OnInitDialog` эту функцию, используя стандартную глобальную процедуру диалогового ящика, общую для всех диалоговых коробок Microsoft Foundation Class Library. Он не вызывает эту функцию через карту сообщений, и поэтому вам не нужна запись на карту сообщений для этого метода.

> [!NOTE]
> Вы не можете переопределить этот `CFileDialog` метод, когда вы используете объект в программе, которая компилируется в Windows Vista или более поздних операционных системах. Для получения дополнительной `CFileDialog` информации об изменениях в Windows Vista и позже, см. [CFileDialog Class](../../mfc/reference/cfiledialog-class.md)

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCControlLadenDialog#67](../../mfc/codesnippet/cpp/cdialog-class_6.cpp)]

## <a name="cdialogonok"></a><a name="onok"></a>CDialog::OnOK

Вызывается, когда пользователь нажимает кнопку **ОК** (кнопка с id IDOK).

```
virtual void OnOK();
```

### <a name="remarks"></a>Remarks

Переопределить этот метод для выполнения действий при активации кнопки **OK.** Если диалоговое окно включает автоматическую проверку данных и обмен, реализация этого метода по умолчанию проверяет данные диалогового окна и обновляет соответствующие переменные в приложении.

При реализации кнопки **OK** в безспособном диалоговом `OnOK` поле необходимо переопределить метод и вызвать [Внедряемый документ.](../../mfc/reference/cwnd-class.md#destroywindow) Не вызывайте метод базового класса, потому что он вызывает [EndDialog,](#enddialog) что делает диалоговый ящик невидимым, но не разрушает его.

> [!NOTE]
> Вы не можете переопределить этот `CFileDialog` метод, когда вы используете объект в программе, которая компилируется под Windows XP. Для получения `CFileDialog`дополнительной информации о , см. [CFileDialog Class](../../mfc/reference/cfiledialog-class.md)

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCControlLadenDialog#68](../../mfc/codesnippet/cpp/cdialog-class_7.cpp)]

## <a name="cdialogonsetfont"></a><a name="onsetfont"></a>CDialog::OnSetFont

Определяет шрифт, который будет использовать элемент управления диалоговой коробкой при рисовании текста.

```
Virtual void OnSetFont(CFont* pFont);
```

### <a name="parameters"></a>Параметры

*pFont*<br/>
(в) Определяет указатель шрифта, который будет использоваться в качестве шрифта по умолчанию для всех элементов управления в этом диалоговом поле.

### <a name="remarks"></a>Remarks

В диалоговом поле указанный шрифт будет использоваться в качестве значения по умолчанию для всех элементов управления.

Редактор диалогов обычно устанавливает шрифт диалог-бокс как часть шаблона диалог-бокса.

> [!NOTE]
> Вы не можете переопределить этот `CFileDialog` метод, когда вы используете объект в программе, которая компилируется в Windows Vista или более поздних операционных системах. Для получения дополнительной `CFileDialog` информации об изменениях в Windows Vista и позже, см. [CFileDialog Class](../../mfc/reference/cfiledialog-class.md)

## <a name="cdialogprevdlgctrl"></a><a name="prevdlgctrl"></a>CDialog::PrevDlgCtrl

Устанавливает фокус на предыдущем элементе управления в диалоговом поле.

```
void PrevDlgCtrl() const;
```

### <a name="remarks"></a>Remarks

Если фокус находится на первом элементе управления в диалоговом поле, он перемещается к последнему элементу управления в поле.

## <a name="cdialogsetdefid"></a><a name="setdefid"></a>CDialog::SetDefID

Изменяет элемент управления кнопкой по умолчанию для диалогового окна.

```
void SetDefID(UINT nID);
```

### <a name="parameters"></a>Параметры

*nID*<br/>
Упогоняет идентификатор управления кнопкой, который станет по умолчанию.

## <a name="cdialogsethelpid"></a><a name="sethelpid"></a>CDialog::SetHelpID

Устанавливает идентификатор справки, чувствительный к контексту, для диалогового окна.

```
void SetHelpID(UINT nIDR);
```

### <a name="parameters"></a>Параметры

*nIDR*<br/>
Упоняет идентификатор справки, чувствительный к контексту.

## <a name="see-also"></a>См. также раздел

[MFC Образец DLGCBR32](../../overview/visual-cpp-samples.md)<br/>
[MFC Образец DLGTEMPL](../../overview/visual-cpp-samples.md)<br/>
[Класс CWnd](../../mfc/reference/cwnd-class.md)<br/>
[Диаграмма иерархии](../../mfc/hierarchy-chart.md)
