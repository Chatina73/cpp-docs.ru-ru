---
title: Класс CDC
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: 830c6d068a5074d0918107ca601c51d198a8a912
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375715"
---
# <a name="cdc-class"></a>Класс CDC

Определяет класс объектов контекста устройства.

## <a name="syntax"></a>Синтаксис

```
class CDC : public CObject
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CDC::CDC](#cdc)|Формирует объект `CDC`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|Прекращает текущее задание печати, снимая все, что приложение написало `StartDoc` устройству с момента последнего вызова функции участника.|
|[CDC::AbortPath](#abortpath)|Закрывает и отбрасывает любые пути в контексте устройства.|
|[CDC:AddMetaFileКомментарий](#addmetafilecomment)|Копирует комментарий из буфера в указанный метафайл расширенного формата.|
|[CDC::AlphaBlend](#alphablend)|Отображает бит-карты с прозрачными или полупрозрачными пикселями.|
|[CDC::AngleArc](#anglearc)|Рисует сегмент линии и дуги, и перемещает текущее положение в конечную точку дуги.|
|[CDC::Arc](#arc)|Рисует эллиптической дуги.|
|[CDC::Аркто](#arcto)|Рисует эллиптической дуги. Эта функция `Arc`аналогична, за исключением того, что текущее положение обновляется.|
|[CDC::Прикрепите](#attach)|Прикрепляет контекст устройства `CDC` Windows к этому объекту.|
|[CDC::BeginPath](#beginpath)|Открывает кронштейн пути в контексте устройства.|
|[CDC::BitBlt](#bitblt)|Копирует битную карту из заданного контекста устройства.|
|[CDC:Chord](#chord)|Рисует аккорд (закрытая фигура, ограниченная пересечением эллипса и сегмента линии).|
|[CDC:CloseFigure](#closefigure)|Закрывает открытую фигуру в пути.|
|[CDC::СозданиеCompatibleDC](#createcompatibledc)|Создает контекст памяти и устройства, совместимый с другим контекстом устройства. Вы можете использовать его для подготовки изображений в памяти.|
|[CDC::CreateDC](#createdc)|Создает контекст устройства для определенного устройства.|
|[CDC::CreateIC](#createic)|Создает информационный контекст для определенного устройства. Это обеспечивает быстрый способ получения информации об устройстве без создания контекста устройства.|
|[CDC::DeleteDC](#deletedc)|Удаляет контекст устройства Windows, `CDC` связанный с этим объектом.|
|[CDC::DeleteTempMap](#deletetempmap)|Вызывается `CWinApp` обработчиком простоя, `CDC` чтобы `FromHandle`удалить любой временный объект, созданный . Также отсоединяет контекст устройства.|
|[CDC::Detach](#detach)|Отсеивает контекст устройства `CDC` Windows от этого объекта.|
|[CDC::DPtoHIMETRIC](#dptohimetric)|Преобразует блоки устройств в блоки HIMETRIC.|
|[CDC::DPtoLP](#dptolp)|Преобразует блоки устройств в логические единицы.|
|[CDC::Draw3dRect](#draw3drect)|Рисует трехмерный прямоугольник.|
|[CDC::DrawDragRect](#drawdragrect)|Стирает и перерисовывает прямоугольник при перетаскивании.|
|[CDC::DrawEdge](#drawedge)|Рисует края прямоугольника.|
|[CDC::DrawEscape](#drawescape)|Доступ к возможностям рисования видеодисплея, которые не доступны напрямую через интерфейс графического устройства (GDI).|
|[CDC::DrawFocusRect](#drawfocusrect)|Рисует прямоугольник в стиле, используемом для обозначения фокуса.|
|[CDC::DrawFrameControl](#drawframecontrol)|Нарисуйте элемент управления кадром.|
|[CDC::DrawIcon](#drawicon)|Рисует значок.|
|[CDC::D](#drawstate)|Отображает изображение и применяет визуальный эффект для обозначения состояния.|
|[CDC::DrawText](#drawtext)|Рисует отформатированный текст в указанном прямоугольнике.|
|[CDC::DrawTextEx](#drawtextex)|Рисует отформатированный текст в указанном прямоугольнике с использованием дополнительных форматов.|
|[CDC::Эллипс](#ellipse)|Рисование эллипса.|
|[CDC:EndDoc](#enddoc)|Завершает задание печати, `StartDoc` начатое функцией участника.|
|[CDC:EndPage](#endpage)|Сообщает водителю устройства, что страница заканчивается.|
|[CDC:EndPath](#endpath)|Закрывает кронштейн пути и выбирает путь, определяемый кронштейном, в контекст устройства.|
|[CDC:EnumObjects](#enumobjects)|Перечисляет ручки и кисти, доступные в контексте устройства.|
|[CDC::Побег](#escape)|Позволяет приложениям получать доступ к объектам, которые не доступны непосредственно с определенного устройства через GDI. Также позволяет получить доступ к функциям выхода Windows. Звонки на побег, сделанные приложением, переводятся и отправляются водителю устройства.|
|[CDC::ExcludeClipRect](#excludecliprect)|Создает новую область отсечения, которая состоит из существующей области отсечения за вычетом заданного прямоугольника.|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|Предотвращает рисование в недействительных областях окна, исключая обновленный уклон в окне из области отсечения.|
|[CDC::ExtFloodFill](#extfloodfill)|Заполняет область текущей щеткой. Обеспечивает большую гибкость, чем функция члена [CDC::FloodFill.](#floodfill)|
|[CDC::ExtTextOut](#exttextout)|Записывает строку символов в прямоугольной области с помощью выбранного в настоящее время шрифта.|
|[CDC:FillPath](#fillpath)|Закрывает любые открытые фигуры в текущем пути и заполняет внутреннюю часть пути с помощью текущего режима заполнения кисти и полигона.|
|[CDC:FillRect](#fillrect)|Заполняет данный прямоугольник с помощью определенной кисти.|
|[CDC:FillRgn](#fillrgn)|Заполняет определенный регион указанной кистью.|
|[CDC:FillSolidRect](#fillsolidrect)|Заполняет прямоугольник твердым цветом.|
|[CDC::FlattenPath](#flattenpath)|Преобразует любые кривые в выбранном пути в текущий контекст устройства и превращает каждую кривую в последовательность линий.|
|[CDC::Наводнение](#floodfill)|Заполняет область текущей щеткой.|
|[CDC::FrameRect](#framerect)|Рисует границу вокруг прямоугольника.|
|[CDC:FrameRgn](#framergn)|Рисует границу вокруг определенного региона с помощью кисти.|
|[CDC::FromHandle](#fromhandle)|Возвращает указатель объекту `CDC` при отваге рукоятки в контекст устройства. Если объект `CDC` не прикреплен к дескриптору, создается и прикрепляется временный объект `CDC`.|
|[CDC:GetArcDirection](#getarcdirection)|Возвращает текущее направление дуги для контекста устройства.|
|[CDC:GetAspectRatioFilter](#getaspectratiofilter)|Извлекает настройки для текущего фильтра отношения аспекта.|
|[CDC::GetBkColor](#getbkcolor)|Извлекает текущий цвет фона.|
|[CDC:GetBkMode](#getbkmode)|Извлекает фоновый режим.|
|[CDC::GetBoundsRect](#getboundsrect)|Возвращает текущий накопленный прямоугольник для заданного контекста устройства.|
|[CDC::GetBrushOrg](#getbrushorg)|Извлекает происхождение текущей кисти.|
|[CDC::GetCharABCШирины](#getcharabcwidths)|Извлекает ширины, в логических единицах, последовательных символов в данном диапазоне от текущего шрифта.|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|Извлекает ширину, в логических единицах, последовательных глифов индексов в определенном диапазоне от текущего шрифта TrueType.|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|Извлекает различные типы информации на строке символов.|
|[CDC::GetCharWidth](#getcharwidth)|Извлекает дробную ширину последовательных символов в заданном диапазоне от текущего шрифта.|
|[CDC::GetCharWidthI](#getcharwidthi)|Извлекает ширины, в логических координатах, последовательных глифов в заданном диапазоне от текущего шрифта.|
|[CDC:GetClipBox](#getclipbox)|Извлекает размеры самого плотного прямоугольника вокруг текущей границы отсечения.|
|[CDC::GetColorAdjustment](#getcoloradjustment)|Извлекает значения регулировки цвета для контекста устройства.|
|[CDC:GetCurrentBitmap](#getcurrentbitmap)|Возвращает указатель на выбранный `CBitmap` в настоящее время объект.|
|[CDC:GetCurrentBrush](#getcurrentbrush)|Возвращает указатель на выбранный `CBrush` в настоящее время объект.|
|[CDC::GetCurrentFont](#getcurrentfont)|Возвращает указатель на выбранный `CFont` в настоящее время объект.|
|[CDC::GetCurrentPalette](#getcurrentpalette)|Возвращает указатель на выбранный `CPalette` в настоящее время объект.|
|[CDC::GetCurrentPen](#getcurrentpen)|Возвращает указатель на выбранный `CPen` в настоящее время объект.|
|[CDC::GetCurrentPosition](#getcurrentposition)|Извлекает текущее положение пера (в логических координатах).|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|Получает текущий цвет кисти.|
|[CDC::GetDCPenColor](#getdcpencolor)|Получает текущий цвет пера.|
|[CDC::GetDeviceCaps](#getdevicecaps)|Извлекает определенный вид информации, конкретной для устройства, о возможностях данного устройства дисплея.|
|[CDC:GetFontData](#getfontdata)|Извлекает метрическую информацию шрифта из масштабируемого файла шрифта. Информация для извлечения идентифицируется путем указания смещения в файл шрифта и длины информации для возврата.|
|[CDC:GetFontLanguageInfo](#getfontlanguageinfo)|Возвращает информацию о выбранном в настоящее время шрифте для указанного контекста отображения.|
|[CDC:GetGlyphOutline](#getglyphoutline)|Извлекает кривую контура или битную карту для символа контура в текущем шрифте.|
|[CDC:GetGraphicsMode](#getgraphicsmode)|Извлекает текущий графический режим для заданного контекста устройства.|
|[CDC:GetHalftoneBrush](#gethalftonebrush)|Извлекает полутонную кисть.|
|[CDC:GetKerningPairs](#getkerningpairs)|Извлекает пары кернинга символов для шрифта, который в настоящее время выбран в указанном контексте устройства.|
|[CDC:GetLayout](#getlayout)|Извлекает макет контекста устройства (DC). Макет может быть как слева направо (по умолчанию), либо справа налево (зеркало).|
|[CDC:GetMapMode](#getmapmode)|Извлекает текущий режим отображения.|
|[CDC:GetMiterLimit](#getmiterlimit)|Возвращает лимит митера для контекста устройства.|
|[CDC::GetNearestColor](#getnearestcolor)|Извлекает ближайший логический цвет к определенному логическому цвету, который может представлять данное устройство.|
|[CDC:GetOutlineTextMetrics](#getoutlinetextmetrics)|Извлекает метрическую информацию шрифта для шрифтов TrueType.|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|Извлекает ширину отдельных символов в последовательной группе символов из текущего шрифта с помощью контекста устройства вывода.|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|Вычисляет ширину и высоту строки символов в контексте вывода устройства.|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|Вычисляет ширину и высоту строки текста на контексте выходного устройства с помощью текущего шрифта для определения размеров.|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|Извлекает метрики для текущего шрифта из контекста устройства вывода.|
|[CDC:GetPath](#getpath)|Извлекает координаты, определяющие конечные точки линий и точки управления кривыми, найденными в пути, выбранном в контексте устройства.|
|[CDC:GetPixel](#getpixel)|Извлекает значение цвета RGB пикселя в указанной точке.|
|[CDC:GetPolyFillMode](#getpolyfillmode)|Извлекает текущий режим заполнения полигона.|
|[CDC::GetROP2](#getrop2)|Извлекает текущий режим чертежа.|
|[CDC:GetSafeHdc](#getsafehdc)|Возвращает [CDC::m_hDC](#m_hdc), контекст выходного устройства.|
|[CDC:GetStretchBltMode](#getstretchbltmode)|Извлекает текущий режим растяжения биткарты.|
|[CDC:GetTabbedTextExtent](#gettabbedtextextent)|Вычисляет ширину и высоту строки символов в контексте атрибута устройства.|
|[CDC:GetTextAlign](#gettextalign)|Извлекает флаги выравнивания текста.|
|[CDC:GetTextCharacterExtra](#gettextcharacterextra)|Извлекает текущий параметр для интервала между персонажами.|
|[CDC::GetTextColor](#gettextcolor)|Извлекает текущий цвет текста.|
|[CDC:GetTextExtent](#gettextextent)|Вычисляет ширину и высоту строки текста на контексте устройства атрибута с помощью текущего шрифта для определения размеров.|
|[CDC::GetTextExtentExPointi](#gettextextentexpointi)|Извлекает количество символов в заданную строку, которая будет вписываться в указанное пространство и заполняет массив с объемом текста для каждого из этих символов.|
|[CDC::GetTextExtentpointI](#gettextextentpointi)|Извлекает ширину и высоту указанного массива глифововых индексов.|
|[CDC:GetTextFace](#gettextface)|Копирует имя шрифта текущего шрифта в буфер в качестве строки с нулевым завершением.|
|[CDC:GetTextMetrics](#gettextmetrics)|Извлекает метрики для текущего шрифта из контекста устройства атрибутов.|
|[CDC:GetViewportExt](#getviewportext)|Извлекает x- и y-объемы viewport.|
|[CDC:GetViewportOrg](#getviewportorg)|Извлекает x- и y-координаты происхождения viewport.|
|[CDC:GetWindow](#getwindow)|Возвращает окно, связанное с контекстом устройства дисплея.|
|[CDC:GetWindowExt](#getwindowext)|Извлекает x- и y-объемы связанного окна.|
|[CDC::GetWindowOrg](#getwindoworg)|Извлекает x- и y-координаты происхождения связанного окна.|
|[CDC:GetWorldTransform](#getworldtransform)|Извлекает текущее пространство мира в преобразование пространства страницы.|
|[CDC:GradientFill](#gradientfill)|Заполняет прямоугольники и треугольные структуры гратационным цветом.|
|[CDC::GrayString](#graystring)|Рисует затемненный (серый) текст в данном месте.|
|[CDC:HIMETRICtoDP](#himetrictodp)|Преобразует HIMETRIC единиц в блоки устройств.|
|[CDC:HIMETRICtoLP](#himetrictolp)|Преобразует HIMETRIC единицы в логические единицы.|
|[CDC:ИнтерсектКскСрезРес](#intersectcliprect)|Создает новую область отсечения, образуя пересечение текущей области и прямоугольника.|
|[CDC:InvertRect](#invertrect)|Инвертирует содержимое прямоугольника.|
|[CDC:InvertRgn](#invertrgn)|Инвертирует цвета в регионе.|
|[CDC::IsPrinting](#isprinting)|Определяет, используется ли контекст устройства для печати.|
|[CDC:LineTo](#lineto)|Рисует линию от текущего положения до, но не включая точку.|
|[CDC::LPtoDP](#lptodp)|Преобразует логические блоки в блоки устройств.|
|[CDC::LPtoHIMETRIC](#lptohimetric)|Преобразует логические единицы в единицы HIMETRIC.|
|[CDC::Маскблт](#maskblt)|Комбинирует исходные данные для исходных и клиративных карт назначения, используя данную маску и raster.|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|Изменяет преобразование мира для контекста устройства с помощью заданного режима.|
|[CDC::MoveTo](#moveto)|Перемещает текущую позицию.|
|[CDC::OffsetClipRgn](#offsetcliprgn)|Перемещает область отсечения данного устройства.|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|Изменяет происхождение порта viewport относительно координат текущего происхождения порта представления.|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|Изменяет происхождение окна относительно координат текущего происхождения окна.|
|[CDC::PaintRgn](#paintrgn)|Заполняет регион выбранной кистью.|
|[CDC::PatBlt](#patblt)|Создает немного шаблон.|
|[CDC::Pie](#pie)|Рисует пирогообразный клин.|
|[CDC::PлайМетаФайл](#playmetafile)|Воспроизведение содержимого указанного метафайла на данном устройстве. Улучшенная версия `PlayMetaFile` отображает изображение, хранящееся в данном метафиле расширенного формата. Метафайл можно воспроизводить в любое количество раз.|
|[CDC::PlgBlt](#plgblt)|Выполняет перенос бит-блоковых данных из заданного прямоугольника в контексте исходного устройства в заданную параллелограмму в данном контексте устройства.|
|[CDC::PolyBezier](#polybezier)|Рисует один или несколько Bzier splines. Текущее положение не используется и не обновляется.|
|[CDC::PolyBezierTo](#polybezierto)|Рисует один или несколько Bzier splines и перемещает текущее положение в конечную точку последнего bzier spline.|
|[CDC::PolyDraw](#polydraw)|Рисует набор сегментов линий и Bzier splines. Эта функция обновляет текущее положение.|
|[CDC::Polygon](#polygon)|Рисует полигон, состоящий из двух или более точек (вертиков), соединенных линиями.|
|[CDC::Polyline](#polyline)|Рисует набор сегментов линий, соединяющих указанные точки.|
|[CDC::PolylineTo](#polylineto)|Рисует одну или несколько прямых линий и перемещает текущее положение в конечную точку последней строки.|
|[CDC: :PolyPolygon](#polypolygon)|Создает два или более полигонов, которые заполняются с помощью текущего режима заполнения полигона. Полигоны могут быть разрозненными или перекрываться.|
|[CDC::PolyPolyline](#polypolyline)|Рисует несколько серий связанных сегментов линий. Текущее положение не используется и не обновляется этой функцией.|
|[CDC::P](#ptvisible)|Определяет, находится ли данный пункт в пределах области отсечения.|
|[CDC::RealizePalette](#realizepalette)|Карты палитры записей в текущей логической палитры в системной палитре.|
|[CDC::Rectangle](#rectangle)|Рисует прямоугольник с помощью текущей ручки и заполняет его с помощью текущей кисти.|
|[CDC::RectVisible](#rectvisible)|Определяет, находится ли какая-либо часть данного прямоугольника в области отсечения.|
|[CDC::ReleaseAttribDC](#releaseattribdc)|Релизы, `m_hAttribDC`контекст атрибута устройства.|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|Релизы, `m_hDC`контекст выходного устройства.|
|[CDC:ResetDC](#resetdc)|Обновляет `m_hAttribDC` контекст устройства.|
|[CDC::RestoreDC](#restoredc)|Восстановление контекста устройства в предыдущем `SaveDC`состоянии, сохраненном с помощью .|
|[CDC::RoundRect](#roundrect)|Рисует прямоугольник с закругленными углами с помощью текущей ручки и заполнены с помощью текущей кисти.|
|[CDC::SaveDC](#savedc)|Сохраняет текущее состояние контекста устройства.|
|[CDC::ScaleViewportExt](#scaleviewportext)|Изменяет размер обзора относительно текущих значений.|
|[CDC::ScaleWindowExt](#scalewindowext)|Изменяет размеры окна относительно текущих значений.|
|[CDC::ScrollDC](#scrolldc)|Прокрутите прямоугольник битов горизонтально и вертикально.|
|[CDC:SelectClipPath](#selectclippath)|Выбрав текущий путь в качестве области отсечения для контекста устройства, объединив новый регион с любым существующим регионом отсечения с помощью заданного режима.|
|[CDC:SelectClipRgn](#selectcliprgn)|Комбинирует данный регион с текущим областью отсечения с помощью указанного режима.|
|[CDC::SelectObject](#selectobject)|Выбирает объект gDI, например ручку.|
|[CDC::SelectPalette](#selectpalette)|Выбирает логическую палитру.|
|[CDC::SelectStockObject](#selectstockobject)|Выбирает один из предопределенных фондовых ручек, кистей или шрифтов, предоставленных Windows.|
|[CDC::SetAbortProc](#setabortproc)|Устанавливает функцию обратного вызова, которую предоставляет Windows, если задание печати должно быть прервано.|
|[CDC:SetArcDirection](#setarcdirection)|Устанавливает направление чертежа, используемое для функций дуги и прямоугольника.|
|[CDC::SetAttribDC](#setattribdc)|Наборы, `m_hAttribDC`контекст устройства атрибута.|
|[CDC::SetBkColor](#setbkcolor)|Устанавливает текущий цвет фона.|
|[CDC::SetBkMode](#setbkmode)|Устанавливает фоновый режим.|
|[CDC::SetBoundsRect](#setboundsrect)|Контролирует накопление информации о границах прямоугольника для указанного контекста устройства.|
|[CDC::SetBrushOrg](#setbrushorg)|Определяет происхождение следующей кисти, выбранной в контексте устройства.|
|[CDC::SetColorAdjustment](#setcoloradjustment)|Устанавливает значения регулировки цвета для контекста устройства с помощью указанных значений.|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|Устанавливает текущий цвет кисти.|
|[CDC::SetDCPenColor](#setdcpencolor)|Устанавливает текущий цвет пера.|
|[CDC::SetGraphicsMode](#setgraphicsmode)|Устанавливает текущий графический режим для заданного контекста устройства.|
|[CDC::SetLayout](#setlayout)|Изменяет расположение контекста устройства (DC).|
|[CDC:SetMapMode](#setmapmode)|Устанавливает текущий режим отображения.|
|[CDC::SetMapperFlags](#setmapperflags)|Изменяет алгоритм, который использует картограф шрифтов, когда он отображает логические шрифты физическим шрифтам.|
|[CDC::SetMiterLimit](#setmiterlimit)|Устанавливает ограничение длины митера для контекста устройства.|
|[CDC::SetOutputDC](#setoutputdc)|Устанавливает `m_hDC`контекст выходного устройства.|
|[CDC::SetPixel](#setpixel)|Устанавливает пиксель в указанной точке к близкому приближению указанного цвета.|
|[CDC::SetPixelV](#setpixelv)|Устанавливает пиксель в указанных координатах к близкому приближению указанного цвета. `SetPixelV`быстрее, `SetPixel` чем потому, что ему не нужно возвращать цветовое значение точки на самом деле окрашены.|
|[CDC::SetPolyFillMode](#setpolyfillmode)|Устанавливает режим заполнения полигона.|
|[CDC::SetROP2](#setrop2)|Устанавливает текущий режим рисования.|
|[CDC::SetStretchBltMode](#setstretchbltmode)|Устанавливает режим растяжения биткарты.|
|[CDC::SetTextAlign](#settextalign)|Устанавливает флаги выравнивания текста.|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|Устанавливает количество интервалов между персонажами.|
|[CDC::SetTextColor](#settextcolor)|Задает цвет текста.|
|[CDC::SetTextОправдание](#settextjustification)|Добавляет пространство для символов разрыва в строке.|
|[CDC::SetViewportExt](#setviewportext)|Устанавливает x- и y-объемы viewport.|
|[CDC::SetViewportOrg](#setviewportorg)|Устанавливает происхождение порта просмотра.|
|[CDC::SetWindowExT](#setwindowext)|Устанавливает x- и y-объемы связанного окна.|
|[CDC::SetWindowOrg](#setwindoworg)|Устанавливает происхождение окна контекста устройства.|
|[CDC::SetWorldTransform](#setworldtransform)|Устанавливает текущее мировое пространство на преобразование пространства страницы.|
|[CDC::StartDoc](#startdoc)|Информирует драйвер устройства о начале нового задания печати.|
|[CDC::StartPage](#startpage)|Сообщает водителю устройства о запуске новой страницы.|
|[CDC::StretchBlt](#stretchblt)|Перемещает битную карту из прямоугольника источника и устройства в прямоугольник назначения, растягивая или сжимая битную карту, если это необходимо, чтобы соответствовать размерам прямоугольника назначения.|
|[CDC:Strokeandfillpath](#strokeandfillpath)|Закрывает любые открытые фигуры в пути, поражает контур пути с помощью текущей ручки, и заполняет его интерьер с помощью текущей кисти.|
|[CDC::StrokePath](#strokepath)|Рендеризирует указанный путь с помощью текущего пера.|
|[CDC:TabbedTextOut](#tabbedtextout)|Записывает строку символов в указанном месте, расширяя вкладки на значения, указанные в массиве позиций остановки вкладок.|
|[CDC:TextOut](#textout)|Записывает строку символов в указанном месте с помощью выбранного в настоящее время шрифта.|
|[CDC::TransparentBlt](#transparentblt)|Перевод бит-блока цветовых данных из заданного контекста исходного устройства в контекст устройства назначения делает определенный цвет прозрачным в передаче.|
|[CDC:UpdateColors](#updatecolors)|Обновляет область клиента контекста устройства, сопоставляя текущие цвета в области клиента с системной палитрой на основе пикселей за пикселем.|
|[CDC:WidenPath](#widenpath)|Переопределяет текущий путь как область, которая будет окрашена, если путь был погладил с помощью пера в настоящее время выбран в контексте устройства.|

### <a name="public-operators"></a>Открытые операторы

|Имя|Описание|
|----------|-----------------|
|[CDC:оператор HDC](#operator_hdc)|Извлекает ручку контекста устройства.|

### <a name="public-data-members"></a>Открытые члены данных

|Имя|Описание|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|Контекст атрибута-устройства, `CDC` используемый этим объектом.|
|[CDC::m_hDC](#m_hdc)|Контекст вывода устройства, используемый этим `CDC` объектом.|

## <a name="remarks"></a>Remarks

Объект `CDC` предоставляет функции участника для работы с контекстом устройства, например отображением или принтером, а также участниками для работы с контекстом отображения, связанным с областью клиента окна.

Делайте все чертежи `CDC` через функции члена объекта. Класс предоставляет функции членов для операций с контекстом устройства, работы с инструментами рисования, выбора объектов интерфейса графического интерфейса (GDI) с безопасностью типов, а также работы с цветами и палитрами. Он также предоставляет функции членов для получения и настройки атрибутов рисования, отображения, работы с областью обзора, работы с уровнем окна, преобразования координат, работы с регионами, отсечения, рисования линий и рисования простых фигур, эллипсов и полигонов. Функции участника также предусмотрены для рисования текста, работы с шрифтами, использования побегов принтеров, прокрутки и воспроизведения метафайлов.

Чтобы использовать `CDC` объект, создайте его, а затем позвоните его функциям-членам, которые параллельны функциям Windows, которые используют контексты устройств.

> [!NOTE]
> Под Windows 95/98 все координаты экрана ограничены 16 битами. Таким образом, **Int** `CDC` переданы член функции должны лежать в диапазоне -32768 до 32767.

Для конкретных применений библиотека класса Фонда Майкрософт предоставляет несколько классов, полученных из `CDC` . `CPaintDC`инкапсулирует звонки и `BeginPaint` `EndPaint`. `CClientDC`управляет контекстом отображения, связанным с областью клиента окна. `CWindowDC`управляет контекстом отображения, связанным со всем окном, включая его рамку и элементы управления. `CMetaFileDC`ассоциирует контекст устройства с метафайлом.

`CDC`предоставляет две функции участника, [GetLayout](#getlayout) и [SetLayout](#setlayout), для обращения вспять макет контекста устройства, который не наследует его макет из окна. Такая ориентация справа налево необходима для приложений, написанных для культур, таких как арабский или иврит, где макет характера не является европейским стандартом.

`CDC`содержит два контекста устройства, [m_hDC](#m_hdc) и [m_hAttribDC,](#m_hattribdc)которые, при создании `CDC` объекта, относятся к одному и тому же устройству. `CDC`направляет все выходные вызовы GDI `m_hDC` и `m_hAttribDC`большинство атрибутов GDI-звонков . (Пример вызова атрибута `GetTextColor`— `SetTextColor` это вызов вывода.)

Например, фреймворк использует эти `CMetaFileDC` два контекста устройства для реализации объекта, который будет отправлять вывод на метафайл при чтении атрибутов с физического устройства. Предварительный просмотр печати реализуется в рамках аналогичным образом. Вы также можете использовать два контекста устройства аналогичным образом в коде конкретного приложения.

Иногда может потребоваться текстовая информация `m_hDC` как `m_hAttribDC` из контекста, так и из контекста устройства. Следующие пары функций обеспечивают эту возможность:

|Использует m_hAttribDC|Использует m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

Для получения `CDC`дополнительной [информации](../../mfc/device-contexts.md)о, см.

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>Требования

**Заголовок:** afxwin.h

## <a name="cdcabortdoc"></a><a name="abortdoc"></a>CDC::AbortDoc

Прекращает текущее задание печати и стирает все, что приложение написало на устройство с момента последнего вызова к функции участника [StartDoc.](#startdoc)

```
int AbortDoc();
```

### <a name="return-value"></a>Возвращаемое значение

Значение, превышающее или равное 0 в случае успеха, или отрицательное значение, если произошла ошибка. В следующем списке указаны общие значения ошибок и их значения:

- SP_ERROR общая ошибка.

- SP_OUTOFDISK недостаточное пространство диска в настоящее время доступно для spooling, и больше не будет доступно пространство.

- SP_OUTOFMEMORY Недостаточно памяти доступно для spooling.

- SP_USERABORT пользователь прекратил работу через менеджер печати.

### <a name="remarks"></a>Remarks

Эта функция члена заменяет побег принтера ABORTDOC.

`AbortDoc`должны быть использованы для прекращения следующих

- Операции печати, в которых не указана функция прерывания работы с помощью [SetAbortProc.](#setabortproc)

- Печать операций, которые еще не достигли своего первого NEWFRAME или NEXTBAND избежать вызова.

Если приложение сталкивается с ошибкой печати или отмененной операцией печати, оно не `AbortDoc` должно пытаться `CDC`завершить операцию, используя либо [функции EndDoc,](#enddoc) либо функции члена класса. GDI автоматически завершает операцию перед возвратом значения ошибки.

Если приложение отображает диалоговый ящик, чтобы позволить пользователю отменить `AbortDoc` операцию печати, он должен вызвать перед уничтожением диалогового окна.

Если менеджер печати был использован для `AbortDoc` запуска задания печати, вызов стирает всю работу катушки - принтер ничего не получает. Если менеджер печати не использовался для запуска задания печати, данные могли быть отправлены на принтер до того, `AbortDoc` как он был вызван. В этом случае драйвер принтера сбросить принтер (когда это возможно) и закрыть задание печати.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::StartDoc](#startdoc).

## <a name="cdcabortpath"></a><a name="abortpath"></a>CDC::AbortPath

Закрывает и отбрасывает любые пути в контексте устройства.

```
BOOL AbortPath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

При наличии в контексте устройства имеется открытая кронштейна пути, кронштейн пути закрывается и путь отбрасывается. При наличии закрытого пути в контексте устройства путь отбрасывается.

## <a name="cdcaddmetafilecomment"></a><a name="addmetafilecomment"></a>CDC:AddMetaFileКомментарий

Копирует комментарий из буфера в указанный метафайл расширенного формата.

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>Параметры

*nDataSize*<br/>
Упоняет длину буфера комментария в байтах.

*pCommentData*<br/>
Указывает на буфер, содержащий комментарий.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Комментарий может включать любую личную информацию - например, источник изображения и дату ее создания. Комментарий должен начинаться с подписи приложения, за которой следуют данные. Комментарии не должны содержать данные, связанные с позицией. Данные, относятся для определения позиции, определяют местоположение записи, и они не должны быть включены, поскольку один метафайл может быть встроен в другой метафайл. Эта функция может использоваться только с улучшенными метафайлами.

## <a name="cdcalphablend"></a><a name="alphablend"></a>CDC::AlphaBlend

Вызовите эту функцию участника для отображения бит-карт с прозрачными или полупрозрачными пикселями.

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>Параметры

*xDest*<br/>
Определяет x-координацию, в логических единицах, верхнего левого угла прямоугольника назначения.

*yDest*<br/>
Определяет y-координацию, в логических единицах, верхнего левого угла прямоугольника назначения.

*nDestWidth*<br/>
Определяет ширину, в логических единицах, прямоугольника назначения.

*nDestHeight*<br/>
Определяет высоту, в логических единицах, прямоугольника назначения.

*pSrcDC*<br/>
Указатель на контекст исходного устройства.

*xSrc*<br/>
Определяет x-координацию, в логических единицах, верхнего левого угла прямоугольника источника.

*ySrc*<br/>
Определяет y-координацию, в логических единицах, верхнего левого угла прямоугольника источника.

*nSrcWidth*<br/>
Определяет ширину в логических единицах прямоугольника источника.

*nSrcHeight*<br/>
Определяет высоту, в логических единицах, прямоугольника источника.

*Смесь*<br/>
Определяет структуру [BLENDFUNCTION.](/windows/win32/api/wingdi/ns-wingdi-blendfunction)

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если успешно; в противном случае — FALSE.

### <a name="remarks"></a>Remarks

Для получения дополнительной информации можно узнать в [SDK Windows.](/windows/win32/api/wingdi/nf-wingdi-alphablend)

## <a name="cdcanglearc"></a><a name="anglearc"></a>CDC::AngleArc

Рисует линейный сегмент и дугу.

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию центра круга.

*Y*<br/>
Определяет логическую y-координацию центра круга.

*nРадиус*<br/>
Определяет радиус круга в логических единицах. Это значение должно быть положительным.

*fStartAngle*<br/>
Определяет начальный угол в градусах относительно оси x.

*fSweepAngle*<br/>
Определяет угол развертки в градусах относительно стартового угла.

### <a name="return-value"></a>Возвращаемое значение

Имеет ненулевое значение в случае успешного выполнения, иначе — 0.

### <a name="remarks"></a>Remarks

Сегмент линии нарисован от текущего положения до начала дуги. Дуга нарисована по периметру круга с заданным радиусом и центром. Длина дуги определяется заданным и подметальным углом.

`AngleArc`перемещает текущее положение в конечную точку дуги. Дуга, нарисованная этой функцией, может показаться эллиптической, в зависимости от текущего режима преобразования и отображения. Перед рисованием дуги эта функция рисует сегмент линии от текущего положения до начала дуги. Дуга нарисована путем построения воображаемого круга с указанным радиусом вокруг указанной центральной точки. Отправная точка дуги определяется путем измерения против часовой стрелки от x-оси круга по количеству градусов в стартовом углу. Конечная точка также расположена путем измерения против часовой стрелки от отправной точки на количество градусов в углу развертки.

Если угол развертки превышает 360 градусов, дуга сметается несколько раз. Эта функция рисует линии с помощью текущего пера. Цифра не заполнена.

## <a name="cdcarc"></a><a name="arc"></a>CDC::Arc

Рисует эллиптической дуги.

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет x-координат верхнего левого угла ограничивающего прямоугольника (в логических единицах).

*y1*<br/>
Определяет y-координат верхнего левого угла ограничивающего прямоугольника (в логических единицах).

*x2*<br/>
Определяет x-координат в нижнем правом углу граничащий прямоугольник (в логических единицах).

*y2*<br/>
Определяет y-координат нижнего правого угла ограничивающего прямоугольника (в логических единицах).

*x3*<br/>
Определяет x-координацию точки, определяющей отправную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*y3*<br/>
Определяет y-координацию точки, определяющей отправную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*x4*<br/>
Определяет x-координацию точки, определяющей конечную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*y4*<br/>
Определяет y-координацию точки, определяющей конечную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*lpRect*<br/>
Определяет ограничивающий прямоугольник (в логических единицах). Вы можете пройти либо LPRECT или [CRect](../../atl-mfc-shared/reference/crect-class.md) объект для этого параметра.

*ptStart*<br/>
Определяет x- и y-координаты точки, определяющей отправную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге. Для этого параметра можно пройти либо структуру [POINT,](/windows/win32/api/windef/ns-windef-point) либо объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*ptEnd*<br/>
Определяет x- и y-координаты точки, определяющие конечную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Дуга, нарисованная с помощью функции, представляет собой сегмент эллипса, определяемый указанным связующим прямоугольником.

Фактической отправной точкой дуги является точка, в которой луч, извлеченный из центра связующего прямоугольника через указанную отправную точку, пересекает эллипс. Фактическая конечная точка дуги — это точка, в которой луч, извлеченный из центра связующего прямоугольника через указанную конечную точку, пересекает эллипс. Дуга нарисована в направлении против часовой стрелки. Так как дуга не является закрытой фигурой, она не заполняется. Ширина и высота прямоугольника должны быть больше 2 единиц и менее 32 767 единиц.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

## <a name="cdcarcto"></a><a name="arcto"></a>CDC::Аркто

Рисует эллиптической дуги.

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет x-координат верхнего левого угла ограничивающего прямоугольника (в логических единицах).

*y1*<br/>
Определяет y-координат верхнего левого угла ограничивающего прямоугольника (в логических единицах).

*x2*<br/>
Определяет x-координат в нижнем правом углу граничащий прямоугольник (в логических единицах).

*y2*<br/>
Определяет y-координат нижнего правого угла ограничивающего прямоугольника (в логических единицах).

*x3*<br/>
Определяет x-координацию точки, определяющей отправную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*y3*<br/>
Определяет y-координацию точки, определяющей отправную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*x4*<br/>
Определяет x-координацию точки, определяющей конечную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*y4*<br/>
Определяет y-координацию точки, определяющей конечную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*lpRect*<br/>
Определяет ограничивающий прямоугольник (в логических единицах). Вы можете передать либо указатель на структуру данных [RECT,](/windows/win32/api/windef/ns-windef-rect) либо объект [CRect](../../atl-mfc-shared/reference/crect-class.md) для этого параметра.

*ptStart*<br/>
Определяет x- и y-координаты точки, определяющей отправную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге. Для этого параметра можно передать либо структуру данных [POINT,](/windows/win32/api/windef/ns-windef-point) либо объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*ptEnd*<br/>
Определяет x- и y-координаты точки, определяющие конечную точку дуги (в логических единицах). Этот пункт не должен лежать точно на дуге. Для этого параметра можно передать либо структуру `POINT` данных, либо `CPoint` объект.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция `CDC::Arc`аналогична, за исключением того, что текущее положение обновляется. Точки *(x1*, *y1)* и *(x2*, *y2)* указать прямоугольник. Эллипс, образованный данным связующим прямоугольником, определяет кривую дуги. Дуга простирается против часовой стрелки (направление дуги по умолчанию) от точки, где она пересекает радиальную линию от центра граничащий прямоугольник *(x3*, *y3*). Дуга заканчивается там, где пересекает радиальную линию от центра граничащий прямоугольник до *(x4,* *y4*). Если отправная точка и конечная точка одинаковы, нарисован полный эллипс.

Линия нарисована от текущего положения до отправной точки дуги. Если ошибки не происходит, текущее положение устанавливается в конечную точку дуги. Дуга нарисована с помощью текущей ручки; она не заполнена.

## <a name="cdcattach"></a><a name="attach"></a>CDC::Прикрепите

Используйте эту функцию члена, `CDC` чтобы прикрепить *hDC* к объекту.

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>Параметры

*Hdc*<br/>
Контекст устройства Windows.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

*HDC* хранится как `m_hDC`в контексте устройства `m_hAttribDC`вывода, так и в контексте атрибута устройства.

## <a name="cdcbeginpath"></a><a name="beginpath"></a>CDC::BeginPath

Открывает кронштейн пути в контексте устройства.

```
BOOL BeginPath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

После открытия кронштейна пути приложение может начать вызывать функции gDI рисования для определения точек, лежащих на пути. Приложение может закрыть кронштейн открытого `EndPath` пути, позвонив в функцию участника. При вызове `BeginPath`приложения любые предыдущие пути отбрасываются.

Смотрите [BeginPath](/windows/win32/api/wingdi/nf-wingdi-beginpath) в SDK Windows для списка функций чертежа, которые определяют точки в пути.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

## <a name="cdcbitblt"></a><a name="bitblt"></a>CDC:BitBlt

Копирует битную карту из контекста исходного устройства в текущем контексте устройства.

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координатум верхнего левого угла прямоугольника назначения.

*Y*<br/>
Определяет логическую y-координацию верхнего левого угла прямоугольника назначения.

*nWidth*<br/>
Определяет ширину (в логических единицах) прямоугольника назначения и исходной биткарты.

*nВысота*<br/>
Определяет высоту (в логических единицах) прямоугольника назначения и исходную бит-карту.

*pSrcDC*<br/>
Указатель на `CDC` объект, который определяет контекст устройства, с которого будет скопирована битовая карта. Он должен быть NULL, если *dwRop* указывает raster операции, которая не включает в себя источник.

*xSrc*<br/>
Определяет логическую х-координацию верхнего левого угла исходной биткарты.

*ySrc*<br/>
Определяет логическую y-координацию верхнего левого угла исходной биткарты.

*dwRop*<br/>
Определяет подлежащую выполнению растровую операцию. Коды Raster-operation определяют, как GDI сочетает в себе цвета в выходных операциях, которые включают текущую кисть, возможную битную карту исхода и битную карту назначения. Смотрите [BitBlt](/windows/win32/api/wingdi/nf-wingdi-bitblt) в Windows SDK для списка raster-операционных кодов для *dwRop* и их описания

Полный список кодов raster-operation [см.](/windows/win32/gdi/raster-operation-codes)

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Приложение может выровнять окна или области клиента на `BitBlt` границах байт, чтобы гарантировать, что операции происходят на прямоугольниках, выровненных на байте. (Установите CS_BYTEALIGNWINDOW или CS_BYTEALIGNCLIENT флаги при регистрации классов окон.)

`BitBlt`операции на выровненных в байт-выровненных прямоугольниках значительно быстрее, чем `BitBlt` операции на прямоугольниках, которые не выровнены. Если вы хотите указать стили классов, такие как выравнивание байт для вашего собственного контекста устройства, вам придется зарегистрировать класс окон, а не полагаться на классы Фонда Майкрософт, чтобы сделать это за вас. Используйте глобальную функцию [AfxRegisterWndClass.](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)

GDI преобразует *nWidth* и *nHeight,* один раз с помощью контекста устройства назначения и один раз с помощью контекста исходного устройства. Если полученные степени не совпадают, GDI использует функцию Windows `StretchBlt` для сжатия или растяжения исходной биткарты по мере необходимости.

Если киксы назначения, источника и шаблонных `BitBlt` битов не имеют одного и того же цветового формата, функция преобразует исходные карты источника и шаблона в соответствии с пунктом назначения. В преобразовании используются цвета переднего плана и фона битовой карты назначения.

Когда `BitBlt` функция преобразует монохромную битную карту в цвет, она устанавливает белые биты (1) в цвет фона и черные биты (0) в цвет переднего плана. Используются цвета переднего плана и фона контекста устройства назначения. Чтобы преобразовать цвет `BitBlt` в монохромный, устанавливает пиксели, которые соответствуют цвету фона на белый и устанавливает все другие пиксели на черный. `BitBlt`использует передний план и фоновые цвета контекста цветного устройства для преобразования из цвета в монохромный.

Обратите внимание, что не `BitBlt`все контексты устройства поддерживаются. Чтобы проверить, поддерживается `BitBlt`ли данный `GetDeviceCaps` контекст устройства, используйте функцию участника и укажите индекс RASTERCAPS.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::CreateCompatibleDC](#createcompatibledc).

## <a name="cdccdc"></a><a name="cdc"></a>CDC::CDC

Формирует объект `CDC`.

```
CDC();
```

## <a name="cdcchord"></a><a name="chord"></a>CDC:Chord

Рисует аккорд (закрытая фигура, ограниченная пересечением эллипса и сегмента линии).

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет x-координат верхнего левого угла связующего прямоугольника аккорда (в логических единицах).

*y1*<br/>
Определяет y-координат верхнего левого угла связующего прямоугольника аккорда (в логических единицах).

*x2*<br/>
Определяет x-координат в правом нижнем углу связующего прямоугольника аккорда (в логических единицах).

*y2*<br/>
Определяет y-координат нижнего правого угла связующего прямоугольника аккорда (в логических единицах).

*x3*<br/>
Определяет x-координацию точки, определяющей отправную точку аккорда (в логических единицах).

*y3*<br/>
Определяет y-координацию точки, определяющей отправную точку аккорда (в логических единицах).

*x4*<br/>
Определяет x-координацию точки, определяющей конечную точку аккорда (в логических единицах).

*y4*<br/>
Определяет y-координацию точки, определяющей конечную точку аккорда (в логических единицах).

*lpRect*<br/>
Определяет ограничивающий прямоугольник (в логических единицах). Вы можете пройти либо LPRECT или [CRect](../../atl-mfc-shared/reference/crect-class.md) объект для этого параметра.

*ptStart*<br/>
Определяет x- и y-координаты точки, определяющей отправную точку аккорда (в логических единицах). Этот момент не должен лежать именно на аккорде. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

*ptEnd*<br/>
Определяет x- и y-координаты точки, определяющие конечную точку аккорда (в логических единицах). Этот момент не должен лежать именно на аккорде. Для этого параметра можно пройти либо структуру [POINT,](/windows/win32/api/windef/ns-windef-point) либо объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Параметры *(x1,* *y1)* и *(x2,* *y2)* указывают верхний левый и нижний правый углы, соответственно, прямоугольника, ограничивающего эллипс, который является частью аккорда. Параметры *(x3,* *y3)* и *(x4,* *y4)* указывают конечные точки линии, пересекающие эллипс. Аккорд нарисован с помощью выбранной ручки и заполняется с помощью выбранной кисти.

Рисунок, нарисованный функцией, `Chord` простирается до, но не включает правые и нижние координаты. Это означает, что высота фигуры *y2* - *y1* и ширина фигуры *x2* - *x1.*

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

## <a name="cdcclosefigure"></a><a name="closefigure"></a>CDC:CloseFigure

Закрывает открытую фигуру в пути.

```
BOOL CloseFigure();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Функция закрывает фигуру, рисуя линию от текущего положения к первой точке фигуры (обычно, точка, указанная последним вызовом функции `MoveTo` члена) и соединяет линии, используя стиль соединения строки. Если фигура закрывается с `LineTo` помощью `CloseFigure`функции члена вместо, конечные колпачки используются для создания угла вместо соединения. `CloseFigure`только при наличии открытой кронштейна пути в контексте устройства.

Фигура в пути открыта, если она явно не закрыта с помощью этой функции. (Цифра может быть открыта, даже если текущая точка и отправная точка фигуры одинаковы.) Любая строка или кривая, добавленная к пути после `CloseFigure` запуска новой фигуры.

## <a name="cdccreatecompatibledc"></a><a name="createcompatibledc"></a>CDC::СозданиеCompatibleDC

Создает контекст устройства памяти, совместимый с устройством, указанным *pDC.*

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>Параметры

*pDC*<br/>
Указатель на контекст устройства. Если *pDC* null, функция создает контекст устройства памяти, который совместим с системным дисплеем.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Контекст устройства памяти — это блок памяти, представляющий поверхность дисплея. Он может быть использован для подготовки изображений в памяти, прежде чем копировать их на фактическую поверхность устройства совместимого устройства.

При создании контекста устройства памяти GDI автоматически выбирает для него монохромную битную карту 1 на 1. Функции вывода GDI могут использоваться в контексте устройства памяти только в том случае, если в этом контексте была создана и выбрана бит-карта.

Эта функция может использоваться только для создания совместимых контекстов устройств для устройств, поддерживающих операции raster. См. функцию члена [CDC:BitBlt](#bitblt) для получения информации о переносе бит-блоков между контекстами устройств. Чтобы определить, поддерживает ли контекст устройства операции raster, см. `CDC::GetDeviceCaps`возможность RC_BITBLT raster в функции элемента.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

## <a name="cdccreatedc"></a><a name="createdc"></a>CDC::CreateDC

Создает контекст устройства для указанного устройства.

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Параметры

*lpszDriverName*<br/>
Указывает на строку с нулевым завершением, которая определяет имя файла (без расширения) драйвера устройства (например, "EPSON"). Вы также можете `CString` передать объект для этого параметра.

*lpszDeviceName*<br/>
Указывает на нулевую строку, определяющую название конкретного устройства, которое будет поддерживаться (например, "EPSON FX-80"). Параметр *lpszDeviceName* используется, если модуль поддерживает более одного устройства. Вы также можете `CString` передать объект для этого параметра.

*lpszOutput*<br/>
Указывает на строку с нулевым завершением, которая определяет имя файла или устройства для физической среды вывода (файл или выходной порт). Вы также можете `CString` передать объект для этого параметра.

*lpInitData*<br/>
Указывает на `DEVMODE` структуру, содержащую данные инициализации устройства для драйвера устройства. Функция `DocumentProperties` Windows получает эту структуру, заполненную для данного устройства. Параметр *lpInitData* должен быть NULL, если водитель устройства использует инициализацию по умолчанию (если таковая имеется), указанную пользователем через панель управления.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

ПРИНПРИ. Файл заголовка H необходим, если используется структура [DEVMODE.](/windows/win32/api/wingdi/ns-wingdi-devmodea)

Названия устройств следуют этим конвенциям: окончание толстой кишки (:) рекомендуется, но необязательно. Windows лишает прекращающуюся толстую кишку так, чтобы название устройства, закончившееся толстой кишка, отображалось в том же порту, что и то же имя без толстой кишки. Названия драйверов и портов не должны содержать ведущие или задние пространства. Функции вывода GDI не могут использоваться в информационных контекстах.

## <a name="cdccreateic"></a><a name="createic"></a>CDC::CreateIC

Создает информационный контекст для указанного устройства.

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>Параметры

*lpszDriverName*<br/>
Указывает на строку с нулевым завершением, которая определяет имя файла (без расширения) драйвера устройства (например, "EPSON"). Вы можете `CString` передать объект для этого параметра.

*lpszDeviceName*<br/>
Указывает на нулевую строку, определяющую название конкретного устройства, которое будет поддерживаться (например, "EPSON FX-80"). Параметр *lpszDeviceName* используется, если модуль поддерживает более одного устройства. Вы можете `CString` передать объект для этого параметра.

*lpszOutput*<br/>
Указывает на строку с нулевым завершением, которая определяет имя файла или устройства для физической среды вывода (файла или порта). Вы можете `CString` передать объект для этого параметра.

*lpInitData*<br/>
Указывает на данные инициализации устройства для драйвера устройства. Параметр *lpInitData* должен быть NULL, если водитель устройства использует инициализацию по умолчанию (если таковая имеется), указанную пользователем через панель управления. Просидляйте `CreateDC` формат данных для инициализации конкретного устройства.

### <a name="return-value"></a>Возвращаемое значение

Имеет ненулевое значение в случае успешного выполнения, иначе — 0.

### <a name="remarks"></a>Remarks

Информационный контекст обеспечивает быстрый способ получения информации об устройстве без создания контекста устройства.

Названия устройств следуют этим конвенциям: окончание толстой кишки (:) рекомендуется, но необязательно. Windows лишает прекращающуюся толстую кишку так, чтобы название устройства, закончившееся толстой кишка, отображалось в том же порту, что и то же имя без толстой кишки. Названия драйверов и портов не должны содержать ведущие или задние пространства. Функции вывода GDI не могут использоваться в информационных контекстах.

## <a name="cdcdeletedc"></a><a name="deletedc"></a>CDC::DeleteDC

В общем, не называйте эту функцию; деструктор сделает это за вас.

```
BOOL DeleteDC();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция успешно завершена; в противном случае 0.

### <a name="remarks"></a>Remarks

Функция `DeleteDC` участника удаляет контексты устройства Windows, `m_hDC` связанные `CDC` с текущим объектом. Если `CDC` этот объект является последним активным контекстом устройства для данного устройства, устройство уведомляется и все ресурсы хранения и системы, используемые устройством, освобождаются.

Приложение не должно `DeleteDC` вызываться, если объекты были выбраны в контексте устройства. Объекты должны быть сначала выбраны из контекста устройства, прежде чем он будет удален.

Приложение не должно удалять контекст устройства, рукоятки которого были получены по телефону [CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc). Вместо этого он должен вызвать [CWnd::ReleaseDC,](../../mfc/reference/cwnd-class.md#releasedc) чтобы освободить контекст устройства. Для обертывания этой функциональности предусмотрены классы [CClientDC](../../mfc/reference/cclientdc-class.md) и [CWindowDC.](../../mfc/reference/cwindowdc-class.md)

Функция `DeleteDC` обычно используется для удаления контекстов устройств, созданных с [помощью CreateDC,](#createdc) [CreateIC](#createic)или [CreateCompatibleDC.](#createcompatibledc)

### <a name="example"></a>Пример

  Смотрите пример [для CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcdeletetempmap"></a><a name="deletetempmap"></a>CDC::DeleteTempMap

Вызывается автоматически `CWinApp` обработчиком `DeleteTempMap` простоя, `CDC` удаляет `FromHandle`любые временные объекты, созданные, но не разрушает ручки контекста устройства (s), `hDC`временно связанные с `CDC` объектами.

```
static void PASCAL DeleteTempMap();
```

## <a name="cdcdetach"></a><a name="detach"></a>CDC::Detach

Вызовите эту функцию, чтобы `m_hDC` отделить (контекст выходного устройства) от `CDC` объекта и установить оба `m_hDC` и `m_hAttribDC` NULL.

```
HDC Detach();
```

### <a name="return-value"></a>Возвращаемое значение

Контекст устройства Windows.

## <a name="cdcdptohimetric"></a><a name="dptohimetric"></a>CDC::DPtoHIMETRIC

Используйте эту функцию, когда вы даете HIMETRIC размеры OLE, преобразовывая пиксели в HIMETRIC.

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*lpSize*<br/>
Указывает на структуру [СИЗЕ](/windows/win32/api/windef/ns-windef-size) или объект [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Если режим отображения объекта контекста устройства находится MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC или MM_HIMETRIC, то преобразование основано на количестве пикселей в физическом дюйме. Если режим отображения является одним из других неограниченных режимов (например, MM_TEXT), то преобразование основано на количестве пикселей в логическом дюйме.

## <a name="cdcdptolp"></a><a name="dptolp"></a>CDC::DPtoLP

Преобразует блоки устройств в логические единицы.

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив структур [POINT](/windows/win32/api/windef/ns-windef-point) или объектов [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*Ncount*<br/>
Количество точек в массиве.

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect.](../../atl-mfc-shared/reference/crect-class.md) Этот параметр используется для простого случая преобразования одного прямоугольника из точек устройства в логические точки.

*lpSize*<br/>
Указывает на структуру [СИЗЕ](/windows/win32/api/windef/ns-windef-size) или объект [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Функция отображает координаты каждой точки или размера от системы координат устройства до системы логических координат GDI. Преобразование зависит от текущего режима отображения и параметров происхождения и размеров окна и порта обзора устройства.

## <a name="cdcdraw3drect"></a><a name="draw3drect"></a>CDC::Draw3dRect

Вызовите эту функцию члена, чтобы нарисовать трехмерный прямоугольник.

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Определяет ограничивающий прямоугольник (в логических единицах). Вы можете передать либо указатель на структуру [RECT,](/windows/win32/api/windef/ns-windef-rect) либо объект [CRect](../../atl-mfc-shared/reference/crect-class.md) для этого параметра.

*clrTopLeft*<br/>
Определяет цвет верхней и левой сторон трехмерного прямоугольника.

*clrBottomRight*<br/>
Определяет цвет нижней и правой сторон трехмерного прямоугольника.

*x*<br/>
Определяет логическую х-координату арменую верхнего левого угла трехмерного прямоугольника.

*Y*<br/>
Определяет логическую y-координацию верхнего левого угла трехмерного прямоугольника.

*Cx*<br/>
Определяет ширину трехмерного прямоугольника.

*Cy*<br/>
Определяет высоту трехмерного прямоугольника.

### <a name="remarks"></a>Remarks

Прямоугольник будет нарисован с верхней и левой сторон в цвете, указанном *clrTopLeft* и нижней и правой сторонв в цвете, указанном *clrBottomRight.*

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

## <a name="cdcdrawdragrect"></a><a name="drawdragrect"></a>CDC::DrawDragRect

Неоднократно вызывайте эту функцию участника, чтобы перерисовать прямоугольник перетаскивания.

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) который определяет логические координаты прямоугольника – в этом случае перерисовывается конечная позиция прямоугольника.

*Размер*<br/>
Определяет перемещение из верхнего левого угла внешней границы в верхний левый угол внутренней границы (т.е. толщины границы) прямоугольника.

*lpRectLast*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) который определяет логические координаты положения прямоугольника – в данном случае исходное положение прямоугольника перерисовывается.

*размерПоследние*<br/>
Определяет перемещение из верхнего левого угла внешней границы в верхний левый угол внутренней границы (т.е. толщину границы) первоначального прямоугольника перерисовывается.

*pBrush*<br/>
Указатель на объект кисти. Установите null для использования кисти полутона по умолчанию.

*pBrushLast*<br/>
Указатель на последний используемый объект кисти. Установите null для использования кисти полутона по умолчанию.

### <a name="remarks"></a>Remarks

Назовите его в цикле, как вы образец мыши позиции, для того, чтобы дать визуальную обратную связь. При вызове `DrawDragRect`предыдущий прямоугольник стирается и нарисован новый. Например, когда пользователь перетаскивает прямоугольник `DrawDragRect` по экрану, он стирает исходный прямоугольник и перерисовывает новый в новом положении. По умолчанию, `DrawDragRect` рисует прямоугольник с помощью полутоновой кисти, чтобы устранить мерцание и создать видимость плавно движущегося прямоугольника.

При первом вызове `DrawDragRect`параметр *lpRectLast* должен быть NULL.

## <a name="cdcdrawedge"></a><a name="drawedge"></a>CDC::DrawEdge

Вызовите эту функцию участника, чтобы нарисовать края прямоугольника указанного типа и стиля.

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указатель на `RECT` структуру, содержащую логические координаты прямоугольника.

*nEdge*<br/>
Определяет тип внутреннего и внешнего края для рисования. Этот параметр должен быть комбинацией одного флага внутренней границы и одного флага внешней границы. Смотрите [DrawEdge](/windows/win32/api/winuser/nf-winuser-drawedge) в SDK Windows для таблицы типов параметра.

*nФлаги*<br/>
Флаги, указывающие тип нарисованной границы. Смотрите `DrawEdge` в SDK Windows для таблицы значений параметра. Для диагональных линий BF_RECT флаги указывают конечную точку вектора, ограниченного параметром прямоугольника.

### <a name="return-value"></a>Возвращаемое значение

Имеет ненулевое значение в случае успешного выполнения, иначе — 0.

## <a name="cdcdrawescape"></a><a name="drawescape"></a>CDC::DrawEscape

Доступ к возможностям рисования видеодисплея, которые не доступны напрямую через интерфейс графического устройства (GDI).

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>Параметры

*nПобег*<br/>
Определяет функцию побега, которая должна быть выполнена.

*nInputSize*<br/>
Определяет количество байтов данных, на которые указывает параметр *lpszInputData.*

*lpszInputData*<br/>
Указывает на входную структуру, необходимую для указанного побега.

### <a name="return-value"></a>Возвращаемое значение

Определяет результат функции. Больше, чем ноль, если успешно, за исключением побега рисовать КЕРИЕСКSUPPORT, который проверяет только для реализации; или ноль, если побег не реализован; или меньше нуля, если произошла ошибка.

### <a name="remarks"></a>Remarks

При вызове `DrawEscape`приложения данные, идентифицированные *nInputSize* и *lpszInputData,* передаются непосредственно указанному драйверу дисплея.

## <a name="cdcdrawfocusrect"></a><a name="drawfocusrect"></a>CDC::DrawFocusRect

Рисует прямоугольник в стиле, используемом для указания на то, что прямоугольник имеет фокус.

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) который определяет логические координаты прямоугольника, который будет нарисован.

### <a name="remarks"></a>Remarks

Так как это функция Boolean XOR, вызов этой функции во второй раз с тем же прямоугольником удаляет прямоугольник с дисплея. Прямоугольник, нарисованный этой функцией, не может быть прокрутлен. Чтобы прокрутить область, содержащую прямоугольник, нарисованный этой функцией, сначала `DrawFocusRect` позвоните, `DrawFocusRect` чтобы удалить прямоугольник с дисплея, затем прокрутите область, а затем снова вызовите, чтобы нарисовать прямоугольник в новом положении.

> [!CAUTION]
> `DrawFocusRect`работает только в MM_TEXT режиме. В других режимах эта функция не правильно рисует прямоугольник фокусировки, но не возвращает значения ошибок.

## <a name="cdcdrawframecontrol"></a><a name="drawframecontrol"></a>CDC::DrawFrameControl

Вызов ифункции этого элемента, чтобы нарисовать элемент управления кадром указанного типа и стиля.

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указатель на `RECT` структуру, содержащую логические координаты прямоугольника.

*nType*<br/>
Определяет тип управления кадром для рисования. Ознакомиться с параметром *uType* в [DrawFrameControl](/windows/win32/api/winuser/nf-winuser-drawframecontrol) можно в SDK Windows, чтобы ознакомиться со списком возможных значений этого параметра.

*nState*<br/>
Определяет начальное состояние элемента управления кадром. Может быть одно или несколько значений, описанных для параметра *uState* в `DrawFrameControl` Windows SDK. Используйте значение *nState* DFCS_ADJUSTRECT для регулировки прямоугольника, чтобы исключить окружающий край кнопки.

### <a name="return-value"></a>Возвращаемое значение

Имеет ненулевое значение в случае успешного выполнения, иначе — 0.

### <a name="remarks"></a>Remarks

В некоторых случаях *nState* зависит от параметра *nType.* В следующем списке показана взаимосвязь между четырьмя значениями *nType* и *nState:*

- DFC_BUTTON

  - кнопка «DFCS_BUTTON3STATE трех состояниях»

  - DFCS_BUTTONCHECK Проверить окно

  - кнопка «DFCS_BUTTONPUSH кнопка»

  - кнопка радио DFCS_BUTTONRADIO

  - DFCS_BUTTONRADIOIMAGE изображение для радиокнопки (неквадратное изображение)

  - DFCS_BUTTONRADIOMASK Маска для кнопки радио (неквадратная маска для нескончаемых потребностей)

- DFC_CAPTION

  - кнопка DFCS_CAPTIONCLOSE закрыть

  - DFCS_CAPTIONHELP кнопка справки

  - DFCS_CAPTIONMAX кнопка «Максимизировать»

  - кнопка DFCS_CAPTIONMIN сведению

  - кнопка DFCS_CAPTIONRESTORE восстановления

- DFC_MENU

  - DFCS_MENUARROW стрелка Подмену

  - DFCS_MENUBULLET пуля

  - DFCS_MENUCHECK Чек-метка

- DFC_SCROLL

  - DFCS_SCROLLCOMBOBOX Combo поле прокрутки бар

  - DFCS_SCROLLDOWN вниз стрелка прокрутки бар

  - DFCS_SCROLLLEFT Левая стрелка панели прокрутки

  - DFCS_SCROLLRIGHT правая стрелка панели прокрутки

  - DFCS_SCROLLSIZEGRIP Размер сцепление в правом нижнем углу окна

  - DFCS_SCROLLUP Стрелка прокрутки

### <a name="example"></a>Пример

Этот код рисует размер захвата в правом нижнем углу окна. Это подходит для `OnPaint` обработчика диалогового окна, который не имеет стилей и обычно не содержит других элементов управления (например, панель статуса), которая может дать ему размер захвата.

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

## <a name="cdcdrawicon"></a><a name="drawicon"></a>CDC::DrawIcon

Рисует значок на устройстве, `CDC` представленном текущим объектом.

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию верхнего левого угла иконы.

*Y*<br/>
Определяет логическую y-координацию верхнего левого угла иконы.

*hIcon*<br/>
Определяет ручку значка, которая будет нарисована.

*Точки*<br/>
Определяет логические x- и y-координаты верхнего левого угла иконы. Для этого параметра можно передать структуру [POINT](/windows/win32/api/windef/ns-windef-point) или объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция успешно завершена; в противном случае 0.

### <a name="remarks"></a>Remarks

Функция помещает верхний левый угол значка в место, указанное *x* и *y.* Местоположение зависит от текущего режима отображения контекста устройства.

Ресурс значка должен быть ранее загружен `CWinApp::LoadIcon`с `CWinApp::LoadStandardIcon`помощью функций, или `CWinApp::LoadOEMIcon`. Режим `MM_TEXT` отображения должен быть выбран до использования этой функции.

### <a name="example"></a>Пример

  Смотрите пример [для CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic).

## <a name="cdcdrawstate"></a><a name="drawstate"></a>CDC::D

Вызов используйте эту функцию для отображения изображения и применяйте визуальный эффект для обозначения состояния, например, отключенного состояния или состояния по умолчанию.

> [!NOTE]
> Для всех состояний *nFlag,* за исключением DSS_NORMAL, изображение преобразуется в монохромный перед визуальным эффектом.

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>Параметры

*пт*<br/>
Определяет местоположение изображения.

*Размер*<br/>
Определяет размер изображения.

*hBitmap*<br/>
Ручка к бит-карте.

*nФлаги*<br/>
Флаги, определяющие тип и состояние изображения. Смотрите [DrawState](/windows/win32/api/winuser/nf-winuser-drawstatew) в Windows SDK для возможных типов и *состояний nFlags.*

*hBrush*<br/>
Ручка ккисти.

*pBitmap*<br/>
Указатель на объект CBitmap.

*pBrush*<br/>
Указатель на объект CBrush.

*hIcon*<br/>
Дескриптор для значка.

*lpszText*<br/>
Указатель на текст.

*bPrefixТекст*<br/>
Текст, который может содержать ускоритель мнемонический. Параметр *lData* определяет адрес строки, а параметр *nTextLen* определяет длину. Если *nTextLen* равен 0, строка считается нулевой.

*nTextLen*<br/>
Длина текстовой строки, на которую указывает *lpszText*. Если *nTextLen* равен 0, строка считается нулевой.

*lpDrawProc*<br/>
Указатель на функцию обратного вызова, используемую для визуализации изображения. Этот параметр необходим, если тип изображения в *nFlags* находится DST_COMPLEX. Это необязательно и может быть NULL, если тип изображения DST_TEXT. Для всех остальных типов изображений этот параметр игнорируется. Для получения дополнительной информации о функции обратного вызова, см [функция DrawStateProc](/windows/win32/api/winuser/nc-winuser-drawstateproc) в Windows SDK.

*Ldata*<br/>
Определяет информацию об изображении. Значение этого параметра зависит от типа изображения.

### <a name="return-value"></a>Возвращаемое значение

Имеет ненулевое значение в случае успешного выполнения, иначе — 0.

## <a name="cdcdrawtext"></a><a name="drawtext"></a>CDC::DrawText

Вызовите эту функцию участника для формата текста в данном прямоугольнике. Чтобы указать дополнительные параметры форматирования, используйте [CDC::DrawTextEx](#drawtextex).

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>Параметры

*lpszString*<br/>
Очки на строку, которая будет нарисована. Если *nCount* -1, строка должна быть нулевых.

*Ncount*<br/>
Определяет количество символов в строке. Если *nCount* является -1, то *lpszString* считается длинным указателем на нулевую строку и `DrawText` автоматически вычисляет количество символов.

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) содержащий прямоугольник (в логических координатах), в котором текст должен быть отформатирован.

*Ул*<br/>
Объект [CString,](../../atl-mfc-shared/reference/cstringt-class.md) содержащий указанные символы, которые должны быть нарисованы.

*nФормат*<br/>
Определяет метод форматирования текста. Это может быть любое сочетание значений, описанных для параметра *uFormat* в [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) в Windows SDK. (комбинат с помощью bitwise или оператора):

> [!NOTE]
> Некоторые комбинации флагов *uFormat* могут привести к изменению пройденного строки. Использование DT_MODIFYSTRING с DT_END_ELLIPSIS или DT_PATH_ELLIPSIS может привести к изменению строки, что приведет к утверждению `CString` в переопределение. Значения DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP и DT_NOPREFIX не могут быть использованы с DT_TABSTOP значением.

### <a name="return-value"></a>Возвращаемое значение

Высота текста, если функция успешна.

### <a name="remarks"></a>Remarks

Он форматирует текст, расширяя вкладки в соответствующие пространства, выравнивая текст влево, вправо или в центре данного прямоугольника и разбивая текст на строки, которые вписываются в данный прямоугольник. Тип форматирования указан *nFormat*.

Эта функция члена использует выбранный шрифт контекста устройства, цвет текста и цвет фона для рисования текста. Если DT_NOCLIP формат не `DrawText` используется, клипы текст так, что текст не появляется за пределами данного прямоугольника. Предполагается, что все форматирование состоит из нескольких строк, если не будет дан формат DT_SINGLELINE.

Если выбранный шрифт слишком велик для указанного `DrawText` прямоугольника, функция члена не пытается заменить меньший шрифт.

Если указан DT_CALCRECT флаг, прямоугольник, указанный *lpRect,* будет обновлен, чтобы отразить ширину и высоту, необходимые для рисования текста.

Если установлен TA_UPDATECP флаг омовании текста (см. [CDC::SetTextAlign),](#settextalign) `DrawText` будет отображаться текст, начиная с текущего положения, а не слева от данного прямоугольника. `DrawText`не будет обернуть текст, когда TA_UPDATECP флаг был установлен (т.е. DT_WORDBREAK флаг не будет иметь никакого эффекта).

Цвет текста может быть установлен [CDC::SetTextColor](#settextcolor).

## <a name="cdcdrawtextex"></a><a name="drawtextex"></a>CDC::DrawTextEx

Текст форматов в данном прямоугольнике.

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>Параметры

*lpszString*<br/>
Очки на строку, которая будет нарисована. Если *nCount* -1, строка должна быть отменена.

*Ncount*<br/>
Определяет количество символов в строке. Если *nCount* является -1, то *lpszString* считается длинным указателем на нулевую строку и `DrawText` автоматически вычисляет количество символов.

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) содержащий прямоугольник (в логических координатах), в котором текст должен быть отформатирован.

*Ул*<br/>
Объект [CString,](../../atl-mfc-shared/reference/cstringt-class.md) содержащий указанные символы, которые должны быть нарисованы.

*nФормат*<br/>
Определяет метод форматирования текста. Это может быть любое сочетание значений, описанных для параметра *uFormat* в [DrawText](/windows/win32/api/winuser/nf-winuser-drawtext) в Windows SDK. (Комбинат с помощью bitwise **или** оператора):

> [!NOTE]
> Некоторые комбинации флагов *uFormat* могут привести к изменению пройденного строки. Использование DT_MODIFYSTRING с DT_END_ELLIPSIS или DT_PATH_ELLIPSIS может привести к изменению строки, что приведет к утверждению `CString` в переопределение. Значения DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL, DT_NOCLIP и DT_NOPREFIX не могут быть использованы с DT_TABSTOP значением.

*lpDTParams*<br/>
Указатель на структуру [DRAWTEXTPARAMS,](/windows/win32/api/winuser/ns-winuser-drawtextparams) которая определяет дополнительные параметры форматирования. Этот параметр может быть NULL.

### <a name="remarks"></a>Remarks

Он форматирует текст, расширяя вкладки в соответствующие пространства, выравнивая текст влево, вправо или в центре данного прямоугольника и разбивая текст на строки, которые вписываются в данный прямоугольник. Тип форматирования указан *nFormat* и *lpDTParams.* Для получения дополнительной информации, [см. CDC::DrawText](#drawtext) и [DrawTextEx](/windows/win32/api/winuser/nf-winuser-drawtextexw) в Windows SDK.

Цвет текста может быть установлен [CDC::SetTextColor](#settextcolor).

## <a name="cdcellipse"></a><a name="ellipse"></a>CDC::Эллипс

Рисование эллипса.

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет логическую х-координатуар верхнего левого угла связующего прямоугольника эллипса.

*y1*<br/>
Определяет логическую y-координацию верхнего левого угла связующего прямоугольника эллипса.

*x2*<br/>
Определяет логическую х-координатум нижнего правого угла связующего прямоугольника эллипса.

*y2*<br/>
Определяет логическую y-координацию нижнего правого угла связывающего прямоугольника эллипса.

*lpRect*<br/>
Определяет прямоугольник эллипса. Вы также можете пройти [CRect](../../atl-mfc-shared/reference/crect-class.md) объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Центр эллипса является центром граничащий прямоугольник, указанный *x1,* *y1*, *x2,* и *y2,* или *lpRect.* Эллипс нарисован текущей ручкой, а его интерьер наполнен текущей кистью.

Рисунок, нарисованный этой функцией, простирается до, но не включает в себя правые и нижние координаты. Это означает, что высота фигуры *y2* - *y1* и ширина фигуры *x2* - *x1.*

Если ширина или высота связывающего прямоугольника составляет 0, эллипс не нарисован.

## <a name="cdcenddoc"></a><a name="enddoc"></a>CDC:EndDoc

Завершает задание печати, начатое вызовом к функции участника [StartDoc.](#startdoc)

```
int EndDoc();
```

### <a name="return-value"></a>Возвращаемое значение

Больше или равно 0, если функция успешна, или отрицательное значение, если произошла ошибка.

### <a name="remarks"></a>Remarks

Эта функция члена заменяет побег принтера ENDDOC и должна быть вызвана сразу после успешного завершения работы по печати.

Если приложение сталкивается с ошибкой печати или отмененной операцией печати, `EndDoc` оно не должно пытаться завершить операцию, используя ни один из них или [AbortDoc.](#abortdoc) GDI автоматически завершает операцию перед возвратом значения ошибки.

Эта функция не должна использоваться внутри метафайлов.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::StartDoc](#startdoc).

## <a name="cdcendpage"></a><a name="endpage"></a>CDC:EndPage

Сообщает устройству, что приложение закончило писать на страницу.

```
int EndPage();
```

### <a name="return-value"></a>Возвращаемое значение

Больше или равно 0, если функция успешна, или отрицательное значение, если произошла ошибка.

### <a name="remarks"></a>Remarks

Эта функция члена обычно используется для того, чтобы направить драйвер устройства на новую страницу.

Эта функция члена заменяет побег принтера NEWFRAME. В отличие от NEWFRAME, эта функция всегда вызывается после печати страницы.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::StartDoc](#startdoc).

## <a name="cdcendpath"></a><a name="endpath"></a>CDC:EndPath

Закрывает кронштейн пути и выбирает путь, определяемый кронштейном, в контекст устройства.

```
BOOL EndPath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::BeginPath](#beginpath).

## <a name="cdcenumobjects"></a><a name="enumobjects"></a>CDC:EnumObjects

Перечисляет ручки и кисти, доступные в контексте устройства.

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>Параметры

*nObjectType*<br/>
Определяет тип объекта. Он может иметь значения OBJ_BRUSH или OBJ_PEN.

*lpfn*<br/>
Является ли адрес процедуры-инстанции функции обратного вызова, предоставленной приложением. Ниже приведен раздел "Замечания".

*lpData*<br/>
Указывает на данные, предоставленные приложением. Данные передаются функции обратного вызова вместе с информацией об объекте.

### <a name="return-value"></a>Возвращаемое значение

Упогоняет последнее значение, возвращенное [функцией обратного вызова.](callback-functions-used-by-mfc.md#enum_objects) Его значение определяется пользователем.

### <a name="remarks"></a>Remarks

Для каждого объекта данного типа функция обратного вызова, которую вы передаете, вызывается с информацией для этого объекта. Система вызывает функцию обратного вызова до тех пор, пока не будет больше объектов или функция обратного вызова не возвращает 0.

Обратите внимание, что новые функции Microsoft Visual C' позволяют использовать обычную функцию при передаваемых `EnumObjects`функциях. Адрес, переданный `EnumObjects` является указателем на функцию, экспортируемую с **EXPORT** и с конвенцией вызова Паскаля. В защитных режимах вам не нужно создавать эту функцию с функцией Windows MakeProcInstance или освобождать ее после использования с функцией FreeProcInstance Windows.

Вам также не нужно экспортировать имя функции в выписке **EXPORTS** в файле определения модуля приложения. Вместо этого можно использовать модификатор функции **EXPORT,** как в

**int CALLBACK EXPORT** AFunction **(LPSTR,** **LPSTR);**

заставить компилятор излучать надлежащий экспортный рекорд для экспорта по имени без псевдонима. Это работает для большинства потребностей. В некоторых особых случаях, таких как экспорт функции по или псевдониму экспорта, все равно необходимо использовать заявление **EXPORTS** в файле определения модуля.

Для компиляции программ Microsoft Foundation обычно используются варианты компилятора /GA и /GEs. Опция компилятора /Gw не используется в классах Фонда Майкрософт. (Если вы используете `MakeProcInstance`функцию Windows, вам нужно будет явно бросить возвращенный указатель функции от FARPROC к типу, необходимому в этом API.) Интерфейсы регистрации обратных вызовов теперь безопасны для типов (вы должны пройти в указатель функции, который указывает на правильный вид функции для конкретного обратного вызова).

Также обратите внимание, что все функции обратного вызова должны заманивать исключения Фонда Майкрософт в ловушку перед возвращением в Windows, так как исключения не могут быть брошены через границы обратного вызова. Для получения дополнительной информации об [Exceptions](../../mfc/exception-handling-in-mfc.md)исключениях см.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

## <a name="cdcescape"></a><a name="escape"></a>CDC::Побег

Эта функция участника практически устарела для программирования Win32.

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>Параметры

*nПобег*<br/>
Определяет функцию побега, которая должна быть выполнена.

Полный список функций побега [можно](/windows/win32/api/wingdi/nf-wingdi-escape) узнать в SDK Windows.

*Ncount*<br/>
Определяет количество байтов данных, на которые указывает *lpszInData.*

*lpszInData*<br/>
Указывает на структуру входных данных, необходимую для этого побега.

*lpOutData*<br/>
Указывает на структуру, которая должна получать выход из этого побега. Параметр *lpOutData* является NULL, если данные не возвращаются.

*nInputSize*<br/>
Определяет количество байтов данных, на которые указывает параметр *lpszInputData.*

*lpszInputData*<br/>
Указывает на входную структуру, необходимую для указанного побега.

*nOutputSize*<br/>
Определяет количество байтов данных, на которые указывает параметр *lpszOutputData.*

*lpszOutputData*<br/>
Указывает на структуру, которая получает выход из этого побега. Этот параметр должен быть NULL, если данные не возвращаются.

### <a name="return-value"></a>Возвращаемое значение

Положительное значение возвращается, если функция успешна, за исключением побега к еЖЕЙСкеГЕДОВЛИС, который проверяет только на реализацию. Ноль возвращается, если побег не реализован. Отрицательное значение возвращается при ошибке. Ниже приведены общие значения ошибки:

- SP_ERROR общая ошибка.

- SP_OUTOFDISK недостаточное пространство диска в настоящее время доступно для spooling, и больше не будет доступно пространство.

- SP_OUTOFMEMORY Недостаточно памяти доступно для spooling.

- SP_USERABORT пользователь закончил работу через менеджера печати.

### <a name="remarks"></a>Remarks

Из исходных побегов принтера поддерживается только компания ,QUERYESCSUPPORT для приложений Win32. Все остальные побеги принтера устарели и поддерживаются только для совместимости с 16-битными приложениями.

Для программирования Win32, `CDC` теперь предоставляет шесть функций члена, которые заменяют их соответствующий принтер избегает:

- [CDC::AbortDoc](#abortdoc)

- [CDC:EndDoc](#enddoc)

- [CDC:EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

Кроме того, [CDC::GetDeviceCaps](#getdevicecaps) поддерживает индексы Win32, которые вытесняют другие принтеры. Для получения дополнительной информации смотрите [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) в SDK Windows.

Эта функция члена позволяет приложениям получать доступ к объектам определенного устройства, которые не доступны непосредственно через GDI.

Используйте первую версию, если приложение использует заранее определенные значения побега. Используйте вторую версию, если приложение определяет личные значения побега. Дополнительную информацию о второй версии можно узнать в [SDK windows.](/windows/win32/api/wingdi/nf-wingdi-extescape)

## <a name="cdcexcludecliprect"></a><a name="excludecliprect"></a>CDC::ExcludeClipRect

Создает новую область отсечения, которая состоит из существующей области отсечения за вычетом заданного прямоугольника.

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет логическую х-координацию верхнего левого угла прямоугольника.

*y1*<br/>
Определяет логическую y-координацию верхнего левого угла прямоугольника.

*x2*<br/>
Определяет логическую х-координацию нижнего правого угла прямоугольника.

*y2*<br/>
Определяет логическую y-координацию нижнего правого угла прямоугольника.

*lpRect*<br/>
Определяет прямоугольник. Также может `CRect` быть объектом.

### <a name="return-value"></a>Возвращаемое значение

Определяет тип нового региона отсечения. В качестве такой точки может выступать любой из следующих вариантов:

- COMPLEXREGION Регион имеет перекрывающиеся границы.

- ERROR Не создан регион.

- НУЛРЕГИОН Регион пуст.

- SIMPLEREGION Регион не имеет перекрывающихся границ.

### <a name="remarks"></a>Remarks

Ширина прямоугольника, указанного абсолютным значением *x2* - *x1,* не должна превышать 32 767 единиц. Это ограничение распространяется и на высоту прямоугольника.

## <a name="cdcexcludeupdatergn"></a><a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn

Предотвращает рисование в недействительных областях окна, исключая обновленную область `CDC` в окне из области отсечения, связанного с объектом.

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>Параметры

*pWnd*<br/>
Указывает на объект окна, окно которого обновляется.

### <a name="return-value"></a>Возвращаемое значение

Тип исключенного региона. Это может быть любое из следующих значений:

- COMPLEXREGION Регион имеет перекрывающиеся границы.

- ERROR Не создан регион.

- НУЛРЕГИОН Регион пуст.

- SIMPLEREGION Регион не имеет перекрывающихся границ.

## <a name="cdcextfloodfill"></a><a name="extfloodfill"></a>CDC::ExtFloodFill

Заполняет область поверхности дисплея текущей щеткой.

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию точки, где начинается заполнение.

*Y*<br/>
Определяет логическую y-координацию точки, где начинается заполнение.

*crColor*<br/>
Определяет цвет границы или области, которая должна быть заполнена. Интерпретация *crColor* зависит от значения *nFillType*.

*nFillType*<br/>
Определяет тип заполнения наводнений, которые должны быть выполнены. Это должно быть любое из следующих значений:

- FLOODFILLBORDER Область заполнения ограничена цветом, указанным *crColor.* Этот стиль идентичен `FloodFill`начинке, выполняемой .

- FLOODFILLSURFACE Область заполнения определяется цветом, указанным *crColor.* Заполнение продолжается наружу во всех направлениях до тех пор, пока цвет встречается. Этот стиль полезен для заполнения областей разноцветными границами.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция успешна; в противном случае 0, если начинка не может быть завершена, если данная точка имеет пограничный цвет, указанный *crColor* (если была запрошена FLOODFILLBORDER), если данная точка не имеет цвета, указанного *crColor* (если была запрошена FLOODFILLSURFACE), или если точка находится за пределами области отсечения.

### <a name="remarks"></a>Remarks

Эта функция члена предлагает `FloodFill` большую гибкость, чем потому, что вы можете указать тип заполнения в *nFillType*.

Если *nFillType* установлен на FLOODFILLBORDER, то область, как предполагается, полностью ограничена цветом, указанным *crColor.* Функция начинается в точке, указанной *x* и *y,* и заполняет во всех направлениях к цветовой границе.

Если *nFillType* установлен на FLOODFILLSURFACE, функция начинается в точке, указанной *x* и *y,* и продолжается во всех направлениях, заполняя все прилегающие области, содержащие цвет, указанный *crColor.*

Только контексты памяти и устройства, поддерживающие `ExtFloodFill`поддержку технологии raster-display. Для получения дополнительной [информации](#getdevicecaps) см.

## <a name="cdcexttextout"></a><a name="exttextout"></a>CDC::ExtTextOut

Вызовите эту функцию участника, чтобы написать строку символов в прямоугольной области с помощью выбранного в настоящее время шрифта.

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию ячейки символов для первого символа в указанной строке.

*Y*<br/>
Определяет логическую y-координацию верхней части ячейки символов для первого символа в указанной строке.

*nВарианты*<br/>
Определяет тип прямоугольника. Этот параметр может быть одним, обоими или ни одним из следующих значений:

- ETO_CLIPPED указывает, что текст присевает к прямоугольнику.

- ETO_OPAQUE указывает, что текущий цвет фона заполняет прямоугольник. (Вы можете установить и заставить текущий цвет фона с функциями члена [SetBkColor](#setbkcolor) и [GetBkColor.)](#getbkcolor)

*lpRect*<br/>
Указывает на структуру [RECT,](/windows/win32/api/windef/ns-windef-rect) определяющую размеры прямоугольника. Этот параметр может быть NULL. Вы также можете пройти [CRect](../../atl-mfc-shared/reference/crect-class.md) объект для этого параметра.

*lpszString*<br/>
Очки к указанной строке символов, которая будет нарисована. Вы также можете передать объект [CString](../../atl-mfc-shared/reference/cstringt-class.md) для этого параметра.

*Ncount*<br/>
Указывает количество знаков в строке.

*lpDxВайза*<br/>
Указывает на массив значений, указывающих расстояние между истоками смежных ячеек символов. Например, *lpDxWidths*и *я*логические единицы будут отделять происхождение ячейки символов *i* и ячейки символов *i* No 1. Если *lpDxWidths* является `ExtTextOut` NULL, используется интервал между символами по умолчанию.

*Ул*<br/>
Объект, `CString` содержащий указанные символы, которые должны быть нарисованы.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Прямоугольная область может быть непрозрачной (заполненной текущим цветом фона), и это может быть область отсечения.

Если *nOptions* 0 и *lpRect* null, функция записывает текст в контекст устройства без использования прямоугольной области. По умолчанию текущая позиция не используется и не обновляется функцией. Если приложению необходимо обновить текущее `ExtTextOut`положение при вызове, приложение может вызвать функцию `CDC` участника [SetTextAlign](#settextalign) с *nFlags,* установленным для TA_UPDATECP. Когда этот флаг установлен, Windows игнорирует *x* и `ExtTextOut` *y* на последующих вызовах и использует вместо этого текущее положение. Когда приложение использует TA_UPDATECP для обновления `ExtTextOut` текущего положения, устанавливает текущее положение либо в конце предыдущей строки текста или в положение, указанное последним элементом массива, на который указывает *lpDxWidths*, в зависимости от того, что больше.

## <a name="cdcfillpath"></a><a name="fillpath"></a>CDC:FillPath

Закрывает любые открытые фигуры в текущем пути и заполняет внутреннюю часть пути с помощью текущего режима заполнения кисти и полигона.

```
BOOL FillPath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

После заполнения его интерьера путь удаляется из контекста устройства.

## <a name="cdcfillrect"></a><a name="fillrect"></a>CDC:FillRect

Вызов ими функции участника для заполнения заданного прямоугольника с помощью указанной кисти.

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на структуру [RECT,](/windows/win32/api/windef/ns-windef-rect) содержащую логические координаты прямоугольника, который должен быть заполнен. Вы также можете пройти [CRect](../../atl-mfc-shared/reference/crect-class.md) объект для этого параметра.

*pBrush*<br/>
Идентифицирует кисть, используемую для заполнения прямоугольника.

### <a name="remarks"></a>Remarks

Функция заполняет полный прямоугольник, включая левую и верхнюю границы, но не заполняет правые и нижние границы.

Кисть должна быть создана с помощью функций члена [CBrush](../../mfc/reference/cbrush-class.md) [CreateHatchBrush,](../../mfc/reference/cbrush-class.md#createhatchbrush) [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)и [CreateSolidBrush,](../../mfc/reference/cbrush-class.md#createsolidbrush)либо извлечена функцией `GetStockObject` Windows.

При заполнении указанного `FillRect` прямоугольника не включается правая и нижняя стороны прямоугольника. GDI заполняет прямоугольник до, но не включает в себя правый столбец и нижний ряд, независимо от текущего режима отображения. `FillRect`сравнивает значения `top`, `bottom`, `left`и `right` члены указанного прямоугольника. Если `bottom` меньше или `top`равно, или `right` если `left`меньше, чем или равны, прямоугольник не обращается.

`FillRect`похож на [CDC::FillSolidRect](#fillsolidrect); однако, `FillRect` принимает щетку и поэтому может быть использован для того чтобы заполнить прямоугольник с твердым цветом, dithered цветом, вылупимыми щетками, или картиной. `FillSolidRect`использует только твердые цвета (указанные параметром COLORREF). `FillRect`как правило, `FillSolidRect`медленнее, чем .

## <a name="cdcfillrgn"></a><a name="fillrgn"></a>CDC:FillRgn

Заполняет область, указанную *pRgn* с кистью, указанной *pBrush*.

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>Параметры

*pRgn*<br/>
Указатель на регион, который должен быть заполнен. Координаты данного региона указаны в логических единицах.

*pBrush*<br/>
Определяет кисть, которая будет использоваться для заполнения региона.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Кисть должна быть создана с `CreatePatternBrush` `CreateSolidBrush`использованием функций `GetStockObject` `CBrush` `CreateHatchBrush`члена, или быть извлечена.

### <a name="example"></a>Пример

  Смотрите пример [cRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn).

## <a name="cdcfillsolidrect"></a><a name="fillsolidrect"></a>CDC:FillSolidRect

Вызов исправи эту функцию участника, чтобы заполнить данный прямоугольник указанным твердым цветом.

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Определяет ограничивающий прямоугольник (в логических единицах). Вы можете передать либо указатель на структуру `CRect` данных [RECT,](/windows/win32/api/windef/ns-windef-rect) либо объект для этого параметра.

*clr* Определяет цвет, который будет использоваться для заполнения прямоугольника.

*x*<br/>
Определяет логическую х-координацию верхнего левого угла прямоугольника.

*Y*<br/>
Определяет логическую y-координацию верхнего левого угла прямоугольника назначения.

*Cx*<br/>
Определяет ширину прямоугольника.

*Cy*<br/>
Определяет высоту прямоугольника.

### <a name="remarks"></a>Remarks

`FillSolidRect`очень похож на [CDC::FillRect](#fillrect); однако, `FillSolidRect` использует только твердые цвета (указанные `FillRect` параметром COLORREF), в то время как занимает кисть и, следовательно, может быть использован для заполнения прямоугольника с твердым цветом, смягченный цвет, вылупились кисти, или шаблон. `FillSolidRect`как правило, `FillRect`быстрее, чем .

> [!NOTE]
> При вызове `FillSolidRect`цвет фона, который ранее был установлен с помощью [SetBkColor,](#setbkcolor)устанавливается на цвет, указанный *clr.*

## <a name="cdcflattenpath"></a><a name="flattenpath"></a>CDC::FlattenPath

Преобразует любые кривые в выбранном пути в текущий контекст устройства и превращает каждую кривую в последовательность линий.

```
BOOL FlattenPath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

## <a name="cdcfloodfill"></a><a name="floodfill"></a>CDC::Наводнение

Заполняет область поверхности дисплея текущей щеткой.

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию точки, где начинается заполнение.

*Y*<br/>
Определяет логическую y-координацию точки, где начинается заполнение.

*crColor*<br/>
Определяет цвет границы.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция успешна; в противном случае 0 возвращается, если начинка не может быть завершена, данная точка имеет цвет границы, указанный *crColor,* или точка находится за пределами области отсечения.

### <a name="remarks"></a>Remarks

Область, как предполагается, ограничена, как указано *crColor*. Функция `FloodFill` начинается в точке, указанной *x* и *y,* и продолжается во всех направлениях к цветовой границе.

Функцию участника поддерживают только контексты памяти и `FloodFill` устройства, поддерживающие технологию raster-display. Для получения информации о `GetDeviceCaps` возможностях RC_BITBLT см.

Функция `ExtFloodFill` обеспечивает аналогичные возможности, но большую гибкость.

## <a name="cdcframerect"></a><a name="framerect"></a>CDC::FrameRect

Рисует границу вокруг прямоугольника, указанного *lpRect.*

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) содержащий логические координаты верхнего левого и нижнего правого углов прямоугольника. Вы также можете `CRect` передать объект для этого параметра.

*pBrush*<br/>
Определяет кисть, которая будет использоваться для обрамления прямоугольника.

### <a name="remarks"></a>Remarks

Функция использует данную кисть для рисования границы. Ширина и высота границы всегда 1 логический блок.

Если координаты `bottom` прямоугольника меньше `top`или равны, или если `right` `left`они меньше или равны, прямоугольник не нарисован.

Граница, нарисованная `FrameRect` в том же положении, что и граница, нарисованная функцией `Rectangle` члена, используя те же координаты (если `Rectangle` используется перо шириной 1 единица). Интерьер прямоугольника не `FrameRect`заполнен.

## <a name="cdcframergn"></a><a name="framergn"></a>CDC:FrameRgn

Рисует границу вокруг региона, указанного *pRgn* с помощью кисти, указанной *pBrush*.

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Параметры

*pRgn*<br/>
Точки объекта, `CRgn` идентифицирующие область, которая должна быть заключена в границу. Координаты данного региона указаны в логических единицах.

*pBrush*<br/>
Указывает на `CBrush` объект, который идентифицирует кисть, которая будет использоваться для рисования границы.

*nWidth*<br/>
Определяет ширину границы вертикальными мазками кисти в устройствах.

*nВысота*<br/>
Определяет высоту границы горизонтальными мазками кисти в устройствах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="example"></a>Пример

  Смотрите пример [для CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn).

## <a name="cdcfromhandle"></a><a name="fromhandle"></a>CDC::FromHandle

Возвращает указатель объекту `CDC` при отваге рукоятки в контекст устройства.

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>Параметры

*Hdc*<br/>
Содержит ручку в контексте устройства Windows.

### <a name="return-value"></a>Возвращаемое значение

Указатель может быть временным и не должен храниться после немедленного использования.

### <a name="remarks"></a>Remarks

Если объект `CDC` не прикреплен к дескриптору, создается и прикрепляется временный объект `CDC`.

### <a name="example"></a>Пример

  Смотрите пример [для CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc).

## <a name="cdcgetarcdirection"></a><a name="getarcdirection"></a>CDC:GetArcDirection

Возвращает текущее направление дуги для контекста устройства.

```
int GetArcDirection() const;
```

### <a name="return-value"></a>Возвращаемое значение

Определяет текущее направление дуги, если успешно. Ниже приведены действительные значения возврата:

- AD_COUNTERCLOCKWISE дуги и прямоугольники, нарисованные против часовой стрелки.

- AD_CLOCKWISE дуги и прямоугольники, нарисованные по часовой стрелке.

При возникновении ошибки значение возврата равен нулю.

### <a name="remarks"></a>Remarks

Функции дуги и прямоугольника используют направление дуги.

## <a name="cdcgetaspectratiofilter"></a><a name="getaspectratiofilter"></a>CDC:GetAspectRatioFilter

Извлекает настройки для текущего фильтра отношения аспекта.

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>Возвращаемое значение

Объект, `CSize` представляющий соотношение сторон, используемый текущим фильтром соотношения аспектов.

### <a name="remarks"></a>Remarks

Соотношение сторон представляет собой соотношение, сформированное шириной и высотой пикселей устройства. Информация о соотношении сторон устройства используется при создании, выборе и отображении шрифтов. Windows предоставляет специальный фильтр, фильтр отношения аспекта, для выбора шрифтов, предназначенных для определенного соотношения аспектов из всех доступных шрифтов. Фильтр использует соотношение сторон, `SetMapperFlags` указанное функцией члена.

## <a name="cdcgetbkcolor"></a><a name="getbkcolor"></a>CDC::GetBkColor

Возвращает текущий цвет фона.

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение цвета RGB.

### <a name="remarks"></a>Remarks

Если фоновым режимом является ОПАЗЗуэ, система использует цвет фона для заполнения пробелов в стиле линий, пробелов между вылупимыми линиями в кисти, и фоном в ячейках символов. Система также использует цвет фона при преобразовании бит-карт между цветными и монохромными контекстами устройства.

## <a name="cdcgetbkmode"></a><a name="getbkmode"></a>CDC:GetBkMode

Возвращает фоновый режим.

```
int GetBkMode() const;
```

### <a name="return-value"></a>Возвращаемое значение

Текущий фоновый режим, который может быть ОПЕРЕЗУ или TRANSPARENT.

### <a name="remarks"></a>Remarks

Фоновый режим определяет, удаляет ли система существующие фоновые цвета на поверхности чертежа перед рисованием текста, вылупившихся кистей или любой стиль пера, который не является сплошной линией.

## <a name="cdcgetboundsrect"></a><a name="getboundsrect"></a>CDC::GetBoundsRect

Возвращает текущий накопленный прямоугольник для заданного контекста устройства.

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Параметры

*lpRectBounds*<br/>
Указывает на буфер, который получит текущий прямоугольник. Прямоугольник возвращается в логических координатах.

*Флаги*<br/>
Уточняется, должен ли быть очищен прямоугольник после его возврата. Этот параметр должен быть нулевым или установить сярприг на следующее значение:

- DCB_RESET принуждает очищать прямоугольник после его возвращения.

### <a name="return-value"></a>Возвращаемое значение

Определяет текущее состояние связующего прямоугольника, если функция успешна. Это может быть сочетание следующих значений:

- DCB_ACCUMULATE происходит накопление прямоугольника.

- DCB_RESET связывая прямоугольник пуст.

- DCB_SET связывание прямоугольника не пусто.

- DCB_ENABLE Связанные накопления на.

- DCB_DISABLE Связанные накопления выключен.

## <a name="cdcgetbrushorg"></a><a name="getbrushorg"></a>CDC::GetBrushOrg

Извлекает происхождение (в единицах устройства) кисти, выбранной в настоящее время для контекста устройства.

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>Возвращаемое значение

Текущее происхождение кисти (в единицах устройства) как объекта [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="remarks"></a>Remarks

Начальное происхождение кисти находится на уровне (0,0) клиентской области. Значение возврата определяет эту точку в единицах устройства относительно происхождения окна рабочего стола.

## <a name="cdcgetcharacterplacement"></a><a name="getcharacterplacement"></a>CDC::GetCharacterPlacement

Извлекает различные типы информации на строке символов.

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>Параметры

*lpString*<br/>
Указатель на строку символов для обработки.

*Ncount*<br/>
Определяет длину строки. Для версии ANSI это количество BYTE, а для функции Unicode — количество WORD. Для получения дополнительной информации [см.](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)

*nMaxExtent*<br/>
Определяет максимальную степень (в логических единицах), к которой обрабатывается строка. Персонажи, которые, если они обработаны, превышают этот объем, игнорируются. Вычисления для любых требуемых массивов заказа или глифов применяются только к включенным символам. Этот параметр используется только в том случае, если значение GCP_MAXEXTENT указано в параметре *dwFlags.* По мере того, как функция обрабатывает строку ввода, каждый символ и его степень добавляются к выходу, объему и другим массивам только в том случае, если общая степень еще не превысила максимум. Как только предел будет достигнут, обработка прекратится.

*lpРезультаты*<br/>
Указатель на [GCP_Results](/windows/win32/api/wingdi/ns-wingdi-gcp_resultsw) структуру, которая получает результаты функции.

*dwFlags*<br/>
Определяет, как обрабатывать строку в требуемые массивы. Этот параметр может быть одним или более значениями, перечисленными в разделе *dwFlags* темы [GetCharacterPlacement.](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw)

*Ул*<br/>
Указатель на объект [CString](../../atl-mfc-shared/reference/cstringt-class.md) для обработки.

### <a name="return-value"></a>Возвращаемое значение

Если функция успешно, значение возврата представляет собой ширину и высоту строки в логических единицах.

Если функция выполняется неудачно, возвращается нулевое значение.

### <a name="remarks"></a>Remarks

Эта функция члена эмулирует функциональность функции [GetCharacterPlacement](/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementw), как описано в Windows SDK.

## <a name="cdcgetcharabcwidths"></a><a name="getcharabcwidths"></a>CDC::GetCharABCШирины

Извлекает ширину последовательных символов в заданном диапазоне от текущего шрифта TrueType.

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>Параметры

*nFirstChar*<br/>
Определяет первый символ в диапазоне символов из текущего шрифта, для которого ширина символов возвращается.

*nLastChar*<br/>
Определяет последний символ в диапазоне символов из текущего шрифта, для которого ширина символов возвращается.

*lpabc*<br/>
Указывает на массив структур [ABC,](/windows/win32/api/wingdi/ns-wingdi-abc) которые получают ширину символа при возврате функции. Этот массив должен содержать `ABC` не менее столько структур, сколько символов в диапазоне, указанном параметрами *nFirstChar* и *nLastChar.*

*lpABCF*<br/>
Указывает на буфер, поставляемый приложением, с массивом структур [ABCFLOAT](/windows/win32/api/wingdi/ns-wingdi-abcfloat) для получения ширины символов при возврате функции. Ширина, возвращенная этой функцией, в формате iEEE floating-point.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Ширина возвращается в логических единицах. Эта функция успешно работает только с шрифтами TrueType.

Rasterizer TrueType обеспечивает интервал между символами "ABC" после выбора определенного размера точки. Расстояние "А" — это расстояние, добавленное к текущему положению перед размещением глифа. Интервал "B" - это ширина черной части глифа. Интервал "C" добавляется к текущему положению для учета белого пространства справа от глифа. Общая продвинутая ширина дается а-Б и С.

Когда `GetCharABCWidths` функция участника получает отрицательную ширину "A" или "C" для символа, этот символ включает в себя перенавесы или свесы.

Для преобразования ширины ABC в единицы проектирования шрифтов приложение должно `lfHeight` создать шрифт, высота которого (как указано `ntmSizeEM` в структуре [LOGFONT)](/windows/win32/api/wingdi/ns-wingdi-logfontw) равна значению, хранящейся в структуре [NEWTEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-newtextmetricw) (Значение `ntmSizeEM` участника можно получить, позвонив в функцию [EnumFontFamilies](/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw) Windows.)

Ширина символа ABC символа по умолчанию используется для символов, которые находятся за пределами диапазона выбранного в настоящее время шрифта.

Для получения ширины символов шрифтов, не относясь к TrueType, приложения должны использовать функцию [GetCharWidth](/windows/win32/api/wingdi/nf-wingdi-getcharwidthw) Windows.

## <a name="cdcgetcharabcwidthsi"></a><a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI

Извлекает ширину, в логических единицах, последовательных глифов индексов в определенном диапазоне от текущего шрифта TrueType.

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>Параметры

*giПервый*<br/>
Определяет первый индекс глифов в группе последовательных индексов глифа из текущего шрифта. Этот параметр используется только в том случае, если параметр *pgi* является NULL.

*Cgi*<br/>
Определяет количество индексов глифа.

*Pgi*<br/>
Указатель на массив, содержащий глиф-индексы. Если значение NULL, вместо него используется параметр *giFirst.* Параметр *cgi* определяет количество индексов глифа в этом массиве.

*lpabc*<br/>
Указатель на массив структур [ABC,](/windows/win32/api/wingdi/ns-wingdi-abc) получающих ширину символа. Этот массив должен содержать `ABC` не менее столько структур, сколько и глифовые индексы, указанные параметром *cgi.*

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция члена эмулирует функциональность функции [GetCharABCWidthsI](/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsi), как описано в Windows SDK.

## <a name="cdcgetcharwidth"></a><a name="getcharwidth"></a>CDC::GetCharWidth

Извлекает ширину отдельных символов в последовательной группе символов `m_hAttribDC`из текущего шрифта, используя контекст вхотового устройства.

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>Параметры

*nFirstChar*<br/>
Определяет первый символ в последовательной группе символов в текущем шрифте.

*nLastChar*<br/>
Определяет последний символ в последовательной группе символов в текущем шрифте.

*lpBuffer*<br/>
Указывает на буфер, который будет получать значения ширины для последовательной группы символов в текущем шрифте.

*lpFloatBuffer*<br/>
Указывает на буфер для получения ширины символа. Возвращается ширина в 32-битный формат IEEE плавающей точки. (Ширина измеряется вдоль базовой линии символов.)

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Например, если *nFirstChar* идентифицирует букву 'a' и *nLastChar* идентифицирует букву 'z', функция получает ширину всех символов нижнего регистра.

Функция хранит значения в буфере, на которые указывает *lpBuffer.* Этот буфер должен быть достаточно большим, чтобы держать всю ширину. То есть в приведенном примере должно быть не менее 26 записей.

Если символ в последовательной группе символов не существует в определенном шрифте, ему будет присвоено значение ширины символа по умолчанию.

## <a name="cdcgetcharwidthi"></a><a name="getcharwidthi"></a>CDC::GetCharWidthI

Извлекает ширины, в логических координатах, последовательных глифов в заданном диапазоне от текущего шрифта.

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Параметры

*giПервый*<br/>
Определяет первый индекс глифов в группе последовательных индексов глифа из текущего шрифта. Этот параметр используется только в том случае, если параметр *pgi* является NULL.

*Cgi*<br/>
Определяет количество индексов глифа.

*Pgi*<br/>
Указатель на массив, содержащий глиф-индексы. Если значение NULL, вместо него используется параметр *giFirst.* Параметр *cgi* определяет количество индексов глифа в этом массиве.

*lpBuffer*<br/>
Указатель на буфер, который получает ширину.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция члена эмулирует функциональность функции [GetCharWidthI](/windows/win32/api/wingdi/nf-wingdi-getcharwidthi), как описано в Windows SDK.

## <a name="cdcgetclipbox"></a><a name="getclipbox"></a>CDC:GetClipBox

Извлекает размеры самого плотного прямоугольника вокруг текущей границы отсечения.

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect,](../../atl-mfc-shared/reference/crect-class.md) который должен получать размеры прямоугольника.

### <a name="return-value"></a>Возвращаемое значение

Тип области отсечения. В качестве такой точки может выступать любой из следующих вариантов:

- Область отсечения COMPLEXREGION имеет перекрывающиеся границы.

- Контекст устройства ERROR недействителен.

- Область отсечения NULLREGION пуста.

- Область отсечения SIMPLEREGION не имеет перекрывающихся границ.

### <a name="remarks"></a>Remarks

Размеры копируются в буфер, на который указывает *lpRect.*

## <a name="cdcgetcoloradjustment"></a><a name="getcoloradjustment"></a>CDC::GetColorAdjustment

Извлекает значения регулировки цвета для контекста устройства.

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>Параметры

*lpColorAdjust*<br/>
Указывает на структуру данных [COLORADJUSTMENT](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) для получения значений регулировки цвета.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

## <a name="cdcgetcurrentbitmap"></a><a name="getcurrentbitmap"></a>CDC:GetCurrentBitmap

Возвращает указатель на выбранный `CBitmap` в настоящее время объект.

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CBitmap` объект, в случае успеха; в противном случае NULL.

### <a name="remarks"></a>Remarks

Эта функция члена может возвращать временные объекты.

## <a name="cdcgetcurrentbrush"></a><a name="getcurrentbrush"></a>CDC:GetCurrentBrush

Возвращает указатель на выбранный `CBrush` в настоящее время объект.

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CBrush` объект, в случае успеха; в противном случае NULL.

### <a name="remarks"></a>Remarks

Эта функция члена может возвращать временные объекты.

## <a name="cdcgetcurrentfont"></a><a name="getcurrentfont"></a>CDC::GetCurrentFont

Возвращает указатель на выбранный `CFont` в настоящее время объект.

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CFont` объект, в случае успеха; в противном случае NULL.

### <a name="remarks"></a>Remarks

Эта функция члена может возвращать временные объекты.

## <a name="cdcgetcurrentpalette"></a><a name="getcurrentpalette"></a>CDC::GetCurrentPalette

Возвращает указатель на выбранный `CPalette` в настоящее время объект.

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CPalette` объект, в случае успеха; в противном случае NULL.

### <a name="remarks"></a>Remarks

Эта функция члена может возвращать временные объекты.

## <a name="cdcgetcurrentpen"></a><a name="getcurrentpen"></a>CDC::GetCurrentPen

Возвращает указатель на выбранный `CPen` в настоящее время объект.

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CPen` объект, в случае успеха; в противном случае NULL.

### <a name="remarks"></a>Remarks

Эта функция члена может возвращать временные объекты.

## <a name="cdcgetcurrentposition"></a><a name="getcurrentposition"></a>CDC::GetCurrentPosition

Извлекает текущее положение (в логических координатах).

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>Возвращаемое значение

Текущее положение `CPoint` как объекта.

### <a name="remarks"></a>Remarks

Текущее положение может быть `MoveTo` установлено с функцией члена.

## <a name="cdcgetdcbrushcolor"></a><a name="getdcbrushcolor"></a>CDC::GetDCBrushColor

Получает текущий цвет кисти.

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>Возвращаемое значение

Если функция успешно, значение возврата является значением [COLORREF](/windows/win32/gdi/colorref) для текущего цвета кисти.

Если функция выполняется неудачно, возвращается значение CLR_INVALID.

### <a name="remarks"></a>Remarks

Эта функция-член имитирует функциональность функции [GetDCBrushColor,](/windows/win32/api/wingdi/nf-wingdi-getdcbrushcolor)как описано в SDK Windows.

## <a name="cdcgetdcpencolor"></a><a name="getdcpencolor"></a>CDC::GetDCPenColor

Получает текущий цвет пера.

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>Возвращаемое значение

Если функция успешно, значение возврата является значением [COLORREF](/windows/win32/gdi/colorref) для текущего цвета пера.

Если функция выполняется неудачно, возвращается значение CLR_INVALID.

### <a name="remarks"></a>Remarks

Эта функция члена использует функцию Win32 [GetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-getdcpencolor), как описано в Windows SDK.

## <a name="cdcgetdevicecaps"></a><a name="getdevicecaps"></a>CDC::GetDeviceCaps

Извлекает широкий спектр информации, конкретной для устройства, о устройстве отображения.

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>Параметры

*Nindex*<br/>
Определяет тип информации для возврата. Список значений можно увидеть [GetDeviceCaps](/windows/win32/api/wingdi/nf-wingdi-getdevicecaps) в SDK Windows.

### <a name="return-value"></a>Возвращаемое значение

Значение запрашиваемых возможностей, если функция успешна.

### <a name="example"></a>Пример

  Смотрите пример [для CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults).

## <a name="cdcgetfontdata"></a><a name="getfontdata"></a>CDC:GetFontData

Извлекает информацию о шрифте-метрике из масштабируемого файла шрифта.

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>Параметры

*dwTable*<br/>
Упогоняет название веримой метео-таблицы. Этот параметр может быть одной из метрических таблиц, задокументированных в спецификации файлов шрифтов TrueType, опубликованной корпорацией Майкрософт. Если этот параметр радо 0, информация извлекается, начиная с начала файла шрифта.

*dwOffset*<br/>
Определяет смещение от начала таблицы, при котором можно начать получение информации. Если этот параметр раподратива 0, информация извлекается, начиная с начала таблицы, указанной параметром *dwTable.* Если это значение больше или равно размеру `GetFontData` таблицы, возвращается 0.

*lpData*<br/>
Указывает на буфер, который будет получать информацию о шрифте. Если это значение NULL, функция возвращает размер буфера, необходимого для данных шрифта, указанных в параметре *dwTable.*

*cbData*<br/>
Определяет длину в байтах информацию, поднимищенную. Если этот параметр `GetFontData` равен 0, возвращается размер данных, указанных в параметре *dwTable.*

### <a name="return-value"></a>Возвращаемое значение

Определяет количество байтов, возвращенных в буфере, на который указывает *lpData,* если функция успешна; в противном случае -1.

### <a name="remarks"></a>Remarks

Информация для извлечения идентифицируется путем указания смещения в файл шрифта и длины информации для возврата.

Иногда приложение может `GetFontData` использовать функцию участника для сохранения шрифта TrueType с помощью документа. Для этого приложение определяет, можно ли встраить шрифт, а затем извлекает весь файл шрифта, указывая 0 для параметров *dwTable,* *dwOffset*и *cbData.*

Приложения могут определить, можно ли встраивать шрифт, проверяя `otmfsType` члена структуры [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Если набор `otmfsType` бита 1 из установлен, встраивание не допускается для шрифта. Если бит 1 ясен, шрифт может быть встроен. Если набор бита 2, встраивание читается только.

Если приложение пытается использовать эту функцию для получения информации для `GetFontData` шрифта, не связанного с TrueType, функция участника возвращается -1.

## <a name="cdcgetfontlanguageinfo"></a><a name="getfontlanguageinfo"></a>CDC:GetFontLanguageInfo

Возвращает информацию о выбранном в настоящее время шрифте для указанного контекста отображения.

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение возврата определяет характеристики выбранного в настоящее время шрифта. Полный список возможных значений можно узнать на примере [GetFontLanguageInfo.](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo)

### <a name="remarks"></a>Remarks

Эта функция члена эмулирует функциональность функции [GetFontLanguageInfo](/windows/win32/api/wingdi/nf-wingdi-getfontlanguageinfo), как описано в Windows SDK.

## <a name="cdcgetglyphoutline"></a><a name="getglyphoutline"></a>CDC:GetGlyphOutline

Извлекает кривую контура или битную карту для символа контура в текущем шрифте.

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>Параметры

*Nchar*<br/>
Определяет характер, для которого информация должна быть возвращена.

*nФормат*<br/>
Определяет формат, в котором функция заключается в возврате информации. Это может быть одно из следующих значений, или 0:

|Значение|Значение|
|-----------|-------------|
|GGO_BITMAP|Возвращает глиф бит-карту. Когда функция возвращается, буфер, на который указывает *lpBuffer,* содержит битную карту размером 1 бит на пиксель, строки которой начинаются на границах двойного слова.|
|GGO_NATIVE|Возвращает точки данных кривой в родном формате rasterizer с помощью единиц устройства. Когда это значение указано, любое преобразование, указанное в *lpmat2,* игнорируется.|

Когда значение *nFormat* составляет 0, функция заполняет структуру [GLYPHMETRICS,](/windows/win32/api/wingdi/ns-wingdi-glyphmetrics) но не возвращает данные глифов.outline.

*lpgm*<br/>
Указывает на структуру GLYPHMETRICS, описывающая размещение глифа в ячейке символов.

*cbBuffer*<br/>
Определяет размер буфера, в который функция копирует информацию о символе контура. Если это значение равен 0, а параметр *nFormat* является либо GGO_BITMAP, либо GGO_NATIVE значениями, функция возвращает необходимый размер буфера.

*lpBuffer*<br/>
Указывает на буфер, в который функция копирует информацию о символе контура. Если *nFormat* указывает GGO_NATIVE значение, информация копируется в виде структур TTPOLYGONHEADER и TTPOLYCURVE. Если это значение null и *nFormat* является либо GGO_BITMAP, либо GGO_NATIVE значение, функция возвращает необходимый размер буфера.

*lpmat2*<br/>
Указывает на структуру [MAT2,](/windows/win32/api/wingdi/ns-wingdi-mat2) содержащую матрицу преобразования для персонажа. Этот параметр не может быть NULL, даже если значение GGO_NATIVE указано для *nFormat.*

### <a name="return-value"></a>Возвращаемое значение

Размер, в байтах, буфера, необходимого для получения информации, если *cbBuffer* составляет 0 или *lpBuffer* является NULL. В противном случае, это положительное значение, если функция успешна, или -1, если есть ошибка.

### <a name="remarks"></a>Remarks

Приложение может вращать символы, извлеченные в формате bitmap, указав матрицу преобразования 2 на 2 в структуре, на которую указывает *lpmat2.*

Контур глифа возвращается в виде серии контуров. Каждый контур определяется структурой [TTPOLYGONHEADER,](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) за которой следует столько `TTPOLYCURVE` структур, сколько требуется для его описания. Все точки возвращаются как структуры [POINTFX](/windows/win32/api/wingdi/ns-wingdi-pointfx) и представляют абсолютные позиции, а не относительные ходы. Отправной `pfxStart` точкой, приведенной членом структуры [TTPOLYGONHEADER,](/windows/win32/api/wingdi/ns-wingdi-ttpolygonheader) является точка, в которой начинается контур контура. [Структуры TTPOLYCURVE,](/windows/win32/api/wingdi/ns-wingdi-ttpolycurve) которые следуют может быть либо полилиновые записи или spline записей. Полилина записи представляют собой ряд точек; линии, нарисованные между точками, описывают контур персонажа. Записи spline представляют собой квадратные кривые, используемые TrueType (т.е. квадратные b-splines).

## <a name="cdcgetgraphicsmode"></a><a name="getgraphicsmode"></a>CDC:GetGraphicsMode

Извлекает текущий графический режим для заданного контекста устройства.

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>Возвращаемое значение

Возвращает текущий графический режим на успех. Список значений, которые может вернуть этот метод, можно, [см.](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)

Возвращает 0 при сбое.

Чтобы получить расширенную информацию об ошибке, позвоните [getLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Remarks

Этот метод обертывает функцию Windows GDI [GetGraphicsMode.](/windows/win32/api/wingdi/nf-wingdi-getgraphicsmode)

## <a name="cdcgethalftonebrush"></a><a name="gethalftonebrush"></a>CDC:GetHalftoneBrush

Вызовите эту функцию участника, чтобы получить полутонную кисть.

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CBrush` объект в случае успеха; в противном случае NULL.

### <a name="remarks"></a>Remarks

Кисти полутона показывает пиксели, которые поочередно являются передний план и фоновые цвета для создания смягчаемого шаблона. Ниже приводится пример смятения шаблона, созданного полутонной щеткой.

![Сведения о штрихе сглаживающего пера](../../mfc/reference/media/vc318s1.gif "Сведения о штрихе сглаживающего пера")

## <a name="cdcgetkerningpairs"></a><a name="getkerningpairs"></a>CDC:GetKerningPairs

Извлекает пары кернинга символов для шрифта, который в настоящее время выбран в указанном контексте устройства.

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>Параметры

*nPairs*<br/>
Определяет количество структур [KERNINGPAIR,](/windows/win32/api/wingdi/ns-wingdi-kerningpair) на которые указывает *lpkrnpair.* Функция не будет копировать больше кернинговых пар, чем указано *nPairs.*

*lpkrnpair*<br/>
Указывает на массив `KERNINGPAIR` структур, которые получают кернинг пары, когда функция возвращается. Этот массив должен содержать не менее столько структур, чем указано *nPairs.* Если этот параметр NULL, функция возвращает общее количество кернинговых пар для шрифта.

### <a name="return-value"></a>Возвращаемое значение

Определяет количество извлеченных пар кернинга или общее количество кернинговых пар в шрифте, если функция успешна. Ноль возвращается, если функция выходит из строя или нет кернинговых пар для шрифта.

## <a name="cdcgetlayout"></a><a name="getlayout"></a>CDC:GetLayout

Вызовите эту функцию участника, чтобы определить макет текста и графики для контекста устройства, например принтерили или метафайл.

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>Возвращаемое значение

В случае успеха макет будет выполняться в контексте текущего устройства. В противном случае, GDI_ERROR. Для получения расширенной информации об ошибке звоните [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror). Список флагов макета [см.](#setlayout)

### <a name="remarks"></a>Remarks

Макет по умолчанию слева направо.

## <a name="cdcgetmapmode"></a><a name="getmapmode"></a>CDC:GetMapMode

Извлекает текущий режим отображения.

```
int GetMapMode() const;
```

### <a name="return-value"></a>Возвращаемое значение

Режим отображения.

### <a name="remarks"></a>Remarks

Для описания режимов отображения `SetMapMode` см.

> [!NOTE]
> Если вы призываете [SetLayout](#setlayout) изменить dc на макет `SetLayout` справа налево, автоматически изменяет режим отображения на MM_ISOTROPIC. Следовательно, любой `GetMapMode` последующий призыв вернется MM_ISOTROPIC.

## <a name="cdcgetmiterlimit"></a><a name="getmiterlimit"></a>CDC:GetMiterLimit

Возвращает лимит митера для контекста устройства.

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Предел митера используется при рисовании геометрических линий, которые имеют митер соединения.

## <a name="cdcgetnearestcolor"></a><a name="getnearestcolor"></a>CDC::GetNearestColor

Возвращает твердый цвет, который лучше всего соответствует указанному логическому цвету.

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>Параметры

*crColor*<br/>
Определяет цвет, который должен быть согласован.

### <a name="return-value"></a>Возвращаемое значение

Значение цвета RGB (красный, зеленый, синий), определяющее твердый цвет, наиболее близкий к значению *crColor,* которое может представлять устройство.

### <a name="remarks"></a>Remarks

Данное устройство должно быть в состоянии представлять этот цвет.

## <a name="cdcgetoutlinetextmetrics"></a><a name="getoutlinetextmetrics"></a>CDC:GetOutlineTextMetrics

Извлекает метрическую информацию для шрифтов TrueType.

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>Параметры

*lpotm*<br/>
Указывает на массив структур [OUTLINETEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) Если этот параметр NULL, функция возвращает размер буфера, необходимого для извлеченных метрических данных.

*cbData*<br/>
Определяет размер буфера, в котором возвращается информация, указывается.

*lpotm*<br/>
Указывает на `OUTLINETEXTMETRIC` структуру. Если этот параметр NULL, функция возвращает размер буфера, необходимого для извлеченной метрической информации.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Структура [OUTLINETEXTMETRIC](/windows/win32/api/wingdi/ns-wingdi-outlinetextmetricw) содержит большую часть метрической информации шрифта, предоставляемой форматом TrueType, включая структуру [TEXTMETRIC.](/windows/win32/api/wingdi/ns-wingdi-textmetricw) Последние четыре члена `OUTLINETEXTMETRIC` структуры являются указателями на строки. Приложения должны выделять место для этих строк в дополнение к пространству, необходимому для других членов. Поскольку нет установленного системой ограничения на размер строк, самый простой способ выделения памяти — получить необходимый размер, `GetOutlineTextMetrics` указав NULL для *lpotm* при первом вызове к функции.

## <a name="cdcgetoutputcharwidth"></a><a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth

Использует контекст `m_hDC`устройства вывода и извлекает ширину отдельных символов в последовательной группе символов из текущего шрифта.

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>Параметры

*nFirstChar*<br/>
Определяет первый символ в последовательной группе символов в текущем шрифте.

*nLastChar*<br/>
Определяет последний символ в последовательной группе символов в текущем шрифте.

*lpBuffer*<br/>
Указывает на буфер, который будет получать значения ширины для последовательной группы символов в текущем шрифте.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Например, если *nFirstChar* идентифицирует букву 'a' и *nLastChar* идентифицирует букву 'z', функция получает ширину всех символов нижнего регистра.

Функция хранит значения в буфере, на которые указывает *lpBuffer.* Этот буфер должен быть достаточно большим, чтобы держать всю ширину; то есть в приведенном примере должно быть не менее 26 записей.

Если символ в последовательной группе символов не существует в определенном шрифте, ему будет присвоено значение ширины символа по умолчанию.

## <a name="cdcgetoutputtabbedtextextent"></a><a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent

Вызов эту функцию элемента для вычисления ширины и высоты строки символов с помощью [m_hDC](#m_hdc)контекста выходного устройства.

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Параметры

*lpszString*<br/>
Указывает на строку символов, которая должна быть измерена. Вы также можете передать объект [CString](../../atl-mfc-shared/reference/cstringt-class.md) для этого параметра.

*Ncount*<br/>
Определяет [длину строки,](/windows/win32/gdi/specifying-length-of-text-output-string) на которую указывает *lpszString.*

*nTabPositions*<br/>
Определяет количество позиций tab-stop в массиве, на которые указывают *lpnTabStopPositions.*

*lpnTabStopPositions*<br/>
Указывает на массив целых числа, содержащих позиции tab-stop в логических единицах. Остановки вкладок должны быть отсортированы в порядке увеличения; наименьшее значение x должно быть первым элементом в массиве. Задние вкладки не допускаются.

*Ул*<br/>
Объект, `CString` содержащий указанные символы, которые должны быть измерены.

### <a name="return-value"></a>Возвращаемое значение

Размеры строки (в логических единицах) в объекте [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Если строка содержит один или несколько символов вкладок, ширина строки основана на остановках вкладок, указанных *lpnTabStopPositions.* Функция использует выбранный в настоящее время шрифт для вычисления размеров строки.

Текущая область отсечения не компенсирует `GetOutputTabbedTextExtent` ширину и высоту, возвращаемую функцией.

Поскольку некоторые устройства не размещают символы в обычных ячейках (т.е. они изъявляют символы), сумма размеров символов в строке может быть неравна с объемом строки.

Если *nTabPositions* равен 0, а *lpnTabStopPositions* является NULL, вкладки расширяются до восьми средних ширин символов. Если *nTabPositions* равен 1, остановки вкладок будут разделены расстоянием, указанным первым значением в массиве, к которому указывает *lpnTabStopPositions.* Если *lpnTabStopPositions* указывает на более чем одно значение, для каждого значения в массиве устанавливается остановка вкладок, вплоть до числа, указанного *nTabPositions.*

## <a name="cdcgetoutputtextextent"></a><a name="getoutputtextextent"></a>CDC::GetOutputTextExtent

Вызов эту функцию элемента для использования контекста устройства вывода, [m_hDC](#m_hdc)и вычислить ширину и высоту строки текста, используя текущий шрифт.

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Параметры

*lpszString*<br/>
Указывает на строку символов. Вы также можете передать объект [CString](../../atl-mfc-shared/reference/cstringt-class.md) для этого параметра.

*Ncount*<br/>
Определяет [длину строки,](/windows/win32/gdi/specifying-length-of-text-output-string) на которую указывает *lpszString.*

*Ул*<br/>
Объект, `CString` содержащий указанные символы, которые должны быть измерены.

### <a name="return-value"></a>Возвращаемое значение

Размеры строки (в логических единицах) возвращаются в объект [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Текущая область отсечения не `GetOutputTextExtent`влияет на ширину и высоту, возвращенную.

Поскольку некоторые устройства не размещают символы в обычных ячейках (т.е. они выполняют кернинг), сумма размеров символов в строке может быть неравна с объемом строки.

## <a name="cdcgetoutputtextmetrics"></a><a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics

Извлекает метрики для `m_hDC`текущего шрифта с помощью контекста вывода устройства.

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Параметры

*lpMetrics*<br/>
Указывает на структуру [TEXTMETRIC,](/windows/win32/api/wingdi/ns-wingdi-textmetricw) которая получает метрики.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

## <a name="cdcgetpath"></a><a name="getpath"></a>CDC:GetPath

Извлекает координаты, определяющие конечные точки линий и точки управления кривыми, найденными в пути, выбранном в контексте устройства.

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив структур данных [POINT](/windows/win32/api/windef/ns-windef-point) или `CPoint` объектов, где расположены конечные точки линии и точки управления кривой.

*lpTypes*<br/>
Указывает на массив байтов, где расположены типы вершин. Значения являются одним из следующих:

- PT_MOVETO указывает, что соответствующая точка в *lpPoints* начинает разрозненную фигуру.

- PT_LINETO указывает, что предыдущая точка и соответствующая точка в *lpPoints* являются конечными точками строки.

- PT_BEZIERTO указывает, что соответствующая точка в *lpPoints* является контрольной точкой или конечным пунктом для кривой Bzier.

PT_BEZIERTO типов всегда встречаются в наборах по три. Точка пути, непосредственно предшествующего им, определяет отправную точку кривой Bzier. Первые две PT_BEZIERTO точки являются контрольные точки, а третья PT_BEZIERTO точка конечная точка (если жестко закодирована).

   Тип PT_LINETO или PT_BEZIERTO может быть объединен со следующим флагом (с помощью битового оператора **ИЛИ),** чтобы указать, что соответствующая точка является последней точкой в рисунке и что фигура должна быть закрыта:

- PT_CLOSEFIGURE указывает, что фигура автоматически закрывается после нарисованной соответствующей строки или кривой. Фигура закрывается, рисуя линию от линии или точки кривой до точки, соответствующей прошлому PT_MOVETO.

*Ncount*<br/>
Определяет общее количество структур данных [POINT,](/windows/win32/api/windef/ns-windef-point) которые могут быть размещены в массиве *lpPoints.* Это значение должно быть таким же, как и количество байтов, которые могут быть помещены в массив *lpTypes.*

### <a name="return-value"></a>Возвращаемое значение

Если параметр *nCount* незеро, количество перечисленных точек. Если *nCount* равен 0, общее количество точек в пути (и `GetPath` ничего не записывает буферам). Если *nCount* незерол и меньше количества точек в пути, значение возврата -1.

### <a name="remarks"></a>Remarks

Контекст устройства должен содержать закрытый путь. Точки пути возвращаются в логических координатах. Точки хранятся в пути координат устройства, поэтому `GetPath` изменяйте точки от координат устройства к логическим координатам, используя обратную сторону текущего преобразования. Функция `FlattenPath` члена может быть `GetPath`вызвана раньше, чтобы преобразовать все кривые в пути в сегменты линий.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::BeginPath](#beginpath).

## <a name="cdcgetpixel"></a><a name="getpixel"></a>CDC:GetPixel

Получает значение цвета RGB пикселя в точке, указанной *x* и *y.*

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию исследуемой точки.

*Y*<br/>
Определяет логическую y-координацию исследуемой точки.

*Точки*<br/>
Определяет логические x- и y-координаты исследуемой точки.

### <a name="return-value"></a>Возвращаемое значение

Для любой версии функции значение цвета RGB для цвета данной точки. Это -1, если координаты не указывают точку в области отсечения.

### <a name="remarks"></a>Remarks

Точка должна быть в области отсечения. Если точка не находится в области отсечения, функция не имеет эффекта и возвращается -1.

Не все устройства поддерживают функцию `GetPixel`. Для получения дополнительной информаци RC_BITBLTи см. [GetDeviceCaps](#getdevicecaps)

Функция `GetPixel` члена имеет две формы. Первый занимает два значения координат; второй занимает либо структуру [POINT,](/windows/win32/api/windef/ns-windef-point) либо объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

## <a name="cdcgetpolyfillmode"></a><a name="getpolyfillmode"></a>CDC:GetPolyFillMode

Извлекает текущий режим заполнения полигона.

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>Возвращаемое значение

Текущий режим, заполненный полигоном, ALTERNATE или WINDING, если функция успешна.

### <a name="remarks"></a>Remarks

Просмотрите `SetPolyFillMode` функцию участника для описания режимов заполнения полигона.

## <a name="cdcgetrop2"></a><a name="getrop2"></a>CDC::GetROP2

Извлекает текущий режим чертежа.

```
int GetROP2() const;
```

### <a name="return-value"></a>Возвращаемое значение

Режим рисования. Для списка значений режима чертежа `SetROP2` см.

### <a name="remarks"></a>Remarks

Режим рисования определяет, как цвета пера и интерьер заполненных объектов сочетаются с цветом, уже на поверхности дисплея.

## <a name="cdcgetsafehdc"></a><a name="getsafehdc"></a>CDC:GetSafeHdc

Вызов ими функции элемента, чтобы получить [m_hDC](#m_hdc)контексте выходного устройства.

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>Возвращаемое значение

Ручка контекста устройства.

### <a name="remarks"></a>Remarks

Эта функция члена также работает с нулевыми указатели.

## <a name="cdcgetstretchbltmode"></a><a name="getstretchbltmode"></a>CDC:GetStretchBltMode

Извлекает текущий режим растяжения биткарты.

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение возврата определяет текущий режим растяжения биткарты - STRETCH_ANDSCANS, STRETCH_DELETESCANS или STRETCH_ORSCANS - если функция успешна.

### <a name="remarks"></a>Remarks

Режим растяжения биткарты определяет, как информация удаляется из битовых `StretchBlt` карт, которые растягиваются или сжимаются функцией участника.

Режимы STRETCH_ANDSCANS и STRETCH_ORSCANS обычно используются для сохранения пикселей переднего плана в монохромных бит-картах. Режим STRETCH_DELETESCANS обычно используется для сохранения цвета в цветных битовых картах.

## <a name="cdcgettabbedtextextent"></a><a name="gettabbedtextextent"></a>CDC:GetTabbedTextExtent

Вызов эту функцию элемента для вычисления ширины и высоты строки символов с помощью [m_hAttribDC](#m_hattribdc)контекста атрибута устройства.

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>Параметры

*lpszString*<br/>
Указывает на строку персонажа. Вы также можете передать объект [CString](../../atl-mfc-shared/reference/cstringt-class.md) для этого параметра.

*Ncount*<br/>
Определяет [длину строки,](/windows/win32/gdi/specifying-length-of-text-output-string) на которую указывает *lpszString.*

*nTabPositions*<br/>
Определяет количество позиций tab-stop в массиве, на которые указывают *lpnTabStopPositions.*

*lpnTabStopPositions*<br/>
Указывает на массив целых числа, содержащих позиции tab-stop в логических единицах. Остановки вкладок должны быть отсортированы в порядке увеличения; наименьшее значение x должно быть первым элементом в массиве. Задние вкладки не допускаются.

*Ул*<br/>
Объект, `CString` содержащий указанные символы, которые должны быть нарисованы.

### <a name="return-value"></a>Возвращаемое значение

Размеры строки (в логических единицах) в объекте [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Если строка содержит один или несколько символов вкладок, ширина строки основана на остановках вкладок, указанных *lpnTabStopPositions.* Функция использует выбранный в настоящее время шрифт для вычисления размеров строки.

Текущая область отсечения не компенсирует `GetTabbedTextExtent` ширину и высоту, возвращаемую функцией.

Поскольку некоторые устройства не размещают символы в обычных ячейках (т.е. они изъявляют символы), сумма размеров символов в строке может быть неравна с объемом строки.

Если *nTabPositions* равен 0, а *lpnTabStopPositions* является NULL, вкладки расширяются в восемь раз больше средней ширины персонажа. Если *nTabPositions* равен 1, остановки вкладок будут разделены расстоянием, указанным первым значением в массиве, к которому указывает *lpnTabStopPositions.* Если *lpnTabStopPositions* указывает на более чем одно значение, для каждого значения в массиве устанавливается остановка вкладок, вплоть до числа, указанного *nTabPositions.*

## <a name="cdcgettextalign"></a><a name="gettextalign"></a>CDC:GetTextAlign

Извлекает статус флагов выравнивания текста для контекста устройства.

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>Возвращаемое значение

Статус флагов текстового выравнивания. Значение возврата — это одно или несколько значений:

- TA_BASELINE определяет выравнивание x-оси и исходной линии выбранного шрифта в граничащий прямоугольник.

- TA_BOTTOM определяет выравнивание x-оси и нижней части граничащий прямоугольника.

- TA_CENTER определяет выравнивание y-оси и центра ограничивающего прямоугольника.

- TA_LEFT определяет выравнивание y-оси и левой стороны ограничивающего прямоугольника.

- TA_NOUPDATECP указывает, что текущая позиция не обновляется.

- TA_RIGHT определяет выравнивание y-оси и правой стороны связывая прямоугольника.

- TA_TOP определяет выравнивание x-оси и верхней части граничащий прямоугольника.

- TA_UPDATECP указывает, что текущая позиция обновляется.

### <a name="remarks"></a>Remarks

Флаги выравнивания текста `TextOut` определяют, как функции и `ExtTextOut` функции участника выравнивают строку текста по отношению к отправной точке строки. Флаги текстового выравнивания не обязательно являются однобитными флагами и могут быть равны 0. Чтобы проверить, установлен ли флаг, приложение должно следовать следующим шагам:

1. Примените оператора bitwise OR к флагу и связанным с ним флагам, сгруппированным следующим образом:

   - TA_LEFT, TA_CENTER и TA_RIGHT

   - TA_BASELINE, TA_BOTTOM и TA_TOP

   - TA_NOUPDATECP и TA_UPDATECP

1. Примените bitwise-AND оператора к результату `GetTextAlign`и значению возврата.

1. Тест на равенство этого результата и флага.

## <a name="cdcgettextcharacterextra"></a><a name="gettextcharacterextra"></a>CDC:GetTextCharacterExtra

Извлекает текущий параметр для интервала между персонажами.

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>Возвращаемое значение

Количество интервалов между символами.

### <a name="remarks"></a>Remarks

GDI добавляет этот интервал для каждого символа, включая символы разрыва, когда он записывает строку текста в контекст устройства.

Значение по умолчанию для интервала между персонажами составляет 0.

## <a name="cdcgettextcolor"></a><a name="gettextcolor"></a>CDC::GetTextColor

Извлекает текущий цвет текста.

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>Возвращаемое значение

Текущий цвет текста как значение цвета RGB.

### <a name="remarks"></a>Remarks

Цвет текста является цветом на переднем плане символов, нарисованных с помощью функций члена GDI текстового вывода [TextOut,](#textout) [ExtTextOut](#exttextout)и [TabbedTextOut.](#tabbedtextout)

## <a name="cdcgettextextent"></a><a name="gettextextent"></a>CDC:GetTextExtent

Вызов эту функцию члена для вычисления ширины и высоты строки текста с помощью текущего шрифта для определения размеров.

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>Параметры

*lpszString*<br/>
Указывает на строку символов. Вы также можете передать объект [CString](../../atl-mfc-shared/reference/cstringt-class.md) для этого параметра.

*Ncount*<br/>
Указывает количество знаков в строке.

*Ул*<br/>
Объект, `CString` содержащий указанные символы.

### <a name="return-value"></a>Возвращаемое значение

Размеры строки (в логических единицах) в объекте [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Информация извлекается из [m_hAttribDC](#m_hattribdc)контекста устройства атрибутов.

По умолчанию предполагается, что текст, `GetTextExtent` для которого он получает, размер установлен вдоль горизонтальной линии (т.е. выход составляет 0). При создании шрифта с указанием ненулевого выхода необходимо точно преобразовать угол текста, чтобы получить размеры строки.

Текущая область отсечения не `GetTextExtent`влияет на ширину и высоту, возвращенную.

Поскольку некоторые устройства не размещают символы в обычных ячейках (т.е. они выполняют кернинг), сумма размеров символов в строке может быть неравна с объемом строки.

## <a name="cdcgettextextentexpointi"></a><a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointi

Извлекает количество символов в заданную строку, которая будет вписываться в указанное пространство и заполняет массив с объемом текста для каждого из этих символов.

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*pgiIn*<br/>
Указатель на массив глифовных индексов, для которых необходимо получить степени.

*Cgi*<br/>
Определяет количество глифов в массиве, на который указывает *pgiIn.*

*nMaxExtent*<br/>
Определяет максимально допустимую ширину, в логических единицах, отформатированных строк.

*lpnFit*<br/>
Указатель на целый ряд, который получает количество максимального количества символов, которые будут вписываться в пространство, указанное *nMaxExtent*. Когда *lpnFit* является NULL, *nMaxExtent* игнорируется.

*alpDx*<br/>
Указатель на массив целых, который получает частичные степени глифа. Каждый элемент в массиве дает расстояние, в логических единицах, между началом массива глифов и одним из глифов, который помещается в пространстве, указанном *nMaxExtent*. Хотя этот массив должен иметь по крайней мере столько элементов, как глиф индексы, указанные *cgi*, функция заполняет массив с размерами только для столько глифов индексов, как указано *в lpnFit*. Если *lpnDx* null, функция не вычисляет частичную ширину строки.

*lpSize*<br/>
Указатель на структуру [СИЗЕ,](/windows/win32/api/windef/ns-windef-size) которая получает размеры массива индексов глифа, в логических единицах. Это значение не может быть NULL.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция-член имитирует функциональность функции [GetTextExtentExPointI,](/windows/win32/api/wingdi/nf-wingdi-gettextextentexpointi)как описано в SDK Windows.

## <a name="cdcgettextextentpointi"></a><a name="gettextextentpointi"></a>CDC::GetTextExtentpointI

Извлекает ширину и высоту указанного массива глифововых индексов.

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*pgiIn*<br/>
Указатель на массив глифовных индексов, для которых необходимо получить степени.

*Cgi*<br/>
Определяет количество глифов в массиве, на который указывает *pgiIn.*

*lpSize*<br/>
Указатель на структуру [СИЗЕ,](/windows/win32/api/windef/ns-windef-size) которая получает размеры массива индексов глифа, в логических единицах. Это значение не может быть NULL.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция члена эмулирует функциональность функции [GetTextExtentPointI](/windows/win32/api/wingdi/nf-wingdi-gettextextentpointi), как описано в Windows SDK.

## <a name="cdcgettextface"></a><a name="gettextface"></a>CDC:GetTextFace

Вызовите эту функцию участника, чтобы скопировать имя шрифта текущего шрифта в буфер.

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>Параметры

*Ncount*<br/>
Определяет размер буфера (в байтах). Если имя шрифта больше, чем количество байтов, указанное этим параметром, то имя усечено.

*lpszFacename*<br/>
Указывает на буфер для имени шрифта.

*rString*<br/>
Ссылка на объект [CString.](../../atl-mfc-shared/reference/cstringt-class.md)

### <a name="return-value"></a>Возвращаемое значение

Количество байтов, скопированных в буфер, не включая термин null. Это 0, если происходит ошибка.

### <a name="remarks"></a>Remarks

Имя шрифта копируется как строка с нулевым завершением.

## <a name="cdcgettextmetrics"></a><a name="gettextmetrics"></a>CDC:GetTextMetrics

Извлекает метрики для текущего шрифта с помощью контекста устройства атрибутов.

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>Параметры

*lpMetrics*<br/>
Указывает на структуру [TEXTMETRIC,](/windows/win32/api/wingdi/ns-wingdi-textmetricw) которая получает метрики.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

## <a name="cdcgetviewportext"></a><a name="getviewportext"></a>CDC:GetViewportExt

Извлекает x- и y-extents зрения контекста устройства.

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>Возвращаемое значение

X- и y-extents (в единицах `CSize` устройства) в качестве объекта.

## <a name="cdcgetviewportorg"></a><a name="getviewportorg"></a>CDC:GetViewportOrg

Извлекает x- и y-координаты происхождения порта представления, связанного с контекстом устройства.

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>Возвращаемое значение

Происхождение объекта представления (в координатах устройства) как `CPoint` объекта.

## <a name="cdcgetwindow"></a><a name="getwindow"></a>CDC:GetWindow

Возвращает окно, связанное с контекстом устройства дисплея.

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CWnd` объект в случае успеха; в противном случае NULL.

### <a name="remarks"></a>Remarks

Это продвинутая функция. Например, эта функция-член не может вернуть окно представления при печати или при предварительном просмотре печати. Он всегда возвращает окно, связанное с выходным. Выходные функции, которые используют данный притягивание постоянного тока в это окно.

## <a name="cdcgetwindowext"></a><a name="getwindowext"></a>CDC:GetWindowExt

Извлекает x- и y-объемы окна, связанные с контекстом устройства.

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>Возвращаемое значение

X- и y-extents (в логических `CSize` единицах) как объект.

## <a name="cdcgetwindoworg"></a><a name="getwindoworg"></a>CDC::GetWindowOrg

Извлекает x- и y-координаты происхождения окна, связанные с контекстом устройства.

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>Возвращаемое значение

Происхождение окна (в логических координатах) как `CPoint` объекта.

## <a name="cdcgetworldtransform"></a><a name="getworldtransform"></a>CDC:GetWorldTransform

Извлекает текущее пространство мира в преобразование пространства страницы.

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>Параметры

*rXform*<br/>
Ссылка на структуру [XFORM,](/windows/win32/api/wingdi/ns-wingdi-xform) которая получает текущее мировое пространство для преобразования пространства страниц.

### <a name="return-value"></a>Возвращаемое значение

Возвращает ненулевое значение успеха.

Возвращает 0 при сбое.

Чтобы получить расширенную информацию об ошибке, позвоните [getLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Remarks

Этот метод обертывает функцию Windows GDI [GetWorldTransform.](/windows/win32/api/wingdi/nf-wingdi-getworldtransform)

## <a name="cdcgradientfill"></a><a name="gradientfill"></a>CDC:GradientFill

Вызов ифункции этого члена для заполнения прямоугольников и треугольников цветом, который плавно исчезает с одной стороны на другую.

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>Параметры

*pVertices*<br/>
Указатель на массив структур [TRIVERTEX,](/windows/win32/api/wingdi/ns-wingdi-trivertex) каждый из которых определяет вершину треугольника.

*nVertices*<br/>
Количество головорающих.

*pMesh*<br/>
Массив [GRADIENT_TRIANGLE](/windows/win32/api/wingdi/ns-wingdi-gradient_triangle) структур в режиме треугольника или массив [GRADIENT_RECT](/windows/win32/api/wingdi/ns-wingdi-gradient_rect) структуры в режиме прямоугольника.

*nМешЭлементы*<br/>
Количество элементов (треугольников или прямоугольников) в *pMesh*.

*dwMode*<br/>
Определяет режим заполнения градиента. Список возможных значений можно узнать в [SDK СДК с видом](/windows/win32/api/wingdi/nf-wingdi-gradientfill) на градиент.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если успешно; в противном случае — FALSE.

### <a name="remarks"></a>Remarks

Для получения дополнительной `GradientFill` информации см.

## <a name="cdcgraystring"></a><a name="graystring"></a>CDC::GrayString

Рисует затемненный (серый) текст в данном месте, написав текст в байк-карте памяти, затемнение битной карты, а затем копирование бит-карты на дисплее.

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Параметры

*pBrush*<br/>
Определяет кисть, которая будет использоваться для затемнения (серого цвета).

*lpfnOutput*<br/>
Упогоняет адрес процедуры-инстанции функции обратного вызова, предоставленной приложением, которая нарисует строку. Для получения дополнительной информации смотрите `OutputFunc` описание [функции обратного вызова](callback-functions-used-by-mfc.md#graystring)Windows. Если этот параметр NULL, система `TextOut` использует функцию Windows для рисования строки, и *lpData* считается длинным указателем на строку символов, чтобы быть выходом.

*lpData*<br/>
Определяет далеко указатель на данные, которые должны быть переданы в функцию вывода. Если *lpfnOutput* является NULL, *lpData* должен быть длинным указателем на строку, чтобы быть выходным.

*Ncount*<br/>
Определяет количество символов, которые будут выходными. Если этот параметр `GrayString` радо 0, вычисляет длину строки (при условии, что *lpData* является указателем на строку). Если *nCount* 1 и функция, на которую указывает *lpfnOutput* возвращает 0, изображение отображается, но не затемняется.

*x*<br/>
Определяет логическую х-координацию исходного положения прямоугольника, который огражает строку.

*Y*<br/>
Определяет логическую y-координацию исходного положения прямоугольника, который огражает строку.

*nWidth*<br/>
Определяет ширину (в логических единицах) прямоугольника, который примыкает к строке. Если *nWidth* равен 0, `GrayString` вычисляет ширину области, предполагая, что *lpData* является указателем на строку.

*nВысота*<br/>
Определяет высоту (в логических единицах) прямоугольника, который примыкает к строке. Если *nHeight* равен 0, `GrayString` вычисляет высоту области, предполагая, что *lpData* является указателем на строку.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если строка нарисована, `TextOut` или 0, если либо функция или функция, поставляемая приложением, вернулись 0, или если не было достаточной памяти для создания битовой карты памяти для затемнения.

### <a name="remarks"></a>Remarks

Функция затемняет текст независимо от выбранной кисти и фона. Функция `GrayString` члена использует выбранный в настоящее время шрифт. Перед использованием этой функции необходимо выбрать режим отображения MM_TEXT.

Приложение может рисовать затемненные (серые) строки на устройствах, поддерживающих сплошной серый цвет без вызова функции `GrayString` участника. Цвет системы COLOR_GRAYTEXT является твердо-серый цвет системы используется для рисования отключен текста. Приложение может вызвать функцию `GetSysColor` Windows для получения цветовой ценности COLOR_GRAYTEXT. Если цвет не растерянный 0 (черный), приложение может вызвать функцию `SetTextColor` участника, чтобы установить цвет текста к цвету значения, а затем нарисовать строку напрямую. Если извлеченный цвет черный, приложение `GrayString` должно позвонить, чтобы потускнеть (серый) текст.

Если *lpfnOutput* является NULL, GDI использует функцию Windows [TextOut,](/windows/win32/api/wingdi/nf-wingdi-textoutw) и *lpData* считается далеким указателем на вывод персонажа. Если символы, которые будут выводиться, не могут быть обработаны функцией `TextOut` члена (например, строка хранится как биткарта), приложение должно предоставить свою собственную функцию вывода.

Также обратите внимание, что все функции обратного вызова должны заманивать исключения Фонда Майкрософт в ловушку перед возвращением в Windows, так как исключения не могут быть брошены через границы обратного вызова. Для получения дополнительной информации об [Exceptions](../../mfc/exception-handling-in-mfc.md)исключениях см.

Функция обратного вызова, `GrayString` переданная, должна использовать колл-конвенцию `__stdcall` и должна экспортироваться с `__declspec`помощью.

Когда фреймворк находится в `GrayString` режиме предварительного `TextOut` просмотра, вызов функции участника переводится на вызов, и функция обратного вызова не вызывается.

## <a name="cdchimetrictodp"></a><a name="himetrictodp"></a>CDC:HIMETRICtoDP

Используйте эту функцию при преобразовании размеров HIMETRIC из OLE в пиксели.

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*lpSize*<br/>
Указывает на структуру [СИЗЕ](/windows/win32/api/windef/ns-windef-size) или объект [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Если режим отображения объекта контекста устройства является MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC или MM_HIMETRIC, то преобразование основано на количестве пикселей в физическом дюйме. Если режим отображения является одним из других неограниченных режимов (например, MM_TEXT), то преобразование основано на количестве пикселей в логическом дюйме.

## <a name="cdchimetrictolp"></a><a name="himetrictolp"></a>CDC:HIMETRICtoLP

Вызовите эту функцию для преобразования единиц HIMETRIC в логические единицы.

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*lpSize*<br/>
Указывает на структуру [СИЗЕ](/windows/win32/api/windef/ns-windef-size) или объект [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Используйте эту функцию, когда вы получаете размеры HIMETRIC от OLE и хотите преобразовать их в естественный режим отображения вашего приложения.

Преобразование осуществляется путем сначала преобразования единиц HIMETRIC в пиксели, а затем преобразования этих единиц в логические единицы с помощью текущих единиц отображения контекста устройства. Обратите внимание, что размеры окна устройства и viewport будут влиять на результат.

## <a name="cdcintersectcliprect"></a><a name="intersectcliprect"></a>CDC:ИнтерсектКскСрезРес

Создает новую область отсечения, образуя пересечение текущей области и прямоугольника, указанного *x1,* *y1,* *x2*и *y2.*

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет логическую х-координацию верхнего левого угла прямоугольника.

*y1*<br/>
Определяет логическую y-координацию верхнего левого угла прямоугольника.

*x2*<br/>
Определяет логическую х-координацию нижнего правого угла прямоугольника.

*y2*<br/>
Определяет логическую y-координацию нижнего правого угла прямоугольника.

*lpRect*<br/>
Определяет прямоугольник. Вы можете передать `CRect` либо объект, либо `RECT` указатель на структуру для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Тип нового региона отсечения. Это может быть любое из следующих значений:

- COMPLEXREGION Новая область отсечения имеет перекрывающиеся границы.

- Контекст устройства ERROR недействителен.

- НОВА область отсечения NULLREGION пуста.

- SIMPLEREGION Новая область отсечения не имеет перекрывающихся границ.

### <a name="remarks"></a>Remarks

GDI зажимает все последующие выходные, чтобы соответствовать новой границе. Ширина и высота не должны превышать 32 767.

## <a name="cdcinvertrect"></a><a name="invertrect"></a>CDC:InvertRect

Инвертирует содержимое данного прямоугольника.

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на `RECT` точку, содержащую логические координаты прямоугольника, который необходимо перевернуть. Вы также можете `CRect` передать объект для этого параметра.

### <a name="remarks"></a>Remarks

Инверсия является логическим НЕ операции и переворачивает биты каждого пикселя. На монохромных дисплеях функция делает белые пиксели черными и черными. На цветных дисплеях инверсия зависит от того, как сгенерируются цвета для дисплея. Вызов `InvertRect` дважды с тем же прямоугольником восстанавливает дисплей до его предыдущих цветов.

Если прямоугольник пуст, ничего не нарисовано.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

## <a name="cdcinvertrgn"></a><a name="invertrgn"></a>CDC:InvertRgn

Инвертирует цвета в регионе, указанном *pRgn*.

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Параметры

*pRgn*<br/>
Идентифицирует регион, который будет инвертирован. Координаты для региона указаны в логических единицах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

На монохромных дисплеях функция делает белые пиксели черными и черными. На цветных дисплеях инверсия зависит от того, как сгенерируются цвета для дисплея.

## <a name="cdcisprinting"></a><a name="isprinting"></a>CDC::IsPrinting

Определяет, используется ли контекст устройства для печати.

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, `CDC` если объект является принтером DC; в противном случае 0.

## <a name="cdclineto"></a><a name="lineto"></a>CDC:LineTo

Рисует линию от текущего положения до, но не включая точку, указанную *x* и *y* (или *точкой).*

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию конечной точки для линии.

*Y*<br/>
Определяет логическую y-координацию конечной точки для линии.

*Точки*<br/>
Определяет конечную точку для строки. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если линия нарисована; в противном случае 0.

### <a name="remarks"></a>Remarks

Линия нарисована выбранной ручкой. Текущая позиция установлена на *x,* *y* или *в точку.*

### <a name="example"></a>Пример

  Смотрите пример [cRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdclptodp"></a><a name="lptodp"></a>CDC::LPtoDP

Преобразует логические блоки в блоки устройств.

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив точек. Каждая точка в массиве представляет собой структуру [POINT](/windows/win32/api/windef/ns-windef-point) или объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*Ncount*<br/>
Количество точек в массиве.

*lpRect*<br/>
Указывает на структуру [RECT](/windows/win32/api/windef/ns-windef-rect) или объект [CRect.](../../atl-mfc-shared/reference/crect-class.md) Этот параметр используется для общего случая отображения прямоугольника от логических к единицам устройства.

*lpSize*<br/>
Указывает на структуру [СИЗЕ](/windows/win32/api/windef/ns-windef-size) или объект [CSize.](../../atl-mfc-shared/reference/csize-class.md)

### <a name="remarks"></a>Remarks

Функция отображает координаты каждой точки или размеры, от системы логических координат GDI до системы координат устройства. Преобразование зависит от текущего режима отображения и параметров происхождения и степени окна и поля зрения устройства.

X- и y-координаты точек 2-байт подписали целые в диапазоне -32,768 до 32,767. В тех случаях, когда режим отображения приведет к значениям больше этих пределов, система устанавливает значения до -32 768 и 32 767, соответственно.

## <a name="cdclptohimetric"></a><a name="lptohimetric"></a>CDC::LPtoHIMETRIC

Вызовите эту функцию для преобразования логических единиц в единицы HIMETRIC.

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>Параметры

*lpSize*<br/>
Указывает на `SIZE` структуру `CSize` или объект.

### <a name="remarks"></a>Remarks

Используйте эту функцию, когда вы даете HIMETRIC размеры OLE, преобразования из естественного отображения режима вашего приложения. Обратите внимание, что размеры окна устройства и viewport будут влиять на результат.

Преобразование осуществляется путем сначала преобразования логических единиц в пиксели с помощью текущих единиц отображения контекста устройства, а затем преобразования этих единиц в единицы HIMETRIC.

## <a name="cdcm_hattribdc"></a><a name="m_hattribdc"></a>CDC::m_hAttribDC

Контекст атрибута для `CDC` этого объекта.

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>Remarks

По умолчанию контекст этого `m_hDC`устройства равен. Как правило, `CDC` GDI звонки, запрашивающие информацию `m_hAttribDC`из контекста устройства, направляются на. Подробнее об использовании этих двух контекстов устройств можно узнать в описании класса [CDC.](../../mfc/reference/cdc-class.md)

## <a name="cdcm_hdc"></a><a name="m_hdc"></a>CDC::m_hDC

Контекст устройства вывода `CDC` для этого объекта.

```
HDC m_hDC;
```

### <a name="remarks"></a>Remarks

По умолчанию, `m_hDC` `m_hAttribDC`равен , другой `CDC`контекст устройства, завернутый в . Как правило, `CDC` вызовы GDI, `m_hDC` создающие выход, переходят в контекст устройства. Можно инициализировать `m_hDC` и `m_hAttribDC` указать на различные устройства. Подробнее об использовании этих двух контекстов устройств можно узнать в описании класса [CDC.](../../mfc/reference/cdc-class.md)

## <a name="cdcmaskblt"></a><a name="maskblt"></a>CDC::Маскблт

Комбинирует исходные данные для исходных и клиративных карт назначения, используя данную маску и raster.

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координатум верхнего левого угла прямоугольника назначения.

*Y*<br/>
Определяет логическую y-координацию верхнего левого угла прямоугольника назначения.

*nWidth*<br/>
Определяет ширину в логических единицах прямоугольника назначения и исходной биткарты.

*nВысота*<br/>
Определяет высоту, в логических единицах, прямоугольника назначения и исходной биткарты.

*pSrcDC*<br/>
Определяет контекст устройства, из которого должна быть скопирована бит-карта. Она должна быть равна нулю, если параметр *dwRop* определяет операцию raster, которая не включает источник.

*xSrc*<br/>
Определяет логическую х-координацию верхнего левого угла исходной биткарты.

*ySrc*<br/>
Определяет логическую y-координацию верхнего левого угла исходной биткарты.

*маскаBitmap*<br/>
Идентифицирует монохромную маску в сочетании с цветовой битовой картой в контексте исходного устройства.

*xМаск*<br/>
Определяет горизонтальный пиксель, смещенный для бикарты маски, указанной параметром *маскиBitmap.*

*yМаск*<br/>
Определяет вертикальное смещение пикселей для бикарты маски, указанной параметром *маскиBitmap.*

*dwRop*<br/>
Определяет как коды работы на переднем плане, так и фонового ternary raster, которые функция использует для управления комбинацией исходных данных и данных назначения. Код операции фонового raster хранится в высоком байте высокого слова этого значения; код операции raster переднего плана хранится в низком байте высокого слова этого значения; низкое слово этого значения игнорируется, и должно быть нулевым. Макро MAKEROP4 создает такие комбинации кодов работы переднего плана и фонового raster. В контексте этой функции смотрите раздел «Замечания» для обсуждения переднего плана и фона. Посмотреть `BitBlt` функцию участника для списка общих кодов операций raster.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Значение 1 в маске, указанном *maskBitmap,* указывает на то, что код работы raster переднего плана, указанный *dwRop,* должен быть применен в этом месте. Значение 0 в маске указывает на то, что код работы фонового raster, указанный *dwRop,* должен быть применен в этом месте. Если операции raster требуют источника, прямоугольник маски должен покрыть прямоугольник источника. Если это не так, функция выйдет из строя. Если операции raster не требуют источника, прямоугольник маски должен покрывать прямоугольник назначения. Если это не так, функция выйдет из строя.

Если вращение или преобразование сдвига действует для контекста исходного устройства при вызове этой функции, возникает ошибка. Тем не менее, разрешены и другие типы преобразований.

Если цветовые форматы исходных, шаблонных и клиральных карт назначения различаются, эта функция преобразует шаблон или формат источника, или оба, в соответствии с форматом назначения. Если бикарта маски не является монохромной битовой картой, возникает ошибка. При записи расширенного метафайла возникает ошибка (и функция возвращается 0), если контекст исходного устройства определяет контекст устройства повышенной метафилы. Не все `MaskBlt`устройства поддерживают. Приложение должно `GetDeviceCaps` вызываться, чтобы определить, поддерживает ли устройство эту функцию. Если не поставляется маска bitmap, эта функция `BitBlt`ведет себя точно так же, как, используя код операции raster переднего плана. Пиксель смещен на карте биткарты маски до точки (0,0) в битной карте контекста исходного устройства. Это полезно для случаев, когда маска bitmap содержит набор масок; приложение может легко применить любой из них к задаче маски-blitting, регулируя пиксельные смещения и прямоугольники размеров, отправленных `MaskBlt`в .

## <a name="cdcmodifyworldtransform"></a><a name="modifyworldtransform"></a>CDC::ModifyWorldTransform

Изменяет преобразование мира для контекста устройства с помощью заданного режима.

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>Параметры

*rXform*<br/>
Ссылка на структуру [XFORM,](/windows/win32/api/wingdi/ns-wingdi-xform) используемую для изменения трансформации мира для данного контекста устройства.

*iMode*<br/>
Определяет, как данные о трансформации изменяют текущую трансформацию мира. Список значений, которые может принять этот параметр, [см.](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)

### <a name="return-value"></a>Возвращаемое значение

Возвращает ненулевое значение успеха.

Возвращает 0 при сбое.

Чтобы получить расширенную информацию об ошибке, позвоните [getLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Remarks

Этот метод обертывает функцию Windows GDI [ModifyWorldTransform.](/windows/win32/api/wingdi/nf-wingdi-modifyworldtransform)

## <a name="cdcmoveto"></a><a name="moveto"></a>CDC::MoveTo

Перемещает текущее положение в точку, указанную *x* и *y* (или по *пункту).*

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию новой позиции.

*Y*<br/>
Определяет логическую y-координацию новой позиции.

*Точки*<br/>
Уточняет новую должность. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

X- и y-координаты предыдущей позиции как `CPoint` объекта.

### <a name="example"></a>Пример

  Смотрите пример [cRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint).

## <a name="cdcoffsetcliprgn"></a><a name="offsetcliprgn"></a>CDC::OffsetClipRgn

Перемещает область отсечения контекста устройства указанными смещениями.

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет количество логических единиц для перемещения влево или вправо.

*Y*<br/>
Определяет количество логических единиц для перемещения вверх или вниз.

*Размер*<br/>
Определяет сумму для компенсации.

### <a name="return-value"></a>Возвращаемое значение

Тип нового региона. Это может быть любое из следующих значений:

- Область отсечения COMPLEXREGION имеет перекрывающиеся границы.

- Контекст устройства ERROR недействителен.

- Область отсечения NULLREGION пуста.

- Область отсечения SIMPLEREGION не имеет перекрывающихся границ.

### <a name="remarks"></a>Remarks

Функция перемещает область *x* единиц вдоль оси x и *y* единиц вдоль y-оси.

## <a name="cdcoffsetviewportorg"></a><a name="offsetviewportorg"></a>CDC::OffsetViewportOrg

Изменяет координаты происхождения viewport относительно координат текущего происхождения порта представления.

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Параметры

*nWidth*<br/>
Определяет количество единиц устройства для добавления к x-координате текущего происхождения.

*nВысота*<br/>
Определяет количество единиц устройства для добавления к y-координату текущего происхождения.

### <a name="return-value"></a>Возвращаемое значение

Предыдущее происхождение объекта (в координатах устройства) в качестве `CPoint` объекта.

## <a name="cdcoffsetwindoworg"></a><a name="offsetwindoworg"></a>CDC::OffsetWindowOrg

Изменяет координаты происхождения окна относительно координат текущего происхождения окна.

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>Параметры

*nWidth*<br/>
Определяет количество логических единиц, чтобы добавить к x-координату текущего происхождения.

*nВысота*<br/>
Определяет количество логических единиц, чтобы добавить к y-координату текущего происхождения.

### <a name="return-value"></a>Возвращаемое значение

Предыдущее происхождение окна (в логических `CPoint` координатах) как объект.

## <a name="cdcoperator-hdc"></a><a name="operator_hdc"></a>CDC:оператор HDC

Используйте этот оператор для извлечения `CDC` контекстной ручки объекта.

```
operator HDC() const;
```

### <a name="return-value"></a>Возвращаемое значение

В случае успеха, ручка устройства контекст объекта; в противном случае, NULL.

### <a name="remarks"></a>Remarks

Ручку можно использовать для прямого вызова AA Windows.

## <a name="cdcpaintrgn"></a><a name="paintrgn"></a>CDC::PaintRgn

Заполняет область, указанную *pRgn,* с помощью текущей кисти.

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>Параметры

*pRgn*<br/>
Определяет регион, который должен быть заполнен. Координаты данного региона указаны в логических единицах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

## <a name="cdcpatblt"></a><a name="patblt"></a>CDC::PatBlt

Создает немного шаблон на устройстве.

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координату айтangle в верхнем левом углу прямоугольника, который должен получить узор.

*Y*<br/>
Определяет логическую y-координацию верхнего левого угла прямоугольника, который должен получить шаблон.

*nWidth*<br/>
Определяет ширину (в логических единицах) прямоугольника, который должен получить шаблон.

*nВысота*<br/>
Определяет высоту (в логических единицах) прямоугольника, который должен получить шаблон.

*dwRop*<br/>
Определяет код raster-operation. Коды Raster-operation (ROPs) определяют, как GDI объединяет цвета в выходных операциях, которые включают текущую кисть, возможную битную карту исхода и битную карту назначения. Этот параметр может быть одним из следующих значений:

- PATCOPY Копии шаблон назначения bitmap.

- PATINVERT сочетает в себе битную карту назначения с узором с помощью оператора Boolean XOR.

- DSTINVERT инвертирует битную карту назначения.

- BLACKNESS превращает все выходные черные.

- WHITENESS превращает все выходные белые.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Шаблон представляет собой сочетание выбранной кисти и шаблона уже на устройстве. Код raster-operation, указанный *dwRop,* определяет, как должны сочетаться шаблоны. Операции raster, перечисленные для этой функции, представляют собой ограниченное подмножество из полных 256 кодов ternary raster-operation; в частности, не может быть использован код raster-operation, относягайский к источнику.

Не все контексты `PatBlt` устройства поддерживают функцию. Чтобы определить, поддерживается `PatBlt`ли `GetDeviceCaps` контекст устройства, позвоните функции участника с индексом RASTERCAPS и проверьте значение возврата для RC_BITBLT флага.

## <a name="cdcpie"></a><a name="pie"></a>CDC::Pie

Рисует клин в форме пирога, рисуя эллиптической дуги, центр и две конечные точки соединены линиями.

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет x-координат верхнего левого угла ограничивающего прямоугольника (в логических единицах).

*y1*<br/>
Определяет y-координат верхнего левого угла ограничивающего прямоугольника (в логических единицах).

*x2*<br/>
Определяет x-координат в нижнем правом углу граничащий прямоугольник (в логических единицах).

*y2*<br/>
Определяет y-координат нижнего правого угла ограничивающего прямоугольника (в логических единицах).

*x3*<br/>
Определяет x-координацию отправной точки дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*y3*<br/>
Определяет y-координацию отправной точки дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*x4*<br/>
Определяет x-координацию конечной точки дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*y4*<br/>
Определяет y-координацию конечной точки дуги (в логических единицах). Этот пункт не должен лежать точно на дуге.

*lpRect*<br/>
Определяет прямоугольник. Вы можете передать `CRect` либо объект, либо `RECT` указатель на структуру для этого параметра.

*ptStart*<br/>
Определяет отправную точку дуги. Этот пункт не должен лежать точно на дуге. Для этого параметра можно пройти либо структуру [POINT,](/windows/win32/api/windef/ns-windef-point) либо объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

*ptEnd*<br/>
Определяет конечную точку дуги. Этот пункт не должен лежать точно на дуге. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Центр дуги является центром связующего прямоугольника, указанного *x1,* *y1,* *x2*и *y2* (или *lpRect).* Стартовые и конечные точки дуги указаны *x3,* *y3,* *x4*и *y4* (или *ptStart* и *ptEnd).*

Дуга нарисована выбранной ручкой, двигаясь в направлении против часовой стрелки. Две дополнительные линии нарисованы от каждой точки конца к центру дуги. Область в форме пирога заполнена текущей кистью. Если *x3* равен *x4* и *y4* *y3,* то это эллипс с одной линией от центра эллипса до точки *(x3,* *y3)* или *(x4,* *y4*).

Рисунок, нарисованный этой функцией, простирается до, но не включает правые и нижние координаты. Это означает, что высота фигуры *y2* - *y1* и ширина фигуры *x2* - *x1.* И ширина, и высота связующего прямоугольника должны быть больше 2 единиц и менее 32 767 единиц.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

## <a name="cdcplaymetafile"></a><a name="playmetafile"></a>CDC::PлайМетаФайл

Воспроизведение содержимого указанного метафайла в контексте устройства.

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>Параметры

*Hmf*<br/>
Идентифицирует метафайл, который будет воспроизводиться.

*hEnhMetaFile*<br/>
Идентифицирует расширенный метафайл.

*lpBounds*<br/>
Указывает на `RECT` структуру `CRect` или объект, содержащий координаты прямоугольника, используемого для отображения изображения. Координаты указаны в логических единицах.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Метафайл можно воспроизводить в любое количество раз.

Вторая версия `PlayMetaFile` отображает изображение, хранящееся в данном метафиле расширенного формата. Когда приложение вызывает вторую `PlayMetaFile`версию, Windows использует рамку изображения в расширенном метафиле заголовок для отображения изображения на прямоугольнике, на который указывает параметр *lpBounds.* (Эта картина может быть сровнена или повернута путем `PlayMetaFile`установки преобразования мира в устройстве вывода перед вызовом .) Точки по краям прямоугольника включены в изображение. Улучшенное изображение метафайла можно отрезать, определив область отсечения в устройстве вывода перед воспроизведением расширенного метафайла.

Если расширенный метафайл содержит дополнительную палитру, приложение может достичь согласованных цветов, настроив цветовую палитру на устройстве вывода перед вызовом второй версии `PlayMetaFile`. Чтобы получить дополнительную палитру, используйте функцию `GetEnhMetaFilePaletteEntries` Windows. Улучшенный метафайл может быть встроен в недавно созданный расширенный метафайл, позвонив во вторую версию `PlayMetaFile` и воспроизвивав увеличенный метафайл источника в контекст устройства для нового расширенного метафайла.

Состояния контекста вывода устройства сохраняются этой функцией. Любой объект, созданный, но не удаленный в расширенном метафайле, удаляется этой функцией. Чтобы остановить эту функцию, `CancelDC` приложение может вызвать функцию Windows из другого потока, чтобы завершить работу. В этом случае функция возвращается ноль.

## <a name="cdcplgblt"></a><a name="plgblt"></a>CDC::PlgBlt

Выполняет перенос бит-блоковых данных из заданного прямоугольника в контексте исходного устройства в заданную параллелограмму в данном контексте устройства.

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>Параметры

*lpPoint*<br/>
Указывает на массив из трех точек в логическом пространстве, которое определяет три угла назначения параллелограммы. Верхний левый угол прямоугольника источника отображается до первой точки в этом массиве, верхний правый угол до второй точки в этом массиве, а нижний левый угол до третьей точки. Нижний правый угол прямоугольника источника отображается на неявной четвертой точке параллелограммы.

*pSrcDC*<br/>
Определяет контекст исходного устройства.

*xSrc*<br/>
Определяет x-координацию, в логических единицах, верхнего левого угла прямоугольника источника.

*ySrc*<br/>
Определяет y-координацию, в логических единицах, верхнего левого угла прямоугольника источника.

*nWidth*<br/>
Определяет ширину в логических единицах прямоугольника источника.

*nВысота*<br/>
Определяет высоту, в логических единицах, прямоугольника источника.

*маскаBitmap*<br/>
Определяет дополнительную монохромную бит-карту, которая используется для маскировки цветов исходного прямоугольника.

*xМаск*<br/>
Определяет x-координат верхнего левого угла монохромной битовой карты.

*yМаск*<br/>
Определяет y-координат верхнего левого угла монохромной битовой карты.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Если данная рукоятки битовой маски идентифицирует действительную монохромную бит-карту, функция использует эту битную карту, чтобы замаскировать биты цветных данных из исходного прямоугольника.

Четвертая вершина параллелограммы (D) определяется путем обработки первых трех точек (A, B и C) в качестве векторов и вычислений D и B и C - A.

Если битмаска существует, значение 1 в маске указывает на то, что цвет пикселей исходного кода должен быть скопирован к месту назначения. Значение 0 в маске указывает на то, что цвет пикселей назначения не должен быть изменен.

Если прямоугольник маски меньше, чем прямоугольники источника и назначения, функция повторяет шаблон маски.

Изменения масштабирования, перевода и отражения разрешены в контексте исходного устройства; однако, вращение и сдвига преобразований не являются. Если бикарта маски не является монохромной битовой картой, возникает ошибка. Режим растяжения для контекста устройства назначения используется для определения того, как растягивать или сжимать пиксели, если это необходимо. При записи расширенного метафайла возникает ошибка, если контекст исходного устройства определяет контекст устройства повышенной метафилы.

Координаты назначения преобразуются в зависимости от контекста устройства назначения; исходные координаты преобразуются в зависимости от контекста исходного устройства. Если преобразование источника имеет вращение или сдвига, возвращается ошибка. Если прямоугольники назначения и источника не имеют одного `PlgBlt` и того же цветового формата, преобразует прямоугольник источника в соответствии с прямоугольником назначения. Не все `PlgBlt`устройства поддерживают. Для получения дополнительной информации, см описание RC_BITBLT `CDC::GetDeviceCaps` возможности raster в функции члена.

Если контексты исходного устройства и устройства `PlgBlt` назначения представляют собой несовместимые устройства, возвращается ошибка.

## <a name="cdcpolybezier"></a><a name="polybezier"></a>CDC::PolyBezier

Рисует один или несколько Bzier splines.

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив структур данных [POINT,](/windows/win32/api/windef/ns-windef-point) которые содержат конечные точки и контрольные точки сплайна(ы).

*Ncount*<br/>
Определяет количество точек в массиве *lpPoints.* Это значение должно быть более чем в три раза больше, чем количество сплайно, которые должны быть нарисованы, потому что каждый Bzier spline требует двух контрольных точек и конечной точки, и начальный сплайн требует дополнительной отправной точки.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция рисует кубические splines Bzier, используя конечные точки и контрольные точки, указанные параметром *lpPoints.* Первый сплайн обращается от первой точки до четвертой, используя вторую и третью в качестве контрольных точек. Каждому последующему сплайну в последовательности нужно ровно три точки: конечная точка предыдущего сплайна используется в качестве отправной точки, следующие две точки в последовательности являются контрольные точки, а третья конечная точка.

Текущее положение не используется и `PolyBezier` не обновляется функцией. Цифра не заполнена. Эта функция рисует линии с помощью текущего пера.

## <a name="cdcpolybezierto"></a><a name="polybezierto"></a>CDC::PolyBezierTo

Рисует один или несколько Bzier splines.

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив структур данных [POINT,](/windows/win32/api/windef/ns-windef-point) содержащий конечные точки и контрольные точки.

*Ncount*<br/>
Определяет количество точек в массиве *lpPoints.* Это значение должно быть в три раза больше, чем нарисовано, потому что каждому bzier spline требуется две контрольные точки и конечная точка.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция рисует кубические splines Bzier, используя контрольные точки, указанные параметром *lpPoints.* Первый сплайн обращается из текущей позиции в третью точку, используя первые две точки в качестве контрольных точек. Для каждого последующего сплайна функции требуется ровно три точки и в качестве отправной точки для следующего используется конечная точка предыдущего сплайна. `PolyBezierTo`перемещает текущее положение в конечную точку последнего bzier spline. Цифра не заполнена. Эта функция рисует линии с помощью текущего пера.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::BeginPath](#beginpath).

## <a name="cdcpolydraw"></a><a name="polydraw"></a>CDC::PolyDraw

Рисует набор сегментов линий и Bzier splines.

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив структур данных [POINT,](/windows/win32/api/windef/ns-windef-point) содержащий конечные точки для каждого сегмента строки и конечные точки и контрольные точки для каждого сплалина Bzier.

*lpTypes*<br/>
Указывает на массив, который определяет, как используется каждая точка в массиве *lpPoints.* Значением может быть одно из следующих.

- PT_MOVETO указывает, что этот момент начинаетразрозненную фигуру. Этот момент становится новой текущей позицией.

- PT_LINETO указывает, что линия должна быть прорисована из текущего положения до этой точки, которая затем становится новой текущей позиции.

- PT_BEZIERTO указывает, что эта точка является контрольной точкой или точкой окончания для bzier spline.

PT_BEZIERTO типов всегда встречаются в наборах по три. Текущее положение определяет отправную точку для bzier spline. Первые две PT_BEZIERTO точки являются контрольные точки, а третья PT_BEZIERTO точка – конечная точка. Конечная точка становится новой текущей позицией. Если нет трех последовательных PT_BEZIERTO очков, результаты ошибки.

   Тип PT_LINETO или PT_BEZIERTO можно комбинировать со следующей константой с помощью битового оператора или указать, что соответствующая точка является последней точкой на рисунке и цифра закрыта:

- PT_CLOSEFIGURE указывает, что фигура автоматически закрывается после PT_LINETO или типа PT_BEZIERTO для этой точки. Линия обращается от этой точки до `MoveTo` последней PT_MOVETO или точки.

   Этот флаг сочетается с PT_LINETO типом для строки, или с PT_BEZIERTO типом конечной точки для spline Bzier, используя bitwise **или** оператора. Текущее положение настроено на конечную точку линии закрытия.

*Ncount*<br/>
Определяет общее количество точек в массиве *lpPoints,* такое же, как количество байтов в массиве *lpTypes.*

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция может быть использована для рисования разрозненных фигур вместо последовательных `CDC::MoveTo`вызовов, `CDC::LineTo`и `CDC::PolyBezierTo` функции членов. Линии и сплайны нарисованы с помощью текущей ручки, а фигуры не заполняются. Если есть активный путь, начатый с вызова функции `CDC::BeginPath` члена, `PolyDraw` добавляет к пути. Точки, содержащиеся в массиве *lpPoints* и в *lpTypes,* `CDC::LineTo`указывают, `CDC::BezierTo` является ли каждая точка частью `CDC::MoveTo`операции, a , или операции. Также можно закрыть цифры. Эта функция обновляет текущее положение.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::BeginPath](#beginpath).

## <a name="cdcpolygon"></a><a name="polygon"></a>CDC::Polygon

Рисует полигон, состоящий из двух или более точек (вертиков), соединенных линиями, используя текущую ручку.

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив точек, которые определяют вершины полигона. Каждая точка в `POINT` массиве `CPoint` представляет собой структуру или объект.

*Ncount*<br/>
Определяет количество головорающих в массиве.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Система закрывает полигон автоматически, при необходимости, рисуя линию от последней вершины до первой.

Текущий режим заполнения полигона можно извлечь или установить `SetPolyFillMode` с помощью функций и функций `GetPolyFillMode` члена.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

## <a name="cdcpolyline"></a><a name="polyline"></a>CDC::Polyline

Рисует набор сегментов линий, соединяющих точки, указанные *lpPoints.*

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив `POINT` структур `CPoint` или объектов, которые должны быть подключены.

*Ncount*<br/>
Определяет количество точек в массиве. Это значение должно быть не менее 2.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Линии нарисованы от первой точки до последующих точек с помощью текущего пера. В `LineTo` отличие от `Polyline` функции члена, функция не использует и не обновляет текущее положение.

Для получения дополнительной [PolyLine](/windows/win32/api/wingdi/nf-wingdi-polyline) информации см.

## <a name="cdcpolylineto"></a><a name="polylineto"></a>CDC::PolylineTo

Рисует одну или несколько прямых линий.

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив структур данных [POINT,](/windows/win32/api/windef/ns-windef-point) содержащий вершины линии.

*Ncount*<br/>
Определяет количество точек в массиве.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Линия нарисована от текущего положения к первой точке, указанной параметром *lpPoints* с помощью текущей ручки. Для каждой дополнительной строки функция рисует от конечной точки предыдущей строки к следующей точке, указанной *lpPoints.* `PolylineTo`перемещает текущее положение в конечную точку последней строки. Если сегменты линии, нарисованные этой функцией, образуют закрытую фигуру, фигура не заполняется.

## <a name="cdcpolypolygon"></a><a name="polypolygon"></a>CDC: :PolyPolygon

Создает два или более полигонов, которые заполняются с помощью текущего режима заполнения полигона.

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив `POINT` структур `CPoint` или объектов, определяющих вершины полигонов.

*lpPolyCounts*<br/>
Указывает на массив целых рядов, каждый из которых определяет количество точек в одном из полигонов в массиве *lpPoints.*

*Ncount*<br/>
Количество записей в массиве *lpPolyCounts.* Это число определяет количество полигонов, которые будут нарисованы. Это значение должно быть не менее 2.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Полигоны могут быть разрозненными или перекрывающимися.

Каждый полигон, указанный в `PolyPolygon` вызове к функции, должен быть закрыт. В отличие от полигонов, созданных функцией `Polygon` члена, `PolyPolygon` созданные полигонами не закрываются автоматически.

Функция создает два или более полигонов. Для создания единого полигона приложение должно `Polygon` использовать функцию члена.

Текущий режим заполнения полигона можно извлечь или установить `SetPolyFillMode` с помощью функций и функций `GetPolyFillMode` члена.

## <a name="cdcpolypolyline"></a><a name="polypolyline"></a>CDC::PolyPolyline

Рисует несколько серий связанных сегментов линий.

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>Параметры

*lpPoints*<br/>
Указывает на массив структур, содержащих вершины полилиней. Полилини указывается последовательно.

*lpPolyPoints*<br/>
Указывает на массив переменных, определяющих количество точек в массиве *lpPoints* для соответствующего полигона. Каждая запись должна быть больше или равна 2.

*Ncount*<br/>
Определяет общее количество пунктов в массиве *lpPolyPoints.*

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Сегменты линий нарисованы с помощью текущего пера. Цифры, сформированные сегментами, не заполняются. Текущее положение не используется и не обновляется этой функцией.

## <a name="cdcptvisible"></a><a name="ptvisible"></a>CDC::P

Определяет, находится ли заданная точка в области отсечения контекста устройства.

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию точки.

*Y*<br/>
Определяет логическую y-координацию точки.

*Точки*<br/>
Определяет точку для проверки логических координат. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если указанная точка находится в пределах области отсечения; в противном случае 0.

## <a name="cdcqueryabort"></a><a name="queryabort"></a>CDC::Квиаборт

Вызывает функцию прерывания, установленную функцией члена [SetAbortProc](#setabortproc) для приложения печати, и запрашивает, следует ли прекратить печать.

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение возврата неявляется, если печать должна продолжаться или если нет процедуры прерывания. Это 0, если задание печати должно быть прекращено. Значение возврата обеспечивается функцией прерывания.

## <a name="cdcrealizepalette"></a><a name="realizepalette"></a>CDC::RealizePalette

Карты записей из текущей логической палитры в системную палитру.

```
UINT RealizePalette();
```

### <a name="return-value"></a>Возвращаемое значение

Указывает, сколько записей в логической палитре было отображено на разных входах в палитре системы. Это представляет собой количество записей, которые эта функция remapped для размещения изменений в палитре системы, поскольку логическая палитра была в последний раз реализована.

### <a name="remarks"></a>Remarks

Логическая цветовая палитра выступает в качестве буфера между цветоем-интенсивных приложений и системы, что позволяет приложению использовать столько цветов, сколько необходимо, не мешая своим собственным отображаемым цветам или цветам, отображаемым другими окнами.

Когда окно имеет фокус ввода `RealizePalette`и вызовы, Windows гарантирует, что окно будет отображать все запрошенные цвета, до максимального числа одновременно доступны на экране. Windows также отображает цвета, не найденные в палитре окна, сопоставляя их с доступными цветами.

Кроме того, Windows соответствует цветам, запрошенным неактивными окнами, которые вызывают функцию как можно ближе к имеющимся цветам. Это значительно уменьшает нежелательные изменения цветов, отображаемых в неактивных окнах.

## <a name="cdcrectangle"></a><a name="rectangle"></a>CDC::Rectangle

Рисует прямоугольник с помощью текущего пера.

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет x-координат верхнего левого угла прямоугольника (в логических единицах).

*y1*<br/>
Определяет y-координат верхнего левого угла прямоугольника (в логических единицах).

*x2*<br/>
Определяет x-координат в нижнем правом углу прямоугольника (в логических единицах).

*y2*<br/>
Определяет y-координат нижнего правого угла прямоугольника (в логических единицах).

*lpRect*<br/>
Определяет прямоугольник в логических единицах. Вы можете передать `CRect` либо объект, либо `RECT` указатель на структуру для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Интерьер прямоугольника заполняется с помощью текущей кисти.

Прямоугольник простирается до, но не включает в себя правые и нижние координаты. Это означает, что высота прямоугольника *y2* - *y1,* а ширина прямоугольника *x2* - *x1.* И ширина, и высота прямоугольника должны быть больше 2 единиц и менее 32 767 единиц.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

## <a name="cdcrectvisible"></a><a name="rectvisible"></a>CDC::RectVisible

Определяет, находится ли какая-либо часть данного прямоугольника в области отсечения контекста дисплея.

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>Параметры

*lpRect*<br/>
Указывает на `RECT` структуру `CRect` или объект, содержащий логические координаты указанного прямоугольника.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если какая-либо часть данного прямоугольника находится в пределах области отсечения; в противном случае 0.

## <a name="cdcreleaseattribdc"></a><a name="releaseattribdc"></a>CDC::ReleaseAttribDC

Вызовите эту `m_hAttribDC` функцию участника, чтобы установить на NULL.

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>Remarks

Это не приводит `Detach` к возникновению. К объекту `CDC` прикрепляется только контекст выходного устройства, и только его можно отсоединить.

## <a name="cdcreleaseoutputdc"></a><a name="releaseoutputdc"></a>CDC::ReleaseOutputDC

Вызовите эту функцию участника, чтобы установить `m_hDC` участника в NULL.

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>Remarks

Эта функция элемента не может быть вызвана `CDC` при подключении контекста вывода устройства к объекту. Используйте `Detach` функцию члена для отсоединения контекста выходного устройства.

## <a name="cdcresetdc"></a><a name="resetdc"></a>CDC:ResetDC

Вызов ифункции этого элемента для `CDC` обновления контекста устройства, обернутого объектом.

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>Параметры

*lpDevMode*<br/>
Указатель на структуру Windows. `DEVMODE`

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Контекст устройства обновляется из информации, `DEVMODE` указанной в структуре Windows. Функция этого элемента только сбрасывает контекст устройства атрибутов.

Приложение обычно использует `ResetDC` функцию элемента, `WM_DEVMODECHANGE` когда окно обрабатывает сообщение. Вы также можете использовать эту функцию члена для изменения бумажной ориентации или бумажных ячеек при печати документа.

Вы не можете использовать эту функцию пользователя для изменения имени драйвера, имени устройства или выходного порта. При изменении пользователем соединения порта или имени устройства необходимо удалить исходный контекст устройства и создать новый контекст устройства с новой информацией.

Прежде чем вызвать эту функцию участника, необходимо убедиться, что все объекты (кроме фондовых объектов), которые были выбраны в контексте устройства, были выбраны.

## <a name="cdcrestoredc"></a><a name="restoredc"></a>CDC::RestoreDC

Восстановление контекста устройства в предыдущем состоянии, идентифицированном *nSavedDC.*

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>Параметры

*nSavedDC*<br/>
Определяет контекст устройства, который будет восстановлен. Это может быть значение, `SaveDC` возвращенное предыдущим вызовом функции. Если *nSavedDC* -1, последний сохраненный контекст устройства восстанавливается.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если указанный контекст был восстановлен; в противном случае 0.

### <a name="remarks"></a>Remarks

`RestoreDC`восстанавливает контекст устройства, выталкивая информацию о состоянии `SaveDC` из стека, созданного более ранними вызовами в функцию элемента.

Стек может содержать информацию о состоянии для нескольких контекстов устройства. Если контекст, указанный *nSavedDC,* не находится `RestoreDC` в верхней части стека, удаляет всю информацию о состоянии между контекстом устройства, указанным *nSavedDC,* и верхней частью стека. Удаленная информация утеряна.

## <a name="cdcroundrect"></a><a name="roundrect"></a>CDC::RoundRect

Рисует прямоугольник с закругленными углами с помощью текущего пера.

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>Параметры

*x1*<br/>
Определяет x-координат верхнего левого угла прямоугольника (в логических единицах).

*y1*<br/>
Определяет y-координат верхнего левого угла прямоугольника (в логических единицах).

*x2*<br/>
Определяет x-координат в нижнем правом углу прямоугольника (в логических единицах).

*y2*<br/>
Определяет y-координат нижнего правого угла прямоугольника (в логических единицах).

*x3*<br/>
Определяет ширину эллипса, используемого для рисования закругленных углов (в логических единицах).

*y3*<br/>
Определяет высоту эллипса, используемого для рисования закругленных углов (в логических единицах).

*lpRect*<br/>
Определяет ограничивающий прямоугольник в логических единицах. Вы можете передать `CRect` либо объект, либо `RECT` указатель на структуру для этого параметра.

*Точки*<br/>
X-координаты *точки* определяют ширину эллипса для рисования закругленных углов (в логических единицах). Y-координаты *точки* определяют высоту эллипса для рисования закругленных углов (в логических единицах). Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Интерьер прямоугольника заполняется с помощью текущей кисти.

Фигура, нарисуемых этой функцией, простирается до, но не включает правые и нижние координаты. Это означает, что высота фигуры *y2* - *y1* и ширина фигуры *x2* - *x1.* Высота и ширина связующего прямоугольника должны быть больше 2 единиц и менее 32 767 единиц.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

## <a name="cdcsavedc"></a><a name="savedc"></a>CDC::SaveDC

Сохраняет текущее состояние контекста устройства путем копирования информации о состоянии (например, области отсечения, выбранных объектов и режима отображения) в стек контекста, поддерживаемый Windows.

```
virtual int SaveDC();
```

### <a name="return-value"></a>Возвращаемое значение

Цель, идентифицирующая контекст сохраненного устройства. Это 0, если происходит ошибка. Это значение возврата может быть использовано `RestoreDC`для восстановления контекста устройства, вызывая.

### <a name="remarks"></a>Remarks

Сохраненный контекст устройства позже `RestoreDC`может быть восстановлен с помощью .

`SaveDC`может использоваться любое количество раз, чтобы сохранить любое количество состояния устройства-контекста.

## <a name="cdcscaleviewportext"></a><a name="scaleviewportext"></a>CDC::ScaleViewportExt

Изменяет размеры порта представления относительно текущих значений.

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Параметры

*xНум*<br/>
Определяет сумму, на которую можно умножить текущий x-extent.

*xDenom*<br/>
Определяет сумму, на которую можно разделить результат умножения текущего x-extent на значение параметра *xNum.*

*yNum*<br/>
Определяет сумму, на которую можно умножить текущий y-extent.

*yDenom*<br/>
Определяет сумму, на которую можно разделить результат умножения текущего y-extent на значение параметра *yNum.*

### <a name="return-value"></a>Возвращаемое значение

Предыдущие степени представления (в единицах устройства) как `CSize` объект.

### <a name="remarks"></a>Remarks

Формулы написаны следующим образом:

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

Новые размеры порта представления рассчитываются путем умножения текущих размеров на данный числитель, а затем деления на данный знаменатель.

## <a name="cdcscalewindowext"></a><a name="scalewindowext"></a>CDC::ScaleWindowExt

Изменяет размеры окна относительно текущих значений.

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>Параметры

*xНум*<br/>
Определяет сумму, на которую можно умножить текущий x-extent.

*xDenom*<br/>
Определяет сумму, на которую можно разделить результат умножения текущего x-extent на значение параметра *xNum.*

*yNum*<br/>
Определяет сумму, на которую можно умножить текущий y-extent.

*yDenom*<br/>
Определяет сумму, на которую можно разделить результат умножения текущего y-extent на значение параметра *yNum.*

### <a name="return-value"></a>Возвращаемое значение

Предыдущие размеры окна (в логических `CSize` единицах) как объект.

### <a name="remarks"></a>Remarks

Формулы написаны следующим образом:

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

Новые размеры окон рассчитываются путем умножения текущих размеров на данный числитель, а затем деления на данный знаменатель.

## <a name="cdcscrolldc"></a><a name="scrolldc"></a>CDC::ScrollDC

Прокрутите прямоугольник битов горизонтально и вертикально.

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>Параметры

*dx*<br/>
Определяет количество горизонтальных единиц прокрутки.

*Dy*<br/>
Определяет количество вертикальных единиц прокрутки.

*lpRectScroll*<br/>
Указывает на `RECT` структуру или `CRect` объект, содержащий координаты прямоугольника прокрутки.

*lpRectClip*<br/>
Указывает на `RECT` структуру или `CRect` объект, содержащий координаты прямоугольника отсечения. Когда этот прямоугольник меньше, чем оригинальный, на который указывает *lpRectScroll,* прокрутка происходит только в меньшем прямоугольнике.

*pRgnUpdate*<br/>
Идентифицирует область, обнаруженную в процессе прокрутки. Функция `ScrollDC` определяет этот регион; это не обязательно прямоугольник.

*lpRectUpdate*<br/>
Указывает на `RECT` структуру или `CRect` объект, который получает координаты прямоугольника, который граничит с областью обновления прокрутки. Это самая большая прямоугольная область, которая требует перекрашивания. Значения в структуре или объекте при возврате функции находятся в координатах клиента, независимо от режима отображения для данного контекста устройства.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если прокрутка выполняется; в противном случае 0.

### <a name="remarks"></a>Remarks

Если *lpRectUpdate* является NULL, Windows не вычисляет прямоугольник обновления. Если *и pRgnUpdate,* и *lpRectUpdate* являются NULL, Windows не вычисляет область обновления. Если *pRgnUpdate* не является NULL, Windows предполагает, что он содержит действительный указатель на `ScrollDC` область, обнаруженную процессом прокрутки (определяемого функцией участника). Область обновления, возвращенная в *lpRectUpdate,* может быть передана `CWnd::InvalidateRgn` при необходимости.

Приложение должно использовать `ScrollWindow` функцию `CWnd` элемента класса, когда необходимо прокрутить всю область клиента окна. В противном `ScrollDC`случае, он должен использовать .

## <a name="cdcselectclippath"></a><a name="selectclippath"></a>CDC:SelectClipPath

Выбрав текущий путь в качестве области отсечения для контекста устройства, объединив новый регион с любым существующим регионом отсечения с помощью заданного режима.

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>Параметры

*nMode*<br/>
Определяет способ использования пути. Разрешены следующие значения:

- RGN_AND Новая область отсечения включает в себя пересечение (перекрывающихся областей) текущего региона отсечения и текущего пути.

- RGN_COPY Новая область отсечения — это текущий путь.

- RGN_DIFF Новая область отсечения включает в себя области текущего региона отсечения, а области текущего пути исключены.

- RGN_OR Новый регион отсечения включает в себя союз (комбинированные области) текущего региона отсечения и текущий путь.

- RGN_XOR Новая область отсечения включает в себя объединение текущего региона отсечения и текущего пути, но без перекрывающихся областей.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Идентифицированный контекст устройства должен содержать закрытый путь.

## <a name="cdcselectcliprgn"></a><a name="selectcliprgn"></a>CDC:SelectClipRgn

Выбрано данный регион в качестве текущего региона отсечения для контекста устройства.

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>Параметры

*pRgn*<br/>
Определяет выбранный регион.

- Для первой версии этой функции, если это значение NULL, выбрана вся область клиента и выход по-прежнему прикрепляется к окну.

- Для второй версии этой функции эта ручка может быть NULL только при указании RGN_COPY режима.

*nMode*<br/>
Указывает операцию для выполнения. Это должно быть одно из следующих значений:

- RGN_AND Новая область отсечения сочетает в себе перекрывающиеся области текущего региона отсечения и область, идентифицированную *pRgn.*

- RGN_COPY Новая область отсечения является копией региона, идентифицированного *pRgn*. Эта функциональность идентична первой `SelectClipRgn`версии . Если область, идентифицированная *pRgn,* является NULL, новый регион отсечения становится областью отсечения по умолчанию (нулевый регион).

- RGN_DIFF Новая область отсечения сочетает в себе области текущего региона отсечения с теми областями, которые исключены из региона, определенных *pRgn*.

- RGN_OR Новая область отсечения сочетает в себе текущую область отсечения и область, идентифицированную *pRgn.*

- RGN_XOR Новая область отсечения сочетает в себе текущую область отсечения и область, определенную *pRgn,* но исключает любые перекрывающиеся области.

### <a name="return-value"></a>Возвращаемое значение

Тип региона. В качестве такой точки может выступать любой из следующих вариантов:

- COMPLEXREGION Новая область отсечения имеет перекрывающиеся границы.

- Контекст устройства ERROR или область недействительна.

- НОВА область отсечения NULLREGION пуста.

- SIMPLEREGION Новая область отсечения не имеет перекрывающихся границ.

### <a name="remarks"></a>Remarks

Используется только копия выбранного региона. Сам регион может быть выбран для любого количества других контекстов устройства, или он может быть удален.

Функция предполагает, что координаты данного региона указаны в единицах устройства. Некоторые устройства принтера поддерживают вывод текста с более высоким разрешением, чем графический вывод, чтобы сохранить точность, необходимую для выражения текстовых метрик. Эти устройства сообщают об устройствах с более высоким разрешением, т.е. в текстовых единицах. Эти устройства затем масштабируют координаты для графики так, что несколько единиц устройства карта только 1 графический блок. Вы всегда должны `SelectClipRgn` вызвать функцию с помощью текстовых единиц.

Приложения, которые должны принимать масштабирование графических объектов в GDI может использовать принтер GETSCALINGFACTOR избежать, чтобы определить фактор масштабирования. Этот фактор масштабирования влияет на отсечение. Если область используется для обжигания графики, GDI делит координаты по фактору масштабирования. Если область используется для обжига текста, GDI не делает корректировку масштабирования. Коэффициент масштабирования 1 приводит к разделению координат на 2; коэффициент масштабирования 2 приводит к разделению координат на 4; и так далее.

## <a name="cdcselectobject"></a><a name="selectobject"></a>CDC:SelectObject

Выберите объект в контекст устройства.

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>Параметры

*pPen*<br/>
Указатель на выбранный объект [CPen.](../../mfc/reference/cpen-class.md)

*pBrush*<br/>
Указатель на выбранный объект [CBrush.](../../mfc/reference/cbrush-class.md)

*pFont*<br/>
Указатель на выбранный объект [CFont.](../../mfc/reference/cfont-class.md)

*pBitmap*<br/>
Указатель на выбранный объект [CBitmap.](../../mfc/reference/cbitmap-class.md)

*pRgn*<br/>
Указатель на выбранный объект [CRgn.](../../mfc/reference/crgn-class.md)

*pObject*<br/>
Указатель на выбранный объект [CGdiObject.](../../mfc/reference/cgdiobject-class.md)

### <a name="return-value"></a>Возвращаемое значение

Указатель на заменяемый объект. Это указатель на объект одного из классов, `CGdiObject`полученных `CPen`из, таких как , в зависимости от того, какая версия функции используется. Значение возврата NULL при наличии ошибки. Эта функция может вернуть указатель на временный объект. Этот временный объект действителен только при обработке одного сообщения Windows. Для получения дополнительной информации см. `CGdiObject::FromHandle`.

Версия функции члена, которая выполняет параметр региона, `SelectClipRgn` выполняет ту же задачу, что и функция члена. Его значение возврата может быть любым из следующих:

- COMPLEXREGION Новая область отсечения имеет перекрывающиеся границы.

- Контекст устройства ERROR или область недействительна.

- НОВА область отсечения NULLREGION пуста.

- SIMPLEREGION Новая область отсечения не имеет перекрывающихся границ.

### <a name="remarks"></a>Remarks

Класс `CDC` предоставляет пять версий, специализирующихся на определенных видах GDI-объектов, включая ручки, кисти, шрифты, бит-карты и регионы. Нововыбранный объект заменяет предыдущий объект того же типа. Например, если *pObject* общей `SelectObject` версии указывает на объект [CPen,](../../mfc/reference/cpen-class.md) функция заменяет текущую ручку пером, указанным *pObject.*

Приложение может выбрать битовую карту только в контекстах устройства памяти и только в одном контексте устройства памяти за один раз. Формат бит-карты должен быть монохромным или совместимым с контекстом устройства; если это не `SelectObject` так, возвращает ошибку.

Для Windows 3.1 и `SelectObject` более поздней функции возвращается то же значение независимо от того, используется она в метафайле или нет. В предыдущих версиях Windows, `SelectObject` вернулся ненулевое значение для успеха и 0 для отказа, когда он был использован в метафайле.

## <a name="cdcselectpalette"></a><a name="selectpalette"></a>CDC::SelectPalette

Выбирает логическую палитру, указанную *pPalette* в качестве выбранного объекта палитры контекста устройства.

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>Параметры

*pPalette*<br/>
Определяет логическую палитру, которая будет выбрана. Эта палитра должна быть `CPalette` уже создана с функцией члена [CreatePalette.](../../mfc/reference/cpalette-class.md#createpalette)

*bForceBackground*<br/>
Уточняется, является ли логическая палитра вынужденной быть фоновой палитрой. Если *bForceBackground* является ненулевой, выбранная палитра всегда является фоновой палитрой, независимо от того, имеет ли окно входная направленность. Если *bForceBackground* равен 0 и контекст устройства присоединен к окну, логическая палитра представляет собой палитру переднего плана, когда окно имеет фокус ввода.

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CPalette` объект, определяющий логическую палитру, заменяемый палитрой, указанной *pPalette.* Это NULL, если есть ошибка.

### <a name="remarks"></a>Remarks

Новая палитра становится объектом палитры, используемым GDI для управления цветами, отображаемыми в контексте устройства, и заменяет предыдущую палитру.

Приложение может выбрать логическую палитру в контексте более чем одного устройства. Однако изменения в логической палитре коснутся всех контекстов устройства, для которых оно выбрано. Если приложение выбирает палитру в контексте более чем одного устройства, контексты устройства должны принадлежать одному физическому устройству.

## <a name="cdcselectstockobject"></a><a name="selectstockobject"></a>CDC:SelectStockObject

Выбирает объект [CGdiObject,](../../mfc/reference/cgdiobject-class.md) который соответствует одной из предопределенных стоковых ручек, кистей или шрифтов.

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>Параметры

*Nindex*<br/>
Определяет вид желаемого акционерного объекта. Может иметь одно из следующих значений.

- BLACK_BRUSH Черная кисть.

- DKGRAY_BRUSH темно-серая кисть.

- GRAY_BRUSH серая кисть.

- HOLLOW_BRUSH полая кисть.

- LTGRAY_BRUSH светло-серая кисть.

- NULL_BRUSH щетка Null.

- WHITE_BRUSH белая кисть.

- BLACK_PEN черная ручка.

- NULL_PEN нулевая ручка.

- WHITE_PEN белая ручка.

- ANSI_FIXED_FONT шрифтом anSI с фиксированной системой.

- ANSI_VAR_FONT шрифтпеременпеременной системы ANSI.

- DEVICE_DEFAULT_FONT зависимый от устройств шрифт.

- OEM_FIXED_FONT OEM-зависимый фиксированный шрифт.

- SYSTEM_FONT системный шрифт. По умолчанию Windows использует системный шрифт для рисования меню, элементов управления диалоговой коробкой и другого текста. Лучше, однако, не полагаться на SYSTEM_FONT для получения шрифта, используемого диалогами и окнами. Вместо этого `SystemParametersInfo` используйте функцию с параметром SPI_GETNONCLIENTMETRICS для извлечения текущего шрифта. `SystemParametersInfo`учитывает текущую тему и предоставляет информацию о шрифтах для заголовков, меню и диалогов сообщений.

- SYSTEM_FIXED_FONT Шрифт системы с фиксированной шириной, используемый в Windows до версии 3.0. Этот объект доступен для совместимости с более ранними версиями Windows.

- DEFAULT_PALETTE цветовая палитра по умолчанию. Эта палитра состоит из 20 статических цветов в системной палитре.

### <a name="return-value"></a>Возвращаемое значение

Указатель на `CGdiObject` объект, который был заменен, если функция успешна. Фактический объект указал на [CPen](../../mfc/reference/cpen-class.md), [CBrush](../../mfc/reference/cbrush-class.md), или [CFont](../../mfc/reference/cfont-class.md) объекта. Если вызов не выполнен, значение возврата является NULL.

## <a name="cdcsetabortproc"></a><a name="setabortproc"></a>CDC::SetAbortProc

Устанавливает процедуру прерывания для выполнения задания печати.

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>Параметры

*lpfn*<br/>
Указатель на функцию прерывания для установки в качестве процедуры прерывания. Для получения дополнительной информации о функции обратного вызова, [см. Функция обратного вызова для CDC::SetAbortProc](callback-functions-used-by-mfc.md#setabortproc).

### <a name="return-value"></a>Возвращаемое значение

Определяет результат функции. `SetAbortProc` Некоторые из следующих значений более вероятны, чем другие, но все возможны.

- SP_ERROR общая ошибка.

- SP_OUTOFDISK недостаточное пространство диска в настоящее время доступно для spooling, и больше не будет доступно пространство.

- SP_OUTOFMEMORY Недостаточно памяти доступно для spooling.

- SP_USERABORT пользователь закончил работу через менеджера печати.

### <a name="remarks"></a>Remarks

Если приложение позволяет отменить задание печати во время spooling, оно должно установить функцию прерывания до начала выполнения задания печати с функцией участника [StartDoc.](#startdoc) Менеджер печати вызывает функцию прерывания во время spooling, чтобы позволить приложению отменить задание печати или обработать условия вне дискового пространства. Если функция прерывания не установлена, задание печати выйдет из строя, если не будет достаточно дискового пространства для спулинга.

Обратите внимание, что функции Microsoft Visual C' упрощают `SetAbortProc`создание функции обратного вызова, передаваемые. Адрес, передаваемый функции `EnumObjects` члена, является `__declspec(dllexport)` указателем `__stdcall` на функцию, экспортируемую с и с вызывающей конвенцией.

Вам также не нужно экспортировать имя функции в выписке **EXPORTS** в файле определения модуля приложения. Вместо этого можно использовать модификатор функции **EXPORT,** как в

**БУЛ ОБРАТНЫЙ ВОЗВРАТ ЭКСПОРТА** AFunction **(HDC**, `int` **);**

заставить компилятор излучать надлежащий экспортный рекорд для экспорта по имени без псевдонима. Это работает для большинства потребностей. В некоторых особых случаях, таких как экспорт функции по или псевдониму экспорта, все равно необходимо использовать заявление **EXPORTS** в файле определения модуля.

Интерфейсы регистрации обратных вызовов теперь безопасны для типов (вы должны пройти в указатель функции, который указывает на правильный вид функции для конкретного обратного вызова).

Также обратите внимание, что все функции обратного вызова должны заманивать исключения Фонда Майкрософт в ловушку перед возвращением в Windows, так как исключения не могут быть брошены через границы обратного вызова. Для получения дополнительной информации об [Exceptions](../../mfc/exception-handling-in-mfc.md)исключениях см.

## <a name="cdcsetarcdirection"></a><a name="setarcdirection"></a>CDC:SetArcDirection

Устанавливает направление чертежа, используемое для функций дуги и прямоугольника.

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>Параметры

*nArcDirection*<br/>
Определяет новое направление дуги. Этот параметр может быть одним из следующих значений:

- AD_COUNTERCLOCKWISE цифры, нарисованные против часовой стрелки.

- AD_CLOCKWISE фигуры, нарисованные по часовой стрелке.

### <a name="return-value"></a>Возвращаемое значение

Определяет старое направление дуги, в случае успеха; в противном случае 0.

### <a name="remarks"></a>Remarks

Направление по умолчанию против часовой стрелки. Функция `SetArcDirection` определяет направление, в котором притягиваются следующие функции:

|Arc|круговая диаграмма;|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

## <a name="cdcsetattribdc"></a><a name="setattribdc"></a>CDC::SetAttribDC

Вызовите эту функцию, `m_hAttribDC`чтобы установить контекст атрибута устройства, .

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>Параметры

*Hdc*<br/>
Контекст устройства Windows.

### <a name="remarks"></a>Remarks

Эта функция элемента не прикрепляет контекст устройства к объекту. `CDC` К объекту `CDC` прикрепляется только контекст выходного устройства.

## <a name="cdcsetbkcolor"></a><a name="setbkcolor"></a>CDC::SetBkColor

Устанавливает текущий цвет фона к указанному цвету.

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>Параметры

*crColor*<br/>
Определяет новый цвет фона.

### <a name="return-value"></a>Возвращаемое значение

Предыдущий цвет фона как значение цвета RGB. При возникновении ошибки значение возврата составляет 0x8000000000.

### <a name="remarks"></a>Remarks

Если фоновым режимом является ОПАЗЗуэ, система использует цвет фона для заполнения пробелов в стиле линий, пробелов между вылупимыми линиями в кисти, и фоном в ячейках символов. Система также использует цвет фона при преобразовании бит-карт между цветными и монохромными контекстами устройства.

Если устройство не может отобразить указанный цвет, система устанавливает цвет фона до ближайшего физического цвета.

## <a name="cdcsetbkmode"></a><a name="setbkmode"></a>CDC::SetBkMode

Устанавливает фоновый режим.

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>Параметры

*nBkMode*<br/>
Определяет режим, который будет установлен. Этот параметр может быть одним из следующих значений:

- Фон OPA-E'E заполнен текущим цветом фона до того, как нарисована текстовая кисть или ручка. Это фоновый режим по умолчанию.

- ТРАНСГИСТИВ фон не изменяется перед рисованием.

### <a name="return-value"></a>Возвращаемое значение

Предыдущий фоновый режим.

### <a name="remarks"></a>Remarks

Фоновый режим определяет, удаляет ли система существующие фоновые цвета на поверхности чертежа перед рисованием текста, вылупившихся кистей или любой стиль пера, который не является сплошной линией.

### <a name="example"></a>Пример

  Смотрите пример [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsetboundsrect"></a><a name="setboundsrect"></a>CDC::SetBoundsRect

Контролирует накопление информации о границах прямоугольника для указанного контекста устройства.

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>Параметры

*lpRectBounds*<br/>
Указывает на `RECT` структуру или `CRect` объект, который используется для установки прямоугольника. Размеры прямоугольника приведены в логических координатах. Этот параметр может быть NULL.

*Флаги*<br/>
Определяет, как новый прямоугольник будет сочетаться с накопленным прямоугольником. Этот параметр может быть комбинацией следующих значений:

- DCB_ACCUMULATE Добавить прямоугольник, указанный *lpRectBounds,* к связующего прямоугольнику (с помощью прямоугольника-соединения).

- DCB_DISABLE выключить накопление границ.

- DCB_ENABLE включите накопление границ. (Настройка по умолчанию для накопления границ отключена.)

### <a name="return-value"></a>Возвращаемое значение

Текущее состояние связующего прямоугольника, если функция успешна. Как *и флаги,* значение возврата может быть сочетанием **DCB_** значений:

- DCB_ACCUMULATE прямоугольник не пуст. Это значение всегда будет установлено.

- DCB_DISABLE накопление границ выключено.

- DCB_ENABLE накопление границ.

### <a name="remarks"></a>Remarks

Windows может поддерживать прямоугольник для всех операций рисования. Этот прямоугольник может быть запрошен и сдан приложением. Границы чертежа полезны для недействительных кэшов битовой карты.

## <a name="cdcsetbrushorg"></a><a name="setbrushorg"></a>CDC::SetBrushOrg

Определяет происхождение, которое GDI назначит следующей кисти, выбранной приложением в контексте устройства.

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет X-координат (в единицах устройства) нового происхождения. Это значение должно быть в диапазоне 0-7.

*Y*<br/>
Определяет y-координацию (в единицах устройства) нового происхождения. Это значение должно быть в диапазоне 0-7.

*Точки*<br/>
Определяет x- и y-координаты нового происхождения. Каждое значение должно быть в диапазоне 0-7. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Предыдущее происхождение кисти в блоках устройств.

### <a name="remarks"></a>Remarks

Координаты по умолчанию для происхождения кисти (0, 0). Чтобы изменить происхождение кисти, `UnrealizeObject` позвоните `CBrush` функции `SetBrushOrg`для объекта, `SelectObject` вызов, а затем вызвать функцию члена, чтобы выбрать кисть в контексте устройства.

Не используйте `SetBrushOrg` `CBrush` с фондовыми объектами.

## <a name="cdcsetcoloradjustment"></a><a name="setcoloradjustment"></a>CDC::SetColorAdjustment

Устанавливает значения регулировки цвета для контекста устройства с помощью указанных значений.

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>Параметры

*lpColorAdjust*<br/>
Указывает на структуру данных [COLORADJUSTMENT,](/windows/win32/api/wingdi/ns-wingdi-coloradjustment) содержащую значения регулировки цвета.

### <a name="return-value"></a>Возвращаемое значение

Имеет ненулевое значение в случае успешного выполнения, иначе — 0.

### <a name="remarks"></a>Remarks

Значения регулировки цвета используются для регулировки входного `CDC::StretchBlt` цвета исходной битовой карты для вызовов функции члена при установке режима HALFTONE.

## <a name="cdcsetdcbrushcolor"></a><a name="setdcbrushcolor"></a>CDC::SetDCBrushColor

Устанавливает текущий контекст устройства (DC) цвет кисти к заданной цветовой стоимости.

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>Параметры

*crColor*<br/>
Определяет новый цвет кисти.

### <a name="return-value"></a>Возвращаемое значение

Если функция успешно, значение возврата определяет предыдущий цвет кисти DC как значение COLORREF.

Если функция выполняется неудачно, возвращается значение CLR_INVALID.

### <a name="remarks"></a>Remarks

Этот метод эмулирует функциональность функции [SetDCBrushColor](/windows/win32/api/wingdi/nf-wingdi-setdcbrushcolor), как описано в Windows SDK.

## <a name="cdcsetdcpencolor"></a><a name="setdcpencolor"></a>CDC::SetDCPenColor

Устанавливает текущий цвет пера контекста устройства (DC) к заданной цветовой стоимости.

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>Параметры

*crColor*<br/>
Определяет новый цвет пера.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция члена использует функцию Win32 [SetDCPenColor](/windows/win32/api/wingdi/nf-wingdi-setdcpencolor), как описано в Windows SDK.

## <a name="cdcsetgraphicsmode"></a><a name="setgraphicsmode"></a>CDC::SetGraphicsMode

Устанавливает графический режим для заданного контекста устройства.

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>Параметры

*iMode*<br/>
Определяет графический режим. Список значений, которые может принять этот параметр, [можно](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)см.

### <a name="return-value"></a>Возвращаемое значение

Возвращает старый графический режим на успех.

Возвращает 0 при сбое. Чтобы получить расширенную информацию об ошибке, позвоните [getLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Remarks

Этот метод обертывает функцию Windows GDI [SetGraphicsMode.](/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode)

## <a name="cdcsetlayout"></a><a name="setlayout"></a>CDC::SetLayout

Назовите эту функцию участника, чтобы изменить расположение текста и графики для контекста устройства справа налево, стандартная компоновка для таких культур, как арабский и иврит.

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>Параметры

*dwLayout*<br/>
Расположение контекста устройства и флаги управления биткартой. Это может быть сочетание следующих значений.

|Значение|Значение|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|Отменяет любое отражение для звонков в [CDC::BitBlt](#bitblt) и [CDC::StretchBlt](#stretchblt).|
|LAYOUT_RTL|Устанавливает горизонтальный макет по умолчанию, чтобы быть справа налево.|
|LAYOUT_LTR|Устанавливает макет по умолчанию, чтобы быть слева направо.|

### <a name="return-value"></a>Возвращаемое значение

В случае успеха предыдущая компоновка контекста устройства.

Если неудача, GDI_ERROR. Чтобы получить расширенную информацию об ошибке, позвоните [getLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Remarks

Как правило, вы `SetLayout` не вызовете окно. Скорее, вы управляете макетом справа налево в окне, устанавливая [расширенные стили окон,](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles) такие как WS_EX_RTLREADING. Контекст устройства, например принтер или метафайл, не наследует эту компоновку. Единственный способ установить контекст устройства для макета справа налево — позвонить. `SetLayout`

При вызове **SetLayout (LAYOUT_RTL)** автоматически `SetLayout` изменяет режим отображения на MM_ISOTROPIC. В результате последующий вызов [в GetMapMode](#getmapmode) вернется MM_ISOTROPIC вместо MM_TEXT.

В некоторых случаях, например, во многих бит-картах, можно сохранить макет слева направо. В этих случаях, сделать `BitBlt` `StretchBlt`изображение, вызывая или , затем установить флаг управления битмейп для *dwLayout* LAYOUT_BITMAPORIENTATIONPRESERVED.

Как только вы измените макет с LAYOUT_RTL флагом, флаги обычно указывают на право или влево, отменяются. Чтобы избежать путаницы, можно определить альтернативные имена для стандартных флагов. Список предлагаемых альтернативных имен флагов можно найти в [SDK](/windows/win32/api/wingdi/nf-wingdi-setlayout) Windows.

## <a name="cdcsetmapmode"></a><a name="setmapmode"></a>CDC:SetMapMode

Устанавливает режим отображения.

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>Параметры

*nMapMode*<br/>
Определяет новый режим отображения. Это может быть любое из следующих значений:

- MM_ANISOTROPIC Логические единицы преобразуются в произвольные единицы с произвольно масштабируемыми осями. Настройка режима отображения на MM_ANISOTROPIC не изменяет настройки текущего окна или порта представления. Чтобы изменить единицы, ориентацию и масштабирование, позвоните в функции участника [SetWindowExt](#setwindowext) и [SetViewportExt.](#setviewportext)

- MM_HIENGLISH Каждая логическая единица преобразуется в 0,001 дюйма. Положительный x находится справа; положительный у вверх.

- MM_HIMETRIC Каждая логическая единица преобразуется в 0,01 миллиметра. Положительный x находится справа; положительный у вверх.

- MM_ISOTROPIC логические единицы преобразуются в произвольные единицы с одинаково масштабированными осями; то есть, 1 единица вдоль x-оси равна 1 единице вдоль y-оси. Используйте `SetWindowExt` `SetViewportExt` функции и функции участника, чтобы указать нужные единицы и ориентацию осей. GDI вносит необходимые коррективы для обеспечения того, чтобы единицы x и y оставались одинакового размера.

- MM_LOENGLISH Каждая логическая единица преобразуется в 0,01 дюйма. Положительный x находится справа; положительный у вверх.

- MM_LOMETRIC Каждая логическая единица преобразуется в 0,1 миллиметра. Положительный x находится справа; положительный у вверх.

- MM_TEXT Каждая логическая единица преобразуется в 1 пиксель устройства. Положительный x находится справа; положительный у вниз.

- MM_TWIPS Каждая логическая единица преобразуется в 1/20 точки. (Потому что точка 1/72 дюйма, twip составляет 1/1440 дюйма.) Положительный x находится справа; положительный у вверх.

### <a name="return-value"></a>Возвращаемое значение

Предыдущий режим отображения.

### <a name="remarks"></a>Remarks

Режим отображения определяет единицу измерения, используемую для преобразования логических единиц в единицы устройства; он также определяет ориентацию х- и y-осей устройства. GDI использует режим отображения для преобразования логических координат в соответствующие координаты устройства. Режим MM_TEXT позволяет приложениям работать в пикселях устройства, где 1 единица равна 1 пикселю. Физический размер пикселя варьируется от устройства к устройству.

Режимы MM_HIENGLISH, MM_HIMETRIC, MM_LOENGLISH, MM_LOMETRIC и MM_TWIPS полезны для приложений, которые должны использоваться в физически значимых единицах (например, дюймах или миллиметрах). Режим MM_ISOTROPIC обеспечивает соотношение сторон 1:1, что полезно, когда важно сохранить точную форму изображения. Режим MM_ANISOTROPIC позволяет самостоятельно корректировать x- и y-координаты.

> [!NOTE]
> Если вы называете [SetLayout](#setlayout) для изменения DC (контекст устройства) `SetLayout` на макет справа налево, автоматически изменяет режим отображения на MM_ISOTROPIC.

### <a name="example"></a>Пример

  Смотрите пример [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetmapperflags"></a><a name="setmapperflags"></a>CDC::SetMapperFlags

Изменяет метод, используемый картографом шрифта, когда он преобразует логический шрифт в физический шрифт.

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>Параметры

*dwFlag*<br/>
Уточняется, пытается ли картограф шрифта сопоставить высоту и ширину шрифта с устройством. Когда это значение ASPECT_FILTERING, картограф выбирает только шрифты, x-aspect и y-aspect точно совпадают с указанными устройствами.

### <a name="return-value"></a>Возвращаемое значение

Предыдущее значение флага шрифт-карты.

### <a name="remarks"></a>Remarks

Приложение может `SetMapperFlags` использоваться для того, чтобы заставить картографа шрифта попытаться выбрать только физический шрифт, который точно соответствует соотношению сторон указанного устройства.

Приложение, используювкоторое только растерские шрифты, может использовать `SetMapperFlags` эту функцию, чтобы гарантировать, что выбранный шрифтом картограф привлекателен и читаем на указанном устройстве. Приложения, использоваваемые масштабируемыми шрифтами (TrueType), обычно не используются. `SetMapperFlags`

Если ни один физический шрифт не имеет соотношения сторон, которое соответствует спецификации в логическом шрифте, GDI выбирает новое соотношение аспектов и выбирает шрифт, который соответствует этому новому соотношению аспектов.

## <a name="cdcsetmiterlimit"></a><a name="setmiterlimit"></a>CDC::SetMiterLimit

Устанавливает ограничение длины митера для контекста устройства.

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>Параметры

*fMiterLimit*<br/>
Укращит новый лимит митера для контекста устройства.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Длина митера определяется как расстояние от пересечения линейных стен на внутренней стороне соединения до пересечения линейных стен на внешней стороне соединения. Пределмит miter будет максимально позволенным отношением длины miter к ширине линии. Лимит митера по умолчанию составляет 10,0.

## <a name="cdcsetoutputdc"></a><a name="setoutputdc"></a>CDC::SetOutputDC

Вызов ими функции участника для `m_hDC`настройки контекста устройства вывода.

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>Параметры

*Hdc*<br/>
Контекст устройства Windows.

### <a name="remarks"></a>Remarks

Эта функция члена может быть вызвана только в том `CDC` случае, если контекст устройства не был прикреплен к объекту. Функция этого `m_hDC` элемента устанавливает, но не `CDC` прикрепляет контекст устройства к объекту.

## <a name="cdcsetpixel"></a><a name="setpixel"></a>CDC::SetPixel

Устанавливает пиксель в точке, указанной к близкому приближению цвета, указанного *crColor.*

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию установленной точки.

*Y*<br/>
Определяет логическую y-координацию точки, которая будет установлена.

*crColor*<br/>
Значение COLORREF RGB, которое определяет цвет, используемый для нарисования точки. Ознакомьтесь с описанием этого значения в [COLORREF](/windows/win32/gdi/colorref) в SDK Windows.

*Точки*<br/>
Определяет логические x- и y-координаты точки, которые необходимо установить. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Значение RGB для цвета, что точка на самом деле окрашены. Это значение может отличаться от значения, указанного *crColor,* если используется приближение этого цвета. Если функция выходит из строя (если точка находится за пределами области отсечения), значение возврата -1.

### <a name="remarks"></a>Remarks

Точка должна быть в области отсечения. Если точка находится не в области отсечения, функция ничего не делает.

Не все устройства поддерживают функцию `SetPixel`. Чтобы определить, поддерживает `SetPixel`ли `GetDeviceCaps` устройство, позвоните функции участника с индексом RASTERCAPS и проверьте значение возврата для RC_BITBLT флага.

## <a name="cdcsetpixelv"></a><a name="setpixelv"></a>CDC::SetPixelV

Устанавливает пиксель в указанных координатах к близкому приближению указанного цвета.

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет x-координацию, в логических единицах, точки, которая будет установлена.

*Y*<br/>
Определяет y-координацию, в логических единицах, точки, которая будет установлена.

*crColor*<br/>
Определяет цвет, который будет использоваться для покраски точки.

*Точки*<br/>
Определяет логические x- и y-координаты точки, которые необходимо установить. Для этого параметра можно передать либо структуру данных [POINT,](/windows/win32/api/windef/ns-windef-point) либо объект [CPoint.](../../atl-mfc-shared/reference/cpoint-class.md)

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Точка должна находиться как в области отсечения, так и в видимой части поверхности устройства. Не все устройства поддерживают функцию участника. Для получения дополнительной информации `CDC::GetDeviceCaps` см RC_BITBLT. `SetPixelV`быстрее, `SetPixel` чем потому, что ему не нужно возвращать цветовое значение точки на самом деле окрашены.

## <a name="cdcsetpolyfillmode"></a><a name="setpolyfillmode"></a>CDC::SetPolyFillMode

Устанавливает режим заполнения полигона.

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>Параметры

*nПолиФиллмомод*<br/>
Определяет новый режим заполнения. Это значение может быть либо ALTERNATE, либо WINDING. Режим по умолчанию, установленный в Windows, является ALTERNATE.

### <a name="return-value"></a>Возвращаемое значение

Предыдущий режим заполнения, в случае успеха; в противном случае 0.

### <a name="remarks"></a>Remarks

Когда режим заполнения полигона ALTERNATE, система заполняет область между нечетными и четными по счетами полигона на каждой линии сканирования. То есть система заполняет область между первой и второй стороной, между третьей и четвертой стороной и так далее. Это режим по умолчанию.

Когда режим заполнения полигона windING, система использует направление, в котором фигура была нарисована, чтобы определить, следует ли заполнить область. Каждый сегмент линии в полигоне нарисован по часовой стрелке или против часовой стрелки. Всякий раз, когда воображаемые линии, взятые из закрытой области на внешнюю сторону фигуры проходит через по часовой стрелке линии сегмента, кол увеличивается. Когда линия проходит через сегмент линии против часовой стрелки, количество decremented. Область заполняется, если количество ненулевое, когда линия достигает внешней стороны фигуры.

## <a name="cdcsetrop2"></a><a name="setrop2"></a>CDC::SetROP2

Устанавливает текущий режим рисования.

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>Параметры

*nDrawMode*<br/>
Определяет новый режим рисования. В качестве такой точки может выступать любой из следующих вариантов:

- R2_BLACK Pixel всегда черный.

- R2_WHITE Pixel всегда белый.

- R2_NOP Pixel остается неизменным.

- R2_NOT Pixel является обратным цвета экрана.

- R2_COPYPEN Pixel - это цвет пера.

- R2_NOTCOPYPEN Pixel является обратным цвета пера.

- R2_MERGEPENNOT Pixel представляет собой комбинацию цвета пера и обратного цвета экрана (окончательный пиксель (НЕ пиксель экрана) или пера).

- R2_MASKPENNOT Pixel представляет собой сочетание цветов, общих как для пера, так и для обратного экрана (окончательный пиксель (НЕ пиксель экрана) и пера).

- R2_MERGENOTPEN Pixel представляет собой сочетание цвета экрана и обратного цвета пера (окончательный пиксель (НЕ перо) или пиксел экрана).

- R2_MASKNOTPEN Pixel представляет собой сочетание цветов, общих как для экрана, так и обратного пера (окончательный пиксель (НЕ перо) и пиксел экрана).

- R2_MERGEPEN Pixel представляет собой сочетание цвета пера и цвета экрана (окончательный пиксель и перо или пиксел экрана).

- R2_NOTMERGEPEN Pixel является обратным R2_MERGEPEN цветом (окончательный пиксель НЕ (перо или пиксель экрана)).

- R2_MASKPEN Pixel представляет собой сочетание цветов, общих как для пера, так и для экрана (окончательный пиксель и пиксель экрана).

- R2_NOTMASKPEN Pixel является обратным R2_MASKPEN цветом (окончательный пиксель НЕ (перо и пиксель экрана)).

- R2_XORPEN Pixel представляет собой сочетание цветов, которые находятся в ручке или на экране, но не в обоих (окончательный пиксель и перо XOR экран пиксел).

- R2_NOTXORPEN Pixel является обратным R2_XORPEN цветом (окончательный пиксель НЕ (pen XOR экран пикселя)).

### <a name="return-value"></a>Возвращаемое значение

Предыдущий режим рисования.

Это может быть любое из значений, приведенных в Windows SDK.

### <a name="remarks"></a>Remarks

Режим рисования определяет, как цвета пера и интерьер заполненных объектов сочетаются с цветом, уже на поверхности дисплея.

Режим чертежа предназначен только для устройств raster; он не применяется к векторные устройства. Режимы рисования представляют собой двоичные raster-operation коды, представляющие все возможные комбинации Boolean двух переменных, используя двоичные операторы AND, OR и XOR (эксклюзивный OR), и неаморную операцию НЕ.

## <a name="cdcsetstretchbltmode"></a><a name="setstretchbltmode"></a>CDC::SetStretchBltMode

Устанавливает режим растяжения биткарты `StretchBlt` для функции члена.

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>Параметры

*nStretchMode*<br/>
Определяет режим растяжения. В качестве такой точки может выступать любой из следующих вариантов:

|Значение|Описание|
|-----------|-----------------|
|БЛЭКОНУАЙТ|Выполняет операцию Boolean AND, используя значения цвета для устраненных и существующих пикселей. Если бит-карта представляет собой монохромную битовую карту, этот режим сохраняет черные пиксели за счет белых пикселей.|
|COLORONCOLOR|Удаляет пиксели. Этот режим удаляет все удаленные линии пикселей, не пытаясь сохранить их информацию.|
|Полутонах|Карты пикселей из исходного прямоугольника в блоки пикселей в прямоугольнике назначения. Средний цвет над блоком назначения пикселей приближаетцвет пикселей источника.|
||После установки режима растяжения HALFTONE приложение должно позвонить в функцию Win32 [SetBrushOrgEx,](/windows/win32/api/wingdi/nf-wingdi-setbrushorgex) чтобы установить происхождение кисти. Если это не удается, происходит несогласованность кисти.|
|STRETCH_ANDSCANS|**Windows 95/98**: То же самое, что BLACKONWHITE|
|STRETCH_DELETESCANS|**Windows 95/98**: То же самое, что И COLORONCOLOR|
|STRETCH_HALFTONE|**Windows 95/98**: То же самое, что HALFTONE.|
|STRETCH_ORSCANS|**Windows 95/98**: То же самое, что WHITEONBLACK|
|УАЙТОНБЛЭК|Выполняет операцию Boolean OR с использованием значений цвета для устраненных и существующих пикселей. Если бит-карта представляет собой монохромную битовую карту, этот режим сохраняет белые пиксели за счет черных пикселей.|

### <a name="return-value"></a>Возвращаемое значение

Предыдущий режим растяжения. Это может быть STRETCH_ANDSCANS, STRETCH_DELETESCANS или STRETCH_ORSCANS.

### <a name="remarks"></a>Remarks

Режим растяжения битовой карты определяет, как информация удаляется из бит-карт, которые сжимаются с помощью функции.

Режимы BLACKONWHITE (STRETCH_ANDSCANS) и WHITEONBLACK (STRETCH_ORSCANS) обычно используются для сохранения пикселей переднего плана в монохромных бит-картах. Режим COLORONCOLOR (STRETCH_DELETESCANS) обычно используется для сохранения цветовых битовых карт.

Режим HALFTONE требует большей обработки исходного изображения, чем остальные три режима; он медленнее, чем другие, но производит изображения более высокого качества. Также обратите `SetBrushOrgEx` внимание, что необходимо вызвать после установки режима HALFTONE, чтобы избежать несогласованности кисти.

Дополнительные режимы растяжения также могут быть доступны в зависимости от возможностей драйвера устройства.

## <a name="cdcsettextalign"></a><a name="settextalign"></a>CDC::SetTextAlign

Устанавливает флаги выравнивания текста.

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>Параметры

*nФлаги*<br/>
Определяет флаги выравнивания текста. Флаги определяют связь между точкой и прямоугольником, который граничит с текстом. Точкой может быть либо текущее положение, либо координаты, указанные функцией текстового вывода. Прямоугольник, который граничит с текстом, определяется смежными ячейками символов в строке текста. Параметр *nFlags* может быть одним или несколько флагами из следующих трех категорий. Выберите только один флаг из каждой категории. Первая категория влияет на выравнивание текста в x-направлении:

- TA_CENTER выравнивает точку с горизонтальным центром граничащий прямоугольник.

- TA_LEFT выравнивает точку с левой стороной граничащий прямоугольник. Это параметр по умолчанию.

- TA_RIGHT выравнивает точку с правой стороной граничащий прямоугольник.

Вторая категория влияет на выравнивание текста в y-направлении:

- TA_BASELINE выравнивает точку с базовой линией выбранного шрифта.

- TA_BOTTOM выравнивает точку с нижней частью граничащий прямоугольника.

- TA_TOP выравнивает точку с верхней частью граничащий прямоугольника. Это параметр по умолчанию.

Третья категория определяет, обновляется ли текущее положение при написании текста:

- TA_NOUPDATECP не обновляет текущее положение после каждого вызова в функцию вывода текста. Это параметр по умолчанию.

- TA_UPDATECP обновляет текущее положение X после каждого вызова функции вывода текста. Новое положение находится на правой стороне связующего прямоугольника для текста. При установке этого флага игнорируются координаты, указанные в вызовах к функции `TextOut` члена.

### <a name="return-value"></a>Возвращаемое значение

Предыдущий параметр выравнивания текста, если он будет успешным. Байт низкого порядка содержит горизонтальную настройку, а байт высокого порядка содержит вертикальную настройку; в противном случае 0.

### <a name="remarks"></a>Remarks

`TextOut` Функции `ExtTextOut` и функции участника используют эти флаги при размещении строки текста на дисплее или устройстве. Флаги определяют связь между определенной точкой и прямоугольником, который граничит с текстом. Координаты этой точки передаются `TextOut` в качестве параметров функции члена. Прямоугольник, который граничит с текстом, формируется соседними ячейками символов в строке текста.

## <a name="cdcsettextcharacterextra"></a><a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra

Устанавливает количество интервалов между персонажами.

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>Параметры

*nCharExtra*<br/>
Определяет количество дополнительного пространства (в логических единицах), которые будут добавлены к каждому символу. Если текущий режим отображения не `MM_TEXT`является, *nCharExtra* преобразуется и округляется до ближайшего пикселя.

### <a name="return-value"></a>Возвращаемое значение

Сумма предыдущего интервала между символами.

### <a name="remarks"></a>Remarks

GDI добавляет этот интервал для каждого символа, включая символы разрыва, когда он записывает строку текста в контекст устройства. Значение по умолчанию для интервала между персонажами составляет 0.

## <a name="cdcsettextcolor"></a><a name="settextcolor"></a>CDC::SetTextColor

Устанавливает цвет текста к указанному цвету.

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>Параметры

*crColor*<br/>
Определяет цвет текста как цветовое значение RGB.

### <a name="return-value"></a>Возвращаемое значение

Значение RGB для предыдущего цвета текста.

### <a name="remarks"></a>Remarks

Система будет использовать этот цвет текста при написании текста в контексте этого устройства, а также при преобразовании битовых карт между цветными и монохромными контекстами устройства.

Если устройство не может представить указанный цвет, система устанавливает цвет текста до ближайшего физического цвета. Цвет фона для персонажа указан `SetBkColor` `SetBkMode` функциями и функциями участника.

### <a name="example"></a>Пример

  Смотрите пример [CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor).

## <a name="cdcsettextjustification"></a><a name="settextjustification"></a>CDC::SetTextОправдание

Добавляет пространство для символов разрыва в строке.

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>Параметры

*nBreakExtra*<br/>
Определяет общее дополнительное пространство, подаваемый в строку текста (в логических единицах). Если текущий режим отображения не `MM_TEXT`является, значение, приведенное этим параметром, преобразуется в текущий режим отображения и округляется до ближайшего блока устройства.

*nBreakCount*<br/>
Определяет количество символов разрыва в строке.

### <a name="return-value"></a>Возвращаемое значение

Один, если функция успешна; в противном случае 0.

### <a name="remarks"></a>Remarks

Приложение может использовать `GetTextMetrics` функции участника для получения символа разрыва шрифта.

После `SetTextJustification` вызова функции участника вызов функции вывода текста `TextOut`(например) равномерно распределяет указанное дополнительное пространство между указанным числом символов разрыва. Символ разрыва обычно является космическим символом (ASCII 32), но может быть определен шрифтом как некий другой символ.

Функция `GetTextExtent` члена обычно используется `SetTextJustification`с помощью . `GetTextExtent`вычисляет ширину заданной линии перед выравниванием. Приложение может определить, сколько места указать в параметре *nBreakExtra,* вычитая значение, возвращенное `GetTextExtent` из ширины строки после выравнивания.

Функция `SetTextJustification` может быть использована для выравнивания строки, содержащей несколько запусков в разных шрифтах. В этом случае линия должна быть создана по частям путем выравнивания и записи каждого запуска по отдельности.

Поскольку ошибки округления могут возникать во время выравнивания, система сохраняет термин ошибки выполнения, определяющий текущую ошибку. При выравнивании строки, `GetTextExtent` содержащей несколько запусков, автоматически использует этот термин ошибки при вычислении степени следующего запуска. Это позволяет функции вывода текста смешивать ошибку в новый запуск.

После выравнивания каждой строки этот термин ошибки должен быть очищен, чтобы предотвратить ее включение в следующую строку. Термин может быть очищен, позвонив `SetTextJustification` с *nBreakExtra* набор 0.

## <a name="cdcsetviewportext"></a><a name="setviewportext"></a>CDC::SetViewportExt

Устанавливает x- и y-объемы контекста просмотра устройства.

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>Параметры

*Cx*<br/>
Определяет x-степень viewport (в блоках устройств).

*Cy*<br/>
Оценивайте y-extent of viewport (в блоках устройства).

*Размер*<br/>
Определяет x- и y-объемы viewport (в единицах устройства).

### <a name="return-value"></a>Возвращаемое значение

Предыдущие степени объекта viewport как [объекта CSize.](../../atl-mfc-shared/reference/csize-class.md) При возникновении ошибки x- и y-координаты возвращенного `CSize` объекта устанавливаются на 0.

### <a name="remarks"></a>Remarks

Порт представления, наряду с окном контекста устройства, определяет, как GDI-карты указывают в системе логических координат точкам в системе координат фактического устройства. Другими словами, они определяют, как GDI преобразует логические координаты в координаты устройства.

При установке следующих режимов отображения вызовы `SetWindowExt` и `SetViewportExt` игнорирования:

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

При установке MM_ISOTROPIC режима приложение `SetWindowExt` должно вызвать `SetViewportExt`функцию участника перед вызовом.

### <a name="example"></a>Пример

  Смотрите пример [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetviewportorg"></a><a name="setviewportorg"></a>CDC::SetViewportOrg

Устанавливает происхождение контекста порта представления.

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет x-координацию (в единицах устройства) происхождения viewport. Значение должно находиться в пределах системы координат устройства.

*Y*<br/>
Определяет y-координацию (в единицах устройства) происхождения viewport. Значение должно находиться в пределах системы координат устройства.

*Точки*<br/>
Определяет происхождение viewport. Значения должны находиться в пределах диапазона системы координат устройства. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Предыдущее происхождение объекта представления (в координатах устройства) как `CPoint` объекта.

### <a name="remarks"></a>Remarks

Порт представления, наряду с окном контекста устройства, определяет, как GDI-карты указывают в системе логических координат точкам в системе координат фактического устройства. Другими словами, они определяют, как GDI преобразует логические координаты в координаты устройства.

Происхождение viewport обозначает точку в системе координат устройства, к которой GDI `SetWindowOrg` отображает происхождение окна, точку в системе логических координат, указанных функцией члена. GDI отображает все остальные точки, следуя тому же процессу, который требуется для отображения происхождения окна в исходный порт. Например, все точки в круге вокруг точки в окне происхождения будут находиться в круге вокруг точки в источнике viewport. Аналогичным образом, все точки в строке, которая проходит через происхождение окна, будут находиться в строке, которая проходит через происхождение viewport.

### <a name="example"></a>Пример

  Смотрите пример [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindowext"></a><a name="setwindowext"></a>CDC::SetWindowExT

Устанавливает x- и y-объемы окна, связанные с контекстом устройства.

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>Параметры

*Cx*<br/>
Определяет x-extent (в логических единицах) окна.

*Cy*<br/>
Определяет y-extent (в логических единицах) окна.

*Размер*<br/>
Определяет x- и y-extents (в логических единицах) окна.

### <a name="return-value"></a>Возвращаемое значение

Предыдущие степени окна (в логических единицах) как `CSize` объект. При возникновении ошибки x- и y-координаты возвращенного `CSize` объекта устанавливаются на 0.

### <a name="remarks"></a>Remarks

Окно, наряду с устройством-контекстом viewport, определяет, как GDI карты указывает в системе логических координат к точкам в системе координат устройства.

При установке следующих режимов отображения вызовы `SetWindowExt` и `SetViewportExt` функции игнорируются:

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

При установке MM_ISOTROPIC режима приложение `SetWindowExt` должно вызвать `SetViewportExt`функцию участника перед вызовом.

### <a name="example"></a>Пример

  Смотрите пример [CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc).

## <a name="cdcsetwindoworg"></a><a name="setwindoworg"></a>CDC::SetWindowOrg

Устанавливает происхождение окна контекста устройства.

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координатку нового происхождения окна.

*Y*<br/>
Определяет логическую y-координацию нового происхождения окна.

*Точки*<br/>
Определяет логические координаты нового происхождения окна. Вы можете передать `POINT` либо `CPoint` структуру, либо объект для этого параметра.

### <a name="return-value"></a>Возвращаемое значение

Предыдущее происхождение окна как `CPoint` объекта.

### <a name="remarks"></a>Remarks

Окно, наряду с устройством-контекстом viewport, определяет, как GDI карты указывает в системе логических координат к точкам в системе координат устройства.

Происхождение окна обозначит точку в системе логических координат, из которой GDI отображает происхождение порта viewport, точку в системе координат устройства, указанную функцией. `SetWindowOrg` GDI отображает все остальные точки, следуя тому же процессу, который требуется для отображения происхождения окна в исходный порт. Например, все точки в круге вокруг точки в окне происхождения будут находиться в круге вокруг точки в источнике viewport. Аналогичным образом, все точки в строке, которая проходит через происхождение окна, будут находиться в строке, которая проходит через происхождение viewport.

## <a name="cdcsetworldtransform"></a><a name="setworldtransform"></a>CDC::SetWorldTransform

Устанавливает двухмерное линейное преобразование между мировым пространством и пространством страницы для заданного контекста устройства. Это преобразование можно использовать для масштабирования, вращения, сдвига или перевода вывода графики.

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>Параметры

*rXform*<br/>
Ссылка на структуру [XFORM,](/windows/win32/api/wingdi/ns-wingdi-xform) содержащую данные о трансформации.

### <a name="return-value"></a>Возвращаемое значение

Возвращает ненулевое значение успеха.

Возвращает 0 при сбое.

Чтобы получить расширенную информацию об ошибке, позвоните [getLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

### <a name="remarks"></a>Remarks

Этот метод обертывает функцию Windows GDI [SetWorldTransform.](/windows/win32/api/wingdi/nf-wingdi-setworldtransform)

## <a name="cdcstartdoc"></a><a name="startdoc"></a>CDC::StartDoc

Информирует драйвер устройства о том, что начинается `EndPage` новая работа печати и что все `EndDoc` последующие `StartPage` и вызовы должны быть спущены под одно и то же задание до тех пор, пока не произойдет вызов.

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>Параметры

*lpDocInfo*<br/>
Указывает на структуру [DOCINFO,](/windows/win32/api/wingdi/ns-wingdi-docinfow) содержащую имя файла документа и имя выходного файла.

*lpszDocName*<br/>
Указатель на строку, содержащую имя файла документа.

### <a name="return-value"></a>Возвращаемое значение

Если функция успешно, значение возврата больше нуля. Это значение является идентификатором выполнения задания печати для документа.

Если функция выходит из строя, значение возврата меньше или равно нулю.

### <a name="remarks"></a>Remarks

Это гарантирует, что документы продолжительного времени, чем одна страница, не будут перемежаться с другими заданиями.

Для версий Windows 3.1 и более позднего, эта функция заменяет принтер STARTDOC побег. Использование этой функции гарантирует, что документы, содержащие более одной страницы, не будут перемежаться с другими заданиями печати.

`StartDoc`не должны использоваться внутри метафайлов.

### <a name="example"></a>Пример

Этот фрагмент кода получает принтер по умолчанию, открывает работу печати и засовывает одну страницу с "Здравствуйте, Мир!" на нем. Поскольку текст, напечатанный этим кодом, не масштабируется до логических блоков принтера, выходный текст может быть такими мелкими буквами, что результат нечитаем. Функции масштабирования CDC, `SetMapMode`такие `SetViewportOrg`как `SetWindowExt`, и, могут быть использованы для исправления масштабирования.

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

## <a name="cdcstartpage"></a><a name="startpage"></a>CDC::StartPage

Вызовите эту функцию участника, чтобы подготовить драйвер принтера к получению данных.

```
int StartPage();
```

### <a name="return-value"></a>Возвращаемое значение

Больше или равно 0, если функция успешна, или отрицательное значение, если произошла ошибка.

### <a name="remarks"></a>Remarks

`StartPage`заменяет NEWFRAME и BANDINFO побегов.

Для обзора последовательности типографских вызовов см. [StartDoc](#startdoc)

Система отменяет функцию `ResetDC` участника между `StartPage` вызовами и `EndPage`.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::StartDoc](#startdoc).

## <a name="cdcstretchblt"></a><a name="stretchblt"></a>CDC::StretchBlt

Копирует точечный рисунок из исходного прямоугольника в прямоугольник назначения, при необходимости растягивая или сжимая точечный рисунок в соответствии с размерами прямоугольника назначения.

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Указывает x-координату (в логических единицах) левого верхнего угла прямоугольника назначения.

*Y*<br/>
Указывает y-координату (в логических единицах) левого верхнего угла прямоугольника назначения.

*nWidth*<br/>
Задает ширину прямоугольника назначения (в логических единицах).

*nВысота*<br/>
Задает высоту прямоугольника назначения (в логических единицах).

*pSrcDC*<br/>
Задает контекст исходного устройства.

*xSrc*<br/>
Указывает x-координату (в логических единицах) левого верхнего угла исходного прямоугольника.

*ySrc*<br/>
Указывает y-координату (в логических единицах) левого верхнего угла исходного прямоугольника.

*nSrcWidth*<br/>
Задает ширину исходного прямоугольника (в логических единицах).

*nSrcHeight*<br/>
Задает высоту исходного прямоугольника (в логических единицах).

*dwRop*<br/>
Определяет подлежащую выполнению растровую операцию. Коды растровых операций определяют, как GDI сочетает цвета в операциях вывода, где используется текущая кисть, возможный исходный точечный рисунок и точечный рисунок назначения. Этот параметр может иметь одно из следующих значений:

- BLACKNESS превращает все выходные черные.

- DSTINVERT инвертирует битную карту назначения.

- MERGECOPY сочетает в себе шаблон и исходную бит-карту с помощью оператора Boolean AND.

- MERGEPAINT сочетает в себе перевернутый исходный бит-карту с битной картой назначения с помощью оператора Boolean OR.

- NOTSRCCOPY Копирует перевернутый исходный бит-карты к месту назначения.

- NOTSRCERASE инвертирует результат объединения клиративок назначения и исходных биткарт с помощью оператора Boolean OR.

- PATCOPY копирует шаблон к битовой карте назначения.

- PATINVERT сочетает в себе битную карту назначения с узором с помощью оператора Boolean XOR.

- PATPAINT сочетает в себе перевернутую битную карту исходного кода с шаблоном с помощью оператора Boolean OR. Объединяет результат операции с точечным рисунком назначения с помощью оператора логического ИЛИ.

- SRCAND объединяет пиксели назначения и исходные биткарты с помощью оператора Boolean AND.

- SRCCOPY копирует исходную бит-карту к биткарте назначения.

- SRCERASE инвертирует битную карту назначения и сочетает в себе результат с исходной битной картой с помощью оператора Boolean AND.

- SRCINVERT объединяет пиксели назначения и исходные биткарты с помощью оператора Boolean XOR.

- SRCPAINT объединяет пиксели назначения и исходные биткарты с помощью оператора Boolean OR.

- WHITENESS превращает все выходные белые.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если точечный рисунок рисуется, в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция использует режим растягивания контекста устройства назначения (задается `SetStretchBltMode`), чтобы определить, как необходимо растянуть или сжать точечный рисунок.

Функция `StretchBlt` перемещает битную карту с исходного устройства, предоставленного *pSrcDC,* на устройство назначения, представленное объектом устройства-контекста, функция члена которого вызывается. Параметры *xSrc,* *ySrc,* *nSrcWidth*и *nSrcHeight* определяют верхний левый угол и размеры прямоугольника источника. Параметры *x,* *y,* *nWidth*и *nHeight* придают верхний левый угол и размеры прямоугольника назначения. Операция raster, указанная *dwRop,* определяет, как комбинируются исходная битная карта и биты, уже наустройстве назначения.

Функция `StretchBlt` создает зеркальное отражение бит-карты, если признаки *nSrcWidth* и *nWidth* или *nSrcHeight* и *nHeight* параметры отличаются. Если *nSrcWidth* и *nWidth* имеют различные знаки, функция создает зеркальное отражение битовой карты вдоль оси x. Если *nSrcHeight* и *nHeight* имеют разные знаки, функция создает зеркальное отражение битовой карты вдоль оси y.

Функция `StretchBlt` растягивает или сжимает исходный точечный рисунок, а затем копирует результат в место назначения. Если узор необходимо объединить с результатом, он не объединяется, пока растянутый исходный точечный рисунок не будет скопирован в место назначения. Если используется кисть, это будет кисть, выбранная в контексте устройства назначения. Координаты назначения преобразуются в зависимости от контекста устройства назначения; исходные координаты преобразуются в зависимости от контекста исходного устройства.

Если точечные рисунки назначения, источника и узора не имеют один формат цвета, `StretchBlt` преобразует точечные рисунки источника и узора в соответствии с точечным рисунком назначения. В преобразовании используются цвета переднего плана и фона контекста устройства назначения.

Если `StretchBlt` необходимо преобразовать монохромный точечный рисунок в цвет, белые биты (1) задаются в качестве значения цвета фона, а черные биты (0) — в качестве цвета переднего плана. Для преобразования цветов в монохромный режим определяются пиксели, сопоставляющие цвет фона белому (1), а все остальные пиксели становятся черными (0). Используются цвета переднего плана и фона контекста устройства назначения с цветом.

Не все устройства поддерживают функцию `StretchBlt`. Чтобы определить, поддерживает `StretchBlt`ли `GetDeviceCaps` устройство, позвоните функции участника с индексом RASTERCAPS и проверьте значение возврата для флага RC_STRETCHBLT.

## <a name="cdcstrokeandfillpath"></a><a name="strokeandfillpath"></a>CDC:Strokeandfillpath

Закрывает любые открытые фигуры в пути, гладит контур пути с помощью текущей ручки, и заполняет его интерьер с помощью текущей кисти.

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Контекст устройства должен содержать закрытый путь. Функция `StrokeAndFillPath` члена имеет тот же эффект, что и закрытие всех открытых фигур на пути, и поглаживание и заполнение пути отдельно, за исключением того, что заполненная область не перекроет гладкую область, даже если перо широкое.

## <a name="cdcstrokepath"></a><a name="strokepath"></a>CDC::StrokePath

Рендеризирует указанный путь с помощью текущего пера.

```
BOOL StrokePath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Контекст устройства должен содержать закрытый путь.

## <a name="cdctabbedtextout"></a><a name="tabbedtextout"></a>CDC:TabbedTextOut

Вызов ими функции участника для записи строки символов в указанном месте, расширяя вкладки на значения, указанные в массиве позиций остановки вкладок.

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Определяет логическую х-координацию отправной точки строки.

*Y*<br/>
Определяет логическую y-координацию отправной точки строки.

*lpszString*<br/>
Очки на строку персонажа для рисования. Вы можете передать либо указатель на массив символов или объект [CString](../../atl-mfc-shared/reference/cstringt-class.md) для этого параметра.

*Ncount*<br/>
Определяет [длину строки,](/windows/win32/gdi/specifying-length-of-text-output-string) на которую указывает *lpszString.*

*nTabPositions*<br/>
Определяет количество значений в массиве позиций tab-stop.

*lpnTabStopPositions*<br/>
Указывает на массив, содержащий позиции tab-stop (в логических единицах). Остановки вкладок должны быть отсортированы в порядке увеличения; наименьшее значение x должно быть первым элементом в массиве.

*nTabOrigin*<br/>
Определяет x-координатизм исходного положения, из которого расширяются вкладки (в логических единицах).

*Ул*<br/>
Объект, `CString` содержащий указанные символы.

### <a name="return-value"></a>Возвращаемое значение

Размеры строки (в логических единицах) как `CSize` объекта.

### <a name="remarks"></a>Remarks

Текст записываются в выбранный в настоящее время шрифт. Если *nTabPositions* равен 0, а *lpnTabStopPositions* является NULL, вкладки расширяются в восемь раз больше средней ширины персонажа.

Если *nTabPositions* равен 1, остановки вкладок разделены расстоянием, указанным первым значением в массиве *lpnTabStopPositions.* Если массив *lpnTabStopPositions* содержит более одного значения, для каждого значения в массиве устанавливается остановка вкладок, вплоть до числа, указанного *nTabPositions.* Параметр *nTabOrigin* позволяет приложению `TabbedTextOut` несколько раз вызывать функцию для одной строки. Если приложение вызывает функцию более одного раза с *nTabOrigin,* установленным на одно и то же значение каждый раз, функция расширяет все вкладки относительно позиции, указанной *nTabOrigin.*

По умолчанию текущая позиция не используется и не обновляется функцией. Если приложению необходимо обновить текущее положение при вызове функции, приложение может вызвать функцию члена [SetTextAlign](#settextalign) с *nFlags,* установленным для TA_UPDATECP. Когда этот флаг установлен, Windows игнорирует параметры *x* и `TabbedTextOut` *y* при последующих вызовах, используя вместо этого текущее положение.

## <a name="cdctextout"></a><a name="textout"></a>CDC:TextOut

Записывает символьную строку в указанном месте, используя текущий выбранный шрифт.

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>Параметры

*x*<br/>
Указывает логическую координату X начальной точки текста.

*Y*<br/>
Указывает логическую координату Y начальной точки текста.

*lpszString*<br/>
Указывает на строку символов, которую необходимо нарисовать.

*Ncount*<br/>
Указывает количество знаков в строке.

*Ул*<br/>
Объект `CString`, который содержит символы, которые необходимо нарисовать.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Начальные координаты символа в левом верхнем углу ячейки символов. По умолчанию текущая позиция не используется и не обновляется функцией.

Если приложению необходимо обновить текущее `TextOut`положение при вызове, приложение может вызвать функцию `SetTextAlign` участника с *nFlags,* установленным для TA_UPDATECP. Когда этот флаг установлен, Windows игнорирует параметры *x* и `TextOut` *y* при последующих вызовах, используя вместо этого текущее положение.

### <a name="example"></a>Пример

  Смотрите пример для [CDC::BeginPath](#beginpath).

## <a name="cdctransparentblt"></a><a name="transparentblt"></a>CDC::TransparentBlt

Вызовите эту функцию участника для передачи бит-блока цветовых данных, который соответствует прямоугольнику пикселей из заданного контекста исходного устройства, в контекст устройства назначения.

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>Параметры

*xDest*<br/>
Определяет x-координацию, в логических единицах, верхнего левого угла прямоугольника назначения.

*yDest*<br/>
Определяет y-координацию, в логических единицах, верхнего левого угла прямоугольника назначения.

*nDestWidth*<br/>
Определяет ширину, в логических единицах, прямоугольника назначения.

*nDestHeight*<br/>
Определяет высоту, в логических единицах, прямоугольника назначения.

*pSrcDC*<br/>
Указатель на контекст исходного устройства.

*xSrc*<br/>
Определяет x-координацию, в логических единицах, прямоугольника источника.

*ySrc*<br/>
Определяет y-координацию, в логических единицах, прямоугольника источника.

*nSrcWidth*<br/>
Определяет ширину в логических единицах прямоугольника источника.

*nSrcHeight*<br/>
Определяет высоту, в логических единицах, прямоугольника источника.

*clrПрозрачный*<br/>
Цвет RGB в исходной битной карте для обработки как прозрачный.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если успешно; в противном случае — FALSE.

### <a name="remarks"></a>Remarks

`TransparentBlt`обеспечивает транспарентность; то есть цвет RGB, указанный *clrTransparent,* становится прозрачным для передачи.

Для получения дополнительной информации [см.](/windows/win32/api/wingdi/nf-wingdi-transparentblt)

## <a name="cdcupdatecolors"></a><a name="updatecolors"></a>CDC:UpdateColors

Обновляет область клиента контекста устройства, сопоставляя текущие цвета в области клиента с системной палитрой на основе пикселей за пикселем.

```
void UpdateColors();
```

### <a name="remarks"></a>Remarks

Неактивное окно с реализованной `UpdateColors` логической палитрой можно назвать альтернативой перерисовке клиентской области при изменении системной палитры.

Для получения дополнительной информации об использовании цветовых палитр, см [UpdateColors](/windows/win32/api/wingdi/nf-wingdi-updatecolors) в Windows SDK.

Функция `UpdateColors` участника обычно обновляет область клиента быстрее, чем перерисовка области. Однако, поскольку функция выполняет цветной перевод на основе цвета каждого пикселя до изменения всей системной палитры, каждый вызов этой функции приводит к потере некоторой точности цвета.

## <a name="cdcwidenpath"></a><a name="widenpath"></a>CDC:WidenPath

Переопределяет текущий путь как область, которая будет окрашена, если путь был погладил с помощью пера в настоящее время выбран в контексте устройства.

```
BOOL WidenPath();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Remarks

Эта функция успешна только в том случае, если текущая `CreatePen` ручка представляет собой геометрическое перо, созданное второй версией функции члена, или если перо создано с первой версией `CreatePen` и имеет ширину, в единицах устройства, больше 1. Контекст устройства должен содержать закрытый путь. Любые кривые Bzier в пути преобразуются в последовательности прямых линий, приближенных к расширенным кривым. Таким образом, кривые Bzier не `WidenPath` остаются в пути после вызова.

## <a name="see-also"></a>См. также раздел

[Класс CObject](../../mfc/reference/cobject-class.md)<br/>
[Диаграмма иерархии](../../mfc/hierarchy-chart.md)<br/>
[Класс CPaintDC](../../mfc/reference/cpaintdc-class.md)<br/>
[Класс CWindowDC](../../mfc/reference/cwindowdc-class.md)<br/>
[Класс CClientDC](../../mfc/reference/cclientdc-class.md)<br/>
[Класс CMetaFileDC](../../mfc/reference/cmetafiledc-class.md)
