---
title: Класс CDatabase
ms.date: 11/04/2016
f1_keywords:
- CDatabase
- AFXDB/CDatabase
- AFXDB/CDatabase::CDatabase
- AFXDB/CDatabase::BeginTrans
- AFXDB/CDatabase::BindParameters
- AFXDB/CDatabase::Cancel
- AFXDB/CDatabase::CanTransact
- AFXDB/CDatabase::CanUpdate
- AFXDB/CDatabase::Close
- AFXDB/CDatabase::CommitTrans
- AFXDB/CDatabase::ExecuteSQL
- AFXDB/CDatabase::GetBookmarkPersistence
- AFXDB/CDatabase::GetConnect
- AFXDB/CDatabase::GetCursorCommitBehavior
- AFXDB/CDatabase::GetCursorRollbackBehavior
- AFXDB/CDatabase::GetDatabaseName
- AFXDB/CDatabase::IsOpen
- AFXDB/CDatabase::OnSetOptions
- AFXDB/CDatabase::Open
- AFXDB/CDatabase::OpenEx
- AFXDB/CDatabase::Rollback
- AFXDB/CDatabase::SetLoginTimeout
- AFXDB/CDatabase::SetQueryTimeout
- AFXDB/CDatabase::m_hdbc
helpviewer_keywords:
- CDatabase [MFC], CDatabase
- CDatabase [MFC], BeginTrans
- CDatabase [MFC], BindParameters
- CDatabase [MFC], Cancel
- CDatabase [MFC], CanTransact
- CDatabase [MFC], CanUpdate
- CDatabase [MFC], Close
- CDatabase [MFC], CommitTrans
- CDatabase [MFC], ExecuteSQL
- CDatabase [MFC], GetBookmarkPersistence
- CDatabase [MFC], GetConnect
- CDatabase [MFC], GetCursorCommitBehavior
- CDatabase [MFC], GetCursorRollbackBehavior
- CDatabase [MFC], GetDatabaseName
- CDatabase [MFC], IsOpen
- CDatabase [MFC], OnSetOptions
- CDatabase [MFC], Open
- CDatabase [MFC], OpenEx
- CDatabase [MFC], Rollback
- CDatabase [MFC], SetLoginTimeout
- CDatabase [MFC], SetQueryTimeout
- CDatabase [MFC], m_hdbc
ms.assetid: bd0de70a-e3c3-4441-bcaa-bbf434426ca8
ms.openlocfilehash: bc920307e09179dc214710a3b6b19ff27a82749d
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "81754643"
---
# <a name="cdatabase-class"></a>Класс CDatabase

Представляет подключение к источнику данных, с помощью которого можно получить доступ к данным.

## <a name="syntax"></a>Синтаксис

```
class CDatabase : public CObject
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CDatabase::CDatabase](#cdatabase)|Формирует объект `CDatabase`. Вы должны инициализировать объект, позвонив `OpenEx` или `Open`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CDatabase::BeginTrans](#begintrans)|Запускает "транзакцию" - серию обратимых `AddNew` `Edit`вызовов `Update` в , `CRecordset` `Delete`и функции члена класса - на подключенный источник данных. Источник данных должен `BeginTrans` поддерживать транзакции, чтобы иметь какой-либо эффект.|
|[CDatabase::BindParameters](#bindparameters)|Позволяет связывать параметры перед `CDatabase::ExecuteSQL`вызовом.|
|[CDatabase::Отмена](#cancel)|Отменяет асинхронную операцию или процесс из второго потока.|
|[CDatabase::CanTransact](#cantransact)|Возвращает ненулевой, если источник данных поддерживает транзакции.|
|[CDatabase::CanUpdate](#canupdate)|Возвращает ненулевой, если `CDatabase` объект updatable (не только читать).|
|[CDatabase::Закрыть](#close)|Закрывает подключение источника данных.|
|[CDatabase::CommitTrans](#committrans)|Завершает транзакцию, `BeginTrans`начатую . Команды в транзакции, изменяющие источник данных, выполняются.|
|[CDatabase::ExecuteS'L](#executesql)|Выполняет выписку по S'L. Записи данных не возвращаются.|
|[CDatabase::GetBookmarkPersistenceenceenceence](#getbookmarkpersistence)|Определяет операции, с помощью которых закладки сохраняются на объектах рекордных.|
|[CDatabase::GetConnect](#getconnect)|Возвращает строку соединения ODBC, `CDatabase` используемую для подключения объекта к источнику данных.|
|[CDatabase::GetCursorCommitBehavior](#getcursorcommitbehavior)|Определяет влияние совершения транзакции на объект открытого набора записей.|
|[CDatabase::GetCursorRollbackBehavior](#getcursorrollbackbehavior)|Определяет эффект отката транзакции на объект е-рекордс.|
|[CDatabase:GetDatabaseName](#getdatabasename)|Возвращает имя базы данных, которая в настоящее время используется.|
|[CDatabase::IsOpen](#isopen)|Возвращает ненулевой, если `CDatabase` объект в настоящее время подключен к источнику данных.|
|[CDatabase:OnsetOptions](#onsetoptions)|Вызывается в рамках установить стандартные параметры соединения. Реализация по умолчанию устанавливает значение тайм-аута запроса. Вы можете установить эти варианты заранее, позвонив `SetQueryTimeout`.|
|[CDatabase::Открыто](#open)|Устанавливает подключение к источнику данных (через драйвер ODBC).|
|[CDatabase::OpenEx](#openex)|Устанавливает подключение к источнику данных (через драйвер ODBC).|
|[CDatabase::Откат](#rollback)|Обратные изменения, внесенные во время текущей транзакции. Источник данных возвращается в прежнее `BeginTrans` состояние, как определено при вызове, без изменений.|
|[CDatabase::SetLoginTimeout](#setlogintimeout)|Устанавливает количество секунд, после которых попытка подключения источника данных будет тайм-аут.|
|[CDatabase::Set'ryTimeout](#setquerytimeout)|Устанавливает количество секунд, после которых операции запроса базы данных будут тайм-аут. Влияет на все `Open`последующие рекорды, `AddNew`и `Edit` `Delete` вызовы.|

### <a name="public-data-members"></a>Открытые члены данных

|Имя|Описание|
|----------|-----------------|
|[CDatabase::m_hdbc](#m_hdbc)|Открытая ручка подключения к базе данных (ODBC) к источнику данных. Тип *HDBC*.|

## <a name="remarks"></a>Remarks

Источник данных — это конкретный экземпляр данных, размещенных в некоторых системах управления базами данных (DBMS). В качестве примеров можно привести сервер Microsoft S'L, Microsoft Access, Borland dBASE и xBASE. В приложении может `CDatabase` быть одновременно один или несколько объектов, активных одновременно.

> [!NOTE]
> Если вы работаете с классами объектов доступа к данным (DAO), а не с классами Open Database Connectivity (ODBC), используйте класс [CDaoDatabase.](../../mfc/reference/cdaodatabase-class.md) Для получения дополнительной информации смотрите статью [Обзор: Программирование базы данных](../../data/data-access-programming-mfc-atl.md).

Для `CDatabase`использования, `CDatabase` построить объект `OpenEx` и вызвать его функцию члена. Это открывает соединение. При построении `CRecordset` объектов для работы на подключенном источнике данных `CDatabase` передайте конструктору записей указатель на объект. Когда вы закончите использовать `Close` соединение, позвоните `CDatabase` функции участника и уничтожить объект. `Close`закрывает все записи, которые вы не закрывали ранее.

Для получения `CDatabase`дополнительной информации о , [Overview: Database Programming](../../data/data-access-programming-mfc-atl.md)см. [Data Source (ODBC)](../../data/odbc/data-source-odbc.md)

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

`CDatabase`

## <a name="requirements"></a>Требования

**Заголовок:** afxdb.h

## <a name="cdatabasebegintrans"></a><a name="begintrans"></a>CDatabase::BeginTrans

Вызовите эту функцию участника, чтобы начать транзакцию с подключенным источником данных.

```
BOOL BeginTrans();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если вызов был успешным и изменения совершаются только вручную; в противном случае 0.

### <a name="remarks"></a>Remarks

Транзакция состоит из одного или `AddNew` `Edit`нескольких `Delete`вызовов к `CRecordset` функции объекта, и `Update` функции участника. Перед началом транзакции `CDatabase` объект должен быть подключен к источнику данных, позвонив в функцию его `OpenEx` или `Open` функции члена. Чтобы закончить транзакцию, позвоните [commitTrans,](#committrans) чтобы принять все изменения в источнике данных (и выполнить их) или вызвать [откат,](#rollback) чтобы прервать всю транзакцию. Звоните `BeginTrans` после открытия любых записей, участвующих в транзакции, и максимально приближены к фактическим операциям обновления.

> [!CAUTION]
> В зависимости от драйвера ODBC, `BeginTrans` открытие набора записей перед вызовом может вызвать проблемы при вызове. `Rollback` Вы должны проверить конкретный драйвер вы используете. Например, при использовании драйвера Microsoft Access, включенного в набор драйверов microsoft ODBC Desktop Driver Pack 3.0, необходимо учитывать требование движка базы данных Jet о том, что вы не должны начинать транзакцию в любой базе данных с открытым курсором. В классах баз данных MFC открытый `CRecordset` курсор означает открытый объект. Для получения дополнительной информации [см.](../../mfc/tn068-performing-transactions-with-the-microsoft-access-7-odbc-driver.md)

`BeginTrans`может также блокировать записи данных на сервере, в зависимости от запрашиваемого параллелизма и возможностей источника данных. Для получения информации о блокировке данных, [см.](../../data/odbc/recordset-locking-records-odbc.md)

Транзакции, определяемые пользователем, объясняются в статье [Transaction (ODBC).](../../data/odbc/transaction-odbc.md)

`BeginTrans`устанавливает состояние, к которому последовательность транзакций может быть отката (обратно). Чтобы установить новое состояние для откатов, совершайте любую текущую транзакцию, а затем позвоните `BeginTrans` снова.

> [!CAUTION]
> Вызов `BeginTrans` снова `CommitTrans` без `Rollback` вызова или является ошибкой.

Позвоните в функцию участника [CanTransact,](#cantransact) чтобы определить, поддерживает ли ваш драйвер транзакции для данной базы данных. Вы также должны позвонить [GetCursorCommitBehavior](#getcursorcommitbehavior) и [GetCursorRollbackBehavior,](#getcursorrollbackbehavior) чтобы определить поддержку сохранения курсора.

Для получения дополнительной информации [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)о транзакциях см.

### <a name="example"></a>Пример

  Смотрите статью [Транзакция: Выполнение транзакции в наборе рекордов (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md).

## <a name="cdatabasebindparameters"></a><a name="bindparameters"></a>CDatabase::BindParameters

Переопределить, `BindParameters` когда вам нужно связать параметры перед вызовом [CDatabase::ExecuteS'L](#executesql).

```
virtual void BindParameters(HSTMT hstmt);
```

### <a name="parameters"></a>Параметры

*hstmt*<br/>
Ручка оператора оператора ODBC, для которой требуется связать параметры.

### <a name="remarks"></a>Remarks

Этот подход полезен, если вам не нужен набор результатов из сохраненной процедуры.

В переопределение, `SQLBindParameters` вызов и связанные функции ODBC связать параметры. MFC вызывает ваш переопределение `ExecuteSQL`перед вашим звоноком к . Вам не нужно `SQLPrepare`звонить; `ExecuteSQL` вызывает `SQLExecDirect` и разрушает *hstmt*, который используется только один раз.

## <a name="cdatabasecancel"></a><a name="cancel"></a>CDatabase::Отмена

Вызовите эту функцию участника, чтобы запросить отмену источника данных либо асинхронной операции, или процесса из второго потока.

```cpp
void Cancel();
```

### <a name="remarks"></a>Remarks

Обратите внимание, что классы MFC ODBC больше не используют асинхронную обработку; для выполнения асинхронной операции необходимо напрямую позвонить в функцию ODBC API [sLSetConnectOption.](/sql/odbc/reference/syntax/sqlsetconnectoption-function) Дополнительные сведения см. в разделе [Асинхронное выполнение](/sql/odbc/reference/develop-app/asynchronous-execution).

## <a name="cdatabasecantransact"></a><a name="cantransact"></a>CDatabase::CanTransact

Позвоните в эту функцию участника, чтобы определить, позволяет ли база данных транзакции.

```
BOOL CanTransact() const;
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если записи, использующие этот `CDatabase` объект, позволяют транзакции; в противном случае 0.

### <a name="remarks"></a>Remarks

Для получения информации о [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)транзакциях см.

## <a name="cdatabasecanupdate"></a><a name="canupdate"></a>CDatabase::CanUpdate

Вызовите эту функцию `CDatabase` участника, чтобы определить, позволяет ли объект обновлять.

```
BOOL CanUpdate() const;
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, `CDatabase` если объект позволяет обновления; в противном случае 0, указывая либо, что `CDatabase` вы прошли правду в *bReadТолько* тогда, когда вы открыли объект или что сам источник данных читается только. Источник данных читается только в том случае, `SQLGetInfo` если звонок в функцию ODBC API для SQL_DATASOURCE_READ_ONLY возвращается "y".

### <a name="remarks"></a>Remarks

Не все драйверы поддерживают обновления.

## <a name="cdatabasecdatabase"></a><a name="cdatabase"></a>CDatabase::CDatabase

Формирует объект `CDatabase`.

```
CDatabase();
```

### <a name="remarks"></a>Remarks

После построения объекта необходимо `OpenEx` вызвать его функцию или `Open` функцию члена, чтобы установить подключение к определенному источнику данных.

Возможно, вам будет удобно `CDatabase` встраивать объект в класс документов.

### <a name="example"></a>Пример

Этот пример иллюстрирует `CDatabase` использование `CDocument`в классе производных.

[!code-cpp[NVC_MFCDatabase#9](../../mfc/codesnippet/cpp/cdatabase-class_1.h)]

[!code-cpp[NVC_MFCDatabase#10](../../mfc/codesnippet/cpp/cdatabase-class_2.cpp)]

## <a name="cdatabaseclose"></a><a name="close"></a>CDatabase::Закрыть

Вызовите эту функцию участника, если вы хотите отключиться от источника данных.

```
virtual void Close();
```

### <a name="remarks"></a>Remarks

Необходимо закрыть все записи, `CDatabase` связанные с объектом, прежде чем вызвать эту функцию участника. Поскольку `Close` `CDatabase` объект не разрушается, можно повторно использовать объект, открыв новое соединение с тем же источником данных или другим источником данных.

Все `AddNew` незавершенные или `Edit` операторские записи с использованием базы данных отменяются, а все ожидающие транзакции откатываются. Любые записи, `CDatabase` зависящие от объекта, остаются в неопределенном состоянии.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDatabase#12](../../mfc/codesnippet/cpp/cdatabase-class_3.cpp)]

## <a name="cdatabasecommittrans"></a><a name="committrans"></a>CDatabase::CommitTrans

Вызовите эту функцию участника после завершения транзакций.

```
BOOL CommitTrans();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если обновления были успешно совершены; в противном случае 0. При `CommitTrans` сбоях состояние источника данных не определено. Необходимо проверить данные, чтобы определить их состояние.

### <a name="remarks"></a>Remarks

Транзакция состоит из серии `AddNew`вызовов `Delete`в `Update` функции `CRecordset` , `Edit`и функции члена объекта, который начался с вызова к функции участника [BeginTrans.](#begintrans) `CommitTrans`совершает транзакцию. По умолчанию обновления заносятся немедленно; вызов `BeginTrans` вызывает обязательство обновлений, которые будут отложены до тех пор, пока не `CommitTrans` будет вызвано.

`CommitTrans` До вызова до окончания транзакции можно вызвать функцию участника [отката,](#rollback) чтобы прервать транзакцию и оставить источник данных в исходном состоянии. Чтобы начать новую `BeginTrans` транзакцию, позвоните еще раз.

Для получения дополнительной информации [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)о транзакциях см.

### <a name="example"></a>Пример

  Смотрите статью [Транзакция: Выполнение транзакции в наборе рекордов (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md).

## <a name="cdatabaseexecutesql"></a><a name="executesql"></a>CDatabase::ExecuteS'L

Вызовите эту функцию участника, когда вам нужно выполнить команду S'L напрямую.

```cpp
void ExecuteSQL(LPCTSTR lpszSQL);
```

### <a name="parameters"></a>Параметры

*lpszS'L*<br/>
Указатель на нулевую строку, содержащую действительную команду S'L для выполнения. Вы можете пройти [CString](../../atl-mfc-shared/reference/cstringt-class.md).

### <a name="remarks"></a>Remarks

Создайте команду в виде строки с нулевым завершением. `ExecuteSQL`не возвращает записи данных. Если вы хотите работать на записях, вместо этого используйте объект записи.

Большинство команд для источника данных выдаются через объекты записей, которые поддерживают команды для выбора данных, вставки новых записей, удаляния записей и редактирования записей. Тем не менее, не все функции ODBC напрямую поддерживаются классами баз данных, поэтому иногда может потребоваться прямой вызов с `ExecuteSQL`помощью s'L.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDatabase#13](../../mfc/codesnippet/cpp/cdatabase-class_4.cpp)]

## <a name="cdatabasegetbookmarkpersistence"></a><a name="getbookmarkpersistence"></a>CDatabase::GetBookmarkPersistenceenceenceence

Вызовите эту функцию-член, чтобы определить наличие закладок в объекте recordset после определенных операций.

```
DWORD GetBookmarkPersistence() const;
```

### <a name="return-value"></a>Возвращаемое значение

Битовая маска, определяющая операции, при выполнении которых закладки сохраняются в объекте recordset. Дополнительные сведения см. в разделе "Заметки".

### <a name="remarks"></a>Remarks

Например, если вызвать метод `CRecordset::GetBookmark`, а затем вызвать`CRecordset::Requery`, закладка, полученная от `GetBookmark`, может быть недействительной. Перед вызовом `GetBookmarkPersistence` следует вызвать метод `CRecordset::SetBookmark`.

В следующей таблице перечислены значения битовой маски, которые можно объединять для возвращаемого значения `GetBookmarkPersistence`.

|Значение битовой маски|Сохранение закладки|
|-------------------|--------------------------|
|SQL_BP_CLOSE|Закладки действительны `Requery` после операции.|
|SQL_BP_DELETE|Закладка для строки действительна после `Delete` операции на этом ряду.|
|SQL_BP_DROP|Закладки действительны `Close` после операции.|
|SQL_BP_SCROLL|Закладки действительны `Move` после любой операции. Этот параметр просто определяет, поддерживаются ли закладки для объекта recordset в соответствии со значением, возвращенным `CRecordset::CanBookmark`.|
|SQL_BP_TRANSACTION|Закладки являются действительными после фиксации или отката транзакции.|
|SQL_BP_UPDATE|Закладка для строки действительна после `Update` операции на этом ряду.|
|SQL_BP_OTHER_HSTMT|Закладки, связанные с одним объектом recordset, действительны для второго объекта recordset.|

Для получения дополнительной информации об этом значении `SQLGetInfo` возврата см. Для получения дополнительной информации о [Recordset: Bookmarks and Absolute Positions (ODBC)](../../data/odbc/recordset-bookmarks-and-absolute-positions-odbc.md)закладках, см.

## <a name="cdatabasegetconnect"></a><a name="getconnect"></a>CDatabase::GetConnect

Вызов этой функции участника для извлечения `OpenEx` строки соединения, используемой во время вызова или `Open` подключенной `CDatabase` к объекту к источнику данных.

```
const CString GetConnect() const;
```

### <a name="return-value"></a>Возвращаемое значение

Const **const**[CString,](../../atl-mfc-shared/reference/cstringt-class.md) содержащий строку соединения, если `OpenEx` или `Open` был вызван; в противном случае, пустая строка.

### <a name="remarks"></a>Remarks

Смотрите [CDatabase:: Открыть](#open) для описания того, как строка соединения создается.

## <a name="cdatabasegetcursorcommitbehavior"></a><a name="getcursorcommitbehavior"></a>CDatabase::GetCursorCommitBehavior

Вызовите эту функцию участника, чтобы определить, как операция [CommitTrans](#committrans) влияет на курсоры на открытых объектах набора записей.

```
int GetCursorCommitBehavior() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение, указывающее влияние транзакций на открытые объекты регистрации. Дополнительные сведения см. в разделе "Заметки".

### <a name="remarks"></a>Remarks

В следующей таблице перечислены `GetCursorCommitBehavior` возможные значения возврата и соответствующее влияние на открытый набор записей.

|Возвращаемое значение|Влияние на объекты CRecordset|
|------------------|----------------------------------|
|SQL_CB_CLOSE|Позвоните `CRecordset::Requery` сразу после совершения транзакции.|
|SQL_CB_DELETE|Позвоните `CRecordset::Close` сразу после совершения транзакции.|
|SQL_CB_PRESERVE|Приступить к `CRecordset` работе в обычном режиме.|

Для получения дополнительной информации об этом значении `SQLGetInfo` возврата см. Для получения дополнительной информации [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)о транзакциях см.

## <a name="cdatabasegetcursorrollbackbehavior"></a><a name="getcursorrollbackbehavior"></a>CDatabase::GetCursorRollbackBehavior

Вызовите эту функцию участника, чтобы определить, как операция [отката](#rollback) влияет на курсоры на открытых объектах набора записей.

```
int GetCursorRollbackBehavior() const;
```

### <a name="return-value"></a>Возвращаемое значение

Значение, указывающее влияние транзакций на открытые объекты регистрации. Дополнительные сведения см. в разделе "Заметки".

### <a name="remarks"></a>Remarks

В следующей таблице перечислены `GetCursorRollbackBehavior` возможные значения возврата и соответствующее влияние на открытый набор записей.

|Возвращаемое значение|Влияние на объекты CRecordset|
|------------------|----------------------------------|
|SQL_CB_CLOSE|Звоните `CRecordset::Requery` сразу после отката транзакции.|
|SQL_CB_DELETE|Звоните `CRecordset::Close` сразу после отката транзакции.|
|SQL_CB_PRESERVE|Приступить к `CRecordset` работе в обычном режиме.|

Для получения дополнительной информации об этом значении `SQLGetInfo` возврата см. Для получения дополнительной информации [Transaction (ODBC)](../../data/odbc/transaction-odbc.md)о транзакциях см.

## <a name="cdatabasegetdatabasename"></a><a name="getdatabasename"></a>CDatabase:GetDatabaseName

Вызовите эту функцию участника для получения имени подключенной в настоящее время базы данных (при условии, что источник данных определяет названный объект под названием "база данных").

```
CString GetDatabaseName() const;
```

### <a name="return-value"></a>Возвращаемое значение

[CString,](../../atl-mfc-shared/reference/cstringt-class.md) содержащий имя базы данных в случае успеха; в противном `CString`случае, пустой .

### <a name="remarks"></a>Remarks

Это не то же самое, что имя источника данных (DSN), указанное в вызове `OpenEx` или `Open` вызове. Что `GetDatabaseName` возвращается зависит от ODBC. Как правило, база данных представляет собой набор таблиц. Если у этой сущности есть имя, `GetDatabaseName` возвращает его.

Например, вы можете отобразить это имя в заголовке. Если ошибка возникает при извлечении `GetDatabaseName` имени из `CString`ODBC, возвращается пустой .

## <a name="cdatabaseisopen"></a><a name="isopen"></a>CDatabase::IsOpen

Вызовите эту функцию `CDatabase` участника, чтобы определить, подключен ли объект в настоящее время к источнику данных.

```
BOOL IsOpen() const;
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, `CDatabase` если объект в настоящее время подключен; в противном случае 0.

## <a name="cdatabasem_hdbc"></a><a name="m_hdbc"></a>CDatabase::m_hdbc

Содержит общедоступную ручку к соединению источника данных ODBC - "ручке соединения".

### <a name="remarks"></a>Remarks

Как правило, у вас не будет необходимости напрямую получать доступ к этой переменной участника. Вместо этого фреймворк выделяет `OpenEx` `Open`ручку при вызове или. Рамочная система разделит ручку при вызове оператора **удаления** на объекте. `CDatabase` Обратите внимание, что функция `Close` члена не разлагает ручку.

Однако при некоторых обстоятельствах вам может потребоваться использовать ручку напрямую. Например, если вам нужно вызвать функции ODBC `CDatabase`API напрямую, а не через класс, вам может понадобиться ручка соединения, чтобы пройти в качестве параметра. Ниже приведен пример кода.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDatabase#15](../../mfc/codesnippet/cpp/cdatabase-class_5.cpp)]

## <a name="cdatabaseonsetoptions"></a><a name="onsetoptions"></a>CDatabase:OnsetOptions

Платформа вызывает эту функцию участника при непосредственном выполнения `ExecuteSQL` оператора S'L с функцией участника.

```
virtual void OnSetOptions(HSTMT hstmt);
```

### <a name="parameters"></a>Параметры

*hstmt*<br/>
Обработка оператора ODBC для того, какие параметры устанавливаются.

### <a name="remarks"></a>Remarks

`CRecordset::OnSetOptions`также вызывает эту функцию члена.

`OnSetOptions`устанавливает значение тайм-аута входа. Если были предыдущие вызовы `SetQueryTimeout` к функции и функции члена, `OnSetOptions` отражает текущие значения; в противном случае он устанавливает значения по умолчанию.

> [!NOTE]
> До MFC 4.2 `OnSetOptions` также устанавливайте режим обработки либо снизронусным, либо асинхронным. Начиная с MFC 4.2, все операции синхронны. Для выполнения асинхронной операции необходимо сделать прямой вызов `SQLSetPos`функции ODBC API.

Вам не нужно переопределять, `OnSetOptions` чтобы изменить значение тайм-аута. Вместо этого, чтобы настроить значение тайм-аута запроса, позвоните `SetQueryTimeout` перед созданием набора записей; `OnSetOptions` будет использовать новое значение. Значения, установленные, применяются к последующим операциям на всех рекордных наборах или прямых вызовах S'L.

Переопределение, `OnSetOptions` если вы хотите установить дополнительные опции. Переопределение должно вызывать базовый класс `OnSetOptions` до или после вызова `SQLSetStmtOption`функции ODBC API. Следуйте методу, иллюстрированному в `OnSetOptions`реализации платформы по умолчанию .

## <a name="cdatabaseopen"></a><a name="open"></a>CDatabase::Открыто

Вызовите эту функцию участника, `CDatabase` чтобы инициализировать недавно построенный объект.

```
virtual BOOL Open(
    LPCTSTR lpszDSN,
    BOOL bExclusive = FALSE,
    BOOL bReadOnly = FALSE,
    LPCTSTR lpszConnect = _T("ODBC;"),
    BOOL bUseCursorLib = TRUE);
```

### <a name="parameters"></a>Параметры

*lpszDSN*<br/>
Укравит имя источника данных - имя, зарегистрированное в ODBC через программу администратора ODBC. Если значение DSN указано в *lpszConnect* (в форме\<"DSN" источник данных>), оно не должно быть указано снова в *lpszDSN*. В этом случае *lpszDSN* должен быть NULL. В противном случае, вы можете передать NULL, если вы хотите представить пользователю диалоговую коробку Источника данных, в которой пользователь может выбрать источник данных. Для получения дополнительной информации см.

*bЭксклюзив*<br/>
Не поддерживается в этой версии библиотеки классов. В настоящее время утверждение не удается, если этот параметр является правдой. Источник данных всегда открывается как общий (не эксклюзивный).

*bReadOnly*<br/>
ПРАВДА, если вы намереваетесь, что соединение будет прочитано только и запретить обновления источника данных. Все зависимые записи наследуют этот атрибут. Значение по умолчанию — FALSE.

*lpszConnect*<br/>
Определяет строку соединения. Строка соединения конкатирует информацию, возможно, включая имя источника данных, идентификатор пользователя, действительный на источнике данных, строку проверки подлинности пользователя (пароль, если источник данных требует одного), и другую информацию. Вся строка соединения должна быть закреплена строкой "ODBC;" (верхний или нижний регистр). Строка "ODBC;" используется для указания на то, что подключение к источнику данных ODBC; это для восходящей совместимости, когда будущие версии библиотеки класса могут поддерживать не-ODBC источников данных.

*bUseCursorLib*<br/>
Правда, если вы хотите ODBC Cursor библиотека DLL будет загружен. Библиотека курсора маскирует некоторую функциональность базового драйвера ODBC, эффективно предотвращая использование динасетов (если водитель поддерживает их). Единственными курсорами, поддерживаемыми при загрузке библиотеки курсоров, являются статические снимки и курсоры только вперед. Значение по умолчанию — TRUE. Если вы планируете создать объект `CRecordset` записи непосредственно из него, не выходя из него, не следует загружать библиотеку курсора.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если соединение успешно сделано; в противном случае 0, если пользователь выбирает Отмена при представлении диалогового окна с просьбой предоставить дополнительную информацию о подключении. Во всех остальных случаях фреймворк выбрасывает исключение.

### <a name="remarks"></a>Remarks

Объект базы данных должен быть инициализирован, прежде чем вы сможете использовать его для построения объекта, установленного записью.

> [!NOTE]
> Вызов функции члена [OpenEx](#openex) является предпочтительным способом подключения к исходу обмена данными и инициализации объекта базы данных.

Если параметры в `Open` вашем вызове не содержат достаточно информации, чтобы сделать соединение, драйвер ODBC открывает диалоговую будку для получения необходимой информации от пользователя. При вызове `Open`строки подключения, *lpszConnect,* хранится в частном порядке в `CDatabase` объекте и доступна, вызывая функцию участника [GetConnect.](#getconnect)

Если вы хотите, вы можете открыть свой `Open` собственный диалоговый ящик, прежде чем звонить, чтобы получить информацию `Open`от пользователя, например пароль, а затем добавить эту информацию в строку соединения вы передаете . Или вы можете сохранить строку соединения, которая проходит, чтобы вы `Open` могли `CDatabase` повторно использовать ее при следующем вызове объекта.

Можно также использовать строку соединения для нескольких уровней авторизации входа (каждый для другого `CDatabase` объекта) или для передачи другой информации, конкретной для источника данных. Для получения дополнительной информации о строках соединения см.

Попытка подключения может быть тайм-аут, если, например, хост DBMS недоступен. Если попытка соединения `Open` не удается, бросает `CDBException`.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDatabase#14](../../mfc/codesnippet/cpp/cdatabase-class_6.cpp)]

## <a name="cdatabaseopenex"></a><a name="openex"></a>CDatabase::OpenEx

Вызовите эту функцию участника, `CDatabase` чтобы инициализировать недавно построенный объект.

```
virtual BOOL OpenEx(
    LPCTSTR lpszConnectString,
    DWORD dwOptions = 0);
```

### <a name="parameters"></a>Параметры

*lpszConnectString*<br/>
Определяет строку соединения ODBC. Это включает в себя имя источника данных, а также другую необязательную информацию, такую как идентификатор пользователя и пароль. Например, "DSN'SQLServer_Source; УИДЗС; PWD'abc123" является возможной строкой соединения. Обратите внимание, что если вы передаете NULL для *lpszConnectString,* диалоговое окно Источника данных подскажет пользователю выбрать источник данных.

*dwOptions*<br/>
Битовая маска, которая определяет сочетание следующих значений. Значение по умолчанию составляет 0, что означает, что база данных будет открыта как общая с доступом к записи, ODBC Cursor Library DLL не будет загружен, а диалоговая коробка соединения ODBC будет отображаться только в том случае, если нет достаточной информации, чтобы сделать соединение.

- `CDatabase::openExclusive`Не поддерживается в этой версии библиотеки классов. Источник данных всегда открывается как общий (не эксклюзивный). В настоящее время утверждение не удается, если вы укажете эту опцию.

- `CDatabase::openReadOnly`Откройте источник данных только для чтения.

- `CDatabase::useCursorLib`Загрузите библиотеку ODBC Cursor DLL. Библиотека курсора маскирует некоторую функциональность базового драйвера ODBC, эффективно предотвращая использование динасетов (если водитель поддерживает их). Единственными курсорами, поддерживаемыми при загрузке библиотеки курсоров, являются статические снимки и курсоры только вперед. Если вы планируете создать объект `CRecordset` записи непосредственно из него, не выходя из него, не следует загружать библиотеку курсора.

- `CDatabase::noOdbcDialog`Не отображайте диалоговую коробку с подключением ODBC, независимо от того, предоставляется ли достаточно информации о подключении.

- `CDatabase::forceOdbcDialog`Всегда отображайте диалоговую коробку с подключением ODBC.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если соединение успешно сделано; в противном случае 0, если пользователь выбирает Отмена при представлении диалогового окна с просьбой предоставить дополнительную информацию о подключении. Во всех остальных случаях фреймворк выбрасывает исключение.

### <a name="remarks"></a>Remarks

Объект базы данных должен быть инициализирован, прежде чем вы сможете использовать его для построения объекта, установленного записью.

Если параметр *lpszConnectString* в `OpenEx` вашем вызове не содержит достаточно информации для подключения, драйвер ODBC открывает диалоговый ящик `CDatabase::noOdbcDialog` для `CDatabase::forceOdbcDialog` получения необходимой информации от пользователя, при условии, что вы не установили или в параметре *dwOptions.* При вызове `OpenEx`строки подключения, *lpszConnectString,* хранится в частном порядке в `CDatabase` объекте и доступен, вызывая функцию участника [GetConnect.](#getconnect)

Если вы хотите, вы можете открыть свой `OpenEx` собственный диалоговый ящик, прежде чем звонить, чтобы получить информацию от `OpenEx`пользователя, например пароль, а затем добавить эту информацию в строку соединения вы передаете . Или вы можете сохранить строку соединения, которая проходит, чтобы вы `OpenEx` могли `CDatabase` повторно использовать ее при следующем вызове объекта.

Можно также использовать строку соединения для нескольких уровней авторизации входа (каждый для другого `CDatabase` объекта) или для передачи другой информации, конкретной для источника данных. Для получения дополнительной информации о строках *ODBC Programmer's Reference*соединения см.

Попытка подключения может быть тайм-аут, если, например, хост DBMS недоступен. Если попытка соединения `OpenEx` не удается, бросает `CDBException`.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCDatabase#11](../../mfc/codesnippet/cpp/cdatabase-class_7.cpp)]

## <a name="cdatabaserollback"></a><a name="rollback"></a>CDatabase::Откат

Вызовите эту функцию участника, чтобы отменить изменения, внесенные во время транзакции.

```
BOOL Rollback();
```

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если транзакция была успешно отменена; в противном случае 0. При `Rollback` сбывании вызова не определенисточник источника данных и состояния транзакции. При `Rollback` возврате 0 необходимо проверить источник данных, чтобы определить его состояние.

### <a name="remarks"></a>Remarks

Все `CRecordset` `AddNew` `Edit`, `Delete`, `Update` и звонки, выполняемые с момента последнего [BeginTrans](#begintrans) откатываются к состоянию, которое существовало во время этого вызова.

После звонка `Rollback`транзакция окончена, и `BeginTrans` вы должны снова позвонить для другой транзакции. Запись, которая была актуальной до `BeginTrans` вызова, `Rollback`становится текущей записью снова после .

После отката запись, которая была текущей до отката, остается актуальной. Подробнее о состоянии рекорда и источнике данных после отката смотрите в статье [Transaction (ODBC).](../../data/odbc/transaction-odbc.md)

### <a name="example"></a>Пример

  Смотрите статью [Транзакция: Выполнение транзакции в наборе рекордов (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md).

## <a name="cdatabasesetlogintimeout"></a><a name="setlogintimeout"></a>CDatabase::SetLoginTimeout

Вызов эту функцию участника `OpenEx` `Open` - до вызова или - переопределить количество секунд, разрешенных до попытки подключения источника данных, время.

```cpp
void SetLoginTimeout(DWORD dwSeconds);
```

### <a name="parameters"></a>Параметры

*dwSeconds*<br/>
Количество секунд, чтобы до попытки соединения разысчасти.

### <a name="remarks"></a>Remarks

Попытка подключения может быть временной, если, например, DBMS недоступна. Звоните `SetLoginTimeout` после построения `CDatabase` неопровержения объекта, но прежде чем вы позвоните `OpenEx` или `Open`.

Значение по умолчанию для тайм-аутов входа составляет 15 секунд. Не все источники данных поддерживают возможность указать значение времени входа. Если источник данных не поддерживает тайм-аут, вы получаете выход трассировки, но не исключение. Значение 0 означает "бесконечный".

## <a name="cdatabasesetquerytimeout"></a><a name="setquerytimeout"></a>CDatabase::Set'ryTimeout

Вызов эту функцию участника, чтобы переопределить число секунд по умолчанию, чтобы позволить до последующих операций на подключенный источник данных тайм-аут.

```cpp
void SetQueryTimeout(DWORD dwSeconds);
```

### <a name="parameters"></a>Параметры

*dwSeconds*<br/>
Количество секунд, которые можно разрешить перед тем, как попытка запроса вычисляет.

### <a name="remarks"></a>Remarks

Операция может быть временной из-за проблем с доступом к сети, чрезмерного времени обработки запросов и так далее. Звоните `SetQueryTimeout` до открытия записи или до вызова `AddNew`функций записи `Update` или `Delete` функций участника, если вы хотите изменить значение тайм-аута запроса. Настройка влияет на `Open` `AddNew`все `Update`последующие, и `Delete` вызывает любые записи, связанные с этим `CDatabase` объектом. Изменение значения тайм-аута запроса для записи после открытия не изменяет значение для записи. Например, `Move` последующие операции не используют новое значение.

Значение по умолчанию для тайм-аутов запроса составляет 15 секунд. Не все источники данных поддерживают возможность установки значения тайм-аута запроса. Если вы установите значение тайм-аута запроса 0, тайм-аут не происходит; связь с источником данных может прекратиться. Такое поведение может быть полезно во время разработки. Если источник данных не поддерживает тайм-аут, вы получаете выход трассировки, но не исключение.

## <a name="see-also"></a>См. также раздел

[Класс CObject](../../mfc/reference/cobject-class.md)<br/>
[Диаграмма иерархии](../../mfc/hierarchy-chart.md)<br/>
[Класс CRecordset](../../mfc/reference/crecordset-class.md)
