---
title: Сведения о приложении и управление им
ms.date: 11/04/2016
helpviewer_keywords:
- applications [MFC], managing
ms.assetid: b72f4154-24db-4e75-bca3-6873e2459c15
ms.openlocfilehash: 934e89d928104c33f0c2038f136b5ad0ca48cbd4
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69507782"
---
# <a name="application-information-and-management"></a>Сведения о приложении и управление им

При написании приложения создается один объект, производный от [CWinApp](../../mfc/reference/cwinapp-class.md). Иногда может потребоваться получить сведения об этом объекте извне объекта, `CWinApp`производного от. Также может потребоваться доступ к другим глобальным объектам "Диспетчер".

Библиотека Microsoft Foundation Class предоставляет следующие глобальные функции, помогающие выполнить эти задачи:

### <a name="application-information-and-management-functions"></a>Сведения о приложении и функции управления

|||
|-|-|
|[афксбегинсреад](#afxbeginthread)|Создает новый поток.|
|[афксконтекстменуманажер](#afxcontextmenumanager)|Указатель на глобальный [Диспетчер контекстных меню](ccontextmenumanager-class.md).|
|[афксендсреад](#afxendthread)|Завершает текущий поток.|
|[афксфиндресаурцехандле](#afxfindresourcehandle)|Просматривает цепочку ресурсов и находит конкретный ресурс по ИДЕНТИФИКАТОРу ресурса и типу ресурса. |
|[AfxFreeLibrary](#afxfreelibrary)|Уменьшает число ссылок загруженного модуля библиотеки динамической компоновки (DLL); Когда счетчик ссылок достигнет нуля, модуль не будет сопоставлен.|
|[афксжетапп](#afxgetapp)|Возвращает указатель на единичный `CWinApp` объект приложения.|
|[афксжетаппнаме](#afxgetappname)|Возвращает строку, содержащую имя приложения.|
|[афксжетинстанцехандле](#afxgetinstancehandle)|Возвращает значение HINSTANCE, представляющее данный экземпляр приложения.|
|[афксжетмаинвнд](#afxgetmainwnd)|Возвращает указатель на текущее окно "Main" приложения, не являющегося приложением OLE, или в окне фрейма на месте серверного приложения.|
|[афксжетперусеррегистратион](#afxgetperuserregistration)|Используйте эту функцию, чтобы определить, будет ли приложение перенаправлять доступ к реестру на узел **HKEY_CURRENT_USER** ( **HKCU**).|
|[афксжетресаурцехандле](#afxgetresourcehandle)|Возвращает значение HINSTANCE для источника ресурсов приложения по умолчанию. Используйте этот параметр для прямого доступа к ресурсам приложения.|
|[афксжетсреад](#afxgetthread)|Извлекает указатель на текущий объект [CWinThread](../../mfc/reference/cwinthread-class.md) .|
|[афксинитричедит](#afxinitrichedit)|Инициализирует элемент управления Rich Edit для приложения версии 1,0.|
|[Требуется метод afxinitrichedit2](#afxinitrichedit2)|Инициализирует для приложения элемент управления редактирования с расширенными возможностями версии 2,0 и более поздних версий.|
|[афксисекстендедфрамекласс](#afxisextendedframeclass)|Определяет, является ли заданное окно расширенным объектом фрейма.|
|[афксисмфктулбар](#afxismfctoolbar)|Определяет, является ли заданное окно объектом панели инструментов.|
|[афкскэйбоардманажер](#afxkeyboardmanager)|Указатель на глобальный [Диспетчер клавиатуры](ckeyboardmanager-class.md).|
|[афкслоадлибрари](#afxloadlibrary)|Сопоставляет модуль DLL и возвращает маркер, который можно использовать для получения адреса функции DLL.|
|[афксменутеароффманажер](#afxmenutearoffmanager)|Указатель на глобальный [Диспетчер меню теарофф](cmenutearoffmanager-class.md).|
|[афксмаусеманажер](#afxmousemanager)|Указатель на глобальный [диспетчер мыши](cmousemanager-class.md).|
|[афксрегистеркласс](#afxregisterclass)|Регистрирует класс окна в библиотеке DLL, использующей MFC.|
|[афксрегистервндкласс](#afxregisterwndclass)|Регистрирует класс окна Windows для дополнения тех, которые автоматически регистрируются MFC.|
|[афкссетперусеррегистратион](#afxsetperuserregistration)|Указывает, будет ли приложение перенаправлять доступ к реестру на узел **HKEY_CURRENT_USER** ( **HKCU**).|
|[афкссетресаурцехандле](#afxsetresourcehandle)|Задает обработчик HINSTANCE, в котором загружаются ресурсы по умолчанию приложения.|
|[афксшеллманажер](#afxshellmanager)|Указатель на глобальный [Диспетчер оболочки](cshellmanager-class.md). |
|[афкссоккетинит](#afxsocketinit)|Вызывается в `CWinApp::InitInstance` переопределении для инициализации сокетов Windows.|
|[афксусертулсманажер](#afxusertoolsmanager)|Указатель на диспетчер глобальных [пользовательских инструментов](cusertoolsmanager-class.md).|
|[афксвининит](#afxwininit)|Вызывается предоставляемой `WinMain` MFC функцией в рамках инициализации [CWinApp](../../mfc/reference/cwinapp-class.md) приложения на основе графического пользовательского интерфейса для инициализации MFC. Должен вызываться напрямую для консольных приложений, использующих MFC.|

##  <a name="afxbeginthread"></a>афксбегинсреад

Вызовите эту функцию, чтобы создать новый поток.

```
CWinThread* AfxBeginThread(
    AFX_THREADPROC pfnThreadProc,
    LPVOID pParam,
    int nPriority = THREAD_PRIORITY_NORMAL,
    UINT nStackSize = 0,
    DWORD dwCreateFlags = 0,
    LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

CWinThread* AfxBeginThread(
    CRuntimeClass* pThreadClass,
    int nPriority = THREAD_PRIORITY_NORMAL,
    UINT nStackSize = 0,
    DWORD dwCreateFlags = 0,
    LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);
```

### <a name="parameters"></a>Параметры

*пфнсреадпрок*<br/>
Указывает на функцию управления для рабочего потока. Не может принимать значение NULL. Эта функция должна быть объявлена следующим образом:

`UINT __cdecl MyControllingFunction( LPVOID pParam );`

*псреадкласс*<br/>
RUNTIME_CLASS объекта, производного от [CWinThread](../../mfc/reference/cwinthread-class.md).

*ппарам*<br/>
Параметр, передаваемый функции управления, как показано в параметре, в объявление функции в *пфнсреадпрок*.

*нприорити*<br/>
Желаемый приоритет потока. Полный список и описание доступных приоритетов см. в разделе [сетсреадприорити](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority) в Windows SDK.

*нстакксизе*<br/>
Задает размер стека в байтах для нового потока. Если значение равно 0, то размер стека по умолчанию совпадает с размером стека создания потока.

*двкреатефлагс*<br/>
Задает дополнительный флаг, управляющий созданием потока. Этот флаг может содержать одно из двух значений:

- CREATE_SUSPENDED. Запустите поток с числом приостановки, равным одному. Используйте CREATE_SUSPENDED, если хотите инициализировать любые данные `CWinThread` элементов объекта, например [m_bAutoDelete](../../mfc/reference/cwinthread-class.md#m_bautodelete) , или все члены производного класса перед запуском потока. После завершения инициализации используйте команду [CWinThread:: ресумесреад](../../mfc/reference/cwinthread-class.md#resumethread) , чтобы запустить поток. Поток не будет выполняться до `CWinThread::ResumeThread` вызова метода.

- **0** . Запустите поток сразу после создания.

*лпсекуритяттрс*<br/>
Указывает на структуру [SECURITY_ATTRIBUTES](/previous-versions/windows/desktop/legacy/aa379560\(v=vs.85\)) , указывающую атрибуты безопасности для потока. Если значение равно NULL, будут использоваться те же атрибуты безопасности, что и при создании потока. Дополнительные сведения об этой структуре см. в Windows SDK.

### <a name="return-value"></a>Возвращаемое значение

Указатель на только что созданный объект потока или значение NULL, если происходит сбой.

### <a name="remarks"></a>Примечания

Первая форма `AfxBeginThread` создает рабочий поток. Вторая форма создает поток, который может выступать в качестве потока пользовательского интерфейса или рабочего потока.

`AfxBeginThread`создает новый `CWinThread` объект, вызывает его функцию [CreateThread](../../mfc/reference/cwinthread-class.md#createthread) , чтобы начать исполнение потока, и возвращает указатель на поток. Проверки выполняются на протяжении всей процедуры, чтобы убедиться, что все объекты освобождены должным образом, в случае сбоя любой части создания. Чтобы завершить поток, вызовите [афксендсреад](#afxendthread) из потока или вернитесь из управляющей функции рабочего потока.

Многопоточность должна быть включена приложением; в противном случае эта функция завершится ошибкой. Дополнительные сведения о включении многопоточности см. в разделе [/MD,/MT,/LD (использование библиотеки времени выполнения)](../../build/reference/md-mt-ld-use-run-time-library.md) в *параметрах C++ компилятора Visual*.

Дополнительные сведения `AfxBeginThread`о см. в статье [многопоточность. Создание рабочих потоков](../../parallel/multithreading-creating-worker-threads.md) и [многопоточность: Создание потоков](../../parallel/multithreading-creating-user-interface-threads.md)пользовательского интерфейса.

### <a name="example"></a>Пример

См. пример для [CSocket:: Attach](../../mfc/reference/csocket-class.md#attach).

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

## <a name="afxcontextmenumanager"></a>афксконтекстменуманажер

Указатель на глобальный [Диспетчер контекстных меню](ccontextmenumanager-class.md).

### <a name="syntax"></a>Синтаксис

```
CContextMenuManager* afxContextMenuManager;
```

### <a name="requirements"></a>Требования

**Заголовок:** афксконтекстменуманажер. h

##  <a name="afxendthread"></a>афксендсреад

Вызовите эту функцию, чтобы завершить выполняющийся в данный момент поток.

```
void AFXAPI AfxEndThread(
    UINT nExitCode,
    BOOL bDelete  = TRUE);
```

### <a name="parameters"></a>Параметры

*некситкоде*<br/>
Указывает код выхода потока.

*бделете*<br/>
Удаляет объект потока из памяти.

### <a name="remarks"></a>Примечания

Должен вызываться из потока для завершения.

Дополнительные сведения `AfxEndThread`о см. в статье [многопоточность. Завершение потоков](../../parallel/multithreading-terminating-threads.md).

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

  ## <a name="afxfindresourcehandle"></a>AfxFindResourceHandle
Используйте `AfxFindResourceHandle` для прохода по цепочке ресурсов и нахождение определенного ресурса по идентификатору ресурса и типу ресурса.

### <a name="syntax"></a>Синтаксис

```
HINSTANCE AFXAPI AfxFindResourceHandle( LPCTSTR lpszName,  LPCTSTR lpszType );
```

### <a name="parameters"></a>Параметры

*лпсзнаме*<br/>
Указатель на строку, содержащую идентификатор ресурса.
*лпсзтипе*<br/>
Указатель на тип ресурса. Список типов ресурсов см. в разделе [FindResource](/windows/win32/api/winbase/nf-winbase-findresourcew) в Windows SDK.

### <a name="return-value"></a>Возвращаемое значение

Обработчик для модуля, содержащего ресурс.

### <a name="remarks"></a>Примечания

`AfxFindResourceHandle`находит конкретный ресурс и возвращает маркер модуля, содержащего ресурс. Ресурс может находиться в любой загруженной библиотеке DLL расширения MFC. `AfxFindResourceHandle`Указывает, какой из них имеет ресурс.

Поиск модулей выполняется в следующем порядке:

1. Основной модуль (если это библиотека DLL расширения MFC).

1. Несистемные модули.

1. Модули, зависящие от языка.

1. Основной модуль (если это системная библиотека DLL).

1. Системные модули.

### <a name="requirements"></a>Требования

**Заголовок:** afxwin.h

##  <a name="afxfreelibrary"></a>AfxFreeLibrary

`AfxFreeLibrary` И`AfxLoadLibrary` поддерживают счетчик ссылок для каждого загруженного модуля библиотеки.

```
BOOL AFXAPI AfxFreeLibrary(HINSTANCE hInstLib);
```

### <a name="parameters"></a>Параметры

*хинстлиб*<br/>
Маркер загруженного модуля библиотеки. [Афкслоадлибрари](#afxloadlibrary) возвращает этот маркер.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если функция выполнена. в противном случае — значение FALSE.

### <a name="remarks"></a>Примечания

`AfxFreeLibrary`уменьшает число ссылок загруженного модуля библиотеки динамической компоновки (DLL). Когда счетчик ссылок достигает нуля, модуль не сопоставляется с адресным пространством вызывающего процесса, и этот маркер становится недействительным. Этот счетчик ссылок увеличивается каждый раз, когда `AfxLoadLibrary` вызывается.

Перед удалением сопоставления модуля библиотеки система позволяет библиотеке DLL отсоединяться от процессов, использующих ее. Это дает библиотеке DLL возможность очищать ресурсы, выделенные от имени текущего процесса. После возврата функции точки входа модуль библиотеки удаляется из адресного пространства текущего процесса.

Используйте `AfxLoadLibrary` для отображения модуля DLL.

Обязательно используйте `AfxFreeLibrary` и `AfxLoadLibrary` (вместо функций `FreeLibrary` Win32 и `LoadLibrary`), если приложение использует несколько потоков. Использование `AfxLoadLibrary` и`AfxFreeLibrary` гарантирует, что код запуска и завершения работы, выполняемый при загрузке и выгрузке библиотеки DLL расширения MFC, не повреждает глобальное состояние MFC.

### <a name="example"></a>Пример

См. пример для [афкслоадлибрари](#afxloadlibrary).

### <a name="requirements"></a>Требования

  **Заголовок** AFXDLL_. h

##  <a name="afxgetapp"></a>афксжетапп

Указатель, возвращаемый этой функцией, может использоваться для доступа к сведениям о приложении, таким как основной код диспетчеризации сообщений или самое верхнее окно.

```
CWinApp* AFXAPI AfxGetApp();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на один `CWinApp` объект для приложения.

### <a name="remarks"></a>Примечания

Если этот метод возвращает значение NULL, это может означать, что главное окно приложения еще не полностью инициализировано. Это также может указывать на проблему.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#126](../../mfc/reference/codesnippet/cpp/application-information-and-management_1.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxgetappname"></a>афксжетаппнаме

Строку, возвращаемую этой функцией, можно использовать для диагностических сообщений или как корневую папку для имен временных строк.

```
LPCTSTR AFXAPI AfxGetAppName();
```

### <a name="return-value"></a>Возвращаемое значение

Строка, заканчивающаяся нулем и содержащая имя приложения.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#127](../../mfc/reference/codesnippet/cpp/application-information-and-management_2.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxgetinstancehandle"></a>афксжетинстанцехандле

Эта функция позволяет получить экземпляр обработчика текущего приложения.

```
HINSTANCE  AFXAPI AfxGetInstanceHandle();
```

### <a name="return-value"></a>Возвращаемое значение

Значение HINSTANCE для текущего экземпляра приложения. Если вызывается из библиотеки DLL, связанной с УСРДЛЛ версией MFC, возвращается значение HINSTANCE для библиотеки DLL.

### <a name="remarks"></a>Примечания

`AfxGetInstanceHandle`всегда возвращает значение HINSTANCE для исполняемого файла (. EXE), если это не вызвано из библиотеки DLL, связанной с УСРДЛЛ версией MFC. В этом случае он возвращает значение HINSTANCE для библиотеки DLL.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#128](../../mfc/reference/codesnippet/cpp/application-information-and-management_3.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxgetmainwnd"></a>афксжетмаинвнд

Если приложение является сервером OLE, вызовите эту функцию, чтобы получить указатель на активное главное окно приложения, а не напрямую ссылаться на элемент [m_pMainWnd](../../mfc/reference/cwinthread-class.md#m_pmainwnd) объекта Application.

```
CWnd* AFXAPI AfxGetMainWnd();
```

### <a name="return-value"></a>Возвращаемое значение

Если сервер содержит объект, который находится в контейнере и активен внутри контейнера, и этот контейнер активен, эта функция возвращает указатель на объект окна фрейма, содержащий активный документ на месте.

Если в контейнере отсутствует объект, активный в месте, или ваше приложение не является сервером OLE, эта функция просто возвращает *m_pMainWnd* объекта приложения.

Если `AfxGetMainWnd` вызывается из основного потока приложения, он возвращает главное окно приложения согласно приведенным выше правилам. Если функция вызывается из вторичного потока в приложении, функция возвращает главное окно, связанное с потоком, который выполнил вызов.

### <a name="remarks"></a>Примечания

Если приложение не является сервером OLE, то вызов этой функции эквивалентен непосредственному обращению к члену *m_pMainWnd* объекта приложения.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#129](../../mfc/reference/codesnippet/cpp/application-information-and-management_4.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxgetperuserregistration"></a>афксжетперусеррегистратион

Используйте эту функцию, чтобы определить, будет ли приложение перенаправлять доступ к реестру на узел **HKEY_CURRENT_USER** ( **HKCU**).

```
BOOL AFXAPI AfxGetPerUserRegistration();
```

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE указывает, что данные реестра направляются на узел HKCU; Значение FALSE указывает, что приложение записывает сведения о реестре в узел по умолчанию. Узел по умолчанию — **HKEY_CLASSES_ROOT** ( **HKCR**).

### <a name="remarks"></a>Примечания

Если включить перенаправление реестра, платформа перенаправит доступ из **HKCR** в **HKEY_CURRENT_USER\SOFTWARE\Classes**. Перенаправление затрагивает только платформы MFC и ATL.

Чтобы изменить, будет ли приложение перенаправлено на доступ к реестру, используйте [афкссетперусеррегистратион](#afxsetperuserregistration).

### <a name="requirements"></a>Требования

  **Заголовок** afxstat_. h

##  <a name="afxgetresourcehandle"></a>афксжетресаурцехандле

Используйте маркер HINSTANCE, возвращенный этой функцией, для доступа к ресурсам приложения напрямую, например, в вызовах функции `FindResource`Windows.

```
extern HINSTANCE  AfxGetResourceHandle();
```

### <a name="return-value"></a>Возвращаемое значение

Обработчик HINSTANCE, в котором загружаются ресурсы по умолчанию приложения.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#130](../../mfc/reference/codesnippet/cpp/application-information-and-management_5.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxgetthread"></a>афксжетсреад

Вызовите эту функцию, чтобы получить указатель на объект [CWinThread](../../mfc/reference/cwinthread-class.md) , представляющий выполняющийся в данный момент поток.

```
CWinThread* AfxGetThread();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на выполняющийся в данный момент поток; в противном случае — NULL.

### <a name="remarks"></a>Примечания

Должен вызываться из нужного потока.

> [!NOTE]
>  При `AfxGetThread` переносе проекта MFC, вызывающего из Visual C++ Versions 4,2, 5,0 или 6,0, вызывает `AfxGetThread` [афксжетапп](#afxgetapp) , если поток не найден. В более поздних версиях компилятора возвращает значение `AfxGetThread` null, если поток не найден. Если требуется поток приложения, необходимо вызвать `AfxGetApp`.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#132](../../mfc/reference/codesnippet/cpp/application-information-and-management_6.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxinitrichedit"></a>афксинитричедит

Вызовите эту функцию, чтобы инициализировать элемент управления Rich Edit (версия 1,0) для приложения.

```
BOOL AFXAPI AfxInitRichEdit();
```

### <a name="remarks"></a>Примечания

Эта функция предоставляется для обеспечения обратной совместимости. Новые приложения должны использовать [требуется метод afxinitrichedit2](#afxinitrichedit2).

`AfxInitRichEdit`загружает RICHED32. DLL для инициализации элемента управления расширенного редактирования версии 1,0. Чтобы использовать версию 2,0 и 3,0 элемента управления Rich Edit, библиотеки RICHED20. Необходимо загрузить библиотеку DLL. Это выполняется с помощью вызова [требуется метод afxinitrichedit2](#afxinitrichedit2).

Чтобы обновить элементы управления Rich Edit в существующих C++ визуальных приложениях до версии 2,0, откройте. RC-файла в виде текста измените имя класса для каждого элемента управления Rich Edit с "RICHEDIT" на "RichEdit20a". Затем замените вызов на `AfxInitRichEdit`. `AfxInitRichEdit2`

Эта функция также инициализирует библиотеку Common Controls, если библиотека еще не была инициализирована для процесса. Если вы используете элемент управления Rich Edit непосредственно из приложения MFC, следует вызвать эту функцию, чтобы убедиться в том, что MFC правильно Инициализирует среду выполнения элемента управления Rich Edit. При вызове метода Create для [CRichEditCtrl](../../mfc/reference/cricheditctrl-class.md), [CRichEditView](../../mfc/reference/cricheditview-class.md)или [CRichEditDoc](../../mfc/reference/cricheditdoc-class.md)обычно не требуется вызывать эту функцию, но в некоторых случаях это может потребоваться.

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxinitrichedit2"></a>Требуется метод afxinitrichedit2

Вызывайте эту функцию для инициализации элемента управления Rich Edit (версии 2,0 и более поздней) для приложения.

```
BOOL AFXAPI AfxInitRichEdit2();
```

### <a name="remarks"></a>Примечания

Вызовите эту функцию, чтобы загрузить библиотеки RICHED20. DLL и инициализация версии 2,0 элемента управления Rich Edit. При вызове метода Create для [CRichEditCtrl](../../mfc/reference/cricheditctrl-class.md), [CRichEditView](../../mfc/reference/cricheditview-class.md)или [CRichEditDoc](../../mfc/reference/cricheditdoc-class.md)обычно не требуется вызывать эту функцию, но в некоторых случаях это может потребоваться.

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

  ## <a name="afxisextendedframeclass"></a>афксисекстендедфрамекласс
Определяет, является ли заданное окно расширенным объектом фрейма.

### <a name="syntax"></a>Синтаксис

```
BOOL AFXAPI AfxIsExtendedFrameClass( CWnd* pWnd );
```

### <a name="parameters"></a>Параметры

*Приводится*<br/>
окне Указатель на объект, производный от `CWnd`.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если предоставленное окно является расширенным объектом Frame; в противном случае — FALSE.

### <a name="remarks"></a>Примечания

Этот метод возвращает значение TRUE, если *приводится* является производным от одного из следующих классов:

- `CFrameWndEx`

- `CMDIFrameWndEx`

- `COleIPFrameWndEx`

- `COleDocIPFrameWndEx`

- `CMDIChildWndEx`

Этот метод полезен, когда требуется проверить, что параметр функции или метода является окном расширенного фрейма.

### <a name="requirements"></a>Требования

**Заголовок:** afxpriv.h

## <a name="afxismfctoolbar"></a>афксисмфктулбар

Определяет, является ли заданное окно объектом панели инструментов.

### <a name="syntax"></a>Синтаксис

```
BOOL AFXAPI AfxIsMFCToolBar(CWnd* pWnd);
```

### <a name="parameters"></a>Параметры

*Приводится*<br/>
окне Указатель на объект, производный от `CWnd`.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если предоставленное окно является объектом панели инструментов; в противном случае — FALSE.

### <a name="remarks"></a>Примечания

Этот метод возвращает `TRUE` значение, если *приводится* является `CMFCToolBar`производным от. Этот метод полезен при проверке того, что параметр функции или метода является `CMFCToolBar` объектом.

### <a name="requirements"></a>Требования

**Заголовок:** afxpriv.h

## <a name="afxkeyboardmanager"></a>афкскэйбоардманажер

Указатель на глобальный [Диспетчер клавиатуры](ckeyboardmanager-class.md).

### <a name="syntax"></a>Синтаксис

```
CKeyboardManager* afxKeyboardManager;
```

### <a name="requirements"></a>Требования

**Заголовок:** афкскэйбоардманажер. h

##  <a name="afxloadlibrary"></a>афкслоадлибрари

Используйте `AfxLoadLibrary` для отображения модуля DLL.

```
HINSTANCE AFXAPI AfxLoadLibrary(LPCTSTR lpszModuleName);
```

### <a name="parameters"></a>Параметры

*лпсзмодуленаме*<br/>
Указывает на строку, завершающуюся нулем, которая содержит имя модуля (или. DLL или. EXE-файл). Указанное имя является именем файла модуля.

Если строка указывает путь, но файл не существует в указанном каталоге, функция завершается ошибкой.

Если путь не указан и расширение имени файла пропущено, используется расширение по умолчанию. DLL добавляется. Однако строка filename может содержать символ завершающей точки (.), указывающий, что имя модуля не имеет расширения. Если путь не указан, функция выполняет поиск файла в следующей последовательности:

- Каталог, из которого загружено приложение.

- Текущий каталог.

- **Windows 95/98:** Системный каталог Windows. **Windows NT:** 32-разрядный системный каталог Windows. Имя этого каталога — SYSTEM32.

- **Только Windows NT:** 16-разрядный системный каталог Windows. Отсутствует функция Win32, которая получает путь к этому каталогу, но ищет его. Имя этого каталога — SYSTEM.

- Каталог Windows.

- Каталоги, перечисленные в переменной среды PATH.

### <a name="return-value"></a>Возвращаемое значение

Если функция выполнена, возвращаемое значение является обработчиком модуля. Если функция завершается ошибкой, возвращается значение NULL.

### <a name="remarks"></a>Примечания

Он возвращает маркер, который можно использовать в [GetProcAddress](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) для получения адреса функции DLL. `AfxLoadLibrary`также может использоваться для отображения других исполняемых модулей.

Каждый процесс поддерживает счетчик ссылок для каждого загруженного модуля библиотеки. Этот счетчик ссылок увеличивается каждый раз `AfxLoadLibrary` , когда вызывается и уменьшается каждый раз. `AfxFreeLibrary` Когда счетчик ссылок достигает нуля, модуль не сопоставляется с адресным пространством вызывающего процесса, и этот маркер становится недействительным.

Обязательно используйте `AfxLoadLibrary` и `AfxFreeLibrary` (вместо функций `LoadLibrary` Win32 и `FreeLibrary`), если приложение использует несколько потоков и динамически загружает библиотеку DLL расширения MFC. С `AfxLoadLibrary` помощью `AfxFreeLibrary` и гарантируется, что код запуска и завершения работы, выполняемый при загрузке и выгрузке библиотеки DLL расширения MFC, не повреждает глобальное состояние MFC.

Для `AfxLoadLibrary` использования в приложении требуется динамическая привязка к DLL-версии MFC; заголовочный файл для `AfxLoadLibrary`, Afxdll_. h, включается, только если MFC связан с приложением в качестве библиотеки DLL. Это связано с тем, что для использования или создания библиотек DLL расширения MFC необходимо создать ссылку на DLL-версию MFC.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFC_DLLUser#1](../../mfc/reference/codesnippet/cpp/application-information-and-management_7.cpp)]
[!code-cpp[NVC_MFC_DLLUser#2](../../mfc/reference/codesnippet/cpp/application-information-and-management_8.cpp)]
[!code-cpp[NVC_MFC_DLLUser#3](../../mfc/reference/codesnippet/cpp/application-information-and-management_9.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXDLL_. h

## <a name="afxmenutearoffmanager"></a>афксменутеароффманажер

Указатель на глобальный [Диспетчер меню теарофф](cmenutearoffmanager-class.md).

### <a name="syntax"></a>Синтаксис

```
CMenuTearOffManager* g_pTearOffMenuManager;
```

### <a name="requirements"></a>Требования

**Заголовок:** афксменутеароффманажер. h

## <a name="afxmousemanager"></a>афксмаусеманажер

Указатель на глобальный [диспетчер мыши](cmousemanager-class.md).

### <a name="syntax"></a>Синтаксис

```
CMouseManager* afxMouseManager;
```

### <a name="requirements"></a>Требования

**Заголовок:** афксмаусеманажер. h

##  <a name="afxregisterclass"></a>афксрегистеркласс

Эта функция используется для регистрации классов окон в библиотеке DLL, использующей MFC.

```
BOOL AFXAPI AfxRegisterClass(WNDCLASS* lpWndClass);
```

### <a name="parameters"></a>Параметры

*лпвндкласс*<br/>
Указатель на структуру [вндкласс](/windows/win32/api/winuser/ns-winuser-wndclassw) , содержащую сведения о классе окна для регистрации. Дополнительные сведения об этой структуре см. в Windows SDK.

### <a name="return-value"></a>Возвращаемое значение

Значение TRUE, если класс успешно зарегистрирован; в противном случае — FALSE.

### <a name="remarks"></a>Примечания

При использовании этой функции класс автоматически отменяет регистрацию при выгрузке библиотеки DLL.

В сборках, отличных от `AfxRegisterClass` DLL, идентификатор определяется как макрос, сопоставляемый с функцией `RegisterClass`Windows, так как классы, зарегистрированные в приложении, автоматически не регистрируются. Если вы используете `AfxRegisterClass` `RegisterClass`вместо, код можно использовать без изменения как в приложении, так и в библиотеке DLL.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFC_DLL#3](../../atl-mfc-shared/codesnippet/cpp/application-information-and-management_10.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxregisterwndclass"></a>афксрегистервндкласс

Позволяет регистрировать собственные классы окон.

```
LPCTSTR AFXAPI AfxRegisterWndClass(
    UINT nClassStyle,
    HCURSOR hCursor = 0,
    HBRUSH hbrBackground = 0,
    HICON hIcon = 0);
```

### <a name="parameters"></a>Параметры

*нклассстиле*<br/>
Задает стиль класса Windows или сочетание стилей, созданных с помощью оператора побитового или ( **&#124;** ) для класса окна. Список стилей классов см. в разделе Структура [вндкласс](/windows/win32/api/winuser/ns-winuser-wndclassw) в Windows SDK. Если значение равно NULL, значения по умолчанию будут установлены следующим образом:

- Задает для стиля мыши значение CS_DBLCLKS, которое отправляет сообщения двойного щелчка в процедуру окна, когда пользователь дважды щелкает мышью.

- Задает стиль курсора со стрелкой к стандарту Windows IDC_ARROW.

- Устанавливает значение NULL для фоновой кисти, поэтому окно не будет очищать свой фон.

- Задает значок стандартного машет-флага эмблемы Windows.

*хкурсор*<br/>
Задает обработчик для ресурса курсора, который должен быть установлен в каждом окне, созданном из класса Window. Если используется значение по умолчанию **0**, будет получен стандартный курсор IDC_ARROW.

*хбрбаккграунд*<br/>
Задает дескриптор ресурса кисти, который должен быть установлен в каждом окне, созданном из класса Window. Если вы используете значение по умолчанию **0**, то у вас будет пустая кисть фона, и окно по умолчанию не будет стирать фон при обработке [WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd).

*hIcon*<br/>
Задает маркер для ресурса значка, который должен быть установлен в каждом окне, созданном из класса Window. Если вы используете значение по умолчанию **0**, то получите стандартный значок логотипа Windows машет.

### <a name="return-value"></a>Возвращаемое значение

Строка, заканчивающаяся нулем и содержащая имя класса. Это имя `Create` класса можно передать функции-члену в `CWnd` или других классах, производных **от CWnd**, для создания окна. Имя создается библиотека Microsoft Foundation Class.

> [!NOTE]
>  Возвращаемое значение является указателем на статический буфер. Чтобы сохранить эту строку, присвойте ее `CString` переменной.

### <a name="remarks"></a>Примечания

Библиотека Microsoft Foundation Class автоматически регистрирует несколько стандартных классов окон. Вызывайте эту функцию, если требуется зарегистрировать собственные классы окон.

Имя, зарегистрированное для класса, `AfxRegisterWndClass` зависит только от параметров. Если несколько раз `AfxRegisterWndClass` вызывается с одинаковыми параметрами, то он регистрируется только при первом вызове. Последующие вызовы `AfxRegisterWndClass` с идентичными параметрами просто возвращают уже зарегистрированное значение ClassName.

При вызове `AfxRegisterWndClass` нескольких классов, производных от CWnd, с одинаковыми параметрами вместо того, чтобы получать отдельный класс окна для каждого класса, каждый класс использует один и тот же класс окна. Это может вызвать проблемы при использовании стиля класса CS_CLASSDC. Вместо нескольких классов окон CS_CLASSDC вы используете один класс окон CS_CLASSDC, и все C++ окна, использующие этот класс, имеют общий доступ к одному и тому же контроллеру домена. Чтобы избежать этой проблемы, вызовите [афксрегистеркласс](#afxregisterclass) , чтобы зарегистрировать класс.

См. Технические примечания [TN001: Регистрация](../../mfc/tn001-window-class-registration.md) класса окна для получения дополнительных сведений о регистрации класса окна `AfxRegisterWndClass` и функции.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#134](../../mfc/reference/codesnippet/cpp/application-information-and-management_11.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

##  <a name="afxsetperuserregistration"></a>афкссетперусеррегистратион

Указывает, будет ли приложение перенаправлять доступ к реестру на узел **HKEY_CURRENT_USER** ( **HKCU**).

```
void AFXAPI AfxSetPerUserRegistration(BOOL bEnable);
```

### <a name="parameters"></a>Параметры

*bEnable*<br/>
окне Значение TRUE указывает, что данные реестра направляются на узел HKCU; Значение FALSE указывает, что приложение записывает сведения о реестре в узел по умолчанию. Узел по умолчанию — **HKEY_CLASSES_ROOT** ( **HKCR**).

### <a name="remarks"></a>Примечания

До Windows Vista приложения, которые обращаются к реестру, обычно используют узел **HKEY_CLASSES_ROOT** . Однако в Windows Vista или более поздних операционных системах необходимо запустить приложение в режиме с повышенными правами для записи в раздел HKCR.

Этот метод позволяет приложению выполнять чтение и запись в реестр без запуска в режиме с повышенными правами путем перенаправления доступа к реестру из раздела HKCR в HKCU. Дополнительные сведения см. в разделе [Linker Property Pages](../../build/reference/linker-property-pages.md).

Если включить перенаправление реестра, платформа перенаправит доступ из HKCR в **HKEY_CURRENT_USER\SOFTWARE\Classes**. Перенаправление затрагивает только платформы MFC и ATL.

Реализация по умолчанию обращается к реестру в разделе HKCR.

### <a name="requirements"></a>Требования

  **Заголовок** afxstat_. h

##  <a name="afxsetresourcehandle"></a>афкссетресаурцехандле

Эта функция используется для задания обработчика HINSTANCE, который определяет, где загружаются ресурсы по умолчанию приложения.

```
void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource);
```

### <a name="parameters"></a>Параметры

*хинстресаурце*<br/>
Обработчик экземпляра или модуля для. Файл EXE или DLL, из которого загружаются ресурсы приложения.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCWindowing#135](../../mfc/reference/codesnippet/cpp/application-information-and-management_12.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

## <a name="afxshellmanager"></a>афксшеллманажер

Указатель на глобальный [Диспетчер оболочки](cshellmanager-class.md).

### <a name="syntax"></a>Синтаксис

```
CShellManager* afxShellManager;
```

### <a name="requirements"></a>Требования

**Заголовок:** афксшеллманажер. h

##  <a name="afxsocketinit"></a>афкссоккетинит

Вызовите эту функцию в `CWinApp::InitInstance` переопределении для инициализации сокетов Windows.

```
BOOL AfxSocketInit(WSADATA* lpwsaData = NULL);
```

### <a name="parameters"></a>Параметры

*лпвсадата*<br/>
Указатель на структуру [всадата](/windows/win32/api/winsock2/ns-winsock2-wsadata) . Если *лпвсадата* не равно null, адрес `WSADATA` структуры заполняется вызовом метода. `WSAStartup` Эта функция также гарантирует, `WSACleanup` что она будет вызываться перед завершением работы приложения.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Примечания

При использовании сокетов MFC во вторичных потоках в статическом связанном приложении MFC необходимо вызвать `AfxSocketInit` в каждом потоке, использующем сокеты для инициализации библиотек сокетов. По умолчанию `AfxSocketInit` метод вызывается только в основном потоке.

### <a name="requirements"></a>Требования

  **Заголовок** афкссокк. h

## <a name="afxusertoolsmanager"></a>афксусертулсманажер

Указатель на диспетчер глобальных [пользовательских инструментов](cusertoolsmanager-class.md).

### <a name="syntax"></a>Синтаксис

```
CUserToolsManager* afxUserToolsManager;
```

### <a name="requirements"></a>Требования

**Заголовок:** афксусертулсманажер. h

##  <a name="afxwininit"></a>афксвининит

Эта функция вызывается предоставляемой `WinMain` MFC функцией в рамках инициализации [CWinApp](../../mfc/reference/cwinapp-class.md) приложения на основе графического пользовательского интерфейса для инициализации MFC.

```
BOOL AFXAPI AfxWinInit(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR lpCmdLine,
    int nCmdShow);
```

### <a name="parameters"></a>Параметры

*hInstance*<br/>
Маркер выполняющегося в данный момент модуля.

*хпревинстанце*<br/>
Маркер предыдущего экземпляра приложения. Для приложения на основе Win32 этот параметр всегда имеет **значение NULL**.

*лпкмдлине*<br/>
Указывает на строку, завершающуюся нулем, указывая командную строку для приложения.

*нкмдшов*<br/>
Указывает, как будет отображаться главное окно приложения с графическим пользовательским интерфейсом.

### <a name="remarks"></a>Примечания

Для консольного приложения, которое не использует предоставляемую `WinMain` MFC функцию, необходимо напрямую вызывать `AfxWinInit` для инициализации MFC.

Если вы вызываете `AfxWinInit` себя самостоятельно, следует объявить экземпляр `CWinApp` класса. Для консольного приложения вы можете не создавать собственный класс из `CWinApp` и вместо этого использовать `CWinApp` экземпляр напрямую. Этот метод подходит, если вы решили оставить все функциональные возможности для своего приложения в реализации **Main**.

> [!NOTE]
>  При создании контекста активации для сборки MFC использует ресурс манифеста, предоставленный модулем пользователя. Контекст активации создается в `AfxWinInit`. Дополнительные сведения см. [в разделе Поддержка контекстов активации в состоянии модуля MFC](../../mfc/support-for-activation-contexts-in-the-mfc-module-state.md).

### <a name="example"></a>Пример

[!code-cpp[NVC_MFC_AfxWinInit#1](../../mfc/reference/codesnippet/cpp/application-information-and-management_13.cpp)]

### <a name="requirements"></a>Требования

  **Заголовок** AFXWIN. h

## <a name="see-also"></a>См. также

[Макросы и глобальные](mfc-macros-and-globals.md)<br/>
[Класс CWinApp](cwinapp-class.md)<br/>
[Класс CContextMenuManager](ccontextmenumanager-class.md)<br/>
[Класс CWnd](cwnd-class.md)<br/>
[Класс CFrameWndEx](cframewndex-class.md)<br/>
[Класс CMFCToolBar](cmfctoolbar-class.md)<br/>
[Класс CKeyboardManager](ckeyboardmanager-class.md)<br/>
[Класс CMenuTearOffManager](cmenutearoffmanager-class.md)<br/>
[Класс CMouseManager](cmousemanager-class.md)<br/>
[Класс CShellManager](cshellmanager-class.md)<br/>
[Класс CUserToolsManager](cusertoolsmanager-class.md)
