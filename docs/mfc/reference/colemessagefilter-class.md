---
description: 'Дополнительные сведения о: Колемессажефилтер Class'
title: Класс Колемессажефилтер
ms.date: 11/04/2016
f1_keywords:
- COleMessageFilter
- AFXOLE/COleMessageFilter
- AFXOLE/COleMessageFilter::COleMessageFilter
- AFXOLE/COleMessageFilter::BeginBusyState
- AFXOLE/COleMessageFilter::EnableBusyDialog
- AFXOLE/COleMessageFilter::EnableNotRespondingDialog
- AFXOLE/COleMessageFilter::EndBusyState
- AFXOLE/COleMessageFilter::OnMessagePending
- AFXOLE/COleMessageFilter::Register
- AFXOLE/COleMessageFilter::Revoke
- AFXOLE/COleMessageFilter::SetBusyReply
- AFXOLE/COleMessageFilter::SetMessagePendingDelay
- AFXOLE/COleMessageFilter::SetRetryReply
helpviewer_keywords:
- COleMessageFilter [MFC], COleMessageFilter
- COleMessageFilter [MFC], BeginBusyState
- COleMessageFilter [MFC], EnableBusyDialog
- COleMessageFilter [MFC], EnableNotRespondingDialog
- COleMessageFilter [MFC], EndBusyState
- COleMessageFilter [MFC], OnMessagePending
- COleMessageFilter [MFC], Register
- COleMessageFilter [MFC], Revoke
- COleMessageFilter [MFC], SetBusyReply
- COleMessageFilter [MFC], SetMessagePendingDelay
- COleMessageFilter [MFC], SetRetryReply
ms.assetid: b1fd1639-fac4-4fd0-bf17-15172deba13c
ms.openlocfilehash: f0ab1d473704f5355933c04072a195c12fb71c73
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97226900"
---
# <a name="colemessagefilter-class"></a>Класс Колемессажефилтер

Управляет параллелизмом, требуемым для взаимодействия приложений OLE.

## <a name="syntax"></a>Синтаксис

```
class COleMessageFilter : public CCmdTarget
```

## <a name="members"></a>Члены

### <a name="public-constructors"></a>Открытые конструкторы

|name|Описание|
|----------|-----------------|
|[Колемессажефилтер:: Колемессажефилтер](#colemessagefilter)|Формирует объект `COleMessageFilter`.|

### <a name="public-methods"></a>Открытые методы

|name|Описание|
|----------|-----------------|
|[Колемессажефилтер:: Бегинбусистате](#beginbusystate)|Переводит приложение в состояние Busy.|
|[Колемессажефилтер:: Енаблебусидиалог](#enablebusydialog)|Включает и отключает диалоговое окно, отображаемое при занятости вызванного приложения.|
|[Колемессажефилтер:: Енабленотреспондингдиалог](#enablenotrespondingdialog)|Включает и отключает диалоговое окно, которое появляется, когда вызываемое приложение не отвечает.|
|[Колемессажефилтер:: Ендбусистате](#endbusystate)|Прерывает занятое состояние приложения.|
|[Колемессажефилтер:: Онмессажепендинг](#onmessagepending)|Вызывается платформой для обработки сообщений во время выполнения вызова OLE.|
|[Колемессажефилтер:: Register](#register)|Регистрирует фильтр сообщений в системных библиотеках DLL OLE.|
|[Колемессажефилтер:: REVOKE](#revoke)|Отменяет регистрацию фильтра сообщений в библиотеках DLL системы OLE.|
|[Колемессажефилтер:: Сетбусирепли](#setbusyreply)|Определяет ответ занятого приложения на вызов OLE.|
|[Колемессажефилтер:: Сетмессажепендингделай](#setmessagependingdelay)|Определяет, как долго приложение ожидает ответа на вызов OLE.|
|[Колемессажефилтер:: Сетретрирепли](#setretryreply)|Определяет ответ вызывающего приложения на занятое приложение.|

## <a name="remarks"></a>Комментарии

`COleMessageFilter`Класс полезен в приложениях Visual Edit Server и Container, а также в приложениях OLE-автоматизации. Для вызываемых серверных приложений этот класс можно использовать для того, чтобы приложение «занято», чтобы входящие вызовы из других приложений контейнера были либо отменены, либо повторены позже. Этот класс также можно использовать для определения действия, выполняемого вызывающим приложением, когда вызванное приложение занято.

Часто используется для того, чтобы серверное приложение вызывало [бегинбусистате](#beginbusystate) и [ендбусистате](#endbusystate) , когда оно опасно для уничтожения документа или другого объекта, доступного для OLE. Эти вызовы выполняются в методе [CWinApp:: OnIdle](../../mfc/reference/cwinapp-class.md#onidle) при обновлении пользовательского интерфейса.

По умолчанию `COleMessageFilter` объект выделяется при инициализации приложения. Его можно получить с помощью [афксолежетмессажефилтер](application-control.md#afxolegetmessagefilter).

Это расширенный класс; Вам редко приходится работать с ним напрямую.

Дополнительные сведения см. в статье [серверы: реализация сервера](../../mfc/servers-implementing-a-server.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

`COleMessageFilter`

## <a name="requirements"></a>Требования

**Заголовок:** афксоле. h

## <a name="colemessagefilterbeginbusystate"></a><a name="beginbusystate"></a> Колемессажефилтер:: Бегинбусистате

Вызовите эту функцию, чтобы начать занятое состояние.

```
virtual void BeginBusyState();
```

### <a name="remarks"></a>Комментарии

Он работает совместно с [ендбусистате](#endbusystate) для управления состоянием занятости приложения. Функция [сетбусирепли](#setbusyreply) определяет ответ приложения на вызов приложений, когда оно занято.

Объект `BeginBusyState` и `EndBusyState` вызывает метод Increment и декремента соответственно счетчику, который определяет, занято ли приложение. Например, два вызова `BeginBusyState` и один вызов по `EndBusyState` -прежнему будут иметь состояние Busy. Чтобы отменить занятое состояние, необходимо вызвать `EndBusyState` то же количество вызовов, которое `BeginBusyState` было вызвано.

По умолчанию платформа переходит в состояние занятости во время обработки простоя, которое выполняется с помощью [CWinApp:: OnIdle](../../mfc/reference/cwinapp-class.md#onidle). Несмотря на то, что приложение обрабатывает ON_COMMANDUPDATEUI уведомления, входящие вызовы обрабатываются позже после завершения обработки простоя.

## <a name="colemessagefiltercolemessagefilter"></a><a name="colemessagefilter"></a> Колемессажефилтер:: Колемессажефилтер

Создает объект `COleMessageFilter`.

```
COleMessageFilter();
```

## <a name="colemessagefilterenablebusydialog"></a><a name="enablebusydialog"></a> Колемессажефилтер:: Енаблебусидиалог

Включает и отключает диалоговое окно Busy, которое отображается при истечении срока ожидания сообщения (см. [сетретрирепли](#setretryreply)) во время вызова OLE.

```cpp
void EnableBusyDialog(BOOL bEnableBusy = TRUE);
```

### <a name="parameters"></a>Параметры

*бенаблебуси*<br/>
Указывает, включено ли или отключено диалоговое окно "занято".

## <a name="colemessagefilterenablenotrespondingdialog"></a><a name="enablenotrespondingdialog"></a> Колемессажефилтер:: Енабленотреспондингдиалог

Включает и отключает диалоговое окно "не отвечает", которое отображается при ожидании сообщения клавиатуры или мыши во время вызова OLE и превышения времени ожидания вызова.

```cpp
void EnableNotRespondingDialog(BOOL bEnableNotResponding = TRUE);
```

### <a name="parameters"></a>Параметры

*бенабленотреспондинг*<br/>
Указывает, включено ли или отключено диалоговое окно "не отвечает".

## <a name="colemessagefilterendbusystate"></a><a name="endbusystate"></a> Колемессажефилтер:: Ендбусистате

Вызовите эту функцию для завершения занятого состояния.

```
virtual void EndBusyState();
```

### <a name="remarks"></a>Комментарии

Он работает совместно с [бегинбусистате](#beginbusystate) для управления состоянием занятости приложения. Функция [сетбусирепли](#setbusyreply) определяет ответ приложения на вызов приложений, когда оно занято.

Объект `BeginBusyState` и `EndBusyState` вызывает метод Increment и декремента соответственно счетчику, который определяет, занято ли приложение. Например, два вызова `BeginBusyState` и один вызов по `EndBusyState` -прежнему будут иметь состояние Busy. Чтобы отменить занятое состояние, необходимо вызвать `EndBusyState` то же количество вызовов, которое `BeginBusyState` было вызвано.

По умолчанию платформа переходит в состояние занятости во время обработки простоя, которое выполняется с помощью [CWinApp:: OnIdle](../../mfc/reference/cwinapp-class.md#onidle). Пока приложение обрабатывает ON_UPDATE_COMMAND_UI уведомления, входящие вызовы обрабатываются после завершения обработки простоя.

## <a name="colemessagefilteronmessagepending"></a><a name="onmessagepending"></a> Колемессажефилтер:: Онмессажепендинг

Вызывается платформой для обработки сообщений во время выполнения вызова OLE.

```
virtual BOOL OnMessagePending(const MSG* pMsg);
```

### <a name="parameters"></a>Параметры

*пмсг*<br/>
Указатель на ожидающее сообщение.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если операция выполнена успешно; в противном случае — значение 0.

### <a name="remarks"></a>Комментарии

Когда вызывающее приложение ожидает завершения вызова, платформа вызывает `OnMessagePending` с указателем на ожидающее сообщение. По умолчанию платформа отправляет WM_PAINT сообщения, поэтому обновление окна может выполняться во время вызова, которое занимает много времени.

Необходимо зарегистрировать фильтр сообщений с помощью вызова для [регистрации](#register) , прежде чем он станет активным.

## <a name="colemessagefilterregister"></a><a name="register"></a> Колемессажефилтер:: Register

Регистрирует фильтр сообщений в системных библиотеках DLL OLE.

```
BOOL Register();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если операция выполнена успешно; в противном случае — значение 0.

### <a name="remarks"></a>Комментарии

Фильтр сообщений не действует, если он не зарегистрирован в системных библиотеках DLL. Обычно код инициализации приложения регистрирует фильтр сообщений приложения. Любой другой фильтр сообщений, зарегистрированный приложением, должен быть отозван до завершения программы с помощью вызова [REVOKE](#revoke).

Фильтр сообщений платформы по умолчанию автоматически регистрируется во время инициализации и отзывается при завершении.

## <a name="colemessagefilterrevoke"></a><a name="revoke"></a> Колемессажефилтер:: REVOKE

Отменяет предыдущую регистрацию, выполненную путем вызова функции [Register](#register).

```cpp
void Revoke();
```

### <a name="remarks"></a>Комментарии

Перед завершением программы необходимо отозвать фильтр сообщений.

Фильтр сообщений по умолчанию, который автоматически создается и регистрируется платформой, также автоматически отзывается.

## <a name="colemessagefiltersetbusyreply"></a><a name="setbusyreply"></a> Колемессажефилтер:: Сетбусирепли

Эта функция задает для приложения "занятый ответ".

```cpp
void SetBusyReply(SERVERCALL nBusyReply);
```

### <a name="parameters"></a>Параметры

*нбусирепли*<br/>
Значение из `SERVERCALL` перечисления, которое определено в компобж. H. Он может иметь одно из следующих значений:

- SERVERCALL_ISHANDLED приложение может принимать вызовы, но может завершиться ошибкой при обработке определенного вызова.

- SERVERCALL_REJECTED приложение, вероятно, никогда не сможет обработать вызов.

- SERVERCALL_RETRYLATER приложение временно находится в состоянии, в котором оно не может обработать вызов.

### <a name="remarks"></a>Комментарии

Функции [бегинбусистате](#beginbusystate) и [ендбусистате](#endbusystate) управляют состоянием занятости приложения.

Когда приложение было загружено с помощью вызова `BeginBusyState` , оно реагирует на вызовы из библиотек DLL системы OLE со значением, определенным в последнем задании `SetBusyReply` . Вызывающее приложение использует этот ответ, чтобы определить, какое действие следует предпринять.

По умолчанию занятый ответ является SERVERCALL_RETRYLATER. Этот ответ заставляет вызывающее приложение повторить вызов как можно скорее.

## <a name="colemessagefiltersetmessagependingdelay"></a><a name="setmessagependingdelay"></a> Колемессажефилтер:: Сетмессажепендингделай

Определяет, как долго вызывающее приложение ждет ответа от вызываемого приложения перед выполнением дальнейших действий.

```cpp
void SetMessagePendingDelay(DWORD nTimeout = 5000);
```

### <a name="parameters"></a>Параметры

*нтимеаут*<br/>
Количество миллисекунд для задержки в сообщении.

### <a name="remarks"></a>Комментарии

Эта функция работает совместно с [сетретрирепли](#setretryreply).

## <a name="colemessagefiltersetretryreply"></a><a name="setretryreply"></a> Колемессажефилтер:: Сетретрирепли

Определяет действие вызывающего приложения при получении занятого ответа от вызванного приложения.

```cpp
void SetRetryReply(DWORD nRetryReply = 0);
```

### <a name="parameters"></a>Параметры

*нретрирепли*<br/>
Число миллисекунд между повторными попытками.

### <a name="remarks"></a>Комментарии

Если вызываемое приложение указывает, что оно занято, вызывающее приложение может ожидать, пока сервер не будет занят, повторить попытку или повторить попытку через указанный интервал. Он также может решить, что вызов полностью отменен.

Ответ вызывающего объекта управляется функциями `SetRetryReply` и [сетмессажепендингделай](#setmessagependingdelay). `SetRetryReply` Определяет, как долго вызывающее приложение должно ожидать между повторными попытками для данного вызова. `SetMessagePendingDelay` Определяет, как долго вызывающее приложение ждет ответа от сервера, прежде чем предпринимать дальнейшие действия.

Обычно значения по умолчанию приемлемы, и их не нужно изменять. Платформа повторяет вызов каждые *нретрирепли* миллисекунд, пока вызов не пройдет через или не истечет время ожидания сообщения. Значение 0 для *нретрирепли* указывает немедленную попытку повтора, а-1 — отмену вызова.

По истечении срока ожидания сообщения появляется диалоговое окно "занято" OLE "(см. [колебусидиалог](../../mfc/reference/colebusydialog-class.md)), чтобы пользователь мог выбрать отмену или повторить вызов. Вызовите [енаблебусидиалог](#enablebusydialog) , чтобы включить или отключить это диалоговое окно.

Если во время вызова ожидается сообщение клавиатуры или мыши, и истекло время ожидания вызова (превышение задержки сообщения), откроется диалоговое окно "не отвечает". Вызовите [енабленотреспондингдиалог](#enablenotrespondingdialog) , чтобы включить или отключить это диалоговое окно. Обычно это состояние дел указывает на то, что что-то пошло не так, и пользователь получает Нештатное подключение.

Когда диалоговые окна отключены, текущий ответ "повторная попытка" всегда используется для вызовов занятых приложений.

## <a name="see-also"></a>См. также раздел

[Класс от CCmdTarget](../../mfc/reference/ccmdtarget-class.md)<br/>
[Иерархическая диаграмма](../../mfc/hierarchy-chart.md)<br/>
[Класс от CCmdTarget](../../mfc/reference/ccmdtarget-class.md)
