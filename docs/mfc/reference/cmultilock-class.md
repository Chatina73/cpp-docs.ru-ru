---
title: Класс CMultiLock
ms.date: 11/04/2016
f1_keywords:
- CMultiLock
- AFXMT/CMultiLock
- AFXMT/CMultiLock::CMultiLock
- AFXMT/CMultiLock::IsLocked
- AFXMT/CMultiLock::Lock
- AFXMT/CMultiLock::Unlock
helpviewer_keywords:
- CMultiLock [MFC], CMultiLock
- CMultiLock [MFC], IsLocked
- CMultiLock [MFC], Lock
- CMultiLock [MFC], Unlock
ms.assetid: c5b7c78b-1f81-4387-b7dd-2c813c5b6b61
ms.openlocfilehash: 27c0eb396ac1384b691f51bf7089f6820157cf8a
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50613425"
---
# <a name="cmultilock-class"></a>Класс CMultiLock

Класс представляет механизм контроля доступа к ресурсам в многопоточных программах.

## <a name="syntax"></a>Синтаксис

```
class CMultiLock
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CMultiLock::CMultiLock](#cmultilock)|Создает объект `CMultiLock`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CMultiLock::IsLocked](#islocked)|Определяет, если объект определенного синхронизации в массиве блокируется.|
|[CMultiLock::Lock](#lock)|Ожиданий в массиве объектов синхронизации.|
|[CMultiLock::Unlock](#unlock)|Освобождает все объекты принадлежащий синхронизации.|

## <a name="remarks"></a>Примечания

`CMultiLock` не имеет базового класса.

Использование классов синхронизации [CSemaphore](../../mfc/reference/csemaphore-class.md), [CMutex](../../mfc/reference/cmutex-class.md), и [CEvent](../../mfc/reference/cevent-class.md), можно создать либо `CMultiLock` или [CSingleLock](../../mfc/reference/csinglelock-class.md)объект для ожидания и освободить объект синхронизации. Использовать `CMultiLock` при наличии нескольких объектов, которые можно использовать в определенное время. Используйте `CSingleLock` при только необходимо подождать на один объект за раз.

Чтобы использовать `CMultiLock` следует сначала создать массив объектов синхронизации, которые вы хотите ожидания. Затем вызовите `CMultiLock` конструктор объекта внутри функции-члена в классе управляемой ресурса. Затем вызовите [блокировки](#lock) функцию-член для определения доступности ресурса (сигнал). Если он, по-прежнему дальнейшим функции-члена. Если ресурс не доступен, подождите в течение определенного времени для освобождения ресурса либо сбой запроса. После завершения использования ресурса, либо вызвать [Unlock](#unlock) работать, если `CMultiLock` объекта будет использоваться повторно, или разрешение `CMultiLock` уничтожаемого объекта.

`CMultiLock` объектов наиболее полезны, когда потоку большое количество `CEvent` может реагировать на объекты. Создайте массив, содержащий все `CEvent` указатели и вызов `Lock`. В результате поток ждать, пока одно из событий переводится в сигнальное состояние.

Дополнительные сведения об использовании `CMultiLock` объектов, см. в статье [Многопоточность: Практическое использование классов синхронизации](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`CMultiLock`

## <a name="requirements"></a>Требования

**Заголовок:** afxmt.h

##  <a name="cmultilock"></a>  CMultiLock::CMultiLock

Создает объект `CMultiLock`.

```
CMultiLock(
    CSyncObject* ppObjects [ ],
    DWORD dwCount,
    BOOL bInitialLock = FALSE);
```

### <a name="parameters"></a>Параметры

*ppObjects*<br/>
Массив указателей на объекты синхронизации, чтобы использовать для ожидания. Не может принимать значение NULL.

*dwCount*<br/>
Число объектов в *ppObjects*. Должно быть больше 0.

*bInitialLock*<br/>
Указывает необходимость изначально пытаются получить доступ к любому из предоставленных объектов.

### <a name="remarks"></a>Примечания

Эта функция вызывается после создания массива объектов синхронизации, чтобы использовать для ожидания. Она обычно вызывается из потока, который необходимо дождаться завершения одного объектов синхронизации, которые становятся доступными.

##  <a name="islocked"></a>  CMultiLock::IsLocked

Определяет, является ли указанный объект несигнальное (недоступна).

```
BOOL IsLocked(DWORD dwItem);
```

### <a name="parameters"></a>Параметры

*dwItem*<br/>
Индекс в массиве объектов, соответствующий объекту, состояние которого выполняется запрос.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если указанный объект заблокирован; в противном случае 0.

##  <a name="lock"></a>  CMultiLock::Lock

Вызывайте эту функцию для получения доступа к одному или нескольким из ресурсы, управляемые объекты синхронизации, передаваемые `CMultiLock` конструктор.

```
DWORD Lock(
    DWORD dwTimeOut = INFINITE,
    BOOL bWaitForAll = TRUE,
    DWORD dwWakeMask = 0);
```

### <a name="parameters"></a>Параметры

*dwTimeOut*<br/>
Указывает время ожидания объекта синхронизации доступен (сигнал). Если БЕСКОНЕЧНЫЙ, `Lock` будет ждать объект переводится в сигнальное состояние перед возвратом.

*bWaitForAll*<br/>
Указывает, должны принять сигнал для ожидания всех объектов, в то же время перед возвратом. Если значение равно FALSE, `Lock` возвращает, если один из объектов, для ожидания переводится в сигнальное состояние.

*dwWakeMask*<br/>
Указывает другие условия, которые могут прервать ожидание. Полный список доступных параметров для этого параметра, см. в разделе [MsgWaitForMultipleObjects](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) в пакете Windows SDK.

### <a name="return-value"></a>Возвращаемое значение

Если `Lock` завершается ошибкой, возвращается - 1. В случае успешного выполнения возвращает одно из следующих значений:

- Между WAIT_OBJECT_0 и WAIT_OBJECT_0 + (число объектов - 1)

   Если *bWaitForAll* имеет значение TRUE, все объекты получают сигнал (доступно). Если *bWaitForAll* имеет значение FALSE, возвращаемое значение — WAIT_OBJECT_0, — это индекс в массиве объектов объекта, который получает сигналы (доступно).

- WAIT_OBJECT_0 + (число объектов)

   Событие, указанное в *dwWakeMask* доступна во входной очереди для потока.

- Между WAIT_ABANDONED_0 и WAIT_ABANDONED_0 + (число объектов - 1)

   Если *bWaitForAll* имеет значение TRUE, все объекты получают сигнал и по крайней мере один из объектов — это объект Брошенный мьютекс. Если *bWaitForAll* имеет значение FALSE, возвращаемое значение — WAIT_ABANDONED_0 — это индекс в массиве объектов Брошенный мьютекс объекта, удовлетворившего операцию ожидания.

- WAIT_TIMEOUT

   Интервал времени ожидания, указанный в *dwTimeOut* истек срок действия без ожидания успешного.

### <a name="remarks"></a>Примечания

Если *bWaitForAll* имеет значение TRUE, `Lock` вернет успешно, как только все объекты синхронизации сигнальное одновременно. Если *bWaitForAll* имеет значение FALSE, `Lock` вернет сразу же оповещенным, один или несколько объектов синхронизации.

Если `Lock` не сможет выполнять возврат немедленно, он будет ожидать не более указанного числа миллисекунд в *dwTimeOut* параметра перед возвратом. Если *dwTimeOut* является бесконечность, `Lock` не вернет, пока не получили доступ к объекту или условие, заданное в *dwWakeMask* было выполнено. В противном случае, если `Lock` было нельзя получить объект синхронизации, будет возвращена успешно; в противном случае возвращается ошибка.

##  <a name="unlock"></a>  CMultiLock::Unlock

Освобождает объект синхронизации, принадлежащий `CMultiLock`.

```
BOOL Unlock();

BOOL Unlock(
    LONG lCount,
    LPLONG lPrevCount = NULL);
```

### <a name="parameters"></a>Параметры

*lCount*<br/>
Номер ссылки счетчики для выпуска. Должно быть больше 0. Если указанного, приводит к превышению допустимого объекта счетчиком, счетчик не изменяется, и функция возвращает значение FALSE.

*lPrevCount*<br/>
Указывает переменную для получения счетчика для объекта синхронизации. Если значение равно NULL, возвращаются счетчика.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае 0.

### <a name="remarks"></a>Примечания

Эта функция вызывается `CMultiLock`в деструктор.

В первой форме `Unlock` пытается разблокировать объект синхронизации, управляемый `CMultiLock`. Вторая форма `Unlock` пытается разблокировать `CSemaphore` объекты, принадлежащие `CMultiLock`. Если `CMultiLock` не владеет заблокированные `CSemaphore` объект, функция возвращает FALSE; в противном случае возвращает значение TRUE. *lCount* и *lpPrevCount* точно совпадают с параметрами [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#unlock). Вторая форма `Unlock` редко применяется к multilock ситуациях.

## <a name="see-also"></a>См. также

[Диаграмма иерархии](../../mfc/hierarchy-chart.md)

