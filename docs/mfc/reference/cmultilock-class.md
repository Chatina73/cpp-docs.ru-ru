---
title: Класс Кмултилокк
ms.date: 11/04/2016
f1_keywords:
- CMultiLock
- AFXMT/CMultiLock
- AFXMT/CMultiLock::CMultiLock
- AFXMT/CMultiLock::IsLocked
- AFXMT/CMultiLock::Lock
- AFXMT/CMultiLock::Unlock
helpviewer_keywords:
- CMultiLock [MFC], CMultiLock
- CMultiLock [MFC], IsLocked
- CMultiLock [MFC], Lock
- CMultiLock [MFC], Unlock
ms.assetid: c5b7c78b-1f81-4387-b7dd-2c813c5b6b61
ms.openlocfilehash: b2fe3ecf2197b8edb13e89600b16e550deff9af2
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69504540"
---
# <a name="cmultilock-class"></a>Класс Кмултилокк

Класс представляет механизм контроля доступа к ресурсам в многопоточных программах.

## <a name="syntax"></a>Синтаксис

```
class CMultiLock
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|name|Описание|
|----------|-----------------|
|[Кмултилокк:: Кмултилокк](#cmultilock)|Создает объект `CMultiLock`.|

### <a name="public-methods"></a>Открытые методы

|name|Описание|
|----------|-----------------|
|[Кмултилокк:: NOLOCK](#islocked)|Определяет, заблокирован ли конкретный объект синхронизации в массиве.|
|[Кмултилокк:: Lock](#lock)|Ожидает массив объектов синхронизации.|
|[Кмултилокк:: Unlock](#unlock)|Освобождает все собственные объекты синхронизации.|

## <a name="remarks"></a>Примечания

`CMultiLock`не имеет базового класса.

Чтобы использовать классы синхронизации [ксемафоре](../../mfc/reference/csemaphore-class.md), [кмутекс](../../mfc/reference/cmutex-class.md)и [цевент](../../mfc/reference/cevent-class.md), можно создать `CMultiLock` объект или [ксинглелокк](../../mfc/reference/csinglelock-class.md) для ожидания и освобождения объекта синхронизации. Используется `CMultiLock` при наличии нескольких объектов, которые можно использовать в определенный момент времени. Используйте `CSingleLock` , когда требуется только один объект за раз.

Чтобы использовать `CMultiLock` объект, сначала создайте массив объектов синхронизации, который вы хотите подождать. Затем вызовите `CMultiLock` конструктор объекта внутри функции-члена в классе контролируемого ресурса. Затем вызовите функцию-член [Lock](#lock) , чтобы определить, доступен ли ресурс (сигнальный). Если таковой имеется, продолжайте работу с оставшейся частью функции-члена. Если ресурс недоступен, подождите в течение указанного промежутка времени для освобождения ресурса или возвратите ошибку. После завершения использования ресурса следует либо вызвать функцию [Unlock](#unlock) , если `CMultiLock` объект будет использоваться повторно `CMultiLock` , либо разрешить уничтожение объекта.

`CMultiLock`объекты наиболее полезны, когда поток имеет большое количество `CEvent` объектов, на которые он может ответить. Создайте массив, содержащий все `CEvent` указатели, и вызовите. `Lock` В результате поток будет ожидать, пока одно из событий не будет сигнальным.

Дополнительные сведения об использовании `CMultiLock` объектов см. в статье [многопоточность. Использование классов](../../parallel/multithreading-how-to-use-the-synchronization-classes.md)синхронизации.

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`CMultiLock`

## <a name="requirements"></a>Требования

**Заголовок:** афксмт. h

##  <a name="cmultilock"></a>Кмултилокк:: Кмултилокк

Создает объект `CMultiLock`.

```
CMultiLock(
    CSyncObject* ppObjects [ ],
    DWORD dwCount,
    BOOL bInitialLock = FALSE);
```

### <a name="parameters"></a>Параметры

*ппобжектс*<br/>
Массив указателей на объекты синхронизации, которые должны быть ожидания. Не может принимать значение NULL.

*двкаунт*<br/>
Количество объектов в *ппобжектс*. Должно быть больше 0.

*бинитиаллокк*<br/>
Указывает, следует ли первоначально пытаться получить доступ к любому из предоставляемых объектов.

### <a name="remarks"></a>Примечания

Эта функция вызывается после создания массива объектов синхронизации для ожидания. Обычно он вызывается из потока, который должен ожидать, пока один из объектов синхронизации не станет доступным.

##  <a name="islocked"></a>Кмултилокк:: NOLOCK

Определяет, является ли указанный объект несигнальным (недоступным).

```
BOOL IsLocked(DWORD dwItem);
```

### <a name="parameters"></a>Параметры

*двитем*<br/>
Индекс в массиве объектов, соответствующий объекту, состояние которого запрашивается.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если указанный объект заблокирован; в противном случае — 0.

##  <a name="lock"></a>Кмултилокк:: Lock

Вызовите эту функцию, чтобы получить доступ к одному или нескольким ресурсам, управляемым объектами синхронизации, предоставленными `CMultiLock` конструктору.

```
DWORD Lock(
    DWORD dwTimeOut = INFINITE,
    BOOL bWaitForAll = TRUE,
    DWORD dwWakeMask = 0);
```

### <a name="parameters"></a>Параметры

*двтимеаут*<br/>
Указывает период времени ожидания доступности объекта синхронизации (сигнальный). В `Lock` случае бесконечности будет ожидать передачи объекта перед возвратом.

*бваитфоралл*<br/>
Указывает, должны ли все объекты ожидать передачи сигнала в одно и то же время перед возвратом. Если значение равно `Lock` false, будет возвращаться, если какой-либо из объектов ожидает передачи сигнала.

*дввакемаск*<br/>
Указывает другие условия, которым разрешено прервать ожидание. Полный список доступных параметров для этого параметра см. в разделе [мсгваитформултиплеобжектс](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects) в Windows SDK.

### <a name="return-value"></a>Возвращаемое значение

В `Lock` случае сбоя возвращается значение-1. В случае успеха возвращается одно из следующих значений:

- Между WAIT_OBJECT_0 и WAIT_OBJECT_0 + (число объектов-1)

   Если *бваитфоралл* имеет значение true, все объекты получают сигнал (доступно). Если *бваитфоралл* имеет значение false, то возвращаемое значение-WAIT_OBJECT_0 является индексом в массиве объектов объекта, на который сообщается (доступно).

- WAIT_OBJECT_0 + (число объектов)

   Событие, указанное в *дввакемаск* , доступно в очереди ввода потока.

- Между WAIT_ABANDONED_0 и WAIT_ABANDONED_0 + (число объектов-1)

   Если *бваитфоралл* имеет значение true, все объекты получают сигнал, а по крайней мере один из объектов является брошенным объектом Mutex. Если *бваитфоралл* имеет значение false, то возвращаемое значение — WAIT_ABANDONED_0 — индекс в массиве объектов брошенного объекта мьютекса, который удовлетворяет ожидания.

- WAIT_TIMEOUT

   Интервал времени ожидания, указанный в *двтимеаут* , истек без ожидания.

### <a name="remarks"></a>Примечания

Если *бваитфоралл* имеет значение true `Lock` , то будет успешно возвращено, как только все объекты синхронизации будут сигнальными одновременно. Если *бваитфоралл* имеет значение false `Lock` , будет возвращаться, как только один или несколько объектов синхронизации становятся сигнальными.

Если `Lock` метод не может вернуть значение немедленно, он будет ожидать не более, чем число миллисекунд, указанное в параметре *двтимеаут* перед возвратом. Если *двтимеаут* имеет бесконечное значение, не возвращает значение, `Lock` пока не будет получен доступ к объекту или было выполнено условие, заданное в *дввакемаск* . В противном `Lock` случае, если удалось получить объект синхронизации, он вернется успешно, а если нет, он возвратит ошибку.

##  <a name="unlock"></a>Кмултилокк:: Unlock

Освобождает объект синхронизации, `CMultiLock`принадлежащий.

```
BOOL Unlock();

BOOL Unlock(
    LONG lCount,
    LPLONG lPrevCount = NULL);
```

### <a name="parameters"></a>Параметры

*lCount*<br/>
Количество счетчиков ссылок для освобождения. Должно быть больше 0. Если указанный объем приведет к превышению максимального значения счетчика объекта, счетчик не изменится и функция вернет значение FALSE.

*лпревкаунт*<br/>
Указывает на переменную для получения предыдущего счетчика для объекта синхронизации. Если значение равно NULL, то предыдущее число не возвращается.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если функция выполнена успешно; в противном случае — 0.

### <a name="remarks"></a>Примечания

Эта функция вызывается `CMultiLock`деструктором.

Первая форма `Unlock` пытается разблокировать объект синхронизации, `CMultiLock`управляемый. Вторая форма `Unlock` пытается `CSemaphore` разблокировать объекты, `CMultiLock`принадлежащие. Если `CMultiLock` не владеет ни одним заблокированным `CSemaphore` объектом, функция возвращает значение false; в противном случае возвращается значение true. *lCount* и *лппревкаунт* в точности совпадают с параметрами [ксинглелокк:: Unlock](../../mfc/reference/csinglelock-class.md#unlock). Вторая форма `Unlock` редко применяется в ситуациях с разблокировками.

## <a name="see-also"></a>См. также

[Диаграмма иерархии](../../mfc/hierarchy-chart.md)
