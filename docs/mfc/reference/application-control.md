---
title: Управление приложением
ms.date: 11/04/2016
helpviewer_keywords:
- application control [MFC]
ms.assetid: c1f69f15-e0fe-4515-9f36-d63d31869deb
ms.openlocfilehash: cb4ad19dfad06b793f226324d8e28c37c084ad67
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79424635"
---
# <a name="application-control"></a>Управление приложением

OLE требует значительного контроля над приложениями и их объектами. Библиотеки DLL системы OLE должны иметь возможность автоматически запускать и освобождать приложения, координировать свои производственные и модификации объектов и т. д. Функции в этом разделе соответствуют этим требованиям. В дополнение к вызову из системных библиотек OLE, эти функции иногда также вызываются приложениями.

### <a name="application-control"></a>Управление приложением

|||
|-|-|
|[афксолеканекситапп](#afxolecanexitapp)|Указывает, может ли приложение завершить работу.|
|[афксолежетмессажефилтер](#afxolegetmessagefilter)|Извлекает текущий фильтр сообщений приложения.|
|[афксолежетусерктрл](#afxolegetuserctrl)|Возвращает текущий флаг пользовательского элемента управления.|
|[афксолесетусерктрл](#afxolesetuserctrl)|Задает или очищает флаг пользовательского элемента управления.|
|[AfxOleLockApp](#afxolelockapp)|Увеличивает глобальное количество активных объектов в приложении платформы.|
|[афксолелоккконтрол](#afxolelockcontrol)| Блокирует фабрику класса указанного элемента управления. |
|[AfxOleUnlockApp](#afxoleunlockapp)|Уменьшает количество активных объектов в приложении на платформе.|
|[афксолеунлоккконтрол](#afxoleunlockcontrol)| Разблокирует фабрику класса указанного элемента управления. |
|[афксолерегистерсерверкласс](#afxoleregisterserverclass)|Регистрирует сервер в системном реестре OLE.|
|[афксолесетедитмену](#afxoleseteditmenu)|Реализует пользовательский интерфейс для команды объекта *TypeName* .|

##  <a name="afxolecanexitapp"></a>афксолеканекситапп

Указывает, может ли приложение завершить работу.

```
BOOL AFXAPI AfxOleCanExitApp();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если приложение может выйти; в противном случае — 0.

### <a name="remarks"></a>Remarks

Приложение не должно завершаться, если имеются необработанные ссылки на объекты. Глобальные функции `AfxOleLockApp` и `AfxOleUnlockApp` инкремент и декремента соответственно — счетчик ссылок на объекты приложения. Приложение не должно завершаться, если этот счетчик не равен нулю. Если значение счетчика не равно нулю, главное окно приложения скрыто (не уничтожается), когда пользователь выбирает пункт Закрыть в меню система или выход из меню файл. Платформа вызывает эту функцию в `CFrameWnd::OnClose`.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAutomation#2](../../mfc/codesnippet/cpp/application-control_1.cpp)]

## <a name="requirements"></a>Требования

**Заголовок**: афксдисп. h

##  <a name="afxolegetmessagefilter"></a>афксолежетмессажефилтер

Извлекает текущий фильтр сообщений приложения.

```
COleMessageFilter* AFXAPI AfxOleGetMessageFilter();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на текущий фильтр сообщений.

### <a name="remarks"></a>Remarks

Вызывайте эту функцию для доступа к текущему объекту, производному `COleMessageFilter`, точно так же, как при вызове `AfxGetApp` для доступа к текущему объекту приложения.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAutomation#3](../../mfc/codesnippet/cpp/application-control_2.cpp)]

[!code-cpp[NVC_MFCAutomation#4](../../mfc/codesnippet/cpp/application-control_3.cpp)]

### <a name="requirements"></a>Требования

**Заголовок**: AFXWIN. h

##  <a name="afxolegetuserctrl"></a>афксолежетусерктрл

Возвращает текущий флаг пользовательского элемента управления.

```
BOOL AFXAPI AfxOleGetUserCtrl();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если пользователь управляет приложением; в противном случае — 0.

### <a name="remarks"></a>Remarks

Пользователь управляет приложением, когда пользователь явно открыл или создал новый документ. Пользователь также управляет, если приложение не было запущено с помощью системных библиотек OLE, иными словами, если пользователь запустил приложение с помощью системной оболочки.

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп. h

##  <a name="afxolesetuserctrl"></a>афксолесетусерктрл

Задает или очищает флаг пользовательского элемента управления, который описывается в справочнике по `AfxOleGetUserCtrl`.

```
void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl);
```

### <a name="parameters"></a>Параметры

*бусерктрл*<br/>
Указывает, должен ли быть установлен или сброшен флаг пользовательского элемента управления.

### <a name="remarks"></a>Remarks

Платформа вызывает эту функцию, когда пользователь создает или загружает документ, но не при загрузке или создании документа с помощью непрямого действия, такого как загрузка внедренного объекта из приложения-контейнера.

Вызывайте эту функцию, если другие действия в приложении должны поместит пользователя в Управление приложением.

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп. h

##  <a name="afxolelockapp"></a>AfxOleLockApp

Увеличивает глобальное количество активных объектов в приложении платформы.

```
void AFXAPI AfxOleLockApp();
```

### <a name="remarks"></a>Remarks

Платформа хранит количество активных объектов в приложении. Функции `AfxOleLockApp` и `AfxOleUnlockApp` соответственно увеличивают и уменьшают этот счетчик.

Когда пользователь пытается закрыть приложение, имеющее активные объекты, — приложение, для которого число активных объектов не равно нулю, платформа скрывает приложение из представления пользователя, а не полностью завершает его работу. Функция `AfxOleCanExitApp` указывает, может ли приложение завершить работу.

Вызывайте `AfxOleLockApp` из любого объекта, предоставляющего интерфейсы OLE, если бы это было нежелательно для уничтожения этого объекта, пока оно еще используется клиентским приложением. Также вызовите `AfxOleUnlockApp` в деструкторе любого объекта, который вызывает `AfxOleLockApp` в конструкторе. По умолчанию `COleDocument` (и производные классы) автоматически блокируют и разблокируют приложение.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAutomation#5](../../mfc/codesnippet/cpp/application-control_4.cpp)]

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп. h

##  <a name="afxoleunlockapp"></a>AfxOleUnlockApp

Уменьшает число активных объектов в приложении.

```
void AFXAPI AfxOleUnlockApp();
```

### <a name="remarks"></a>Remarks

Дополнительные сведения см. в разделе `AfxOleLockApp`.

Когда количество активных объектов достигает нуля, вызывается `AfxOleOnReleaseAllObjects`.

### <a name="example"></a>Пример

См. пример для [AfxOleLockApp](#afxolelockapp).

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп. h

## <a name="afxolelockcontrol"></a>AfxOleLockControl

Блокирует фабрику класса указанного элемента управления таким образом, чтобы динамически создаваемые данные, связанные с элементом управления, оставались в памяти.

### <a name="syntax"></a>Синтаксис

```
BOOL AFXAPI AfxOleLockControl(  REFCLSID clsid  );
BOOL AFXAPI AfxOleLockControl( LPCTSTR lpszProgID );
```

### <a name="parameters"></a>Параметры

*этому*<br/>
Уникальный идентификатор класса элемента управления.

*лпсзпрогид*<br/>
Уникальный идентификатор программы элемента управления.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если фабрика класса элемента управления была успешно заблокирована; в противном случае — 0.

### <a name="remarks"></a>Remarks

Это может значительно ускорить отображение элементов управления. Например, после создания элемента управления в диалоговом окне и блокировки элемента управления с помощью `AfxOleLockControl`вам не нужно создавать и уничтожать его повторно при каждом отображении или уничтожении диалогового окна. Если пользователь открывает и закрывает диалоговое окно несколько раз, Блокировка элементов управления может значительно повысить производительность. Когда вы будете готовы уничтожить элемент управления, вызовите `AfxOleUnlockControl`.

### <a name="example"></a>Пример

```cpp
// Starts and locks control's (Microsoft Calendar) class factory.
// Control will remain in memory for lifetime of
// application or until AfxOleUnlockControl() is called.

AfxOleLockControl(_T("MSCAL.Calendar"));
```

### <a name="requirements"></a>Требования

**Заголовок:** afxwin.h

##  <a name="afxoleregisterserverclass"></a>афксолерегистерсерверкласс

Эта функция позволяет зарегистрировать сервер в системном реестре OLE.

```
BOOL AFXAPI AfxOleRegisterServerClass(
    REFCLSID clsid,
    LPCTSTR lpszClassName,
    LPCTSTR lpszShortTypeName,
    LPCTSTR lpszLongTypeName,
    OLE_APPTYPE nAppType = OAT_SERVER,
    LPCTSTR* rglpszRegister = NULL,
    LPCTSTR* rglpszOverwrite = NULL);
```

### <a name="parameters"></a>Параметры

*этому*<br/>
Ссылка на идентификатор класса OLE сервера.

*лпсзкласснаме*<br/>
Указатель на строку, содержащую имя класса объектов сервера.

*лпсзшорттипенаме*<br/>
Указатель на строку, содержащую короткое имя типа объекта сервера, например "Диаграмма".

*лпсзлонгтипенаме*<br/>
Указатель на строку, содержащую длинное имя типа объекта сервера, например "Диаграмма Microsoft Excel 5,0".

*напптипе*<br/>
Значение, взятое из перечисления OLE_APPTYPE, с указанием типа приложения OLE. Возможны следующие значения:

- OAT_INPLACE_SERVER Server имеет полный пользовательский интерфейс сервера.

- Сервер OAT_SERVER поддерживает только внедрение.

- Контейнер OAT_CONTAINER поддерживает ссылки на внедрения.

- OAT_DISPATCH_OBJECT объект, поддерживающий `IDispatch`.

*рглпсзрегистер*<br/>
Массив указателей на строки, представляющие ключи и значения, добавляемые в системный реестр OLE, если не найдены существующие значения для ключей.

*рглпсзоверврите*<br/>
Массив указателей на строки, представляющие ключи и значения, добавляемые в системный реестр OLE, если реестр содержит существующие значения для заданных ключей.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если серверный класс успешно зарегистрирован; в противном случае — 0.

### <a name="remarks"></a>Remarks

Большинство приложений могут использовать `COleTemplateServer::Register` для регистрации типов документов приложения. Если формат системного реестра приложения не соответствует стандартному шаблону, можно использовать `AfxOleRegisterServerClass` для большего контроля.

Реестр состоит из набора ключей и значений. Аргументы *рглпсзрегистер* и *рглпсзоверврите* — это массивы указателей на строки, каждый из которых состоит из ключа и значения, разделенные **нулевым** символом (`'\0'`). Каждая из этих строк может содержать заменяемые параметры, места которых помечены последовательностями символов *%1* – *%5*.

Символы заполняются следующим образом:

|Символ|Значение|
|------------|-----------|
|%1|Идентификатор класса, отформатированный как строка|
|%2|Имя класса|
|%3|Путь к исполняемому файлу|
|%4|Короткое имя типа|
|%5|Имя типа long|

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп. h

##  <a name="afxoleseteditmenu"></a>афксолесетедитмену

Реализует пользовательский интерфейс для команды объекта *TypeName* .

```
void AFXAPI AfxOleSetEditMenu(
    COleClientItem* pClient,
    CMenu* pMenu,
    UINT iMenuItem,
    UINT nIDVerbMin,
    UINT nIDVerbMax = 0,
    UINT nIDConvert = 0);
```

### <a name="parameters"></a>Параметры

*пклиент*<br/>
Указатель на клиентский элемент OLE.

*пмену*<br/>
Указатель на обновляемый объект меню.

*именуитем*<br/>
Индекс обновляемого элемента меню.

*нидвербмин*<br/>
Идентификатор команды, соответствующий первичной команде.

*нидвербмакс*<br/>
Идентификатор команды, соответствующий последней команде.

*нидконверт*<br/>
Идентификатор элемента меню Convert.

### <a name="remarks"></a>Remarks

Если сервер распознает только первичную команду, пункт меню становится «объектом *TypeName* verb», а команда *нидвербмин* отправляется, когда пользователь выбирает команду. Если сервер распознает несколько глаголов, пункт меню становится "объектом *TypeName* ", а в подменю, в котором отображаются все команды, отображается, когда пользователь выбирает команду. Когда пользователь выбирает команду из подменю, *нидвербмин* отправляется, если выбрана первая команда, *нидвербмин* + 1 отправляется, если выбрана вторая команда и т. д. Реализация `COleDocument` по умолчанию автоматически обрабатывает эту функцию.

В скрипте ресурса приложения клиента должна быть следующая инструкция (. RC):

**#include \<афксолекл. RC >**

### <a name="requirements"></a>Требования

**Заголовок**: афксоле. h

## <a name="afxoleunlockcontrol"></a>афксолеунлоккконтрол

Разблокирует фабрику класса указанного элемента управления.

### <a name="syntax"></a>Синтаксис

```
BOOL AFXAPI AfxOleUnlockControl( REFCLSID clsid );
BOOL AFXAPI AfxOleUnlockControl( LPCTSTR lpszProgID );
```

### <a name="parameters"></a>Параметры

*этому*<br/>
Уникальный идентификатор класса элемента управления.

*лпсзпрогид*<br/>
Уникальный идентификатор программы элемента управления.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если фабрика класса элемента управления была успешно разблокирована; в противном случае — 0.

### <a name="remarks"></a>Remarks

Элемент управления заблокирован `AfxOleLockControl`, поэтому динамически создаваемые данные, связанные с элементом управления, остаются в памяти. Это может значительно ускорить отображение элемента управления, поскольку элемент управления не должен создаваться и уничтожаться каждый раз при его отображении. Когда вы будете готовы уничтожить элемент управления, вызовите `AfxOleUnlockControl`.

### <a name="example"></a>Пример

```cpp
// Unlock control's (Microsoft Calendar Control) class factory.

AfxOleUnlockControl(_T("MSCAL.Calendar"));
```

### <a name="requirements"></a>Требования

**Заголовок:** afxwin.h

## <a name="see-also"></a>См. также раздел

[Макросы и глобальные](mfc-macros-and-globals.md)<br/>
