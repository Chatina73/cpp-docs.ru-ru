---
title: 'TN033: Версия библиотеки DLL MFC'
ms.date: 06/28/2018
f1_keywords:
- vc.mfc.dll
helpviewer_keywords:
- MFC DLLs [MFC], writing MFC extension DLLS
- AFXDLL library
- DLLs [MFC], MFC
- DLL version of MFC [MFC]
- TN033
ms.assetid: b6f1080b-b66b-4b1e-8fb1-926c5816392c
ms.openlocfilehash: 4bfc60e20a073dd34945b91dd48ba82cdf4ab9f3
ms.sourcegitcommit: 5cecccba0a96c1b4ccea1f7a1cfd91f259cc5bde
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2019
ms.locfileid: "58767786"
---
# <a name="tn033-dll-version-of-mfc"></a>TN033: Версия библиотеки DLL MFC

Эта заметка описывает, как можно использовать MFCxx.DLL и MFCxxD.DLL (где x — номер версии MFC) общие библиотеки динамической компоновки с MFC-приложения и библиотеки DLL расширений MFC. Дополнительные сведения о регулярных DLL MFC, см. в разделе [использование MFC как часть библиотеки DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md).

Это техническое Примечание рассматриваются три аспекта библиотеки DLL. Последние два предназначены для более опытных пользователей:

- [Как создать DLL расширения MFC](#_mfcnotes_how_to_write_an_mfc_extension_dll)

- [Как создать приложение MFC, используется версия библиотеки DLL MFC](#_mfcnotes_writing_an_application_that_uses_the_dll_version)

- [Реализуются как общие библиотеки динамической компоновки MFC](#_mfcnotes_how_the_mfc30.dll_is_implemented)

Если вы заинтересованы в создании DLL с использованием MFC, который может использоваться с приложениями не MFC (это называется обычной библиотеки DLL MFC), см. раздел [Технические заметки 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md).

## <a name="overview-of-mfcxxdll-support-terminology-and-files"></a>Общие сведения о поддержке MFCxx.DLL: Терминология и файлов

**Обычная библиотека DLL MFC**: Использовать обычную библиотеку DLL MFC для создания изолированной DLL с использованием некоторых классов MFC. Интерфейсы через границу приложения или DLL, являются интерфейсами «C» и клиентское приложение не обязательно в приложении MFC.

Это версия поддерживается в версии 1.0 с MFC поддержки библиотеки DLL. Он описан в [Технические заметки 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md) пример MFC Дополнительные понятия и [DLLScreenCap](../overview/visual-cpp-samples.md).

> [!NOTE]
> Начиная с Visual C++ версии 4.0 термин **USRDLL** является устаревшим и будет заменен обычной библиотеки DLL MFC, статически скомпонованную с MFC. Можно также можно создавать обычной библиотеки DLL MFC, динамически скомпонованную с MFC.

MFC 3.0 (и более поздних версий) поддерживает обычные библиотеки DLL MFC с новыми функциями, включая классы OLE и базы данных.

**AFXDLL**: Это также называется общей версии библиотеки MFC. Это новую поддержку библиотеки DLL, добавлены в MFC 2.0. Сама библиотека MFC доступна в библиотеках DLL (описаны ниже) и клиентское приложение или библиотека DLL динамически скомпонована библиотеки DLL, которые необходимы. Интерфейсы через границу библиотеки DLL приложения являются C++/MFC интерфейсов класса. Клиентское приложение должно быть приложение MFC. Это поддерживает все функциональные возможности MFC 3.0 (исключение: Юникод не поддерживается для классов баз данных).

> [!NOTE]
> Начиная с Visual C++ версии 4.0 этот тип из библиотеки DLL, называется «Расширение DLL.»

Эта заметка будет использоваться MFCxx.DLL для ссылки на весь установленные библиотеки DLL MFC, включая:

- Отладка: MFCxxD.DLL (объединены) и MFCSxxD.LIB (статический).

- Выпуск: (В сочетании) MFCxx.DLL и MFCSxx.LIB (статический).

- Отладка Юникода: (В сочетании) MFCxxUD.DLL и MFCSxxD.LIB (статический).

- Выпуск Юникода: (В сочетании) MFCxxU.DLL и MFCSxxU.LIB (статический).

> [!NOTE]
> MFCSxx [U] [D]. Библиотеки LIB используются в сочетании с MFC общих библиотек DLL. Эти библиотеки содержат код, который должен быть статически компонуемые с приложением или библиотекой DLL.

Приложение содержит ссылки на соответствующие библиотеки импорта.

- Отладка: MFCxxD.LIB

- Выпуск: MFCxx.LIB

- Отладка Юникода: MFCxxUD.LIB

- Выпуск Юникода: MFCxxU.LIB

«Библиотека DLL расширения MFC» является библиотекой DLL, построенных на основе MFCxx.DLL (и/или других MFC общих библиотек DLL). Здесь архитектура компонентов MFC начинается. Если полезные класс наследуется от класса MFC, или создать другой набор средств по принципу MFC, его можно поместить в библиотеке DLL. Что библиотека DLL использует MFCxx.DLL, что и ultimate клиентское приложение. Это позволяет многократно используемых листовые классы, многократно используемые базовые классы и классы многократного использования представления/документов.

## <a name="pros-and-cons"></a>Преимущества и недостатки

Почему следует использовать общей версии MFC

- Использование общей библиотеки можно привести приложений меньшего размера (минимального приложения, которое использует большинство библиотеки MFC, меньше 10 КБ).

- Общей версии MFC поддерживает библиотеки DLL расширения MFC и обычные библиотеки DLL MFC.

- Создание приложения, использующего общие библиотеки MFC выполняется быстрее, чем создание статически скомпонованной приложения MFC, поскольку нет необходимости связывать саму библиотеку MFC. Это особенно верно в **Отладка** сборок, для которых компоновщик выполняет сжатие отладочной информации — путем связывания с библиотекой DLL, которая уже содержит отладочную информацию, имеется уменьшить объем отладочной информации путем ее сжатия в приложении.

Почему вы не следует использовать общей версии MFC:

- Доставка приложения, использующего общей библиотеки требуется отправить MFCxx.DLL (и других) библиотеки со своей программой. MFCxx.DLL можно свободно распространять, таких как библиотеки DLL, но вы по-прежнему необходимо установить библиотеку DLL в программу установки. Кроме того необходимо предоставить MSVCRTxx.DLL, который содержит библиотеки времени выполнения C, который используется как программы и самими библиотеками MFC DLL.

##  <a name="_mfcnotes_how_to_write_an_mfc_extension_dll"></a> Как написать библиотеки DLL расширения MFC

DLL расширения MFC является библиотекой DLL, содержащую классы и функции, написанные для развертывания функциональных возможностей классов MFC. DLL расширения MFC использует общие библиотеки DLL MFC таким же образом, приложение использует его, с помощью несколько дополнительных факторов:

- Процесс сборки выполняется аналогично построению приложения, использующего общие библиотеки MFC с несколько Дополнительные параметры компилятора и компоновщика.

- DLL расширения MFC не поддерживает `CWinApp`-производного класса.

- DLL расширения MFC необходимо предоставить специальный `DllMain`. Предоставляет AppWizard `DllMain` функции, которые можно изменить.

- DLL расширения MFC предоставит процедуры инициализации для создания `CDynLinkLibrary` Если расширения MFC DLL необходимо экспортировать `CRuntimeClass`es или ресурсов для приложения. Класс, производный от `CDynLinkLibrary` можно использовать, если данные на уровне приложения должны поддерживать библиотеки DLL расширения MFC.

Эти рекомендации описываются более подробно ниже. Также обратитесь к примеру основные понятия Advanced MFC [DLLHUSK](../overview/visual-cpp-samples.md) так, как он иллюстрирует:

- Построение приложения с использованием общей библиотеки. (DLLHUSK. EXE является приложение MFC, динамически скомпонованную с MFC библиотеки DLL, а также другие).

- Построение библиотеки DLL расширения MFC. (Обратите внимание специальные флаги, такие как `_AFXEXT` , которые используются при построении библиотеки DLL расширения MFC)

- Два примера библиотеки DLL расширения MFC. Один показана базовая структура DLL расширения MFC с ограниченной экспорты (TESTDLL1) и других передач, экспорт весь класс интерфейса (TESTDLL2).

Клиентское приложение и все библиотеки DLL расширения MFC необходимо использовать ту же версию MFCxx.DLL. Должно соответствовать соглашению: библиотеки DLL MFC и предоставляет отладочную и розничной торговли (/ release) версию библиотеки DLL расширения MFC. Это позволяет клиентские программы для создания и отладки, так и розничные версии своих приложений и связать их с помощью отладки, подходящие или розничную версию всех файлов DLL.

> [!NOTE]
>  Так как C++ имя искажением и экспортировать проблемы, список экспорта из библиотеки DLL расширения MFC могут отличаться между отладочные и розничные версии той же библиотеки DLL и библиотеки DLL для различных платформ. Розничные MFCxx.DLL примерно в 2000 экспортировала точки входа; отладочные MFCxxD.DLL около 3000 экспортировала точки входа.

### <a name="quick-note-on-memory-management"></a>Обратите внимание на управление памятью

В разделе «Управление памятью,» в конце этого техническое Примечание описывает реализацию MFCxx.DLL с общей версии MFC. Сведения, необходимые для реализации только расширения MFC DLL является описанных здесь.

MFCxx.DLL и всех библиотек расширения MFC, загруженного в адресное пространство клиентское приложение будет использовать же распределитель памяти, загрузка ресурсов и другие состояния «глобальные» MFC, как если бы они были в одном приложении. Это важно, так как библиотеки MFC DLL и обычные библиотеки DLL MFC, статической компоновке с MFC выполнять прямо противоположно и каждой библиотеки DLL, выделение за пределами пула памяти.

Если библиотеки DLL расширения MFC выделяет память, что память можно свободно смешивается с любым другим объектом, выделенными в приложение. Кроме того в случае сбоя приложения, использующего общие библиотеки MFC защиты операционной системы будет поддерживать целостность данных в любое другое приложение MFC, совместное использование библиотеки DLL.

Аналогичным образом другие «глобальные» состояния MFC, такие как текущий исполняемый файл для загрузки ресурсов, также являются общими между клиентским приложением и все библиотеки DLL расширения MFC также MFCxx.DLL сам.

### <a name="building-an-mfc-extension-dll"></a>Построение библиотеки DLL расширения MFC

Мастером приложений можно использовать для создания проекта библиотеки DLL расширения MFC, и она автоматически сформирует соответствующие параметры компилятора и компоновщика. Было также создают `DllMain` функции, которые можно изменить.

При преобразовании существующего проекта для библиотеки DLL расширения MFC, начните с стандартные правила для создания приложения с помощью общей версии MFC, а затем сделайте следующее:

- Добавить **/D_AFXEXT** флаги компилятора. В диалоговом окне свойств проекта выберите узел C/C++. Затем выберите категорию, препроцессора. Добавить `_AFXEXT` к полю определения макросов, разделив каждый из элементов точкой с запятой.

- Удалить **/Gy** параметр компилятора. В диалоговом окне свойств проекта выберите узел C/C++. Затем выберите категорию, создания кода. Убедитесь, что не установлен флажок «Включить компоновку на уровне функции». Это облегчит процедура экспорта классов, так как компоновщик не удаляет неиспользуемые функции. Если исходный проект используется для создания обычной MFC DLL, статически компонуемые с MFC, изменение **[d] / MT** параметра компилятора **[d] / MD**.

- Создание библиотеки экспорта с помощью **/DLL** параметр по ССЫЛКЕ. Это будет иметь значение при создании новую цель, указав библиотеки динамической компоновки Win32 в качестве целевого типа.

### <a name="changing-your-header-files"></a>Изменение файлов заголовка

Цель библиотеки DLL расширения MFC обычно является экспорт некоторые общие функциональные возможности одного или нескольких приложений, которые могут использовать эту функциональность. Это сводится к экспорту классы и глобальные функции, которые доступны для клиентских приложений.

Для этого необходимо убедиться, что каждая из функций-членов помечается как импорт или экспорт соответствующим образом. Для этого требуется объявлений специальные: `__declspec(dllexport)` и `__declspec(dllimport)`. Когда ваши классы используются клиентскими приложениями, вам нужно быть объявлены как `__declspec(dllimport)`. При построении самой библиотеки DLL расширения MFC, они должны быть объявлены как `__declspec(dllexport)`. Кроме того функции необходимо фактически экспортировать, чтобы привязать клиентских программ к их во время загрузки.

Чтобы экспортировать весь класс, используйте `AFX_EXT_CLASS` в определении класса. Этот макрос определяется платформой как `__declspec(dllexport)` при `_AFXDLL` и `_AFXEXT` определен, но определяется как `__declspec(dllimport)` при `_AFXEXT` не определен. `_AFXEXT` как описано выше, определяется только при построении библиотеки DLL расширения MFC. Пример:

```cpp
class AFX_EXT_CLASS CExampleExport : public CObject
{ /* ... class definition ... */ };
```

### <a name="not-exporting-the-entire-class"></a>Экспортирует весь класс

Иногда можно экспортировать только отдельные необходимые члены класса. Например, если при экспорте `CDialog`-производного класса только необходимо экспортировать в конструктор и `DoModal` вызова. Вы можете экспортировать эти элементы, с помощью библиотеки DLL. DEF-файл, но можно также использовать `AFX_EXT_CLASS` так же, для отдельных членов, нужно экспортировать.

Пример:

```cpp
class CExampleDialog : public CDialog
{
public:
    AFX_EXT_CLASS CExampleDialog();
    AFX_EXT_CLASS int DoModal();
    // rest of class definition
    // ...
};
```

При этом вы можете столкнуться дополнительную проблему, так как больше не экспортируются все члены класса. Проблема заключается в способе работы макросов библиотеки MFC. Несколько вспомогательных макросов MFC объявляют или определяют члены данных. Таким образом эти члены данных также потребуется экспортировать из библиотеки DLL.

Например DECLARE_DYNAMIC-макрос определяется следующим образом при построении библиотеки DLL расширения MFC:

```cpp
#define DECLARE_DYNAMIC(class_name) \
protected: \
    static CRuntimeClass* PASCAL _GetBaseClass(); \
    public: \
    static AFX_DATA CRuntimeClass class##class_name; \
    virtual CRuntimeClass* GetRuntimeClass() const; \
```

Строка, которая начинается «статический `AFX_DATA`"объявляет статический объект внутри класса. Для успешного выполнения экспорта этого класса и доступ к среде выполнения сведения от клиента. EXE-файла, необходимо экспортировать статический объект. Так как статический объект объявлен с модификатором `AFX_DATA`, необходимо определить `AFX_DATA` быть `__declspec(dllexport)` при построении библиотеки DLL и определяют его как `__declspec(dllimport)` при построении исполняемый файл клиента.

Как уже говорилось ранее, `AFX_EXT_CLASS` уже определен таким образом. Необходимо повторно определить `AFX_DATA` быть так же, как `AFX_EXT_CLASS` вокруг его определение.

Пример:

```cpp
#undef  AFX_DATA
#define AFX_DATA AFX_EXT_CLASS
class CExampleView : public CView
{
    DECLARE_DYNAMIC()
    // ... class definition ...
};
#undef  AFX_DATA
#define AFX_DATA
```

Всегда используется библиотекой MFC `AFX_DATA` символов для элементов данных, он определяет в пределах своего макроса, поэтому этот метод будет работать для таких сценариев. Например он будет работать для DECLARE_MESSAGE_MAP.

> [!NOTE]
> Если экспортируется весь класс, а не выбранные элементы класса, автоматически экспортируются статические данные-члены.

Можно использовать ту же методику для автоматического экспорта `CArchive` оператор извлечения для классов, которые используются макросы DECLARE_SERIAL и IMPLEMENT_SERIAL. Экспортируйте оператор архива, скобок объявления класса (расположенный в. H-файл) со следующим кодом:

```cpp
#undef AFX_API
#define AFX_API AFX_EXT_CLASS

/* your class declarations here */

#undef AFX_API
#define AFX_API
```

### <a name="limitations-of-afxext"></a>Ограничения _AFXEXT

Можно использовать _**AFXEXT** символов препроцессора для библиотек, если у вас нет многочисленные расширения MFC библиотеки DLL расширения MFC. Если у вас есть расширение MFC DLL, вызывающие или являются производными от классов в свои собственные расширения MFC библиотеки DLL, которые являются производными от классов MFC, необходимо использовать собственный символ препроцессора во избежание неоднозначности.

Проблема в том, что в Win32, необходимо явно объявить все данные в виде `__declspec(dllexport)` Если требуется экспортировать из библиотеки DLL, и `__declspec(dllimport)` Если требуется импортировать из библиотеки DLL. При определении `_AFXEXT`, заголовки MFC убедитесь, что `AFX_EXT_CLASS` определен правильно.

При наличии нескольких уровней, один символ например `AFX_EXT_CLASS` недостаточно, так как библиотеки DLL расширения MFC может экспортировать новые классы, а также импортировать другие классы из другой библиотеки DLL расширения MFC. Чтобы решить эту проблему, используйте специальный символ препроцессора, указывающее, что вы создаете непосредственно в Библиотеки и библиотеки DLL. Например представьте себе две библиотеки DLL расширения MFC, A.DLL и B.DLL. Каждый из них экспортирует некоторые классы, в файлах A.H и B.H соответственно. B.DLL использует классы из A.DLL. Файлы заголовков будет выглядеть следующим образом:

```cpp
/* A.H */
#ifdef A_IMPL
    #define CLASS_DECL_A   __declspec(dllexport)
#else
    #define CLASS_DECL_A   __declspec(dllimport)
#endif

class CLASS_DECL_A CExampleA : public CObject
{ /* ... class definition ... */ };

/* B.H */
#ifdef B_IMPL
    #define CLASS_DECL_B   __declspec(dllexport)
#else
    #define CLASS_DECL_B   __declspec(dllimport)
#endif

class CLASS_DECL_B CExampleB : public CExampleA
{ /* ... class definition ... */ };
```

При построении A.DLL, построены с **/DA_IMPL** и при построении B.DLL, построены с **/DB_IMPL**. С помощью отдельных символов для каждой библиотеки DLL, класс CExampleB экспортируется и класс CExampleA импортируется при построении B.DLL. Класс CExampleA экспортируется при построении A.DLL и импортируется при использовании B.DLL (или другим клиентом).

Не удается выполнить этот тип архитектуры при использовании встроенной `AFX_EXT_CLASS` и `_AFXEXT` символы препроцессора. Способ, описанный выше решает эту проблему в способом, отличным от используется классами MFC при создании его библиотеки DLL расширения OLE, базы данных и сети MFC.

### <a name="not-exporting-the-entire-class"></a>Экспортирует весь класс

Опять же необходимо принять специальные меры, в том случае, если не экспортируется весь класс. Необходимо убедиться, что элементы необходимые данные, созданные макросы MFC экспортируются правильно. Это можно сделать путем повторного определения `AFX_DATA` макрос определенного класса. Это должен сделать любое время, не экспортируется весь класс.

Пример:

```cpp
// A.H
#ifdef A_IMPL
    #define CLASS_DECL_A  _declspec(dllexport)
#else
    #define CLASS_DECL_A  _declspec(dllimport)
#endif

#undef  AFX_DATA
#define AFX_DATA CLASS_DECL_A

class CExampleA : public CObject
{
    DECLARE_DYNAMIC()
    CLASS_DECL_A int SomeFunction();
    // class definition
    // ...
};

#undef AFX_DATA
#define AFX_DATA
```

### <a name="dllmain"></a>DllMain

Ниже приведен необходимый код следует поместить в основной исходный файл для библиотеки DLL расширения MFC. Он должен иметь после содержат стандартные. Обратите внимание, что при использовании мастером приложений, чтобы создать начальный набор файлов для библиотеки DLL расширения MFC, он передает `DllMain` для вас.

```cpp
#include "afxdllx.h"

static AFX_EXTENSION_MODULE extensionDLL;

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      // MFC extension DLL one-time initialization
      if (!AfxInitExtensionModule(
             extensionDLL, hInstance))
         return 0;

      // TODO: perform other initialization tasks here
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      // MFC extension DLL per-process termination
      AfxTermExtensionModule(extensionDLL);

      // TODO: perform other cleanup tasks here
   }
   return 1;   // ok
}
```

Вызов `AfxInitExtensionModule` захватывает модули классов среды выполнения (`CRuntimeClass` структур) а также производства объектов (`COleObjectFactory` объектов) для использования более поздние версии `CDynLinkLibrary` создается объект. (Необязательно) вызов `AfxTermExtensionModule` позволяет MFC очистки библиотеки DLL расширения MFC после отсоединения всех процессов (что происходит при завершении процесса или при выгрузке библиотеки DLL в результате использования `FreeLibrary` вызовите) из библиотеки DLL расширения MFC. Так как большинство расширения MFC, библиотеки DLL не загружаются динамически (как правило, они связаны с помощью свои библиотеки импорта), вызов `AfxTermExtensionModule` обычно нет необходимости.

Если приложение загружает и освобождает библиотек DLL расширений MFC, динамически, необходимо вызвать `AfxTermExtensionModule` как показано выше. Также не забудьте указать `AfxLoadLibrary` и `AfxFreeLibrary` (вместо функций Win32 `LoadLibrary` и `FreeLibrary`) Если приложение использует несколько потоков или если она динамически загружает библиотеки DLL расширения MFC. С помощью `AfxLoadLibrary` и `AfxFreeLibrary` следит за тем, что код запуска и завершения работы, который выполняется при загрузке и выгрузке библиотеки DLL расширения MFC не приведет к повреждению глобального состояния MFC.

Файл заголовка AFXDLLX. H содержит специальные определения для структур, используемых в библиотеки DLL расширения MFC, например определение `AFX_EXTENSION_MODULE` и `CDynLinkLibrary`.

Глобальный *extensionDLL* должен быть объявлен, как показано. В отличие от 16-разрядной версии MFC, можно выделять память и вызвать функции MFC в течение этого времени, так как MFCxx.DLL полной инициализации к моменту ваш `DllMain` вызывается.

### <a name="sharing-resources-and-classes"></a>Совместное использование ресурсов и классы

Простой библиотеки DLL расширения MFC требуется экспортировать только несколько функций с низкой пропускной способностью для клиентского приложения и ничего более. Дополнительные библиотеки DLL с большим объемом, пользовательского интерфейса может потребоваться экспортировать ресурсы и классы C++ клиентскому приложению.

Экспорт ресурсов осуществляется по списку ресурсов. В каждом приложении — это однонаправленный список `CDynLinkLibrary` объектов. При поиске ресурса, сначала в текущем модуле ресурсов выполняют большую часть стандартных реализаций MFC, загружающих ресурсы (`AfxGetResourceHandle`) и если он не найден стека список `CDynLinkLibrary` объектов, попытки загрузить запрошенный ресурс.

Аналогично динамического создания объектов C++, получает имя класса C++. Механизм десериализации объекта MFC должен иметь все `CRuntimeClass` объекты зарегистрированы, чтобы его можно восстановить путем динамического создания объектов C++ требуемого типа, в зависимости от того, что было сохранено ранее.

Если вы хотите, чтобы клиентское приложение для использования классов в библиотеке DLL расширения MFC, которые являются `DECLARE_SERIAL`, то необходимо будет экспортировать класс видимым для клиентского приложения. Это выполняется разбором `CDynLinkLibrary` списка.

В нашем примере основные понятия Advanced MFC [DLLHUSK](../overview/visual-cpp-samples.md), список выглядит примерно так:

```Example
head ->   DLLHUSK.EXE   - or - DLLHUSK.EXE
               |                    |
          TESTDLL2.DLL         TESTDLL2.DLL
               |                    |
          TESTDLL1.DLL         TESTDLL1.DLL
               |                    |
               |                    |
           MFC90D.DLL           MFC90.DLL
```

MFCxx.DLL является обычно последним в списке ресурсов и в списке классов. MFCxx.DLL включает все стандартные ресурсы MFC, включая строку запроса для всех стандартных идентификаторов команд. Поместить его в конец списка позволяет библиотекам DLL и клиентское приложение не имеет свою собственную копию стандартные ресурсы MFC, но для используют общие ресурсы в MFCxx.DLL вместо этого.

Объединение ресурсов и имена классов всех библиотек DLL в пространство имен клиентского приложения есть недостаток, что вам нужно соблюдать осторожность какие идентификаторы или имена, которые вы можете выбрать. Само собой отключить эту функцию, не экспортировав либо ресурсами или `CDynLinkLibrary` объект клиентскому приложению. [DLLHUSK](../overview/visual-cpp-samples.md) пример управляет пространство имен общих ресурсов с помощью нескольких файлов заголовков. См. в разделе [технические 35 Примечание](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md) Дополнительные советы по использованию общих файлов ресурсов.

### <a name="initializing-the-dll"></a>Инициализация библиотеки DLL

Как упоминалось выше, обычно требуется создать `CDynLinkLibrary` объект для экспорта ресурсы и классы для клиентского приложения. Необходимо предоставить экспортированный стартовой точкой для инициализации библиотеки DLL. Как минимум это void подпрограмму, которая не принимает аргументы и не возвращает ничего, но он может быть любым.

Каждый клиентское приложение, которое хочет использовать библиотеки DLL необходимо вызвать этой процедуры инициализации, при использовании этого подхода. Также может выделить это `CDynLinkLibrary` объект в вашей `DllMain` сразу после вызова метода `AfxInitExtensionModule`.

Необходимо создать процедуры инициализации `CDynLinkLibrary` объект в куче текущего приложения, с указанным сведения библиотеки DLL расширения MFC. Это можно сделать с помощью следующих:

```cpp
extern "C" extern void WINAPI InitXxxDLL()
{
    new CDynLinkLibrary(extensionDLL);
}
```

Имя подпрограммы, *InitXxxDLL* в этом примере можно изменить в зависимости. Его не требуется **extern «C»**, но делаю это делает списке экспорта проще было обслуживать.

> [!NOTE]
> Если вы используете библиотеки DLL расширения MFC с обычной библиотеки DLL MFC, необходимо экспортировать эту функцию инициализации. Эту функцию необходимо вызывать от обычных MFC DLL перед использованием любым классы библиотеки DLL расширения MFC или ресурсам.

### <a name="exporting-entries"></a>Экспорт записей

Простой способ экспорта классов является использование `__declspec(dllimport)` и `__declspec(dllexport)` в каждый класс или глобальной функции, которые необходимо экспортировать. Это делает гораздо проще, но это менее эффективно, чем именования каждой точки входа (как описано ниже), так как имеется меньше возможностей экспортируются какие функции управления и его нельзя экспортировать функции по порядковому номеру. Этот метод следует использовать, чтобы экспортировать записи их TESTDLL1 и TESTDLL2.

Более эффективный метод (и метод, используемый MFCxx.DLL) — экспорт каждой записи вручную путем именования в каждой записи в. DEF-файл. Так как мы экспортируются выборочной экспорты из нашей библиотеки DLL (то есть не все), мы необходимо решить, какие определенного интерфейсы, которые нужно экспортировать. Это непросто, поскольку искаженные имена компоновщика необходимо указать в виде записей в. DEF-файл. Не экспортируйте любые классы C++, если вам действительно нужен символьную ссылку для него.

Если вы попытались Экспорт C++ классы с. DEF-файла прежде, чем вы можете разработать средство для автоматического создания этого списка. Это можно сделать с помощью ссылки на два этапа процесса. Связывание библиотеки DLL, один раз с экспортируемые элементы и разрешить компоновщик для создания. Файл Сопоставления. . Файл КАРТЫ можно использовать для создания списка функций, которые должны быть экспортированы, чтобы с некоторые изменения порядка, его можно использовать для создания записей экспорта для вашего. DEF-файл. Экспорт списка MFCxx.DLL OLE и библиотеки DLL расширения MFC базы данных, несколько тысяч по числу, был создан с такого процесса (хотя он не является полностью автоматическая и требует некоторых наличии настройки каждый раз, в то время как).

### <a name="cwinapp-vs-cdynlinklibrary"></a>CWinApp vs. CDynLinkLibrary

DLL расширения MFC не поддерживает `CWinApp`-производного объекта свои собственные; вместо этого он должен работать с `CWinApp`-производным объектом клиентского приложения. Это означает, что клиентское приложение является владельцем цикла обработки сообщений цикла простоя и т. д.

Если библиотека DLL расширения MFC необходимо сохранить дополнительные данные для каждого приложения, можно наследовать новый класс из `CDynLinkLibrary` и создать его в InitXxxDLL, подпрограмма описано выше. При запуске, библиотеки DLL можно проверить список текущего приложения `CDynLinkLibrary` объектов для поиска для конкретной библиотеки DLL расширения MFC.

### <a name="using-resources-in-your-dll-implementation"></a>Использование ресурсов в вашей реализации библиотеки DLL

Как упоминалось выше, нагрузка по умолчанию ресурсов приведена пошаговая процедура список `CDynLinkLibrary` объектов, поиск первого EXE или DLL, имеющий запрошенный ресурс. Все API-интерфейсов MFC, а также все использует внутренний код `AfxFindResourceHandle` для обхода список ресурсов для поиска любого ресурса, независимо от того, в котором он находится.

Если вы хотите только загружать ресурсы из определенного места, используйте API-интерфейсы `AfxGetResourceHandle` и `AfxSetResourceHandle` для сохранения старого дескриптора и задайте новый маркер. Не забудьте восстановить старый дескриптор ресурсов, прежде чем вернуться в клиентское приложение. В примере TESTDLL2 используется этот подход для явной загрузки меню.

Проход по списку имеет недостатки, что он немного медленнее и требует управления уровнями идентификатора ресурса. Он имеет то преимущество, что клиентское приложение, которое содержит ссылки на несколько библиотек DLL расширения MFC можно использовать любой предоставленный библиотекой DLL ресурсов без указания дескриптора экземпляра библиотеки DLL. `AfxFindResourceHandle` API-Интерфейс, используемый для просмотра списка ресурсов для поиска для данного сопоставления. Она принимает имя и тип ресурса и возвращает дескриптор ресурса, где он был обнаружен (или NULL).

##  <a name="_mfcnotes_writing_an_application_that_uses_the_dll_version"></a> Написание приложения, использующего версией библиотеки DLL

### <a name="application-requirements"></a>Требования приложения

Приложения, использующего общей версии MFC необходимо выполнить несколько простых правил:

- Он должен иметь `CWinApp` объекта и выполните стандартные правила для обработки сообщений.

- Он должен быть скомпилирован с набор флагов требуется компилятор (см. ниже).

- Его необходимо связать с библиотеками импорта MFCxx. Установка флагов требуется компилятор, заголовки MFC определить во время компоновки какую библиотеку, приложение должно быть скомпоновано с.

- Чтобы запустить исполняемый файл, MFCxx.DLL необходимо в пути или в системном каталоге Windows.

### <a name="building-with-the-development-environment"></a>Создание с помощью среды разработки

Если вы используете внутренней makefile с большинством стандартных значений по умолчанию, можно легко изменить проект для построения версией библиотеки DLL.

Приведенную ниже предполагается, что у вас есть правильно функционирующее приложение MFC, связанные с NAFXCWD. LIB (для отладки) и NAFXCW. LIB (для розничной торговли) и вы хотите преобразовать его для использования общей версии библиотеки MFC. Вы выполняете среды Visual C++ и файл внутреннего проекта.

1. На **проекты** меню, щелкните **свойства**. В **Общие** странице в разделе **проекта по умолчанию**, равным Microsoft Foundation Classes **использовать MFC в общей DLL** (MFCxx(d).dll).

### <a name="building-with-nmake"></a>Построение с (NMAKE)

Если вы используете функцию внешний сборочный файл проекта Visual C++, или используете NMAKE напрямую, будет необходимо внести изменения в файл makefile для поддержки возможности компилятора и компоновщика

Обязательные флаги компилятора:

- **/D_AFXDLL /MD**
   **/D_AFXDLL**

Стандартные заголовки MFC потребуется этот символ определяется:

- **/ MD** приложению нужна версия DLL библиотеки времени выполнения c.

Все остальные флаги компилятора имеют значения по умолчанию MFC (например, _DEBUG для отладки).

Измените список библиотек компоновщика. Изменение NAFXCWD. LIB MFCxxD.LIB и измените NAFXCW. LIB для MFCxx.LIB. Замените LIBC. LIB с MSVCRT. LIB. Как с любой другой библиотеке MFC очень важно, что размещается MFCxxD.LIB **перед** все библиотеки времени выполнения C.

При необходимости добавьте **/D_AFXDLL** для розничной торговли и отладки параметры компилятора ресурсов (тот, который фактически компилирует ресурсы с **/R**). Это делает конечного исполняемого файла меньшего размера, отправляя ресурсы, которые присутствуют в библиотеки DLL MFC.

Полное перестроение требуется после внесения этих изменений.

### <a name="building-the-samples"></a>Построение примеров

Большая часть примеров программ MFC можно создавать с помощью Visual C++ или из общей MAKEFILE совместимые NMAKE из командной строки.

Чтобы преобразовать любой из этих примеров, чтобы использовать MFCxx.DLL, можно загрузить. MAK файлов в Visual C++ и задайте параметры проекта, как описано выше. Если вы используете сборки NMAKE, можно указать «AFXDLL = 1» на NMAKE командной строки, которые будут создавать образца с использованием общей библиотеки MFC.

Пример MFC Дополнительные понятия [DLLHUSK](../overview/visual-cpp-samples.md) создается с использованием версия библиотеки DLL MFC. В этом примере не только показано, как создать приложение, связанной с MFCxx.DLL, но также показывает другие функции параметр упаковки MFC DLL, таких как библиотеки DLL расширения MFC, описанные далее в этом техническом примечании.

### <a name="packaging-notes"></a>Заметки о упаковки

Розничную версию библиотеки DLL (MFCxx [U]. Библиотека DLL) является Свободно распространяемыми. Отладочная версия библиотеки DLL не являются можно свободно распространять и должен использоваться только во время разработки приложения.

Отладочные версии библиотек DLL предоставляются с отладочной информацией. С помощью отладчика Visual C++, можно отслеживать выполнение приложения, а также библиотеки DLL. Выпуск библиотеки DLL (MFCxx [U]. Библиотека DLL) не содержит отладочную информацию.

Если настроить или Перестройте библиотеки DLL, затем следует вызывать их что-то отличного от файла MFC SRC «MFCxx» MFCDLL. MAK описываются параметры сборки и содержит логику для переименования библиотеки DLL. Переименования файлов необходим, так как эти DLL-файлы являются совместно несколькими приложениями MFC. Наличие пользовательской версии библиотек DLL MFC replace они установлены в системе может нарушить работу другого приложения MFC, с помощью общих библиотек DLL MFC.

Перестроение библиотеки MFC DLL не рекомендуется.

##  <a name="_mfcnotes_how_the_mfc30.dll_is_implemented"></a> Реализации MFCxx.DLL

В следующем разделе описаны реализации библиотеки DLL MFC (MFCxx.DLL и MFCxxD.DLL). Понимание углубляться в подробности, также не важно, если все, что нужно сделать — это использование библиотеки DLL MFC вместе с приложением. Здесь не важны для понимания того, как написать библиотеки DLL расширения MFC, но основные сведения об этой реализации может помочь в создании собственной библиотеки DLL.

### <a name="implementation-overview"></a>Общие сведения о реализации

Библиотеки DLL MFC действительно является особым случаем из библиотеки DLL расширения MFC, как описано выше. Он имеет очень большое количество экспортов для большое количество классов. Существует несколько дополнительных вещей, которые мы делаем в библиотеке DLL MFC, которые делают ее еще более специфическими правами, чем регулярных DLL расширения MFC.

### <a name="win32-does-most-of-the-work"></a>Win32 поддерживает большую часть работы

В 16-разрядной версии MFC требуется ряд специальных методов, включая данные на уровне приложения в сегменте стека, специальные сегменты, созданный код сборки 80 x 86, контексты исключения на уровне процесса и других методов. Win32 напрямую поддерживает данных каждого процесса в библиотеке DLL, то, что нужно большую часть времени. В большинстве случаев MFCxx.DLL — просто NAFXCW. LIB, упакованных в библиотеку DLL. Если посмотреть на исходный код MFC, можно найти очень мало _AFXDLL #ifdef, поскольку существует очень мало особые случаи, которые необходимо внести. Особые случаи, которые существуют в частности, дело с Win32 в Windows 3.1 (также известное как Win32s). Win32s не не данные на уровне процесса DLL поддержки напрямую, поэтому с библиотекой DLL MFC необходимо использовать локальное хранилище потока (TLS) API-интерфейсов Win32 для получения процесса локальных данных.

### <a name="impact-on-library-sources-additional-files"></a>Влияние на библиотеки источников, дополнительные файлы

Влияние **_AFXDLL** версией в обычном источников библиотеки классов MFC и заголовки относительно незначительны. Имеется файл специальная версия (AFXV_DLL. H), а также дополнительный заголовочный файл (AFXDLL_. H) по основной AFXWIN включена. Заголовок H. AFXDLL_. Включает заголовок H `CDynLinkLibrary` класс и другие сведения о реализации обоих `_AFXDLL` приложениями и библиотеками DLL расширения MFC. AFXDLLX. H заголовок указан для создания библиотеки DLL расширения MFC (см. выше сведения).

Регулярные источники для библиотеки MFC в MFC SRC имеют дополнительный условный код в разделе `_AFXDLL` #ifdef. Файл дополнительных исходных (DLLINIT. CPP) содержит дополнительный код инициализации библиотеки DLL и другие связывающих для общей версии MFC.

Для создания общей версии MFC, предоставляются дополнительные файлы. (См. ниже дополнительные сведения о том, как создать библиотеку DLL.)

- Два. DEF-файлы используются для экспорта точки входа библиотеки DLL MFC для отладки (MFCxxD.DEF) и версии (MFCxx.DEF) библиотеки DLL.

- . RC-файле (MFCDLL. Версия-Кандидат) содержит все стандартные ресурсы MFC и ресурсе VERSIONINFO для библиотеки DLL.

- ОБЪЕКТ. Файл CLW (MFCDLL. CLW) предоставляется право на просмотр MFC классов с помощью классов. Примечание: Эта функция не относится к версия библиотеки DLL MFC.

### <a name="memory-management"></a>Управление памятью

Приложение, использующее MFCxx.DLL использует общие распределитель памяти, предоставляемые MSVCRTxx.DLL общей библиотеки DLL времени выполнения C. Приложения, все библиотеки DLL расширения MFC и также самими библиотеками MFC DLL используют этот механизм распределения общей памяти. С помощью общей DLL для выделения памяти, библиотеки DLL MFC можно выделить память, освобождается более поздней версии для приложения или наоборот. Так как приложения и библиотеки DLL необходимо использовать же распределитель, не следует переопределять глобальные C++ **оператор new** или **оператор delete**. Те же правила применяются к остальным процедур выделения памяти времени выполнения C (такие как **malloc**, **realloc**, **бесплатный**и другие).

### <a name="ordinals-and-class-declspecdllexport-and-dll-naming"></a>Порядковые номера "и" класс __declspec(dllexport) "и" именование библиотеки DLL

Мы не используем `class` **__declspec(dllexport)** функциональных возможностей C++ компилятора. Вместо этого списком экспортируемых входит в состав библиотеки класса источники (MFCxx.DEF и MFCxxD.DEF). Экспортируются только эти выберите набор точек входа (функциям и данным). Другие символы, такие как MFC закрытой реализации функций или классов, не экспортируются все экспорты, выполняются по порядковому номеру без имени строки в таблицу имен, находящихся или не резидентной.

С помощью `class` **__declspec(dllexport)** может быть жизнеспособную альтернативу для построения библиотеки DLL меньшего размера, но в случае с большой DLL, таких как MFC, экспорт механизм по умолчанию имеет эффективность и емкость ограничения.

Это означает, что все Какова, мы можете упаковать большой объем функциональные возможности в выпуске MFCxx.DLL, только около 800 КБ без ущерба много выполнения или скорость загрузки. MFCxx.DLL было бы 100 тыс. больше бы этот метод не было использовать. Это также дает возможность добавить дополнительные точки входа в конце. DEF-файл, чтобы разрешить простое управление версиями без ущерба для эффективности скорости и размера экспорта по порядковому номеру. Основной номер версии редакции в библиотеке классов MFC изменится имя библиотеки. То есть MFC30. DLL-ФАЙЛ является распространяемые библиотеки DLL, содержащей библиотека классов MFC версии 3.0. Обновление этой библиотеки DLL, скажем, в гипотетической 3.1 MFC, библиотеки DLL будет называться MFC31. Библиотека DLL вместо этого. Опять же если изменить исходный код MFC для создания пользовательской версии библиотеки DLL MFC, используйте другое имя (а лучше — без «MFC» в имени).

## <a name="see-also"></a>См. также

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
