---
title: TN033. Версия библиотеки DLL MFC
ms.date: 06/28/2018
helpviewer_keywords:
- MFC DLLs [MFC], writing MFC extension DLLS
- AFXDLL library
- DLLs [MFC], MFC
- DLL version of MFC [MFC]
- TN033
ms.assetid: b6f1080b-b66b-4b1e-8fb1-926c5816392c
ms.openlocfilehash: ad4cb883cfe7e397cf599d659afb02b23501dc5a
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370317"
---
# <a name="tn033-dll-version-of-mfc"></a>TN033. Версия библиотеки DLL MFC

В этой заметке описывается, как можно использовать MFCxx.DLL и MFCxxD.DLL (где x является номером версии MFC) общие динамические библиотеки ссылок с приложениями MFC и DLL расширения MFC. Для получения дополнительной информации о регулярных DLL MFC, [см. Использование MFC как часть DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md).

Эта техническая записка охватывает три аспекта DLLs. Последние два для более продвинутых пользователей:

- [Как построить DLL расширения MFC](#_mfcnotes_how_to_write_an_mfc_extension_dll)

- [Как вы строите приложение MFC, использующее dLL-версию MFC](#_mfcnotes_writing_an_application_that_uses_the_dll_version)

- [Как реализуются библиотеки с динамической ссылкой MFC](#_mfcnotes_how_the_mfc30.dll_is_implemented)

Если вы заинтересованы в создании DLL с использованием MFC, которые могут быть использованы с не-MFC приложений (это называется регулярным MFC DLL), обратитесь к [технической примечание 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md).

## <a name="overview-of-mfcxxdll-support-terminology-and-files"></a>Обзор поддержки MFCxx.DLL: Терминология и файлы

**Регулярный MFC DLL**: Вы используете обычный MFC DLL для создания автономного DLL с использованием некоторых классов MFC. Интерфейсы через границу App/DLL являются интерфейсами "C", и клиентское приложение не должно быть приложением MFC.

Это версия поддержки DLL поддерживается в MFC 1.0. Он описан в [техническом примечании 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md) и MFC Расширенные концепции образца [DLLScreenCap](../overview/visual-cpp-samples.md).

> [!NOTE]
> По состоянию на версию Visual C', термин **USRDLL** устарел и был заменен обычным MFC DLL, который статично ссылается на MFC. Вы также можете создать регулярный MFC DLL, который динамически связывается с MFC.

MFC 3.0 (и выше) поддерживает регулярные DLL MFC со всеми новыми функциями, включая классы OLE и базы данных.

**AFXDLL**: Это также называется общей версией библиотек MFC. Это новая поддержка DLL, добавленная в MFC 2.0. Сама библиотека MFC находится в нескольких DLL (описано ниже), и клиентское приложение или DLL динамически связывает DLLs, которые он требует. Интерфейсы через границу приложения/DLL являются интерфейсами класса C/MFC. Клиентское приложение должно быть приложением MFC. Это поддерживает все функциональные возможности MFC 3.0 (исключение: UNICODE не поддерживается для классов баз данных).

> [!NOTE]
> По состоянию на версию Visual C', 4.0, этот тип DLL называется "Расширение DLL".

В этой заметке будет использоваться MFCxx.DLL для обозначения всего набора MFC DLL, который включает в себя:

- Ошибка: MFCxxD.DLL (в сочетании) и MFCSxxD.LIB (статический).

- Выпуск: MFCxx.DLL (в сочетании) и MFCSxx.LIB (статический).

- Unicode Debug: MFCxxUD.DLL (в сочетании) и MFCSxxD.LIB (статический).

- Выпуск Unicode: MFCxxU.DLL (в сочетании) и MFCSxxU.LIB (статический).

> [!NOTE]
> MFCSxx.» Библиотеки LIB используются совместно с общими DLL MFC. Эти библиотеки содержат код, который должен быть статически связан с приложением или DLL.

Приложение ссылается на соответствующие библиотеки импорта:

- Ошибка: MFCxxD.LIB

- Выпуск: MFCxx.LIB

- Unicode Debug: MFCxxUD.LIB

- Выпуск Unicode: MFCxxU.LIB

"MFC Extension DLL" - это DLL, построенный на MFCxx.DLL (и/или других общих DLL MFC). Здесь начинается архитектура компонентов MFC. Если вы получаете полезный класс из класса MFC или создаете другой набор инструментов, похожий на MFC, вы можете поместить его в DLL. Это DLL использует MFCxx.DLL, как и конечное приложение клиента. Это позволяет многоразовые классы листьев, многоразовые базовые классы и многоразовые классы представления/документа.

## <a name="pros-and-cons"></a>Плюсы и минусы

Почему следует использовать общую версию MFC

- Использование общей библиотеки может привести к уменьшению числа приложений (минимальное приложение, использующее большую часть библиотеки MFC, составляет менее 10K).

- Общая версия MFC поддерживает MFC Расширение DLL и регулярные DLL MFC.

- Создание приложения, использующее общие библиотеки MFC, происходит быстрее, чем создание статично связанного приложения MFC, поскольку нет необходимости связывать сам MFC. Это особенно верно в **deBUG** строит, где ссылка должна компактный отладка информации - путем ссылки на DLL, который уже содержит информацию об отладке, есть меньше отладки информации для компактного в вашем приложении.

Почему вы не должны использовать общую версию MFC:

- Доставка приложения, использующее общую библиотеку, требует, чтобы вы отправляли в вашу программу библиотеку MFCxx.DLL (и другие). MFCxx.DLL свободно переносится, как и многие DLLs, но вы все равно должны установить DLL в вашей программе SETUP. Кроме того, вы должны отправить MSVCRTxx.DLL, который содержит C-runtime библиотека, которая используется как вашей программы и MFC DLLs себя.

## <a name="how-to-write-an-mfc-extension-dll"></a><a name="_mfcnotes_how_to_write_an_mfc_extension_dll"></a>Как написать расширение MFC DLL

DLL MFC Extension — это DLL, содержащий классы и функции, написанные для приукрашивания функциональности классов MFC. MFC Extension DLL использует общие DLL MFC так же, как приложение использует его, с несколькими дополнительными соображениями:

- Процесс сборки аналогичен созданию приложения, использующее общие библиотеки MFC с несколькими дополнительными вариантами компилятора и связующим звеном.

- MFC Extension DLL не `CWinApp`имеет класса, полученного в результате получения.

- MFC Extension DLL должен `DllMain`предоставить специальный . AppWizard поставляет `DllMain` функцию, которую вы можете изменить.

- MFC Extension DLL обычно предоставляет процедуру инициализации для создания, `CDynLinkLibrary` `CRuntimeClass`если расширение MFC DLL желает экспортировать es или ресурсы в приложение. Полученный класс `CDynLinkLibrary` может быть использован, если данные по приложению должны поддерживаться DLL расширения MFC.

Эти соображения описаны более подробно ниже. Вы также должны обратиться к MFC Расширенные концепции образца [DLLHUSK,](../overview/visual-cpp-samples.md) поскольку он иллюстрирует:

- Создание приложения с использованием общих библиотек. (DLLHUSK. EXE - это приложение MFC, которое динамически связывается с библиотеками МФЦ, а также с другими DLL.)

- Строительство MFC расширение DLL. (Обратите внимание на `_AFXEXT` специальные флаги, такие как, которые используются при создании dLL расширения MFC)

- Два примера DLL расширения MFC. На одном из них показана базовая структура DLL расширения MFC с ограниченным экспортом (TESTDLL1), а на другом показана экспорт интерфейса всего класса (TESTDLL2).

Как клиентское приложение, так и любые DL-адреса расширения MFC должны использовать одну и ту же версию MFCxx.DLL. Вы должны следовать конвенции MFC DLL и предоставить как отладку и розничную (/релиз) версию вашего расширения MFC DLL. Это позволяет клиентским программам создавать как отладки, так и розничные версии своих приложений и связывать их с соответствующей отладкой или розничной версией всех DLL.

> [!NOTE]
> Из-за проблем с названием c', из-за проблем с экспортом, список экспорта из DLL расширения MFC может отличаться между отладки и розничными версиями одного и того же DLL и DLL для разных платформ. Розничная MFCxx.DLL имеет около 2000 экспортированных точек входа; отладка MFCxxD.DLL имеет около 3000 экспортированных точек входа.

### <a name="quick-note-on-memory-management"></a>Быстрая заметка об управлении памятью

В разделе, озаглавленном "Управление памятью", ближе к концу этой технической записки, описывается реализация MFCxx.DLL с общей версией MFC. Информация, которую необходимо знать для реализации только расширения MFC DLL описана здесь.

MFCxx.DLL и все DLL расширения MFC, загруженные в адресное пространство клиентского приложения, будут использовать тот же разллеть памяти, загрузку ресурсов и другие «глобальные» состояния MFC, как если бы они находились в одном приложении. Это важно, потому что библиотеки, не являющиеся MFC DLL и регулярные DLL MFC, которые статически ссылаются на MFC, делают прямо противоположное и имеют каждый DLL, выделяющий свой собственный пул памяти.

Если расширение MFC DLL выделяет память, то эта память может свободно смешиваться с любым другим объектом, выделенным приложением. Кроме того, если приложение, используюеееееееееобщие библиотеки MFC, выходит из строя, защита операционной системы сохранит целостность любого другого приложения MFC, разделяющего DLL.

Аналогичным образом другие "глобальные" государства MFC, такие как текущий исполняемый файл для загрузки ресурсов, также совместно распределяются между клиентским приложением и всеми DLL расширения MFC, а также mFCxx.DLL себя.

### <a name="building-an-mfc-extension-dll"></a>Строительство расширения MFC DLL

Вы можете использовать AppWizard для создания проекта DLL расширения MFC, и он будет автоматически генерировать соответствующие настройки компилятора и связующим звена. Кроме того, `DllMain` была создать функцию, которую можно изменить.

Если вы преобразуете существующий проект в DLL расширения MFC, начните со стандартных правил создания приложения с использованием общей версии MFC, а затем сделайте следующее:

- Добавьте **/D_AFXEXT** к флагам компилятора. В диалоге Project Properties выберите узл C/C.. Затем выберите категорию Preprocessor. Добавьте `_AFXEXT` к полю Define Macros, отделяя каждый из элементов с запятыми.

- Удалите коммутатор **/Gy** компилятора. В диалоге Project Properties выберите узл C/C.. Затем выберите категорию «Поколение кода». Убедитесь, что опция "Включить связь функционального уровня" не включена. Это упростит экспорт классов, поскольку ссылка не будет удалять неотсываемые функции. Если исходный проект используется для создания регулярного MFC DLL, статически связанного с MFC, измените опцию компилятора **/MT'd на** **/MD'd .**

- Создайте экспортную библиотеку с опцией **/DLL** link. Это будет установлено при создании новой цели, упомяной библиотеку Win32 Dynamic-Link в качестве целевого типа.

### <a name="changing-your-header-files"></a>Изменение файлов заголовка

Целью DLL расширения MFC обычно является экспорт некоторых общих функциональных возможностей в одно или несколько приложений, которые могут использовать эту функциональность. Это сводится к экспорту классов и глобальных функций, которые доступны для ваших клиентских приложений.

Для этого необходимо убедиться, что каждая из функций участника пометина как импорт или экспорт в соответствующих случаях. Это требует специальных `__declspec(dllexport)` `__declspec(dllimport)`деклараций: и . Когда ваши классы используются клиентскими приложениями, `__declspec(dllimport)`вы хотите, чтобы они были объявлены как . Когда mFC расширение DLL сам строится, они `__declspec(dllexport)`должны быть объявлены как . Кроме того, функции должны быть фактически экспортированы, так что клиентские программы привязываются к ним во время загрузки.

Для экспорта всего `AFX_EXT_CLASS` класса используйте определение класса. Этот макрос определяется `__declspec(dllexport)` рамкой как `_AFXDLL` когда и `_AFXEXT` определяется, но определяется как `__declspec(dllimport)` когда `_AFXEXT` не определено. `_AFXEXT`как описано выше, определяется только при построении вашего расширения MFC DLL. Пример:

```cpp
class AFX_EXT_CLASS CExampleExport : public CObject
{ /* ... class definition ... */ };
```

### <a name="not-exporting-the-entire-class"></a>Не экспортировать весь класс

Иногда вы можете экспортировать только отдельных необходимых членов вашего класса. Например, если вы экспортируете класс `CDialog`,derived, возможно, потребуется `DoModal` экспортировать конструктор и вызов. Вы можете экспортировать этих членов с помощью DLL' . ФАЙЛ DEF, но вы `AFX_EXT_CLASS` также можете использовать во многом таким же образом на отдельных членов, вам нужно экспортировать.

Пример:

```cpp
class CExampleDialog : public CDialog
{
public:
    AFX_EXT_CLASS CExampleDialog();
    AFX_EXT_CLASS int DoModal();
    // rest of class definition
    // ...
};
```

Когда вы делаете это, вы можете столкнуться с дополнительной проблемой, потому что вы больше не экспортируете всех членов класса. Проблема заключается в том, как работают макросы MFC. Некоторые из макросов-помощников MFC фактически декларируют или определяют данные. Таким образом, эти данные также должны быть экспортированы из вашего DLL.

Например, DECLARE_DYNAMIC макрос определяется следующим образом при создании DLL расширения MFC:

```cpp
#define DECLARE_DYNAMIC(class_name) \
protected: \
    static CRuntimeClass* PASCAL _GetBaseClass(); \
    public: \
    static AFX_DATA CRuntimeClass class##class_name; \
    virtual CRuntimeClass* GetRuntimeClass() const; \
```

Линия, которая начинается "статическая" `AFX_DATA`объявляет статический объект внутри вашего класса. Для правильного экспорта этого класса и доступа к информации о времени выполнения от клиента. EXE, вам нужно экспортировать этот статический объект. Поскольку статический объект объявляется `AFX_DATA`с помощью `AFX_DATA` модификатора, необходимо только определить, чтобы быть `__declspec(dllexport)` при создании DLL и определить его как `__declspec(dllimport)` при создании вашего клиента исполняемых.

Как уже `AFX_EXT_CLASS` говорилось выше, уже определено таким образом. Вам просто нужно переопределить, `AFX_DATA` чтобы `AFX_EXT_CLASS` быть таким же, как вокруг определения класса.

Пример:

```cpp
#undef  AFX_DATA
#define AFX_DATA AFX_EXT_CLASS
class CExampleView : public CView
{
    DECLARE_DYNAMIC()
    // ... class definition ...
};
#undef  AFX_DATA
#define AFX_DATA
```

MFC всегда `AFX_DATA` использует символ на элементах данных, которые он определяет в своих макросах, поэтому этот метод будет работать для всех таких сценариев. Например, он будет работать для DECLARE_MESSAGE_MAP.

> [!NOTE]
> Если вы экспортируете весь класс, а не выбранные члены класса, статические участники данных автоматически экспортируются.

Вы можете использовать тот же `CArchive` метод для автоматического экспорта оператора добычи для классов, которые используют DECLARE_SERIAL и IMPLEMENT_SERIAL макросов. Экспорт оператора архива, скобки классовых деклараций (расположен в . H файл) со следующим кодом:

```cpp
#undef AFX_API
#define AFX_API AFX_EXT_CLASS

/* your class declarations here */

#undef AFX_API
#define AFX_API
```

### <a name="limitations-of-_afxext"></a>Ограничения _AFXEXT

Вы можете использовать предпроцессорный символ**AFXEXT** для DLL расширения MFC до тех пор, пока у вас нет нескольких слоев DLL расширения MFC. Если у вас есть DLL расширения MFC, которые звонят или вытекают из классов в вашем собственном DLL расширения MFC, которые затем вытекают из классов MFC, вы должны использовать свой собственный символ предварительного процессора, чтобы избежать двусмысленности.

Проблема в том, что в Win32 вы `__declspec(dllexport)` должны прямо декларировать любые данные, как если бы они были экспортированы из DLL, и `__declspec(dllimport)` если они должны быть импортированы из DLL. При определении `_AFXEXT`заголовки MFC убедитесь, что `AFX_EXT_CLASS` это определено правильно.

Если у вас есть несколько `AFX_EXT_CLASS` слоев, один символ, такой как не является достаточным, так как расширение MFC DLL может экспортировать новые классы, а также импортировать другие классы из другого расширения MFC DLL. Для решения этой проблемы используйте специальный предпроцессорный символ, указывающий на то, что вы строите сам DLL по сравнению с использованием DLL. Например, представьте себе два расширения MFC DLL, A.DLL и B.DLL. Каждый из них экспортирует некоторые классы в A.H и B.H, соответственно. B.DLL использует классы от A.DLL. Файлы заголовка будут выглядеть примерно так:

```cpp
/* A.H */
#ifdef A_IMPL
    #define CLASS_DECL_A   __declspec(dllexport)
#else
    #define CLASS_DECL_A   __declspec(dllimport)
#endif

class CLASS_DECL_A CExampleA : public CObject
{ /* ... class definition ... */ };

/* B.H */
#ifdef B_IMPL
    #define CLASS_DECL_B   __declspec(dllexport)
#else
    #define CLASS_DECL_B   __declspec(dllimport)
#endif

class CLASS_DECL_B CExampleB : public CExampleA
{ /* ... class definition ... */ };
```

Когда A.DLL построен, он построен с **/ DA_IMPL** и когда B.DLL построен, он построен с **/ DB_IMPL**. Используя отдельные символы для каждого DLL, CExampleB экспортируется и CExampleA импортируется при создании B.DLL. CExampleA экспортируется при создании A.DLL и импортируется при использовании B.DLL (или другим клиентом).

Этот тип наслоения не может быть `AFX_EXT_CLASS` выполнен `_AFXEXT` при использовании встроенных и препроцессорных символов. Описанный выше метод решает эту проблему таким образом, который не отличается от механизма, который использует сам MFC при создании своих DLL расширения OL, Database и Network MFC.

### <a name="not-exporting-the-entire-class"></a>Не экспортировать весь класс

Опять же, вам придется принять особую осторожность, когда вы не экспортируете весь класс. Необходимо обеспечить правильную экспорт необходимых элементов данных, созданных макросами MFC. Это можно сделать путем переопределения `AFX_DATA` макроса вашего конкретного класса. Это должно быть сделано в любое время вы не экспортируете весь класс.

Пример:

```cpp
// A.H
#ifdef A_IMPL
    #define CLASS_DECL_A  _declspec(dllexport)
#else
    #define CLASS_DECL_A  _declspec(dllimport)
#endif

#undef  AFX_DATA
#define AFX_DATA CLASS_DECL_A

class CExampleA : public CObject
{
    DECLARE_DYNAMIC()
    CLASS_DECL_A int SomeFunction();
    // class definition
    // ...
};

#undef AFX_DATA
#define AFX_DATA
```

### <a name="dllmain"></a>DllMain

Ниже приводится точный код, который вы должны поместить в основной исходный файл для расширения MFC DLL. Он должен прийти после стандарта включает. Обратите внимание, что при использовании AppWizard для создания стартовых `DllMain` файлов для DLL расширения MFC, он поставляет для вас.

```cpp
#include "afxdllx.h"

static AFX_EXTENSION_MODULE extensionDLL;

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      // MFC extension DLL one-time initialization
      if (!AfxInitExtensionModule(
             extensionDLL, hInstance))
         return 0;

      // TODO: perform other initialization tasks here
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      // MFC extension DLL per-process termination
      AfxTermExtensionModule(extensionDLL);

      // TODO: perform other cleanup tasks here
   }
   return 1;   // ok
}
```

Вызов для `AfxInitExtensionModule` захвата модулей классов времени`CRuntimeClass` выполнения (структур), а также`COleObjectFactory` его объектов заводов `CDynLinkLibrary` (объектов) для использования позже, когда объект создается. (необязательный) `AfxTermExtensionModule` вызов позволяет MFC очистить расширение MFC DLL, когда каждый процесс отделяется (что происходит, когда процесс выходит, `FreeLibrary` или когда DLL выгружается в результате вызова) от расширения DLL MFC. Поскольку большинство DLL расширения MFC не загружаются динамически (обычно они `AfxTermExtensionModule` связаны через свои библиотеки импорта), вызов обычно не является необходимым.

Если ваше приложение загружается и высвобождается DLL расширения MFC динамически, не забудьте позвонить, `AfxTermExtensionModule` как показано выше. Также не `AfxLoadLibrary` забудьте `AfxFreeLibrary` использовать и (вместо `LoadLibrary` `FreeLibrary`функций Win32 и) если ваше приложение использует несколько потоков или если он динамически загружает расширение MFC DLL. Использование `AfxLoadLibrary` `AfxFreeLibrary` и гарантирует, что код запуска и выключения, выполняемый при загрузке и выгрузке расширения MFC, не портит глобальное состояние MFC.

Файл заголовка AFXDLLX. H содержит специальные определения для структур, используемых в DLL `CDynLinkLibrary`расширения MFC, такие как определение и `AFX_EXTENSION_MODULE` .

Глобальное *расширение* должно быть объявлено как показано на рисунке. В отличие от 16-битной версии MFC, вы можете выделить память и вызвать функции MFC в течение `DllMain` этого времени, так как MFCxx.DLL полностью инициализирован к моменту вызова.

### <a name="sharing-resources-and-classes"></a>Совместное использование ресурсов и классов

Простое расширение MFC DLLs нужно только экспортировать несколько функций с низкой пропускной способностью в клиентское приложение и не более того. Более пользовательский интерфейс интенсивных DLLs может потребоваться экспорт ресурсов и классов СЗ в клиентское приложение.

Экспорт ресурсов осуществляется через список ресурсов. В каждом приложении есть повседный список объектов. `CDynLinkLibrary` При поиске ресурса большинство стандартных реализаций MFC, которые загружают ресурсы, сначала смотрят на текущий модуль ресурсов ()`AfxGetResourceHandle`и если не находят, то идут по списку объектов, `CDynLinkLibrary` пытающихся загрузить запрашиваемый ресурс.

Динамическое создание объектов СЗ, учитываемых именем класса СЗ, аналогично. Механизм десериализации объектов MFC должен `CRuntimeClass` зарегистрировать все объекты, чтобы он мог реконструировать, динамически создавая объект с помощью требуемого типа на основе того, что хранилось ранее.

Если вы хотите, чтобы клиентское приложение использовало классы в DLL расширения MFC, которые являются, `DECLARE_SERIAL`то вам нужно будет экспортировать свои классы, чтобы быть видимым для клиентского приложения. Это также делается `CDynLinkLibrary` путем ходьбы список.

В случае MFC Advanced Concepts образец [DLLHUSK](../overview/visual-cpp-samples.md), список выглядит примерно так:

```Example
head ->   DLLHUSK.EXE   - or - DLLHUSK.EXE
               |                    |
          TESTDLL2.DLL         TESTDLL2.DLL
               |                    |
          TESTDLL1.DLL         TESTDLL1.DLL
               |                    |
               |                    |
           MFC90D.DLL           MFC90.DLL
```

MFCxx.DLL обычно занимает последнее последнее время в списке ресурсов и классов. MFCxx.DLL включает в себя все стандартные ресурсы MFC, включая строки для всех стандартных идов команд. Размещение его в хвосте списка позволяет DLLs и клиенту приложение само по себе не иметь свою собственную копию стандартных ресурсов MFC, но полагаться на общие ресурсы в MFCxx.DLL вместо.

Слияние ресурсов и имен классов всех DLLs в пространство имен клиентского приложения имеет недостаток, что вы должны быть осторожны, что идентиматы или имена вы выбираете. Конечно, вы можете отключить эту функцию, не экспортируя ни ваши ресурсы, ни `CDynLinkLibrary` объект клиентского приложения. Образец [DLLHUSK](../overview/visual-cpp-samples.md) управляет общим пространством имени ресурса с помощью нескольких файлов заголовков. Дополнительные советы по использованию общих файлов ресурсов можно узнать в [Technical Note 35.](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md)

### <a name="initializing-the-dll"></a>Инициализация DLL

Как уже упоминалось выше, вы, как правило, хотите создать `CDynLinkLibrary` объект для того, чтобы экспортировать свои ресурсы и классы в клиентское приложение. Для инициализации DLL необходимо предоставить пункт входа на экспорт. Минимально, это пустая рутина, которая не принимает никаких аргументов и ничего не возвращает, но это может быть все, что вам нравится.

Каждое клиентское приложение, которое хочет использовать Ваш DLL, должно назвать эту процедуру инициализации, если вы используете этот подход. Вы также можете `CDynLinkLibrary` выделить `DllMain` этот объект `AfxInitExtensionModule`в вашем сразу после вызова .

Процедура инициализации `CDynLinkLibrary` должна создать объект в куче текущего приложения, подключенный к информации о dLL расширения MFC. Это можно сделать следующим образом:

```cpp
extern "C" extern void WINAPI InitXxxDLL()
{
    new CDynLinkLibrary(extensionDLL);
}
```

Обычное *название, InitXxxDLL* в этом примере, может быть все, что вы хотите. Он не должен быть **extern "C",** но это делает список экспорта легче в обслуживании.

> [!NOTE]
> Если вы используете расширение MFC DLL от обычного DLL MFC, вы должны экспортировать эту функцию инициализации. Эта функция должна быть вызвана из регулярного MFC DLL перед использованием каких-либо mFC расширение DLL классов или ресурсов.

### <a name="exporting-entries"></a>Экспорт записей

Простой способ экспорта ваших `__declspec(dllimport)` классов `__declspec(dllexport)` заключается в использовании и на каждом классе и глобальной функции, которые вы хотите экспортировать. Это делает его намного проще, но менее эффективным, чем наименование каждой точки входа (описано ниже), так как у вас меньше контроля над тем, какие функции экспортируются, и вы не можете экспортировать функции по обычному. TESTDLL1 и TESTDLL2 используют этот метод для экспорта своих записей.

Более эффективным методом (и метод, используемый MFCxx.DLL) является экспорт каждой записи вручную, называя каждую запись в . Файл DEF. Поскольку мы экспортируем селективный экспорт из нашего DLL (то есть, не все), мы должны решить, какие конкретные интерфейсы мы хотим экспортировать. Это трудно, так как вы должны указать искаженные имена для linker в виде записей в . Файл DEF. Не экспортируйте какие-либо классы СЗ, если вам действительно не нужно иметь символическую ссылку для него.

Если вы пробовали экспортировать классы СЗ с помощью . DEF файл раньше, вы можете разработать инструмент для создания этого списка автоматически. Это можно сделать с помощью двухэтапного процесса ссылки. Свяжите свой DLL один раз без экспорта, и позвольте связующее звено для создания . Файл MAP. Teh. Map файл может быть использован для создания списка функций, которые должны быть экспортированы, так что с некоторыми перестановки, он может быть использован для создания ваших записей EXPORT для вашего . Файл DEF. С таким процессом был создан список экспорта для MFCxx.DLL и DLL расширения МФУ OLE и базы данных, число которых составляет несколько тысяч человек (хотя он не является полностью автоматическим и требует некоторой ручной настройки время от времени).

### <a name="cwinapp-vs-cdynlinklibrary"></a>CWinApp vs. CDynLinkLibrary

MFC Extension DLL не `CWinApp`имеет собственного объекта; вместо этого он `CWinApp`должен работать с производным объектом клиентского приложения. Это означает, что клиентское приложение владеет основным насосом сообщения, циклом простоя и так далее.

Если вашему DLL расширения MFC необходимо поддерживать дополнительные данные `CDynLinkLibrary` для каждого приложения, вы можете получить новый класс и создать его в режиме InitXxxDLL, описанном выше. При запуске DLL может проверить список `CDynLinkLibrary` объектов текущего приложения, чтобы найти список объектов для этого конкретного расширения MFC DLL.

### <a name="using-resources-in-your-dll-implementation"></a>Использование ресурсов в реализации DLL

Как уже упоминалось выше, нагрузка `CDynLinkLibrary` ресурсов по умолчанию будет ходить список объектов, ищущих первый EXE или DLL, который имеет запрошенный ресурс. Все AA-АДИ MFC, а `AfxFindResourceHandle` также все внутренние коды используются для ходьбы список ресурсов, чтобы найти любой ресурс, независимо от того, где он может проживать.

Если вы хотите загрузить ресурсы только из определенного места, используйте AA `AfxGetResourceHandle` и `AfxSetResourceHandle` сохраните старую ручку и установите новую ручку. Не забудьте восстановить старую ручку ресурса, прежде чем вернуться к клиенту приложения. Образец TESTDLL2 использует этот подход для явной загрузки меню.

Ходьба список имеет недостатки, что это немного медленнее и требует управления диапазонами идентификаторов ресурсов. Преимущество клиента в том, что клиентское приложение, которое ссылается на несколько DL-ресурсов расширения MFC, может использовать любой предоставленный DLL ресурс без указания рукоятки экземпляра DLL. `AfxFindResourceHandle`— это API, используемый для ходьбы по списку ресурсов для поиска данного совпадения. Он принимает имя и тип ресурса и возвращает ручку ресурса, где он был впервые найден (или NULL).

## <a name="writing-an-application-that-uses-the-dll-version"></a><a name="_mfcnotes_writing_an_application_that_uses_the_dll_version"></a>Написание приложения, использующего версию DLL

### <a name="application-requirements"></a>Требования к заявкам

Приложение, использующее общую версию MFC, должно следовать нескольким простым правилам:

- Он должен `CWinApp` иметь объект и следовать стандартным правилам для насоса сообщения.

- Он должен быть составлен с набором требуемых флагов компилятора (см. ниже).

- Он должен связываться с библиотеками импорта MFCxx. Установив требуемые флаги компилятора, заголовки MFC определяют время ссылки, с какой библиотекой приложение должно быть связано.

- Чтобы запустить исполняемый, MFCxx.DLL должен быть на пути или в каталоге системы Windows.

### <a name="building-with-the-development-environment"></a>Строительство с средой развития

Если вы используете внутренний makefile с большинством стандартных по умолчанию, вы можете легко изменить проект для создания версии DLL.

Следующий шаг предполагает, что у вас есть правильно функционирующее приложение MFC, связанное с NAFXCWD. LIB (для отладки) и NAFXCW. LIB (для розничной торговли), и вы хотите преобразовать его в общую версию библиотеки MFC. Вы работаете в среде Visual C и имеете внутренний файл проекта.

1. В меню **Проектов** нажмите **Свойства**. На **общей** странице в рамках **проекта по умолчанию**установите классы Фонда Майкрософт для **использования MFC в общей DLL** (MFCxx(d).d).dll).

### <a name="building-with-nmake"></a>Здание с NMAKE

Если вы используете внешнюю функцию makefile Visual C, или используете NMAKE напрямую, вам придется отсеивать свой makefile для поддержки компилятора и вариантов связующих

Обязательные флаги компилятора:

- **/D_AFXDLL /MD**
   **/D_AFXDLL**

Стандартные заголовки MFC должны быть определены:

- **/MD** Приложение должно использовать DLL-версию библиотеки c

Все остальные флаги компилятора следуют по умолчанию MFC (например, _DEBUG для отладки).

Оторите список библиотек. Измените NAFXCWD. LIB на MFCxxD.LIB и изменить NAFXCW. LIB к MFCxx.LIB. Замените LIBC. LIB с MSVCRT. Lib. Как и в любой другой библиотеке MFC, важно, чтобы MFCxxD.LIB размещался **перед** любыми библиотеками C-runtime.

Дополнительно добавляйте **/D_AFXDLL** как в розничные, так и к вариантам компилятора ресурсов (тот, который фактически компилирует ресурсы с **/R).** Это делает ваш окончательный исполняемый меньше, делясь ресурсами, которые присутствуют в MFC DLLs.

После внесения этих изменений требуется полное восстановление.

### <a name="building-the-samples"></a>Построение образцов

Большинство примерных программ MFC могут быть построены из Визуального СЗ или из общего nMAKE-совместимого MAKEFILE из командной строки.

Для преобразования любого из этих образцов в использование MFCxx.DLL можно загрузить . Файл MAK в визуальный C и установить параметры проекта, как описано выше. Если вы используете сборку NMAKE, вы можете указать "AFXDLL-1" в командной строке NMAKE и создать образец с помощью общих библиотек MFC.

Образец Передовых концепций MFC [DLLHUSK](../overview/visual-cpp-samples.md) построен с DLL-версией MFC. Этот пример не только иллюстрирует, как построить приложение, связанное с MFCxx.DLL, но и иллюстрирует другие особенности варианта упаковки MFC DLL, такие как MFC Extension DLLs, описанные позднее в этой технической записке.

### <a name="packaging-notes"></a>Упаковка примечаний

Розничная версия DLLs (MFCxx.ru). DLL) свободно перераспределительных. Версия отладки DLL не свободно переносится и должна использоваться только при разработке приложения.

Отладка DLL предоставляется с информацией об отладке. С помощью отладчика Visual C', вы можете проследить выполнение вашего приложения, а также DLL. Выпуск DLLs (MFCxx.RU) DLL) не содержат информации об отладке.

Если вы настраиваете или перестраиваете DLLs, то вы должны назвать их чем-то другим, чем "MFCxx" Файл MFC SFCMLL. MAK описывает параметры сборки и содержит логику переименования DLL. Переименование файлов необходимо, так как эти DLL потенциально разделяютмногие приложения MFC. После пользовательской версии MFC DLLs заменить те, которые установлены на системе может сломать другое приложение MFC с помощью общих MFC DLLs.

Восстановление MFC DLLs не рекомендуется.

## <a name="how-the-mfcxxdll-is-implemented"></a><a name="_mfcnotes_how_the_mfc30.dll_is_implemented"></a>Как реализуется MFCxx.DLL

В следующем разделе описывается, как реализуется MFC DLL (MFCxx.DLL и MFCxxD.DLL). Понимание деталей здесь также не важно, если все, что вы хотите сделать, это использовать MFC DLL с вашим приложением. Детали здесь не являются существенными для понимания того, как написать расширение MFC DLL, но понимание этой реализации может помочь вам написать свой собственный DLL.

### <a name="implementation-overview"></a>Обзор реализации

MFC DLL действительно особый случай расширения MFC DLL, как описано выше. Он имеет очень большое количество экспорта для большого числа классов. Есть несколько дополнительных вещей, которые мы делаем в MFC DLL, которые делают его еще более особенным, чем регулярное расширение MFC DLL.

### <a name="win32-does-most-of-the-work"></a>Win32 делает большую часть работы

16-битная версия MFC нуждалась в ряде специальных методов, включая данные по приложению в сегменте стека, специальные сегменты, созданные сборочным кодом 80x86, контексты исключения для процессов и другие методы. Win32 непосредственно поддерживает данные по процессу в DLL, что и требуется большую часть времени. По большей части MFCxx.DLL просто NAFXCW. LIB упакованв в DLL. Если вы посмотрите на исходный код MFC, вы найдете очень мало #ifdef _AFXDLL, так как Есть очень мало специальных случаев, которые должны быть сделаны. Специальные случаи, которые есть специально для решения Win32 на Windows 3.1 (иначе известный как Win32s). Win32s не поддерживает данные DLL на самом деле на основе обработки, поэтому MFC DLL должен использовать aIS-аПЫ для локального хранения данных (TLS) Win32 для получения локальных данных обработки.

### <a name="impact-on-library-sources-additional-files"></a>Влияние на библиотечные источники, дополнительные файлы

Влияние **_AFXDLL** версии на обычные источники библиотеки и заголовки классов MFC относительно незначительны. Существует специальная версия файла (AFXV_DLL. H), а также дополнительный файл заголовка (AFXDLL_. H) включены в основной AFXWIN. H заголовок. The AFXDLL_. H заголовок `CDynLinkLibrary` включает в себя класс `_AFXDLL` и другие детали реализации как приложений, так и DLL расширения MFC. The AFXDLLX. H заголовок предоставляется для создания MFC расширение DLLs (см. выше для деталей).

Регулярные источники в библиотеке МФЦ в МФЦ `_AFXDLL` SRC имеют некоторые дополнительные условный код в соответствии с #ifdef. Дополнительный исходный файл (DLLINIT. CPP) содержит дополнительный код инициализации DLL и другой клей для общей версии MFC.

Для создания общей версии MFC предоставляются дополнительные файлы. (См. ниже для получения подробной информации о том, как построить DLL.)

- Два. Файлы DEF используются для экспорта точек входа MFC DLL для отладки (MFCxxD.DEF) и выпуска (MFCxx.DEF) версий DLL.

- An . RC файл (MFCDLL. RC) содержит все стандартные ресурсы MFC и ресурс VERSIONINFO для DLL.

- A . Файл CLW (MFCDLL. CLW) предоставляется, чтобы разрешить просмотр классов MFC с помощью ClassWizard. Примечание: эта функция не является особенной для версии DLL MFC.

### <a name="memory-management"></a>Управление памятью

Приложение с использованием MFCxx.DLL использует общий разлкат памяти, предоставляемый MSVCRTxx.DLL, общим C-runtime DLL. Приложение, любое расширение MFC DLLs, а также MFC DLLs сами используют этот общий разлкот памяти. Используя общий DLL для распределения памяти, DLL MFC может выделять память, которая позже освобождается приложением или наоборот. Поскольку и приложение, и DLL должны использовать один и тот же allocator, не следует переопределять **глобального оператора** c's new или **оператора на удаление.** Те же правила применяются к остальной части C времени распределения памяти процедур (таких, как **malloc**, **realloc**, **бесплатно**, и другие).

### <a name="ordinals-and-class-__declspecdllexport-and-dll-naming"></a>Ординала и класс __declspec (dllexport) и наименование DLL

Мы не используем `class` **__declspec (dllexport)** функциональность компилятора СЗ. Вместо этого, список экспорта включен с источниками библиотеки класса (MFCxx.DEF и MFCxxD.DEF). Экспортируются только эти выбранные наборы точек входа (функции и данные). Другие символы, такие как частные функции реализации MFC или классы, не экспортируются Все экспорты выполняются по ординаторской без строки имя в таблице имени резидента или нерезидента.

Использование `class` **__declspec (dllexport)** может быть жизнеспособной альтернативой для создания небольших DLL, но в случае большого DLL, как MFC, механизм экспорта по умолчанию имеет эффективность и ограничения мощности.

Что все это означает, что мы можем упаковать большое количество функциональности в выпуске MFCxx.DLL, что составляет всего около 800 кБ без ущерба для большого исполнения или скорости загрузки. MFCxx.DLL был бы на 100 K больше, если бы этот метод не был использован. Это также позволяет добавлять дополнительные точки входа в конце . ФАЙЛ DEF позволяет простые версии без ущерба для скорости и размера эффективности экспорта по ординатору. Основные изменения версий в библиотеке класса MFC изменят название библиотеки. То есть, MFC30. DLL — это перераспределителяемый DLL, содержащий версию 3.0 библиотеки класса MFC. Обновление этого DLL, скажем, в гипотетической MFC 3.1, DLL будет называться MFC31. DLL вместо. Опять же, если вы измените исходный код MFC для создания пользовательской версии MFC DLL, используйте другое имя (и желательно одно без "MFC" в названии).

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
