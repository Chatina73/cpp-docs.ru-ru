---
title: TN033. Версия библиотеки DLL MFC
ms.date: 06/28/2018
helpviewer_keywords:
- MFC DLLs [MFC], writing MFC extension DLLS
- AFXDLL library
- DLLs [MFC], MFC
- DLL version of MFC [MFC]
- TN033
ms.assetid: b6f1080b-b66b-4b1e-8fb1-926c5816392c
ms.openlocfilehash: c627f891efc893f4eb8dae4bfb0b3b78f7af1a46
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87215937"
---
# <a name="tn033-dll-version-of-mfc"></a>TN033. Версия библиотеки DLL MFC

Это примечание описывает, как можно использовать MFCxx.DLL и MFCxxD.DLL (где x — номер версии MFC) Общие библиотеки динамической компоновки с приложениями MFC и библиотеками DLL расширения MFC. Дополнительные сведения о регулярных библиотеках DLL MFC см. в разделе [Использование MFC в составе библиотеки DLL](../mfc/tn011-using-mfc-as-part-of-a-dll.md).

В этом техническом примечании рассматриваются три аспекта библиотек DLL. Последние два — для более опытных пользователей:

- [Создание библиотеки DLL расширения MFC](#_mfcnotes_how_to_write_an_mfc_extension_dll)

- [Создание приложения MFC, использующего версию библиотеки MFC](#_mfcnotes_writing_an_application_that_uses_the_dll_version)

- [Как реализуются общие библиотеки динамической компоновки MFC](#_mfcnotes_how_the_mfc30.dll_is_implemented)

Если вы заинтересованы в создании библиотеки DLL с помощью MFC, которую можно использовать с приложениями, не использующими MFC (это называется обычной библиотекой DLL MFC), см. [техническое примечание 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md).

## <a name="overview-of-mfcxxdll-support-terminology-and-files"></a>Общие сведения о поддержке MFCxx.DLL: терминологии и файлах

**Обычная библиотека DLL MFC**. для создания ИЗОЛИРОВАНной библиотеки DLL с использованием некоторых классов MFC используется обычная библиотека DLL MFC. В границах приложения или библиотеки DLL используются интерфейсы C, а клиентское приложение не обязательно должно быть приложением MFC.

Это версия библиотеки DLL, поддерживаемой в MFC 1,0. Он описан в [техническом примечании 11](../mfc/tn011-using-mfc-as-part-of-a-dll.md) и пример [DLLScreenCap](../overview/visual-cpp-samples.md)с MFC Advanced концепциями.

> [!NOTE]
> Начиная с версии Visual C++ 4,0 термин **усрдлл** устарел и заменен обычной библиотекой DLL MFC, которая статически связывается с MFC. Вы также можете создать обычную библиотеку DLL MFC, которая динамически связывается с MFC.

MFC 3,0 (и более поздние версии) поддерживает регулярные библиотеки DLL MFC со всеми новыми функциями, включая классы OLE и базы данных.

**AFXDLL**: это также называется общей версией библиотек MFC. Это новая поддержка DLL, добавленная в MFC 2,0. Сама библиотека MFC находится в нескольких библиотеках DLL (описанных ниже), а клиентское приложение или библиотека DLL динамически связывают необходимые библиотеки DLL. Интерфейсы через границы приложения или библиотеки DLL являются интерфейсами классов C++/МФК. Клиентское приложение должно быть приложением MFC. Поддерживает все функции MFC 3,0 (исключение: Юникод не поддерживается для классов базы данных).

> [!NOTE]
> Начиная с версии Visual C++ 4,0 этот тип DLL называется "DLL расширения".

В этом заметке будет использоваться MFCxx.DLL для ссылки на весь набор DLL MFC, в том числе:

- Отладка: MFCxxD.DLL (Объединенная) и Мфксксксд. LIB (статическая).

- Выпуск: MFCxx.DLL (Объединенная) и Мфкскскс. LIB (static).

- Отладка в Юникоде: MFCxxUD.DLL (Объединенная) и Мфксксксд. LIB (static).

- Выпуск Юникод: MFCxxU.DLL (Объединенная) и Мфксксксу. LIB (статический).

> [!NOTE]
> Мфкскскс [U] [D]. Библиотеки LIB используются совместно с общими библиотеками DLL MFC. Эти библиотеки содержат код, который должен быть статически связан с приложением или библиотекой DLL.

Приложение связывается с соответствующими библиотеками импорта:

- Отладка: Мфкксксд. LIB

- Выпуск: Мфккскс. LIB

- Отладка Юникода: Мфкксксуд. LIB

- Выпуск Юникод: Мфкксксу. LIB

Библиотека DLL расширения MFC — это библиотека DLL, созданная на основе MFCxx.DLL (или других общих библиотек DLL MFC). Здесь начинается архитектура компонентов MFC. Если вы наследуете от класса MFC полезный класс или создаете другой набор средств, аналогичных MFC, его можно поместить в библиотеку DLL. Эта библиотека DLL использует MFCxx.DLL, как и конечное клиентское приложение. Это позволяет многократно использовать конечные классы, повторно используемые базовые классы и классы представлений и документов с возможностью повторного использования.

## <a name="pros-and-cons"></a>Плюсы и минусы

Зачем использовать общую версию MFC

- Использование общей библиотеки может привести к небольшим приложениям (минимальное приложение, использующее большую часть библиотеки MFC, меньше 10 000).

- Общая версия MFC поддерживает библиотеки DLL расширения MFC и регулярные библиотеки DLL MFC.

- Создание приложения, использующего общие библиотеки MFC, выполняется быстрее, чем создание статически связанного приложения MFC, поскольку нет необходимости связывать саму MFC. Это особенно справедливо в **отладочных** сборках, где компоновщик должен сжимать отладочную информацию — путем СВЯЗЫВАНИЯ с библиотекой DLL, которая уже содержит отладочную информацию, в приложении меньше отладочной информации.

Зачем не использовать общую версию MFC:

- Доставка приложения, использующего общую библиотеку, требует доставки библиотеки MFCxx.DLL (и других) вместе с программой. MFCxx.DLL свободно распространяемым, как и многие библиотеки DLL, но все равно необходимо установить библиотеку DLL в программе установки. Кроме того, необходимо поставлять MSVCRTxx.DLL, который содержит библиотеку времени выполнения C, которая используется программой и библиотеками DLL MFC.

## <a name="how-to-write-an-mfc-extension-dll"></a><a name="_mfcnotes_how_to_write_an_mfc_extension_dll"></a>Написание библиотеки DLL расширения MFC

Библиотека DLL расширения MFC — это библиотека DLL, содержащая классы и функции, написанные для надстрочных функций классов MFC. Библиотека DLL расширения MFC использует общие библиотеки DLL MFC так же, как приложение использует его, с несколькими дополнительными соображениями.

- Процесс сборки аналогичен созданию приложения, использующего общие библиотеки MFC с несколькими дополнительными параметрами компилятора и компоновщика.

- Библиотека DLL расширения MFC не имеет `CWinApp` производного класса.

- Библиотека DLL расширения MFC должна предоставлять специальное значение `DllMain` . Помощью мастера предоставляет `DllMain` функцию, которую можно изменить.

- Библиотека DLL расширения MFC обычно предоставляет подпрограммы инициализации для создания, `CDynLinkLibrary` Если библиотека DLL расширения MFC хочет экспортировать `CRuntimeClass` ES или Resources в приложение. Производный класс `CDynLinkLibrary` может использоваться, если данные каждого приложения должны поддерживаться библиотекой DLL расширения MFC.

Эти рекомендации подробно описаны ниже. Также следует ознакомиться с примером "Дополнительные понятия MFC" [DLLHUSK](../overview/visual-cpp-samples.md) , как показано ниже.

- Создание приложения с помощью общих библиотек. (DLLHUSK.EXE — это приложение MFC, которое динамически связывается с библиотеками MFC, а также с другими библиотеками DLL.)

- Создание библиотеки DLL расширения MFC. (Обратите внимание на специальные флаги, такие как `_AFXEXT` , используемые при построении библиотеки DLL расширения MFC).

- Два примера библиотек DLL расширения MFC. В одной показана базовая структура библиотеки DLL расширения MFC с ограниченными экспортами (TESTDLL1), а другая — экспорт всего интерфейса класса (TESTDLL2).

Как клиентское приложение, так и любая библиотека DLL расширения MFC должны использовать одну и ту же версию MFCxx.DLL. Следует соблюдать соглашение MFC DLL и предоставить версию библиотеки DLL расширения MFC для отладки и розничной торговли (/Release). Это позволяет клиентским программам создавать отладочные и розничные версии своих приложений и связывать их с соответствующей отладочной или коммерческой версией всех библиотек DLL.

> [!NOTE]
> Так как проблемы с искажением и экспортом имен C++, список экспорта из библиотеки DLL расширения MFC может отличаться между версиями отладки и розничной версии одной и той же библиотеки DLL и библиотек DLL для разных платформ. Розничная MFCxx.DLL содержит около 2000 экспортированных точек входа; MFCxxD.DLL отладки содержит около 3000 экспортированных точек входа.

### <a name="quick-note-on-memory-management"></a>Быстрая Заметка об управлении памятью

В разделе "Управление памятью" около конца этой технической заметки описывается реализация MFCxx.DLL с общей версией MFC. Сведения, которые необходимо знать для реализации только библиотеки DLL расширения MFC, описаны здесь.

MFCxx.DLL и все библиотеки DLL расширения MFC, загруженные в адресное пространство клиентского приложения, будут использовать один и тот же распределитель памяти, загрузку ресурсов и другие глобальные состояния MFC, как если бы они находились в одном приложении. Это важно, так как библиотеки DLL, не относящиеся к MFC, и обычные библиотеки MFC, которые статически связываются с MFC, выполняют точную противоположность и каждый DLL выделяется из собственного пула памяти.

Если библиотека DLL расширения MFC выделяет память, то эта память может свободно смешивание с любым другим объектом, выделенным приложением. Кроме того, если приложение, использующее общие библиотеки MFC, аварийно завершает работу, защита операционной системы будет поддерживать целостность любых других приложений MFC, совместно использующих библиотеку DLL.

Аналогично другим глобальным состояниям MFC, таким как текущий исполняемый файл для загрузки ресурсов, также совместно используются клиентское приложение и все библиотеки DLL расширения MFC, а также сам MFCxx.DLL.

### <a name="building-an-mfc-extension-dll"></a>Создание библиотеки DLL расширения MFC

Помощью мастера можно использовать для создания проекта библиотеки DLL расширения MFC, который автоматически создаст соответствующие параметры компилятора и компоновщика. Она также создавала `DllMain` функцию, которую можно изменить.

Если вы преобразуете существующий проект в библиотеку DLL расширения MFC, начните с стандартных правил для создания приложения с помощью общей версии MFC, а затем выполните следующие действия.

- Добавление **/D_AFXEXT** к флагам компилятора. В диалоговом окне Свойства проекта выберите узел C/C++. Затем выберите категорию препроцессора. Добавьте `_AFXEXT` в поле define Macros (определение макросов), разделяя каждый элемент точкой с запятой.

- Удалите параметр компилятора **/Gy** . В диалоговом окне Свойства проекта выберите узел C/C++. Затем выберите категорию создание кода. Убедитесь, что параметр "включить компоновку на уровне функций" не включен. Это упростит экспорт классов, так как компоновщик не удаляет функции, не имеющие ссылок. Если исходный проект используется для создания обычной библиотеки DLL MFC, которая статически связана с MFC, измените параметр компилятора **/MT [d]** на **/MD [d]**.

- Создайте библиотеку экспорта с параметром **/DLL** для связывания. Это значение будет задано при создании нового целевого объекта с указанием библиотеки динамической компоновки Win32 в качестве целевого типа.

### <a name="changing-your-header-files"></a>Изменение файлов заголовков

Библиотека DLL расширения MFC обычно используется для экспорта некоторых стандартных функций в одно или несколько приложений, которые могут использовать эти функции. Это сводится к экспорту классов и глобальных функций, доступных для клиентских приложений.

Для этого необходимо убедиться, что каждая из функций-членов помечена как импортируемая или экспортируемая по мере необходимости. Для этого требуются специальные объявления: `__declspec(dllexport)` и `__declspec(dllimport)` . Если классы используются клиентскими приложениями, их необходимо объявлять как `__declspec(dllimport)` . При сборке библиотеки DLL расширения MFC ее следует объявлять как `__declspec(dllexport)` . Кроме того, функции должны быть экспортированы, поэтому клиентские программы будут привязаны к ним во время загрузки.

Чтобы экспортировать весь класс, используйте `AFX_EXT_CLASS` в определении класса. Этот макрос определяется платформой так, как `__declspec(dllexport)` Если `_AFXDLL` и `_AFXEXT` определен, но определяется, как `__declspec(dllimport)` Если `_AFXEXT` не определен. `_AFXEXT`как описано выше, определяется только при создании библиотеки DLL расширения MFC. Пример:

```cpp
class AFX_EXT_CLASS CExampleExport : public CObject
{ /* ... class definition ... */ };
```

### <a name="not-exporting-the-entire-class"></a>Неполный экспорт класса

Иногда может потребоваться экспортировать только отдельные необходимые члены класса. Например, при экспорте класса, производного от `CDialog`, может потребоваться экспортировать только конструктор и вызов `DoModal`. Эти члены можно экспортировать с помощью библиотеки DLL. DEF, но его также можно использовать практически так же, как и для `AFX_EXT_CLASS` отдельных элементов, которые необходимо экспортировать.

Пример:

```cpp
class CExampleDialog : public CDialog
{
public:
    AFX_EXT_CLASS CExampleDialog();
    AFX_EXT_CLASS int DoModal();
    // rest of class definition
    // ...
};
```

При этом может возникнуть дополнительная проблема, так как вы больше не экспортируете все члены класса. Проблема заключается в способе работы макросов MFC. Некоторые из вспомогательных макросов MFC объявляют или определяют элементы данных. Поэтому эти члены данных также должны быть экспортированы из библиотеки DLL.

Например, макрос DECLARE_DYNAMIC определяется следующим образом при построении библиотеки DLL расширения MFC.

```cpp
#define DECLARE_DYNAMIC(class_name) \
protected: \
    static CRuntimeClass* PASCAL _GetBaseClass(); \
    public: \
    static AFX_DATA CRuntimeClass class##class_name; \
    virtual CRuntimeClass* GetRuntimeClass() const; \
```

Строка, начинающаяся с "static `AFX_DATA` ", объявляет статический объект внутри класса. Чтобы правильно экспортировать этот класс и получить доступ к сведениям о времени выполнения от клиента. EXE, необходимо экспортировать этот статический объект. Поскольку статический объект объявляется с модификатором `AFX_DATA`, необходимо определить только `AFX_DATA` как `__declspec(dllexport)` при сборке библиотеки DLL и определить ее как `__declspec(dllimport)` при сборке исполняемого файла клиента.

Как упоминалось выше, `AFX_EXT_CLASS` уже определено таким образом. Необходимо просто переопределить, `AFX_DATA` чтобы они совпадали с `AFX_EXT_CLASS` определением класса.

Пример:

```cpp
#undef  AFX_DATA
#define AFX_DATA AFX_EXT_CLASS
class CExampleView : public CView
{
    DECLARE_DYNAMIC()
    // ... class definition ...
};
#undef  AFX_DATA
#define AFX_DATA
```

MFC всегда использует `AFX_DATA` символ для элементов данных, которые он определяет в макросах, поэтому этот метод будет работать для всех таких сценариев. Например, он будет работать для DECLARE_MESSAGE_MAP.

> [!NOTE]
> При экспорте всего класса вместо отдельных элементов класса статические элементы данных экспортируются автоматически.

Эту же методику можно использовать для автоматического экспорта `CArchive` оператора извлечения для классов, использующих макросы DECLARE_SERIAL и IMPLEMENT_SERIAL. Экспортируйте оператор архива, забавив в скобки объявления класса (расположенные в. H-файл) со следующим кодом:

```cpp
#undef AFX_API
#define AFX_API AFX_EXT_CLASS

/* your class declarations here */

#undef AFX_API
#define AFX_API
```

### <a name="limitations-of-_afxext"></a>Ограничения для символа _AFXEXT

Вы можете использовать символ предварительного процессора _**афксекст** для библиотек DLL расширения MFC при условии, что у вас нет нескольких слоев библиотек DLL расширения MFC. Если у вас есть библиотеки DLL для расширения MFC, которые вызывают или выводят классы из ваших собственных библиотек DLL для расширения MFC, а те, в свою очередь, используют производные классы MFC, вам потребуется использовать собственный символ препроцессора, чтобы избежать неоднозначности.

Проблема заключается в том, что в Win32 необходимо явно объявлять любые данные так, как `__declspec(dllexport)` если бы они были экспортированы из библиотеки DLL, и `__declspec(dllimport)` импортировать их из библиотеки DLL. При определении `_AFXEXT` заголовков MFC убедитесь, что `AFX_EXT_CLASS` они определены правильно.

При наличии нескольких слоев один символ, например, недостаточно `AFX_EXT_CLASS` , так как библиотека DLL расширения MFC может экспортировать новые классы, а также импортировать другие классы из другой библиотеки DLL расширения MFC. Чтобы справиться с этой проблемой, используйте специальный символ препроцессора, который указывает, что вы создаете саму библиотеку DLL и не используете библиотеку DLL. Например, представьте две библиотеки DLL расширения MFC, A.DLL и B.DLL. Каждый из них экспортирует некоторые классы в. H и B. H соответственно. B.DLL использует классы из A.DLL. Файлы заголовка будут выглядеть примерно так:

```cpp
/* A.H */
#ifdef A_IMPL
    #define CLASS_DECL_A   __declspec(dllexport)
#else
    #define CLASS_DECL_A   __declspec(dllimport)
#endif

class CLASS_DECL_A CExampleA : public CObject
{ /* ... class definition ... */ };

/* B.H */
#ifdef B_IMPL
    #define CLASS_DECL_B   __declspec(dllexport)
#else
    #define CLASS_DECL_B   __declspec(dllimport)
#endif

class CLASS_DECL_B CExampleB : public CExampleA
{ /* ... class definition ... */ };
```

При построении A.DLL создается с помощью **/DA_IMPL** и при построении B.DLL он создается с помощью **/DB_IMPL**. Используя отдельные символы для каждой библиотеки DLL, Цексамплеб экспортируется и Цексамплеа импортируется при построении B.DLL. Цексамплеа экспортируется при построении A.DLL и импортируется при использовании B.DLL (или другого клиента).

Этот тип уровней не может быть выполнен при использовании встроенных `AFX_EXT_CLASS` и `_AFXEXT` символов препроцессора. Описанный выше метод решает эту проблему в отличие от механизма, который сама использует библиотека MFC при построении библиотек DLL расширения MFC, базы данных и сети.

### <a name="not-exporting-the-entire-class"></a>Неполный экспорт класса

Опять же, вам придется уделять особое внимание, если вы не экспортируете весь класс. Необходимо убедиться, что необходимые элементы данных, созданные с помощью макросов MFC, экспортированы правильно. Это можно сделать с помощью повторного определения `AFX_DATA` макроса для конкретного класса. Это нужно делать каждый раз, когда вы экспортируете класс не полностью.

Пример:

```cpp
// A.H
#ifdef A_IMPL
    #define CLASS_DECL_A  _declspec(dllexport)
#else
    #define CLASS_DECL_A  _declspec(dllimport)
#endif

#undef  AFX_DATA
#define AFX_DATA CLASS_DECL_A

class CExampleA : public CObject
{
    DECLARE_DYNAMIC()
    CLASS_DECL_A int SomeFunction();
    // class definition
    // ...
};

#undef AFX_DATA
#define AFX_DATA
```

### <a name="dllmain"></a>DllMain

Ниже приведен точный код, который необходимо поместить в основной исходный файл для библиотеки DLL расширения MFC. Он должен следовать после стандартных включений. Обратите внимание, что при использовании помощью мастера для создания начальных файлов для библиотеки DLL расширения MFC она предоставляет `DllMain` для вас.

```cpp
#include "afxdllx.h"

static AFX_EXTENSION_MODULE extensionDLL;

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      // MFC extension DLL one-time initialization
      if (!AfxInitExtensionModule(
             extensionDLL, hInstance))
         return 0;

      // TODO: perform other initialization tasks here
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      // MFC extension DLL per-process termination
      AfxTermExtensionModule(extensionDLL);

      // TODO: perform other cleanup tasks here
   }
   return 1;   // ok
}
```

Вызов для `AfxInitExtensionModule` захвата классов среды выполнения ( `CRuntimeClass` структур), а также фабрик объектов ( `COleObjectFactory` объектов) для последующего использования при `CDynLinkLibrary` создании объекта. Вызов метода `AfxTermExtensionModule` позволяет MFC очищать библиотеку DLL расширения MFC при отсоединении каждого процесса (что происходит при завершении процесса или при выгрузке библиотеки DLL в результате `FreeLibrary` вызова) из библиотеки DLL расширения MFC. Так как большинство библиотек DLL расширения MFC не загружаются динамически (обычно они связаны с помощью библиотек импорта), вызов метода `AfxTermExtensionModule` обычно не требуется.

Если приложение загружает и освобождает библиотеки DLL расширения MFC динамически, обязательно вызовите метод, `AfxTermExtensionModule` как показано выше. Также обязательно используйте `AfxLoadLibrary` и `AfxFreeLibrary` (вместо функций Win32 `LoadLibrary` и `FreeLibrary` ), если приложение использует несколько потоков или динамически загружает библиотеку DLL расширения MFC. С помощью `AfxLoadLibrary` и `AfxFreeLibrary` гарантируется, что код запуска и завершения работы, выполняемый при загрузке и ВЫГРУЗКЕ библиотеки DLL расширения MFC, не повреждает глобальное состояние MFC.

Файл заголовка АФКСДЛЛКС. H содержит специальные определения структур, используемых в библиотеках DLL расширения MFC, например определение для `AFX_EXTENSION_MODULE` и `CDynLinkLibrary` .

Глобальный *екстенсиондлл* должен быть объявлен как показано ниже. В отличие от 16-разрядной версии MFC, можно выделить память и вызвать функции MFC в это время, так как MFCxx.DLL полностью инициализируется на время `DllMain` вызова.

### <a name="sharing-resources-and-classes"></a>Совместное использование ресурсов и классов

Простые библиотеки расширения MFC требуют только экспортировать несколько функций с низкой пропускной способностью в клиентское приложение и ничего больше. Для большего числа библиотек DLL с интенсивным использованием пользовательского интерфейса может потребоваться экспортировать ресурсы и классы C++ в клиентское приложение.

Экспорт ресурсов осуществляется посредством списка ресурсов. В каждом приложении используется однонаправленный список `CDynLinkLibrary` объектов. При поиске ресурса большинство стандартных реализаций MFC, которые загружают ресурсы, сначала выглядят в текущем модуле ресурсов ( `AfxGetResourceHandle` ), а если не найдены, то список `CDynLinkLibrary` объектов, пытающихся загрузить запрошенный ресурс.

Динамическое создание объектов C++ с именем класса C++ аналогично. Механизм десериализации объектов MFC должен иметь `CRuntimeClass` зарегистрированные объекты, чтобы его можно было восстановить путем динамического создания объекта C++ требуемого типа в зависимости от того, что было сохранено ранее.

Если требуется, чтобы клиентское приложение использовало классы в библиотеке DLL расширения MFC, которые являются, необходимо экспортировать классы, которые должны `DECLARE_SERIAL` быть видимыми для клиентского приложения. Это также делается путем прохода по `CDynLinkLibrary` списку.

В случае с примером "Дополнительные понятия MFC" [DLLHUSK](../overview/visual-cpp-samples.md)список выглядит примерно следующим образом:

```Example
head ->   DLLHUSK.EXE   - or - DLLHUSK.EXE
               |                    |
          TESTDLL2.DLL         TESTDLL2.DLL
               |                    |
          TESTDLL1.DLL         TESTDLL1.DLL
               |                    |
               |                    |
           MFC90D.DLL           MFC90.DLL
```

MFCxx.DLL, как правило, является последним в списке ресурсов и классов. MFCxx.DLL включает все стандартные ресурсы MFC, включая строки запросов для всех стандартных идентификаторов команд. Помещение его в конец списка позволяет библиотекам DLL и клиентскому приложению не иметь собственной копии стандартных ресурсов MFC, но вместо этого использовать общие ресурсы в MFCxx.DLL.

Объединение ресурсов и имен классов всех библиотек DLL в пространство имен клиентского приложения имеет недостатки, которые необходимо учитывать при выборе идентификаторов или имен. Разумеется, эту функцию можно отключить, не экспортировав ресурсы или `CDynLinkLibrary` объект в клиентское приложение. Пример [DLLHUSK](../overview/visual-cpp-samples.md) управляет пространством имен общих ресурсов с помощью нескольких файлов заголовков. Дополнительные советы по использованию файлов общих ресурсов см. в [техническом примечании 35](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md) .

### <a name="initializing-the-dll"></a>Инициализация библиотеки DLL

Как упоминалось выше, для `CDynLinkLibrary` экспорта ресурсов и классов в клиентское приложение, как правило, требуется создать объект. Необходимо будет указать экспортированную точку входа для инициализации библиотеки DLL. Как минимум, это подпрограммы типа void, которая не принимает аргументы и не возвращает ничего, но может быть любым.

Каждое клиентское приложение, желающее использовать вашу библиотеку DLL, должно вызывать эту подпрограммы инициализации при использовании такого подхода. Вы также можете выделить этот `CDynLinkLibrary` объект в `DllMain` сразу после вызова `AfxInitExtensionModule` .

Подпрограммы инициализации должны создать `CDynLinkLibrary` объект в куче текущего приложения, проводных до сведений о библиотеке DLL расширения MFC. Это можно сделать следующим образом:

```cpp
extern "C" extern void WINAPI InitXxxDLL()
{
    new CDynLinkLibrary(extensionDLL);
}
```

Имя подпрограммы, *инитксксксдлл* в этом примере, может быть любым. Это не обязательно должен быть **внешний "C"**, но это упрощает обслуживание списка экспорта.

> [!NOTE]
> Если вы используете библиотеку DLL расширения MFC из обычной библиотеки DLL MFC, необходимо экспортировать эту функцию инициализации. Эта функция должна вызываться из обычной библиотеки DLL MFC перед использованием любых классов или ресурсов DLL расширения MFC.

### <a name="exporting-entries"></a>Экспорт записей

Простой способ экспорта классов заключается в использовании `__declspec(dllimport)` `__declspec(dllexport)` функций и для каждого класса и глобальной функции, которую вы хотите экспортировать. Это намного проще, но менее эффективно, чем именование каждой точки входа (описанной ниже), так как вы менее контролируете экспортируемые функции и не можете экспортировать функции по порядковому номеру. TESTDLL1 и TESTDLL2 используют этот метод для экспорта записей.

Более эффективный метод (и метод, используемый MFCxx.DLL) заключается в экспорте каждой записи вручную путем именования каждой записи в. DEF файл. Так как мы экспортируем выборочные экспорты из нашей библиотеки DLL (то есть не все), необходимо решить, какие именно интерфейсы нужно экспортировать. Это сложно, поскольку необходимо указать искаженные имена компоновщика в виде записей в. DEF файл. Не экспортируйте ни один из классов C++, если для него не требуется символьная ссылка.

Если вы попытались экспортировать классы C++ с помощью. DEF-файл прежде, возможно, потребуется разработать средство для автоматического создания этого списка. Это можно сделать с помощью процесса компоновки, сопоставленного с двумя этапами. Свяжите библиотеку DLL один раз без экспорта и разрешите компоновщику создавать. Файл отображения. Тот. Файл MAP можно использовать для создания списка функций, которые должны быть экспортированы, поэтому с помощью переупорядочения их можно использовать для создания записей экспорта для. DEF файл. В списке экспорта для MFCxx.DLL и библиотек DLL расширения MFC и базы данных OLE, которые были созданы с помощью такого процесса (хотя он не является полностью автоматическим и требует некоторой настройки каждый раз в течение некоторого интервала).

### <a name="cwinapp-vs-cdynlinklibrary"></a>CWinApp и CDynLinkLibrary

Библиотека DLL расширения MFC не имеет `CWinApp` собственного производного объекта; вместо этого она должна работать с `CWinApp` объектом, производным от клиентского приложения. Это означает, что клиентское приложение владеет основным конвейером сообщений, циклом бездействия и т. д.

Если библиотека DLL расширения MFC должна поддерживать дополнительные данные для каждого приложения, можно создать новый класс, производный от, `CDynLinkLibrary` и его создание в подсистеме инитксксксдлл, описанной выше. При запуске библиотека DLL может проверить список объектов текущего приложения, `CDynLinkLibrary` чтобы найти его для конкретной библиотеки DLL расширения MFC.

### <a name="using-resources-in-your-dll-implementation"></a>Использование ресурсов в реализации библиотеки DLL

Как упоминалось выше, при загрузке ресурсов по умолчанию будет рассмотрен список `CDynLinkLibrary` объектов для первого exe-или DLL-файла с запрошенным ресурсом. Все API-интерфейсы MFC, а также весь внутренний код использует, `AfxFindResourceHandle` чтобы проанализировать список ресурсов, чтобы найти любой ресурс независимо от того, где он может находиться.

Если вы хотите загружать ресурсы только из определенного места, используйте API-интерфейсы `AfxGetResourceHandle` и `AfxSetResourceHandle` Сохраните старый обработчик и задайте новый. Не забудьте восстановить старый обработчик ресурсов перед возвратом в клиентское приложение. В примере TESTDLL2 используется этот подход для явной загрузки меню.

Анализ списка имеет недостатки, которые немного замедляют работу и требуют управления диапазонами идентификаторов ресурсов. Преимущество заключается в том, что клиентское приложение, которое ссылается на несколько библиотек DLL расширения MFC, может использовать любой ресурс, предоставляемый библиотекой DLL, без указания обработчика экземпляра DLL. `AfxFindResourceHandle` — это API, используемый для анализа списка ресурсов для поиска заданного соответствия. Он принимает имя и тип ресурса и возвращает маркер ресурса, в котором он был впервые найден (или значение NULL).

## <a name="writing-an-application-that-uses-the-dll-version"></a><a name="_mfcnotes_writing_an_application_that_uses_the_dll_version"></a>Написание приложения, использующего версию библиотеки DLL

### <a name="application-requirements"></a>Требования к приложениям

Приложение, использующее общую версию MFC, должно соответствовать следующим простым правилам:

- Он должен иметь `CWinApp` объект и следовать стандартным правилам для конвейера сообщений.

- Он должен быть скомпилирован с набором обязательных флагов компилятора (см. ниже).

- Он должен быть связан с библиотеками импорта Мфккскс. Устанавливая необходимые флаги компилятора, заголовки MFC определяют во время компоновки, с какой библиотекой приложение должно связываться.

- Чтобы запустить исполняемый файл, MFCxx.DLL должен находиться в пути или в системном каталоге Windows.

### <a name="building-with-the-development-environment"></a>Сборка с помощью среды разработки

При использовании внутреннего файла makefile с большинством стандартных значений по умолчанию можно легко изменить проект, чтобы построить версию библиотеки DLL.

На следующем этапе предполагается, что у вас есть правильно работающее приложение MFC, связанное с НАФКСКВД. LIB (для отладки) и НАФКСКВ. LIB (для розничной торговли) и вы хотите преобразовать ее для использования общей версии библиотеки MFC. Вы используете среду Visual C++ и имеете внутренний файл проекта.

1. В меню **проекты** выберите пункт **свойства**. На странице **Общие** в разделе **проект по умолчанию**задайте Microsoft Foundation classes, чтобы **использовать MFC в общей библиотеке DLL** (мфккскс (d). dll).

### <a name="building-with-nmake"></a>Сборка с помощью NMAKE

Если вы используете внешний компонент makefile Visual C++ или используете NMAKE напрямую, вам потребуется изменить файл makefile для поддержки параметров компилятора и компоновщика.

Обязательные флаги компилятора:

- **/D_AFXDLL/MD** 
   **/D_AFXDLL**

Этот символ должен определяться стандартными заголовками MFC:

- **/MD** Приложение должно использовать версию библиотеки DLL среды выполнения C

Все остальные флаги компилятора следуют параметрам MFC по умолчанию (например, _DEBUG для отладки).

Измените список компоновщика библиотек. Измените НАФКСКВД. LIB в Мфкксксд. LIB и изменить НАФКСКВ. LIB в Мфккскс. LIB. Замените LIBC. LIB с MSVCRT. LIB. Как и в случае с любой другой библиотекой MFC, важно, чтобы Мфкксксд. LIB размещался **перед** любыми библиотеками среды выполнения C.

При необходимости добавьте **/D_AFXDLL** к параметрам компилятора розничных и отладочных ресурсов (тот, который фактически компилирует ресурсы с помощью **/r**). Это делает последний исполняемый файл меньшим путем совместного использования ресурсов, имеющихся в библиотеках DLL MFC.

После внесения этих изменений требуется полное перестроение.

### <a name="building-the-samples"></a>Построение образцов

Большинство примеров программ MFC можно создавать из Visual C++ или из общего файла MAKEFILE, совместимого с NMAKE, из командной строки.

Чтобы преобразовать любой из этих примеров для использования MFCxx.DLL, можно загрузить. Файл MAK в Visual C++ и задайте параметры проекта, как описано выше. При использовании сборки NMAKE можно указать "AFXDLL = 1" в командной строке NMAKE и выполнить построение образца с помощью общих библиотек MFC.

Пример "Дополнительные понятия MFC" для примера [DLLHUSK](../overview/visual-cpp-samples.md) создан с использованием библиотеки DLL MFC. В этом примере не только показано, как создать приложение, связанное с MFCxx.DLL, но также демонстрируются другие возможности параметра упаковки MFC DLL, такие как библиотеки расширения MFC, описанные далее в этой технической статье.

### <a name="packaging-notes"></a>Заметки о упаковке

Розничная версия библиотек DLL (Мфккскс [U]. DLL) свободно распространяемый пакет. Отладочная версия библиотек DLL не является свободно распространяемой и должна использоваться только во время разработки приложения.

Отладочные библиотеки DLL предоставляются с отладочной информацией. С помощью отладчика Visual C++ можно отслеживать выполнение приложения, а также библиотеку DLL. Библиотеки DLL выпуска (Мфккскс [U]). DLL) не содержат отладочную информацию.

Если вы настраиваете или перестраиваете библиотеки DLL, то следует вызывать их не так, как «Мфккскс» файла МФКДЛЛ библиотеки MFC SRC. MAK описывает параметры сборки и содержит логику для переименования библиотеки DLL. Переименование файлов является обязательным, так как эти библиотеки DLL потенциально являются общими для многих приложений MFC. Замена пользовательской версии библиотек DLL MFC, установленных в системе, может нарушить работу другого приложения MFC, использующего общие библиотеки DLL MFC.

Перестроение библиотек DLL MFC не рекомендуется.

## <a name="how-the-mfcxxdll-is-implemented"></a><a name="_mfcnotes_how_the_mfc30.dll_is_implemented"></a>Как реализуется MFCxx.DLL

В следующем разделе описано, как реализуется библиотека DLL MFC (MFCxx.DLL и MFCxxD.DLL). Понимание этой информации также не имеет значения, если все, что нужно сделать, — использовать библиотеку DLL MFC вместе с приложением. Эти сведения не являются обязательными для понимания того, как писать библиотеку DLL расширения MFC, но понимание этой реализации может помочь вам написать собственную библиотеку DLL.

### <a name="implementation-overview"></a>Обзор реализации

Библиотека DLL MFC в действительности является особым случаем библиотеки DLL расширения MFC, как описано выше. Он содержит очень большое количество экспортов для большого числа классов. В библиотеке DLL MFC есть несколько дополнительных вещей, которые делают ее еще более специализированной, чем обычная библиотека DLL расширения MFC.

### <a name="win32-does-most-of-the-work"></a>Win32 выполняет большую часть работы

В 16-разрядной версии MFC требуется ряд специальных методов, включая данные для каждого приложения в сегменте стека, Специальные сегменты, созданные некоторым кодом сборки 80x86, контексты исключений для каждого процесса и другие методы. Win32 напрямую поддерживает данные отдельного процесса в библиотеке DLL, что является наиболее часто используемым процессом. Для большей части MFCxx.DLL просто НАФКСКВ. Библиотека, упакованная в библиотеку DLL. Если взглянуть на исходный код MFC, вы увидите очень мало #ifdef _AFXDLL, так как необходимо внести несколько особых случаев. Особые случаи, в частности, относятся к работе с Win32 в Windows 3,1 (иначе известной как Win32s). Win32 не поддерживает данные DLL для каждого процесса напрямую, поэтому библиотека DLL MFC должна использовать API Win32 локального хранилища потока (TLS) для получения локальных данных процесса.

### <a name="impact-on-library-sources-additional-files"></a>Влияние на источники библиотек, дополнительные файлы

Влияние версии **_AFXDLL** на обычные источники и заголовки библиотеки классов MFC является относительно незначительным. Существует специальный файл версии (AFXV_DLL. H), а также дополнительный файл заголовка (AFXDLL_. H), включаемое в основной AFXWIN. Заголовок H. AFXDLL_. Заголовок H содержит `CDynLinkLibrary` класс и другие сведения о реализации как `_AFXDLL` приложений, так и библиотек DLL расширения MFC. АФКСДЛЛКС. Заголовок H предоставляется для создания библиотек DLL расширения MFC (Дополнительные сведения см. выше).

Обычные источники для библиотеки MFC в MFC SRC имеют некоторый дополнительный условный код в `_AFXDLL` #ifdef. Дополнительный исходный файл (ДЛЛИНИТ. CPP) содержит дополнительный код инициализации DLL и другое привязывание для общей версии MFC.

Для создания общей версии MFC предоставляются дополнительные файлы. (Дополнительные сведения о построении библиотеки DLL см. ниже.)

- Эти. DEF-файлы используются для экспорта точек входа библиотеки DLL MFC для версий библиотеки DLL Debug (Мфкксксд. DEF) и Release (Мфккскс. DEF).

- Ранне. RC-файл (МФКДЛЛ. RC) содержит все стандартные ресурсы MFC и ресурс VERSIONINFO для библиотеки DLL.

- Конкретного. Файл КЛВ (МФКДЛЛ. КЛВ) предоставляется, чтобы разрешить просмотр классов MFC с помощью ClassWizard. Примечание. Эта функция не относится к версии DLL MFC.

### <a name="memory-management"></a>Управление памятью

Приложение, использующее MFCxx.DLL, использует общий распределитель памяти, предоставляемый MSVCRTxx.DLL, общей DLL-библиотекой времени выполнения C. Приложение, любые библиотеки DLL расширения MFC, а также сами библиотеки DLL MFC используют этот механизм распределения общей памяти. Используя общую библиотеку DLL для выделения памяти, библиотеки DLL MFC могут выделить память, которая позже освобождается приложением, или наоборот. Так как приложение и библиотека DLL должны использовать один и тот же распределитель, не следует переопределять глобальный **оператор C++ New** или **operator delete**. Те же правила применяются к остальным частям подпрограммы выделения памяти среды выполнения C (например, **malloc**, **realloc**, **Free**и др.).

### <a name="ordinals-and-class-__declspecdllexport-and-dll-naming"></a>Порядковые номера и __declspec класса (dllexport) и именование библиотек DLL

Мы не используем `class` **`__declspec(dllexport)`** функции компилятора C++. Вместо этого список экспортов включается в источники библиотеки классов (Мфккскс. DEF и Мфкксксд. DEF). Экспортируются только выбранные наборы точек входа (функции и данные). Другие символы, такие как закрытые функции или классы реализации MFC, не экспортируются. все операции экспорта выполняются по порядковому номеру без имени строки в резидентной или нерезидентной таблице имен.

Использование `class` **`__declspec(dllexport)`** может быть приемлемым вариантом для создания небольших библиотек DLL, но в случае с большой библиотекой DLL, такой как MFC, механизм экспорта по умолчанию имеет эффективность и ограничения емкости.

Это означает, что мы можем упаковать большой объем функциональных возможностей в MFCxx.DLL выпуска, который составляет всего около 800 КБ без ущерба для выполнения или скорости загрузки. MFCxx.DLL было бы более 100 000, если эта методика не использовалась. Это также дает возможность добавлять дополнительные точки входа в конце. DEF, чтобы обеспечить простое управление версиями без ущерба для скорости и эффективности экспорта по порядковому номеру. Основной номер версии в библиотеке классов MFC изменит имя библиотеки. То есть MFC30.DLL является распространяемой DLL-библиотекой, содержащей версию 3,0 библиотеки классов MFC. При обновлении этой библиотеки DLL, скажем, в гипотетическом MFC 3,1, вместо этого библиотека DLL будет называться MFC31.DLL. Опять же, если изменить исходный код MFC для создания пользовательской версии библиотеки DLL MFC, используйте другое имя (и, желательно, если имя не "MFC" в имени).

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
