---
title: TN026. Процедуры DDX и DDV
ms.date: 06/28/2018
f1_keywords:
- DDX
- DDV
helpviewer_keywords:
- DDX (dialog data exchange), procedures
- TN026
- DDV (dialog data validation), procedures
ms.assetid: c2eba87a-4b47-4083-b28b-e2fa77dfb4c4
ms.openlocfilehash: 711d433b51ca09836f372d09a11f86c28b82cce6
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370337"
---
# <a name="tn026-ddx-and-ddv-routines"></a>TN026. Процедуры DDX и DDV

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

В этой заметке описывается архитектура обмена диалоговыми данными (DDX) и проверки данных диалогов (DDV). В нем также описывается, как вы пишете DDX_ или DDV_ процедуру и как вы можете расширить ClassWizard использовать ваши процедуры.

## <a name="overview-of-dialog-data-exchange"></a>Обзор обмена данными Dialog

Все функции диалоговые данные выполняются с помощью кода СЗ. Нет специальных ресурсов или волшебных макросов. Сердцем механизма является виртуальная функция, которая переопределяется в каждом классе диалогов, который делает обмен и проверку диалоговых данных. Он всегда находится в этой форме:

```cpp
void CMyDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);   // call base class

    //{{AFX_DATA_MAP(CMyDialog)
        <data_exchange_function_call>
        <data_validation_function_call>
    //}}AFX_DATA_MAP
}
```

Комментарии AFX специального формата позволяют ClassWizard находить и отсылать код в рамках этой функции. Код, несовместимый с ClassWizard, должен размещаться за пределами комментариев специального формата.

В приведенном \<выше примере data_exchange_function_call> в форме:

```cpp
DDX_Custom(pDX, nIDC, field);
```

и \<data_validation_function_call> является необязательным и в форме:

```cpp
DDV_Custom(pDX, field, ...);
```

В каждую `DoDataExchange` функцию может быть включено более одной пары DDX_/DDV_.

Список всех процедур обмена диалоговых данных и процедур проверки данных диалоговых данных, предоставляемых MFC, читайте в afxdd_.h.

Данные Dialog — это именно `CMyDialog` то, что: данные о членах в классе. Он не хранится в структуре или что-нибудь подобное.

## <a name="notes"></a>Примечания

Хотя мы называем это "диалоговых данных", все функции доступны в любом классе, полученных из `CWnd` и не ограничиваются только диалоги.

Первоначальные значения данных устанавливаются в стандартном конструкторе СЗ, как правило, в блоке с `//{{AFX_DATA_INIT` комментариями и `//}}AFX_DATA_INIT` комментариями.

`CWnd::UpdateData`— это операция, которая делает инициализацию и обработку ошибок вокруг `DoDataExchange`вызова.

Вы можете `CWnd::UpdateData` позвонить в любое время для выполнения обмена данными и проверки. По `UpdateData`умолчанию (TRUE) вызывается `UpdateData`в обработчике по `CDialog::OnInitDialog`умолчанию `CDialog::OnOK` и (FALSE) вызывается по умолчанию.

DDV_ рутина должна немедленно следовать DDX_ рутины для этой *области*.

## <a name="how-does-it-work"></a>Как это работает

Вам не нужно понимать следующее, чтобы использовать данные диалогов. Тем не менее, понимание того, как это работает за кулисами поможет вам написать свой собственный обмен или процедуру проверки.

Функция `DoDataExchange` члена очень похожа `Serialize` на функцию члена - она отвечает за получение или настройку данных в/из внешней формы (в данном случае управления в диалоге) от/к данным членов в классе. Параметр *pDX* является контекстом для ведения обмена `CArchive` данными и аналогичен параметру. `CObject::Serialize` *PDX* `CDataExchange` (объект) имеет флаг направления `CArchive` так же, как имеет флаг направления:

- Если, `!m_bSaveAndValidate`затем загрузить состояние данных в элементы управления.

- Если, `m_bSaveAndValidate`затем установите состояние данных из элементов управления.

Проверка происходит только `m_bSaveAndValidate` при установке. Значение `m_bSaveAndValidate` определяется параметром BOOL `CWnd::UpdateData`для .

Есть еще три `CDataExchange` интересных участника:

- `m_pDlgWnd`: Окно (обычно диалог), содержащее элементы управления. Это делается для того, чтобы абоненты DDX_ и DDV_ глобальных функций от необходимости передавать "это" для каждого DDX / DDV рутины.

- `PrepareCtrl`, `PrepareEditCtrl`и : Готовит диалог-контроль для обмена данными. Хранит ручку управления для настройки фокуса при сбое проверки. `PrepareCtrl`используется для элементов управления `PrepareEditCtrl` без отсылки и используется для элементов управления.

- `Fail`: Вызывается после создания окна сообщения, предупреждающего пользователя об ошибке ввода. Эта процедура восстановит фокус к последнему элементу `PrepareCtrl` `PrepareEditCtrl`управления (последний вызов или) и бросит исключение. Эта функция члена может вызываться как из DDX_, так и DDV_ процедур.

## <a name="user-extensions"></a>Расширения пользователей

Существует несколько способов расширения механизма DDX/DDV по умолчанию. Вы можете:

- Добавление новых типов данных.

    ```cpp
    CTime
    ```

- Добавьте новые процедуры обмена (DDX_).

    ```cpp
    void PASCAL DDX_Time(CDataExchange* pDX, int nIDC, CTime& tm);
    ```

- Добавить новые процедуры проверки (DDV_).

    ```cpp
    void PASCAL DDV_TimeFuture(CDataExchange* pDX, CTime tm, BOOL bFuture);
    // make sure time is in the future or past
    ```

- Пройдите произвольные выражения процедурам проверки.

    ```cpp
    DDV_MinMax(pDX, age, 0, m_maxAge);
    ```

    > [!NOTE]
    > Такие произвольные выражения не могут быть отредактированы ClassWizard и поэтому должны быть перемещены за пределы комментариев специального формата (//AFX_DATA_MAP (CMyClass)).

Поимеет `DoDialogExchange` функцию участника условные или любые другие допустимые заявления к C е с перемешанные вызовы функции обмена и проверки.

```cpp
//{{AFX_DATA_MAP(CMyClass)
DDX_Check(pDX, IDC_SEX, m_bFemale);
DDX_Text(pDX, IDC_EDIT1, m_age);
//}}AFX_DATA_MAP
if (m_bFemale)
    DDV_MinMax(pDX, age, 0, m_maxFemaleAge);
else
    DDV_MinMax(pDX, age, 0, m_maxMaleAge);
```

> [!NOTE]
> Как показано выше, такой код не может быть отредактирован ClassWizard и должен использоваться только за пределами комментариев специального формата.

## <a name="classwizard-support"></a>Поддержка ClassWizard

ClassWizard поддерживает подмножество настраиваемых DDX/DDV, позволяя вам интегрировать свои собственные DDX_ и DDV_ процедуры в пользовательский интерфейс ClassWizard. Это выгодно только в том случае, если вы планируете повторно использовать определенные процедуры DDX и DDV в проекте или во многих проектах.

Для этого в DDX делаются специальные записи. CLW (предыдущие версии Visual C' хранят эту информацию в APSTUDIO. INI) или в вашем проекте . Файл CLW. Специальные записи могут быть введены либо в разделе «Общая информация» вашего проекта . Файл CLW или в разделе «ExtraDDX» DDX. Файл CLW в каталоге «Файлы программы» (Microsoft Visual Studio) визуальный каталог C. Возможно, потребуется создать DDX. Файл CLW, если он еще не существует. Если вы планируете использовать пользовательские DDX_/DDV_ процедур только в определенном проекте, добавьте записи в раздел «Общая информация» вашего проекта. Файл CLW вместо этого. Если вы планируете использовать процедуры во многих проектах, добавьте записи в раздел DDX «ExtraDDX». Clw.

Общий формат этих специальных записей:

> ExtraDDXCount*n*

где *n* число ExtraDDX? линии, чтобы следовать, формы

> ExtraDDX?*keys* *vb-ключи*; *подсказка*; *тип*; *initValue*; *DDX_Proc* к.; *DDV_Proc;* *prompt1*; *arg1 (aarg1;* *prompt2*; *fmt2*

Где? является числом 1 - *n* с указанием типа DDX в списке, который определяется.

Каждое поле разграничено символом ';'. Поля и их назначение описаны ниже.

- *Ключи*

  Допускается список отдельных символов, указывающих на то, для чего диалог управляет этим переменным типом.

  |Знак|Разрешенный контроль|
  |-|-|
  E | изменение;
  C | двухгосударственный флажок
  с | трехгосударственный флажок
  R | первая кнопка радио в группе
  L | несортированный список поле
  l | отсортированный список поле
  M | комбо-коробка (с элементом для отодвина)
  Нет | несортированный список выпадающих
  n | отсортированный список выпадения
  1 | если вставка DDX должна быть добавлена в главу списка (по умолчанию добавляется к хвосту) Это обычно используется для процедур DDX, которые передают свойство 'Control'.

- *vb-ключи*

  Это поле используется только в 16-битном продукте для элементов управления VBX (элементы управления VBX не поддерживаются в 32-битном продукте)

- *Строке*

  Строка для размещения в комбо-коробке свойств (без кавычек)

- *тип*

  Единый идентификатор для типа для испускаемого в файле заголовка. В нашем примере выше с DDX_Time, это будет установлено на CTime.

- *vb-ключи*

  Не используется в этой версии и всегда должен быть пустым

- *initValue*

  Начальное значение - 0 или пустое. Если она пуста, то ни одна строка инициализации не будет написана в разделе //'AFX_DATA_INIT в разделе файла реализации. Для объектов СЗ `CString`(например, `CTime`и так далее) следует использовать пустую запись, в которых есть конструкторы, гарантирующие правильную инициализацию.

- *DDX_Proc*

  Единый идентификатор для процедуры DDX_. Имя функции C's должно начинаться с "DDX_", но \<не включать "DDX_" в идентификатор DDX_Proc>. В приведенном выше \<примере идентификатор DDX_Proc> будет Time. Когда ClassWizard записывает вызов функции в файл реализации в разделе «AFX_DATA_MAP», он прикрепляет это имя к DDX_, таким образом, прибывая в DDX_Time.

- *comment*

  Комментарий, чтобы показать в диалоге для переменной с этим DDX. Поместите любой текст, который вы хотели бы здесь, и обычно предоставляете что-то, что описывает операцию, выполненную парой DDX/DDV.

- *DDV_Proc*

  Часть записи DDV не является обязательной. Не все процедуры DDX имеют соответствующие процедуры DDV. Часто более удобно включать фазу проверки в качестве неотъемлемой части передачи. Это часто бывает, когда ваш dDV рутина не требует каких-либо параметров, потому что ClassWizard не поддерживает DDV процедур без каких-либо параметров.

- *Arg*

  Единый идентификатор для процедуры DDV_. Название функции СЗ должно начинаться с "DDV_", но \<не включать "DDX_" в идентификатор DDX_Proc>.

  *За arg* следуют 1 или 2 DDV args:

  - *promptN*

      Строка для размещения над элементом отодвинутеля (с & для ускорителя).

  - *fmtN*

      Формат персонажа для типа арг, один из:

      |Знак|Тип|
      |-|-|
      |d | INT|
      |u | unsigned int|
      |D | длинный Int (то есть, долго)|
      |U | долго неподписанных (т.е. DWORD)|
      |f | FLOAT|
      |F | double|
      |s | строка|

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические заметки по категориям](../mfc/technical-notes-by-category.md)
