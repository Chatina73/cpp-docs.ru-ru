---
description: 'Дополнительные сведения: TN026: DDX и DDV.'
title: TN026. Процедуры DDX и DDV
ms.date: 06/28/2018
f1_keywords:
- DDX
- DDV
helpviewer_keywords:
- DDX (dialog data exchange), procedures
- TN026
- DDV (dialog data validation), procedures
ms.assetid: c2eba87a-4b47-4083-b28b-e2fa77dfb4c4
ms.openlocfilehash: 1e5c8d3679b7e91ad7f356c1e6f6badc61cdd46f
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97215707"
---
# <a name="tn026-ddx-and-ddv-routines"></a>TN026. Процедуры DDX и DDV

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Это примечание описывает архитектуру обмена данными диалога (DDX) и проверки данных диалогового окна (DDV). Здесь также описано, как написать DDX_ или DDV_ процедуру и как можно расширить ClassWizard для использования ваших подпрограмм.

## <a name="overview-of-dialog-data-exchange"></a>Обзор обмена данными в диалоговом окне

Все функции данных диалогового окна выполняются с помощью кода C++. Специальных ресурсов или волшебных макросов нет. Основой механизма является виртуальная функция, которая переопределена в каждом классе диалога, который осуществляет обмен и проверку данных диалоговых окон. Он всегда находится в следующем виде:

```cpp
void CMyDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);   // call base class

    //{{AFX_DATA_MAP(CMyDialog)
        <data_exchange_function_call>
        <data_validation_function_call>
    //}}AFX_DATA_MAP
}
```

Специальный формат комментариев AFX позволяет ClassWizard размещать и редактировать код в этой функции. Код, несовместимый с ClassWizard, должен размещаться за пределами специального формата комментариев.

В приведенном выше примере \<data_exchange_function_call> имеет вид:

```cpp
DDX_Custom(pDX, nIDC, field);
```

и \<data_validation_function_call> является необязательным и имеет вид:

```cpp
DDV_Custom(pDX, field, ...);
```

В каждую функцию может быть включена более одной пары DDX_/DDV_ `DoDataExchange` .

Список всех подпрограмм обмена данными диалоговых окон и подпрограммы проверки данных диалоговых окон, предоставляемых MFC, см. в разделе "afxdd_. h".

Данные диалогового окна — это просто данные элемента в `CMyDialog` классе. Он не хранится в структуре или что-либо аналогичное.

## <a name="notes"></a>Примечания

Несмотря на то, что мы вызываем это «диалоговые данные», все функции доступны в любом классе, производном от, `CWnd` и не ограничиваются только диалогами.

Начальные значения данных задаются в стандартном конструкторе C++, обычно в блоке с `//{{AFX_DATA_INIT` `//}}AFX_DATA_INIT` комментариями и.

`CWnd::UpdateData` операция, которая выполняет инициализацию и обработку ошибок вокруг вызова `DoDataExchange` .

`CWnd::UpdateData`Для выполнения обмена данными и проверки можно в любое время вызвать. По умолчанию `UpdateData` (true) вызывается в обработчике по умолчанию `CDialog::OnOK` и `UpdateData` по умолчанию вызывается (false) `CDialog::OnInitDialog` .

Подпрограммы DDV_ должны сразу следовать подDDX_ для этого *поля*.

## <a name="how-does-it-work"></a>Как это работает

Для использования данных диалогового окна не нужно понимать следующее. Тем не менее, понимание того, как это работает в фоновом режиме, поможет вам написать собственную процедуру Exchange или проверку.

`DoDataExchange`Функция-член во многом аналогична `Serialize` функции члена — она отвечает за получение или установку данных во внешнюю форму (в данном случае это элементы управления в диалоговом окне) от или к данным элемента в классе. Параметр *pDX* является контекстом для обмена данными и аналогичен `CArchive` параметру `CObject::Serialize` . *PDX* ( `CDataExchange` объект) имеет флаг направления, похожий на `CArchive` флаг направления:

- Если значение равно `!m_bSaveAndValidate` , то загрузите состояние данных в элементы управления.

- Если `m_bSaveAndValidate` задано значение, то задайте состояние данных из элементов управления.

Проверка выполняется только в том случае `m_bSaveAndValidate` , если задан параметр. Значение определяется `m_bSaveAndValidate` параметром bool в `CWnd::UpdateData` .

Есть три других интересных `CDataExchange` члена:

- `m_pDlgWnd`: Окно (обычно диалоговое окно), содержащее элементы управления. Это необходимо, чтобы вызывающие объекты DDX_ и DDV_ глобальные функции не передавали this в каждую подпрограммы DDX/DDV.

- `PrepareCtrl`и `PrepareEditCtrl` : подготавливает элемент управления диалогом для обмена данными. Сохраняет маркер элемента управления для установки фокуса в случае сбоя проверки. `PrepareCtrl` используется для элементов управления, не являющихся элементами редактирования, и `PrepareEditCtrl` используется для элементов управления для редактирования.

- `Fail`: Вызывается после вывода окна сообщения с уведомлением пользователя об ошибке ввода. Эта подпрограммы восстановит фокус на последнем элементе управления (последний вызов метода `PrepareCtrl` или `PrepareEditCtrl` ) и создаст исключение. Эту функцию члена можно вызывать из подпрограмм DDX_ и DDV_.

## <a name="user-extensions"></a>Пользовательские расширения

Существует несколько способов расширить механизм DDX/DDV по умолчанию. Можно сделать следующее:

- Добавление новых типов данных.

    ```cpp
    CTime
    ```

- Добавьте новые процедуры Exchange (DDX_).

    ```cpp
    void PASCAL DDX_Time(CDataExchange* pDX, int nIDC, CTime& tm);
    ```

- Добавьте новые процедуры проверки (DDV_).

    ```cpp
    void PASCAL DDV_TimeFuture(CDataExchange* pDX, CTime tm, BOOL bFuture);
    // make sure time is in the future or past
    ```

- Передайте произвольные выражения в процедуры проверки.

    ```cpp
    DDV_MinMax(pDX, age, 0, m_maxAge);
    ```

    > [!NOTE]
    > Такие произвольные выражения нельзя изменять с помощью ClassWizard, поэтому их следует перемещать за пределы специального формата комментариев (//{{AFX_DATA_MAP (Кмикласс)).

`DoDialogExchange`Функция члена включает условия или любые другие допустимые инструкции C++ с использованием смешанных вызовов функций Exchange и проверки.

```cpp
//{{AFX_DATA_MAP(CMyClass)
DDX_Check(pDX, IDC_SEX, m_bFemale);
DDX_Text(pDX, IDC_EDIT1, m_age);
//}}AFX_DATA_MAP
if (m_bFemale)
    DDV_MinMax(pDX, age, 0, m_maxFemaleAge);
else
    DDV_MinMax(pDX, age, 0, m_maxMaleAge);
```

> [!NOTE]
> Как показано выше, такой код нельзя изменять с помощью ClassWizard и должен использоваться только за пределами специального формата комментариев.

## <a name="classwizard-support"></a>Поддержка ClassWizard

ClassWizard поддерживает подмножество настроек DDX/DDV, позволяя интегрировать собственные подпрограммы DDX_ и DDV_ в пользовательский интерфейс ClassWizard. Это выгодно только в том случае, если планируется многократное использование определенных подподпрограмм DDX и DDV в проекте или во многих проектах.

Для этого специальные записи вносятся в DDX. КЛВ (предыдущие версии Visual C++ хранили эти сведения в APSTUDIO.INI) или в проекте. Файл КЛВ. Специальные записи можно указать либо в разделе [General info] проекта. Файл КЛВ или в разделе [Екстраддкс] файла DDX. КЛВ в каталоге \Program Files\Microsoft Visual Студио\висуал C++ \bin. Возможно, потребуется создать файл DDX. КЛВ, если он еще не создан. Если вы планируете использовать пользовательские подпрограммы DDX_/DDV_ только в определенном проекте, добавьте записи в раздел [General info] проекта. Вместо этого используйте файл КЛВ. Если планируется использовать подпрограммы для многих проектов, добавьте записи в раздел [Екстраддкс] файла DDX. КЛВ.

Общий формат этих специальных записей:

> Екстраддкскаунт =*n*

где *n* — число екстраддкс? строки для выполнения формы

> Екстраддкс? =*ключи*; *VB — ключи*; *запрос*; *тип*; *инитвалуе*; *DDX_Proc* [; *DDV_Proc*; *prompt1*; *arg1* [; *prompt2*; *fmt2*]]

которому? число 1- *n* , указывающее, какой тип DDX в определяемом списке.

Каждое поле отделяется символом ";". Поля и их назначение описаны ниже.

- *ключ*

  Список одиночных символов, указывающий, для какого диалогового окна этот тип переменной разрешен.

  |Символ|Разрешенный элемент управления|
  |-|-|
  E | изменение;
  C | флажок с двумя состояниями
  с | флажок с тремя состояниями
  R | первый переключатель в группе
  L | Несортированный список
  l | отсортированный список
  M | поле со списком (с изменяемым элементом)
  N | раскрывающийся список без сортировки
  n | упорядоченный раскрывающийся список
  1 | Если инструкция DDX INSERT должна быть добавлена в заголовок списка (по умолчанию добавляется к хвосту), это обычно используется для подпрограмм DDX, передаваемых свойству Control.

- *VB — ключи*

  Это поле используется только в 16-разрядном продукте для элементов управления VBX (элементы управления VBX не поддерживаются в 32-разрядном продукте)

- *prompt*

  Строка для размещения в поле со списком свойств (без кавычек)

- *type*

  Один идентификатор для типа, выдаваемый в файле заголовка. В нашем примере выше с DDX_Time для этого параметра будет задано значение CTime.

- *VB — ключи*

  Не используется в этой версии и всегда должен быть пустым

- *инитвалуе*

  Начальное значение — 0 или пустое. Если он пуст, то строка инициализации не будет записана в раздел//{{AFX_DATA_INIT файла реализации. Пустая запись должна использоваться для объектов C++ (таких как `CString` , `CTime` и т. д.), которые имеют конструкторы, гарантирующие правильную инициализацию.

- *DDX_Proc*

  Один идентификатор для процедуры DDX_. Имя функции C++ должно начинаться с "DDX_", но не включать "DDX_" в \<DDX_Proc> идентификатор. В приведенном выше примере \<DDX_Proc> идентификатор будет иметь значение Time. Когда ClassWizard записывает вызов функции в файл реализации в разделе {{AFX_DATA_MAP, он добавляет это имя в DDX_, тем самым поступающим на DDX_Time.

- *comment*

  Комментарий, отображаемый в диалоговом окне для переменной с этим DDX. Поместите любой текст, который вам нравится, и, как правило, укажите нечто, описывающее операцию, выполняемую парой DDX/DDV.

- *DDV_Proc*

  Часть DDV записи является необязательной. Не все подпрограммы DDX имеют соответствующие подпрограммы DDV. Часто бывает удобнее включить этап проверки в качестве неотъемлемой части перемещения. Это часто случается, когда подпрограммы DDV не нуждаются в параметрах, так как ClassWizard не поддерживает подпрограммы DDV без каких-либо параметров.

- *АРГ*

  Один идентификатор для процедуры DDV_. Имя функции C++ должно начинаться с "DDV_", но не включать "DDX_" в \<DDX_Proc> идентификатор.

  за *аргументом arg* следуют 1 или 2 DDV args:

  - *промптн*

      Строка, помещаемая над элементом редактирования (с & для ускорителя).

  - *фмтн*

      Символ формата для типа ARG, один из следующих:

      |Символ|Тип|
      |-|-|
      |d | INT|
      |u | unsigned int|
      |D | long int (длинное целое)|
      |U | Long без знака (т. е. DWORD)|
      |f | FLOAT|
      |F | double|
      |s | строка|

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
