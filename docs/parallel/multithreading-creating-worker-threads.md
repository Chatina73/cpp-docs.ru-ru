---
title: Многопоточность. Создание рабочих потоков в MFC
ms.date: 11/04/2016
helpviewer_keywords:
- multithreading [C++], worker threads
- background tasks [C++]
- threading [C++], worker threads
- worker threads [C++]
- threading [C++], creating threads
- threading [MFC], worker threads
- threading [C++], user input not required
ms.assetid: 670adbfe-041c-4450-a3ed-be14aab15234
ms.openlocfilehash: c8df3dd9d17819b23362a3b31d8e198883aa9143
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69512062"
---
# <a name="multithreading-creating-worker-threads-in-mfc"></a>Многопоточность. Создание рабочих потоков в MFC

Рабочий поток обычно используется для обработки фоновых задач, которые пользователю не нужно ждать, чтобы продолжить использовать приложение. Хорошим примером рабочих потоков являются такие задачи, как пересчет и фоновая печать. В этом разделе подробно описаны шаги, необходимые для создания рабочего потока. Ниже приведен список разделов.

- [Запуск потока](#_core_starting_the_thread)

- [Реализация функции управления](#_core_implementing_the_controlling_function)

- [Пример](#_core_controlling_function_example)

Создание рабочего потока является относительно простой задачей. Для выполнения потока требуется только два действия: реализация функции управления и запуск потока. Нет необходимости создавать класс, производный от [CWinThread](../mfc/reference/cwinthread-class.md). Класс можно создать `CWinThread`, если требуется специальная версия, но не требуется для большинства простых рабочих потоков. Вы можете использовать `CWinThread` без изменений.

##  <a name="_core_starting_the_thread"></a>Запуск потока

Существует две перегруженные версии `AfxBeginThread`: одна, которая может создавать только рабочие потоки и один, который может создавать потоки пользовательского интерфейса и рабочие потоки. Чтобы начать выполнение рабочего потока с помощью первой перегрузки, вызовите [афксбегинсреад](../mfc/reference/application-information-and-management.md#afxbeginthread), предоставив следующие сведения:

- Адрес функции управления.

- Параметр, передаваемый функции управления.

- Используемых Желаемый приоритет потока. По умолчанию используется обычная важность. Дополнительные сведения о доступных уровнях приоритета см. в разделе [сетсреадприорити](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority) в Windows SDK.

- Используемых Требуемый размер стека для потока. Значение по умолчанию — это тот же стек размеров, что и при создании потока.

- Используемых CREATE_SUSPENDED, если вы хотите, чтобы поток создавался в приостановленном состоянии. Значение по умолчанию — 0 или запустить поток обычным образом.

- Используемых Требуемые атрибуты безопасности. По умолчанию используется тот же доступ, что и для родительского потока. Дополнительные сведения о формате этих сведений о безопасности см. в разделе [SECURITY_ATTRIBUTES](/previous-versions/windows/desktop/legacy/aa379560\(v=vs.85\)) в Windows SDK.

`AfxBeginThread`создает и инициализирует `CWinThread` объект, запускает его и возвращает его адрес, чтобы можно было обращаться к нему позже. Проверки выполняются на протяжении всей процедуры, чтобы убедиться, что все объекты освобождены должным образом, в случае сбоя любой части создания.

##  <a name="_core_implementing_the_controlling_function"></a>Реализация функции управления

Управляющая функция определяет поток. При входе в эту функцию поток запускается, и когда он завершает работу, поток завершается. Эта функция должна иметь следующий прототип:

```
UINT MyControllingFunction( LPVOID pParam );
```

Параметр является одиночным значением. Значение, которое функция получает в этом параметре, — это значение, передаваемое конструктору при создании объекта потока. Функция управления может интерпретировать это значение любым способом, который он выбрал. Он может рассматриваться как скалярное значение или указатель на структуру, содержащую несколько параметров, или же она может быть пропущена. Если параметр ссылается на структуру, то эта структура может использоваться не только для передачи данных от вызывающего потока в поток, но и для передачи данных из потока вызывающему объекту. Если вы используете такую структуру для передачи данных обратно вызывающему объекту, потоку необходимо уведомить вызывающего объекта о готовности результатов. Сведения о связи между рабочим потоком и вызывающим объектом см. в [разделе Многопоточность. Советы по](multithreading-programming-tips.md)программированию.

Когда функция завершает работу, она должна возвращать значение UINT, указывающее причину завершения. Как правило, этот код выхода имеет значение 0, что означает успешное выполнение с другими значениями, указывающими на различные типы ошибок. Это исключительно зависит от реализации. Некоторые потоки могут поддерживать счетчики использования объектов и возвращать текущее количество применений этого объекта. Сведения о том, как приложения могут извлекать это [значение, см. в разделе Многопоточность. Завершение потоков](multithreading-terminating-threads.md).

Существуют некоторые ограничения на то, что можно делать в многопоточной программе, написанной с помощью библиотеки MFC. Описание этих ограничений и другие советы по использованию потоков см. в разделе [многопоточность. Советы по](multithreading-programming-tips.md)программированию.

##  <a name="_core_controlling_function_example"></a>Пример функции управления

В следующем примере показано, как определить функцию управления и использовать ее из другой части программы.

```
UINT MyThreadProc( LPVOID pParam )
{
    CMyObject* pObject = (CMyObject*)pParam;

    if (pObject == NULL ||
        !pObject->IsKindOf(RUNTIME_CLASS(CMyObject)))
    return 1;   // if pObject is not valid

    // do something with 'pObject'

    return 0;   // thread completed successfully
}

// inside a different function in the program
.
.
.
pNewObject = new CMyObject;
AfxBeginThread(MyThreadProc, pNewObject);
.
.
.
```

## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Многопоточность. Создание потоков, обрабатывающих события от пользовательского интерфейса](multithreading-creating-user-interface-threads.md)

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
