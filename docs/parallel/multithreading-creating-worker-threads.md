---
title: 'Многопоточность: Создание рабочих потоков в MFC'
ms.date: 11/04/2016
helpviewer_keywords:
- multithreading [C++], worker threads
- background tasks [C++]
- threading [C++], worker threads
- worker threads [C++]
- threading [C++], creating threads
- threading [MFC], worker threads
- threading [C++], user input not required
ms.assetid: 670adbfe-041c-4450-a3ed-be14aab15234
ms.openlocfilehash: 54bea7b42018637bf868dfdd923b94dd75aa2307
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50559488"
---
# <a name="multithreading-creating-worker-threads-in-mfc"></a>Многопоточность: Создание рабочих потоков в MFC

Рабочий поток широко используется для обработки фоновых задач, которые пользователь не следует ожидать, чтобы продолжить работу с приложением. Задачи, такие как пересчет и фоновая печать являются хорошими примерами рабочих потоков. В этой статье описываются действия, необходимые для создания рабочего потока. Ниже приведен список разделов.

- [Запуск потока](#_core_starting_the_thread)

- [Реализация функции управления](#_core_implementing_the_controlling_function)

- [Пример](#_core_controlling_function_example)

Создание рабочего потока является относительно простой задачей. Для запуска потока необходимы только два действия: реализация функции управления и запустить поток. Нет необходимости создавать производный класс из [CWinThread](../mfc/reference/cwinthread-class.md). Можно наследовать класс, если вам требуется специальная версия `CWinThread`, но он не является обязательным для большинства простых рабочих потоков. Можно использовать `CWinThread` без изменений.

##  <a name="_core_starting_the_thread"></a> Запуск потока

Существует две перегруженные версии `AfxBeginThread`: один, можно создать только рабочих потоков и, который может создаваться потоки пользовательского интерфейса и рабочие потоки. Чтобы начать выполнение рабочего потока с использованием первой перегрузки, вызовите [AfxBeginThread](../mfc/reference/application-information-and-management.md#afxbeginthread), указав следующие сведения:

- Адрес функции управления.

- Параметр, передаваемый в функцию управления.

- (Необязательно) Желаемый приоритет потока. Значение по умолчанию используется обычный приоритет. Дополнительные сведения о доступных уровнях приоритета см. в разделе [SetThreadPriority](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreadpriority) в пакете Windows SDK.

- (Необязательно) Желаемый размер стека для потока. По умолчанию используется тот же размер стека, что и для создания потока.

- (Необязательно) CREATE_SUSPENDED, если необходимо создать в приостановленном состоянии потока. По умолчанию равно 0 или запустите потока в обычном режиме.

- (Необязательно) Желаемые атрибуты безопасности. По умолчанию используется тот же уровень доступа как родительского потока. Дополнительные сведения о формате информации о безопасности см. в разделе [SECURITY_ATTRIBUTES](https://msdn.microsoft.com/library/windows/desktop/aa379560) в пакете Windows SDK.

`AfxBeginThread` Создает и инициализирует `CWinThread` объекта, запускает его и возвращает его адрес, чтобы обращаться к нему позже. Проверки выполняются на протяжении процедуры, чтобы убедиться в том, что все объекты, освобожденные должным образом вызывать любую часть создания.

##  <a name="_core_implementing_the_controlling_function"></a> Реализация функции управления

Функция управления определяет поток. При вводе этой функции поток запускается, и при ее действии поток завершается. Данная функция должна иметь следующий прототип:

```
UINT MyControllingFunction( LPVOID pParam );
```

Параметр является одиночное значение. Значение, которое эта функция получает в этот параметр имеет значение, которое было передано в конструктор при создании объекта потока. Функция управления может интерпретировать это значение любым образом, он выбирает. Его можно рассматривать как скалярное значение или указатель на структуру, содержащую многочисленные параметры, или его можно пропустить. Если параметр ссылается на структуру, структура может использоваться не только для передачи данных из вызывающего объекта в поток, но также и для передачи данных из потока в вызывающий объект. При использовании такой структуры для передачи данных обратно в вызывающий объект потока необходимо уведомить вызывающий объект в том случае, когда результаты готовы. Сведения о связи рабочего потока с вызывающим объектом, см. в разделе [Многопоточность: советы по программированию](multithreading-programming-tips.md).

При завершении функции она должна вернуть значение целое число без знака, указывающее на причину завершения. Как правило этот код выхода равен 0, означающее успешное выполнение другие значения, означающие различные типы ошибок. Это полностью зависит от реализации. Некоторые потоки могут поддерживать счетчики объектов и возвращать текущее количество использования этого объекта. Чтобы увидеть, как приложения можно получить это значение, см. в разделе [Многопоточность: Завершение потоков](multithreading-terminating-threads.md).

Существуют некоторые ограничения на возможности многопоточного приложения, написанные с помощью библиотеки MFC. Описание этих ограничений, а также другие советы по использованию потоков, см. в разделе [Многопоточность: советы по программированию](multithreading-programming-tips.md).

##  <a name="_core_controlling_function_example"></a> Пример функции управления

В следующем примере показано, как определения функции управления и использовать его из другой части программы.

```
UINT MyThreadProc( LPVOID pParam )
{
    CMyObject* pObject = (CMyObject*)pParam;

    if (pObject == NULL ||
        !pObject->IsKindOf(RUNTIME_CLASS(CMyObject)))
    return 1;   // if pObject is not valid

    // do something with 'pObject'

    return 0;   // thread completed successfully
}

// inside a different function in the program
.
.
.
pNewObject = new CMyObject;
AfxBeginThread(MyThreadProc, pNewObject);
.
.
.
```

## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Многопоточность. Создание потоков пользовательского интерфейса](multithreading-creating-user-interface-threads.md)

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)