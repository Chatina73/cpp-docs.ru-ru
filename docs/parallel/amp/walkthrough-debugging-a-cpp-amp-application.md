---
title: Пошаговое руководство. Отладка приложения C++ AMP
ms.date: 11/04/2016
helpviewer_keywords:
- debugging, C++ Accelerated Massive Parallelism
- C++ AMP, debugging
- C++ Accelerated Massive Parallelism, debugging
- debugging, C++ AMP
ms.assetid: 40e92ecc-f6ba-411c-960c-b3047b854fb5
ms.openlocfilehash: 4f8cdc315b561b5cbb4538e8486208d6278af9df
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50579911"
---
# <a name="walkthrough-debugging-a-c-amp-application"></a>Пошаговое руководство. Отладка приложения C++ AMP

В этом разделе показано, как выполнить отладку приложения, использующего C++ Accelerated Massive Parallelism (C++ AMP), чтобы воспользоваться преимуществами графический процессор (GPU). Она использует сокращения параллельной программы, которая суммирует большой массив целых чисел. В данном пошаговом руководстве рассмотрены следующие задачи:

- Запуск отладчика GPU.

- Проверка потоков GPU в окне потоков GPU.

- С помощью **Параллельные стеки** окно, чтобы одновременно просмотреть стеки вызовов нескольких потоков GPU.

- С помощью **контроль параллельных данных** окно для проверки значений из одного выражения в нескольких потоках одновременно.

- Пометка, закрепление, размораживание и группировки потоков GPU.

- Выполнение всех потоков плитки в определенное расположение в коде.

## <a name="prerequisites"></a>Предварительные требования

Перед началом работы в этом пошаговом руководстве:

- Чтение [Обзор C++ AMP](../../parallel/amp/cpp-amp-overview.md).

- Убедитесь, что в этой строке отображаются числа в текстовом редакторе. Дополнительные сведения см. в разделе [как: отображение номеров строк в редакторе](/visualstudio/ide/reference/how-to-display-line-numbers-in-the-editor).

- Убедитесь, что вы используете Windows 8 или Windows Server 2012 для поддержки отладки в эмуляторе программного обеспечения.

[!INCLUDE[note_settings_general](../../mfc/includes/note_settings_general_md.md)]

### <a name="to-create-the-sample-project"></a>Создание примера проекта

1. Запустите Visual Studio.

2. В строке меню выберите **Файл** > **Создать** > **Проект**.

3. В разделе **установленные** в области «Шаблоны» выберите **Visual C++**.

4. Выберите **консольное приложение Win32**, тип `AMPMapReduce` в **имя** поле, а затем выберите **ОК** кнопки.

5. Нажмите кнопку **Далее**.

6. Очистить **предкомпилированный заголовок** , а затем нажать **Готово** кнопки.

7. В **обозревателе решений**, удалить файл stdafx.h, targetver.h и stdafx.cpp из проекта.

8. Откройте AMPMapReduce.cpp и замените его содержимое следующим кодом.

```cpp
    // AMPMapReduce.cpp defines the entry point for the program.
    // The program performs a parallel-sum reduction that computes the sum of an array of integers.

    #include <stdio.h>
    #include <tchar.h>
    #include <amp.h>

    const int BLOCK_DIM = 32;

    using namespace concurrency;

    void sum_kernel_tiled(tiled_index<BLOCK_DIM> t_idx, array<int, 1> &A, int stride_size) restrict(amp)
    {
        tile_static int localA[BLOCK_DIM];

        index<1> globalIdx = t_idx.global * stride_size;
        index<1> localIdx = t_idx.local;

        localA[localIdx[0]] =  A[globalIdx];

        t_idx.barrier.wait();

        // Aggregate all elements in one tile into the first element.
        for (int i = BLOCK_DIM / 2; i > 0; i /= 2)
        {
            if (localIdx[0] < i)
            {

                localA[localIdx[0]] += localA[localIdx[0] + i];
            }

            t_idx.barrier.wait();
        }

        if (localIdx[0] == 0)
        {
            A[globalIdx] = localA[0];
        }
    }

    int size_after_padding(int n)
    {
        // The extent might have to be slightly bigger than num_stride to
        // be evenly divisible by BLOCK_DIM. You can do this by padding with zeros.
        // The calculation to do this is BLOCK_DIM * ceil(n / BLOCK_DIM)
        return ((n - 1) / BLOCK_DIM + 1) * BLOCK_DIM;
    }

    int reduction_sum_gpu_kernel(array<int, 1> input)
    {
        int len = input.extent[0];

        //Tree-based reduction control that uses the CPU.
        for (int stride_size = 1; stride_size < len; stride_size *= BLOCK_DIM)
        {
            // Number of useful values in the array, given the current
            // stride size.
            int num_strides = len / stride_size;

            extent<1> e(size_after_padding(num_strides));

            // The sum kernel that uses the GPU.
            parallel_for_each(extent<1>(e).tile<BLOCK_DIM>(), [&input, stride_size] (tiled_index<BLOCK_DIM> idx) restrict(amp)
            {
                sum_kernel_tiled(idx, input, stride_size);
            });
        }

        array_view<int, 1> output = input.section(extent<1>(1));
        return output[0];
    }

    int cpu_sum(const std::vector<int> &arr) {
        int sum = 0;
        for (size_t i = 0; i < arr.size(); i++) {
            sum += arr[i];
        }
        return sum;
    }

    std::vector<int> rand_vector(unsigned int size) {
        srand(2011);

        std::vector<int> vec(size);
        for (size_t i = 0; i < size; i++) {
            vec[i] = rand();
        }
        return vec;
    }

    array<int, 1> vector_to_array(const std::vector<int> &vec) {
        array<int, 1> arr(vec.size());
        copy(vec.begin(), vec.end(), arr);
        return arr;
    }

    int _tmain(int argc, _TCHAR* argv[])
    {
        std::vector<int> vec = rand_vector(10000);
        array<int, 1> arr = vector_to_array(vec);

        int expected = cpu_sum(vec);
        int actual = reduction_sum_gpu_kernel(arr);

        bool passed = (expected == actual);
        if (!passed) {
            printf("Actual (GPU): %d, Expected (CPU): %d", actual, expected);
        }
        printf("sum: %s\n", passed  "Passed!" : "Failed!");

        getchar();

        return 0;
    }
```

9. В строке меню выберите **Файл** > **Сохранить все**.

10. В **обозревателе решений**, откройте контекстное меню для **AMPMapReduce**, а затем выберите **свойства**.

11. В **страницы свойств** диалогового **свойства конфигурации**, выберите **C/C++** > **предкомпилированные заголовки**.

12. Для **предкомпилированный заголовок** выберите **не использовать предкомпилированные заголовки**, а затем выберите **ОК** кнопки.

13. В строке меню последовательно выберите **Сборка**  >  **Собрать решение**.

## <a name="debugging-the-cpu-code"></a>Отладка кода ЦП

В этой процедуре будет использовать локальный отладчик Windows, чтобы убедиться в том, правильность кода ЦП в этом приложении. Сегмент кода ЦП в этом приложении, которая особенно интересна `for` цикл `reduction_sum_gpu_kernel` функции. Он управляет на основе дерева параллельной редукции, выполняются в GPU.

### <a name="to-debug-the-cpu-code"></a>Для отладки кода ЦП

1. В **обозревателе решений**, откройте контекстное меню для **AMPMapReduce**, а затем выберите **свойства**.

2. В **страницы свойств** диалогового **свойства конфигурации**, выберите **Отладка**. Убедитесь, что **локальный отладчик Windows** выбран в **отладчик для запуска** списка.

3. Вернитесь к **редактор кода**.

4. Установите точки останова в строках кода, показанного на следующем рисунке (около строки 67 строку 70).

     ![Точки останова ЦП](../../parallel/amp/media/campcpubreakpoints.png "campcpubreakpoints") точки останова ЦП

5. В строке меню выберите **Отладка** > **Начать отладку**.

6. В **"Локальные"** окна, определите значение для `stride_size` до достижения точки останова в строке 70.

7. В строке меню выберите **Отладка** > **Остановить отладку**.

## <a name="debugging-the-gpu-code"></a>Отладка кода GPU

В этом разделе показаны способы отладки кода GPU, что код, содержащийся в `sum_kernel_tiled` функции. Кода GPU параллельно вычисляет сумму целых чисел для каждого «block».

### <a name="to-debug-the-gpu-code"></a>Для отладки кода GPU

1. В **обозревателе решений**, откройте контекстное меню для **AMPMapReduce**, а затем выберите **свойства**.

2. В **страницы свойств** диалогового **свойства конфигурации**, выберите **Отладка**.

3. В **отладчик для запуска** выберите **локальный отладчик Windows**.

4. В **тип отладчика** списке, убедитесь, что **автоматически** выбран.

    **Автоматическое** значение по умолчанию. До Windows 10 **только графический Процессор** — это обязательное значение вместо **автоматически**.

5. Нажмите кнопку **ОК** .

6. Установите точку останова в строке 30, как показано на следующем рисунке.

     ![Точки останова GPU](../../parallel/amp/media/campgpubreakpoints.png "campgpubreakpoints") GPU в точке останова

7. В строке меню выберите **Отладка** > **Начать отладку**. Точки останова в коде ЦП в строках 67 и 70 не выполняются во время отладки, поскольку эти строки кода выполняются на ЦП GPU.

### <a name="to-use-the-gpu-threads-window"></a>Использование окна потоков GPU

1. Чтобы открыть **потоки GPU** окно, в строке меню выберите **Отладка** > **Windows** > **потоки GPU**.

   Вы можете проверить состояние потоков GPU в **потоки GPU** появившемся окне.

2. Dock **потоки GPU** окно в нижней части Visual Studio. Выберите **разверните переключение потока** кнопку, чтобы отобразить поля плитки "и" Поток ". **Потоки GPU** окне отображается общее число активных и заблокированных потоков GPU, как показано на следующем рисунке.

     ![Окно "потоки GPU" с 4 активными потоками](../../parallel/amp/media/campc.png "campc") окна "потоки GPU"

   Имеются 313 плитки, выделенных для этого вычисления. Каждая плитка содержит 32 потоков. Поскольку локальной отладки GPU в программном эмуляторе происходит, существуют четыре активные потоки GPU. Четыре потока одновременно выполнять инструкции и затем перемещаются следующую инструкцию.

   В **потоки GPU** мыши четырех потоков GPU активны и 28 заблокированных потоков GPU в [tile_barrier::wait](reference/tile-barrier-class.md#wait) инструкции около строки 21 (`t_idx.barrier.wait();`). Все 32 потоков GPU принадлежат к первой плитке `tile[0]`. Стрелка указывает на строку, которая включает в себя текущего потока. Чтобы переключиться на другой поток, используйте один из следующих методов:

    - В строке для потока для переключения в **потоки GPU** окно, откройте контекстное меню и выберите **переключиться на поток**. Если строка представляет более одного потока, можно будет переключиться на первый поток, в соответствии с координаты потока.

    - Введите значения плитки и поток потока в соответствующих текстовых полях и выберите **поток коммутатора** кнопки.

   **Стек вызовов** окна отображается стек вызовов для текущего потока GPU.

### <a name="to-use-the-parallel-stacks-window"></a>Использование окна параллельных стеков

1. Чтобы открыть **Параллельные стеки** окно, в строке меню выберите **Отладка** > **Windows** > **Параллельные стеки**.

   Можно использовать **Параллельные стеки** окно, чтобы одновременно проверки кадров стека нескольких потоков GPU.

2. Dock **Параллельные стеки** окно в нижней части Visual Studio.

3. Убедитесь, что **потоков** выбран в списке в левом верхнем углу. На следующем рисунке **Параллельные стеки** окне будет показано представление с фокусом ввода стека вызовов потоков GPU, которые вы видели в **потоки GPU** окна.

     ![Окно параллельных стеков с 4 активными потоками](../../parallel/amp/media/campd.png "campd") окна "Параллельные стеки"

   32 потоков изменился с `_kernel_stub` в лямбда-выражении в `parallel_for_each` вызов функции и затем `sum_kernel_tiled` функции, где происходит параллельной редукции. 28 из 32 потока создали для [tile_barrier::wait](reference/tile-barrier-class.md#wait) инструкции и остаются заблокированными в строке 22, тогда как другие потоки 4 остаются активными в `sum_kernel_tiled` функции в строке 30.

   Можно проверить свойства поток GPU, доступные в **потоки GPU** окно в богатый подсказке по данным из **Параллельные стеки** окна. Для этого наведите указатель мыши на кадр стека **sum_kernel_tiled**. На следующем рисунке подсказке по данным.

     ![DataTip для окна "Параллельные стеки"](../../parallel/amp/media/campe.png "campe") поток GPU подсказки данных

   Дополнительные сведения о **Параллельные стеки** окно, см. в разделе [в окне параллельных стеков](/visualstudio/debugger/using-the-parallel-stacks-window).

### <a name="to-use-the-parallel-watch-window"></a>Использование окна параллельных контрольных значений

1. Чтобы открыть **контроль параллельных данных** окно, в строке меню выберите **Отладка** > **Windows** > **контроль параллельных данных**  >  **Контроль параллельных данных 1**.

   Можно использовать **контроль параллельных данных** окно для проверки значений выражения в нескольких потоках.

2. Dock **контроль параллельных данных 1** окно к нижней части Visual Studio. В таблице есть 32 строк **контроль параллельных данных** окна. Каждый соответствует поток GPU, появившегося в окне потоков GPU и **Параллельные стеки** окна. Теперь можно ввести выражения, значения которого требуется проверить все 32 потоков GPU.

3. Выберите **Добавить контрольное значение** заголовок столбца, введите `localIdx`, а затем выберите **ввод** ключ.

4. Выберите **Добавить контрольное значение** заголовок столбца еще раз, тип `globalIdx`, а затем выберите **ввод** ключ.

5. Выберите **Добавить контрольное значение** заголовок столбца еще раз, тип `localA[localIdx[0]]`, а затем выберите **ввод** ключ.

   Щелкнув заголовок соответствующего столбца можно отсортировать по указанному выражению.

   Выберите **localA [localIdx [0]]** заголовок столбца для сортировки столбца. На следующем рисунке показан результаты сортировки **localA [localIdx [0]]**.

     ![Окно параллельных контрольных значений с отсортированными результатами](../../parallel/amp/media/campf.png "campf") результаты сортировки

   Вы можете экспортировать содержимое в **контроль параллельных данных** окна в Excel, выбрав **Excel** кнопки, а затем выбрав **открыть в Excel**. При наличии на компьютере разработчика установлена программа Excel откроется лист Excel, содержащий содержимое.

6. В правом верхнем углу **контроль параллельных данных** окне имеется элемент управления фильтра, который можно использовать для фильтрации содержимого с помощью логических выражений. Ввод `localA[localIdx[0]] > 20000` в тексте элемента управления фильтра и нажмите кнопку **ввод** ключ.

   Окно теперь содержит только потоки, на котором `localA[localIdx[0]]` больше, чем 20000. Содержимое по-прежнему сортируется по `localA[localIdx[0]]` столбец, который является сортировки действия, выполненные ранее.

## <a name="flagging-gpu-threads"></a>Пометка потоков GPU

Можно пометить определенные потоки GPU, помечая их в **потоки GPU** окне **контроль параллельных данных** окно или в подсказке по данным **Параллельные стеки** окна. Если строка в окне потоков GPU содержит более одного потока, Пометка этой строки помечает все потоки, которые содержатся в строке.

### <a name="to-flag-gpu-threads"></a>Пометка потоков GPU

1. Выберите **[поток]** заголовок столбца в **контроль параллельных данных 1** окно, чтобы отсортировать по индексу плитки и индекс потока.

2. В строке меню выберите **Отладка** > **Продолжить**, что приводит четыре потока были активны для хода выполнения работ по Далее барьера (определенных в строке 32 AMPMapReduce.cpp).

3. Выберите флаг символ слева от строки, содержащей четыре потоки, которые сейчас активны.

   На следующем рисунке показаны четыре active отмеченные потоки в **потоки GPU** окна.

     ![Окно "потоки GPU" с помеченными потоками](../../parallel/amp/media/campg.png "campg") активные потоки в окне потоков GPU

   **Контроль параллельных данных** окно и подсказке по данным из **Параллельные стеки** окно оба указывают помеченных потоков.

4. Если вы хотите сосредоточиться на четырех потоков, которые вы были отмечены, можно отобразить, в **потоки GPU**, **контроль параллельных данных**, и **Параллельные стеки** windows, только помеченные потоки.

   Выберите **Показать только помеченные** кнопку на любом windows или на **место отладки** панели инструментов. На следующем рисунке показано **Показать только помеченные** кнопку **место отладки** панели инструментов.

     ![Расположение панели со значком, Показать только отмеченные отладки](../../parallel/amp/media/camph.png "camph")
**Показать только помеченные** кнопки

   Теперь **потоки GPU**, **контроль параллельных данных**, и **Параллельные стеки** окнах отображаются только помеченных потоков.

## <a name="freezing-and-thawing-gpu-threads"></a>Замораживание и размораживание потоков GPU

Можно закрепить (приостанавливать) и размораживать (возобновлять) GPU потоки либо из **потоки GPU** окна или **контроль параллельных данных** окна. Можно заморозить или Разморозить потоки ЦП одинаково. сведения см. в разделе [как: использование окна потоков](/visualstudio/debugger/how-to-use-the-threads-window).

### <a name="to-freeze-and-thaw-gpu-threads"></a>Чтобы заморозить и Разморозить потоки GPU

1. Выберите **Показать только помеченные** кнопку, чтобы отобразить все потоки.

2. В строке меню выберите **Отладка** > **Продолжить**.

3. Откройте контекстное меню для активной строки, а затем выберите **закрепить**.

   На следующем рисунке **потоки GPU** окно показывает, что все четыре потоки заморожены.

     ![Windows потоки GPU, в котором показаны замороженные потоки](../../parallel/amp/media/campk.png "campk") застывает в текущем состоянии потоков **потоки GPU** окно

   Аналогичным образом **контроль параллельных данных** окно показывает, что все четыре потоки заморожены.

4. В строке меню выберите **Отладка** > **Продолжить** следующих четырех потоков GPU работ, прошедшими барьер в строке 22 и достигнет точки останова в строке 30. **Потоки GPU** окно показывает, что четыре ранее замороженные потоки остаются Замороженные и в активном состоянии.

5. В строке меню выберите **Отладка**, **Продолжить**.

6. Из **контроль параллельных данных** окно, можно также Разморозить одного или нескольких потоков GPU.

### <a name="to-group-gpu-threads"></a>Группирование потоков GPU

1. В контекстном меню для одного из потоков в **потоки GPU** окно, выберите **Group By**, **адрес**.

   Потоки в **потоки GPU** окно группируются по адресу. Адрес соответствует инструкции в дизассемблированном коде, где расположена каждая группа потоков. 24 потоки, в строке 22 где [метод tile_barrier::wait](reference/tile-barrier-class.md#wait) выполняется. 12 потоков, инструкции для барьера строки 32. Четыре из этих потоков, помечаются. В точке останова в строке 30 — восемь потоков. Четыре из эти потоки заморожены. На следующем рисунке показаны сгруппированные потоки в **потоки GPU** окна.

     ![Окно "потоки GPU" с потоками, сгруппированными по адресам](../../parallel/amp/media/campl.png "campl") сгруппированные потоки в **потоки GPU** окно

2. Можно также выполнить **Group By** операции, открыв контекстное меню для сетки данных **контроль параллельных данных** окно, выбрав **Group By**и выбрав в меню элемент, соответствующий способ группировки потоков.

## <a name="running-all-threads-to-a-specific-location-in-code"></a>Выполнение всех потоков в определенное расположение в коде

Нужно запустить все потоки в заданной плитки для строки, содержащей курсор с помощью **выполнить текущей плитки до курсора**.

### <a name="to-run-all-threads-to-the-location-marked-by-the-cursor"></a>Для выполнения всех потоков в расположение, отмеченного курсора

1. В контекстном меню для замороженные потоки, выберите **Разморозить**.

2. В **редактор кода**, поместите курсор в строки 30.

3. В контекстном меню для **редактор кода**, выберите **выполнить текущий Tile до курсора**.

   24 потоками, которые ранее были заблокированы в барьер в строке 21 создали строку 32. Это показано в **потоки GPU** окна.

## <a name="see-also"></a>См. также

[Общие сведения о C++ AMP](../../parallel/amp/cpp-amp-overview.md)<br/>
[Отладка кода GPU](/visualstudio/debugger/debugging-gpu-code)<br/>
[Практическое руководство. Использование окна потоков GPU](/visualstudio/debugger/how-to-use-the-gpu-threads-window)<br/>
[Практическое руководство. Использование окна контроля параллельных данных](/visualstudio/debugger/how-to-use-the-parallel-watch-window)<br/>
[Анализ кода C++ AMP с Визуализатором параллелизма](https://blogs.msdn.microsoft.com/nativeconcurrency/2012/03/09/analyzing-c-amp-code-with-the-concurrency-visualizer/)