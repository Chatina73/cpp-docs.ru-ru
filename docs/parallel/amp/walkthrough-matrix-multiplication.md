---
title: Пошаговое руководство. Умножение матриц
ms.date: 04/23/2019
ms.assetid: 61172e8b-da71-4200-a462-ff3a908ab0cf
ms.openlocfilehash: a84383aa02b3f8300774e18ba2b27655d07b72ae
ms.sourcegitcommit: 8e285a766523e653aeeb34d412dc6f615ef7b17b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2020
ms.locfileid: "80075709"
---
# <a name="walkthrough-matrix-multiplication"></a>Пошаговое руководство. Умножение матриц

В этом пошаговом руководстве показано, как использовать C++ amp для ускорения выполнения умножения матриц. Представлены два алгоритма: один — без мозаичного заполнения и один с мозаичным заполнением.

## <a name="prerequisites"></a>Предварительные требования

Перед началом.

- Ознакомьтесь [ C++ с обзором amp](../../parallel/amp/cpp-amp-overview.md).

- Чтение [с помощью плиток](../../parallel/amp/using-tiles.md).

- Убедитесь, что используется как минимум Windows 7 или Windows Server 2008 R2.

### <a name="to-create-the-project"></a>Создание проекта

Инструкции по созданию нового проекта зависят от установленной версии Visual Studio. Убедитесь, что в левом верхнем углу установлен правильный выбор версии.

::: moniker range="vs-2019"

### <a name="to-create-the-project-in-visual-studio-2019"></a>Создание проекта в Visual Studio 2019

1. В строке меню последовательно выберите **файл** > **создать** > **проект** , чтобы открыть диалоговое окно **Создание нового проекта** .

1. В верхней части диалогового окна для параметра **Язык** выберите значение **C++** , для параметра **Платформа** — значение **Windows**, а для параметра **Тип проекта** — значение **Консоль**.

1. В отфильтрованном списке типов проектов выберите **пустой проект** , а затем нажмите кнопку **Далее**. На следующей странице введите *матриксмултипли* в поле **имя** , чтобы указать имя проекта, и при необходимости укажите расположение проекта.

   ![Новое консольное приложение](../../build/media/mathclient-project-name-2019.png "Новое консольное приложение")

1. Нажмите кнопку **Создать**, чтобы создать клиентский проект.

1. В **Обозреватель решений**откройте контекстное меню **исходных файлов**и выберите команду **добавить** > **новый элемент**.

1. В диалоговом окне **Добавление нового элемента** выберите  **C++ файл (. cpp)** , введите *матриксмултипли. cpp* в поле **имя** , а затем нажмите кнопку **Добавить** .

::: moniker-end

::: moniker range="<=vs-2017"

### <a name="to-create-a-project-in-visual-studio-2017-or-2015"></a>Создание проекта в Visual Studio 2017 или 2015

1. В строке меню Visual Studio выберите **файл** > **создать** > **проект**.

1. В разделе **установленные** на панели Шаблоны выберите **визуальный C++** элемент.

1. Выберите **пустой проект**, введите *Матриксмултипли* в поле **имя** , а затем нажмите кнопку **ОК** .

1. Нажмите кнопку **Далее**.

1. В **Обозреватель решений**откройте контекстное меню **исходных файлов**и выберите команду **добавить** > **новый элемент**.

1. В диалоговом окне **Добавление нового элемента** выберите  **C++ файл (. cpp)** , введите *матриксмултипли. cpp* в поле **имя** , а затем нажмите кнопку **Добавить** .

::: moniker-end

## <a name="multiplication-without-tiling"></a>Умножение без мозаичного заполнения

В этом разделе мы рассмотрим умножение двух матриц, A и B, которые определены следующим образом:

![3&#45;на&#45;2 матрица A](../../parallel/amp/media/campmatrixanontiled.png "3&#45;на&#45;2 матрица A")

![2&#45;на&#45;3 Матрица B](../../parallel/amp/media/campmatrixbnontiled.png "2&#45;на&#45;3 Матрица B")

A — это матрица размером 3 на 2, а B — матрица размером 2 на 3. Результатом умножения A на B является следующая матрица с 3 по 3. Продукт вычисляется путем умножения строк объекта на столбцы элемента B по элементу.

![&#45;матрица&#45;3 на 3 продукта](../../parallel/amp/media/campmatrixproductnontiled.png "&#45;матрица&#45;3 на 3 продукта")

### <a name="to-multiply-without-using-c-amp"></a>Умножение без использования C++ amp

1. Откройте Матриксмултипли. cpp и используйте следующий код, чтобы заменить существующий код.

   ```cpp
   #include <iostream>

   void MultiplyWithOutAMP() {
       int aMatrix[3][2] = {{1, 4}, {2, 5}, {3, 6}};
       int bMatrix[2][3] = {{7, 8, 9}, {10, 11, 12}};
       int product[3][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};

       for (int row = 0; row < 3; row++) {
           for (int col = 0; col < 3; col++) {
               // Multiply the row of A by the column of B to get the row, column of product.
               for (int inner = 0; inner < 2; inner++) {
                   product[row][col] += aMatrix[row][inner] * bMatrix[inner][col];
               }
               std::cout << product[row][col] << "  ";
           }
           std::cout << "\n";
       }
   }

   int main() {
       MultiplyWithOutAMP();
       getchar();
   }
   ```

   Алгоритм является простой реализацией определения умножения матрицы. Он не использует параллельные или потоки алгоритмы для сокращения времени вычисления.

1. В строке меню выберите **Файл** > **Сохранить все**.

1. Нажмите клавишу **F5** , чтобы начать отладку, и убедитесь, что выходные данные верны.

1. Нажмите клавишу **Ввод** , чтобы выйти из приложения.

### <a name="to-multiply-by-using-c-amp"></a>Умножение с помощью C++ amp

1. В Матриксмултипли. cpp добавьте следующий код перед методом `main`.

   ```cpp
   void MultiplyWithAMP() {
   int aMatrix[] = { 1, 4, 2, 5, 3, 6 };
   int bMatrix[] = { 7, 8, 9, 10, 11, 12 };
   int productMatrix[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };

   array_view<int, 2> a(3, 2, aMatrix);

   array_view<int, 2> b(2, 3, bMatrix);

   array_view<int, 2> product(3, 3, productMatrix);

   parallel_for_each(product.extent,
      [=] (index<2> idx) restrict(amp) {
          int row = idx[0];
          int col = idx[1];
          for (int inner = 0; inner <2; inner++) {
              product[idx] += a(row, inner)* b(inner, col);
          }
      });

   product.synchronize();

   for (int row = 0; row <3; row++) {
      for (int col = 0; col <3; col++) {
          //std::cout << productMatrix[row*3 + col] << "  ";
          std::cout << product(row, col) << "  ";
      }
      std::cout << "\n";
     }
   }
   ```

   Код AMP напоминает код, отличный от AMP. Вызов `parallel_for_each` запускает один поток для каждого элемента в `product.extent`и заменяет `for`ные циклы для строк и столбцов. Значение ячейки в строке и столбце доступно в `idx`. Доступ к элементам объекта `array_view` можно получить с помощью оператора `[]` и переменной индекса либо оператора `()` и переменных строки и столбца. В примере демонстрируются оба метода. Метод `array_view::synchronize` копирует значения переменной `product` обратно в переменную `productMatrix`.

1. Добавьте в начало Матриксмултипли. cpp следующие операторы `include` и `using`.

   ```cpp
   #include <amp.h>
   using namespace concurrency;
   ```

1. Измените метод `main`, чтобы вызвать метод `MultiplyWithAMP`.

   ```cpp
   int main() {
       MultiplyWithOutAMP();
       MultiplyWithAMP();
       getchar();
   }
   ```

1. Нажмите сочетание клавиш **Ctrl**+**F5** , чтобы начать отладку и убедиться, что выходные данные верны.

1. Нажмите клавишу **пробел** , чтобы выйти из приложения.

## <a name="multiplication-with-tiling"></a>Умножение с помощью мозаичного заполнения

Мозаичное заполнение — это методика разделения данных на подмножества одинакового размера, которые называются плитками. При использовании мозаичного заполнения изменились три вещи.

- Можно создать `tile_static` переменные. Доступ к данным в `tile_static` пространстве может выполняться в несколько раз быстрее, чем доступ к данным в глобальном пространстве. Экземпляр `tile_static` переменной создается для каждой плитки, а все потоки в плитке имеют доступ к переменной. Основным преимуществом мозаичного заполнения является повышение производительности из-за `tile_static`ного доступа.

- Можно вызвать метод [tile_barrier:: wait](reference/tile-barrier-class.md#wait) , чтобы останавливаются все потоки в одной плитке в указанной строке кода. Нельзя гарантировать порядок, в котором будут выполняться потоки, только тогда, когда все потоки в одной плитке будут прекращаться при вызове `tile_barrier::wait`, прежде чем продолжить выполнение.

- У вас есть доступ к индексу потока относительно всего объекта `array_view` и индекса относительно плитки. С помощью локального индекса можно упростить чтение и отладку кода.

Чтобы воспользоваться преимуществами мозаичного умножения матрицы, алгоритм должен секционировать матрицу на плитках, а затем скопировать данные плитки в `tile_static` переменные для более быстрого доступа. В этом примере матрица секционирована на подматрицы одинакового размера. Продукт можно найти, умножив подматрицы. В этом примере используются две матрицы и их продукты:

![4&#45;на&#45;4 матрица A](../../parallel/amp/media/campmatrixatiled.png "4&#45;на&#45;4 матрица A")

![4&#45;на&#45;4 Матрица B](../../parallel/amp/media/campmatrixbtiled.png "4&#45;на&#45;4 Матрица B")

![Матрица с 4&#45;на&#45;4 продукта](../../parallel/amp/media/campmatrixproducttiled.png "Матрица с 4&#45;на&#45;4 продукта")

Матрицы разделены на четыре матрицы 2x2, которые определяются следующим образом:

![4&#45;на&#45;4 матрица, секционированная в&#45;2&#45;– 2&#45;подматрицы](../../parallel/amp/media/campmatrixapartitioned.png "4&#45;на&#45;4 матрица, секционированная в&#45;2&#45;– 2&#45;подматрицы")

![4&#45;на&#45;4 Матрица B, секционированная&#45;в&#45;2 –&#45;2 подматрицы](../../parallel/amp/media/campmatrixbpartitioned.png "4&#45;на&#45;4 Матрица B, секционированная&#45;в&#45;2 –&#45;2 подматрицы")

Теперь продукт A и B можно записать и вычислить следующим образом:

![4&#45;на&#45;4 матрица A B, секционированная&#45;в&#45;2 на&#45;2 подматрицы](../../parallel/amp/media/campmatrixproductpartitioned.png "4&#45;на&#45;4 матрица A B, секционированная&#45;в&#45;2 на&#45;2 подматрицы")

Так как матрицы `a`ся через `h` — это матрицы 2x2, все продукты и их суммы также являются матрицами 2x2. Также следует убедиться, что продукт A и B является матрицей 4x4, как и ожидалось. Чтобы быстро проверить алгоритм, Вычислите значение элемента в первой строке первого столбца продукта. В этом примере это значение элемента в первой строке и первом столбце `ae + bg`. Необходимо вычислить только первый столбец, первая строка `ae` и `bg` для каждого термина. Это значение для `ae` равно `(1 * 1) + (2 * 5) = 11`. Значение `bg` равно `(3 * 1) + (4 * 5) = 23`. Конечное значение — `11 + 23 = 34`, что верно.

Для реализации этого алгоритма код:

- Использует `tiled_extent` объект вместо объекта `extent` в вызове `parallel_for_each`.

- Использует `tiled_index` объект вместо объекта `index` в вызове `parallel_for_each`.

- Создает переменные `tile_static` для хранения подматриц.

- Использует метод `tile_barrier::wait`, чтобы прерывать потоки для вычисления продуктов подматриц.

### <a name="to-multiply-by-using-amp-and-tiling"></a>Умножение с помощью AMP и мозаичного заполнения

1. В Матриксмултипли. cpp добавьте следующий код перед методом `main`.

   ```cpp
   void MultiplyWithTiling() {
       // The tile size is 2.
       static const int TS = 2;

       // The raw data.
       int aMatrix[] = { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };
       int bMatrix[] = { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };
       int productMatrix[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

       // Create the array_view objects.
       array_view<int, 2> a(4, 4, aMatrix);
       array_view<int, 2> b(4, 4, bMatrix);
       array_view<int, 2> product(4, 4, productMatrix);

       // Call parallel_for_each by using 2x2 tiles.
       parallel_for_each(product.extent.tile<TS, TS>(),
           [=] (tiled_index<TS, TS> t_idx) restrict(amp)
           {
               // Get the location of the thread relative to the tile (row, col)
               // and the entire array_view (rowGlobal, colGlobal).
               int row = t_idx.local[0];
               int col = t_idx.local[1];
               int rowGlobal = t_idx.global[0];
               int colGlobal = t_idx.global[1];
               int sum = 0;

               // Given a 4x4 matrix and a 2x2 tile size, this loop executes twice for each thread.
               // For the first tile and the first loop, it copies a into locA and e into locB.
               // For the first tile and the second loop, it copies b into locA and g into locB.
               for (int i = 0; i < 4; i += TS) {
                   tile_static int locA[TS][TS];
                   tile_static int locB[TS][TS];
                   locA[row][col] = a(rowGlobal, col + i);
                   locB[row][col] = b(row + i, colGlobal);
                   // The threads in the tile all wait here until locA and locB are filled.
                   t_idx.barrier.wait();

                   // Return the product for the thread. The sum is retained across
                   // both iterations of the loop, in effect adding the two products
                   // together, for example, a*e.
                   for (int k = 0; k < TS; k++) {
                       sum += locA[row][k] * locB[k][col];
                   }

                   // All threads must wait until the sums are calculated. If any threads
                   // moved ahead, the values in locA and locB would change.
                   t_idx.barrier.wait();
                   // Now go on to the next iteration of the loop.
               }

               // After both iterations of the loop, copy the sum to the product variable by using the global location.
               product[t_idx.global] = sum;
           });

       // Copy the contents of product back to the productMatrix variable.
       product.synchronize();

       for (int row = 0; row <4; row++) {
           for (int col = 0; col <4; col++) {
               // The results are available from both the product and productMatrix variables.
               //std::cout << productMatrix[row*3 + col] << "  ";
               std::cout << product(row, col) << "  ";
           }
           std::cout << "\n";
       }
   }
   ```

   Этот пример значительно отличается от примера без мозаичного заполнения. В коде используются следующие концептуальные шаги:
   1. Скопируйте элементы мозаики [0, 0] `a` в `locA`. Скопируйте элементы мозаики [0, 0] `b` в `locB`. Обратите внимание, что `product` заполняется, а не `a` и `b`. Таким образом, для доступа к `a, b`и `product`используются глобальные индексы. Вызов `tile_barrier::wait` является обязательным. Он останавливает все потоки в плитке до тех пор, пока не будут заполнены оба `locA` и `locB`.

   1. Умножьте `locA` и `locB` и помещайте результаты в `product`.

   1. Скопируйте элементы мозаики [0, 1] `a` в `locA`. Скопируйте элементы мозаики [1, 0] `b` в `locB`.

   1. Умножьте `locA` и `locB` и добавьте их в результаты, которые уже находятся в `product`.

   1. Умножение плитки [0, 0] завершено.

   1. Повторите эти четыре плитки. Индексирование для плиток не предусмотрено, и потоки могут выполняться в любом порядке. По мере выполнения каждого потока `tile_static` переменные создаются для каждой плитки соответствующим образом, а вызов `tile_barrier::wait` управляет ходом выполнения программы.

   1. При тщательном анализе алгоритма Обратите внимание, что каждая подматрица загружается в `tile_static`ную память дважды. Эта перенаправление данных занимает некоторое время. Однако после того, как данные находятся в `tile_static` памяти, доступ к данным будет выполняться гораздо быстрее. Поскольку вычисление продуктов требует многократного доступа к значениям в подматрицах, существует общий выигрыш в производительности. Для каждого алгоритма требуется экспериментирование, чтобы найти оптимальный алгоритм и размер плитки.

   В примерах, отличных от AMP и не являющихся плитками, доступ к каждому элементу A и B осуществляется четыре раза из глобальной памяти для вычисления продукта. В примере плитки доступ к каждому элементу осуществляется дважды из глобальной памяти и четыре раза из памяти `tile_static`. Это не является значительной приростом производительности. Однако если A и B были 1024x1024 матрицы и размер плитки был 16, то производительность будет значительно увеличена. В этом случае каждый элемент копируется в `tile_static` память только 16 раз и доступ к `tile_static` памяти 1024 раз.

1. Измените метод Main, чтобы вызвать метод `MultiplyWithTiling`, как показано ниже.

   ```cpp
   int main() {
       MultiplyWithOutAMP();
       MultiplyWithAMP();
       MultiplyWithTiling();
       getchar();
   }
   ```

1. Нажмите сочетание клавиш **Ctrl**+**F5** , чтобы начать отладку и убедиться, что выходные данные верны.

1. Нажмите клавишу **пробел** , чтобы выйти из приложения.

## <a name="see-also"></a>См. также:

[C++ AMP (C++ Accelerated Massive Parallelism)](../../parallel/amp/cpp-amp-cpp-accelerated-massive-parallelism.md)<br/>
[Пошаговое руководство. Отладка приложения C++ AMP](../../parallel/amp/walkthrough-debugging-a-cpp-amp-application.md)
