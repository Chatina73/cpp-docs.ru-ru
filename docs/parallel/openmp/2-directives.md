---
title: 2. Директивы
ms.date: 01/18/2019
ms.assetid: d1a69374-6c03-45fb-8c86-e91cea8adae8
ms.openlocfilehash: 125d2d83b277e62d007e3a208e426ea717d52790
ms.sourcegitcommit: 382e247c0f1b4cb7c2dab837b8b6fdff24bff47a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/28/2019
ms.locfileid: "55087344"
---
# <a name="2-directives"></a>2. Директивы

Директивы основаны на `#pragma` директивы, определенные в стандартах C и C++.  Компиляторы, которые поддерживают API OpenMP C и C++ API будет включать параметр командной строки, которая активирует и позволяет интерпретацию все директивы компилятора OpenMP.

## <a name="21-directive-format"></a>2.1 формат директивы

Синтаксис в директиве OpenMP определяется формально грамматики в [приложение C](c-openmp-c-and-cpp-grammar.md)и неформально следующим образом:

```cpp
#pragma omp directive-name  [clause[ [,] clause]...] new-line
```

Каждая директива начинается с `#pragma omp`, чтобы уменьшить вероятность возникновения конфликтов с помощью директивы pragma других (отличных от OpenMP или поставщика расширения с OpenMP) с теми же именами. Остальная часть директивы соглашениям стандартов C и C++ для директивы компилятора. В частности, можно использовать пробелы до и после `#`, и иногда необходимо использовать пробелы для разделения слов в директиве. Следующие токены предварительной обработки `#pragma omp` подвержены замены макроса.

Директивы учитывается регистр. Порядок, в котором предложения отображаются в директивы невелика. Предложения для директивы может повторяться, при необходимости, распространяются ограничения, перечисленных в описании каждого предложения. Если *списка переменной* отображается в предложении, его необходимо указать только переменные. Только один *имя директивы* может быть указан для каждой директивы.  Например следующая директива не является допустимым:

```cpp
/* ERROR - multiple directive names not allowed */
#pragma omp parallel barrier
```

В директиве OpenMP применяется более одной последующие инструкции, который должен быть структурированный блок.

## <a name="22-conditional-compilation"></a>2.2 условная компиляция

`_OPENMP` Имя макроса определяется OpenMP совместимым реализациями как десятичной константы *yyyymm*, она будет называться год и месяц утвержденных спецификации. Этот макрос не должно быть предметом `#define` или `#undef` директивы предварительной обработки.

```cpp
#ifdef _OPENMP
iam = omp_get_thread_num() + index;
#endif
```

Если поставщиков определяют расширения OpenMP, они могут указать дополнительные предопределенные макросы.

## <a name="23-parallel-construct"></a>2.3 конструкция parallel

Следующая директива определяет параллельной области, являющийся областью программы, необходимо выполнить множество потоков в параллельном режиме. Эта директива является фундаментальной конструкцией, которая запускает параллельного выполнения.

```cpp
#pragma omp parallel [clause[ [, ]clause] ...] new-line   structured-block
```

*Предложение* является одним из следующих:

- `if(` *скалярное выражение* `)`
- `private(` *переменная list* `)`
- `firstprivate(` *переменная list* `)`
- `default(shared | none)`
- `shared(` *переменная list* `)`
- `copyin(` *переменная list* `)`
- `reduction(` *оператор* `:` *переменной list* `)`
- `num_threads(` *integer-expression* `)`

Если поток получает к параллельной конструкции, группу потоков создается в том случае, если выполняется одно из следующих случаев:

- Не `if` присутствует предложение.
- `if` Выражение принимает значение ненулевое значение.

Этот поток становится главного потока рабочей группы, с количеством потоков 0, и все потоки в группе, включая главный поток выполнения области в параллельном режиме. Если значение `if` выражение равно нулю, сериализуется области.

Чтобы определить количество потоков, которые запрашиваются, в порядке будет считаться следующие правила. Применяется первое правило, условия:

1. Если `num_threads` присутствует предложение, а затем значение целочисленного выражения число потоков, в запросе.

1. Если `omp_set_num_threads` вызова функции библиотеки, то значение аргумента в вызове самого последнего выполненного является количество потоков, в запросе.

1. Если переменная среды `OMP_NUM_THREADS` задан, то значение этой переменной среды является количество потоков, в запросе.

1. Если ни один из описанных выше методов, число потоков, в запросе, определяемого реализацией.

Если `num_threads` присутствует предложение, а затем она заменяет собой число потоков, запрашиваемых `omp_set_num_threads` функции библиотеки или `OMP_NUM_THREADS` в переменной среды только область параллельной обработки, он применяется. В нем не затрагиваются позже параллельных регионов.

Количество потоков, выполняющих параллельной области также зависит от того, включен ли динамическую настройку количество потоков. Если динамическую настройку отключена, запрашиваемое количество потоков, которые будет выполняться область параллельной обработки. Если включено динамическое выравнивание запрошенное число потоков, то максимальное число потоков, которые могут выполняться область параллельной обработки.

Если область параллельной обработки встречается динамическую настройку число потоков, отключена, и число потоков, запрошенный для параллельной области больше, чем число, которое может предоставить системе времени выполнения, то поведение программы не определяемого реализацией. Реализация может например, прервать выполнение программы, или он может сериализовать область параллельной обработки.

`omp_set_dynamic` Функция библиотеки и `OMP_DYNAMIC` переменной среды можно использовать для включения и отключения динамическую настройку количество потоков.

Число физических процессоров, потоки, кем фактически размещена в любой момент времени, определяемого реализацией. После создания, число потоков в группе остается неизменным в течение этой параллельной области. Его можно изменить явно пользователем или автоматически системой времени выполнения из одной параллельной области в другую.

Инструкции, содержащиеся в динамических степень параллельной области будут выполняться каждым потоком, и каждый поток может выполняться контура инструкций, который отличается от других потоков. Директивы обнаружил за пределами лексическую область параллельной области, называются потерянные директивы.

Нет подразумеваемых барьера, в конце параллельной области. Только главный поток команда продолжает выполнение в конце параллельной области.

Если поток в команде выполнения параллельной области обнаруживает другие параллельные конструкции, он создает новую группу, и становится главным этой новой команды. Вложенные области параллельной сериализуются по умолчанию. Таким образом по умолчанию, вложенный параллельной области выполняется командой, состоящий из одного потока. Поведение по умолчанию может быть изменен с помощью функции библиотеки среды выполнения `omp_set_nested` или переменную среды `OMP_NESTED`. Однако количество потоков в группе, выполняющих параллельной вложенной области определяется реализацией.

Ограничения для `parallel` директива таковы:

- Не более одного `if` предложение может использоваться в директиве.

- Он этот атрибут не задан ли любой из которых побочные эффекты внутри if выражение или `num_threads` происходят выражение.

- Объект `throw` внутри параллельной области могут вызвать для возобновления в динамических экстент же структурированном блоке выполнения, и он должен перехватывать же потока, вызвавшего исключение.

- Только один `num_threads` предложение может использоваться в директиве. `num_threads` Выражение вычисляется вне контекста область параллельной обработки и должен иметь положительное целое значение.

- Порядок вычисления `if` и `num_threads` предложения не указано.

### <a name="cross-references"></a>Перекрестные ссылки

- `private`, `firstprivate`, `default`, `shared`, `copyin`, и `reduction` предложений ([разделе 2.7.2](#272-data-sharing-attribute-clauses))
- [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads) переменной среды
- [omp_set_dynamic](3-run-time-library-functions.md#317-omp_set_dynamic-function) функции библиотеки
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic) переменной среды
- [omp_set_nested](3-run-time-library-functions.md#319-omp_set_nested-function) функции
- [OMP_NESTED](4-environment-variables.md#44-omp_nested) переменной среды
- [omp_set_num_threads](3-run-time-library-functions.md#311-omp_set_num_threads-function) функции библиотеки

## <a name="24-work-sharing-constructs"></a>2.4 конструкции совместной работы

Конструкции совместной работы распределяет выполнение связанные инструкции между членами команды, которые оно возникает. Директив совместной работы не запуска новых потоков, и на запись конструкции совместной работы преград подразумеваемых.

Создает последовательность совместной работы и `barrier` директивы обнаружил должны быть одинаковыми для каждого потока в группе.

OpenMP определяет следующие конструкции совместной работы, и эти конструкции описаны в следующих разделах:

- [для](#241-for-construct) директива
- [разделы](#242-sections-construct) директива
- [единый](#243-single-construct) директива

### <a name="241-for-construct"></a>2.4.1 конструкция for

`for` Директива идентифицирует итеративный конструкция совместной работы, которая указывает, что итерации связанного цикла будет выполняться в параллельном режиме. Итераций `for` цикла распределяются по потокам, которые уже существуют в группе, выполнения параллельной конструкции, к которому он привязан. Синтаксис `for` конструкция выглядит следующим образом:

```cpp
#pragma omp for [clause[[,] clause] ... ] new-line for-loop
```

Предложение является одним из следующих:

- `private(` *переменная list* `)`
- `firstprivate(` *переменная list* `)`
- `lastprivate(` *переменная list* `)`
- `reduction(` *оператор* `:` *переменной list* `)`
- `ordered`
- `schedule(` *Тип* [`,` *chunk_size*] `)`
- `nowait`

`for` Директива накладывает ограничения на структуру соответствующего `for` цикла. В частности, соответствующий `for` цикл должен иметь каноническую форму:

`for (` *init-expr* `;` *var  logical-op  b* `;` *incr-expr* `)`

*init-expr*<br/>
Один из следующих вариантов:

- *var* = *lb*
- *var целочисленного типа* = *lb*

*INCR-expr*<br/>
Один из следующих вариантов:

- `++` *var*
- *var* `++`
- `--` *var*
- *var* `--`
- *var* `+=` *incr*
- *var* `-=` *incr*
- *var* `=` *var* `+` *incr*
- *var* `=` *incr* `+` *var*
- *var* `=` *var* `-` *incr*

*var*<br/>
Переменная, целое число со знаком. Если эта переменная в противном случае используются совместно, она выполняется неявно закрытый в течение `for`. Не изменяйте эту переменную в теле `for` инструкции. Если не указано в переменной `lastprivate`, его значение после цикла не определен.

*logical-op*<br/>
Один из следующих вариантов:

- `<`
- `<=`
- `>`
- `>=`

*lb*, *b*, и *incr*<br>
Цикл целые инвариантного выражения. Синхронизация не выполняется во время вычисления эти выражения, вычисленного побочных эффектов привести к непредсказуемым результатам.

Каноническая форма позволяет количество итераций цикла вычисляться при входе в цикл. Это вычисление устанавливается с использованием значения в тип *var*, после восходящее приведение целочисленных типов. В частности, если значение *b* `-` *lb* `+` *incr* не могут быть представлены в том, что тип, результат не определен. Кроме того, если *логических операций* — `<` или `<=`, затем *incr-expr* могут вызвать *var* для повышения на каждой итерации цикла.   Если *логических операций* — `>` или `>=`, затем *incr-expr* могут вызвать *var* для получения меньшего размера на каждой итерации цикла.

`schedule` Предложение указывает, каким образом итераций `for` цикл разделяются между несколькими потоками рабочей группы. Правильность программы не должен зависеть какой поток выполняет определенной итерации. Значение *chunk_size*, если он указан, должно быть выражение цикла инвариантного целое число с положительным. Синхронизация не выполняется во время вычисления этого выражения, вычисленного побочных эффектов привести к непредсказуемым результатам. Расписание *вид* может принимать одно из следующих значений:

Таблица 2-1. `schedule` предложение *вид* значения

|||
|-|-|
|статический|Когда `schedule(static,` *chunk_size* `)` указан, итераций, разделены на блоки размер, указанный параметром *chunk_size*. Блоки назначаются статически для потоков в команде в циклического перебора порядке номер потока. Если аргумент *chunk_size* задан, пространство итерации делится на фрагменты, размер которых примерно одинакового размера, с помощью одного фрагмента данных, назначенный каждому потоку.|
|dynamic|Когда `schedule(dynamic,` *chunk_size* `)` указан, количество итераций можно разделить на ряд блоков данных, каждая из которых содержит *chunk_size* итераций. Каждый блок назначается поток, который ожидает назначения. Поток выполняет кусок итераций, а затем ждет свое назначение Далее, пока не блоки по-прежнему назначаться. Последний блок для назначения может иметь меньшее число итераций. Если аргумент *chunk_size* задан, он по умолчанию 1.|
|Интерактивная|Когда `schedule(guided,` *chunk_size* `)` указан, итераций назначенных потоков в виде фрагментов с уменьшение размеров. Когда поток завершает его назначенного кусок итераций, динамически назначил очередного блока, пока не остается none. Для *chunk_size* 1, объем каждого фрагмента данных составляет приблизительно соответствующее количеству неназначенные итераций, деленное на количество потоков. Эти размеры уменьшаться экспоненциально почти в 1. Для *chunk_size* со значением *k* больше 1, почти экспоненциально до уменьшить размеры *k*, за исключением того, что последний блок может иметь меньше, чем *k* итераций. Если аргумент *chunk_size* задан, он по умолчанию 1.|
|исполняющая среда|Когда `schedule(runtime)` указано, решение о планировании откладывается до времени выполнения. Расписание *вид* и размер фрагментов можно выбрать во время выполнения, задав переменную среды `OMP_SCHEDULE`. Если эта переменная среды не задана, полученный расписание определяется реализацией. Когда `schedule(runtime)` указано, *chunk_size* не должно быть указано.|

При отсутствии явно определенной `schedule` предложение, по умолчанию `schedule` определяется реализацией.

Приложение с OpenMP не стоит полагаться на конкретное расписание для правильного выполнения. Программа не стоит полагаться на расписание *вид* удовлетворяющие точно описание указанного выше, так как это может быть вариации в реализациях тому же расписанию *вид* через разные компиляторы. Описания можно использовать для выбора расписания, которое подходит для конкретной ситуации.

`ordered` Предложение должен присутствовать, если `ordered` директивы привязки к `for` построения.

Есть неявное барьер в конце `for` создать, если не `nowait` указано предложение.

Ограничения для `for` директива таковы:

- `for` Цикла должно быть структурированный блок, и, кроме того, его выполнение должны завершаться не по `break` инструкции.

- Значения цикла управления выражения `for` цикл, связанный с `for` директива должны быть одинаковыми для всех потоков в группе.

- `for` Переменной итерации цикла должен иметь тип целого числа со знаком.

- Только один `schedule` предложения могут отображаться на `for` директива.

- Только один `ordered` предложения могут отображаться на `for` директива.

- Только один `nowait` предложения могут отображаться на `for` директива.

- Неуказанный if или как часто влияет на любой стороне в пределах *chunk_size*, *lb*, *b*, или *incr* выражения встречаются.

- Значение *chunk_size* выражение должно быть одинаковым для всех потоков в группе.

#### <a name="cross-references"></a>Перекрестные ссылки

- `private`, `firstprivate`, `lastprivate`, и `reduction` предложений ([разделе 2.7.2](#272-data-sharing-attribute-clauses))
- [OMP_SCHEDULE](4-environment-variables.md#41-omp_schedule) переменной среды
- [упорядоченные](#266-ordered-construct) построения
- [расписание](d-using-the-schedule-clause.md) предложение

### <a name="242-sections-construct"></a>2.4.2 разделы конструкция

`sections` Директива идентифицирует noniterative конструкции совместной работы, указывающий набор конструкций, которые будет разделен между потоками в группе. В каждом разделе выполняется один раз потоком в группе. Синтаксис `sections` директива выглядит следующим образом:

```cpp
#pragma omp sections [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block ]
...
}
```

Предложение является одним из следующих:

- `private(` *переменная list* `)`
- `firstprivate(` *переменная list* `)`
- `lastprivate(` *переменная list* `)`
- `reduction(` *оператор* `:` *переменной list* `)`
- `nowait`

В каждом разделе предшествует `section` директивы, несмотря на то что `section` директива не является обязательным для первого раздела. `section` Директивы необходимо заключать в лексическую область `sections` директива. Есть неявное барьер в конце `sections` создать, если не `nowait` указан.

Ограничения для `sections` директива таковы:

- Объект `section` директива не должна находиться за пределами лексическую область `sections` директива.

- Только один `nowait` предложения могут отображаться на `sections` директива.

#### <a name="cross-references"></a>Перекрестные ссылки

- `private`, `firstprivate`, `lastprivate`, и `reduction` предложений ([разделе 2.7.2](#272-data-sharing-attribute-clauses))

### <a name="243-single-construct"></a>2.4.3 конструкция single

`single` Директива определяет конструкцию, которая указывает, что связанный структурированном блоке выполняется только одним потоком в группе (не обязательно главный поток). Синтаксис `single` директива выглядит следующим образом:

```cpp
#pragma omp single [clause[[,] clause] ...] new-linestructured-block
```

Предложение является одним из следующих:

- `private(` *переменная list* `)`
- `firstprivate(` *переменная list* `)`
- `copyprivate(` *переменная list* `)`
- `nowait`

Есть неявное барьера после `single` создать, если не `nowait` указано предложение.

Ограничения для `single` директива таковы:

- Только один `nowait` предложения могут отображаться на `single` директива.
- `copyprivate` Предложение не должны использоваться с `nowait` предложение.

#### <a name="cross-references"></a>Перекрестные ссылки

- `private`, `firstprivate`, и `copyprivate` предложений ([разделе 2.7.2](#272-data-sharing-attribute-clauses))

## <a name="25-combined-parallel-work-sharing-constructs"></a>2.5 объединенный параллельные конструкции совместной работы

Объединенный параллельные конструкции совместной работы являются ярлыками для указания область параллельной обработки, который имеет только один конструкции совместной работы. Эти директивы семантика аналогично указанию явно `parallel` после директивы с одной конструкции совместной работы.

В следующих разделах описаны объединенный параллельные конструкции совместной работы:

- [Параллельные для](#251-parallel-for-construct) директива
- [Параллельная разделах](#252-parallel-sections-construct) директива

### <a name="251-parallel-for-construct"></a>2.5.1 конструкция parallel for

`parallel for` Директива является ярлыком для `parallel` область, которая содержит только один `for` директива. Синтаксис `parallel for` директива выглядит следующим образом:

```cpp
#pragma omp parallel for [clause[[,] clause] ...] new-linefor-loop
```

Эта директива позволяет использовать все предложения из `parallel` директивы и `for` директив, за исключением `nowait` предложение, идентичные значения и ограничения. Семантика такие же, как явно указав `parallel` непосредственно предшествовать директива `for` директива.

#### <a name="cross-references"></a>Перекрестные ссылки

- [Параллельные](#23-parallel-construct) директива
- [для](#241-for-construct) директива
- [Предложения атрибута данных](#272-data-sharing-attribute-clauses)

### <a name="252-parallel-sections-construct"></a>2.5.2 конструкция параллельных разделов

`parallel sections` Директива предоставляет форму ярлык для указания `parallel` область, которая содержит только одну `sections` директива. Семантика такие же, как явно указав `parallel` непосредственно предшествовать директива `sections` директива. Синтаксис `parallel sections` директива выглядит следующим образом:

```cpp
#pragma omp parallel sections  [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block  ]
   ...
}
```

*Предложение* может принимать одно из предложений, принимаемое `parallel` и `sections` директивы, за исключением `nowait` предложение.

#### <a name="cross-references"></a>Перекрестные ссылки

- [Параллельные](#23-parallel-construct) директива
- [разделы](#242-sections-construct) директива

## <a name="26-master-and-synchronization-directives"></a>2.6 директивы Master и синхронизации

В следующих разделах:

- [Главный](#261-master-construct) построения
- [критические](#262-critical-construct) построения
- [Барьер](#263-barrier-directive) директива
- [atomic](#264-atomic-construct) построения
- [Очистить](#265-flush-directive) директива
- [упорядоченные](#266-ordered-construct) построения

### <a name="261-master-construct"></a>2.6.1 конструкция master

`master` Директива определяет конструкцию, которая указывает структурированный блок, который выполняется потоком главной рабочей группы. Синтаксис `master` директива выглядит следующим образом:

```cpp
#pragma omp master new-linestructured-block
```

Другие потоки в группе не выполняете структурированных блоку. Нет преград подразумеваемых на запись или выход из конструкция master.

### <a name="262-critical-construct"></a>2.6.2 конструкция critical

`critical` Директива определяет конструкцию, которая ограничивает выполнение блоку структурированных к одному потоку за раз. Синтаксис `critical` директива выглядит следующим образом:

```cpp
#pragma omp critical [(name)]  new-linestructured-block
```

Необязательный *имя* может использоваться для идентификации критической области. Идентификаторы, используемые для идентификации критической области имеют внешнюю компоновку и находятся в пространстве имен, который отличается от пространства имен, используемые метки, теги, членов и обычные идентификаторы.

Поток ожидает в начале критической области, пока другие потоки не выполняется в критической области (в любом месте программы) с тем же именем. Все неименованные `critical` директивы сопоставляются с тем же именем unspecified.

### <a name="263-barrier-directive"></a>2.6.3 барьер директива

`barrier` Директива синхронизирует все потоки в команде. При обнаружении каждый поток в группе ожидает, пока не всех остальных достигли этой точки. Синтаксис `barrier` директива выглядит следующим образом:

```cpp
#pragma omp barrier new-line
```

После всех потоков в группе столкнулись барьера, каждый поток в команде начинается выполнение инструкций после директивы барьер в параллельном режиме. Так как `barrier` директива не содержит инструкцию языка C, как часть его синтаксис, существуют некоторые ограничения на его размещения в программе. Дополнительные сведения о формальная Грамматика, см. в разделе [приложение C](c-openmp-c-and-cpp-grammar.md). В примере ниже показаны эти ограничения.

```cpp
/* ERROR - The barrier directive cannot be the immediate
*          substatement of an if statement
*/
if (x!=0)
   #pragma omp barrier
...

/* OK - The barrier directive is enclosed in a
*      compound statement.
*/
if (x!=0) {
   #pragma omp barrier
}
```

### <a name="264-atomic-construct"></a>2.6.4 конструкция atomic

`atomic` Директива гарантирует, что конкретное расположение в памяти обновляется атомарно, вместо того чтобы предоставлять к нему доступ можно несколько одновременных потоков записи. Синтаксис `atomic` директива выглядит следующим образом:

```cpp
#pragma omp atomic new-lineexpression-stmt
```

Оператор выражения должен иметь одно из следующих форм:

- *x binop* `=` *expr*
- *x* `++`
- `++` *x*
- *x* `--`
- `--` *x*

В предыдущем выражения:

- *x* выражение lvalue, скалярный тип.

- *expr* выражение с скалярный тип, и он не ссылаться на объект, указанный *x*.

- *binop* не перегруженного оператора и является одним из `+`, `*`, `-`, `/`, `&`, `^`, `|`, `<<`, или `>>`.

Несмотря на то, что он определяется реализацией ли реализация заменяет все `atomic` директивы с `critical` директивы, которые имеют одинаковый уникальный *имя*, `atomic` директива позволяет лучше оптимизации . Часто оборудование инструкции можно найти, можно выполнять атомарные обновления с наименее затратен.

Только нагрузки и хранилище, назначенному с помощью объекта *x* неделимы; вычисления *expr* не является атомарной. Чтобы избежать состояний гонки, все обновления расположения в параллельном режиме должны быть защищены с помощью `atomic` директив, кроме тех, которые известны свободную от условия конкуренции.

Ограничения для `atomic` директива таковы:

- Все atomic ссылки на расположение хранилища x в программе должен быть в совместимый тип.

#### <a name="examples"></a>Примеры

```cpp
extern float a[], *p = a, b;
/* Protect against races among multiple updates. */
#pragma omp atomic
a[index[i]] += b;
/* Protect against races with updates through a. */
#pragma omp atomic
p[i] -= 1.0f;

extern union {int n; float x;} u;
/* ERROR - References through incompatible types. */
#pragma omp atomic
u.n++;
#pragma omp atomic
u.x -= 1.0f;
```

### <a name="265-flush-directive"></a>2.6.5 директива flush

`flush` Директивы, явных или подразумеваемых, указывается точкой следования «между потоками», по которому требуется реализация обеспечить согласованное представление определенных объектов (указан ниже) в памяти для всех потоков в группе. Это означает, что выполнены предыдущие оценки выражения, ссылающиеся на эти объекты, и еще не начал последующих вычислений. Например компиляторы необходимо восстановить значения объектов из регистров в памяти и оборудования может потребоваться очистить буферы записи в память и перезагрузить значений объектов из памяти.

Синтаксис `flush` директива выглядит следующим образом:

```cpp
#pragma omp flush [(variable-list)]  new-line
```

Если объекты, которые требуется синхронизация всех назначается в переменных, а затем эти переменные можно указать в необязательном *списка переменной*. При наличии в указатель *списка переменной*, очищается сам указатель, не объект указателя ссылается.

Объект `flush` директив без *списка переменной* синхронизируется с автоматическую длительность хранения всех общих объектов, кроме недоступные объекты. (Это может оказать большие затраты, чем `flush` с *списка переменной*.) Объект `flush` директив без *списка переменной* подразумевается для следующие директивы:

- `barrier`
- На вход и выход из `critical`
- На вход и выход из `ordered`
- На вход и выход из `parallel`
- При выходе из `for`
- При выходе из `sections`
- При выходе из `single`
- На вход и выход из `parallel for`
- На вход и выход из `parallel sections`

Директива не по умолчанию, если `nowait` присутствует предложение. Следует отметить, что `flush` директива не содержится в разрешении для любой из следующих:

- При входе `for`
- В записи "или" Выход "из `master`
- При входе `sections`
- При входе `single`

Ссылка, которая обращается к значению объекта с типом с квалификатором volatile ведет себя так, как если бы `flush` директива, указав этот объект в предыдущей точке последовательности. Ссылка, которая изменяет значение объекта с типом с квалификатором volatile ведет себя так, как если бы `flush` директива, указав этот объект в точку следующей последовательности.

Так как `flush` директива не содержит инструкцию языка C, как часть его синтаксис, существуют некоторые ограничения на его размещения в программе. Дополнительные сведения о формальная Грамматика, см. в разделе [приложение C](c-openmp-c-and-cpp-grammar.md). В примере ниже показаны эти ограничения.

```cpp
/* ERROR - The flush directive cannot be the immediate
*          substatement of an if statement.
*/
if (x!=0)
   #pragma omp flush (x)
...

/* OK - The flush directive is enclosed in a
*      compound statement
*/
if (x!=0) {
   #pragma omp flush (x)
}
```

Ограничения для `flush` директива таковы:

- Переменная, указанная в `flush` директива не должен иметь ссылочный тип.

### <a name="266-ordered-construct"></a>2.6.6 упорядоченный конструкция

Следующие структурированный блок `ordered` директива выполняется в том порядке, в котором выполняются итерации с помощью последовательного цикла. Синтаксис `ordered` директива выглядит следующим образом:

```cpp
#pragma omp ordered new-linestructured-block
```

`ordered` Директива должна быть в пределах динамический объем `for` или `parallel for` построения. `for` Или `parallel for` директивы, к которому `ordered` конструкция привязки должен иметь `ordered` условие, указанное как описано в разделе [разделе 2.4.1](#241-for-construct). При выполнении `for` или `parallel for` построения с `ordered` предложение, `ordered` конструкции выполняются строго в порядке, в котором они будут выполняться в последовательного выполнения цикла.

Ограничения для `ordered` директива таковы:

- Итерация цикла с `for` конструкция не может выполняться же директивы ordered более одного раза, и он не может выполняться несколько `ordered` директива.

## <a name="27-data-environment"></a>2.7 среда данных

В этом разделе описываются директивы и несколько предложений для управления средой данных во время выполнения параллельных регионов следующим образом:

- Объект [threadprivate](#271-threadprivate-directive) директива позволяет сделать области видимости файла, область пространства имен или переменные статические области видимости блока локального для потока.

- Предложения, которые могут быть указаны в директивы для управления доступом атрибуты переменных в течение конструкции параллельного или совместной работы описаны в [разделе 2.7.2](#272-data-sharing-attribute-clauses).

### <a name="271-threadprivate-directive"></a>2.7.1 директива threadprivate

`threadprivate` Директива делает именованные области видимости файла, область пространства имен то есть статические области видимости блока переменные, указанные в *списка переменной* частной для потока. *переменная list* является разделенный запятыми список переменных, у которых нет неполный тип. Синтаксис `threadprivate` директива выглядит следующим образом:

```cpp
#pragma omp threadprivate(variable-list) new-line
```

Каждая копия `threadprivate` переменная инициализируется один раз, в неизвестной точке в программе перед первым обращением к этой копии и обычным способом (т. е. как мастер-копии будет инициализироваться в последовательное выполнение программы). Обратите внимание, что если в инициализатор явные ссылки на объект `threadprivate` переменной и значения объекта изменяется перед первым обращением к копия переменной, то поведение не определено.

Как с любой частную переменную, поток не должна ссылаться на другой поток копию `threadprivate` объекта. Во время последовательной и master областями программы ссылки будут для главного потока копию объекта.

После выполнения первого параллельной области данных в `threadprivate` объектов гарантированно сохраняются, только если динамического потока механизм была отключена, и если количество потоков остается неизменным для всех параллельных регионов.

Ограничения, которые необходимо `threadprivate` директива таковы:

- Объект `threadprivate` директива для переменных области видимости файла или области видимости пространства имен должна находиться за пределами любое определение или объявление, а также должно лексически предшествовать все ссылки на все переменные в списке.

- Каждая переменная в *списка переменной* из `threadprivate` директивы в области видимости файла или пространства имен должны ссылаться на объявление переменной на уровне файлов или пространств имен, лексически предшествующей директиве.

- Объект `threadprivate` директива для переменных статические области видимости блока должны располагаться в области этой переменной, а не во вложенной области. Директива должно лексически предшествовать все ссылки на все переменные в списке.

- Каждая переменная в *списка переменной* из `threadprivate` директивы в области видимости блока должны ссылаться на объявление переменной в той же области, лексически предшествующей директиве. Объявление переменной необходимо использовать описатель статических классов хранения.

- Если переменная задается в `threadprivate` директивы в одной записи преобразования, он должен быть указан в `threadprivate` директив в каждую запись преобразования в котором она объявлена.

- Объект `threadprivate` переменной не должны присутствовать в любое предложение, за исключением `copyin`, `copyprivate`, `schedule`, `num_threads`, или `if` предложение.

- Адрес `threadprivate` переменной не константу адреса.

- Объект `threadprivate` переменная не должна иметь неполный тип или ссылочным типом.

- Объект `threadprivate` переменной с типом класса, отличных от POD должны иметь доступный и однозначный копирования конструктору, если он объявляется с помощью инициализатора явной.

В следующем примере показано, как изменение, отображаемый в инициализаторе переменной может привести к непредсказуемому поведению и как избежать этой проблемы, используя это вспомогательный объект и конструктор копии.

```cpp
int x = 1;
T a(x);
const T b_aux(x); /* Capture value of x = 1 */
T b(b_aux);
#pragma omp threadprivate(a, b)

void f(int n) {
   x++;
   #pragma omp parallel for
   /* In each thread:
   * Object a is constructed from x (with value 1 or 2?)
   * Object b is copy-constructed from b_aux
   */
   for (int i=0; i<n; i++) {
      g(a, b); /* Value of a is unspecified. */
   }
}
```

#### <a name="cross-references"></a>Перекрестные ссылки

- [динамические потоки](3-run-time-library-functions.md#317-omp_set_dynamic-function)
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic) переменной среды

### <a name="272-data-sharing-attribute-clauses"></a>2.7.2 данных предложения атрибутов совместного использования

Некоторые директивы принятия предложения, которые позволяют пользователю для управления доступом атрибуты переменных до конца области. Доступом предложения атрибутов применяются только к переменные в лексической экстенте директивы, на которой отображается предложение. Не все из следующих предложений разрешены все директивы. Список предложений, которые являются допустимыми для конкретной директивы описываются с помощью директивы.

Если переменная является видимым, когда параллельный или возникла конструкции совместной работы и переменной не указано в предложении совместного использования атрибута или `threadprivate` директив, затем переменная используется совместно. Статические переменные, объявленные в динамических степень параллельной области являются общими. Кучи, выделенной памяти (например, с помощью `malloc()` на C или C++ или `new` оператор в C++) является общим. (Указатель на эту память, тем не менее, может быть закрытые или Общие.) Переменные, объявленные в динамических степень параллельной области длительность автоматического хранения являются закрытыми.

Большая часть предложения принять *переменной list* аргумент, который является разделенный запятыми список переменных, которые являются видимыми. Если ссылка на переменную в предложении совместного использования данных атрибут имеет тип, производный от шаблона и нет других ссылок на эту переменную в программе, то поведение не определено.

Все переменные, которые отображаются в рамках предложений директивы должен быть видимым. Предложений может повторяться при необходимости, но переменная не может быть указан в более чем одно предложение, за исключением того, что можно указать переменную в обоих `firstprivate` и `lastprivate` предложение.

В следующих разделах описаны предложения атрибутов совместного использования данных:

- [private](#2721-private)
- [firstprivate](#2722-firstprivate)
- [lastprivate](#2723-lastprivate)
- [Общие](#2724-shared)
- [default](#2725-default)
- [reduction](#2726-reduction)
- [copyin](#2727-copyin)
- [copyprivate](#2728-copyprivate)

#### <a name="2721-private"></a>2.7.2.1 private

`private` Предложение объявляет переменные в переменной списке, чтобы быть частной для любого потока в группе. Синтаксис `private` предложение выглядит следующим образом:

```cpp
private(variable-list)
```

Поведение переменной, указанной в `private` предложение выглядит следующим образом. Новый объект с автоматическую длительность хранения выделяется для конструкции. Размер и выравнивание нового объекта определяются тип переменной. Такое распределение происходит один раз для каждого потока в группе и вызывается конструктор по умолчанию для объекта класса, при необходимости; в противном случае начальное значение не определено.  Исходный объект ссылается переменная имеет неопределенное значение после входа к конструкции, не должны быть изменены в области динамической памяти конструкции и имеет неопределенное значение при выходе из конструкции.

В лексической экстенте директив конструкции переменная ссылается на новый частный объект, выделенный поток.

Ограничения, которые необходимо `private` предложение, следующим образом:

- Переменная с типом класса, который указан в `private` предложение должен иметь конструктор по умолчанию, доступный и однозначный.

- Переменная, указанная в `private` не должны иметь предложение `const`-типа с указанием только если есть тип с помощью класса `mutable` член.

- Переменная, указанная в `private` предложение не должен иметь неполный тип или ссылочным типом.

- Переменная, используемая в `reduction` предложении `parallel` директива не может указываться в `private` предложении директивы совместной работы, которая привязывается к параллельной конструкции.

#### <a name="2722-firstprivate"></a>2.7.2.2 firstprivate

`firstprivate` Предложение предоставляет надмножество функциональных возможностях, предоставляемых `private` предложение. Синтаксис `firstprivate` предложение выглядит следующим образом:

```cpp
firstprivate(variable-list)
```

Переменные, указанные в *списка переменной* имеют `private` предложение семантику, как описано в разделе [разделе 2.7.2.1](#2721-private). Инициализации или построения происходит так, как если бы это были сделать один раз на поток, перед выполнением потока конструкции. Для `firstprivate` предложение на параллельные конструкции, начальное значение нового закрытого объекта является исходный объект, который существует непосредственно перед параллельной конструкции для потока, который встречает значение. Для `firstprivate` предложение на конструкции совместной работы, начальное значение нового закрытого объекта для каждого потока, выполняющего конструкции совместной работы является исходный объект, который уже существует до точки во времени, что тот же поток, встречает значение конструкции совместной работы. Кроме того для объектов C++, новый закрытый объект для каждого потока является копии, созданные из исходного объекта.

Ограничения, которые необходимо `firstprivate` предложение, следующим образом:

- Переменная, указанная в `firstprivate` предложение не должен иметь неполный тип или ссылочным типом.

- Переменная с типом класса, который указан как `firstprivate` должны иметь доступный и однозначный копирования конструктору.

- Переменные, являются закрытыми внутри параллельной области или, которые отображаются на `reduction` предложении `parallel` директива не может указываться в `firstprivate` предложении директивы совместной работы, которая привязывается к параллельной конструкции.

#### <a name="2723-lastprivate"></a>2.7.2.3 lastprivate

`lastprivate` Предложение предоставляет надмножество функциональных возможностях, предоставляемых `private` предложение. Синтаксис `lastprivate` предложение выглядит следующим образом:

```cpp
lastprivate(variable-list)
```

Переменные, указанные в *списка переменной* имеют `private` предложение семантику. Когда `lastprivate` присутствует предложение в директиве, определяющая конструкции совместной работы, значение каждого `lastprivate` назначается переменной из последовательно последней итерации связанного цикла или лексически последней директивой раздела, исходный объект в переменной. Переменные, которым не назначены значение с последней итерации `for` или `parallel for`, или лексически последний раздел `sections` или `parallel sections` директивы, имеют неопределенные значения после конструктора. Неназначенные вложенных объектов также иметь неопределенное значение после конструкции.

Ограничения, которые необходимо `lastprivate` предложение, следующим образом:

- Все ограничения для `private` применить.

- Переменная с типом класса, который указан как `lastprivate` должен иметь оператор присваивания копии доступный и однозначный.

- Переменные, являются закрытыми внутри параллельной области или, которые отображаются на `reduction` предложении `parallel` директива не может указываться в `lastprivate` предложении директивы совместной работы, которая привязывается к параллельной конструкции.

#### <a name="2724-shared"></a>2.7.2.4 shared

Это предложение совместно использует переменные, которые отображаются в *списка переменной* среди всех потоков в группе. Все потоки в группе доступ к той же области памяти для `shared` переменные.

Синтаксис `shared` предложение выглядит следующим образом:

```cpp
shared(variable-list)
```

#### <a name="2725-default"></a>2.7.2.5 default

`default` Предложение пользователь может повлиять на совместный доступ к данным, атрибуты переменных. Синтаксис `default` предложение выглядит следующим образом:

```cpp
default(shared | none)
```

Указание `default(shared)` эквивалентен явный список всех видимых в настоящее время переменных `shared` предложение, если только это не `threadprivate` или `const`-полное. В случае отсутствия явно `default` предложение, по умолчанию выполняется так же, как если `default(shared)` были указаны.

Указание `default(none)` требует, что по крайней мере одно из следующих должны соблюдаться для каждой ссылка на переменную в лексическую область параллельной конструкции:

- Переменная явно указан в предложении совместного использования данных атрибута конструкции, содержащему эту ссылку.

- Переменная объявлена в параллельной конструкции.

- Переменная является `threadprivate`.

- Переменная имеет `const`-типа с указанием.

- Переменная является управляющей переменной цикла для `for` цикл, который следует сразу за `for` или `parallel for` директивы и ссылку на переменную появляется внутри цикла.

Задание переменной на `firstprivate`, `lastprivate`, или `reduction` предложении закрытой директиве вызывает неявную ссылку на переменную в охватывающем контексте. Такие неявные ссылки также подлежат указанным выше требованиям.

Только один `default` предложение может быть указано в `parallel` директива.

По умолчанию переменной атрибутов совместного использования данных можно переопределить с помощью `private`, `firstprivate`, `lastprivate`, `reduction`, и `shared` предложения, как показано в следующем примере:

```cpp
#pragma  omp  parallel  for  default(shared)  firstprivate(i)\
   private(x)  private(r)  lastprivate(i)
```

#### <a name="2726-reduction"></a>2.7.2.6 reduction

Это предложение выполняется редукция скалярные переменные, которые отображаются в *списка переменной*, с помощью оператора *op*. Синтаксис `reduction` предложение выглядит следующим образом:

`reduction(` *OP* `:` *переменной list* `)`

Уменьшение, как правило, задаются для инструкции с одним из следующих форм:

- *x* `=` *x* *op* *expr*
- *x* *binop* `=` *expr*
- *x* `=` *expr* *op* *x* (за исключением вычитания)
- *x* `++`
- `++` *x*
- *x* `--`
- `--` *x*

Здесь:

*x*<br/>
Одно из переменные сокращения, указанных в списке.

*переменная list*<br/>
Разделенный запятыми список переменных скалярная редукция.

*expr*<br/>
Выражение скалярного типа, которые не ссылаются на *x*.

*op*<br/>
Не перегруженного оператора, но один из `+`, `*`, `-`, `&`, `^`, `|`, `&&`, или `||`.

*binop*<br/>
Не перегруженного оператора, но один из `+`, `*`, `-`, `&`, `^`, или `|`.

Ниже приведен пример `reduction` предложение:

```cpp
#pragma omp parallel for reduction(+: a, y) reduction(||: am)
for (i=0; i<n; i++) {
   a += b[i];
   y = sum(y, c[i]);
   am = am || b[i] == c[i];
}
```

Как показано в примере, оператор может быть скрыт внутри вызова функции. Пользователю следует соблюдать осторожность, что оператор, указанные в `reduction` предложение на предмет соответствия операции сокращения.

Несмотря на то что правый операнд `||` оператор не имеет побочных эффектов в этом примере, они все разрешены, но следует использовать с осторожностью. В этом контексте побочные эффекты, которое гарантированно не возникающие во время последовательного выполнения цикла может возникнуть при параллельном выполнении. Это различие может возникать, если не определен порядок выполнения итераций.

Оператор, используемый для определения начального значения всех частных переменных, используемый компилятором для сокращения и определить оператор финализации. Явное указание оператора позволяет инструкции сокращения, выходящих за пределы области лексические конструкции. Любое количество `reduction` предложения могут быть указаны в директиве, но переменную может отображаться в одном `reduction` предложение для этой директивы.

Локальную копию каждой переменной в *переменной list* создаются по одному для каждого потока, как если `private` было использовано предложение. Закрытой копии инициализируется в соответствии с оператора (см. ниже).

В конце области, для которого `reduction` указано предложение, исходный объект будет обновлена с учетом результат объединения свое исходное значение с конечное значение каждого из собственных копий, с помощью указанного оператора. Сокращение операторы имеют все ассоциативность (за исключением вычитание), а компилятор может свободно повторное связывание вычисления конечное значение. (Частичные результаты вычитания уменьшение добавляются для формирования конечного значения).

Значение для исходного объекта становится неопределенным, когда первый поток достигает содержащего предложение и сохраняет данный тип до завершения вычисления сокращения.  Как правило выполняется вычисление будет завершен, в конце конструкции; Тем не менее если `reduction` предложение используется в конструкции, к которому `nowait` является также применяется значение исходного объекта остается неопределенным пока не будет выполнена синхронизация барьера чтобы убедиться, что все потоки завершили `reduction`предложение.

Ниже перечислены операторы, которые являются допустимыми и их значения каноническую инициализации. Значение фактического инициализации будет совместимым с типом данных переменной сокращения.

|Оператор|Инициализация|
|--------------|--------------------|
|`+`|0|
|`*`|1|
|`-`|0|
|`&`|~0|
|`|`|0|
|`^`|0|
|`&&`|1|
|`||`|0|

Ограничения, которые необходимо `reduction` предложение, следующим образом:

- Тип переменных в `reduction` предложение должно быть допустимым для оператором редукции, за исключением того, что типы указателей и ссылочные типы никогда не разрешены.

- Переменная, которая указана в `reduction` предложение не должно быть `const`-полное.

- Переменные, являются закрытыми внутри параллельной области или, которые отображаются на `reduction` предложении `parallel` директива не может указываться в `reduction` предложении директивы совместной работы, которая привязывается к параллельной конструкции.

   ```cpp
   #pragma omp parallel private(y)
   { /* ERROR - private variable y cannot be specified
                in a reduction clause */
      #pragma omp for reduction(+: y)
      for (i=0; i<n; i++)
         y += b[i];
   }

   /* ERROR - variable x cannot be specified in both
              a shared and a reduction clause */
   #pragma omp parallel for shared(x) reduction(+: x)
   ```

#### <a name="2727-copyin"></a>2.7.2.7 copyin

`copyin` Предложение предоставляет механизм для назначения то же значение, чтобы `threadprivate` переменные для каждого потока выполнения параллельной области группы. Для каждой переменной, указанной в `copyin` предложение, значение переменной в главный поток команды для копирования, как если назначение в частные для потока копии в начале параллельной области. Синтаксис `copyin` предложение выглядит следующим образом:

```cpp

copyin(
variable-list
)
```

Ограничения, которые необходимо `copyin` предложение, следующим образом:

- Переменная, которая указана в `copyin` предложение необходимо иметь доступный и однозначный оператор присваивания копии.

- Переменная, которая указана в `copyin` предложение должно быть `threadprivate` переменной.

#### <a name="2728-copyprivate"></a>2.7.2.8 copyprivate

`copyprivate` Предложение предоставляет механизм использовать частную переменную для рассылки значение из одного членом команды с другими элементами. Это альтернатива использованию общей переменной для значения, когда предоставляя общей переменной будет трудно (например, в рекурсии, требуя отдельную переменную на каждом уровне). `copyprivate` Предложение может находиться только в `single` директива.

Синтаксис `copyprivate` предложение выглядит следующим образом:

```cpp

copyprivate(
variable-list
)
```

Последствия `copyprivate` предложение на переменные в своем списке переменной происходит после выполнения структурированном блоке, связанные с `single` создать, и до каких-либо потоков в группе осталось барьера в конце конструкции. Затем в других потоков в группе, для каждой переменной в *списка переменной*, эта переменная становится определенным (как в результате присваивания) со значением соответствующего структурной переменной в потоке, конструкция была выполнена блок.

Ограничения для `copyprivate` предложение, следующим образом:

- Переменная, которая указана в `copyprivate` предложение не должны присутствовать в `private` или `firstprivate` предложение для того же `single` директива.

- Если `single` директиву `copyprivate` все переменные предложение встречается в динамических степень параллельной области, указанной в `copyprivate` предложение должна быть частной в охватывающем контексте.

- Переменная, которая указана в `copyprivate` предложение должен иметь оператор присваивания доступны однозначный копирования.

## <a name="28-directive-binding"></a>2.8 привязка директив

Динамическая привязка директив должен соответствовать следующим правилам:

- `for`, `sections`, `single`, `master`, И `barrier` директивы привязки к динамически включающего `parallel`, если таковой имеется, независимо от значения любого `if` предложения, которые могут присутствовать на, директива. Если нет параллельной области выполняется в данный момент, директивы выполняются командой, состоящие только главного потока.

- `ordered` Директива привязывается к динамически включающего `for`.

- `atomic` Директива обеспечивает монопольный доступ по отношению к `atomic` директивы во всех потоках, не только текущей команды.

- `critical` Директива обеспечивает монопольный доступ по отношению к `critical` директивы во всех потоках, не только текущей команды.

- Директива можно никогда не привязать к любой директивой за пределами ближайшим динамически заключения `parallel`.

## <a name="29-directive-nesting"></a>2.9 директива nesting

Динамические вложения директив должен соответствовать следующим правилам:

- Объект `parallel` директив динамически внутри другого `parallel` логически устанавливает новой команды, который состоит из всех потоков, если вложенные параллелизма включен.

- `for`, `sections`, и `single` директивы, которые привязаны к тому же `parallel` запрещено быть вложенными друг в друга.

- `critical` директивы с тем же именем не может быть вложенными друг в друга. Обратите внимание на то, что это ограничение не недостаточно для предотвращения взаимоблокировок.

- `for`, `sections`, и `single` директивы не допускаются в динамических экстент `critical`, `ordered`, и `master` регионов, если привязка директив на тот же `parallel` как области.

- `barrier` директивы не допускаются в динамических экстент `for`, `ordered`, `sections`, `single`, `master`, и `critical` регионов, если привязка директив на тот же `parallel` как области.

- `master` директивы не допускаются в динамических экстент `for`, `sections`, и `single` директивы Если `master` директивы привязать к тому же `parallel` как директив совместной работы.

- `ordered` директивы запрещено в динамических экстент `critical` регионов, если привязка директив на тот же `parallel` как области.

- Все директивы, которое разрешено при выполнении динамически внутри параллельной области разрешен также в том случае, когда выполняются за пределами параллельной области. При выполнении динамически вне пользовательской параллельной области директивы выполняется командой, состоящие только главного потока.
