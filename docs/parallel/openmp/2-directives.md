---
title: 2. Директивы
ms.date: 01/18/2019
ms.assetid: d1a69374-6c03-45fb-8c86-e91cea8adae8
ms.openlocfilehash: c3aadcf34e013c66dec81ca4b09dce4144294ac3
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87228405"
---
# <a name="2-directives"></a>2. Директивы

Директивы основаны на `#pragma` директивах, определенных в стандартах C и C++.  Компиляторы, поддерживающие API OpenMP C и C++, включают параметр командной строки, который активирует и позволяет интерпретировать все директивы компилятора OpenMP.

## <a name="21-directive-format"></a>формат директивы 2,1

Синтаксис директивы OpenMP формально определяется грамматикой в [приложении C](c-openmp-c-and-cpp-grammar.md)и имеет следующий вид:

```cpp
#pragma omp directive-name  [clause[ [,] clause]...] new-line
```

Каждая директива начинается с `#pragma omp` , чтобы уменьшить вероятность конфликта с другими директивами pragma (без OpenMP или нестандартными расширениями поставщика в OpenMP) с теми же именами. Оставшаяся часть директивы соответствует соглашениям стандартов C и C++ для директив компилятора. В частности, пробелы можно использовать до и после `#` , а иногда пробелы должны использоваться для разделения слов в директиве. Токены предварительной обработки, приведенные после, `#pragma omp` подлежат замене макросов.

Директивы чувствительны к регистру. Порядок, в котором предложения отображаются в директивах, не имеет значения. Предложения в директивах могут повторяться по мере необходимости в соответствии с ограничениями, перечисленными в описании каждого предложения. Если в предложении присутствует предложение *variable-List* , оно должно указывать только переменные. Для каждой директивы можно указать только одно *имя директивы* .  Например, следующая директива не допускается:

```cpp
/* ERROR - multiple directive names not allowed */
#pragma omp parallel barrier
```

Директива OpenMP применяется не более чем к одной инструкции, которая должна быть структурированным блоком.

## <a name="22-conditional-compilation"></a>2,2. Условная компиляция

`_OPENMP`Имя макроса определяется реализациями, совместимыми с OpenMP, в виде десятичной константы *иииимм*, которая будет содержать год и месяц утвержденной спецификации. Этот макрос не должен быть темой `#define` `#undef` директивы или предварительной обработки.

```cpp
#ifdef _OPENMP
iam = omp_get_thread_num() + index;
#endif
```

Если поставщики определяют расширения для OpenMP, они могут указывать дополнительные предопределенные макросы.

## <a name="23-parallel-construct"></a>2,3. Параллельная конструкция

Следующая директива определяет параллельную область, которая является областью программы, которая должна выполняться многими потоками параллельно. Эта директива является фундаментальной конструкцией, которая начинает параллельное выполнение.

```cpp
#pragma omp parallel [clause[ [, ]clause] ...] new-line   structured-block
```

*Предложение* является одним из следующих:

- `if(`*скалярное выражение*`)`
- `private(`*список переменных*`)`
- `firstprivate(`*список переменных*`)`
- `default(shared | none)`
- `shared(`*список переменных*`)`
- `copyin(`*список переменных*`)`
- `reduction(`*оператор* `:` *список переменных*  `)`
- `num_threads(`*выражение типа Integer*`)`

Когда поток получается в параллельную конструкцию, группа потоков создается, если выполняется один из следующих случаев.

- `if`Предложение отсутствует.
- `if`Результатом вычисления выражения является ненулевое значение.

Этот поток превращается в главный поток команды с номером потока 0, а все потоки в группе, включая главный поток, выполняют этот регион параллельно. Если значение `if` выражения равно нулю, то область сериализуется.

Чтобы определить количество запрошенных потоков, следующие правила будут учитываться по порядку. Будет применено первое правило, условие которого соблюдается:

1. Если `num_threads` предложение имеется, значение целочисленного выражения равно количеству запрошенных потоков.

1. Если `omp_set_num_threads` была вызвана функция библиотеки, то значение аргумента в последнем выполненном вызове — это число запрошенных потоков.

1. Если переменная среды `OMP_NUM_THREADS` определена, значение этой переменной среды равно количеству запрошенных потоков.

1. Если ни один из вышеперечисленных методов не используется, то число запрошенных потоков определяется реализацией.

Если `num_threads` предложение имеется, оно заменяет количество потоков, запрошенных `omp_set_num_threads` функцией библиотеки, или `OMP_NUM_THREADS` переменной среды только для параллельной области, к которой он применяется. Более поздние области параллельных регионов не затрагиваются.

Число потоков, выполняющих параллельную область, также зависит от того, включена ли Динамическая коррекция числа потоков. Если динамическая корректировка отключена, запрошенное число потоков будет выполнять параллельную область. Если включена динамическая настройка, запрошенное число потоков — это максимальное число потоков, которые могут выполнять параллельную область.

Если во время динамической корректировки количества потоков обнаружена параллельная область, а число потоков, запрошенных для параллельной области, превышает число, которое может предоставить система времени выполнения, то поведение программы определяется реализацией. Реализация может, например, прерывать выполнение программы или выполнять сериализацию параллельной области.

`omp_set_dynamic`Библиотечную функцию и `OMP_DYNAMIC` переменную среды можно использовать для включения и отключения динамической корректировки числа потоков.

Число физических процессоров, на которых фактически размещены потоки в любой конкретный момент, определяется реализацией. После создания число потоков в группе остается постоянным в течение этой параллельной области. Его можно изменить либо явным образом пользователем, либо автоматически системой времени выполнения из одной параллельной области в другую.

Инструкции, содержащиеся в динамической экстенте параллельной области, выполняются каждым потоком, и каждый поток может выполнить путь к операторам, отличным от других потоков. Директивы, обнаруженные вне лексического экстента параллельной области, называются потерянными директивами.

В конце параллельной области есть неявный барьер. Только главный поток команды продолжит выполнение в конце параллельной области.

Если поток в группе, в которой выполняется параллельная область, встречает другую параллельную конструкцию, он создает новую команду и станет главной группой этой новой команды. Вложенные параллельные области сериализуются по умолчанию. В результате по умолчанию вложенная параллельная область выполняется командой, состоящей из одного потока. Поведение по умолчанию можно изменить с помощью функции библиотеки времени выполнения `omp_set_nested` или переменной среды `OMP_NESTED` . Однако число потоков в команде, выполняющем вложенную параллельную область, определяется реализацией.

К `parallel` директиве применяются следующие ограничения.

- В `if` директиве может присутствовать только одно предложение.

- Он не указывает, выполняются ли какие либо побочные эффекты в выражении if или `num_threads` выражении.

- `throw`Выполнение внутри параллельной области должно привести к возобновлению выполнения в динамической области того же структурированного блока и должно быть перехвачено тем же потоком, который выдал исключение.

- `num_threads`В директиве может присутствовать только одно предложение. `num_threads`Выражение вычисляется вне контекста параллельной области и должно иметь положительное целое значение.

- Порядок вычисления `if` `num_threads` предложений и не определен.

### <a name="cross-references"></a>Перекрестные ссылки

- `private``firstprivate`предложения,, `default` , `shared` , `copyin` и `reduction` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))
- Переменная среды [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads)
- функция библиотеки [omp_set_dynamic](3-run-time-library-functions.md#317-omp_set_dynamic-function)
- Переменная среды [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)
- Функция [omp_set_nested](3-run-time-library-functions.md#319-omp_set_nested-function)
- Переменная среды [OMP_NESTED](4-environment-variables.md#44-omp_nested)
- функция библиотеки [omp_set_num_threads](3-run-time-library-functions.md#311-omp_set_num_threads-function)

## <a name="24-work-sharing-constructs"></a>2,4 конструкции совместной работы

Конструкция совместного использования распределяет выполнение соответствующей инструкции среди членов команды, в которой он встречается. Директивы совместного использования не запускают новые потоки, и нет подразумеваемого барьера на входе в конструкцию совместной работы.

Последовательность конструкций и директив совместного использования `barrier` должны быть одинаковыми для каждого потока в группе.

OpenMP определяет следующие конструкции совместного использования, и эти конструкции описаны в следующих разделах:

- [для](#241-for-construct) директивы
- Директива [Sections](#242-sections-construct)
- [одна](#243-single-construct) директива

### <a name="241-for-construct"></a>2.4.1 для конструкции

`for`Директива определяет итеративную конструкцию совместной работы, которая указывает, что итерации связанного цикла будут выполняться параллельно. Итерации `for` цикла распределяются между потоками, которые уже существуют в группе, выполняющей параллельную конструкцию, к которой она привязана. Синтаксис `for` конструкции выглядит следующим образом:

```cpp
#pragma omp for [clause[[,] clause] ... ] new-line for-loop
```

Предложение является одним из следующих:

- `private(`*список переменных*`)`
- `firstprivate(`*список переменных*`)`
- `lastprivate(`*список переменных*`)`
- `reduction(`*оператор* `:` *список переменных*`)`
- `ordered`
- `schedule(`*Kind* [ `,` *chunk_size*]`)`
- `nowait`

`for`Директива размещает ограничения на структуру соответствующего `for` цикла. В частности, соответствующий `for` цикл должен иметь каноническую форму:

`for (`*init-expr* `;` *var-логическая операция b* `;` *incr-expr*`)`

*init-expr*<br/>
Это может быть:

- *var*  =  *фунтов*
- *integer-тип var*  =  *фунтов*

*incr-expr*<br/>
Это может быть:

- `++`*var*
- *var*`++`
- `--`*var*
- *var*`--`
- *var* `+=` *incr*
- *var* `-=` *incr*
- *var* `=` *var* `+` *incr*
- *var* `=` *incr* `+` *var*
- *var* `=` *var* `-` *incr*

*var*<br/>
Целочисленная переменная со знаком. Если эта переменная в противном случае будет совместно использоваться, она неявно становится закрытой в течение времени `for` . Не изменяйте эту переменную в теле `for` инструкции. Если переменная не указана `lastprivate` , ее значение после цикла будет неопределенным.

*логическая операция*<br/>
Это может быть:

- `<`
- `<=`
- `>`
- `>=`

*фунтов*, *b*и *incr*<br>
Инвариантные целочисленные выражения цикла. Во время оценки этих выражений синхронизация не выполняется, поэтому все вычисленные побочные эффекты приводят к непредсказуемым результатам.

Каноническая форма позволяет вычислять число итераций цикла при входе в цикл. Это вычисление выполняется с использованием значений в типе *var*после целочисленных акций. В частности, если значение *b* `-` *фунтов* `+` *incr* не может быть представлено в этом типе, результат будет неопределенным. Кроме того, если *логическая операция* имеет значение `<` или `<=` , то *incr-expr* должен привести к увеличению *var* при каждой итерации цикла.   Если оператор *Logical-Op* имеет значение `>` или `>=` , то *incr-expr* должен привести к меньшему числу элементов *var* при каждой итерации цикла.

`schedule`Предложение указывает, как итерации `for` цикла делятся между потоками команды. Правильность программы не должна зависеть от того, какой поток выполняет определенную итерацию. Значение *chunk_size*, если оно указано, должно быть инвариантным целочисленным выражением цикла с положительным значением. Во время вычисления этого выражения синхронизация не выполняется, поэтому все вычисленные побочные эффекты приводят к непредсказуемым результатам. *Тип* расписания может принимать одно из следующих значений:

Таблица 2-1: `schedule` значения *типа* предложения

|||
|-|-|
|static|Если `schedule(static,` *chunk_size* `)` указано chunk_size, итерации делятся на фрагменты размера, указанного в *chunk_size*. Фрагменты статически назначаются потокам в группе с циклическим перебором в порядке номера потока. Если *chunk_size* не указано, пространство итерации делится на фрагменты, размер которых приблизительно равен размеру, с одним блоком, назначенным каждому потоку.|
|Динамический|Если `schedule(dynamic,` *chunk_size* `)` указано chunk_size, итерации делятся на ряд фрагментов, каждый из которых содержит итерации *chunk_size* . Каждый блок назначается потоку, ожидающему назначения. Поток выполняет фрагмент итераций, а затем ожидает следующего назначения, пока не останется назначенный фрагмент. Последний блок, который необходимо назначить, может иметь меньшее количество итераций. Если *chunk_size* не указано, по умолчанию используется значение 1.|
|Интерактивное|Если `schedule(guided,` *chunk_size* `)` указано chunk_size, итерации назначаются потокам в блоках с уменьшением размеров. Когда поток завершает назначенный ему блок итераций, ему динамически назначается другой блок, пока не останется ничего. Для *chunk_size* 1 Размер каждого фрагмента составляет примерно столько неназначенных итераций, деленное на число потоков. Эти размеры уменьшаются почти экспоненциально до 1. Для *chunk_size* со значением *k* больше 1, размеры уменьшаются почти экспоненциально до *k*, за исключением того, что в последнем фрагменте может быть меньше *k* итераций. Если *chunk_size* не указано, по умолчанию используется значение 1.|
|исполняющая среда|Если `schedule(runtime)` указан параметр, решение о планировании откладывается до времени выполнения. *Тип* и размер расписания для фрагментов можно выбрать во время выполнения, задав переменную среды `OMP_SCHEDULE` . Если эта переменная среды не задана, результирующее расписание определяется реализацией. Если `schedule(runtime)` указан, *chunk_size* не должно быть указано.|

При отсутствии явно определенного `schedule` предложения значение по умолчанию `schedule` определяется реализацией.

Программа, совместимая с OpenMP, не должна полагаться на определенное расписание для правильного выполнения. Программа не должна полагаться на *тип* расписания в соответствии с описанным выше описанием, поскольку возможны вариации в реализациях одного и того же *типа* расписания для разных компиляторов. Описания можно использовать для выбора расписания, соответствующего конкретной ситуации.

`ordered`Предложение должно присутствовать, если `ordered` директивы привязываются к `for` конструкции.

В конце конструкции имеется неявный барьер, `for` Если `nowait` не указано предложение.

К `for` директиве применяются следующие ограничения.

- `for`Цикл должен быть структурированным блоком, и, Кроме того, его выполнение не должно завершаться **`break`** оператором.

- Значения выражений управления циклом `for` цикла, связанного с `for` директивой, должны быть одинаковыми для всех потоков в группе.

- `for`Переменная итерации цикла должна иметь тип целого числа со знаком.

- `schedule`В директиве может присутствовать только одно предложение `for` .

- `ordered`В директиве может присутствовать только одно предложение `for` .

- `nowait`В директиве может присутствовать только одно предложение `for` .

- Он не указывается, если или как часто происходят любые побочные эффекты в выражениях *chunk_size*, *фунтов*, *b*или *incr* .

- Значение выражения *chunk_size* должно быть одинаковым для всех потоков в команде.

#### <a name="cross-references"></a>Перекрестные ссылки

- `private``firstprivate`предложения,, `lastprivate` и `reduction` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))
- Переменная среды [OMP_SCHEDULE](4-environment-variables.md#41-omp_schedule)
- [упорядоченная](#266-ordered-construct) конструкция
- предложение [Schedule](d-using-the-schedule-clause.md)

### <a name="242-sections-construct"></a>Конструкция разделов 2.4.2

`sections`Директива определяет неитеративную конструкцию совместной работы, которая указывает набор конструкций, которые должны быть распределены между потоками в группе. Каждый раздел запускается потоком в группе один раз. Синтаксис `sections` директивы выглядит следующим образом:

```cpp
#pragma omp sections [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block ]
...
}
```

Предложение является одним из следующих:

- `private(`*список переменных*`)`
- `firstprivate(`*список переменных*`)`
- `lastprivate(`*список переменных*`)`
- `reduction(`*оператор* `:` *список переменных*  `)`
- `nowait`

Каждому разделу предшествует `section` директива, хотя `section` директива является необязательной для первого раздела. `section`Директивы должны находиться в лексической области `sections` директивы. Неявный барьер в конце `sections` конструкции, если `nowait` не указан.

К `sections` директиве применяются следующие ограничения.

- `section`Директива не должна находиться за пределами лексического экстента `sections` директивы.

- `nowait`В директиве может присутствовать только одно предложение `sections` .

#### <a name="cross-references"></a>Перекрестные ссылки

- `private``firstprivate`предложения,, `lastprivate` и `reduction` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))

### <a name="243-single-construct"></a>2.4.3, единая конструкция

`single`Директива определяет конструкцию, которая указывает, что связанный структурированный блок выполняется только одним потоком в группе (не обязательно главным потоком). Синтаксис `single` директивы выглядит следующим образом:

```cpp
#pragma omp single [clause[[,] clause] ...] new-linestructured-block
```

Предложение является одним из следующих:

- `private(`*список переменных*`)`
- `firstprivate(`*список переменных*`)`
- `copyprivate(`*список переменных*`)`
- `nowait`

Существует неявное барьер после `single` конструкции, если `nowait` не указано предложение.

К `single` директиве применяются следующие ограничения.

- `nowait`В директиве может присутствовать только одно предложение `single` .
- `copyprivate`Предложение не должно использоваться с `nowait` предложением.

#### <a name="cross-references"></a>Перекрестные ссылки

- `private``firstprivate`предложения, и `copyprivate` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))

## <a name="25-combined-parallel-work-sharing-constructs"></a>2,5. Объединенные конструкции параллельной совместной работы

Объединенные параллельные конструкции совместной работы — это сочетания клавиш для указания параллельной области, которая имеет только одну конструкцию совместного использования. Семантика этих директив аналогична явному заданию `parallel` директивы, за которой следует одна конструкция совместного использования.

В следующих разделах описаны Объединенные конструкции параллельного совместного использования.

- [параллельная](#251-parallel-for-construct) директива for
- Директива [Parallel Sections](#252-parallel-sections-construct)

### <a name="251-parallel-for-construct"></a>2.5.1 параллельно для конструкции

`parallel for`Директива является ярлыком для `parallel` области, содержащей только одну `for` директиву. Синтаксис `parallel for` директивы выглядит следующим образом:

```cpp
#pragma omp parallel for [clause[[,] clause] ...] new-linefor-loop
```

Эта директива разрешает все предложения `parallel` директивы и `for` директивы, кроме `nowait` предложения, с идентичными значениями и ограничениями. Семантика аналогична явному указанию `parallel` директивы, за которой следует `for` директива.

#### <a name="cross-references"></a>Перекрестные ссылки

- Директива [Parallel](#23-parallel-construct)
- [для](#241-for-construct) директивы
- [Предложения атрибутов данных](#272-data-sharing-attribute-clauses)

### <a name="252-parallel-sections-construct"></a>Конструкция параллельных секций 2.5.2

`parallel sections`Директива предоставляет форму ярлыка для указания `parallel` области, которая содержит только одну `sections` директиву. Семантика аналогична явному указанию `parallel` директивы, за которой следует `sections` директива. Синтаксис `parallel sections` директивы выглядит следующим образом:

```cpp
#pragma omp parallel sections  [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block  ]
   ...
}
```

*Предложение* может быть одним из предложений, принимаемых `parallel` `sections` директивами и, за исключением `nowait` предложения.

#### <a name="cross-references"></a>Перекрестные ссылки

- Директива [Parallel](#23-parallel-construct)
- Директива [Sections](#242-sections-construct)

## <a name="26-master-and-synchronization-directives"></a>2,6. Главные и синхронизирующие директивы

В следующих разделах описывается следующее:

- [Главная](#261-master-construct) конструкция
- [критическая](#262-critical-construct) конструкция
- Директива [барьера](#263-barrier-directive)
- [атомарная](#264-atomic-construct) конструкция
- [flush](#265-flush-directive) , директива
- [упорядоченная](#266-ordered-construct) конструкция

### <a name="261-master-construct"></a>Главная конструкция 2.6.1

`master`Директива определяет конструкцию, которая задает структурированный блок, который выполняется главным потоком команды. Синтаксис `master` директивы выглядит следующим образом:

```cpp
#pragma omp master new-linestructured-block
```

Другие потоки в команде не выполняют связанный структурированный блок. Нет подразумеваемого барьера для входа или выхода из главной конструкции.

### <a name="262-critical-construct"></a>Критическая конструкция 2.6.2

`critical`Директива определяет конструкцию, которая запрещает выполнение связанного структурированного блока в один поток за раз. Синтаксис `critical` директивы выглядит следующим образом:

```cpp
#pragma omp critical [(name)]  new-linestructured-block
```

Для поиска критической области можно использовать необязательное *имя* . Идентификаторы, используемые для идентификации критической области, имеют внешнюю компоновку и находятся в пространстве имен, отделенном от пространств имен, используемых метками, тегами, элементами и обычными идентификаторами.

Поток ожидает в начале критического региона до тех пор, пока другой поток не выполнит критический регион (в любом месте программы) с тем же именем. Все неименованные `critical` директивы сопоставляются с одним и тем же неопределенным именем.

### <a name="263-barrier-directive"></a>Директива 2.6.3 барьера

`barrier`Директива синхронизирует все потоки в команде. При обнаружении каждый поток в группе ожидает, пока все остальные не достигают этого момента. Синтаксис `barrier` директивы выглядит следующим образом:

```cpp
#pragma omp barrier new-line
```

После того как все потоки в группе столкнулись с барьером, каждый поток в команде начинает выполнять инструкции после директивы барьера в параллельном режиме. Так как `barrier` директива не содержит инструкции языка C в составе своего синтаксиса, существуют некоторые ограничения на его размещение в программе. Дополнительные сведения о формальной грамматике см. в [приложении в](c-openmp-c-and-cpp-grammar.md). Эти ограничения показаны в приведенном ниже примере.

```cpp
/* ERROR - The barrier directive cannot be the immediate
*          substatement of an if statement
*/
if (x!=0)
   #pragma omp barrier
...

/* OK - The barrier directive is enclosed in a
*      compound statement.
*/
if (x!=0) {
   #pragma omp barrier
}
```

### <a name="264-atomic-construct"></a>2.6.4 Атомарная конструкция

`atomic`Директива гарантирует, что определенное место в памяти будет обновляться атомарно, вместо того чтобы предоставлять его возможности для нескольких одновременных потоков записи. Синтаксис `atomic` директивы выглядит следующим образом:

```cpp
#pragma omp atomic new-lineexpression-stmt
```

Оператор выражения должен иметь одну из следующих форм:

- *биноп x* `=` *выражение*
- *x*`++`
- `++` *x*
- *x*`--`
- `--` *x*

В предыдущих выражениях:

- *x* является выражением lvalue со скалярным типом.

- *expr* является выражением с скалярным типом и не ссылается на объект, обозначенный *x*.

- *биноп* не является перегруженным оператором и является одним из `+` , `*` , `-` ,,, `/` `&` `^` , `|` , `<<` или `>>` .

Несмотря на то, что реализация определяет, заменяют ли все директивы директивами с `atomic` `critical` одинаковыми уникальными *именами*, `atomic` Директива допускает лучшую оптимизацию. Для выполнения атомарного обновления с минимальными издержками доступны часто используемые инструкции по оборудованию.

Атомарными являются только нагрузка и хранение объекта, обозначенного *x* . Вычисление *выражения expr* не является атомарным. Чтобы избежать конкуренции, все обновления расположения в параллельном режиме должны быть защищены с помощью `atomic` директивы, за исключением тех случаев, когда известно, что они свободны от состояний гонки.

К `atomic` директиве применяются следующие ограничения.

- Все атомарные ссылки на расположение хранилища x по всей программе должны иметь совместимый тип.

#### <a name="examples"></a>Примеры

```cpp
extern float a[], *p = a, b;
/* Protect against races among multiple updates. */
#pragma omp atomic
a[index[i]] += b;
/* Protect against races with updates through a. */
#pragma omp atomic
p[i] -= 1.0f;

extern union {int n; float x;} u;
/* ERROR - References through incompatible types. */
#pragma omp atomic
u.n++;
#pragma omp atomic
u.x -= 1.0f;
```

### <a name="265-flush-directive"></a>2.6.5. Директива flush

`flush`Директива (явная или подразумеваемая) указывает точку последовательности «перекрестных потоков», в которой требуется реализация, чтобы гарантировать, что все потоки в команде будут иметь единообразное представление определенных объектов (указанных ниже) в памяти. Это означает, что предыдущие вычисления выражений, ссылающихся на эти объекты, завершаются, и последующие вычисления еще не началися. Например, компиляторы должны восстанавливать значения объектов из регистров в память, а оборудование может потребовать записи буферов записи в память и повторной загрузки значений объектов из памяти.

Синтаксис `flush` директивы выглядит следующим образом:

```cpp
#pragma omp flush [(variable-list)]  new-line
```

Если объекты, требующие синхронизации, могут быть назначены переменными, то эти переменные могут быть указаны в необязательном *переменном списке*. Если указатель имеется в *переменной-списке*, сам указатель очищается, а не объект, на который ссылается указатель.

`flush`Директива без *переменной-List* синхронизирует все общие объекты, за исключением недоступных объектов с автоматическим длительностью хранения. (Это может привести к дополнительным издержкам, чем `flush` с помощью *переменного списка*.) `flush`Директива без *переменной-List* подразумевается для следующих директив:

- `barrier`
- При входе и выходе из`critical`
- При входе и выходе из`ordered`
- При входе и выходе из`parallel`
- При выходе из`for`
- При выходе из`sections`
- При выходе из`single`
- При входе и выходе из`parallel for`
- При входе и выходе из`parallel sections`

Директива не подразумевается, если `nowait` имеется предложение. Следует отметить, что `flush` директива не подразумевается для следующих элементов:

- При входе в`for`
- При входе или выходе из`master`
- При входе в`sections`
- При входе в`single`

Ссылка, обращающаяся к значению объекта с постоянным типом, будет работать так, как если бы существовала `flush` директива, указывающая этот объект в предыдущей точке следования. Ссылка, изменяющая значение объекта с постоянным типом, ведет себя так, как если бы существовала `flush` директива, указывающая этот объект в последующей точке последовательности.

Так как `flush` директива не содержит инструкции языка C в составе своего синтаксиса, существуют некоторые ограничения на его размещение в программе. Дополнительные сведения о формальной грамматике см. в [приложении в](c-openmp-c-and-cpp-grammar.md). Эти ограничения показаны в приведенном ниже примере.

```cpp
/* ERROR - The flush directive cannot be the immediate
*          substatement of an if statement.
*/
if (x!=0)
   #pragma omp flush (x)
...

/* OK - The flush directive is enclosed in a
*      compound statement
*/
if (x!=0) {
   #pragma omp flush (x)
}
```

К `flush` директиве применяются следующие ограничения.

- Переменная, указанная в `flush` директиве, не должна иметь ссылочный тип.

### <a name="266-ordered-construct"></a>2.6.6 упорядоченная конструкция

Структурированный блок, `ordered` который следует за директивой, выполняется в том порядке, в котором итерации будут выполняться в последовательном цикле. Синтаксис `ordered` директивы выглядит следующим образом:

```cpp
#pragma omp ordered new-linestructured-block
```

`ordered`Директива должна находиться в динамической области `for` `parallel for` конструкции или. `for` `parallel for` Директива или, к которой `ordered` привязываются конструкции, должна иметь `ordered` предложение, как описано в [разделе 2.4.1](#241-for-construct). При выполнении `for` `parallel for` конструкции или с `ordered` предложением `ordered` конструкции выполняются строго в том порядке, в котором они будут выполняться при последовательном выполнении цикла.

К `ordered` директиве применяются следующие ограничения.

- Итерация цикла с `for` конструкцией не должна выполнять одну и ту же упорядоченную директиву более одного раза и не должна выполнять более одной `ordered` директивы.

## <a name="27-data-environment"></a>Среда данных 2,7

В этом разделе представлена директива и несколько предложений для управления средой данных во время выполнения параллельных регионов, как показано ниже.

- Директива [threadprivate](#271-threadprivate-directive) предназначена для того, чтобы переменные области действия файла, области видимости пространства имен или статических переменных областей видимости блока были локальными для потока.

- Предложения, которые могут быть заданы в директивах для управления общими атрибутами переменных на протяжении параллельных или совместно используемых конструкций, описаны в [разделе 2.7.2](#272-data-sharing-attribute-clauses).

### <a name="271-threadprivate-directive"></a>2.7.1 threadprivate, директива

`threadprivate`Директива делает переменные именованной области файла, области видимости пространства имен или статической области видимости блока, указанные в *переменной-List* Private, потоку. *variable-List* — это разделенный запятыми список переменных, которые не имеют неполного типа. Синтаксис `threadprivate` директивы выглядит следующим образом:

```cpp
#pragma omp threadprivate(variable-list) new-line
```

Каждая копия `threadprivate` переменной инициализируется один раз, в неопределенной точке программы до первой ссылки на эту копию и обычным способом (т. е. при инициализации главной копии в последовательном исполнении программы). Обратите внимание, что если на объект имеется ссылка в явном инициализаторе `threadprivate` переменной, а значение объекта изменяется до первой ссылки на копию переменной, то поведение не определено.

Как и любая частная переменная, поток не должен ссылаться на копию объекта другого потока `threadprivate` . Во время последовательного и главного регионов программы ссылки будут указывать на копию объекта в главном потоке.

После выполнения первой параллельной области данные в `threadprivate` объектах гарантированно сохраняются только в том случае, если механизм динамических потоков был отключен и число потоков остается неизменным для всех параллельных регионов.

К `threadprivate` директиве применяются следующие ограничения.

- `threadprivate`Директива для переменных области видимости файла или пространства имен должна находиться за пределами определения или объявления и должна быть лексической перед всеми ссылками на любые из переменных в списке.

- Каждая переменная в *переменной List* `threadprivate` директивы в области файла или пространства имен должна ссылаться на объявление переменной в области файла или пространства имен, которое лексически предшествует директиве.

- `threadprivate`Директива для статических переменных области видимости блока должна находиться в области видимости переменной, а не во вложенной области. Директива должна быть лексической перед всеми ссылками на любые переменные в своем списке.

- Каждая переменная в *переменной-списке* `threadprivate` директивы в области видимости блока должна ссылаться на объявление переменной в той же области, которая лексически предшествует директиве. Объявление переменной должно использовать спецификатор класса хранения static.

- Если переменная указана в `threadprivate` директиве в одной записи преобразования, она должна быть указана в `threadprivate` директиве в каждой единице преобразования, в которой он объявлен.

- `threadprivate`Переменная не должна использоваться в любом предложении, кроме `copyin` предложения,, `copyprivate` `schedule` , `num_threads` или `if` .

- Адрес `threadprivate` переменной не является константой адреса.

- `threadprivate`Переменная не должна иметь неполный тип или ссылочный тип.

- `threadprivate`Переменная с типом класса, отличной от Pod, должна иметь доступный однозначный конструктор копии, если он объявлен с явной инициализатором.

В следующем примере показано, как изменение переменной, отображаемой в инициализаторе, может привести к неопределенному поведению, а также как избежать этой проблемы с помощью вспомогательного объекта и конструктора копии.

```cpp
int x = 1;
T a(x);
const T b_aux(x); /* Capture value of x = 1 */
T b(b_aux);
#pragma omp threadprivate(a, b)

void f(int n) {
   x++;
   #pragma omp parallel for
   /* In each thread:
   * Object a is constructed from x (with value 1 or 2?)
   * Object b is copy-constructed from b_aux
   */
   for (int i=0; i<n; i++) {
      g(a, b); /* Value of a is unspecified. */
   }
}
```

#### <a name="cross-references"></a>Перекрестные ссылки

- [динамические потоки](3-run-time-library-functions.md#317-omp_set_dynamic-function)
- Переменная среды [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)

### <a name="272-data-sharing-attribute-clauses"></a>2.7.2 предложения атрибутов совместного использования данных

Несколько директив принимают предложения, которые позволяют пользователю управлять атрибутами совместного использования переменных в течение региона. Предложения атрибутов совместного использования применяются только к переменным в лексической области директивы, в которой отображается предложение. Не все следующие предложения разрешены для всех директив. Список предложений, допустимых для конкретной директивы, описан в директиве.

Если переменная видна при обнаружении параллельной или совместно используемой конструкции, а переменная не указана в предложении или `threadprivate` директиве общего доступа, переменная является общей. Статические переменные, объявленные внутри динамической экстента параллельной области, являются общими. Память, выделенная в куче (например, использование `malloc()` в C или c++ или **`new`** оператор в c++), является общей. (Указатель на эту память, однако, может быть либо частным, либо общим.) Переменные с автоматической длительностью хранения, объявленной в динамической экстенте параллельной области, являются закрытыми.

Большинство предложений принимают аргумент *переменного списка* , который является списком видимых переменных с разделителями-запятыми. Если переменная, на которую имеется ссылка в предложении атрибута совместного использования данных, имеет тип, производный от шаблона, и в программе нет других ссылок на эту переменную, поведение не определено.

Все переменные, которые отображаются в предложениях директивы, должны быть видимыми. Предложения могут повторяться по мере необходимости, но ни одна переменная не может быть указана в нескольких предложениях, за исключением того, что переменная может быть указана в `firstprivate` `lastprivate` предложении и.

В следующих разделах описаны предложения атрибутов совместного использования данных.

- [private](#2721-private)
- [firstprivate](#2722-firstprivate)
- [lastprivate](#2723-lastprivate)
- [используемый](#2724-shared)
- [default](#2725-default)
- [снизить](#2726-reduction)
- [copyin](#2727-copyin)
- [copyprivate](#2728-copyprivate)

#### <a name="2721-private"></a>2.7.2.1 private

`private`Предложение объявляет переменные в переменной-List как частные для каждого потока в группе. Синтаксис `private` предложения выглядит следующим образом:

```cpp
private(variable-list)
```

Поведение переменной, заданной в `private` предложении, выглядит следующим образом. Для конструкции выделяется новый объект с автоматическим периодом хранения. Размер и выравнивание нового объекта определяются типом переменной. Это выделение выполняется один раз для каждого потока в команде, а при необходимости вызывается конструктор по умолчанию для объекта класса. в противном случае начальное значение является неопределенным.  Исходный объект, на который ссылается переменная, имеет неопределенное значение при входе в конструкцию, не должен изменяться внутри динамической области конструкции и имеет неопределенное значение при выходе из конструкции.

В лексической области конструкции директивы переменная ссылается на новый закрытый объект, выделенный потоком.

К `private` предложению применяются следующие ограничения.

- Переменная с типом класса, заданной в `private` предложении, должна иметь доступный однозначный конструктор по умолчанию.

- Переменная, указанная в `private` предложении, не должна иметь **`const`** квалифицированный тип, если он не имеет типа класса с `mutable` членом.

- Переменная, указанная в `private` предложении, не должна иметь неполный тип или ссылочный тип.

- Переменные, которые отображаются в `reduction` предложении `parallel` директивы, не могут быть указаны в `private` предложении в директиве совместного использования, которая выполняет привязку к параллельной конструкции.

#### <a name="2722-firstprivate"></a>2.7.2.2 firstprivate

`firstprivate`Предложение предоставляет надмножество функциональных возможностей, предоставляемых `private` предложением. Синтаксис `firstprivate` предложения выглядит следующим образом:

```cpp
firstprivate(variable-list)
```

Переменные, указанные в *переменной-List* `private` , имеют семантику предложения, как описано в [разделе 2.7.2.1](#2721-private). Инициализация или конструкция происходит так же, как если бы она была выполнена один раз для каждого потока, до выполнения конструкции в потоке. Для `firstprivate` предложения в параллельной конструкции начальное значение нового закрытого объекта — это значение исходного объекта, существующего непосредственно перед параллельной конструкцией для потока, который его встречает. Для `firstprivate` предложения в конструкции совместного использования, исходное значение нового закрытого объекта для каждого потока, выполняющего конструкцию совместного использования, — это значение исходного объекта, существующего до момента времени, когда тот же поток встречает конструкцию совместного использования. Кроме того, для объектов C++ новый закрытый объект для каждого потока копируется из исходного объекта.

К `firstprivate` предложению применяются следующие ограничения.

- Переменная, указанная в `firstprivate` предложении, не должна иметь неполный тип или ссылочный тип.

- Переменная с типом класса, которая указана как, `firstprivate` должна иметь доступный ненеоднозначный конструктор копии.

- Переменные, которые являются частными в параллельной области или отображаются в `reduction` предложении `parallel` директивы, не могут быть указаны в `firstprivate` предложении в директиве совместного использования, которая выполняет привязку к параллельной конструкции.

#### <a name="2723-lastprivate"></a>2.7.2.3 lastprivate

`lastprivate`Предложение предоставляет надмножество функциональных возможностей, предоставляемых `private` предложением. Синтаксис `lastprivate` предложения выглядит следующим образом:

```cpp
lastprivate(variable-list)
```

Переменные, указанные в параметре *variable-List* , имеют `private` семантику предложения. Когда `lastprivate` предложение появляется в директиве, определяющей конструкцию совместного использования, значение каждой `lastprivate` переменной из последовательно последней итерации связанного цикла или лексического последнего раздела назначается исходному объекту переменной. Переменные, которым не присвоено значение в результате последней итерации `for` или в `parallel for` лексической последней секции `sections` `parallel sections` директивы или, имеют неопределенные значения после конструкции. Неназначенные подобъекты также имеют неопределенное значение после конструкции.

К `lastprivate` предложению применяются следующие ограничения.

- Все ограничения для `private` Apply.

- Переменная с типом класса, которая указана как, `lastprivate` должна иметь доступный ненеоднозначный оператор присваивания копирования.

- Переменные, которые являются частными в параллельной области или отображаются в `reduction` предложении `parallel` директивы, не могут быть указаны в `lastprivate` предложении в директиве совместного использования, которая выполняет привязку к параллельной конструкции.

#### <a name="2724-shared"></a>2.7.2.4 shared

Это предложение использует переменные, которые появляются в *списке переменных* , для всех потоков в группе. Все потоки в группе обращаются к одной и той же области хранения для `shared` переменных.

Синтаксис `shared` предложения выглядит следующим образом:

```cpp
shared(variable-list)
```

#### <a name="2725-default"></a>2.7.2.5 default

`default`Предложение позволяет пользователю влиять на атрибуты совместного использования данных переменных. Синтаксис `default` предложения выглядит следующим образом:

```cpp
default(shared | none)
```

Указание `default(shared)` является эквивалентом явной перечислением каждой видимой переменной в `shared` предложении, если только это значение не `threadprivate` **`const`** определено. При отсутствии явного `default` предложения поведение по умолчанию аналогично `default(shared)` указанному.

Для указания параметра `default(none)` требуется, чтобы хотя бы одно из следующих должно быть истинным для каждой ссылки на переменную в лексической области параллельной конструкции:

- Переменная явно указана в предложении атрибута совместного использования данных конструкции, содержащей ссылку.

- Переменная объявляется в параллельной конструкции.

- Переменная имеет значение `threadprivate` .

- Переменная имеет **`const`** квалифицированный тип.

- Переменная — это Управляющая переменная цикла для `for` цикла, который сразу следует за `for` `parallel for` директивой или, а ссылка на переменную появляется внутри цикла.

Указание переменной в `firstprivate` `lastprivate` `reduction` предложении, или директивы с вложенным оператором приводит к неявной ссылке на переменную в включающем контексте. Такие неявные ссылки также подчиняются указанным выше требованиям.

`default`В директиве может быть указано только одно предложение `parallel` .

Атрибут совместного использования данных переменной по умолчанию может быть переопределен с помощью `private` предложений, `firstprivate` , `lastprivate` , `reduction` и `shared` , как показано в следующем примере:

```cpp
#pragma  omp  parallel  for  default(shared)  firstprivate(i)\
   private(x)  private(r)  lastprivate(i)
```

#### <a name="2726-reduction"></a>2.7.2.6 reduction

Это предложение выполняет сокращение скалярных переменных, которые отображаются в *переменной List*, с оператором *Op*. Синтаксис `reduction` предложения выглядит следующим образом:

`reduction(`*Операция* `:` *список переменных*`)`

Сокращение обычно указывается для инструкции с одной из следующих форм:

- *x* `=` *x* *Op* *expr*
- *выражение x* *биноп* `=` *expr*
- *x* `=` *expr* *Op* *x* (за исключением вычитания)
- *x*`++`
- `++` *x*
- *x*`--`
- `--` *x*

где:

*x*<br/>
Одна из переменных сокращения, указанных в списке.

*список переменных*<br/>
Разделенный запятыми список переменных сокращения скаляра.

*expr*<br/>
Выражение со скалярным типом, которое не ссылается на *x*.

*операцион*<br/>
Не перегруженный оператор, но один из,,,,,, `+` `*` `-` `&` `^` `|` `&&` или `||` .

*биноп*<br/>
Не перегруженный оператор, но один из,,,, `+` `*` `-` `&` `^` или `|` .

Ниже приведен пример `reduction` предложения.

```cpp
#pragma omp parallel for reduction(+: a, y) reduction(||: am)
for (i=0; i<n; i++) {
   a += b[i];
   y = sum(y, c[i]);
   am = am || b[i] == c[i];
}
```

Как показано в примере, оператор может быть скрыт внутри вызова функции. Пользователь должен быть аккуратным, чтобы оператор, указанный в `reduction` предложении, соответствовал операции сокращения.

Хотя правый операнд `||` оператора не имеет побочных эффектов в этом примере, он разрешен, но должен использоваться с осторожностью. В этом контексте побочный результат, который гарантированно не будет происходить во время последовательного выполнения цикла, может произойти во время параллельного выполнения. Это различие может возникать из-за того, что порядок выполнения итераций не определен.

Оператор используется для определения начального значения всех частных переменных, используемых компилятором для сокращения, и для определения оператора финализации. При указании оператора явно разрешается, что оператор сокращения выходит за пределы лексического экстента конструкции. `reduction`В директиве может быть указано любое количество предложений, но переменная может присутствовать не более чем в одном `reduction` предложении для этой директивы.

Создается частная копия каждой переменной в *переменной List* , по одной для каждого потока, как если `private` бы предложение было использовано. Закрытая копия инициализируется в соответствии с оператором (см. следующую таблицу).

В конце региона, для которого `reduction` было указано предложение, исходный объект обновляется в соответствии с результатом объединения исходного значения с конечным значением всех частных копий с помощью указанного оператора. Операторы сокращения являются ассоциативными (за исключением вычитания), и компилятор может свободно повторно связать вычисление окончательного значения. (Частичные результаты сокращения вычитания добавляются для формирования окончательного значения.)

Значение исходного объекта становится неопределенным, если первый поток достигает содержащего его предложения и остается таким, пока не завершится вычисление сокращения.  Как правило, вычисление будет выполнено в конце конструкции; Однако если `reduction` предложение используется для конструкции, к которой `nowait` также применяется, значение исходного объекта остается неопределенным до тех пор, пока не будет выполнена синхронизация барьера, чтобы убедиться, что все потоки завершили `reduction` предложение.

В следующей таблице перечислены допустимые операторы и их канонические значения инициализации. Фактическое значение инициализации будет соответствовать типу данных переменной сокращения.

|Оператор|Инициализация|
|--------------|--------------------|
|`+`|0|
|`*`|1|
|`-`|0|
|`&`|~0|
|`|`|0|
|`^`|0|
|`&&`|1|
|`||`|0|

К `reduction` предложению применяются следующие ограничения.

- Тип переменных в `reduction` предложении должен быть допустимым для оператора сокращения, за исключением того, что типы указателей и ссылочные типы не допускаются.

- Переменная, указанная в `reduction` предложении, не должна быть **`const`** квалифицированной.

- Переменные, которые являются частными в параллельной области или отображаются в `reduction` предложении `parallel` директивы, не могут быть указаны в `reduction` предложении в директиве совместного использования, которая выполняет привязку к параллельной конструкции.

   ```cpp
   #pragma omp parallel private(y)
   { /* ERROR - private variable y cannot be specified
                in a reduction clause */
      #pragma omp for reduction(+: y)
      for (i=0; i<n; i++)
         y += b[i];
   }

   /* ERROR - variable x cannot be specified in both
              a shared and a reduction clause */
   #pragma omp parallel for shared(x) reduction(+: x)
   ```

#### <a name="2727-copyin"></a>2.7.2.7 copyin

`copyin`Предложение предоставляет механизм для присвоения одинакового значения `threadprivate` переменным для каждого потока в группе, в которой выполняется параллельная область. Для каждой переменной, указанной в `copyin` предложении, значение переменной в главном потоке команды копируется, как и при назначении, в частные копии потока в начале параллельной области. Синтаксис `copyin` предложения выглядит следующим образом:

```cpp

copyin(
variable-list
)
```

К `copyin` предложению применяются следующие ограничения.

- Переменная, указанная в `copyin` предложении, должна иметь доступный ненеоднозначный оператор присваивания копирования.

- Переменная, указанная в `copyin` предложении, должна быть `threadprivate` переменной.

#### <a name="2728-copyprivate"></a>2.7.2.8 copyprivate

`copyprivate`Предложение предоставляет механизм для использования закрытой переменной для передачи значения из одного члена команды в другие члены. Это альтернатива использованию общей переменной для значения при предоставлении такой общей переменной сложной (например, в рекурсии, для которой требуется другая переменная на каждом уровне). `copyprivate`Предложение может использоваться только в `single` директиве.

Синтаксис `copyprivate` предложения выглядит следующим образом:

```cpp

copyprivate(
variable-list
)
```

Воздействие `copyprivate` предложения на переменные в его переменном списке происходит после выполнения структурированного блока, связанного с `single` конструкцией, и до того, как любой из потоков в группе не покинул барьер в конце конструкции. Затем, во всех остальных потоках в команде, для каждой переменной в *переменной-List*эта переменная определяется (как if по назначению) значением соответствующей переменной в потоке, выполняющем структурированный блок конструкции.

К `copyprivate` предложению применяются следующие ограничения.

- Переменная, указанная в `copyprivate` предложении, не должна использоваться в `private` `firstprivate` предложении или для той же `single` директивы.

- Если `single` `copyprivate` в динамическом экстенте параллельной области обнаружена директива с предложением, все переменные, указанные в `copyprivate` предложении, должны быть частными во включающем контексте.

- Переменная, указанная в `copyprivate` предложении, должна иметь доступный ненеоднозначный оператор присваивания копирования.

## <a name="28-directive-binding"></a>Привязка директив 2,8

Динамическая привязка директив должна соответствовать следующим правилам.

- `for`Директивы,,, `sections` `single` `master` и `barrier` связываются с динамическим включающим `parallel` , если он существует, независимо от значения любого `if` предложения, которое может присутствовать в этой директиве. Если в данный момент параллельная область не выполняется, директивы выполняются командой, состоящей только из главного потока.

- `ordered`Директива привязывается к динамически заданному элементу `for` .

- `atomic`Директива обеспечивает эксклюзивный доступ в отношении `atomic` директив во всех потоках, а не только для текущей команды.

- `critical`Директива обеспечивает эксклюзивный доступ в отношении `critical` директив во всех потоках, а не только для текущей команды.

- Директива не может быть привязана к любой директиве за пределами ближайшего к динамическому включению `parallel` .

## <a name="29-directive-nesting"></a>2,9. вложенное вложение директивы

Динамическое вложение директив должно соответствовать следующим правилам.

- `parallel`Динамическая директива внутри другой `parallel` логически создает новую команду, которая состоит только из текущего потока, если не включен вложенный параллелизм.

- `for``sections`директивы, и, `single` которые привязаны к одному и тому же, `parallel` не могут быть вложены друг в друга.

- `critical`директивы с одинаковыми именами не могут быть вложены друг в друга. Обратите внимание, что это ограничение не является достаточным для предотвращения взаимоблокировок.

- `for``sections` `single` директивы, и не допускаются в динамической области `critical` , `ordered` и, `master` Если директивы привязаны к тому же, что и `parallel` регионы.

- `barrier`директивы не разрешены в динамической области `for` ,, `ordered` , `sections` , `single` `master` и регионах, `critical` Если директивы привязаны к тому же, `parallel` что и регионы.

- `master`директивы не допускаются в динамической области `for` директив, `sections` и, `single` Если `master` директивы привязываются к тому же, `parallel` что и директивы совместного использования.

- `ordered`директивы не допускаются в динамической области `critical` областей, если директивы привязаны к тому же, `parallel` что и регионы.

- Любая директива, которая разрешена при динамическом выполнении в параллельной области, также разрешается при выполнении вне параллельной области. При динамическом выполнении за пределами указанной пользователем параллельной области директива выполняется командой, состоящей только из главного потока.
