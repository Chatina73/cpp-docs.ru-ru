---
title: 2. Директивы
ms.date: 01/18/2019
ms.assetid: d1a69374-6c03-45fb-8c86-e91cea8adae8
ms.openlocfilehash: 125d2d83b277e62d007e3a208e426ea717d52790
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78882871"
---
# <a name="2-directives"></a>2. Директивы

Директивы основаны на директивах `#pragma`, определенных в C и C++ стандартах.  Компиляторы, поддерживающие OpenMP C и C++ API, включают параметр командной строки, который активирует и позволяет интерпретировать все директивы компилятора OpenMP.

## <a name="21-directive-format"></a>формат директивы 2,1

Синтаксис директивы OpenMP формально определяется грамматикой в [приложении C](c-openmp-c-and-cpp-grammar.md)и имеет следующий вид:

```cpp
#pragma omp directive-name  [clause[ [,] clause]...] new-line
```

Каждая директива начинается с `#pragma omp`, чтобы снизить вероятность конфликта с другими директивами pragma (не расширениями OpenMP или поставщиками для OpenMP) с теми же именами. Оставшаяся часть директивы соответствует соглашениям языка C и C++ стандартов для директив компилятора. В частности, пробелы можно использовать до и после `#`, а иногда пробелы должны использоваться для разделения слов в директиве. Токены предварительной обработки после `#pragma omp` подчиняются замене макросов.

Директивы чувствительны к регистру. Порядок, в котором предложения отображаются в директивах, не имеет значения. Предложения в директивах могут повторяться по мере необходимости в соответствии с ограничениями, перечисленными в описании каждого предложения. Если в предложении присутствует предложение *variable-List* , оно должно указывать только переменные. Для каждой директивы можно указать только одно *имя директивы* .  Например, следующая директива не допускается:

```cpp
/* ERROR - multiple directive names not allowed */
#pragma omp parallel barrier
```

Директива OpenMP применяется не более чем к одной инструкции, которая должна быть структурированным блоком.

## <a name="22-conditional-compilation"></a>2,2. Условная компиляция

Имя макроса `_OPENMP` определяется реализациями, совместимыми с OpenMP, в виде десятичной константы *иииимм*, которая будет содержать год и месяц утвержденной спецификации. Этот макрос не должен быть темой директивы препроцессора `#define` или `#undef`.

```cpp
#ifdef _OPENMP
iam = omp_get_thread_num() + index;
#endif
```

Если поставщики определяют расширения для OpenMP, они могут указывать дополнительные предопределенные макросы.

## <a name="23-parallel-construct"></a>2,3. Параллельная конструкция

Следующая директива определяет параллельную область, которая является областью программы, которая должна выполняться многими потоками параллельно. Эта директива является фундаментальной конструкцией, которая начинает параллельное выполнение.

```cpp
#pragma omp parallel [clause[ [, ]clause] ...] new-line   structured-block
```

*Предложение* является одним из следующих:

- `if(` `)` *скалярного выражения*
- `private(` `)` *списка переменных*
- `firstprivate(` `)` *списка переменных*
- `default(shared | none)`
- `shared(` `)` *списка переменных*
- `copyin(` `)` *списка переменных*
- `reduction(` *оператор* `:`*список переменных* `)`
- `num_threads(` `)` *целочисленного выражения*

Когда поток получается в параллельную конструкцию, группа потоков создается, если выполняется один из следующих случаев.

- Предложение `if` отсутствует.
- Выражение `if` принимает ненулевое значение.

Этот поток превращается в главный поток команды с номером потока 0, а все потоки в группе, включая главный поток, выполняют этот регион параллельно. Если значение `if`ного выражения равно нулю, то область сериализуется.

Чтобы определить количество запрошенных потоков, следующие правила будут учитываться по порядку. Будет применено первое правило, условие которого соблюдается:

1. Если указано предложение `num_threads`, то значение целочисленного выражения равно количеству запрошенных потоков.

1. Если была вызвана функция библиотеки `omp_set_num_threads`, то значение аргумента в последнем выполненном вызове — это число запрошенных потоков.

1. Если определена переменная среды `OMP_NUM_THREADS`, значение этой переменной среды равно количеству запрошенных потоков.

1. Если ни один из вышеперечисленных методов не используется, то число запрошенных потоков определяется реализацией.

Если указано предложение `num_threads`, оно заменяет количество потоков, запрашиваемых функцией библиотеки `omp_set_num_threads`, или переменной среды `OMP_NUM_THREADS` только для параллельной области, к которой он применяется. Более поздние области параллельных регионов не затрагиваются.

Число потоков, выполняющих параллельную область, также зависит от того, включена ли Динамическая коррекция числа потоков. Если динамическая корректировка отключена, запрошенное число потоков будет выполнять параллельную область. Если включена динамическая настройка, запрошенное число потоков — это максимальное число потоков, которые могут выполнять параллельную область.

Если при динамической настройке количества потоков обнаружена параллельная область, а число потоков, запрошенных для параллельной области, превышает число, которое может быть предоставлено системой времени выполнения, то поведение программы будет определяется реализацией. Реализация может, например, прерывать выполнение программы или выполнять сериализацию параллельной области.

Функцию библиотеки `omp_set_dynamic` и переменную среды `OMP_DYNAMIC` можно использовать для включения и отключения динамической корректировки числа потоков.

Число физических процессоров, на которых фактически размещены потоки в любой конкретный момент, определяется реализацией. После создания число потоков в группе остается постоянным в течение этой параллельной области. Его можно изменить либо явным образом пользователем, либо автоматически системой времени выполнения из одной параллельной области в другую.

Инструкции, содержащиеся в динамической экстенте параллельной области, выполняются каждым потоком, и каждый поток может выполнить путь к операторам, отличным от других потоков. Директивы, обнаруженные вне лексического экстента параллельной области, называются потерянными директивами.

В конце параллельной области есть неявный барьер. Только главный поток команды продолжит выполнение в конце параллельной области.

Если поток в группе, в которой выполняется параллельная область, встречает другую параллельную конструкцию, он создает новую команду и станет главной группой этой новой команды. Вложенные параллельные области сериализуются по умолчанию. В результате по умолчанию вложенная параллельная область выполняется командой, состоящей из одного потока. Поведение по умолчанию можно изменить с помощью функции библиотеки времени выполнения `omp_set_nested` или переменной среды `OMP_NESTED`. Однако число потоков в команде, выполняющем вложенную параллельную область, определяется реализацией.

К директиве `parallel` относятся следующие ограничения.

- В директиве может присутствовать только одно предложение `if`.

- Он не указывает, происходят ли побочные эффекты в выражении if или выражении `num_threads`.

- `throw`, выполняемая внутри параллельной области, должна возобновить выполнение в динамической области того же структурированного блока, и она должна быть перехвачена тем же потоком, который выдал исключение.

- В директиве может присутствовать только одно предложение `num_threads`. Выражение `num_threads` вычисляется вне контекста параллельной области и должно иметь положительное целое значение.

- Порядок вычисления предложений `if` и `num_threads` не задан.

### <a name="cross-references"></a>Перекрестные ссылки

- предложения `private`, `firstprivate`, `default`, `shared`, `copyin`и `reduction` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))
- Переменная среды [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads)
- функция библиотеки [omp_set_dynamic](3-run-time-library-functions.md#317-omp_set_dynamic-function)
- Переменная среды [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)
- Функция [omp_set_nested](3-run-time-library-functions.md#319-omp_set_nested-function)
- Переменная среды [OMP_NESTED](4-environment-variables.md#44-omp_nested)
- функция библиотеки [omp_set_num_threads](3-run-time-library-functions.md#311-omp_set_num_threads-function)

## <a name="24-work-sharing-constructs"></a>2,4 конструкции совместной работы

Конструкция совместного использования распределяет выполнение соответствующей инструкции среди членов команды, в которой он встречается. Директивы совместного использования не запускают новые потоки, и нет подразумеваемого барьера на входе в конструкцию совместной работы.

Последовательность конструкций совместного использования и директив `barrier` для каждого потока в команде должна быть одинаковой.

OpenMP определяет следующие конструкции совместного использования, и эти конструкции описаны в следующих разделах:

- [для](#241-for-construct) директивы
- Директива [Sections](#242-sections-construct)
- [одна](#243-single-construct) директива

### <a name="241-for-construct"></a>2.4.1 для конструкции

Директива `for` определяет итеративную конструкцию совместной работы, которая указывает, что итерации связанного цикла будут выполняться параллельно. Итерации цикла `for` распределяются между потоками, которые уже существуют в группе, выполняющей параллельную конструкцию, к которой он привязан. Синтаксис конструкции `for` выглядит следующим образом:

```cpp
#pragma omp for [clause[[,] clause] ... ] new-line for-loop
```

Предложение является одним из следующих:

- `private(` `)` *списка переменных*
- `firstprivate(` `)` *списка переменных*
- `lastprivate(` `)` *списка переменных*
- `reduction(` *оператор* `:` *список переменных* `)`
- `ordered`
- *тип* `schedule(` [`,` *chunk_size*] `)`
- `nowait`

Директива `for` размещает ограничения на структуру соответствующего цикла `for`. В частности, соответствующий цикл `for` должен иметь каноническую форму:

`for (` *init-expr* `;` *var Logical-Op b* `;` *incr-expr* `)`

*init-expr*<br/>
Возможно одно из следующих:.

- *var* = *фунтов*
- *целочисленный тип var* = *фунтов*

*incr-expr*<br/>
Возможно одно из следующих:.

- `++` *var*
- *var* `++`
- `--` *var*
- *var* `--`
- *var* `+=` *incr*
- *var* `-=` *incr*
- *var* `=` *var* `+` *incr*
- *var* `=` *incr* `+` *var*
- *var* `=` *var* `-` *incr*

*var*<br/>
Целочисленная переменная со знаком. Если эта переменная в противном случае будет совместно использоваться, она неявно становится закрытой в течение `for`. Не изменяйте эту переменную в теле оператора `for`. Если переменная не указана `lastprivate`, ее значение после цикла будет неопределенным.

*логическая операция*<br/>
Возможно одно из следующих:.

- `<`
- `<=`
- `>`
- `>=`

*фунтов*, *b*и *incr*<br>
Инвариантные целочисленные выражения цикла. Во время оценки этих выражений синхронизация не выполняется, поэтому все вычисленные побочные эффекты приводят к непредсказуемым результатам.

Каноническая форма позволяет вычислять число итераций цикла при входе в цикл. Это вычисление выполняется с использованием значений в типе *var*после целочисленных акций. В частности, если значение *b* `-` *фунтов* `+` *incr* не может быть представлено в этом типе, результат будет неопределенным. Кроме того, если *логическая операция* `<` или `<=`, то *incr-expr* должен привести к увеличению *var* при каждой итерации цикла.   Если *логическая операция* `>` или `>=`, то *incr-expr* должен привести к тому, что *переменная var* будет меньше при каждой итерации цикла.

Предложение `schedule` указывает, как итерации цикла `for` делятся между потоками команды. Правильность программы не должна зависеть от того, какой поток выполняет определенную итерацию. Значение *chunk_size*, если оно указано, должно быть инвариантным целочисленным выражением цикла с положительным значением. Во время вычисления этого выражения синхронизация не выполняется, поэтому все вычисленные побочные эффекты приводят к непредсказуемым результатам. *Тип* расписания может принимать одно из следующих значений:

Таблица 2-1. значения *типа* для предложения `schedule`

|||
|-|-|
|static|Если указано `schedule(static,` *chunk_size* `)`, итерации делятся на фрагменты размера, указанного в *chunk_size*. Фрагменты статически назначаются потокам в группе с циклическим перебором в порядке номера потока. Если *chunk_size* не указано, пространство итерации делится на фрагменты, размер которых приблизительно равен размеру, с одним блоком, назначенным каждому потоку.|
|динамические|Если указано `schedule(dynamic,` *chunk_size* `)`, итерации делятся на ряд фрагментов, каждый из которых содержит итерации *chunk_size* . Каждый блок назначается потоку, ожидающему назначения. Поток выполняет фрагмент итераций, а затем ожидает следующего назначения, пока не останется назначенный фрагмент. Последний блок, который необходимо назначить, может иметь меньшее количество итераций. Если *chunk_size* не указано, по умолчанию используется значение 1.|
|Интерактивное|Если указано `schedule(guided,` *chunk_size* `)`, итерации назначаются потокам в блоках с уменьшением размеров. Когда поток завершает назначенный ему блок итераций, ему динамически назначается другой блок, пока не останется ничего. Для *chunk_size* 1 Размер каждого фрагмента составляет примерно столько неназначенных итераций, деленное на число потоков. Эти размеры уменьшаются почти экспоненциально до 1. Для *chunk_size* со значением *k* больше 1, размеры уменьшаются почти экспоненциально до *k*, за исключением того, что в последнем фрагменте может быть меньше *k* итераций. Если *chunk_size* не указано, по умолчанию используется значение 1.|
|среда выполнения|Если указано `schedule(runtime)`, решение о планировании откладывается до времени выполнения. *Тип* и размер расписания для фрагментов можно выбрать во время выполнения, задав переменную среды `OMP_SCHEDULE`. Если эта переменная среды не задана, результирующее расписание определяется реализацией. Если указано `schedule(runtime)`, *chunk_size* не должно быть указано.|

При отсутствии явно определенного предложения `schedule` `schedule` по умолчанию определяется реализацией.

Программа, совместимая с OpenMP, не должна полагаться на определенное расписание для правильного выполнения. Программа не должна полагаться на *тип* расписания в соответствии с описанным выше описанием, поскольку возможны вариации в реализациях одного и того же *типа* расписания для разных компиляторов. Описания можно использовать для выбора расписания, соответствующего конкретной ситуации.

Предложение `ordered` должно присутствовать, когда директивы `ordered` привязываются к конструкции `for`.

В конце конструкции `for` имеется неявный барьер, если не указано предложение `nowait`.

К директиве `for` относятся следующие ограничения.

- Цикл `for` должен быть структурированным блоком, и, Кроме того, его выполнение не должно завершаться инструкцией `break`.

- Значения выражений управления циклом `for` цикла, связанного с директивой `for`, должны быть одинаковыми для всех потоков в группе.

- Переменная итерации цикла `for` должна иметь тип целого числа со знаком.

- В директиве `for` может присутствовать только одно предложение `schedule`.

- В директиве `for` может присутствовать только одно предложение `ordered`.

- В директиве `for` может присутствовать только одно предложение `nowait`.

- Он не указывается, если или как часто происходят любые побочные эффекты в выражениях *chunk_size*, *фунтов*, *b*или *incr* .

- Значение выражения *chunk_size* должно быть одинаковым для всех потоков в команде.

#### <a name="cross-references"></a>Перекрестные ссылки

- предложения `private`, `firstprivate`, `lastprivate`и `reduction` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))
- Переменная среды [OMP_SCHEDULE](4-environment-variables.md#41-omp_schedule)
- [упорядоченная](#266-ordered-construct) конструкция
- предложение [Schedule](d-using-the-schedule-clause.md)

### <a name="242-sections-construct"></a>Конструкция разделов 2.4.2

Директива `sections` определяет неитеративную конструкцию совместной работы, которая указывает набор конструкций, которые должны быть распределены между потоками в группе. Каждый раздел запускается потоком в группе один раз. Синтаксис директивы `sections` выглядит следующим образом:

```cpp
#pragma omp sections [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block ]
...
}
```

Предложение является одним из следующих:

- `private(` `)` *списка переменных*
- `firstprivate(` `)` *списка переменных*
- `lastprivate(` `)` *списка переменных*
- `reduction(` *оператор* `:`*список переменных* `)`
- `nowait`

Каждому разделу предшествует директива `section`, хотя директива `section` является необязательной для первого раздела. Директивы `section` должны находиться в лексической области директивы `sections`. В конце конструкции `sections` имеется неявный барьер, если не указано `nowait`.

К директиве `sections` относятся следующие ограничения.

- Директива `section` не должна находиться за пределами лексического экстента директивы `sections`.

- В директиве `sections` может присутствовать только одно предложение `nowait`.

#### <a name="cross-references"></a>Перекрестные ссылки

- предложения `private`, `firstprivate`, `lastprivate`и `reduction` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))

### <a name="243-single-construct"></a>2.4.3, единая конструкция

Директива `single` определяет конструкцию, которая указывает, что связанный структурированный блок выполняется только одним потоком в группе (не обязательно главным потоком). Синтаксис директивы `single` выглядит следующим образом:

```cpp
#pragma omp single [clause[[,] clause] ...] new-linestructured-block
```

Предложение является одним из следующих:

- `private(` `)` *списка переменных*
- `firstprivate(` `)` *списка переменных*
- `copyprivate(` `)` *списка переменных*
- `nowait`

Существует неявное препятствие после конструкции `single`, если не указано предложение `nowait`.

К директиве `single` относятся следующие ограничения.

- В директиве `single` может присутствовать только одно предложение `nowait`.
- Предложение `copyprivate` не должно использоваться с предложением `nowait`.

#### <a name="cross-references"></a>Перекрестные ссылки

- предложения `private`, `firstprivate`и `copyprivate` ([раздел 2.7.2](#272-data-sharing-attribute-clauses))

## <a name="25-combined-parallel-work-sharing-constructs"></a>2,5. Объединенные конструкции параллельной совместной работы

Объединенные параллельные конструкции совместной работы — это сочетания клавиш для указания параллельной области, которая имеет только одну конструкцию совместного использования. Семантика этих директив аналогична явному указанию директивы `parallel`, за которой следует одна конструкция совместного использования.

В следующих разделах описаны Объединенные конструкции параллельного совместного использования.

- [параллельная](#251-parallel-for-construct) директива for
- Директива [Parallel Sections](#252-parallel-sections-construct)

### <a name="251-parallel-for-construct"></a>2.5.1 параллельно для конструкции

Директива `parallel for` является ярлыком для `parallel` региона, который содержит только одну директиву `for`. Синтаксис директивы `parallel for` выглядит следующим образом:

```cpp
#pragma omp parallel for [clause[[,] clause] ...] new-linefor-loop
```

Эта директива разрешает все предложения директивы `parallel` и директивы `for`, за исключением предложения `nowait` с идентичными значениями и ограничениями. Семантика аналогична явному указанию директивы `parallel`, за которой следует директива `for`.

#### <a name="cross-references"></a>Перекрестные ссылки

- Директива [Parallel](#23-parallel-construct)
- [для](#241-for-construct) директивы
- [Предложения атрибутов данных](#272-data-sharing-attribute-clauses)

### <a name="252-parallel-sections-construct"></a>Конструкция параллельных секций 2.5.2

Директива `parallel sections` предоставляет форму ярлыка для указания `parallel` области, которая содержит только одну директиву `sections`. Семантика аналогична явному указанию директивы `parallel`, за которой следует директива `sections`. Синтаксис директивы `parallel sections` выглядит следующим образом:

```cpp
#pragma omp parallel sections  [clause[[,] clause] ...] new-line
   {
   [#pragma omp section new-line]
      structured-block
   [#pragma omp section new-linestructured-block  ]
   ...
}
```

*Предложение* может быть одним из предложений, принимаемых директивами `parallel` и `sections`, за исключением предложения `nowait`.

#### <a name="cross-references"></a>Перекрестные ссылки

- Директива [Parallel](#23-parallel-construct)
- Директива [Sections](#242-sections-construct)

## <a name="26-master-and-synchronization-directives"></a>2,6. Главные и синхронизирующие директивы

В следующих разделах описывается следующее:

- [Главная](#261-master-construct) конструкция
- [критическая](#262-critical-construct) конструкция
- Директива [барьера](#263-barrier-directive)
- [атомарная](#264-atomic-construct) конструкция
- [flush](#265-flush-directive) , директива
- [упорядоченная](#266-ordered-construct) конструкция

### <a name="261-master-construct"></a>Главная конструкция 2.6.1

Директива `master` определяет конструкцию, которая задает структурированный блок, который выполняется главным потоком команды. Синтаксис директивы `master` выглядит следующим образом:

```cpp
#pragma omp master new-linestructured-block
```

Другие потоки в команде не выполняют связанный структурированный блок. Нет подразумеваемого барьера для входа или выхода из главной конструкции.

### <a name="262-critical-construct"></a>Критическая конструкция 2.6.2

Директива `critical` определяет конструкцию, которая запрещает выполнение связанного структурированного блока в один поток за раз. Синтаксис директивы `critical` выглядит следующим образом:

```cpp
#pragma omp critical [(name)]  new-linestructured-block
```

Для поиска критической области можно использовать необязательное *имя* . Идентификаторы, используемые для идентификации критической области, имеют внешнюю компоновку и находятся в пространстве имен, отделенном от пространств имен, используемых метками, тегами, элементами и обычными идентификаторами.

Поток ожидает в начале критического региона до тех пор, пока другой поток не выполнит критический регион (в любом месте программы) с тем же именем. Все неименованные директивы `critical` сопоставляются с одним и тем же неопределенным именем.

### <a name="263-barrier-directive"></a>Директива 2.6.3 барьера

Директива `barrier` синхронизирует все потоки в команде. При обнаружении каждый поток в группе ожидает, пока все остальные не достигают этого момента. Синтаксис директивы `barrier` выглядит следующим образом:

```cpp
#pragma omp barrier new-line
```

После того как все потоки в группе столкнулись с барьером, каждый поток в команде начинает выполнять инструкции после директивы барьера в параллельном режиме. Поскольку директива `barrier` не содержит инструкции языка C в составе своего синтаксиса, существуют некоторые ограничения на его размещение в программе. Дополнительные сведения о формальной грамматике см. в [приложении в](c-openmp-c-and-cpp-grammar.md). Эти ограничения показаны в приведенном ниже примере.

```cpp
/* ERROR - The barrier directive cannot be the immediate
*          substatement of an if statement
*/
if (x!=0)
   #pragma omp barrier
...

/* OK - The barrier directive is enclosed in a
*      compound statement.
*/
if (x!=0) {
   #pragma omp barrier
}
```

### <a name="264-atomic-construct"></a>2.6.4 Атомарная конструкция

Директива `atomic` гарантирует, что определенное место в памяти будет обновляться атомарно, вместо того чтобы предоставлять его возможность нескольким одновременным потокам записи. Синтаксис директивы `atomic` выглядит следующим образом:

```cpp
#pragma omp atomic new-lineexpression-stmt
```

Оператор выражения должен иметь одну из следующих форм:

- *x биноп* `=` *expr*
- `++` *x*
- `++` *x*
- `--` *x*
- `--` *x*

В предыдущих выражениях:

- *x* является выражением lvalue со скалярным типом.

- *expr* является выражением с скалярным типом и не ссылается на объект, обозначенный *x*.

- *биноп* не является перегруженным оператором и является одним из `+`, `*`, `-`, `/`, `&`, `^`, `|`, `<<`или `>>`.

Несмотря на то, что реализация замещает все директивы `atomic` с директивами `critical` с одинаковым уникальным *именем*, директива `atomic` допускает лучшую оптимизацию. Для выполнения атомарного обновления с минимальными издержками доступны часто используемые инструкции по оборудованию.

Атомарными являются только нагрузка и хранение объекта, обозначенного *x* . Вычисление *выражения expr* не является атомарным. Чтобы избежать конкуренции, все обновления расположения в параллельном режиме должны быть защищены с помощью директивы `atomic`, за исключением тех случаев, когда известно, что они свободны от состояний гонки.

К директиве `atomic` относятся следующие ограничения.

- Все атомарные ссылки на расположение хранилища x по всей программе должны иметь совместимый тип.

#### <a name="examples"></a>Примеры

```cpp
extern float a[], *p = a, b;
/* Protect against races among multiple updates. */
#pragma omp atomic
a[index[i]] += b;
/* Protect against races with updates through a. */
#pragma omp atomic
p[i] -= 1.0f;

extern union {int n; float x;} u;
/* ERROR - References through incompatible types. */
#pragma omp atomic
u.n++;
#pragma omp atomic
u.x -= 1.0f;
```

### <a name="265-flush-directive"></a>2.6.5. Директива flush

Директива `flush` (явная или подразумеваемая) указывает точку последовательности "перекрестных потоков", в которой требуется реализация, чтобы гарантировать, что все потоки в команде будут иметь единообразное представление определенных объектов (указанных ниже) в памяти. Это означает, что предыдущие вычисления выражений, ссылающихся на эти объекты, завершаются, и последующие вычисления еще не началися. Например, компиляторы должны восстанавливать значения объектов из регистров в память, а оборудование может потребовать записи буферов записи в память и повторной загрузки значений объектов из памяти.

Синтаксис директивы `flush` выглядит следующим образом:

```cpp
#pragma omp flush [(variable-list)]  new-line
```

Если объекты, требующие синхронизации, могут быть назначены переменными, то эти переменные могут быть указаны в необязательном *переменном списке*. Если указатель имеется в *переменной-списке*, сам указатель очищается, а не объект, на который ссылается указатель.

Директива `flush` без *переменной-List* синхронизирует все общие объекты, за исключением недоступных объектов с автоматическим длительностью хранения. (Это может привести к дополнительным издержкам, чем `flush` с *переменным списком*.) Директива `flush` без *переменной-List* подразумевается для следующих директив:

- `barrier`
- При входе и выходе из `critical`
- При входе и выходе из `ordered`
- При входе и выходе из `parallel`
- При выходе из `for`
- При выходе из `sections`
- При выходе из `single`
- При входе и выходе из `parallel for`
- При входе и выходе из `parallel sections`

Директива не подразумевается, если имеется предложение `nowait`. Следует отметить, что директива `flush` не подразумевается для следующих элементов:

- При входе в `for`
- При входе или выходе из `master`
- При входе в `sections`
- При входе в `single`

Ссылка, обращающаяся к значению объекта с постоянным типом, ведет себя так, как если бы директива `flush` указывала этот объект в предыдущей точке следования. Ссылка, изменяющая значение объекта с постоянным типом, ведет себя так, как если бы была Директива `flush`, указывающая этот объект в последующей точке следования.

Поскольку директива `flush` не содержит инструкции языка C в составе своего синтаксиса, существуют некоторые ограничения на его размещение в программе. Дополнительные сведения о формальной грамматике см. в [приложении в](c-openmp-c-and-cpp-grammar.md). Эти ограничения показаны в приведенном ниже примере.

```cpp
/* ERROR - The flush directive cannot be the immediate
*          substatement of an if statement.
*/
if (x!=0)
   #pragma omp flush (x)
...

/* OK - The flush directive is enclosed in a
*      compound statement
*/
if (x!=0) {
   #pragma omp flush (x)
}
```

К директиве `flush` относятся следующие ограничения.

- Переменная, указанная в директиве `flush`, не должна иметь ссылочный тип.

### <a name="266-ordered-construct"></a>2.6.6 упорядоченная конструкция

Структурированный блок, следующий за директивой `ordered`, выполняется в том порядке, в котором итерации будут выполняться в последовательном цикле. Синтаксис директивы `ordered` выглядит следующим образом:

```cpp
#pragma omp ordered new-linestructured-block
```

Директива `ordered` должна находиться в динамической области конструкции `for` или `parallel for`. Директива `for` или `parallel for`, к которой привязываются `ordered` конструкция, должна иметь предложение `ordered`, как описано в [разделе 2.4.1](#241-for-construct). При выполнении конструкции `for` или `parallel for` с предложением `ordered`, `ordered` конструкции выполняются строго в том порядке, в котором они будут выполняться при последовательном выполнении цикла.

К директиве `ordered` относятся следующие ограничения.

- Итерация цикла с `for` конструкцией не должна выполнять одну и ту же упорядоченную директиву более одного раза и не должна выполнять более одной директивы `ordered`.

## <a name="27-data-environment"></a>Среда данных 2,7

В этом разделе представлена директива и несколько предложений для управления средой данных во время выполнения параллельных регионов, как показано ниже.

- Директива [threadprivate](#271-threadprivate-directive) предназначена для того, чтобы переменные области действия файла, области видимости пространства имен или статических переменных областей видимости блока были локальными для потока.

- Предложения, которые могут быть заданы в директивах для управления общими атрибутами переменных на протяжении параллельных или совместно используемых конструкций, описаны в [разделе 2.7.2](#272-data-sharing-attribute-clauses).

### <a name="271-threadprivate-directive"></a>2.7.1 threadprivate, директива

Директива `threadprivate` делает переменные именованной области файла, области пространства имен или статической области видимости блока, указанные в *переменной-List* Private, потоку. *variable-List* — это разделенный запятыми список переменных, которые не имеют неполного типа. Синтаксис директивы `threadprivate` выглядит следующим образом:

```cpp
#pragma omp threadprivate(variable-list) new-line
```

Каждая копия `threadprivate` переменной инициализируется один раз, в неопределенной точке программы до первой ссылки на эту копию и обычным способом (т. е. при инициализации главной копии в последовательном исполнении программы). Обратите внимание, что если на объект имеется ссылка в явном инициализаторе `threadprivate` переменной, а значение объекта изменяется до первой ссылки на копию переменной, то поведение не указано.

Как и любая частная переменная, поток не должен ссылаться на копию объекта `threadprivate` другого потока. Во время последовательного и главного регионов программы ссылки будут указывать на копию объекта в главном потоке.

После выполнения первой параллельной области данные в `threadprivate`ных объектах гарантированно сохраняются только в том случае, если механизм динамических потоков был отключен и количество потоков остается неизменным для всех параллельных регионов.

К директиве `threadprivate` относятся следующие ограничения.

- Директива `threadprivate` для переменных области видимости файла или пространства имен должна находиться за пределами определения или объявления и должна быть лексической перед всеми ссылками на любые переменные в списке.

- Каждая переменная в *списке Variables* директивы `threadprivate` в области файла или пространства имен должна ссылаться на объявление переменной в области файла или пространства имен, которое лексически предшествует директиве.

- Директива `threadprivate` для статических переменных области блока должна находиться в области видимости переменной, а не во вложенной области. Директива должна быть лексической перед всеми ссылками на любые переменные в своем списке.

- Каждая переменная в *списке Variables* директивы `threadprivate` в области блока должна ссылаться на объявление переменной в той же области, которая лексически предшествует директиве. Объявление переменной должно использовать спецификатор класса хранения static.

- Если переменная указана в директиве `threadprivate` в одной записи преобразования, она должна быть указана в директиве `threadprivate` в каждой единице преобразования, в которой он объявлен.

- Переменная `threadprivate` не должна присутствовать в предложении, кроме `copyin`, `copyprivate`, `schedule`, `num_threads`или предложения `if`.

- Адрес переменной `threadprivate` не является константой адреса.

- Переменная `threadprivate` не должна иметь неполный тип или ссылочный тип.

- Переменная `threadprivate` с типом класса, отличной от POD, должна иметь доступный однозначный конструктор копии, если он объявлен с явной инициализатором.

В следующем примере показано, как изменение переменной, отображаемой в инициализаторе, может привести к неопределенному поведению, а также как избежать этой проблемы с помощью вспомогательного объекта и конструктора копии.

```cpp
int x = 1;
T a(x);
const T b_aux(x); /* Capture value of x = 1 */
T b(b_aux);
#pragma omp threadprivate(a, b)

void f(int n) {
   x++;
   #pragma omp parallel for
   /* In each thread:
   * Object a is constructed from x (with value 1 or 2?)
   * Object b is copy-constructed from b_aux
   */
   for (int i=0; i<n; i++) {
      g(a, b); /* Value of a is unspecified. */
   }
}
```

#### <a name="cross-references"></a>Перекрестные ссылки

- [динамические потоки](3-run-time-library-functions.md#317-omp_set_dynamic-function)
- Переменная среды [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)

### <a name="272-data-sharing-attribute-clauses"></a>2.7.2 предложения атрибутов совместного использования данных

Несколько директив принимают предложения, которые позволяют пользователю управлять атрибутами совместного использования переменных в течение региона. Предложения атрибутов совместного использования применяются только к переменным в лексической области директивы, в которой отображается предложение. Не все следующие предложения разрешены для всех директив. Список предложений, допустимых для конкретной директивы, описан в директиве.

Если переменная видна при обнаружении параллельной или совместно используемой конструкции, а переменная не указана в предложении атрибута общего доступа или директиве `threadprivate`, то переменная является общей. Статические переменные, объявленные внутри динамической экстента параллельной области, являются общими. Выделенная в куче память (например, использование `malloc()` в C C++ или или оператор `new` в C++) является общим. (Указатель на эту память, однако, может быть либо частным, либо общим.) Переменные с автоматической длительностью хранения, объявленной в динамической экстенте параллельной области, являются закрытыми.

Большинство предложений принимают аргумент *переменного списка* , который является списком видимых переменных с разделителями-запятыми. Если переменная, на которую имеется ссылка в предложении атрибута совместного использования данных, имеет тип, производный от шаблона, и в программе нет других ссылок на эту переменную, поведение не определено.

Все переменные, которые отображаются в предложениях директивы, должны быть видимыми. Предложения могут повторяться по мере необходимости, но ни одна переменная не может быть указана в более чем одном предложении, за исключением того, что переменная может быть указана как в `firstprivate`е, так и в предложении `lastprivate`.

В следующих разделах описаны предложения атрибутов совместного использования данных.

- [private](#2721-private)
- [firstprivate](#2722-firstprivate)
- [lastprivate](#2723-lastprivate)
- [используемый](#2724-shared)
- [значение по умолчанию](#2725-default)
- [reduction](#2726-reduction)
- [copyin](#2727-copyin)
- [copyprivate](#2728-copyprivate)

#### <a name="2721-private"></a>2.7.2.1 private

Предложение `private` объявляет переменные в переменной-списке как частные для каждого потока в группе. Синтаксис предложения `private` выглядит следующим образом:

```cpp
private(variable-list)
```

Поведение переменной, указанной в предложении `private`, выглядит следующим образом. Для конструкции выделяется новый объект с автоматическим периодом хранения. Размер и выравнивание нового объекта определяются типом переменной. Это выделение выполняется один раз для каждого потока в команде, а при необходимости вызывается конструктор по умолчанию для объекта класса. в противном случае начальное значение является неопределенным.  Исходный объект, на который ссылается переменная, имеет неопределенное значение при входе в конструкцию, не должен изменяться внутри динамической области конструкции и имеет неопределенное значение при выходе из конструкции.

В лексической области конструкции директивы переменная ссылается на новый закрытый объект, выделенный потоком.

К предложению `private` относятся следующие ограничения.

- Переменная с типом класса, заданной в предложении `private`, должна иметь доступный однозначный конструктор по умолчанию.

- Переменная, указанная в предложении `private`, не должна иметь тип, квалифицированный `const`, если он не содержит тип класса с элементом `mutable`.

- Переменная, указанная в предложении `private`, не должна иметь неполный тип или ссылочный тип.

- Переменные, которые отображаются в предложении `reduction` директивы `parallel`, не могут быть указаны в предложении `private` в директиве совместного использования, которая привязывается к параллельной конструкции.

#### <a name="2722-firstprivate"></a>2.7.2.2 firstprivate

Предложение `firstprivate` предоставляет надмножество функциональных возможностей, предоставляемых предложением `private`. Синтаксис предложения `firstprivate` выглядит следующим образом:

```cpp
firstprivate(variable-list)
```

Переменные, указанные в *переменной List* , имеют семантику предложения `private`, как описано в [разделе 2.7.2.1](#2721-private). Инициализация или конструкция происходит так же, как если бы она была выполнена один раз для каждого потока, до выполнения конструкции в потоке. Для предложения `firstprivate` в параллельной конструкции начальное значение нового закрытого объекта — это значение исходного объекта, существующего непосредственно перед параллельной конструкцией для потока, который его встречает. Для предложения `firstprivate` в конструкции совместного использования, исходное значение нового закрытого объекта для каждого потока, выполняющего конструкцию совместного использования, — это значение исходного объекта, существующего до момента времени, когда тот же поток встречает конструкцию совместного использования. Кроме того, для C++ объектов новый закрытый объект для каждого потока копируется из исходного объекта.

К предложению `firstprivate` относятся следующие ограничения.

- Переменная, указанная в предложении `firstprivate`, не должна иметь неполный тип или ссылочный тип.

- Переменная с типом класса, заданной как `firstprivate`, должна иметь доступный ненеоднозначный конструктор копии.

- Переменные, являющиеся частными в параллельной области или отображаемые в предложении `reduction` директивы `parallel`, не могут быть указаны в предложении `firstprivate` в директиве совместного использования, которая привязывается к параллельной конструкции.

#### <a name="2723-lastprivate"></a>2.7.2.3 lastprivate

Предложение `lastprivate` предоставляет надмножество функциональных возможностей, предоставляемых предложением `private`. Синтаксис предложения `lastprivate` выглядит следующим образом:

```cpp
lastprivate(variable-list)
```

Переменные, указанные в *переменной-List* , имеют семантику предложения `private`. Когда в директиве, определяющей конструкцию совместной работы, появляется предложение `lastprivate`, значение каждой переменной `lastprivate` из последовательно последней итерации связанного цикла или лексического последнего раздела назначается исходному объекту переменной. Переменные, которым не присвоено значение в результате последней итерации `for` или `parallel for`или в лексической последней части директивы `sections` или `parallel sections`, имеют неопределенные значения после конструкции. Неназначенные подобъекты также имеют неопределенное значение после конструкции.

К предложению `lastprivate` относятся следующие ограничения.

- Все ограничения для `private` применяются.

- Переменная с типом класса, заданной как `lastprivate`, должна иметь доступный ненеоднозначный оператор присваивания копирования.

- Переменные, являющиеся частными в параллельной области или отображаемые в предложении `reduction` директивы `parallel`, не могут быть указаны в предложении `lastprivate` в директиве совместного использования, которая привязывается к параллельной конструкции.

#### <a name="2724-shared"></a>2.7.2.4 shared

Это предложение использует переменные, которые появляются в *списке переменных* , для всех потоков в группе. Все потоки в группе обращаются к одной и той же области хранения для `shared` переменных.

Синтаксис предложения `shared` выглядит следующим образом:

```cpp
shared(variable-list)
```

#### <a name="2725-default"></a>2.7.2.5 default

Предложение `default` позволяет пользователю влиять на атрибуты совместного использования данных переменных. Синтаксис предложения `default` выглядит следующим образом:

```cpp
default(shared | none)
```

Указание `default(shared)` эквивалентно явному перечислению каждой видимой переменной в предложении `shared`, если только это не `threadprivate` или `const`. При отсутствии явного предложения `default` поведение по умолчанию будет таким же, как если бы были указаны `default(shared)`.

Для указания `default(none)` требуется, чтобы хотя бы одно из следующих должно быть истинным для каждой ссылки на переменную в лексической области параллельной конструкции:

- Переменная явно указана в предложении атрибута совместного использования данных конструкции, содержащей ссылку.

- Переменная объявляется в параллельной конструкции.

- Переменная `threadprivate`.

- Переменная имеет тип, квалифицированный `const`.

- Переменная — это Управляющая переменная цикла для цикла `for`, который сразу следует за директивой `for` или `parallel for`, а ссылка на переменную появляется внутри цикла.

Если указать переменную в предложении `firstprivate`, `lastprivate`или `reduction` директивы, заключенной в скобки, вызывается неявная ссылка на переменную в включающем контексте. Такие неявные ссылки также подчиняются указанным выше требованиям.

В директиве `parallel` можно указать только одно предложение `default`.

Атрибут совместного использования данных переменной по умолчанию может быть переопределен с помощью предложений `private`, `firstprivate`, `lastprivate`, `reduction`и `shared`, как показано в следующем примере:

```cpp
#pragma  omp  parallel  for  default(shared)  firstprivate(i)\
   private(x)  private(r)  lastprivate(i)
```

#### <a name="2726-reduction"></a>2.7.2.6 reduction

Это предложение выполняет сокращение скалярных переменных, которые отображаются в *переменной List*, с оператором *Op*. Синтаксис предложения `reduction` выглядит следующим образом:

`reduction(` *op* `:` *variable-List* `)`

Сокращение обычно указывается для инструкции с одной из следующих форм:

- *выражение* *x* `=` *x* *Op*
- *x* *биноп* `=` *expr*
- *x* `=` *expr* *Op* *x* (за исключением вычитания)
- `++` *x*
- `++` *x*
- `--` *x*
- `--` *x*

где:

*x*<br/>
Одна из переменных сокращения, указанных в списке.

*список переменных*<br/>
Разделенный запятыми список переменных сокращения скаляра.

*expr*<br/>
Выражение со скалярным типом, которое не ссылается на *x*.

*операцион*<br/>
Не перегруженный оператор, но один из `+`, `*`, `-`, `&`, `^`, `|`, `&&`или `||`.

*биноп*<br/>
Не перегруженный оператор, но один из `+`, `*`, `-`, `&`, `^`или `|`.

Ниже приведен пример предложения `reduction`.

```cpp
#pragma omp parallel for reduction(+: a, y) reduction(||: am)
for (i=0; i<n; i++) {
   a += b[i];
   y = sum(y, c[i]);
   am = am || b[i] == c[i];
}
```

Как показано в примере, оператор может быть скрыт внутри вызова функции. Пользователь должен быть аккуратным, чтобы оператор, указанный в предложении `reduction`, соответствовал операции сокращения.

Хотя правый операнд оператора `||` не имеет побочных эффектов в этом примере, он разрешен, но должен использоваться с осторожностью. В этом контексте побочный результат, который гарантированно не будет происходить во время последовательного выполнения цикла, может произойти во время параллельного выполнения. Это различие может возникать из-за того, что порядок выполнения итераций не определен.

Оператор используется для определения начального значения всех частных переменных, используемых компилятором для сокращения, и для определения оператора финализации. При указании оператора явно разрешается, что оператор сокращения выходит за пределы лексического экстента конструкции. В директиве можно указать любое количество `reduction` предложений, но для этой директивы может использоваться не более одного `reduction` предложения.

Создается частная копия каждой переменной в *переменной List* , по одной для каждого потока, как если бы было использовано предложение `private`. Закрытая копия инициализируется в соответствии с оператором (см. следующую таблицу).

В конце региона, для которого было указано предложение `reduction`, исходный объект обновляется в соответствии с результатом объединения исходного значения с конечным значением всех частных копий с помощью указанного оператора. Операторы сокращения являются ассоциативными (за исключением вычитания), и компилятор может свободно повторно связать вычисление окончательного значения. (Частичные результаты сокращения вычитания добавляются для формирования окончательного значения.)

Значение исходного объекта становится неопределенным, если первый поток достигает содержащего его предложения и остается таким, пока не завершится вычисление сокращения.  Как правило, вычисление будет выполнено в конце конструкции; Однако если предложение `reduction` используется в конструкции, к которой также применяется `nowait`, значение исходного объекта остается неизменным до тех пор, пока не будет выполнена синхронизация барьера, чтобы убедиться, что все потоки завершили предложение `reduction`.

В следующей таблице перечислены допустимые операторы и их канонические значения инициализации. Фактическое значение инициализации будет соответствовать типу данных переменной сокращения.

|Оператор|Инициализация|
|--------------|--------------------|
|`+`|0|
|`*`|1|
|`-`|0|
|`&`|~0|
|`|`|0|
|`^`|0|
|`&&`|1|
|`||`|0|

К предложению `reduction` относятся следующие ограничения.

- Тип переменных в предложении `reduction` должен быть допустимым для оператора сокращения, за исключением того, что типы указателей и ссылочные типы не допускаются.

- Переменная, указанная в предложении `reduction`, не должна быть квалифицирована `const`.

- Переменные, являющиеся частными в параллельной области или отображаемые в предложении `reduction` директивы `parallel`, не могут быть указаны в предложении `reduction` в директиве совместного использования, которая привязывается к параллельной конструкции.

   ```cpp
   #pragma omp parallel private(y)
   { /* ERROR - private variable y cannot be specified
                in a reduction clause */
      #pragma omp for reduction(+: y)
      for (i=0; i<n; i++)
         y += b[i];
   }

   /* ERROR - variable x cannot be specified in both
              a shared and a reduction clause */
   #pragma omp parallel for shared(x) reduction(+: x)
   ```

#### <a name="2727-copyin"></a>2.7.2.7 copyin

Предложение `copyin` предоставляет механизм для присвоения одинакового значения `threadprivate` переменным для каждого потока в группе, в которой выполняется параллельная область. Для каждой переменной, указанной в предложении `copyin`, значение переменной в главном потоке команды копируется, как при назначении, в частные копии потока в начале параллельной области. Синтаксис предложения `copyin` выглядит следующим образом:

```cpp

copyin(
variable-list
)
```

К предложению `copyin` относятся следующие ограничения.

- Переменная, указанная в предложении `copyin`, должна иметь доступный однозначный оператор присваивания копирования.

- Переменная, указанная в предложении `copyin`, должна быть `threadprivate` переменной.

#### <a name="2728-copyprivate"></a>2.7.2.8 copyprivate

Предложение `copyprivate` предоставляет механизм, позволяющий использовать закрытую переменную для передачи значения из одного члена команды в другие члены группы. Это альтернатива использованию общей переменной для значения при предоставлении такой общей переменной сложной (например, в рекурсии, для которой требуется другая переменная на каждом уровне). Предложение `copyprivate` может использоваться только в директиве `single`.

Синтаксис предложения `copyprivate` выглядит следующим образом:

```cpp

copyprivate(
variable-list
)
```

Воздействие предложения `copyprivate` на переменные в его переменной-списке происходит после выполнения структурированного блока, связанного с конструкцией `single`, а также до того, как любой из потоков в группе покинул барьер в конце конструкции. Затем, во всех остальных потоках в команде, для каждой переменной в *переменной-List*эта переменная определяется (как if по назначению) значением соответствующей переменной в потоке, выполняющем структурированный блок конструкции.

К предложению `copyprivate` относятся следующие ограничения.

- Переменная, указанная в предложении `copyprivate`, не должна присутствовать в предложении `private` или `firstprivate` для той же директивы `single`.

- Если в динамическом экстенте параллельной области обнаружена директива `single` с предложением `copyprivate`, все переменные, указанные в предложении `copyprivate`, должны быть частными во включающем контексте.

- Переменная, указанная в предложении `copyprivate`, должна иметь доступный ненеоднозначный оператор присваивания копирования.

## <a name="28-directive-binding"></a>Привязка директив 2,8

Динамическая привязка директив должна соответствовать следующим правилам.

- Директивы `for`, `sections`, `single`, `master`и `barrier` привязываются к динамически включающей `parallel`, если таковая существует, независимо от значения любого предложения `if`, которое может присутствовать в этой директиве. Если в данный момент параллельная область не выполняется, директивы выполняются командой, состоящей только из главного потока.

- Директива `ordered` привязывается к динамически включающей `for`.

- Директива `atomic` обеспечивает эксклюзивный доступ в отношении директив `atomic` во всех потоках, а не только для текущей команды.

- Директива `critical` обеспечивает эксклюзивный доступ в отношении директив `critical` во всех потоках, а не только для текущей команды.

- Директива не может быть привязана к любой директиве за пределами ближайшего динамически включающего `parallel`.

## <a name="29-directive-nesting"></a>2,9. вложенное вложение директивы

Динамическое вложение директив должно соответствовать следующим правилам.

- Директива `parallel` динамически в другой `parallel` логически создает новую команду, которая состоит только из текущего потока, если не включен вложенный параллелизм.

- директивы `for`, `sections`и `single`, которые привязаны к одному и тому же `parallel`, не могут быть вложены друг в друга.

- директивы `critical` с одинаковыми именами не могут быть вложены друг в друга. Обратите внимание, что это ограничение не является достаточным для предотвращения взаимоблокировок.

- директивы `for`, `sections`и `single` не допускаются в динамической области `critical`, `ordered`и `master`, если директивы привязаны к тому же `parallel`, что и регионы.

- директивы `barrier` не разрешены в динамической области `for`, `ordered`, `sections`, `single`, `master`и `critical`, если директивы привязаны к тому же `parallel`, что и регионы.

- директивы `master` не разрешены в динамической области директив `for`, `sections`и `single`, если директивы `master` привязаны к тому же `parallel`, что и директивы совместного использования.

- директивы `ordered` не разрешены в динамической области `critical` регионов, если директивы привязаны к тому же `parallel`, что и регионы.

- Любая директива, которая разрешена при динамическом выполнении в параллельной области, также разрешается при выполнении вне параллельной области. При динамическом выполнении за пределами указанной пользователем параллельной области директива выполняется командой, состоящей только из главного потока.
