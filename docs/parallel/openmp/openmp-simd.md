---
description: Дополнительные сведения о расширении SIMD
title: Расширение SIMD
ms.date: 03/20/2019
helpviewer_keywords:
- SIMD
- OpenMP in Visual C++, new features
- explicit parallelization, new features
ms.openlocfilehash: 58a3f29002c4e517a2019454dfe741dfb5352a3e
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97342430"
---
# <a name="simd-extension"></a>Расширение SIMD

В настоящее время Visual C++ поддерживает стандарт OpenMP 2,0, однако теперь Visual Studio 2019 также предлагает функции SIMD.

> [!NOTE]
> Чтобы использовать SIMD, Скомпилируйте с `-openmp:experimental` параметром, который включает дополнительные возможности OpenMP, недоступные при использовании `-openmp` параметра.
>
> `-openmp:experimental`Параметр субсумес `-openmp` означает, что все компоненты OpenMP 2,0 включены в его использование.

Дополнительные сведения см. [в статье расширение SIMD на C++ OpenMP в Visual Studio](https://devblogs.microsoft.com/cppblog/simd-extension-to-c-openmp-in-visual-studio/).

## <a name="openmp-simd-in-visual-c"></a>OpenMP SIMD in Visual C++

OpenMP SIMD, представленный в стандарте OpenMP 4,0, предназначен для создания удобных в векторах циклов. Используя `simd` директиву перед циклом, компилятор может игнорировать векторные зависимости, сделать цикл как можно более понятным и принять во внимание намерение пользователей одновременное выполнение нескольких итераций цикла.

```c
    #pragma omp simd
    for (i = 0; i < count; i++)
    {
        a[i] = a[i-1] + 1;
        b[i] = *c + 1;
        bar(i);
    }
```

Visual C++ предоставляет похожие прагмы циклов, отличные от OpenMP, такие как `#pragma vector` и `#pragma ivdep` , но с OpenMP SIMD, компилятор может делать больше, например:

- Всегда разрешено игнорировать существующие векторные зависимости.
- `/fp:fast` включается в цикле.
- Внешние циклы и циклы с вызовами функций являются векторно-ориентированными.
- Вложенные циклы можно объединять в один цикл и сделать векторно понятным.
- Гибридное ускорение с `#pragma omp for simd` целью позволяет использовать многопотоковые многопоточные и детализированные векторы.  

Для векторно-ориентированных циклов компилятор остается скрытым, если не используется переключатель журнала поддержки вектора:

```cmd
    cl -O2 -openmp:experimental -Qvec-report:2 mycode.cpp
```

```Output
    mycode.cpp(84) : info C5002: Omp simd loop not vectorized due to reason '1200'
    mycode.cpp(90) : info C5002: Omp simd loop not vectorized due to reason '1200'
    mycode.cpp(96) : info C5001: Omp simd loop vectorized
```

Для циклов, не ориентированных на вектор, компилятор выдает каждое сообщение:

```cmd
    cl -O2 -openmp:experimental mycode.cpp
```

```Output
    mycode.cpp(84) : info C5002: Omp simd loop not vectorized due to reason '1200'
    mycode.cpp(90) : info C5002: Omp simd loop not vectorized due to reason '1200'
```

### <a name="clauses"></a>Предложения

Директива OpenMP SIMD может также принимать следующие предложения для улучшения поддержки векторов:

|Директива|Описание|
|---|---|
|`simdlen(length)`|Укажите число векторных дорожек.|
|`safelen(length)`|Укажите расстояние векторной зависимости.|
|`linear(list[ : linear-step]`)|Линейное сопоставление переменной выведения цикла с подпиской на массив.|
|`aligned(list[ : alignment])`|Выравнивание данных.|
|`private(list)`|Укажите приватизацией данных.|
|`lastprivate(list)`|Укажите приватизацией данных с окончательным значением из последней итерации.|
|`reduction(reduction-identifier:list)`|Укажите настраиваемые операции сокращения.|
|`collapse(n)`|Объединение вложенного цикла.|

> [!NOTE]
> Неэффективные предложения SIMD анализируются и пропускаются компилятором с предупреждением.
>
> Например, при использовании следующего кода выдается предупреждение:
>
> ```c
>    #pragma omp simd simdlen(8)
>    for (i = 0; i < count; i++)
>    {
>        a[i] = a[i-1] + 1;
>        b[i] = *c + 1;
>        bar(i);
>    }
> ```
>
> ```Output
>    warning C4849: OpenMP 'simdlen' clause ignored in 'simd' directive
> ```

### <a name="example"></a>Пример
  
Директива OpenMP SIMD предоставляет пользователям способ для диктовки векторно-ориентированных циклов. Аннотирование цикла с помощью директивы OpenMP SIMD позволяет пользователям одновременно выполнять несколько итераций цикла.

Например, следующий цикл помечается с помощью директивы OpenMP SIMD. Нет идеального параллелизма между итерациями цикла, так как существует обратная зависимость от [i] до [i-1], но из-за директивы SIMD компилятору все равно разрешено упаковать последовательные итерации первой инструкции в одну векторную инструкцию и параллельно запускать их.

```c
    #pragma omp simd
    for (i = 0; i < count; i++)
    {
        a[i] = a[i-1] + 1;
        b[i] = *c + 1;
        bar(i);
    }
```

Таким образом, следующая преобразованная векторная форма цикла является **допустимой** , так как компилятор сохраняет последовательное поведение каждой итерации исходного цикла. Иными словами, выполняется `a[i]` после `a[-1]` , `b[i]` после `a[i]` чего вызов выполняется `bar` последним.

```c
    for (i = 0; i < count; i+=4)
    {
        a[i:i+3] = a[i-1:i+2] + 1;
        b[i:i+3] = *c + 1;
        bar(i);
        bar(i+1);
        bar(i+2);
        bar(i+3);
    }
```

**Не допускается** перемещение ссылки на память `*c` из цикла, если он может быть псевдонимом `a[i]` или `b[i]` . Кроме того, нельзя изменить порядок инструкций внутри одной исходной итерации, если она нарушает последовательную зависимость. Например, следующий Преобразованный цикл является недопустимым:

```c
    c = b;
    t = *c;
    for (i = 0; i < count; i+=4)
    {
        a[i:i+3] = a[i-1:i+2] + 1;
        bar(i);            // illegal to reorder if bar[i] depends on b[i]
        b[i:i+3] = t + 1;  // illegal to move *c out of the loop
        bar(i+1);
        bar(i+2);
        bar(i+3);
    }
```

## <a name="see-also"></a>См. также раздел

[/OpenMP (Включение поддержки OpenMP 2,0)](../../build/reference/openmp-enable-openmp-2-0-support.md)<br/>
