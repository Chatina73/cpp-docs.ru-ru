---
title: Расширение SIMD
ms.date: 03/20/2019
helpviewer_keywords:
- SIMD
- OpenMP in Visual C++, new features
- explicit parallelization, new features
ms.openlocfilehash: 0a7f1142a3a432628795341f4885b76a5c144990
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81366455"
---
# <a name="simd-extension"></a>Расширение SIMD

В настоящее время визуальный стандарт «СИ» поддерживает стандарт OpenMP 2.0, однако Visual Studio 2019 также теперь предлагает функциональность SIMD.

> [!NOTE]
> Чтобы использовать SIMD, компилировать с коммутатором, `-openmp:experimental` который `-openmp` позволяет дополнительные функции OpenMP недоступны при использовании коммутатора.
>
> Переключатель `-openmp:experimental` subsumes `-openmp`, то есть все openMP 2.0 функции включены в его использование.

Для получения дополнительной информации, [см.](https://devblogs.microsoft.com/cppblog/simd-extension-to-c-openmp-in-visual-studio/)

## <a name="openmp-simd-in-visual-c"></a>OpenMP SIMD в визуальном C

OpenMP SIMD, представленный в стандарте OpenMP 4.0, нацелен на создание векторных циклов. Используя `simd` директиву перед циклом, компилятор может игнорировать векторные зависимости, сделать цикл максимально удобным для векторных и уважать намерение пользователей выполнять несколько циклов одновременно.

```c
    #pragma omp simd
    for (i = 0; i < count; i++)
    {
        a[i] = a[i-1] + 1;
        b[i] = *c + 1;
        bar(i);
    }
```

Визуальный C ' предоставляет аналогичные не-OpenMP цикл прагмы, как `#pragma vector` и `#pragma ivdep`, однако с OpenMP SIMD, компилятор может сделать больше, как:

- Всегда позволялигнорировать игнорировать нынешние векторные зависимости.
- `/fp:fast`включен в цикле.
- Внешние петли и петли с функциональными вызовами удобны для векторных.
- Вложенные петли могут быть объединены в одну петлю и сделаны вектором.
- Гибридное `#pragma omp for simd` ускорение с включением грубозернистых многонитевых и мелкозернистых векторов.  

Для векторных циклов компилятор остается безмолвным, если вы не используете переключатель журнала поддержки вектора:

```cmd
    cl -O2 -openmp:experimental -Qvec-report:2 mycode.cpp
```

```Output
    mycode.cpp(84) : info C5002: Omp simd loop not vectorized due to reason '1200'
    mycode.cpp(90) : info C5002: Omp simd loop not vectorized due to reason '1200'
    mycode.cpp(96) : info C5001: Omp simd loop vectorized
```

Для невекторных циклов компилятор выдает каждое сообщение:

```cmd
    cl -O2 -openmp:experimental mycode.cpp
```

```Output
    mycode.cpp(84) : info C5002: Omp simd loop not vectorized due to reason '1200'
    mycode.cpp(90) : info C5002: Omp simd loop not vectorized due to reason '1200'
```

### <a name="clauses"></a>Предложения

Директива OpenMP SIMD может также принимать следующие положения для усиления векторной поддержки:

|Директива|Описание|
|---|---|
|`simdlen(length)`|Укажите количество векторных полос.|
|`safelen(length)`|Укажите расстояние векторной зависимости.|
|`linear(list[ : linear-step]`)|Линейное отображение от переменной индукции цикла к подписке массива.|
|`aligned(list[ : alignment])`|Выравнивание данных.|
|`private(list)`|Укажите приватизацию данных.|
|`lastprivate(list)`|Укажите приватизацию данных с конечной стоимостью из последней итерации.|
|`reduction(reduction-identifier:list)`|Укажите индивидуальные операции по сокращению.|
|`collapse(n)`|Угольное гнездо.|

> [!NOTE]
> Неэффективные положения SIMD разбираются и игнорируются компилятором с предупреждением.
>
> Например, использование следующего кода выдает предупреждение:
>
> ```c
>    #pragma omp simd simdlen(8)
>    for (i = 0; i < count; i++)
>    {
>        a[i] = a[i-1] + 1;
>        b[i] = *c + 1;
>        bar(i);
>    }
> ```
>
> ```Output
>    warning C4849: OpenMP 'simdlen' clause ignored in 'simd' directive
> ```

### <a name="example"></a>Пример
  
Директива OpenMP SIMD предоставляет пользователям способ диктовать компилятору сделать циклы векторными. Аннотируя цикл директивой OpenMP SIMD, пользователи намерены выполнять несколько итераций циклов одновременно.

Например, следующий цикл аннотирован директивой OpenMP SIMD. Нет идеального параллелизма среди циклических итераций, так как существует отсталая зависимость от аиики к аи-1, но из-за директивы SIMD компилятор по-прежнему может упаковать последовательные итерации первого оператора в одну векторовую инструкцию и запустить их параллельно.

```c
    #pragma omp simd
    for (i = 0; i < count; i++)
    {
        a[i] = a[i-1] + 1;
        b[i] = *c + 1;
        bar(i);
    }
```

Таким образом, следующая преобразованная форма вектора цикла **является законной,** поскольку компилятор сохраняет последовательное поведение каждой первоначальной итерации цикла. Другими словами, `a[i]` выполняется `b[i]` после `a[i]` `a[-1]`, после `bar` и вызов происходит в последний раз.

```c
    for (i = 0; i < count; i+=4)
    {
        a[i:i+3] = a[i-1:i+2] + 1;
        b[i:i+3] = *c + 1;
        bar(i);
        bar(i+1);
        bar(i+2);
        bar(i+3);
    }
```

Это **не законно,** чтобы переместить `*c` ссылку памяти из цикла, если он может псевдоним с `a[i]` или `b[i]`. Кроме того, не законно переупорядочить операторы внутри одной исходной итерации, если она нарушает последовательную зависимость. Например, следующий преобразованный цикл не является законным:

```c
    c = b;
    t = *c;
    for (i = 0; i < count; i+=4)
    {
        a[i:i+3] = a[i-1:i+2] + 1;
        bar(i);            // illegal to reorder if bar[i] depends on b[i]
        b[i:i+3] = t + 1;  // illegal to move *c out of the loop
        bar(i+1);
        bar(i+2);
        bar(i+3);
    }
```

## <a name="see-also"></a>См. также раздел

[/openmp (Включить поддержку OpenMP 2.0)](../../build/reference/openmp-enable-openmp-2-0-support.md)<br/>
