---
title: 3. Функции библиотеки среды выполнения
ms.date: 05/13/2019
ms.assetid: b226e512-6822-4cbe-a2ca-74cc2bb7e880
ms.openlocfilehash: 6155eb87bd7a1a0533caf99afb3db8417854df30
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79424173"
---
# <a name="3-run-time-library-functions"></a>3. функции библиотеки времени выполнения

В этом разделе описываются функции OpenMP C C++ и библиотеки времени выполнения. Заголовок **\<omp. h >** объявляет два типа, несколько функций, которые можно использовать для управления и запроса среды параллельного выполнения, а также функции блокировки, которые могут использоваться для синхронизации доступа к данным.

Тип `omp_lock_t` является типом объекта, способным представлять, что блокировка доступна или что поток владеет блокировкой. Эти блокировки называются *простыми блокировками*.

Тип `omp_nest_lock_t` — это тип объекта, способный представлять доступную блокировку или удостоверение потока, владеющего блокировкой, и *число вложений* (описанное ниже). Эти блокировки называются *вложенными блокировками*.

Библиотечные функции — это внешние функции с компоновкой "C".

Описания в этой главе делятся на следующие темы:

- [Функции среды выполнения](#31-execution-environment-functions)
- [Функции блокировки](#32-lock-functions)
- [Подпрограммы синхронизации](#33-timing-routines)

## <a name="31-execution-environment-functions"></a>3,1. функции среды выполнения

Функции, описанные в этом разделе, затрагивают и отслеживают потоки, процессоры и параллельную среду.

- [omp_set_num_threads](#311-omp_set_num_threads-function)
- [omp_get_num_threads](#312-omp_get_num_threads-function)
- [omp_get_max_threads](#313-omp_get_max_threads-function)
- [omp_get_thread_num](#314-omp_get_thread_num-function)
- [omp_get_num_procs](#315-omp_get_num_procs-function)
- [omp_in_parallel](#316-omp_in_parallel-function)
- [omp_set_dynamic](#317-omp_set_dynamic-function)
- [omp_get_dynamic](#318-omp_get_dynamic-function)
- [omp_set_nested](#319-omp_set_nested-function)
- [omp_get_nested](#3110-omp_get_nested-function)

### <a name="311-omp_set_num_threads-function"></a>Функция omp_set_num_threads 3.1.1

Функция `omp_set_num_threads` задает количество потоков по умолчанию, используемых для последующих параллельных регионов, не указывающих предложение `num_threads`. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_num_threads(int num_threads);
```

Значение параметра *num_threads* должно быть положительным целым числом. Его воздействие зависит от того, включена ли Динамическая коррекция числа потоков. Полный набор правил взаимодействия между функцией `omp_set_num_threads` и динамической настройкой потоков см. в [разделе 2,3](2-directives.md#23-parallel-construct).

Эта функция имеет описанные выше эффекты при вызове из части программы, в которой функция `omp_in_parallel` возвращает ноль. Если он вызывается из части программы, в которой функция `omp_in_parallel` возвращает ненулевое значение, поведение этой функции не определено.

Этот вызов имеет приоритет над переменной среды `OMP_NUM_THREADS`. Значение по умолчанию для количества потоков, которое может быть установлено путем вызова `omp_set_num_threads` или установки переменной среды `OMP_NUM_THREADS`, может быть явно переопределено в одной директиве `parallel` путем указания предложения `num_threads`.

Дополнительные сведения см. в разделе [omp_set_dynamic](#317-omp_set_dynamic-function).

#### <a name="cross-references"></a>Перекрестные ссылки

- Функция [omp_set_dynamic](#317-omp_set_dynamic-function)
- Функция [omp_get_dynamic](#318-omp_get_dynamic-function)
- Переменная среды [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads)
- предложение [num_threads](2-directives.md#23-parallel-construct)

### <a name="312-omp_get_num_threads-function"></a>Функция omp_get_num_threads 3.1.2

Функция `omp_get_num_threads` возвращает количество потоков, которые в настоящее время находятся в группе, выполняющей параллельную область, из которой он вызывается. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_num_threads(void);
```

Предложение `num_threads`, функция `omp_set_num_threads` и переменная среды `OMP_NUM_THREADS` управляют количеством потоков в команде.

Если число потоков не было явно задано пользователем, значение по умолчанию определяется реализацией. Эта функция выполняет привязку к ближайшей включающей директиве `parallel`. При вызове из последовательной части программы или из вложенной параллельной области эта функция возвращает значение 1.

Дополнительные сведения см. в разделе [omp_set_dynamic](#317-omp_set_dynamic-function).

#### <a name="cross-references"></a>Перекрестные ссылки

- [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads)
- [num_threads](2-directives.md#23-parallel-construct)
- [parallel](2-directives.md#23-parallel-construct)

### <a name="313-omp_get_max_threads-function"></a>Функция omp_get_max_threads 3.1.3

Функция `omp_get_max_threads` возвращает целое число, которое гарантированно должно быть не меньше числа потоков, которые будут использоваться для формирования команды, если в этой точке кода не было видно параллельной области без предложения `num_threads`. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_max_threads(void);
```

Ниже выражается Нижняя граница значения `omp_get_max_threads`:

> *потоки — используются для* <= `omp_get_max_threads`

Обратите внимание, что если другая параллельная область использует предложение `num_threads` для запроса определенного числа потоков, гарантия на нижнюю границу результата `omp_get_max_threads` больше не удерживается.

Возвращаемое значение функции `omp_get_max_threads` можно использовать для динамического выделения необходимого хранилища для всех потоков в группе, сформированной в следующей параллельной области.

#### <a name="cross-references"></a>Перекрестные ссылки

- [omp_get_num_threads](#312-omp_get_num_threads-function)
- [omp_set_num_threads](#311-omp_set_num_threads-function)
- [omp_set_dynamic](#317-omp_set_dynamic-function)
- [num_threads](2-directives.md#23-parallel-construct)

### <a name="314-omp_get_thread_num-function"></a>Функция omp_get_thread_num 3.1.4

Функция `omp_get_thread_num` возвращает номер потока в своей команде потока, в котором выполнялась функция. Номер потока находится в диапазоне от 0 до `omp_get_num_threads()`-1 включительно. Главный поток команды — это поток 0.

Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_thread_num(void);
```

Если вызывается из последовательной области, `omp_get_thread_num` возвращает 0. Если вызывается из во вложенной параллельной области, которая сериализуется, эта функция возвращает 0.

#### <a name="cross-references"></a>Перекрестные ссылки

- Функция [omp_get_num_threads](#312-omp_get_num_threads-function)

### <a name="315-omp_get_num_procs-function"></a>Функция omp_get_num_procs 3.1.5.

Функция `omp_get_num_procs` возвращает количество процессоров, доступных для программы во время вызова функции. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_num_procs(void);
```

### <a name="316-omp_in_parallel-function"></a>Функция omp_in_parallel 3.1.6

Функция `omp_in_parallel` возвращает ненулевое значение, если оно вызывается в динамической области параллельного региона, выполняемого параллельно. в противном случае возвращается значение 0. Используется следующий формат:

```cpp
#include <omp.h>
int omp_in_parallel(void);
```

Эта функция возвращает ненулевое значение при вызове из области, выполняемой параллельно, включая вложенные области, которые сериализуются.

### <a name="317-omp_set_dynamic-function"></a>Функция omp_set_dynamic 3.1.7

Функция `omp_set_dynamic` включает или отключает динамическую настройку количества потоков, доступных для выполнения параллельных регионов. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_dynamic(int dynamic_threads);
```

Если *dynamic_threads* принимает ненулевое значение, количество потоков, используемых для выполнения предстоящих параллельных регионов, может быть автоматически настроено средой выполнения для оптимального использования системных ресурсов. Как следствие, число потоков, заданное пользователем, является максимальным числом потоков. Число потоков в группе, выполняющих параллельную область, остается фиксированным на протяжении этой параллельной области и сообщается функции `omp_get_num_threads`.

Если *dynamic_threads* принимает значение 0, динамическая корректировка отключена.

Эта функция имеет описанные выше эффекты при вызове из части программы, в которой функция `omp_in_parallel` возвращает ноль. Если он вызывается из части программы, в которой функция `omp_in_parallel` возвращает ненулевое значение, поведение этой функции не определено.

Вызов `omp_set_dynamic` имеет приоритет над переменной среды `OMP_DYNAMIC`.

Значение по умолчанию для динамической корректировки потоков определяется реализацией. В результате коды пользователей, которые зависят от определенного числа потоков для правильного выполнения, должны явным образом отключить динамические потоки. Реализации не обязательно должны обеспечивать динамическую настройку количества потоков, но они должны предоставлять интерфейс для поддержки переносимости на всех платформах.

#### <a name="microsoft-specific"></a>Специально для систем Майкрософт

Текущая поддержка `omp_get_dynamic` и `omp_set_dynamic` выглядит следующим образом:

Входной параметр для `omp_set_dynamic` не влияет на политику потоков и не изменяет число потоков. `omp_get_num_threads` всегда возвращает либо определенное пользователем число, если оно задано, либо номер потока по умолчанию. В текущей реализации Майкрософт `omp_set_dynamic(0)` отключает динамическую обработку потоков, чтобы существующий набор потоков можно было повторно использовать для следующей параллельной области. `omp_set_dynamic(1)` включает динамическую обработку потоков, удаляя существующий набор потоков и создавая новый набор для предстоящей параллельной области. Число потоков в новом наборе совпадает со значением старого набора и основывается на возвращаемом значении `omp_get_num_threads`. Таким образом, для лучшей производительности используйте `omp_set_dynamic(0)`, чтобы повторно использовать существующие потоки.

#### <a name="cross-references"></a>Перекрестные ссылки

- [omp_get_num_threads](#312-omp_get_num_threads-function)
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)
- [omp_in_parallel](#316-omp_in_parallel-function)

### <a name="318-omp_get_dynamic-function"></a>Функция omp_get_dynamic 3.1.8

Функция `omp_get_dynamic` возвращает ненулевое значение, если включена динамическая настройка потоков, и возвращает 0 в противном случае. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_dynamic(void);
```

Если реализация не реализует динамическую настройку количества потоков, эта функция всегда возвращает значение 0. Дополнительные сведения см. в разделе [omp_set_dynamic](#317-omp_set_dynamic-function).

#### <a name="cross-references"></a>Перекрестные ссылки

- Описание динамической настройки потока см. в разделе [omp_set_dynamic](#317-omp_set_dynamic-function).

### <a name="319-omp_set_nested-function"></a>Функция omp_set_nested 3.1.9

Функция `omp_set_nested` включает или отключает вложенный параллелизм. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_nested(int nested);
```

Если параметр *Nested* имеет значение 0, то вложенный параллелизм отключен, что является значением по умолчанию, а вложенные параллельные области сериализуются и выполняются текущим потоком. В противном случае включен вложенный параллелизм, а параллельные регионы, которые являются вложенными, могут развертывать дополнительные потоки для формирования вложенных команд.

Эта функция имеет описанные выше эффекты при вызове из части программы, в которой функция `omp_in_parallel` возвращает ноль. Если он вызывается из части программы, в которой функция `omp_in_parallel` возвращает ненулевое значение, поведение этой функции не определено.

Этот вызов имеет приоритет над переменной среды `OMP_NESTED`.

Если включен вложенный параллелизм, то число потоков, используемых для выполнения вложенных параллельных регионов, определяется реализацией. В результате реализации, совместимые с OpenMP, могут сериализовать вложенные параллельные области, даже если включен вложенный параллелизм.

#### <a name="cross-references"></a>Перекрестные ссылки

- [OMP_NESTED](4-environment-variables.md#44-omp_nested)
- [omp_in_parallel](#316-omp_in_parallel-function)

### <a name="3110-omp_get_nested-function"></a>Функция omp_get_nested 3.1.10

Функция `omp_get_nested` возвращает ненулевое значение, если включен вложенный параллелизм, и 0, если он отключен. Дополнительные сведения о вложенном параллелизме см. в разделе [omp_set_nested](#319-omp_set_nested-function). Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_nested(void);
```

Если реализация не реализует вложенный параллелизм, эта функция всегда возвращает значение 0.

## <a name="32-lock-functions"></a>3,2 функции блокировки

Функции, описанные в этом разделе, управляют блокировками, используемыми для синхронизации.

Для следующих функций переменная Lock должна иметь тип `omp_lock_t`. Доступ к этой переменной должен осуществляться только через эти функции. Для всех функций блокировки требуется аргумент, имеющий указатель на `omp_lock_t` тип.

- Функция [omp_init_lock](#321-omp_init_lock-and-omp_init_nest_lock-functions) инициализирует простую блокировку.
- Функция [omp_destroy_lock](#322-omp_destroy_lock-and-omp_destroy_nest_lock-functions) удаляет простую блокировку.
- Функция [omp_set_lock](#323-omp_set_lock-and-omp_set_nest_lock-functions) ожидает, пока не будет доступна простая блокировка.
- Функция [omp_unset_lock](#324-omp_unset_lock-and-omp_unset_nest_lock-functions) освобождает простую блокировку.
- Функция [omp_test_lock](#325-omp_test_lock-and-omp_test_nest_lock-functions) тестирует простую блокировку.

Для следующих функций переменная Lock должна иметь тип `omp_nest_lock_t`.  Доступ к этой переменной должен осуществляться только через эти функции. Для всех вложенных функций блокировки требуется аргумент, имеющий указатель на тип `omp_nest_lock_t`.

- Функция [omp_init_nest_lock](#321-omp_init_lock-and-omp_init_nest_lock-functions) инициализирует вложенную блокировку.
- Функция [omp_destroy_nest_lock](#322-omp_destroy_lock-and-omp_destroy_nest_lock-functions) удаляет вложенную блокировку.
- Функция [omp_set_nest_lock](#323-omp_set_lock-and-omp_set_nest_lock-functions) ожидает, пока не будет доступна вложенная блокировка.
- Функция [omp_unset_nest_lock](#324-omp_unset_lock-and-omp_unset_nest_lock-functions) освобождает вложенную блокировку.
- Функция [omp_test_nest_lock](#325-omp_test_lock-and-omp_test_nest_lock-functions) проверяет вложенную блокировку.

Функции блокировки OpenMP обращаются к переменной блокировки таким образом, что они всегда считывают и обновляют самое последнее значение переменной блокировки. Таким образом, программе OpenMP не требуется включать явные директивы `flush`, чтобы гарантировать согласованность значения переменной блокировки между различными потоками. (Для обеспечения единообразия значений других переменных может потребоваться директива `flush`.)

### <a name="321-omp_init_lock-and-omp_init_nest_lock-functions"></a>omp_init_lock 3.2.1 и функции omp_init_nest_lock

Эти функции предоставляют единственные средства для инициализации блокировки. Каждая функция инициализирует блокировку, связанную с *блокировкой* параметра, для использования в ближайших вызовах. Используется следующий формат:

```cpp
#include <omp.h>
void omp_init_lock(omp_lock_t *lock);
void omp_init_nest_lock(omp_nest_lock_t *lock);
```

Начальное состояние разблокировано (то есть ни один поток не владеет блокировкой). Для вложенной блокировки начальное число вложений равно нулю. Он не соответствует вызову любой из этих подпрограмм с переменной блокировки, которая уже была инициализирована.

### <a name="322-omp_destroy_lock-and-omp_destroy_nest_lock-functions"></a>функции omp_destroy_lock и omp_destroy_nest_lock 3.2.2

Эти функции позволяют убедиться, что блокировка *блокировки* переменной не инициализирована. Используется следующий формат:

```cpp
#include <omp.h>
void omp_destroy_lock(omp_lock_t *lock);
void omp_destroy_nest_lock(omp_nest_lock_t *lock);
```

Он не соответствует вызову любой из этих подпрограмм с переменной блокировки, которая не инициализирована или разблокирована.

### <a name="323-omp_set_lock-and-omp_set_nest_lock-functions"></a>функции omp_set_lock и omp_set_nest_lock 3.2.3

Каждая из этих функций блокирует поток, который исполняет функцию, до тех пор, пока заданная блокировка не станет доступной, а затем установит блокировку. Простая блокировка доступна, если она разблокирована. Вложенная блокировка доступна, если она разблокирована или уже принадлежит потоку, выполняющим функцию. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_lock(omp_lock_t *lock);
void omp_set_nest_lock(omp_nest_lock_t *lock);
```

Для простой блокировки аргумент функции `omp_set_lock` должен указывать на инициализированную переменную блокировки. Владение блокировкой предоставляется потоку, выполняющим функцию.

Для вложенной блокировки аргумент функции `omp_set_nest_lock` должен указывать на инициализированную переменную блокировки. Число вложений увеличивается, и поток предоставляется или сохраняется владельцем блокировки.

### <a name="324-omp_unset_lock-and-omp_unset_nest_lock-functions"></a>функции omp_unset_lock и omp_unset_nest_lock 3.2.4

Эти функции предоставляют средства для освобождения владения блокировкой. Используется следующий формат:

```cpp
#include <omp.h>
void omp_unset_lock(omp_lock_t *lock);
void omp_unset_nest_lock(omp_nest_lock_t *lock);
```

Аргумент для каждой из этих функций должен указывать на инициализированную переменную блокировки, принадлежащую потоку, выполняющим функцию. Поведение не определено, если поток не владеет этой блокировкой.

Для простой блокировки функция `omp_unset_lock` освобождает поток, который исполняет функцию, от владения блокировкой.

Для вложенной блокировки функция `omp_unset_nest_lock` уменьшает число вложений и освобождает поток, который выполняет функцию, от владения блокировкой, если полученное число равно нулю.

### <a name="325-omp_test_lock-and-omp_test_nest_lock-functions"></a>функции omp_test_lock и omp_test_nest_lock 3.2.5

Эти функции пытаются установить блокировку, но не блокируют выполнение потока. Используется следующий формат:

```cpp
#include <omp.h>
int omp_test_lock(omp_lock_t *lock);
int omp_test_nest_lock(omp_nest_lock_t *lock);
```

Аргумент должен указывать на инициализированную переменную блокировки. Эти функции пытаются установить блокировку таким же образом, как `omp_set_lock` и `omp_set_nest_lock`, за исключением того, что они не блокируют выполнение потока.

Для простой блокировки функция `omp_test_lock` возвращает ненулевое значение, если блокировка установлена успешно. в противном случае возвращается ноль.

Для вложенной блокировки функция `omp_test_nest_lock` возвращает новый счетчик вложений, если блокировка установлена успешно. в противном случае возвращается ноль.

## <a name="33-timing-routines"></a>3,3. подпрограммы синхронизации

Функции, описанные в этом разделе, поддерживают переносной таймер Walls-Clock:

- Функция [omp_get_wtime](#331-omp_get_wtime-function) возвращает затраченное время на почасовой стене.
- Функция [omp_get_wtick](#332-omp_get_wtick-function) Возвращает секунды между последовательными тактами.

### <a name="331-omp_get_wtime-function"></a>Функция omp_get_wtime 3.3.1

Функция `omp_get_wtime` возвращает значение с плавающей запятой двойной точности, равное часовому интервалу прошедшего работы в секундах с момента некоторого «времени в прошлом».  Фактическое «время в прошлом» является произвольным, но при выполнении программы Приложение гарантированно не изменяется. Используется следующий формат:

```cpp
#include <omp.h>
double omp_get_wtime(void);
```

Предполагается, что функция будет использоваться для измерения затраченного времени, как показано в следующем примере:

```cpp
double start;
double end;
start = omp_get_wtime();
... work to be timed ...
end = omp_get_wtime();
printf_s("Work took %f sec. time.\n", end-start);
```

Возвращаемые значения времени — это «раз в поток». Это означает, что они не обязательно должны быть глобально согласованными во всех потоках, участвующих в приложении.

### <a name="332-omp_get_wtick-function"></a>Функция omp_get_wtick 3.3.2

Функция `omp_get_wtick` возвращает значение с плавающей запятой двойной точности, равное количеству секунд между последовательными тактовыми импульсами. Используется следующий формат:

```cpp
#include <omp.h>
double omp_get_wtick(void);
```
