---
title: 3. Функции библиотеки среды выполнения
ms.date: 05/13/2019
ms.assetid: b226e512-6822-4cbe-a2ca-74cc2bb7e880
ms.openlocfilehash: 767c006b0a2d81af4d1f8f2e23f84d7847326f31
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370275"
---
# <a name="3-run-time-library-functions"></a>3. Функции библиотеки run-time

В этом разделе описаны функции библиотеки OpenMP C и C'е. Заголовок ** \<omp.h>** объявляет два типа, несколько функций, которые могут быть использованы для управления и запроса параллельной среды выполнения, и функции блокировки, которые могут быть использованы для синхронизации доступа к данным.

Тип `omp_lock_t` — это тип объекта, способный представлять доступ к блокировке или к тому, что поток владеет замком. Эти блокировки называются *простыми замками.*

Тип `omp_nest_lock_t` — это тип объекта, способный представлять либо доступ к блокировке, либо как идентификацию потока, владеющего замком, так и *количество вложений* (описано ниже). Эти замки называются *вложенными замками.*

Функции библиотеки являются внешними функциями с увязкой "С".

Описания в этой главе делятся на следующие темы:

- [Функции среды выполнения](#31-execution-environment-functions)
- [Функции блокировки](#32-lock-functions)
- [Сроки процедур](#33-timing-routines)

## <a name="31-execution-environment-functions"></a>3.1 Функции среды выполнения

Функции, описанные в этом разделе, влияют и отслеживают потоки, процессоры и параллельную среду:

- [omp_set_num_threads](#311-omp_set_num_threads-function)
- [omp_get_num_threads](#312-omp_get_num_threads-function)
- [omp_get_max_threads](#313-omp_get_max_threads-function)
- [omp_get_thread_num](#314-omp_get_thread_num-function)
- [omp_get_num_procs](#315-omp_get_num_procs-function)
- [omp_in_parallel](#316-omp_in_parallel-function)
- [omp_set_dynamic](#317-omp_set_dynamic-function)
- [omp_get_dynamic](#318-omp_get_dynamic-function)
- [omp_set_nested](#319-omp_set_nested-function)
- [omp_get_nested](#3110-omp_get_nested-function)

### <a name="311-omp_set_num_threads-function"></a><a name="311-omp_set_num_threads-function"></a>3.1.1 функция omp_set_num_threads

`omp_set_num_threads` Функция устанавливает число потоков по умолчанию для использования для более `num_threads` поздних параллельных регионов, которые не указывают положение. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_num_threads(int num_threads);
```

Значение параметра *num_threads* должно быть положительным. Его эффект зависит от того, включена ли динамическая регулировка количества потоков. Для полного набора правил о `omp_set_num_threads` взаимодействии между функцией и динамической регулировкой потоков [см.](2-directives.md#23-parallel-construct)

Эта функция имеет эффекты, описанные выше, когда `omp_in_parallel` называется из части программы, где функция возвращается ноль. Если он называется из части программы, `omp_in_parallel` где функция возвращает ненулевое значение, поведение этой функции не определено.

Этот вызов имеет приоритет `OMP_NUM_THREADS` над переменной среды. Значение по умолчанию для числа потоков, которое `omp_set_num_threads` может быть `OMP_NUM_THREADS` установлено путем вызова или установки переменной среды, может быть явно перекрыто в одной `parallel` директиве, указав `num_threads` положение.

Для получения дополнительной информации см [omp_set_dynamic.](#317-omp_set_dynamic-function)

#### <a name="cross-references"></a>Перекрестные ссылки

- [функция omp_set_dynamic](#317-omp_set_dynamic-function)
- [функция omp_get_dynamic](#318-omp_get_dynamic-function)
- [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads) переменная окружающей среды
- [положение num_threads](2-directives.md#23-parallel-construct)

### <a name="312-omp_get_num_threads-function"></a><a name="312-omp_get_num_threads-function"></a>3.1.2 функция omp_get_num_threads

Функция `omp_get_num_threads` возвращает количество потоков, наиболее наданных в настоящее время в команде, исключающей параллельный регион, из которого она называется. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_num_threads(void);
```

Положение, `num_threads` `omp_set_num_threads` функция и переменная `OMP_NUM_THREADS` среды контролируют количество потоков в группе.

Если число потоков не было явно установлено пользователем, по умолчанию определена реализация. Эта функция связывается с ближайшей `parallel` директивой. Если вызов из последовательной части программы или из вложенной параллельной области, которая сериализована, эта функция возвращает 1.

Для получения дополнительной информации см [omp_set_dynamic.](#317-omp_set_dynamic-function)

#### <a name="cross-references"></a>Перекрестные ссылки

- [OMP_NUM_THREADS](4-environment-variables.md#42-omp_num_threads)
- [num_threads](2-directives.md#23-parallel-construct)
- [parallel](2-directives.md#23-parallel-construct)

### <a name="313-omp_get_max_threads-function"></a><a name="313-omp_get_max_threads-function"></a>3.1.3 функция omp_get_max_threads

`omp_get_max_threads` Функция возвращает целый ряд, который гарантированно будет по крайней мере такой же большой, как количество потоков, которые будут использоваться для формирования группы, если параллельный регион без `num_threads` оговорки должны были быть замечены в этот момент в коде. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_max_threads(void);
```

Ниже выражается нижняя граница `omp_get_max_threads`на значение:

> *потоки, используемые для следующей команды* <= `omp_get_max_threads`

Обратите внимание, что если `num_threads` другой параллельный регион использует положение для запроса определенного `omp_get_max_threads` количества потоков, гарантия на нижней границе результата больше не выполняется.

Значение `omp_get_max_threads` возврата функции может быть использовано для динамического распределения достаточного объема хранилища для всех потоков в группе, сформированной в следующем параллельном регионе.

#### <a name="cross-references"></a>Перекрестные ссылки

- [omp_get_num_threads](#312-omp_get_num_threads-function)
- [omp_set_num_threads](#311-omp_set_num_threads-function)
- [omp_set_dynamic](#317-omp_set_dynamic-function)
- [num_threads](2-directives.md#23-parallel-construct)

### <a name="314-omp_get_thread_num-function"></a><a name="314-omp_get_thread_num-function"></a>3.1.4 функции omp_get_thread_num

`omp_get_thread_num` Функция возвращает номер потока в команде потока, исполняющего функцию. Номер потока находится между `omp_get_num_threads()`0 и -1, включительно. Основной поток команды — это поток 0.

Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_thread_num(void);
```

Если вызов из серийного региона, `omp_get_thread_num` возвращает 0. Если вызов из вложенной параллельной области, которая сериализована, эта функция возвращает 0.

#### <a name="cross-references"></a>Перекрестные ссылки

- [функция omp_get_num_threads](#312-omp_get_num_threads-function)

### <a name="315-omp_get_num_procs-function"></a><a name="315-omp_get_num_procs-function"></a>3.1.5 функция omp_get_num_procs

Функция `omp_get_num_procs` возвращает количество процессоров, доступных для программы на момент вызова функции. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_num_procs(void);
```

### <a name="316-omp_in_parallel-function"></a><a name="316-omp_in_parallel-function"></a>3.1.6 функция omp_in_parallel

Функция `omp_in_parallel` возвращает ненулевое значение, если оно называется в динамической степени параллельного выполнения региона; в противном случае, он возвращает 0. Используется следующий формат:

```cpp
#include <omp.h>
int omp_in_parallel(void);
```

Эта функция возвращает ненулевое значение при вызове из региона, выполнения которого параллельно, включая вложенные области, которые сериализируются.

### <a name="317-omp_set_dynamic-function"></a><a name="317-omp_set_dynamic-function"></a>3.1.7 функция omp_set_dynamic

Функция `omp_set_dynamic` позволяет или отражает динамическую регулировку количества потоков, доступных для выполнения параллельных регионов. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_dynamic(int dynamic_threads);
```

Если *dynamic_threads* оценивается к ненулевому значению, количество потоков, используемых для выполнения предстоящих параллельных регионов, может быть автоматически скорректировано средой времени выполнения с целью оптимального использования системных ресурсов. Как следствие, число потоков, указанное пользователем, является максимальным количеством потоков. Количество потоков в группе, исцеляющей параллельный регион, остается фиксированным на протяжении всего параллельного региона и сообщается в функции. `omp_get_num_threads`

Если *dynamic_threads* оценивает до 0, динамическая регулировка отключается.

Эта функция имеет эффекты, описанные выше, когда `omp_in_parallel` называется из части программы, где функция возвращается ноль. Если он называется из части программы, `omp_in_parallel` где функция возвращает ненулевое значение, поведение этой функции не определено.

Вызов имеет `omp_set_dynamic` приоритет над переменной среды. `OMP_DYNAMIC`

По умолчанию для динамической регулировки потоков определяется реализация. В результате коды пользователей, зависят от определенного количества потоков для правильного выполнения, должны явно отсутчать динамические потоки. Реализация не требуется, чтобы обеспечить возможность динамической настройки числа потоков, но они необходимы для обеспечения интерфейса для поддержки переносимости на всех платформах.

#### <a name="microsoft-specific"></a>Специально для систем Майкрософт

Текущая поддержка `omp_get_dynamic` `omp_set_dynamic` и заключается в следующем:

Параметр `omp_set_dynamic` ввода не влияет на политику потока и не изменяет количество потоков. `omp_get_num_threads`всегда возвращает либо определенный пользователем номер, если он установлен, либо номер потока по умолчанию. В текущей реализации Microsoft выключается `omp_set_dynamic(0)` динамическое потоков, чтобы существующий набор потоков можно было повторно использовать для следующей параллельной области. `omp_set_dynamic(1)`включает динамическое потоковое, отбрасывая существующий набор потоков и создавая новый набор для предстоящей параллельной области. Количество потоков в новом наборе такое же, как и старый набор, и основано на значении `omp_get_num_threads`возврата. Поэтому для наилучшей `omp_set_dynamic(0)` производительности используйте для повторного использования существующих потоков.

#### <a name="cross-references"></a>Перекрестные ссылки

- [omp_get_num_threads](#312-omp_get_num_threads-function)
- [OMP_DYNAMIC](4-environment-variables.md#43-omp_dynamic)
- [omp_in_parallel](#316-omp_in_parallel-function)

### <a name="318-omp_get_dynamic-function"></a><a name="318-omp_get_dynamic-function"></a>3.1.8 функция omp_get_dynamic

Функция `omp_get_dynamic` возвращает ненулевое значение, если включена динамическая регулировка потоков, и возвращает 0 в противном случае. Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_dynamic(void);
```

Если реализация не выполняет динамическую регулировку числа потоков, эта функция всегда возвращает 0. Для получения дополнительной информации см [omp_set_dynamic.](#317-omp_set_dynamic-function)

#### <a name="cross-references"></a>Перекрестные ссылки

- Для описания динамической регулировки потока [omp_set_dynamic](#317-omp_set_dynamic-function)см.

### <a name="319-omp_set_nested-function"></a><a name="319-omp_set_nested-function"></a>3.1.9 функция omp_set_nested

Функция `omp_set_nested` позволяет или отстраивала ежепардис. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_nested(int nested);
```

Если *вложенные* оценки до 0, вложенный параллелизм отключается, что является по умолчанию, а вложенные параллельные области сериализируются и выполняются текущим потоком. В противном случае включен вложенный параллелизм, и параллельные области, которые вложены, могут развернуть дополнительные потоки для формирования вложенных групп.

Эта функция имеет эффекты, описанные выше, когда `omp_in_parallel` называется из части программы, где функция возвращается ноль. Если он называется из части программы, `omp_in_parallel` где функция возвращает ненулевое значение, поведение этой функции не определено.

Этот вызов имеет приоритет `OMP_NESTED` над переменной среды.

При включении вложенного параллеля, количество потоков, используемых для выполнения вложенных параллельных областей, определяется реализацией. В результате реализации, совместимые с OpenMP, могут сериализовать вложенные параллельные области даже при включении вложенного параллелизма.

#### <a name="cross-references"></a>Перекрестные ссылки

- [OMP_NESTED](4-environment-variables.md#44-omp_nested)
- [omp_in_parallel](#316-omp_in_parallel-function)

### <a name="3110-omp_get_nested-function"></a><a name="3110-omp_get_nested-function"></a>3.1.10 функция omp_get_nested

Функция `omp_get_nested` возвращает ненулевое значение, если вложенный параллелизм включен и 0, если он отключен. Для получения дополнительной информации о вложенных параллелизм, [смomp_set_nested](#319-omp_set_nested-function). Используется следующий формат:

```cpp
#include <omp.h>
int omp_get_nested(void);
```

Если реализация не реализует вложенный параллелизм, эта функция всегда возвращает 0.

## <a name="32-lock-functions"></a>3.2 Функции блокировки

Функции, описанные в этом разделе, манипулируют блокировками, используемыми для синхронизации.

Для следующих функций переменная `omp_lock_t`блокировки должна иметь тип. К этой переменной необходимо получить доступ только через эти функции. Все функции блокировки требуют аргумента, который имеет указатель для `omp_lock_t` ввода.

- Функция [omp_init_lock](#321-omp_init_lock-and-omp_init_nest_lock-functions) инициализирует простой замок.
- Функция [omp_destroy_lock](#322-omp_destroy_lock-and-omp_destroy_nest_lock-functions) удаляет простой замок.
- Функция [omp_set_lock](#323-omp_set_lock-and-omp_set_nest_lock-functions) ждет, пока не будет доступна простая блокировка.
- Функция [omp_unset_lock](#324-omp_unset_lock-and-omp_unset_nest_lock-functions) выпускает простой замок.
- Функция [omp_test_lock](#325-omp_test_lock-and-omp_test_nest_lock-functions) тестирует простой замок.

Для следующих функций переменная `omp_nest_lock_t`блокировки должна иметь тип.  К этой переменной необходимо получить доступ только через эти функции. Все функции блокировки, пригодиваемые для вложения, требуют аргумента, который имеет указатель для `omp_nest_lock_t` ввода.

- [Функция omp_init_nest_lock](#321-omp_init_lock-and-omp_init_nest_lock-functions) инициализирует вложенный замок.
- Функция [omp_destroy_nest_lock](#322-omp_destroy_lock-and-omp_destroy_nest_lock-functions) удаляет замок, пригодный для вложения.
- Функция [omp_set_nest_lock](#323-omp_set_lock-and-omp_set_nest_lock-functions) ждет, пока не доступен замок, вложенный.
- Функция [omp_unset_nest_lock](#324-omp_unset_lock-and-omp_unset_nest_lock-functions) выпускает вложенный замок.
- Функция [omp_test_nest_lock](#325-omp_test_lock-and-omp_test_nest_lock-functions) тестирует вложенный замок.

Функции блокировки OpenMP получают доступ к переменной блокировки таким образом, чтобы они всегда читали и обновляли наиболее текущее значение переменной блокировки. Поэтому программа OpenMP не должна включать явные `flush` директивы, чтобы убедиться, что значение переменной блокировки соответствует между различными потоками. (Возможно, потребуется `flush` директивы, чтобы сделать значения других переменных согласованными.)

### <a name="321-omp_init_lock-and-omp_init_nest_lock-functions"></a><a name="321-omp_init_lock-and-omp_init_nest_lock-functions"></a>3.2.1 функции omp_init_lock и omp_init_nest_lock

Эти функции обеспечивают единственное средство инициализации блокировки. Каждая функция инициализирует блокировку, связанную с *блокировкой* параметров, для использования в предстоящих вызовах. Используется следующий формат:

```cpp
#include <omp.h>
void omp_init_lock(omp_lock_t *lock);
void omp_init_nest_lock(omp_nest_lock_t *lock);
```

Начальное состояние разблокировано (т.е. ни один поток не владеет блокировкой). Для вложенного замка начальный отсчет вложений равен нулю. Вызов любого из этих процедур не соответствует переменной блокировки, которая уже была инициализирована.

### <a name="322-omp_destroy_lock-and-omp_destroy_nest_lock-functions"></a><a name="322-omp_destroy_lock-and-omp_destroy_nest_lock-functions"></a>3.2.2 omp_destroy_lock и omp_destroy_nest_lock функции

Эти функции убедитесь, что указанная на блокировку переменная *блокировка* не является первоначальной. Используется следующий формат:

```cpp
#include <omp.h>
void omp_destroy_lock(omp_lock_t *lock);
void omp_destroy_nest_lock(omp_nest_lock_t *lock);
```

Вызов любого из этих процедур не совместим с переменной блокировки, которая не является начальной или разблокированной.

### <a name="323-omp_set_lock-and-omp_set_nest_lock-functions"></a><a name="323-omp_set_lock-and-omp_set_nest_lock-functions"></a>3.2.3 omp_set_lock и omp_set_nest_lock функции

Каждая из этих функций блокирует выполнение функции потока до тех пор, пока не будет доступен указанный замок, а затем устанавливает блокировку. Простой замок доступен, если он разблокирован. Блокировка может быть доступна, если он разблокирован или если он уже принадлежит потоку, исполняя функцию. Используется следующий формат:

```cpp
#include <omp.h>
void omp_set_lock(omp_lock_t *lock);
void omp_set_nest_lock(omp_nest_lock_t *lock);
```

Для простого блокировки аргумент `omp_set_lock` к функции должен указывать на инициализированную переменную блокировки. Владение блокировкой предоставляется потоку, исполняя функцию.

Для вложенного замка аргумент `omp_set_nest_lock` к функции должен указывать на инициализированную переменную блокировки. Количество вложений приращено, и поток предоставляется или сохраняет право собственности на замок.

### <a name="324-omp_unset_lock-and-omp_unset_nest_lock-functions"></a><a name="324-omp_unset_lock-and-omp_unset_nest_lock-functions"></a>3.2.4 функции omp_unset_lock и omp_unset_nest_lock

Эти функции обеспечивают средства освобождения собственности на блокировку. Используется следующий формат:

```cpp
#include <omp.h>
void omp_unset_lock(omp_lock_t *lock);
void omp_unset_nest_lock(omp_nest_lock_t *lock);
```

Аргумент к каждой из этих функций должен указывать на инициализированную переменную блокировки, принадлежащую потоку, исполняющую функцию. Поведение не определено, если поток не владеет этим замком.

Для простого блокировки `omp_unset_lock` функция освобождает поток, исполняющий функцию, из владения замком.

Для вложенного замка `omp_unset_nest_lock` функция выделяет количество вложений и высвобождает поток, выполнив функцию из владения замком, если полученный отсчет равен нулю.

### <a name="325-omp_test_lock-and-omp_test_nest_lock-functions"></a><a name="325-omp_test_lock-and-omp_test_nest_lock-functions"></a>3.2.5 omp_test_lock и omp_test_nest_lock функции

Эти функции пытаются установить блокировку, но не блокируют выполнение потока. Используется следующий формат:

```cpp
#include <omp.h>
int omp_test_lock(omp_lock_t *lock);
int omp_test_nest_lock(omp_nest_lock_t *lock);
```

Аргумент должен указывать на инициализированную переменную блокировки. Эти функции пытаются установить блокировку таким же образом, как `omp_set_lock` и, `omp_set_nest_lock`за исключением того, что они не блокируют выполнение потока.

Для простого блокировки `omp_test_lock` функция возвращает значение ненулевого значения, если блокировка успешно установлена; в противном случае, он возвращаетное нулевую.

Для вложенного замка `omp_test_nest_lock` функция возвращает новый счет вложения, если блокировка успешно установлена; в противном случае, он возвращаетное нулевую.

## <a name="33-timing-routines"></a>3.3 Сроки процедуры

Функции, описанные в этом разделе, поддерживают портативный таймер настенных часов:

- Функция [omp_get_wtime](#331-omp_get_wtime-function) возвращает прошедшее время настенных часов.
- Функция [omp_get_wtick](#332-omp_get_wtick-function) возвращает секунды между последовательными тиками часов.

### <a name="331-omp_get_wtime-function"></a><a name="331-omp_get_wtime-function"></a>3.3.1 функция omp_get_wtime

Функция `omp_get_wtime` возвращает двойное значение плавающей точки, равное прошедшего времени настенных часов в секундах, так как некоторое "время в прошлом".  Фактическое "время в прошлом" является произвольным, но это гарантированно не изменится во время выполнения программы приложения. Используется следующий формат:

```cpp
#include <omp.h>
double omp_get_wtime(void);
```

Предполагается, что функция будет использоваться для измерения прошедшего времени, как показано в следующем примере:

```cpp
double start;
double end;
start = omp_get_wtime();
... work to be timed ...
end = omp_get_wtime();
printf_s("Work took %f sec. time.\n", end-start);
```

Возвращается время "за поток раз", что означает, что они не должны быть глобально последовательными во всех потоках, участвующих в приложении.

### <a name="332-omp_get_wtick-function"></a><a name="332-omp_get_wtick-function"></a>3.3.2 omp_get_wtick функции

Функция `omp_get_wtick` возвращает двойное плавающее значение точки, равное количеству секунд между последовательными тиками часов. Используется следующий формат:

```cpp
#include <omp.h>
double omp_get_wtick(void);
```
