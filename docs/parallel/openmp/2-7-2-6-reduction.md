---
title: 2.7.2.6 reduction
ms.date: 11/04/2016
ms.assetid: e7630a15-2978-4dbe-a29b-3a46371a0151
ms.openlocfilehash: 54b326feb4e4ccf1f1da5c8152ffc8d1e4bd13b2
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50456021"
---
# <a name="2726-reduction"></a>2.7.2.6 reduction

Это предложение выполняется редукция скалярные переменные, которые отображаются в *списка переменной*, с помощью оператора *op*. Синтаксис `reduction` предложение выглядит следующим образом:

> сокращение (*op*: *списка переменной*)

Уменьшение, как правило, задаются для инструкции с одним из следующих форм:

> *x* = *x* *op* *expr*
> *x* *binop* = *expr*
> *x* = *expr* *op* *x* (за исключением для вычитания) *x*++
> ++*x*
> *x*--
> --*x*

Здесь:

*x*<br/>
Одной из указанных в переменных сокращения `list`.

*переменная list*<br/>
Разделенный запятыми список переменных скалярная редукция.

*expr*<br/>
Выражение скалярного типа, которое не ссылается на *x*.

*op*<br/>
Не перегруженного оператора, но один из +, &#42;, -, &amp;, ^, &#124;, &amp; &amp;, или &#124; &#124;.

*binop*<br/>
Не перегруженного оператора, но один из +, &#42;, -, &amp;, ^, или &#124;.

Ниже приведен пример `reduction` предложение:

```cpp
#pragma omp parallel for reduction(+: a, y) reduction(||: am)
for (i=0; i<n; i++) {
   a += b[i];
   y = sum(y, c[i]);
   am = am || b[i] == c[i];
}
```

Как показано в примере, оператор может быть скрыт внутри вызова функции. Пользователю следует соблюдать осторожность, что оператор, указанные в `reduction` предложение на предмет соответствия операции сокращения.

Несмотря на то что правый операнд &#124; &#124; оператор не имеет побочных эффектов в этом примере, они допускаются, но следует использовать с осторожностью. В этом контексте побочные эффекты, гарантированно не происходит во время последовательного выполнения цикла может возникнуть при параллельном выполнении. Это различие может возникать, если не определен порядок выполнения итераций.

Оператор, используемый для определения начального значения всех частных переменных, используемый компилятором для сокращения и определить оператор финализации. Явное указание оператора позволяет инструкции сокращения, выходящих за пределы области лексические конструкции. Любое количество `reduction` предложения могут быть указаны в директиве, но переменную может отображаться в одном `reduction` предложение для этой директивы.

Локальную копию каждой переменной в *переменной list* создаются по одному для каждого потока, как если `private` было использовано предложение. Закрытой копии инициализируется в соответствии с оператора (см. ниже).

В конце области, для которого `reduction` указано предложение, исходный объект будет обновлена с учетом результат объединения свое исходное значение с конечное значение каждого из собственных копий, с помощью указанного оператора. Сокращение операторы имеют все ассоциативность (за исключением вычитание), а компилятор может свободно повторное связывание вычисления конечное значение. (Частичные результаты вычитания уменьшение добавляются для формирования конечного значения).

Значение для исходного объекта становится неопределенным, когда первый поток достигает содержащего предложение и сохраняет данный тип до завершения вычисления сокращения.  Как правило выполняется вычисление будет завершен, в конце конструкции; Тем не менее если `reduction` предложение используется в конструкции, к которому `nowait` является также применяется значение исходного объекта остается неопределенным пока не будет выполнена синхронизация барьера чтобы убедиться, что все потоки завершили `reduction`предложение.

Ниже перечислены операторы, которые являются допустимыми и их значения каноническую инициализации. Значение фактического инициализации будет совместимым с типом данных переменной сокращения.

|Оператор|Инициализация|
|--------------|--------------------|
|+|0|
|&#42;|1|
|-|0|
|&amp;|~0|
|&#124;|0|
|^|0|
|&amp;&amp;|1|
|&#124;&#124;|0|

Ограничения, которые необходимо `reduction` предложение, следующим образом:

- Тип переменных в `reduction` предложение должно быть допустимым для оператором редукции, за исключением того, что типы указателей и ссылочные типы никогда не разрешены.

- Переменная, которая указана в `reduction` предложение не должно быть **const**-полное.

- Переменные, являются закрытыми внутри параллельной области или, которые отображаются на `reduction` предложении **параллельных** директива не может указываться в `reduction` предложении директивы совместной работы, которая привязывается к параллельной конструкции.

   ```cpp
   #pragma omp parallel private(y)
   { /* ERROR - private variable y cannot be specified
                in a reduction clause */
      #pragma omp for reduction(+: y)
      for (i=0; i<n; i++)
         y += b[i];
   }

   /* ERROR - variable x cannot be specified in both
              a shared and a reduction clause */
   #pragma omp parallel for shared(x) reduction(+: x)
   ```
