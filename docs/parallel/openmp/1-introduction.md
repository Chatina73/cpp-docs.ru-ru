---
title: 1. Вступление
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: 8c735408bdf9f9a13693bd0ad25df185bb1db42a
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62236454"
---
# <a name="1-introduction"></a>1. Вступление

В этом документе определяет коллекцию директивы компилятора, библиотечные функции и переменные среды, которые можно использовать для указания общей памяти параллелизма в программах на C и C++. Возможности, описываемые в этом документе которые в совокупности называются *OpenMP C/C++ приложения программа интерфейс (API)*. Цель этой спецификации — предоставить модель параллельного программирования, который позволяет программам можно переносить на другие архитектуры общей памяти от разных поставщиков. Компиляторы из многие поставщики поддерживают API OpenMP C/C++. Дополнительные сведения о OpenMP, включая *OpenMP Fortran прикладной программный интерфейс*, можно найти на веб-узла:

[https://www.openmp.org](https://www.openmp.org)

Директивы, библиотечные функции и переменные среды, определенные в этом документе позволяют создавать и управлять ими параллельных программ, при этом переносимость. Директивы расширения C и C++ последовательного программирования модели с одной программы, который создает несколько данных (SPMD), конструкции совместной работы и синхронизации конструкции. Они также поддерживают общий доступ и приватизация данных. Компиляторы, которые поддерживают API OpenMP C и C++ API включают параметр командной строки для компилятора, который активирует и позволяет интерпретацию все директивы компилятора OpenMP.

## <a name="11-scope"></a>1.1 Область

Эта спецификация охватывает только управляемое пользователем параллелизации, при котором какие действия следует явным образом определить компилятор и система времени выполнения для параллельного выполнения программы. Реализации API OpenMP C и C++, не являются обязательными для проверки зависимости, конфликты, взаимоблокировки, гонки или других проблем, приводящих к возникновению выполнения неправильные программы. Вы несете ответственность за обеспечение правильности выполнения приложения с помощью конструкций API OpenMP C и C++ API. В этом документе не рассматривается компилятором автоматическую параллелизацию и директивы компилятора для помощи такой параллелизации.

## <a name="12-definition-of-terms"></a>1.2 Определение терминов

В этом документе используются следующие термины:

- barrier

  Точка синхронизации, все потоки в команде необходимо получить доступ.  Каждый поток ожидает, пока все потоки в группе поступают на этом этапе. Существует явное барьеры, определяемым директивы и неявные барьеры, созданное реализацией.

- construct

  Это конструкция является оператором. Он состоит из директивы, за которым следует структурированный блок. Некоторые директивы не входят в конструкции. (См. в разделе *openmp директива* в [приложение C](c-openmp-c-and-cpp-grammar.md)).

- директива

  C или C++ `#pragma` следуют `omp` идентификатор, другой текст и строки. Директива указывает поведение программы.

- динамические экстента

  Все инструкции в *лексическую область*, а также любая инструкция внутри функции, который выполняется в результате выполнения инструкции в лексической области. Динамические экстент также называется *регион*.

- лексическая область

  Операторы лексически хранящиеся в *структурированный блок*.

- главный поток

  Поток, который создает команду при *область параллельной обработки* вводится.

- область параллельной обработки

  Инструкции, привязки к параллельной конструкции OpenMP и может выполняться много потоков.

- private

  Закрытая переменная имен блок хранилища, который уникален в поток, выполняющий ссылки. Существует несколько способов для указания, что переменная является закрытым: определение внутри параллельной области, `threadprivate` директивы, `private`, `firstprivate`, `lastprivate`, или `reduction` предложение или переменную как `for`цикла Управляющая переменная в `for` цикл сразу после `for` или `parallel for` директива.

- region

  Динамические экстента.

- последовательный регион

  Инструкции, выполняемые только *освоить потоке* за пределами области динамических любого *область параллельной обработки*.

- Сериализация

  Для выполнения параллельной конструкции с:

  - группу потоков, состоящий из только один поток (который является главного потока для этой параллельной конструкции),

  - Последовательный порядок выполнения инструкций в структурированном блоке (же заказа, как будто блока не являются частью параллельные конструкции), и

  - не влияет на значение, возвращенное `omp_in_parallel()` (помимо последствия любые вложенные параллельные конструкции).

- общие

  Общей переменной имен один блок памяти. Все потоки в группе, которые обращаются к этой переменной также получить доступ к этой одного блока памяти.

- структурированный блок

  Структурированный блок является оператором (одинарную или составные) с одной записи и один выход. Если переход в или из него инструкцию, которая является структурированный блок. (Это правило включает вызов `longjmp`(3C) или использование `throw`, хотя вызов `exit` разрешен.) Если его выполнение всегда начинается с открытия `{` и всегда заканчивается закрывающий `}`, составной оператор — это структурированный блок. Оператор выражения, оператор выбора, оператора итерации или `try` блок — структурированный блок, если получить соответствующий составной оператор, заключив его в `{` и `}` бы структурированный блок. Оператор перехода, оператор с меткой или оператор объявления не структурированный блок.

- Команды

  Один или несколько потоков совместно действующих в выполнении конструкции.

- thread

  Сущность выполнения, наличие последовательного потока управления, набор закрытых переменных и доступ к общим переменным.

- Переменная

  Идентификатор, при необходимости вместе с именами пространства имен, имя объекта.

## <a name="13-execution-model"></a>1.3 модель выполнения

OpenMP использует модель ветвления слияния параллельного выполнения. Несмотря на то, что эта модель ветвления соединения может быть полезна для решения различных проблем, она предназначена для крупных приложений на основе массива. OpenMP предназначен для поддержки программы, которые выполняются правильно только в качестве параллельных программ (много потоков выполнения и полный OpenMP библиотеку поддержки). Она также доступна для программы, которые выполняются правильно, как последовательные программы (директивы игнорируются и простую библиотеку заглушки OpenMP). Тем не менее возможно и разрешено Разработка программы, не работает правильно для последовательного исполнения. Кроме того различные степени параллелизма может привести различных числовых результатов из-за изменений в ассоциации числовых операций. Например сокращения последовательной сложения может иметь другой шаблон Добавление ассоциации, чем параллельной редукции. Эти различные ассоциации может повлиять на результаты сложения с плавающей запятой.

Программа, написанная с помощью API OpenMP C/C++ начинает выполнение как один поток выполнения, вызываемую *освоить потоке*. Главный поток выполняет в область с последовательной, пока не будет обнаружен первый параллельной конструкции. В API OpenMP C/C++ `parallel` директива составляет параллельной конструкции. При обнаружении параллельной конструкции, основной поток создает группу потоков, а master становится основной группы. Каждый поток в группе выполняет инструкции в динамических степень параллельной области, за исключением конструкции совместной работы. Все потоки в группе должна получить конструкции совместной работы, в том же порядке, и один или несколько потоков, выполняет операторы внутри структурированных блоку. Барьер, который содержится в разрешении в конце конструкции совместной работы без `nowait` предложение выполняется всеми потоками в группе.

Если поток изменяет общий объект, оно влияет не только среды выполнения, но также те из других потоков в программе. Изменение гарантированно завершенной, с точки зрения другого потока, на следующем этапе последовательности (как определено в базовый язык), только в том случае, если объект объявляется как volatile. В противном случае изменение гарантированно завершения после сначала изменение потока. Другие потоки затем (или одновременно) см. в разделе `flush` директивы, указывающий объект (явно или неявно). Когда `flush` директивы, которые неявно выражены другие директивы OpenMP не гарантируют правильный порядок побочные эффекты, что программист должен предоставить дополнительные, явные `flush` директивы.

После завершения параллельной конструкции потоки в группе синхронизации в неявных барьера, и только главный поток продолжает выполнение. Любое количество параллельные конструкции можно указать в одной программе. Таким образом программа может создать вилку и присоединить много раз во время выполнения.

API OpenMP C/C++ позволяют программистам использовать директивы в функции, вызываемые из параллельные конструкции. Директивы, которые не отображаются в лексической области параллельные конструкции, но могут находиться в области динамической называются *потерянные* директивы. С потерянных директивы программисты могли выполняться параллельно, с помощью лишь незначительно последовательной программы основной части своих программах. Благодаря этой функции можно создавать параллельные конструкции на верхних уровнях дерева вызовов программы, а затем использовать директивы для управления выполнением в любом из вызываемые функции.

Несинхронизированные вызовы для языков C и C++ выходных данных функции, записывающие в тот же файл может привести к выходных данных, в котором данные, записанные разными потоками отображается в порядке недетерминированные. Аналогичным образом несинхронизированных вызовы входных данных функции, выполняющие чтение из одного файла может читать данные в недетерминированные заказа. Несинхронизированные использования операций ввода-вывода, таким образом, чтобы каждый поток обращается к другой файл, имела тот же результат, как последовательное выполнение функций ввода-вывода.

## <a name="14-compliance"></a>1.4 Совместимость

Реализация API OpenMP C/C++ является *OpenMP совместимым* если он распознает и позволяет сохранить семантику всех элементов этой спецификации, согласно утвержденному главы 1, 2, 3, 4, и приложение C. приложения A, B, D, E и F для сведения только в целях и не входит в спецификацию. Реализации, которая включает только подмножество API-интерфейса не OpenMP совместимым.

API OpenMP C и C++ API является расширением базового языка, которое поддерживается реализацией. Если используемый базовый язык не поддерживает языковой конструкции или расширение, содержащееся в этом документе, реализация OpenMP не обязательно должна поддерживать его.

Все стандартные функции библиотеки C и C++ и встроенные функции (то есть функции, которых у компилятора есть специальными знаниями) должны быть потокобезопасными. Несинхронизированные использование поточно ориентированные функции разных потоков внутри параллельной области не привести к неопределенному поведению. Тем не менее поведение может отличаться как в последовательной регион. (Функцию создания случайных чисел является примером).

API OpenMP C/C++ указывает, что определенное поведение *определяемого реализацией.* Определить и задокументировать его поведение в этих случаях необходима соответствующая реализация OpenMP. Список всех элементов поведения, определяемые реализацией, см. в разделе [приложении E](e-implementation-defined-behaviors-in-openmp-c-cpp.md).

## <a name="15-normative-references"></a>1.5 ссылки на Нормативные документы

- ISO/IEC 9899: 1999, *сведения о технологии - языки программирования - C*. Эта спецификация OpenMP API называется ISO/IEC 9899: 1999 C99.

- ISO/IEC 9899: 1990, *сведения о технологии - языки программирования - C*. Эта спецификация OpenMP API называется ISO/IEC 9899: 1990 C90.

- 14882:1998 ISO/IEC *сведения C++ технологии - языки программирования -*. Эта спецификация OpenMP API называется ISO/IEC 14882:1998 C++.

Там, где эта спецификация OpenMP API ссылается на C, имеется ссылка на базовый язык, поддерживаемый в реализации.

## <a name="16-organization"></a>1.6 Организация

- [Функции библиотеки среды выполнения](3-run-time-library-functions.md)
- [Переменные среды](4-environment-variables.md)
- [Поведения, определяемые реализацией, в OpenMP C/C++](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [Новые возможности в OpenMP C/C++ версии 2.0](f-new-features-and-clarifications-in-version-2-0.md)
