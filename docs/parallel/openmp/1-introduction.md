---
title: 1. Введение
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: 60a5090814b722cc0d9f6e51ab9038e697a4ed2a
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231654"
---
# <a name="1-introduction"></a>1. Введение

В этом документе указывается коллекция директив компилятора, библиотечных функций и переменных среды, которые можно использовать для указания параллелизма общей памяти в программах C и C++. Функциональные возможности, описанные в этом документе, вместе называются *интерфейсом прикладного программирования (API) OpenMP C/C++*. Цель этой спецификации — предоставить модель для параллельного программирования, которая позволяет выполнять перенос программы в архитектурах с общей памятью от разных поставщиков. Компиляторы от многих поставщиков поддерживают API OpenMP C/C++. Дополнительные сведения об OpenMP, включая *интерфейс программы OpenMP*на уровне приложения, можно найти на следующем веб-сайте:

[https://www.openmp.org](https://www.openmp.org)

Директивы, библиотечные функции и переменные среды, определенные в этом документе, позволяют создавать параллельные программы и управлять ими, обеспечивая переносимость. Директивы расширяют программную модель последовательного программирования C и C++ с помощью конструкций с несколькими данными (SPMD), конструкций совместного использования и конструкций синхронизации. Они также поддерживают совместное использование и приватизацией данных. Компиляторы, поддерживающие API OpenMP C и C++, включают параметр командной строки для компилятора, который активирует и позволяет интерпретировать все директивы компилятора OpenMP.

## <a name="11-scope"></a>1.1 Область

В этой спецификации рассматривается только ориентированное на пользователей параллелизации, где явно определяются действия, выполняемые компилятором и системой времени выполнения для параллельного выполнения программы. Реализации OpenMP C и C++ не требуют проверки наличия зависимостей, конфликтов, взаимоблокировок, состояний гонки или других проблем, приводящих к неправильному выполнению программы. Вы несете ответственность за то, чтобы приложение, использующее конструкции API OpenMP C и C++, выполнялось правильно. Создаваемые компилятором Автоматические параллелизации и директивы компилятору для помощи в этом документе не рассматриваются.

## <a name="12-definition-of-terms"></a>1,2 определение терминов

В этом документе используются следующие термины:

- barrier

  Точка синхронизации, к которой должны обращаться все потоки в команде.  Каждый поток ожидает, пока все потоки в команде не попадают в этот момент. Существуют явные барьеры, определяемые директивами и неявными барьерами, созданными реализацией.

- construct

  Конструкция — это оператор. Он состоит из директивы, за которой следует структурированный блок. Некоторые директивы не являются частью конструкции. (См. *директиву OpenMP* в [приложении C](c-openmp-c-and-cpp-grammar.md)).

- директива

  C или C++, `#pragma` за которым следует `omp` идентификатор, другой текст и новая строка. Директива задает поведение программы.

- Динамическая область

  Все операторы в *лексической области*и любая инструкция внутри функции, которая выполняется в результате выполнения инструкций внутри лексического экстента. Динамическая область также называется *регионом*.

- лексическая область

  Операторы лексического удержания в *структурированном блоке*.

- Главный поток

  Поток, создающий команду при входе в *параллельную область* .

- Параллельная область

  Инструкции, которые привязаны к параллельной конструкции OpenMP и могут выполняться многими потоками.

- private

  Частная переменная именует блок хранилища, уникальный для потока, который делает ссылку. Существует несколько способов указать, что переменная является закрытой: определение в параллельной области, `threadprivate` директива, предложение,, `private` `firstprivate` `lastprivate` или `reduction` , или использование переменной **`for`** в качестве переменной цикла в **`for`** цикле сразу после `for` `parallel for` директивы или.

- region

  Динамический экстент.

- регион последовательного порта

  Операторы выполняются только *главным потоком* за пределами динамической *области любого параллельного региона*.

- serialize

  Для выполнения параллельной конструкции с:

  - Группа потоков, состоящая только из одного потока (который является главным потоком для этой параллельной конструкции),

  - последовательный порядок выполнения для операторов в структурированном блоке (тот же порядок, как если бы блок не был частью параллельной конструкции) и

  - не влияет на значение, возвращаемое `omp_in_parallel()` (помимо влияния любых вложенных параллельных конструкций).

- общие

  Общая переменная именует один блок хранилища. Все потоки в команде, обращающиеся к этой переменной, также обращаются к этому единственному блоку хранилища.

- структурированный блок

  Структурированный блок является оператором (одиночным или составным) с одной записью и одним выходом. Если имеется переход в оператор или из него, то этот оператор является структурированным блоком. (Это правило включает вызов `longjmp` (3C) или использование `throw` , хотя вызов `exit` разрешен.) Если его выполнение всегда начинается с открывающего элемента `{` и всегда заканчивается на закрывающем `}` , составной оператор является структурированным блоком. Оператор выражения, оператор выбора, оператор итерации или **`try`** блок являются структурированным блоком, если соответствующая составная инструкция, полученная путем ее включения в и, является `{` `}` структурированным блоком. Оператор перехода, помеченный оператором или оператор объявления не является структурированным блоком.

- команда

  Один или несколько потоков, работающих при выполнении конструкции.

- поток

  Сущность выполнения с последовательным потоком управления, набором частных переменных и доступом к общим переменным.

- переменная

  Идентификатор, при необходимости уточненный именем пространства имен, который именует объект.

## <a name="13-execution-model"></a>модель выполнения 1,3

В OpenMP используется модель параллельного выполнения с разветвленным соединением. Хотя эта модель разветвления может быть полезной для решения различных задач, она предназначена для больших приложений на основе массивов. OpenMP предназначен для поддержки программ, которые правильно работают как параллельные программы (многие потоки выполнения и полную библиотеку поддержки OpenMP). Она также применяется для программ, которые правильно выполняются как последовательные программы (директивы игнорируются и простая библиотека заглушек OpenMP). Однако возможно и разрешается разрабатывать программу, которая не работает должным образом при последовательном выполнении. Более того, различные степени параллелизма могут привести к различным числовым результатам из-за изменений в сопоставлении числовых операций. Например, снижение последовательного сложения может иметь другой шаблон связей сложения, чем снижение параллельности. Эти различные ассоциации могут изменить результаты сложения с плавающей точкой.

Программа, написанная с помощью API OpenMP C/C++, начинает выполнение как отдельный поток выполнения, называемый *главным потоком*. Главный поток выполняется в последовательном регионе до тех пор, пока не будет обнаружена первая параллельная конструкция. В API OpenMP C/C++ `parallel` директива представляет собой параллельную конструкцию. При обнаружении параллельной конструкции главный поток создает группу потоков, и главный проект становится главным участником группы. Каждый поток в группе выполняет инструкции в динамическом экстенте параллельной области, за исключением конструкций совместного использования. Все потоки в команде должны столкнуться с конструкциями совместной работы в том же порядке, а один или несколько потоков выполняют инструкции в связанном структурированном блоке. Барьер, подразумеваемый в конце конструкции совместного использования, без предложения, `nowait` выполняется всеми потоками в группе.

Если поток изменяет общий объект, он влияет не только на собственную среду выполнения, но и на другие потоки в программе. Это изменение будет гарантированно завершено с точки зрения другого потока в следующей точке последовательности (как определено на базовом языке) только в том случае, если объект объявлен как volatile. В противном случае изменение гарантированно завершится после первого изменения потока. Другие потоки затем (или параллельно) видят `flush` директиву, которая указывает объект (неявно или явно). Если `flush` директивы, подразумеваемые другими директивами OpenMP, не гарантируют правильного упорядочения побочных эффектов, программист обязан предоставить дополнительные явные `flush` директивы.

После завершения параллельной конструкции потоки в команде синхронизируются в неявном барьере, и только главный поток продолжит выполнение. В одной программе можно указать любое количество параллельных конструкций. В результате программа может подключаться и присоединяться много раз во время выполнения.

API OpenMP C/C++ позволяет программистам использовать директивы в функциях, вызываемых из параллельных конструкций. Директивы, которые не отображаются в лексической области параллельной конструкции, но могут находиться в динамической области, называются *потерянными* директивами. Благодаря потерянным директивам программисты могут выполнять основные части своей программы параллельно, при этом только минимальные изменения в последовательной программе. С помощью этой функции можно программировать параллельные конструкции на верхних уровнях дерева вызовов программы и использовать директивы для управления выполнением в любой из вызываемых функций.

Несинхронизированные вызовы выходных функций C и C++, которые выполняют запись в один и тот же файл, могут привести к выходу, в котором данные, записанные различными потоками, отображаются в недетерминированном порядке. Аналогичным образом, несинхронизированные вызовы функций ввода, которые считывают из одного и того же файла, могут считывать данные в недетерминированном порядке. Несинхронизированное использование операций ввода-вывода, чтобы каждый поток получал доступ к другому файлу, выдает те же результаты, что и последовательное выполнение функций ввода-вывода.

## <a name="14-compliance"></a>1.4 Совместимость

Реализация API OpenMP C/C++ совместима с *OpenMP* , если он распознает и сохраняет семантику всех элементов данной спецификации, как описано в главах 1, 2, 3, 4 и приложение C. приложения A, B, D, E и F в предназначены только для информационных целей и не являются частью спецификации. Реализации, включающие только подмножество API, не соответствуют OpenMP.

API OpenMP C и C++ является расширением базового языка, поддерживаемого реализацией. Если базовый язык не поддерживает конструкцию языка или расширение, которое отображается в этом документе, реализация OpenMP не требуется для ее поддержки.

Все функции библиотеки Standard C и C++ и встроенные функции (то есть функции, для которых компилятор имеет определенные знания) должны быть потокобезопасными. Несинхронизированное использование потокобезопасных функций в разных потоках внутри параллельной области не приводит к неопределенному поведению. Однако поведение может отличаться от поведения в последовательном регионе. (Примером является функция генерации случайных чисел.)

API OpenMP C/C++ указывает, что определенное поведение *определяется реализацией.* Для определения и документирования его поведения в таких случаях требуется соответствующая реализация OpenMP. Список поведения, определяемых реализацией, см. в [приложении E](e-implementation-defined-behaviors-in-openmp-c-cpp.md).

## <a name="15-normative-references"></a>1,5 Нормативные ссылки

- ISO/IEC 9899:1999, *информационные технологии — языки программирования — C*. Эта спецификация API OpenMP ссылается на ISO/IEC 9899:1999 как C99.

- ISO/IEC 9899:1990, *информационные технологии — языки программирования — C*. Эта спецификация API OpenMP ссылается на ISO/IEC 9899:1990 как C90.

- ISO/IEC 14882:1998, *информационные технологии — языки программирования — C++*. Эта спецификация API OpenMP относится к ISO/IEC 14882:1998 как C++.

Если эта спецификация API OpenMP ссылается на C, то ссылка делается на базовый язык, поддерживаемый реализацией.

## <a name="16-organization"></a>1.6 Организация

- [Функции библиотеки среды выполнения](3-run-time-library-functions.md)
- [Переменные среды](4-environment-variables.md)
- [Поведения, определяемые реализацией, в OpenMP C/C++](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [Новые возможности в OpenMP C/C++ версии 2,0](f-new-features-and-clarifications-in-version-2-0.md)
