---
title: Написание многопотоковой программы Win32
ms.date: 11/04/2016
helpviewer_keywords:
- thread stacks [C++]
- resources [C++], multithreading
- stacks [C++]
- shared resources [C++]
- threading [C++], sharing common resources
- multithreading [C++], thread stacks
- multithreading [C++], sharing common resources
- mutual exclusion [C++]
- communications [C++], between threads
- mutex [C++]
- threading [C++], thread stacks
ms.assetid: 1415f47d-417f-4f42-949b-946fb28aab0e
ms.openlocfilehash: c7d9790cfee39fbddd9ab545d48fa375d56f3a05
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50561334"
---
# <a name="writing-a-multithreaded-win32-program"></a>Написание многопотоковой программы Win32

При написании программы с несколькими потоками, необходимо скоординировать их поведение и [использования ресурсов программы](#_core_sharing_common_resources_between_threads). Также необходимо убедиться в том, что каждый поток получает [собственный стек](#_core_thread_stacks).

##  <a name="_core_sharing_common_resources_between_threads"></a> Совместное использование общих ресурсов между потоками

> [!NOTE]
>  Описание аналогичных проблем с точки зрения MFC см. в разделе [Многопоточность: советы по программированию](multithreading-programming-tips.md) и [Многопоточность: использование классов синхронизации](multithreading-when-to-use-the-synchronization-classes.md).

Каждый поток имеет собственный стек и регистрирует свою собственную копию ЦП. Другие ресурсы, такие как файлы, статические данные и память в куче, являются общими для всех потоков в процессе. Потоки, использующие общие ресурсы должны быть синхронизированы. Win32 предоставляет несколько способов синхронизации ресурсов, включая семафоры, события, мьютексы и критические.

Когда несколько потоков обращаются статические данные, необходимо указать программы для возможные конфликты. Рассмотрим программу, когда один поток обновляет статические данные структура, содержащая *x*,*y* координаты для элементов для отображения другим потоком. Если поток обновления изменяет *x* координации и прерывается до изменения *y* координат, поток отображения может быть запланировано до выполнения *y* координаты обновлены. Элемент будет отображаться в неправильном месте. Этой проблемы можно избежать с помощью семафоры для управления доступом к структуре.

Мьютекс (сокращенно *сокращение от mut*ual *ex*clusion) — это способ взаимодействия между потоками и процессами, которые выполняются асинхронно. Это взаимодействие обычно используется для координации действий, несколько потоков или процессов, как правило, контролируя доступ к общему ресурсу, открывая и закрывая ресурса. Чтобы решить эту проблему *x*,*y* проблему обновления координат, поток обновления задает мьютекс, указывающее, что структуры данных используется перед выполнением обновления. Он сбросит мьютекс после обе координаты будут обработаны. Отображение потока необходимо дождаться мьютекса, чтобы пояснить, перед обновлением экрана. Этот процесс ожидания мьютекса часто называется блокировкой мьютекса, так как процесс будет заблокирован и не может выполняться до очищает мьютекса.

В программе Bounce.c на [Пример многопоточной программы на C](sample-multithread-c-program.md) используется мьютекс `ScreenMutex` для координации обновления экрана. Каждый раз, один из потоков отображения готов для записи на экран, он вызывает `WaitForSingleObject` с дескриптором для `ScreenMutex` и постоянное INFINITE, чтобы указать, что `WaitForSingleObject` вызов должен блокироваться на мьютексом, а также время ожидания не истекает. Если `ScreenMutex` очевидно, функция ожидания устанавливает его, чтобы другие потоки не может взаимодействовать с отображением и продолжает выполнение потока. В противном случае поток блокируется до очищает мьютекса. По завершении обновления дисплея поток освобождает мьютекс, вызвав `ReleaseMutex`.

Отображает экран и статические данные — это только два ресурсы, требующие тщательного управления. Например программа может быть несколько потоков, доступ к тот же файл. Так как другой поток может перемещать указатель файла, каждый поток необходимо сбросить указатель файла перед считыванием или записью. Кроме того каждый поток необходимо убедиться в том, не прерван между временем устанавливает указатель и времени, он обращается к файлу. Эти потоки должны использовать семафор для управления доступом к файлу с файл `WaitForSingleObject` и `ReleaseMutex` вызовов. В следующем примере кода показан этот принцип.

```
HANDLE    hIOMutex= CreateMutex (NULL, FALSE, NULL);

WaitForSingleObject( hIOMutex, INFINITE );
fseek( fp, desired_position, 0L );
fwrite( data, sizeof( data ), 1, fp );
ReleaseMutex( hIOMutex);
```

##  <a name="_core_thread_stacks"></a> Стеки потоков

Все пространство стека приложения по умолчанию выделяется первый поток выполнения, который известен как поток 1. Таким образом необходимо указать, какой объем памяти, выделяемой для стека в каждый дополнительный поток программы требуется. Операционная система выделяет пространство дополнительных стека для потока, при необходимости, но необходимо указать значение по умолчанию.

Первый аргумент в `_beginthread` вызов — это указатель на `BounceProc` функцию, которая выполняет потоки. Второй аргумент задает размер стека по умолчанию для потока. Последний аргумент — это номер идентификатора, который передается `BounceProc`. `BounceProc` Чтобы задать начальное значение генератора случайных чисел, а также для выбора атрибута цвета потока и отображается знак использует этот идентификатор.

Потоки, которые выполняют вызовы Win32 API или библиотеки времени выполнения C предусматривают достаточного пространства стека для библиотеки и функций API. C `printf` функции требуется более 500 байт стекового пространства, и необходимо 2 K доступного пространства стека при вызове процедуры Win32 API.

Так как каждый поток имеет собственный стек, можно избежать потенциальных конфликтов за элементов данных, используя в качестве меньше статических данных возможно. Составьте программу использовать автоматические переменные стека для всех данных, которые могут быть частной для потока. Только глобальные переменные в программе Bounce.c являются мьютексы и переменные, которые не изменяются после их инициализации.

Win32 также предоставляет хранилище локального потока (TLS) для хранения отдельного потока данных. Дополнительные сведения см. в разделе [локальное хранилище потока (TLS)](thread-local-storage-tls.md).

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C с помощью функций Win32](multithreading-with-c-and-win32.md)