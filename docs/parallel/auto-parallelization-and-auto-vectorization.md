---
title: Автоматическая параллелизация и автоматическая векторизация
ms.date: 11/04/2016
ms.assetid: ec71583a-287b-4599-8767-1d255e080fe3
ms.openlocfilehash: adc0dd9346cc2850b02e01804e26044c367f2d14
ms.sourcegitcommit: fcc3aeb271449f8be80348740cffef39ba543407
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/29/2020
ms.locfileid: "82538612"
---
# <a name="auto-parallelization-and-auto-vectorization"></a>Автоматическая параллелизация и автоматическая векторизация

Автоматический параллелизатор и автоматический векторизатор обеспечивают автоматическое повышение производительности циклов в коде.

## <a name="auto-parallelizer"></a>Автоматический параллелизатор

Параметр компилятора [/Qpar](../build/reference/qpar-auto-parallelizer.md) включает *автоматическую параллелизации* циклов в коде. Если установить этот флажок без изменения существующего кода, компилятор проанализирует код, чтобы выявить циклы, выполнение которых можно ускорить благодаря параллелизации. Компилятор может обнаружить циклы, которые не представляют большую нагрузку и по которым не получается выигрыш от параллелизации. Для организации параллелизации может потребоваться создание пула потоков, дополнительная синхронизация или другая обработка, которая вместо повышения производительности может привести к ее снижению. Поэтому компилятор строго оценивает возможность выигрыша при выборе циклов для параллелизации. Например, рассмотрим случай, в котором верхняя граница цикла неизвестна во время компиляции.

```cpp
void loop_test(int u) {
   for (int i=0; i<u; ++i)
      A[i] = B[i] * C[i];
}
```

Поскольку значение `u` может быть маленьким, компилятор не будет выполнять автоматическую параллелизацию этого цикла. Допустим, вам известно, что значение `u` всегда будет большим и параллелизацию этого цикла желательно выполнить. Чтобы включить автоматическую параллелизации, укажите [цикл #pragma (hint_parallel (n))](../preprocessor/loop.md), где — число `n` потоков, по которым будет осуществляться параллельный режим. В приведенном ниже примере компилятор попытается выполнить параллелизацию цикла по 8 потокам.

```cpp
void loop_test(int u) {
#pragma loop(hint_parallel(8))
   for (int i=0; i<u; ++i)
      A[i] = B[i] * C[i];
}
```

Как и все [директивы pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md), также поддерживается альтернативный `__pragma(loop(hint_parallel(n)))` синтаксис директивы pragma.

Существуют такие циклы, для которых компилятор не сможет выполнить параллелизацию, даже если вы захотите это сделать. Пример:

```cpp
#pragma loop(hint_parallel(8))
for (int i=0; i<upper_bound(); ++i)
    A[i] = B[i] * C[i];
```

Функция `upper_bound()` может меняться при каждом вызове. Поскольку верхняя граница неизвестна, компилятор может вывести диагностическое сообщение, объясняющее, почему он не может выполнить параллелизацию этого цикла. В приведенном ниже примере демонстрируется цикл, в котором может выполняться параллелизация, цикл, в котором не может выполняться параллелизация, синтаксис компилятора для командной строки и выходные данные компилятора для каждого параметра командной строки:

```cpp
int A[1000];
void test() {
#pragma loop(hint_parallel(0))
    for (int i=0; i<1000; ++i) {
        A[i] = A[i] + 1;
    }

    for (int i=1000; i<2000; ++i) {
        A[i] = A[i] + 1;
    }
}
```

При компиляции с помощью команды:

`cl d:\myproject\mylooptest.cpp /O2 /Qpar /Qpar-report:1`

получаются следующие выходные данные:

```Output
--- Analyzing function: void __cdecl test(void)
d:\myproject\mytest.cpp(4) : loop parallelized
```

При компиляции с помощью команды:

`cl d:\myproject\mylooptest.cpp /O2 /Qpar /Qpar-report:2`

получаются следующие выходные данные:

```Output
--- Analyzing function: void __cdecl test(void)
d:\myproject\mytest.cpp(4) : loop parallelized
d:\myproject\mytest.cpp(4) : loop not parallelized due to reason '1008'
```

Обратите внимание на разницу в выводе между двумя различными параметрами [/Qpar-report (Auto-Параллелизатора Reporting Level)](../build/reference/qpar-report-auto-parallelizer-reporting-level.md) . `/Qpar-report:1` выводит сообщения параллелизатора только для тех циклов, параллелизация которых успешно выполнена. `/Qpar-report:2` выводит сообщения параллелизатора как для выполненных, так и для невыполненных параллелизаций цикла.

Дополнительные сведения о кодах причин и сообщениях см. в разделе [сообщения векторизатора и параллелизатора](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md).

## <a name="auto-vectorizer"></a>Автоматический векторизатор

Автоматический векторизатор анализирует циклы в коде и использует векторные регистры и инструкции на целевом компьютере для их выполнения, если это возможно. Это может повысить производительность кода. Компилятор обращается к инструкциям SSE2, AVX и AVX2 в процессорах Intel или AMD или инструкциях NEON на процессорах ARM в соответствии с параметром [/Arch](../build/reference/arch-minimum-cpu-architecture.md) .

Автоматический векторизатор может создавать инструкции, отличные от указанных в переключателе `/arch`. Эти инструкции защищены проверкой среды выполнения, гарантирующей, что код все еще работает правильно. Например, при компиляции `/arch:SSE2` могут быть выданы инструкции SSE4.2. При проверке среды выполнения проверяется, что инструкция SSE4.2 доступна на целевом процессоре, и осуществляется переход к версии цикла, отличной от SSE4.2, если процессор не поддерживает эти инструкции.

По умолчанию автоматический векторизатор включен. Если необходимо сравнить производительность кода при использовании векторной обработки, можно использовать [цикл #pragma (no_vector)](../preprocessor/loop.md) для отключения вектора любого заданного цикла.

```cpp
#pragma loop(no_vector)
for (int i = 0; i < 1000; ++i)
   A[i] = B[i] + C[i];
```

Как и все [директивы pragma](../preprocessor/pragma-directives-and-the-pragma-keyword.md), также поддерживается альтернативный `__pragma(loop(no_vector))` синтаксис директивы pragma.

Как и в случае с Auto-Параллелизатора, можно указать параметр командной строки [/Qvec-report (Auto-векторизатора Reporting Level)](../build/reference/qvec-report-auto-vectorizer-reporting-level.md) , чтобы сообщить либо об успешном векторном`/Qvec-report:1`цикле, либо как успешно, так и в неуспешном векторном цикле —`/Qvec-report:2`).

Дополнительные сведения о кодах причин и сообщениях см. в разделе [сообщения векторизатора и параллелизатора](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md).

Пример, демонстрирующий работу векторизатора на практике, см. в разделе [Project Остин часть 2 из 6: Залистывание страниц](https://devblogs.microsoft.com/cppblog/project-austin-part-2-of-6-page-curling/)

## <a name="see-also"></a>См. также

[повторить](../preprocessor/loop.md)<br/>
[Параллельное программирование в машинном коде](/archive/blogs/nativeconcurrency)<br/>
[/Qpar (авто-Параллелизатора)](../build/reference/qpar-auto-parallelizer.md)<br/>
[/Qpar-report (автоматический уровень отчетов Параллелизатора)](../build/reference/qpar-report-auto-parallelizer-reporting-level.md)<br/>
[/Qvec-report (автоматический уровень отчетов векторизатора)](../build/reference/qvec-report-auto-vectorizer-reporting-level.md)<br/>
[Сообщения векторизатора и Параллелизатора](../error-messages/tool-errors/vectorizer-and-parallelizer-messages.md)
