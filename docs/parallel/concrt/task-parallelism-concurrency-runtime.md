---
title: Параллелизм задач (среда выполнения с параллелизмом)
ms.date: 11/04/2016
helpviewer_keywords:
- structured task groups [Concurrency Runtime]
- structured tasks [Concurrency Runtime]
- task groups [Concurrency Runtime]
- task parallelism
- tasks [Concurrency Runtime]
ms.assetid: 42f05ac3-2098-494a-ba84-737fcdcad077
ms.openlocfilehash: f65521771db3eb0fe19dc863b1b49e9627fc60e6
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81368591"
---
# <a name="task-parallelism-concurrency-runtime"></a>Параллелизм задач (среда выполнения с параллелизмом)

В Параллельном Runtime *задача* представляет собой единицу работы, выполняя определенную задачу и обычно выполняемую параллельно с другими задачами. Задача может быть разложена на дополнительные, более мелкозернистые задачи, которые организованы в *целевую группу.*

Задачи используются, когда при создании асинхронного кода требуется, чтобы после завершения асинхронной операции выполнялись некоторые операции. Например, можно использовать задачу для асинхронного чтения из файла, а затем использовать другую задачу — *задачу продолжения,* которая объясняется позже в этом документе — для обработки данных после их появления. И наоборот, можно использовать группы задач для разбиения параллельной работы на более мелкие части. Например, предположим, что имеется рекурсивный алгоритм, разделяющий оставшуюся работу на два раздела. С помощью групп задач вы можете одновременно запустить эти разделы, а затем подождать, пока выполнится эта разделенная задача.

> [!TIP]
> Если вы хотите применить ту же рутину к каждому элементу коллекции параллельно, используйте параллельный алгоритм, [например, параллелизм: :parallel,](reference/concurrency-namespace-functions.md#parallel_for)вместо задачи или группы задач. Для получения дополнительной информации [Parallel Algorithms](../../parallel/concrt/parallel-algorithms.md)о параллельных алгоритмах см.

## <a name="key-points"></a>Основные моменты

- При передаче переменных в лямбда-выражение по ссылке необходимо обеспечить сохранение существования этой переменной до завершения задачи.

- При написании асинхронного кода используйте задачи [(параллелизм::класс задачи).](../../parallel/concrt/reference/task-class.md) Класс задач использует в качестве своего планировщика Windows ThreadPool (пул потоков Windows), а не среду выполнения с параллелизмом.

- Используйте группы задач [(параллелизм::task_group](reference/task-group-class.md) класс или [алгоритм параллелизма: :pаралэле-ввоковалгоритм),](reference/concurrency-namespace-functions.md#parallel_invoke) когда требуется разложить параллельную работу на более мелкие части, а затем ждать завершения этих меньших частей.

- Используйте [параллел::task::тогда](reference/task-class.md#then) метод создания продолжений. *Продолжение* — это задача, которая выполняется асинхронно после завершения другой задачи. Вы можете подключать любое количество продолжений для формирования цепочки асинхронной работы.

- Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение.

- Используйте [параллелизм::when_all](reference/concurrency-namespace-functions.md#when_all) создать задачу, которая завершается после завершения каждого члена набора задач. Используйте [параллелизм::when_any](reference/concurrency-namespace-functions.md#when_any) создать задачу, которая завершается после завершения одного из членов набора задач.

- Задачи и группы задач могут участвовать в механизме отмены библиотеки параллельных шаблонов (PPL). Для получения дополнительной [информации см.](cancellation-in-the-ppl.md)

- Чтобы узнать, как время выполнения обрабатывает исключения, брошенные [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)задачами и группами задач, см.

## <a name="in-this-document"></a>В этом документе

- [Использование лямбда-выражений](#lambdas)

- [Класс task](#task-class)

- [Задачи продолжения](#continuations)

- [Сравнение продолжения на основе значения и на основе задачи](#value-versus-task)

- [Составление задач](#composing-tasks)

  - [Функция when_all](#when-all)

  - [Функция when_any](#when-any)

- [Отложенное выполнение задач](#delayed-tasks)

- [Группы задач](#task-groups)

- [Сравнение task_group и structured_task_group](#comparing-groups)

- [Пример](#example)

- [Надежное программирование](#robust)

## <a name="using-lambda-expressions"></a><a name="lambdas"></a>Использование выражений Lambda

Благодаря их лаконичному синтаксису лямбда-выражения часто используют для определения операций, выполняемых задачами и группами задач. Ниже приведены некоторые советы по использованию.

- Поскольку задачи обычно выполняются в фоновых потоках, помните о времени существования объекта при включении переменных в лямбда-выражения. При вводе переменной по значению в тексте лямбда-выражения создается копия этой переменной. При вводе по ссылке копия не создается. Следовательно, необходимо убедиться, что время существования любой введенной по ссылке переменной превышает время существования задачи, которая ее использует.

- Когда вы передаете выражение лямбда задаче, не фиксируете переменные, которые выделены в стеке по ссылке.

- Четко освящейся переменных, которые вы захватываете в выражениях lambda, чтобы определить, что вы захватываете по значению по сравнению с ссылкой. По этой причине рекомендуется не использовать параметры `[=]` или `[&]` для лямбда-выражений.

Распространенный подход заключается в том, что одна задача в цепочке продолжения назначает переменную, а другая задача читает эту переменную. Вы не можете захватить по значению, потому что каждая задача продолжения будет содержать различную копию переменной. Для распределенных стегов переменных вы также не можете захватить по ссылке, поскольку переменная может больше не быть действительной.

Чтобы решить эту проблему, используйте смарт-указатель, например [std::shared_ptr,](../../standard-library/shared-ptr-class.md)чтобы обернуть переменную и передать смарт-указатель по стоимости. Таким образом этот базовый объект можно назначать и читать, и срок его существования будет превышать срок существования задач, которые его используют. Используйте этот метод даже в том случае, если переменная является указателем или дескриптором с подсчетом ссылок (`^`) объекта среды выполнения Windows. Простой пример:

[!code-cpp[concrt-lambda-task-lifetime#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_1.cpp)]

Для получения дополнительной информации о выражениях lambda, см [Lambda Выражения](../../cpp/lambda-expressions-in-cpp.md).

## <a name="the-task-class"></a><a name="task-class"></a>Класс задач

Можно использовать [параллелиз::класс задач](../../parallel/concrt/reference/task-class.md) для создания задач в набор зависимых операций. Эта модель композиции поддерживается понятием *продолжения.* Продолжение позволяет выполнять код при завершении предыдущей или *предшествующей*задачи. Результат предшествующей задачи передается в качестве входных данных в одну или несколько задач продолжения. По завершении предшествующей задачи все ожидающие ее задачи продолжения планируются для выполнения. Каждая задача продолжения получает копию результатов предшествующей задачи. В свою очередь, эти задачи продолжения также могут быть предшествующими задачами для других продолжений, тем самым создавая цепочки задач. Продолжения помогают создавать цепочки задач произвольной длины с определенными зависимостями между входящими в них задачами. Кроме того, задача может участвовать в отмене либо до запуска, либо совместно во время выполнения. Для получения дополнительной информации об этой модели отмены [см.](cancellation-in-the-ppl.md)

`task` является классом шаблона. Параметр типа `T` — это тип результата, созданного задачей. Это может быть тип `void`, если задача не возвращает значение. Параметр `T` не может использовать модификатор `const`.

При создании задачи обеспечивается *рабочая функция,* выполняемый органом задачи. Эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Чтобы дождаться завершения задачи, не получив результата, позвоните в [параллел::task:::wait](reference/task-class.md#wait) method. Метод `task::wait` возвращает [параллелизм::task_status](reference/concurrency-namespace-enums.md#task_group_status) значение, описывая ли задача была выполнена или отменена. Чтобы получить результат задачи, позвоните в [параллел::задача:::Получить](reference/task-class.md#get) метод. Этот метод вызывает метод `task::wait` для ожидания завершения задачи и таким образом блокирует выполнение текущего потока, пока не станет доступен результат.

В следующем примере показано, как создать задачу, дождаться ее результата и отобразить полученное значение. В примерах в этой документации используются лямбда-функции, поскольку они обеспечивают более лаконичный синтаксис. Однако при использовании задач вы также можете применять указатели функций и объекты функций.

[!code-cpp[concrt-basic-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_2.cpp)]

При использовании [параллелизма::create_task](reference/concurrency-namespace-functions.md#create_task) функции, вы можете использовать ключевое `auto` слово вместо объявления типа. Например, рассмотрим следующий код, который создает и печатает матрицу тождественности.

[!code-cpp[concrt-create-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_3.cpp)]

Вы можете использовать функцию `create_task` для создания эквивалентной операции.

[!code-cpp[concrt-create-task#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_4.cpp)]

Если во время выполнения задачи возникает исключение, среда выполнения маршалирует исключение в последующий вызов метода `task::get` или `task::wait`, или в продолжение на основе задачи. Для получения дополнительной информации о механизме обработки исключений задачи [см.](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)

Для примера, `task`который использует, [параллелизм::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md), отмена, см. [Подключите: Подключение С помощью задач и XML HTTP Запросы.](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md) (Класс `task_completion_event` описывается далее в этом документе.)

> [!TIP]
> Чтобы узнать подробности, характерные [для](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md)задач в приложениях UWP, [см.](/windows/uwp/threading-async/asynchronous-programming-in-cpp-universal-windows-platform-apps)

## <a name="continuation-tasks"></a><a name="continuations"></a>Задачи продолжения

В асинхронном программировании очень распространено при завершении одной асинхронной операции вызывать вторую операцию и передавать в нее данные. Как правило, это делается с помощью методов обратного вызова. В Concurrency Runtime такая же функциональность обеспечивается *задачами продолжения.* Задача продолжения (также известная как продолжение) — это асинхронная задача, вызываемый другой задачей, которая известна как *предшествующая,* когда предшествующая завершается. С помощью продолжений вы можете делать следующее.

- Передавать данные из предшествующей задачи в продолжение.

- Указывать точные условия, при которых продолжение вызывается или не вызывается.

- Отменять продолжение перед его запуском либо совместно во время его выполнения.

- Определять подсказки, как должно планироваться продолжение. (Это относится только к универсальным приложениям платформы Windows (UWP). Для получения дополнительной информации [см. Создание асинхронных операций в СЗ для UWP Apps.)](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md)

- Вызывать несколько продолжений из одной и той же предшествующей задачи.

- Вызывать одно продолжение по завершении всех или одной из нескольких предшествующих задач.

- Прикреплять продолжения одно после другого до любой длины.

- Использовать продолжение для обработки исключений, вызванных предшествующей задачей.

Эти возможности позволяют выполнять одну или несколько задач после завершения первой задачи. Например, можно создать продолжение, которое сжимает файл после того, как первая задача прочитает этот файл с диска.

Следующий пример изменяет предыдущий для использования [параллелизма::task::then](reference/task-class.md#then) метод для планирования продолжения, который печатает значение предшествующей задачи, когда она доступна.

[!code-cpp[concrt-basic-continuation#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_5.cpp)]

Вы можете прикреплять и вкладывать задачи до любой длины. Задача также может иметь несколько продолжений. В следующем примере демонстрируется базовая цепочка продолжений, которая увеличивает значение предыдущей задачи три раза.

[!code-cpp[concrt-continuation-chain#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_6.cpp)]

Продолжение может также возвращать другую задачу. Если отмена отсутствует, то эта задача выполняется до последующего продолжения. Этот метод известен как *асинхронное распаковка.* Асинхронное развертывание удобно использовать, когда требуется выполнить дополнительную работу в фоновом режиме, но так, чтобы текущая задача не блокировала текущий поток. (Это часто встречается в приложениях UWP, где продолжения могут работать на потоке uI). В следующем примере показаны три задачи. Первая задача возвращает вторую задачу, которая выполняется перед задачей продолжения.

[!code-cpp[concrt-async-unwrapping#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_7.cpp)]

> [!IMPORTANT]
> Когда продолжение задачи возвращает вложенную задачу типа `N`, результирующая задача имеет тип `N`, а не `task<N>`, и завершается при завершении вложенной задачи. Другими словами, продолжение выполняет развертывание вложенной задачи.

## <a name="value-based-versus-task-based-continuations"></a><a name="value-versus-task"></a>Продолжение на основе значений и задач

Принимая во внимание объект `task`, который имеет возвращаемый тип `T`, вы можете предоставить значение типа `T` или `task<T>` в соответствующие задачи продолжения. Продолжение, которое `T` принимает тип, известно как *продолжение, основанное на ценностях.* Продолжение на основе значения планируется для выполнения, когда предшествующая задача завершается без ошибок и не отменяется. Продолжение, которое `task<T>` принимает тип в качестве параметра, известно как *продолжение, основанное на задачах.* Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение. Затем можно вызвать `task::get`, чтобы получить результат предшествующей задачи. Если предшествующей задачи `task::get` была отменена, бросает [параллель::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). Если предшествующая задача выдала исключение, `task::get` повторно выдает это исключение. Продолжение на основе задачи не отмечается как отмененное, когда отменяется предшествующая задача.

## <a name="composing-tasks"></a><a name="composing-tasks"></a>Составление задач

В этом разделе описывается [параллел::when_all](reference/concurrency-namespace-functions.md#when_all) и [параллелизм::when_any](reference/concurrency-namespace-functions.md#when_all) функции, которые могут помочь вам составить несколько задач для реализации общих шаблонов.

### <a name="the-when_all-function"></a><a name="when-all"></a>Функция when_all

Функция `when_all` создает задачу, которая выполняется после завершения набора задач. Эта функция возвращает std::[векторный](../../standard-library/vector-class.md) объект, содержащий результат каждой задачи в наборе. В следующем базовом примере функция `when_all` используется для создания задачи, которая представляет завершение трех других задач.

[!code-cpp[concrt-join-tasks#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_8.cpp)]

> [!NOTE]
> Задачи, которые вы передаете в функцию `when_all`, должны быть единообразными. Другими словами, все они должны возвращать один и тот же тип.

Для создания задачи, выполняемой после завершения набора задач, можно также использовать синтаксис `&&`, как показано в следующем примере.

`auto t = t1 && t2; // same as when_all`

Обычно для выполнения действия после завершения набора задач используется продолжение вместе с функцией `when_all`. В следующем примере изменяется предыдущий пример для печати суммы трех задач, каждая из которых создает результат `int`.

[!code-cpp[concrt-join-tasks#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_9.cpp)]

В этом примере можно также указать `task<vector<int>>`, чтобы создать продолжение на основе задачи.

Если какая-либо из задач в наборе задач отменяется или порождает исключение, `when_all` немедленно завершается и не ждет завершения выполнения оставшихся задач. Если выдается исключение, среда выполнения повторно выдает это исключение при вызове `task::get` или `task::wait` в объекте задачи, который возвращает `when_all`. Если исключение выдают несколько задач, среда выполнения выбирает одну из них. Поэтому убедитесь, что вы заметили все исключения после завершения всех задач; необработанное исключение задачи приведет к завершению работы приложения.

Вот утилита функция, которую можно использовать, чтобы убедиться, что ваша программа соблюдает все исключения. Для каждой задачи в указанном диапазоне эта служебная функция `observe_all_exceptions` запускает повторную выдачу каждого возникшего исключения, а затем поглощает это исключение.

[!code-cpp[concrt-eh-when_all#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_10.cpp)]

Рассмотрим приложение UWP, которое использует C и XAML и записывает набор файлов на диск. В следующем примере показано, как использовать функции `when_all` и `observe_all_exceptions`, чтобы убедиться, что программа обнаруживает все исключения.

[!code-cpp[concrt-eh-when_all#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_11.cpp)]

##### <a name="to-run-this-example"></a>Запуск примера

1. Добавьте в файл MainPage.xaml элемент управления `Button`.

[!code-xml[concrt-eh-when_all#3](../../parallel/concrt/codesnippet/xaml/task-parallelism-concurrency-runtime_12.xaml)]

1. В MainPage.xaml.h добавьте в раздел `private` объявления класса `MainPage` следующие предваряющие объявления.

[!code-cpp[concrt-eh-when_all#4](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_13.h)]

1. В MainPage.xaml.cpp реализуйте обработчик событий `Button_Click`.

[!code-cpp[concrt-eh-when_all#5](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_14.cpp)]

1. В MainPage.xaml.cpp реализуйте `WriteFilesAsync`, как показано в примере.

> [!TIP]
> Функция `when_all` является функцией без блокировки, в качестве результата создающей `task`. В отличие от [задачи::подождите,](reference/task-class.md#wait)это безопасно назвать эту функцию в приложении UWP на потоке ASTA (Application STA).

### <a name="the-when_any-function"></a><a name="when-any"></a>Функция when_any

Функция `when_any` создает задачу, которая выполняется после завершения первой задачи в наборе задач. Эта функция возвращает объект [std::pair,](../../standard-library/pair-structure.md) содержащий результат выполненной задачи и индекс этой задачи в наборе.

Функция `when_any` особенно полезна в следующих ситуациях.

- Избыточные операции. Рассмотрим алгоритм или операцию, которые можно выполнить несколькими способами. Функцию `when_any` можно использовать для выбора операции, которая завершается первой, и последующей отмены оставшихся операций.

- Операции с чередованием. Можно запустить несколько операций, которые все должны завершиться, и использовать функцию `when_any` для обработки результатов при завершении каждой операции. После завершения одной операции можно запустить одну или несколько дополнительных задач.

- Регулируемые операции. Функцию `when_any` можно использовать для расширения предыдущего сценария путем ограничения количества параллельных операций.

- Операции с истекшим сроком действия. Функцию `when_any` можно использовать, чтобы сделать выбор между одной или несколькими задачами и задачей, завершающейся после определенного времени.

Как и в случае с функцией `when_all`, обычно для выполнения действия после завершения первой задачи в наборе используется продолжение, имеющее функцию `when_any`. В следующем базовом примере функция `when_any` используется для создания задачи, которая выполняется после завершения первой из трех других задач.

[!code-cpp[concrt-select-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_15.cpp)]

В этом примере можно также указать `task<pair<int, size_t>>`, чтобы создать продолжение на основе задачи.

> [!NOTE]
> Как и при использовании функции `when_all`, задачи, которые вы передаете в `when_any`, должны возвращать один и тот же тип.

Для создания задачи, выполняемой после завершения первой задачи в наборе, можно также использовать синтаксис `||`, как показано в следующем примере.

`auto t = t1 || t2; // same as when_any`

> [!TIP]
> Как `when_all`и `when_any` в том, что это не блокирует и безопасно вызывать в приложении UWP на потоке ASTA.

## <a name="delayed-task-execution"></a><a name="delayed-tasks"></a>Задержка выполнения задачи

Иногда требуется отложить выполнение задачи до выполнения условия или запустить задачу в ответ на внешнее событие. Например, в асинхронном программировании может потребоваться запустить задачу в ответ на событие завершения операции ввода-вывода.

Два способа достижения этой задачи — использовать продолжение или запустить задачу и ждать события внутри рабочей функции задачи. Однако бывают случаи, когда невозможно использовать ни один из этих способов. Например, чтобы создать продолжение, необходимо иметь предшествующую задачу. Однако, если у вас нет задачи предшествующей задачи, можно создать *событие завершения задачи,* а затем цепочку события завершения к задаче предшествующей, когда оно станет доступным. Кроме того, поскольку ожидающая задача также блокирует поток, можно использовать события завершения задачи для выполнения работы при завершении асинхронной операции и тем самым освободить поток.

[Параллель::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) класс помогает упростить такой состав задач. Как и в классе `task`, параметр типа `T` — это тип результата, созданного задачей. Это может быть тип `void`, если задача не возвращает значение. Параметр `T` не может использовать модификатор `const`. Как правило, объект `task_completion_event` передается в поток или задачу, которые будут сообщать, когда значение для них станет доступным. В то же время одна или несколько задач устанавливаются в качестве прослушивателей этого события. Когда событие возникает, задачи прослушивателя выполняются и их продолжения планируются для запуска.

Например, для `task_completion_event` реализации задачи, выполняемых после задержки, см. [Как: Создайте задачу, которая завершается после задержки.](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)

## <a name="task-groups"></a><a name="task-groups"></a>Целевые группы

*Целевая группа* организует набор задач. Группы задач помещают задачи в очередь перехвата работы. Планировщик удаляет задачи из этой очереди и выполняет их с использованием доступных вычислительных ресурсов. После добавления задач в группу задач можно ожидать завершения всех задач или отменить задачи, которые еще не запускались.

PPL использует [параллелизм::task_group](reference/task-group-class.md) и [параллелизм::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) классов для представления групп задач, а [параллелизм::task_handle](../../parallel/concrt/reference/task-handle-class.md) класс для представления задач, которые выполняются в этих группах. Класс `task_handle` инкапсулирует код, выполняющий работу. Как и в случае класса `task`, эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Обычно не требуется работать с объектами `task_handle` напрямую. Вместо этого вы передаете рабочие функции в группу задач, а группа задач создает объекты `task_handle` и управляет ими.

PPL делит целевые группы на эти две категории: *неструктурированные целевые группы* и *структурированные целевые группы.* PPL использует класс `task_group` для представления неструктурированных групп задач и класс `structured_task_group` — для представления структурированных групп задач.

> [!IMPORTANT]
> PPL также определяет [алгоритм параллелизма::parallel'invoke,](reference/concurrency-namespace-functions.md#parallel_invoke) который использует `structured_task_group` класс для выполнения набора задач параллельно. Поскольку алгоритм `parallel_invoke` имеет более лаконичный синтаксис, рекомендуется по возможности использовать его вместо класса `structured_task_group`. Тема [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md) описывается `parallel_invoke` более подробно.

Используйте алгоритм `parallel_invoke`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, и перед продолжением необходимо дождаться завершения всех задач. Этот метод часто называют *вилкой и присоединиться к* параллелизму. Используйте алгоритм `task_group`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, но дождаться завершения всех задач требуется позднее. Например, вы можете добавить задачи в объект `task_group` и дожидаться завершения этих задач в другой функции или из другого потока.

Группы задач поддерживают принцип отмены. Отмена позволяет сообщить всем активным задачам, что необходимо отменить всю операцию. Отмена также предотвращает запуск задач, которые еще не начали выполняться. Для получения дополнительной информации об отмене, см [Отмена в PPL](cancellation-in-the-ppl.md).

Среда выполнения также предоставляет модель обработки исключений, которая позволяет вызывать исключение из задачи и обработать это исключение при ожидании завершения группы связанных задач. Для получения дополнительной информации об [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)этой модели обработки исключений см.

## <a name="comparing-task_group-to-structured_task_group"></a><a name="comparing-groups"></a>Сравнение task_group с structured_task_group

Несмотря на то что мы рекомендуем использовать `task_group` или `parallel_invoke` вместо класса `structured_task_group`, бывают ситуации, в которых вы захотите использовать класс `structured_task_group`, например при создании параллельного алгоритма, который выполняет переменное количество задач или которому требуется поддержка отмены. В этом разделе описываются различия между классами `task_group` и `structured_task_group`.

Класс `task_group` является потокобезопасным. Поэтому можно добавлять задачи в объект `task_group` из нескольких потоков и ожидать или отменять объект `task_group` из нескольких потоков. Создание и уничтожение объекта `structured_task_group` должно происходить в одной лексической области. Кроме того, все операции с объектом `structured_task_group` должны происходить в одном потоке. Исключением из этого правила является [параллель::structured_task_group:::отмена](reference/structured-task-group-class.md#cancel) и [параллел::structured_task_group:::is_canceling](reference/structured-task-group-class.md#is_canceling) методы. Дочерняя задача может вызывать эти методы для отмены родительской группы задач или проверки на предмет отмены в любое время.

Вы можете выполнить `task_group` дополнительные задачи на объекте после вызова [параллелизма::task_group:::Wait](reference/task-group-class.md#wait) или [параллел::task_group::run_and_wait](reference/task-group-class.md#run_and_wait) метод. И наоборот, если вы `structured_task_group` запустите дополнительные задачи на объекте после вызова [параллелизма::structured_task_group:::Wait](reference/structured-task-group-class.md#wait) или [параллел::structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait) методов, то поведение не определено.

Поскольку класс `structured_task_group` не синхронизируется в потоках, он имеет меньше затрат на выполнение, чем класс `task_group`. Таким образом, если проблема не требует планирования работы в нескольких потоках и нельзя использовать алгоритм `parallel_invoke`, класс `structured_task_group` класс может помочь написать более производительный код.

При использовании одного объекта `structured_task_group` внутри другого объекта `structured_task_group` внутренний объект должен быть завершен и уничтожен до завершения внешнего объекта. Класс `task_group` не требуется для завершения вложенных групп задач до завершения внешней группы.

Неструктурированные группы задач и структурированные группы задач работают с дескрипторами задач по-разному. Вы можете передавать рабочие функции непосредственно в объект `task_group`; объект `task_group` будет создавать дескриптор задач и управлять им. Класс `structured_task_group` требует, чтобы вы управляли объектом `task_handle` для каждой задачи. Каждый объект `task_handle` должен оставаться допустимым в течение всего времени существования связанного объекта `structured_task_group`. Используйте [параллелизм::make_task](reference/concurrency-namespace-functions.md#make_task) `task_handle` функцию для создания объекта, как показано в следующем базовом примере:

[!code-cpp[concrt-make-task-structure#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_16.cpp)]

Для обработки задач для случаев, когда у вас есть переменное количество задач, используйте процедуру распределения стеков, такую как [_malloca](../../c-runtime-library/reference/malloca.md) или класс контейнеров, например std::[вектор](../../standard-library/vector-class.md).

И `task_group`, и `structured_task_group` поддерживают отмену. Для получения дополнительной информации об отмене, см [Отмена в PPL](cancellation-in-the-ppl.md).

## <a name="example"></a><a name="example"></a>Примере

В следующем базовом примере показано, как работать с группами задач. В этом примере используется алгоритм `parallel_invoke` для выполнения двух задач одновременно. Каждая задача добавляет подзадачи в объект `task_group`. Обратите внимание, что класс `task_group` позволяет добавлять в него задачи одновременно нескольким задачам.

[!code-cpp[concrt-using-task-groups#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_17.cpp)]

Ниже приведен пример выходных данных для данного примера.

```Output
Message from task: Hello
Message from task: 3.14
Message from task: 42
```

Поскольку алгоритм `parallel_invoke` выполняет задачи параллельно, порядок выходных сообщений может меняться.

Для получения полных примеров, которые показывают, как использовать `parallel_invoke` алгоритм, см., [как: Используйте parallel_invoke, чтобы написать параллельный сортировки и](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) [как: Используйте parallel_invoke для выполнения параллельных операций.](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md) Для полного примера, который использует `task_group` класс для реализации асинхронных фьючерсов, см. [Walkthrough: Implementing Futures](../../parallel/concrt/walkthrough-implementing-futures.md)

## <a name="robust-programming"></a><a name="robust"></a>Надежное программирование

Убедитесь, что понимаете роль отмены и обработки исключений при использовании задач, групп задач и параллельных алгоритмов. Например, в дереве параллельной работы отмененная задача предотвращает запуск дочерних задач. Это может привести к проблемам, если одна из дочерних задач выполняет операцию, важную для приложения, например высвобождает ресурс. Кроме того, если дочерняя задача создает исключение, это исключение может распространиться через деструктор объекта и вызвать неопределенное поведение в приложении. Например, иллюстрирующий эти моменты, см. раздел [«Понять, как обработка объектов и исключение влияет на разрушение объектов»](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) в разделе «Лучшие практики в документе Библиотеки параллельных шаблонов». Для получения дополнительной информации о моделях отмены [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)и обработки исключений в PPL [см.](../../parallel/concrt/cancellation-in-the-ppl.md)

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Практическое руководство. Использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности алгоритма битонной сортировки.|
|[Как: Используйте parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности программы, выполняющей несколько операций с общим источником данных.|
|[Практическое руководство. Создание задачи, выполняемой после задержки](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)|Показывает, как `task`использовать `cancellation_token_source` `cancellation_token`, `task_completion_event` и классы для создания задачи, которая завершается после задержки.|
|[Пошаговое руководство. Реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md)|Показано, как объединить существующие функциональные возможности в среде выполнения с параллелизмом в то, что делает больше.|
|[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)|Описывается библиотека PPL, которая предоставляет императивную модель программирования для разработки параллельных приложений.|

## <a name="reference"></a>Справочник

[Класс task (среда выполнения с параллелизмом)](../../parallel/concrt/reference/task-class.md)

[Класс task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md)

[Функция when_all](reference/concurrency-namespace-functions.md#when_all)

[Функция when_any](reference/concurrency-namespace-functions.md#when_any)

[Класс task_group](reference/task-group-class.md)

[Функция parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke)

[Класс structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md)
