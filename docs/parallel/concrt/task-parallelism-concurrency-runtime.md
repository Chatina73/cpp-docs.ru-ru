---
title: Параллелизм задач (среда выполнения с параллелизмом)
ms.date: 11/04/2016
helpviewer_keywords:
- structured task groups [Concurrency Runtime]
- structured tasks [Concurrency Runtime]
- task groups [Concurrency Runtime]
- task parallelism
- tasks [Concurrency Runtime]
ms.assetid: 42f05ac3-2098-494a-ba84-737fcdcad077
ms.openlocfilehash: c9f18dfd1498538ce3700fd73a27ce6f6088ee42
ms.sourcegitcommit: 1819bd2ff79fba7ec172504b9a34455c70c73f10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2018
ms.locfileid: "51331221"
---
# <a name="task-parallelism-concurrency-runtime"></a>Параллелизм задач (среда выполнения с параллелизмом)

В среде выполнения с параллелизмом *задачи* — это единица работы, которая выполняет конкретное задание и обычно выполняется параллельно с другими задачами. Задачу можно разложить на дополнительные, более мелкие задачи, которые упорядочены по *группа задач*.

Задачи используются, когда при создании асинхронного кода требуется, чтобы после завершения асинхронной операции выполнялись некоторые операции. Например, можно использовать задачи для асинхронного чтения из файла, а затем с помощью другой задачи — *задача продолжения*, описанный далее в этом документе, для обработки данных, в том случае, когда они станут доступными. И наоборот, можно использовать группы задач для разбиения параллельной работы на более мелкие части. Например, предположим, что имеется рекурсивный алгоритм, разделяющий оставшуюся работу на два раздела. С помощью групп задач вы можете одновременно запустить эти разделы, а затем подождать, пока выполнится эта разделенная задача.

> [!TIP]
> Если вы хотите применить одну процедуру для каждого элемента коллекции параллельно, используйте параллельный алгоритм, например [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), вместо задачи или группы задач. Дополнительные сведения об алгоритмах параллельных операций, см. в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

## <a name="key-points"></a>Ключевые моменты

- При передаче переменных в лямбда-выражение по ссылке необходимо обеспечить сохранение существования этой переменной до завершения задачи.

- Использование задач ( [concurrency::task](../../parallel/concrt/reference/task-class.md) класс) при написании асинхронного кода. Класс задач использует в качестве своего планировщика Windows ThreadPool (пул потоков Windows), а не среду выполнения с параллелизмом.

- Использование групп задач ( [concurrency::task_group](reference/task-group-class.md) класса или [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм) Если требуется разбить параллельную работу на более мелкие части, а затем подождать этих меньшего размера фрагменты для выполнения.

- Используйте [Concurrency::Task:: Then](reference/task-class.md#then) метод для создания продолжений. Объект *продолжения* — это задача, которая выполняется асинхронно после завершения другой задачи. Вы можете подключать любое количество продолжений для формирования цепочки асинхронной работы.

- Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение.

- Используйте [concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) для создания задачи, выполняемой после завершения каждого элемента набора задач. Используйте [concurrency::when_any](reference/concurrency-namespace-functions.md#when_any) для создания задачи, выполняемой после завершения один член набора задач.

- Задачи и группы задач могут участвовать в механизме отмены библиотеки параллельных шаблонов (PPL). Дополнительные сведения см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md).

- Чтобы узнать, как среда выполнения обрабатывает исключения, вызываемые задачами и группами задач, см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

## <a name="in-this-document"></a>В этом документе

- [Использование лямбда-выражения](#lambdas)

- [Класс task](#task-class)

- [Задачи продолжения](#continuations)

- [По значениям и продолжения на основе задач](#value-versus-task)

- [Составление задач](#composing-tasks)

    - [Функция when_all](#when-all)

    - [Функция when_any](#when-any)

- [Отложенное выполнение задач](#delayed-tasks)

- [Группы задач](#task-groups)

- [Сравнение task_group и structured_task_group](#comparing-groups)

- [Пример](#example)

- [Отказоустойчивость](#robust)

##  <a name="lambdas"></a> Использование лямбда-выражения

Благодаря их лаконичному синтаксису лямбда-выражения часто используют для определения операций, выполняемых задачами и группами задач. Ниже приведены некоторые советы по использованию.

- Поскольку задачи обычно выполняются в фоновых потоках, помните о времени существования объекта при включении переменных в лямбда-выражения. При вводе переменной по значению в тексте лямбда-выражения создается копия этой переменной. При вводе по ссылке копия не создается. Следовательно, необходимо убедиться, что время существования любой введенной по ссылке переменной превышает время существования задачи, которая ее использует.

- При передаче лямбда-выражения в задачу не вводите переменные, которые размещаются в стеке, по ссылке.

- Четко формулируйте ввод переменных в лямбда-выражения, чтобы можно было определить, как введена переменная — по значению или по ссылке. По этой причине рекомендуется не использовать параметры `[=]` или `[&]` для лямбда-выражений.

Распространенный подход заключается в том, что одна задача в цепочке продолжения назначает переменную, а другая задача читает эту переменную. В этом случае нельзя записывать переменную по значению, поскольку каждая задача продолжения будет содержать другую копию переменной. Для переменных, размещенных в стеке, также нельзя записывать переменную по ссылке, так как переменная может перестать быть действительной.

Чтобы решить эту проблему, используйте интеллектуальный указатель, такие как [std::shared_ptr](../../standard-library/shared-ptr-class.md), чтобы заключите переменную и передавайте этот интеллектуальный указатель по значению. Таким образом этот базовый объект можно назначать и читать, и срок его существования будет превышать срок существования задач, которые его используют. Используйте этот метод даже в том случае, если переменная является указателем или дескриптором с подсчетом ссылок (`^`) объекта среды выполнения Windows. Ниже приводится базовый пример.

[!code-cpp[concrt-lambda-task-lifetime#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_1.cpp)]

Дополнительные сведения о лямбда-выражениях см. в разделе [Лямбда-выражения](../../cpp/lambda-expressions-in-cpp.md).

##  <a name="task-class"></a> Класс task

Можно использовать [concurrency::task](../../parallel/concrt/reference/task-class.md) класс для объединения задач в набор зависимых операций. Такая модель формирования поддерживается идеей *продолжений*. Необходимо выполнить, когда код разрешает продолжение предыдущей, или *предшествующая задача*, завершения задачи. Результат предшествующей задачи передается в качестве входных данных в одну или несколько задач продолжения. По завершении предшествующей задачи все ожидающие ее задачи продолжения планируются для выполнения. Каждая задача продолжения получает копию результатов предшествующей задачи. В свою очередь, эти задачи продолжения также могут быть предшествующими задачами для других продолжений, тем самым создавая цепочки задач. Продолжения помогают создавать цепочки задач произвольной длины с определенными зависимостями между входящими в них задачами. Кроме того, задача может участвовать в отмене либо до запуска, либо совместно во время выполнения. Дополнительные сведения о модели отмены см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md).

`task` является классом шаблона. Параметр типа `T` — это тип результата, созданного задачей. Это может быть тип `void`, если задача не возвращает значение. Параметр `T` не может использовать модификатор `const`.

При создании задачи, следует указать *рабочая функция* , выполняет текст задачи. Эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Чтобы дождаться завершения без получения результата задачи, вызовите [Concurrency::Task:: wait](reference/task-class.md#wait) метод. `task::wait` Возвращает [concurrency::task_status](reference/concurrency-namespace-enums.md#task_group_status) значение, описывающее, был ли задача завершена или отменена. Чтобы получить результат задачи, вызовите [Concurrency::Task:: Get](reference/task-class.md#get) метод. Этот метод вызывает метод `task::wait` для ожидания завершения задачи и таким образом блокирует выполнение текущего потока, пока не станет доступен результат.

В следующем примере показано, как создать задачу, дождаться ее результата и отобразить полученное значение. В примерах в этой документации используются лямбда-функции, поскольку они обеспечивают более лаконичный синтаксис. Однако при использовании задач вы также можете применять указатели функций и объекты функций.

[!code-cpp[concrt-basic-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_2.cpp)]

При использовании [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) функции, можно использовать `auto` ключевое слово вместо объявления типа. Например, рассмотрим следующий код, который создает и печатает матрицу тождественности.

[!code-cpp[concrt-create-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_3.cpp)]

Вы можете использовать функцию `create_task` для создания эквивалентной операции.

[!code-cpp[concrt-create-task#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_4.cpp)]

Если во время выполнения задачи возникает исключение, среда выполнения маршалирует исключение в последующий вызов метода `task::get` или `task::wait`, или в продолжение на основе задачи. Дополнительные сведения о механизме обработки исключений задач см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

Пример, использующий `task`, [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md), отмены, см. в разделе [Пошаговое руководство: подключение с использованием задач и HTTP-запросов XML](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md). (Класс `task_completion_event` описывается далее в этом документе.)

> [!TIP]
>  Дополнительные сведения, относящиеся к задачам в приложениях универсальной платформы Windows, см. в разделе [асинхронное программирование в C++](/windows/uwp/threading-async/asynchronous-programming-in-cpp-universal-windows-platform-apps) и [создание асинхронных операций в C++ для приложений UWP](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).

##  <a name="continuations"></a> Задачи продолжения

В асинхронном программировании очень распространено при завершении одной асинхронной операции вызывать вторую операцию и передавать в нее данные. Как правило, это делается с помощью методов обратного вызова. В среде выполнения с параллелизмом предоставляет те же функциональные возможности *задач продолжения*. Задача продолжения (также называемая просто продолжением) — это асинхронная задача, вызываемая другой задачей, которая называется *предшествующая задача*, при ее завершении. С помощью продолжений вы можете делать следующее.

- Передавать данные из предшествующей задачи в продолжение.

- Указывать точные условия, при которых продолжение вызывается или не вызывается.

- Отменять продолжение перед его запуском либо совместно во время его выполнения.

- Определять подсказки, как должно планироваться продолжение. (Это относится к только для приложений универсальной платформы Windows (UWP). Дополнительные сведения см. в разделе [создание асинхронных операций в C++ для приложений UWP](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).)

- Вызывать несколько продолжений из одной и той же предшествующей задачи.

- Вызывать одно продолжение по завершении всех или одной из нескольких предшествующих задач.

- Прикреплять продолжения одно после другого до любой длины.

- Использовать продолжение для обработки исключений, вызванных предшествующей задачей.

Эти функции позволяют выполнять одну или несколько задач после завершения первой задачи. Например, можно создать продолжение, которое сжимает файл после того, как первая задача прочитает этот файл с диска.

В следующем примере изменяется предыдущий [Concurrency::Task:: Then](reference/task-class.md#then) метод для планирования продолжения, которое распечатывает значение предшествующей задачи, когда она станет доступна.

[!code-cpp[concrt-basic-continuation#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_5.cpp)]

Вы можете прикреплять и вкладывать задачи до любой длины. Задача также может иметь несколько продолжений. В следующем примере демонстрируется базовая цепочка продолжений, которая увеличивает значение предыдущей задачи три раза.

[!code-cpp[concrt-continuation-chain#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_6.cpp)]

Продолжение может также возвращать другую задачу. Если отмена отсутствует, то эта задача выполняется до последующего продолжения. Этот прием называется *асинхронным развертыванием*. Асинхронное развертывание удобно использовать, когда требуется выполнить дополнительную работу в фоновом режиме, но так, чтобы текущая задача не блокировала текущий поток. (Это часто встречается в приложениях UWP, где продолжения могут запускаться в потоке пользовательского интерфейса). В следующем примере показаны три задачи. Первая задача возвращает вторую задачу, которая выполняется перед задачей продолжения.

[!code-cpp[concrt-async-unwrapping#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_7.cpp)]

> [!IMPORTANT]
>  Когда продолжение задачи возвращает вложенную задачу типа `N`, результирующая задача имеет тип `N`, а не `task<N>`, и завершается при завершении вложенной задачи. Другими словами, продолжение выполняет развертывание вложенной задачи.

##  <a name="value-versus-task"></a> По значениям и продолжения на основе задач

Принимая во внимание объект `task`, который имеет тип возвращаемого значения `T`, вы можете предоставить значение типа `T` или `task<T>` в соответствующие задачи продолжения. Продолжение, которое принимает тип `T` называется *продолжение, основанное на значении*. Продолжение на основе значения планируется для выполнения, когда предшествующая задача завершается без ошибок и не отменяется. Продолжение, которое принимает тип `task<T>` как ее параметр называется *продолжение на основе задач*. Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение. Затем можно вызвать `task::get`, чтобы получить результат предшествующей задачи. Если предшествующая задача была отменена, `task::get` вызывает [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). Если предшествующая задача выдала исключение, `task::get` повторно выдает это исключение. Продолжение на основе задачи не отмечается как отмененное, когда отменяется предшествующая задача.

##  <a name="composing-tasks"></a> Составление задач

В этом разделе описываются [concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) и [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) функций, которые помогут вам создать ряд задач для реализации общих шаблонов.

###  <a name="when-all"></a> Функция when_all

Функция `when_all` создает задачу, которая выполняется после завершения набора задач. Эта функция возвращает объект std::[вектор](../../standard-library/vector-class.md) , содержащий результат каждой задачи в наборе. В следующем базовом примере функция `when_all` используется для создания задачи, которая представляет завершение трех других задач.

[!code-cpp[concrt-join-tasks#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_8.cpp)]

> [!NOTE]
>  Задачи, которые вы передаете в функцию `when_all`, должны быть единообразными. Другими словами, все они должны возвращать один и тот же тип.

Для создания задачи, выполняемой после завершения набора задач, можно также использовать синтаксис `&&`, как показано в следующем примере.

`auto t = t1 && t2; // same as when_all`

Обычно для выполнения действия после завершения набора задач используется продолжение вместе с функцией `when_all`. В следующем примере изменяется предыдущий пример для печати суммы трех задач, каждая из которых создает результат `int`.

[!code-cpp[concrt-join-tasks#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_9.cpp)]

В этом примере можно также указать `task<vector<int>>`, чтобы создать продолжение на основе задачи.

Если какая-либо из задач в наборе задач отменяется или порождает исключение, `when_all` немедленно завершается и не ждет завершения выполнения оставшихся задач. Если выдается исключение, среда выполнения повторно выдает это исключение при вызове `task::get` или `task::wait` в объекте задачи, который возвращает `when_all`. Если исключение выдают несколько задач, среда выполнения выбирает одну из них. Поэтому убедитесь, что вы заметили все исключения после завершения всех задач; необработанное исключение задачи приведет к завершению работы приложения.

Имеется служебная функция, которая позволяет убедиться, что программа обнаруживает все исключения. Для каждой задачи в указанном диапазоне эта служебная функция `observe_all_exceptions` запускает повторную выдачу каждого возникшего исключения, а затем поглощает это исключение.

[!code-cpp[concrt-eh-when_all#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_10.cpp)]

Рассмотрим приложение UWP, которое использует C++ и XAML и записывает набор файлов на диск. В следующем примере показано, как использовать функции `when_all` и `observe_all_exceptions`, чтобы убедиться, что программа обнаруживает все исключения.

[!code-cpp[concrt-eh-when_all#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_11.cpp)]

##### <a name="to-run-this-example"></a>Запуск примера

1. Добавьте в файл MainPage.xaml элемент управления `Button`.

[!code-xml[concrt-eh-when_all#3](../../parallel/concrt/codesnippet/xaml/task-parallelism-concurrency-runtime_12.xaml)]

1. В MainPage.xaml.h добавьте в раздел `private` объявления класса `MainPage` следующие предваряющие объявления.

[!code-cpp[concrt-eh-when_all#4](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_13.h)]

1. В MainPage.xaml.cpp реализуйте обработчик событий `Button_Click`.

[!code-cpp[concrt-eh-when_all#5](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_14.cpp)]

1. В MainPage.xaml.cpp реализуйте `WriteFilesAsync`, как показано в примере.

> [!TIP]
> Функция `when_all` является функцией без блокировки, в качестве результата создающей `task`. В отличие от [task::wait](reference/task-class.md#wait), безопасно для вызова этой функции в приложении UWP в потоке ASTA (STA приложения).

###  <a name="when-any"></a> Функция when_any

Функция `when_any` создает задачу, которая выполняется после завершения первой задачи в наборе задач. Эта функция возвращает [std::pair](../../standard-library/pair-structure.md) , содержащий результат завершенной задачи и индекс этой задачи в наборе.

Функция `when_any` особенно полезна в следующих ситуациях.

- Избыточные операции. Рассмотрим алгоритм или операцию, которые можно выполнить несколькими способами. Функцию `when_any` можно использовать для выбора операции, которая завершается первой, и последующей отмены оставшихся операций.

- Операции с чередованием. Можно запустить несколько операций, которые все должны завершиться, и использовать функцию `when_any` для обработки результатов при завершении каждой операции. После завершения одной операции можно запустить одну или несколько дополнительных задач.

- Регулируемые операции. Функцию `when_any` можно использовать для расширения предыдущего сценария путем ограничения количества параллельных операций.

- Операции с истекшим сроком действия. Функцию `when_any` можно использовать, чтобы сделать выбор между одной или несколькими задачами и задачей, завершающейся после определенного времени.

Как и в случае с функцией `when_all`, обычно для выполнения действия после завершения первой задачи в наборе используется продолжение, имеющее функцию `when_any`. В следующем базовом примере функция `when_any` используется для создания задачи, которая выполняется после завершения первой из трех других задач.

[!code-cpp[concrt-select-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_15.cpp)]

В этом примере можно также указать `task<pair<int, size_t>>`, чтобы создать продолжение на основе задачи.

> [!NOTE]
> Как и при использовании функции `when_all`, задачи, которые вы передаете в `when_any`, должны возвращать один и тот же тип.

Для создания задачи, выполняемой после завершения первой задачи в наборе, можно также использовать синтаксис `||`, как показано в следующем примере.

`auto t = t1 || t2; // same as when_any`

> [!TIP]
> Как и в `when_all`, `when_any` без блокировки и безопасно вызывать в приложении UWP в потоке ASTA.

##  <a name="delayed-tasks"></a> Отложенное выполнение задач

Иногда требуется отложить выполнение задачи до выполнения условия или запустить задачу в ответ на внешнее событие. Например, в асинхронном программировании может потребоваться запустить задачу в ответ на событие завершения операции ввода-вывода.

Это можно сделать двумя способами: использовать продолжение или запустить задачу и ожидать событие внутри рабочей функции задачи. Однако бывают случаи, когда невозможно использовать ни один из этих способов. Например, чтобы создать продолжение, необходимо иметь предшествующую задачу. Тем не менее, если у вас нет предшествующей задачи, можно создать *события завершения задачи* и позднее прикрепить это событие завершения к предшествующей задачи, когда она станет доступной. Кроме того, поскольку ожидающая задача также блокирует поток, можно использовать события завершения задачи для выполнения работы при завершении асинхронной операции и тем самым освободить поток.

[Concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) класса позволяет упростить такую композицию задач. Как и в классе `task`, параметр типа `T` — это тип результата, созданного задачей. Это может быть тип `void`, если задача не возвращает значение. Параметр `T` не может использовать модификатор `const`. Как правило, объект `task_completion_event` передается в поток или задачу, которые будут сообщать, когда значение для них станет доступным. В то же время одна или несколько задач устанавливаются в качестве прослушивателей этого события. Когда событие возникает, задачи прослушивателя выполняются и их продолжения планируются для запуска.

Пример, использующий `task_completion_event` для реализации задачи, выполняемой после задержки, см. в разделе [как: Создание задачи, завершается после задержки](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md).

##  <a name="task-groups"></a> Группы задач

Объект *группа задач* упорядочивает коллекцию задач. Группы задач помещают задачи в очередь перехвата работы. Планировщик удаляет задачи из этой очереди и выполняет их с использованием доступных вычислительных ресурсов. После добавления задач в группу задач можно ожидать завершения всех задач или отменить задачи, которые еще не запускались.

PPL использует [concurrency::task_group](reference/task-group-class.md) и [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) классы для представления групп задач и [concurrency::task_handle](../../parallel/concrt/reference/task-handle-class.md) класса для представления задачи, которые выполняются в этих группах. Класс `task_handle` инкапсулирует код, выполняющий работу. Как и в случае класса `task`, эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Обычно не требуется работать с объектами `task_handle` напрямую. Вместо этого вы передаете рабочие функции в группу задач, а группа задач создает объекты `task_handle` и управляет ими.

PPL разделяет группы задач на две категории: *неструктурированные группы задач* и *структурированные группы задач*. PPL использует класс `task_group` для представления неструктурированных групп задач и класс `structured_task_group` — для представления структурированных групп задач.

> [!IMPORTANT]
> PPL также задает [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм, который использует `structured_task_group` класс для выполнения набора задач в параллельном режиме. Поскольку алгоритм `parallel_invoke` имеет более лаконичный синтаксис, рекомендуется по возможности использовать его вместо класса `structured_task_group`. Раздел [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md) описывает `parallel_invoke` более подробно.

Используйте алгоритм `parallel_invoke`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, и перед продолжением необходимо дождаться завершения всех задач. Этот прием часто называется *ветвления и соединения* параллелизма. Используйте алгоритм `task_group`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, но дождаться завершения всех задач требуется позднее. Например, вы можете добавить задачи в объект `task_group` и дожидаться завершения этих задач в другой функции или из другого потока.

Группы задач поддерживают принцип отмены. Отмена позволяет сообщить всем активным задачам, что необходимо отменить всю операцию. Отмена также предотвращает запуск задач, которые еще не начали выполняться. Дополнительные сведения об отмене см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md).

Среда выполнения также предоставляет модель обработки исключений, которая позволяет вызывать исключение из задачи и обработать это исключение при ожидании завершения группы связанных задач. Дополнительные сведения об этой модели обработки исключений см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

##  <a name="comparing-groups"></a> Сравнение task_group и structured_task_group

Несмотря на то что мы рекомендуем использовать `task_group` или `parallel_invoke` вместо класса `structured_task_group`, бывают ситуации, в которых вы захотите использовать класс `structured_task_group`, например при создании параллельного алгоритма, который выполняет переменное количество задач или которому требуется поддержка отмены. В этом разделе описываются различия между классами `task_group` и `structured_task_group`.

Класс `task_group` является потокобезопасным. Поэтому можно добавлять задачи в объект `task_group` из нескольких потоков и ожидать или отменять объект `task_group` из нескольких потоков. Создание и уничтожение объекта `structured_task_group` должно происходить в одной лексической области. Кроме того, все операции с объектом `structured_task_group` должны происходить в одном потоке. Исключением из этого правила является [Concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) и [Concurrency::structured_task_group:: is_canceling](reference/structured-task-group-class.md#is_canceling) методы. Дочерняя задача может вызывать эти методы для отмены родительской группы задач или проверки на предмет отмены в любое время.

Можно выполнить дополнительные задачи по `task_group` объекта после вызова метода [Concurrency::task_group:: wait](reference/task-group-class.md#wait) или [Concurrency::task_group:: run_and_wait](reference/task-group-class.md#run_and_wait) метод. И наоборот Если вы выполняете дополнительные задачи `structured_task_group` объекта после вызова метода [Concurrency::structured_task_group:: wait](reference/structured-task-group-class.md#wait) или [Concurrency::structured_task_group:: run_and_wait](reference/structured-task-group-class.md#run_and_wait) методы , то поведение не определено.

Поскольку класс `structured_task_group` не синхронизируется в потоках, он имеет меньше затрат на выполнение, чем класс `task_group`. Таким образом, если проблема не требует планирования работы в нескольких потоках и нельзя использовать алгоритм `parallel_invoke`, класс `structured_task_group` класс может помочь написать более производительный код.

При использовании одного объекта `structured_task_group` внутри другого объекта `structured_task_group` внутренний объект должен быть завершен и уничтожен до завершения внешнего объекта. Класс `task_group` не требуется для завершения вложенных групп задач до завершения внешней группы.

Неструктурированные группы задач и структурированные группы задач работают с дескрипторами задач по-разному. Вы можете передавать рабочие функции непосредственно в объект `task_group`; объект `task_group` будет создавать дескриптор задач и управлять им. Класс `structured_task_group` требует, чтобы вы управляли объектом `task_handle` для каждой задачи. Каждый объект `task_handle` должен оставаться допустимым в течение всего времени существования связанного объекта `structured_task_group`. Используйте [concurrency::make_task](reference/concurrency-namespace-functions.md#make_task) функцию для создания `task_handle` объекта, как показано в следующем примере:

[!code-cpp[concrt-make-task-structure#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_16.cpp)]

Чтобы управлять дескрипторами задач в случаях, когда имеется переменное количество задач, используйте подпрограмму выделения стека, такие как [_malloca](../../c-runtime-library/reference/malloca.md) или класс контейнера, например std::[вектор](../../standard-library/vector-class.md).

И `task_group`, и `structured_task_group` поддерживают отмену. Дополнительные сведения об отмене см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md).

##  <a name="example"></a> Пример

В следующем базовом примере показано, как работать с группами задач. В этом примере используется алгоритм `parallel_invoke` для выполнения двух задач одновременно. Каждая задача добавляет подзадачи в объект `task_group`. Обратите внимание, что класс `task_group` позволяет добавлять в него задачи одновременно нескольким задачам.

[!code-cpp[concrt-using-task-groups#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_17.cpp)]

Ниже приведен пример выходных данных для данного примера.

```Output
Message from task: Hello
Message from task: 3.14
Message from task: 42
```

Поскольку алгоритм `parallel_invoke` выполняет задачи параллельно, порядок выходных сообщений может меняться.

Полные примеры, показывающие, как использовать `parallel_invoke` алгоритм, см. в разделе [как: использование функции parallel_invoke для написания параллельного сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) и [как: использование функции parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md). Полный пример, использующий `task_group` класс для реализации асинхронных фьючерсов, см. в разделе [Пошаговое руководство: реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md).

##  <a name="robust"></a> Отказоустойчивость

Убедитесь, что понимаете роль отмены и обработки исключений при использовании задач, групп задач и параллельных алгоритмов. Например, в дереве параллельной работы отмененная задача предотвращает запуск дочерних задач. Это может вызвать проблемы, если одна из дочерних задач выполняет операцию, важную для приложения, например высвобождает ресурс. Кроме того, если дочерняя задача создает исключение, это исключение может распространиться через деструктор объекта и вызвать неопределенное поведение в приложении. Пример, иллюстрирующий эти моменты, см. в разделе [Общие сведения о том, как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) статьи рекомендации в документе библиотеку параллельных шаблонов. Дополнительные сведения о моделях отмены и обработки исключений в PPL см. в разделе [отмены](../../parallel/concrt/cancellation-in-the-ppl.md) и [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Практическое руководство. Использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности алгоритма битонной сортировки.|
|[Практическое руководство. Использование функции parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности программы, выполняющей несколько операций с общим источником данных.|
|[Практическое руководство. Создание задачи, выполняемой после задержки](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)|Демонстрируется использование `task`, `cancellation_token_source`, `cancellation_token`, и `task_completion_event` классы для создания задачи, выполняемой после задержки.|
|[Пошаговое руководство. Реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md)|Показано, как объединить существующие функциональные возможности в среде выполнения с параллелизмом в то, что делает больше.|
|[Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)|Описывается библиотека PPL, которая предоставляет императивную модель программирования для разработки параллельных приложений.|

## <a name="reference"></a>Ссылка

[Класс task (среда выполнения с параллелизмом)](../../parallel/concrt/reference/task-class.md)

[Класс task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md)

[Функция when_all](reference/concurrency-namespace-functions.md#when_all)

[Функция when_any](reference/concurrency-namespace-functions.md#when_any)

[Класс task_group](reference/task-group-class.md)

[Функция parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke)

[Класс structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md)
