---
description: Дополнительные сведения см. в разделе Пошаговое руководство. Создание агента потоков данных
title: Пошаговое руководство. Создание агента потоков данных
ms.date: 04/25/2019
helpviewer_keywords:
- creating dataflow agents [Concurrency Runtime]
- dataflow agents, creating [Concurrency Runtime]
ms.assetid: 9db5ce3f-c51b-4de1-b79b-9ac2a0cbd130
ms.openlocfilehash: 2f7f2435d5a4ede1dd48a4dee672ed7affbdfd9f
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97163864"
---
# <a name="walkthrough-creating-a-dataflow-agent"></a>Пошаговое руководство. Создание агента потоков данных

В этом документе показано, как создать основанные на агентах приложения, основанные на потоке данных, а не в потоке управления.

*Поток управления* — это порядок выполнения операций в программе. Управление потоком регулируется с помощью структур управления, таких как условные операторы, циклы и т. д. Кроме того, *поток* данных относится к модели программирования, в которой вычисления выполняются только при наличии всех необходимых данных. Модель программирования потоков данных связана с концепцией передачи сообщений, при которой независимые компоненты программы взаимодействуют друг с другом, отправляя сообщения.

Асинхронные агенты поддерживают модели программирования потока управления и потока данных. Хотя модель потока управления подходит во многих случаях, модель потока данных подходит для других пользователей, например, когда агент получает данные и выполняет действие, основанное на полезных данных.

## <a name="prerequisites"></a>Предварительные требования

Прежде чем приступить к работе с этим пошаговым руководством, прочитайте следующие документы:

- [Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)

- [Асинхронные блоки сообщений](../../parallel/concrt/asynchronous-message-blocks.md)

- [Как использовать фильтр блоков сообщений](../../parallel/concrt/how-to-use-a-message-block-filter.md)

## <a name="sections"></a><a name="top"></a> Священ

Это пошаговое руководство содержит следующие разделы:

- [Создание базового агента Control-Flow](#control-flow)

- [Создание основного агента потоков данных](#dataflow)

- [Создание агента Message-Logging](#logging)

## <a name="creating-a-basic-control-flow-agent"></a><a name="control-flow"></a> Создание базового агента Control-Flow

Рассмотрим следующий пример, определяющий `control_flow_agent` класс. `control_flow_agent`Класс работает с тремя буферами сообщений: одним входным буфером и двумя выходными буферами. `run`Метод считывает из буфера исходного сообщения в цикле и использует условный оператор для направления потока выполнения программы. Агент увеличивает один счетчик для ненулевых отрицательных значений и увеличивает другой счетчик для ненулевых положительных значений. После того как агент получает значение Sentinel, равное нулю, он отправляет значения счетчиков в выходные буферы сообщений. `negatives`Методы и `positives` позволяют приложению считывать количество отрицательных и положительных значений от агента.

[!code-cpp[concrt-dataflow-agent#1](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_1.cpp)]

Несмотря на то что этот пример делает базовое использование потока управления в агенте, он демонстрирует последовательное представление программирования на основе потока управления. Каждое сообщение должно обрабатываться последовательно, несмотря на то, что в буфере входящих сообщений могут быть доступны несколько сообщений. Модель потока данных позволяет параллельно оценивать обе ветви условного оператора. Модель потоков данных также позволяет создавать более сложные сети обмена сообщениями, работающие с данными по мере их поступления.

[[Top](#top)]

## <a name="creating-a-basic-dataflow-agent"></a><a name="dataflow"></a> Создание основного агента потоков данных

В этом разделе показано, как преобразовать `control_flow_agent` класс, чтобы использовать модель потока данных для выполнения той же задачи.

Агент потоков данных работает путем создания сети буферов сообщений, каждая из которых служит определенной цели. Некоторые блоки сообщений используют функцию фильтра для принятия или отклонения сообщения на основе его полезных данных. Функция фильтра гарантирует, что блок сообщений получит только определенные значения.

#### <a name="to-convert-the-control-flow-agent-to-a-dataflow-agent"></a>Преобразование агента потока управления в агент потока данных

1. Скопируйте текст `control_flow_agent` класса в другой класс, например `dataflow_agent` . Кроме того, можно переименовать `control_flow_agent` класс.

1. Удалите текст цикла, который вызывает `receive` `run` метод из метода.

[!code-cpp[concrt-dataflow-agent#2](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_2.cpp)]

1. В `run` методе после инициализации переменных `negative_count` и `positive_count` добавьте `countdown_event` объект, отслеживающий количество активных операций.

[!code-cpp[concrt-dataflow-agent#6](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_3.cpp)]

   `countdown_event`Класс показан далее в этом разделе.

1. Создайте объекты буфера сообщений, которые будут участвовать в сети потока данных.

[!code-cpp[concrt-dataflow-agent#3](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_4.cpp)]

1. Подключите буферы сообщений для формирования сети.

[!code-cpp[concrt-dataflow-agent#4](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_5.cpp)]

1. Дождитесь `event` `countdown event` установки объектов и. Эти события сообщают, что агент получил значение Sentinel и все операции завершены.

[!code-cpp[concrt-dataflow-agent#5](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_6.cpp)]

На следующей схеме показана полная сеть потока данных для `dataflow_agent` класса:

![Сеть потока данных](../../parallel/concrt/media/concrt_dataflow.png "Сеть потока данных")

Следующая таблица описывает члены сети.

|Член|Описание|
|------------|-----------------|
|`increment_active`|Объект [Concurrency:: transformer](../../parallel/concrt/reference/transformer-class.md) , увеличивающий Счетчик активных событий и передающий входное значение остальной части сети.|
|`negatives`, `positives`|[Concurrency:: Call](../../parallel/concrt/reference/call-class.md) Objects, которые увеличивают число чисел и уменьшают счетчик активных событий. Каждый объект использует фильтр, чтобы принимать отрицательные или положительные числа.|
|`sentinel`|Объект [Concurrency:: Call](../../parallel/concrt/reference/call-class.md) , принимающий только значение Sentinel, равное нулю, и уменьшающий счетчик активного события.|
|`connector`|Объект [Concurrency:: unbounded_buffer](reference/unbounded-buffer-class.md) , который подключает исходный буфер сообщений к внутренней сети.|

Поскольку `run` метод вызывается в отдельном потоке, другие потоки могут передавать сообщения в сеть до полного подключения к сети. `_source`Элемент данных — это `unbounded_buffer` объект, который помещает все входные данные, отправляемые из приложения агенту. Чтобы убедиться, что сеть обрабатывает все входные сообщения, агент сначала связывает внутренние узлы сети, а затем связывает начало этой сети `connector` с `_source` элементом данных. Это гарантирует, что сообщения не будут обрабатываться при формировании сети.

Так как сеть в этом примере основана на потоке данных, а не на потоке управления, сеть должна взаимодействовать с агентом, который завершил обработку каждого входного значения, и что узел-Метка получил свое значение. В этом примере используется `countdown_event` объект для сигнализации о том, что все входные значения обработаны, и объект [Concurrency:: Event](../../parallel/concrt/reference/event-class.md) , указывающий, что узел-Метка получил свое значение. `countdown_event`Класс использует `event` объект для сигнализации, когда значение счетчика достигает нуля. Заголовок сети потоков данных увеличивает счетчик каждый раз, когда он получает значение. Каждый узел терминала сети уменьшает счетчик после обработки входного значения. После того как агент формирует сеть потока данных, он ждет, пока на узле Sentinel `event` задастся объект, и для `countdown_event` объекта, чтобы сообщить, что его счетчик достиг нуля.

В следующем примере показаны `control_flow_agent` классы, `dataflow_agent` и `countdown_event` . `wmain`Функция создает `control_flow_agent` объект и и `dataflow_agent` использует `send_values` функцию для отправки ряда случайных значений агентам.

[!code-cpp[concrt-dataflow-agent#7](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_7.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
Control-flow agent:
There are 500523 negative numbers.
There are 499477 positive numbers.
Dataflow agent:
There are 500523 negative numbers.
There are 499477 positive numbers.
```

### <a name="compiling-the-code"></a>Компиляция кода

Скопируйте пример кода и вставьте его в проект Visual Studio или вставьте в файл с именем, `dataflow-agent.cpp` а затем выполните следующую команду в окне командной строки Visual Studio.

**cl.exe/EHsc датафлов-ажент. cpp**

[[Top](#top)]

## <a name="creating-a-message-logging-agent"></a><a name="logging"></a> Создание агента Message-Logging

В следующем примере показан `log_agent` класс, напоминающий `dataflow_agent` класс. `log_agent`Класс реализует асинхронный агент ведения журнала, который записывает сообщения журнала в файл и в консоль. `log_agent`Класс позволяет приложению классифицировать сообщения как информационные, warning или Error. Он также позволяет приложению указать, записывается ли каждая категория журнала в файл, в консоль или в то и другое. В этом примере все сообщения журнала записываются в файл, а в консоль — только сообщения об ошибках.

[!code-cpp[concrt-log-filter#1](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_8.cpp)]

В этом примере на консоль записываются следующие выходные данные.

```Output
error: This is a sample error message.
```

В этом примере также создается файл log.txt, который содержит следующий текст.

```Output
info: ===Logging started.===
warning: This is a sample warning message.
error: This is a sample error message.
info: ===Logging finished.===
```

### <a name="compiling-the-code"></a>Компиляция кода

Скопируйте пример кода и вставьте его в проект Visual Studio или вставьте в файл с именем, `log-filter.cpp` а затем выполните следующую команду в окне командной строки Visual Studio.

**cl.exe/EHsc лог-филтер. cpp**

[[Top](#top)]

## <a name="see-also"></a>См. также раздел

[среда выполнения с параллелизмом пошаговые руководства](../../parallel/concrt/concurrency-runtime-walkthroughs.md)
