---
title: Пошаговое руководство. Создание агента потоков данных
ms.date: 11/04/2016
helpviewer_keywords:
- creating dataflow agents [Concurrency Runtime]
- dataflow agents, creating [Concurrency Runtime]
ms.assetid: 9db5ce3f-c51b-4de1-b79b-9ac2a0cbd130
ms.openlocfilehash: 35532fd01259bcbf64a70aaca16c621f875bb43f
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50487650"
---
# <a name="walkthrough-creating-a-dataflow-agent"></a>Пошаговое руководство. Создание агента потоков данных

В этом документе показано, как создавать приложения на основе агента, основанные на потоке данных, а не потока управления.

*Поток управления* ссылается на порядок выполнения операций в программе. Поток управления контролируется с помощью структур управления, такие как условные операторы, циклы и т. д. Кроме того *потока данных* ссылается на модель программирования, в котором вычисления выполняются, только когда доступна все необходимые данные. Модель программирования потоков данных связана с понятием передачи сообщений, в которой независимые компоненты программы взаимодействуют друг с другом посредством отправки сообщений.

Асинхронные агенты поддерживают потока управления и потока данных, модели программирования. Несмотря на то, что модель управления потоком подходит во многих случаях модель потоков данных подходит в других случаях, например, когда агент получает данные и выполняет действие, которое зависит от полезных данных этих данных.

## <a name="prerequisites"></a>Предварительные требования

Прежде чем приступать к этому руководству, приведены в следующих источниках:

- [Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)

- [Асинхронные блоки сообщений](../../parallel/concrt/asynchronous-message-blocks.md)

- [Практическое руководство. Использование фильтра блоков сообщений](../../parallel/concrt/how-to-use-a-message-block-filter.md)

##  <a name="top"></a> Разделы

Это пошаговое руководство содержит следующие разделы:

- [Создание агента базовый поток управления](#control-flow)

- [Создание основного агента потока данных](#dataflow)

- [Создание агента ведения журнала сообщений](#logging)

##  <a name="control-flow"></a> Создание агента базовый поток управления

Рассмотрим следующий пример, определяющий `control_flow_agent` класса. `control_flow_agent` Класс предназначен для трех буферов сообщений: один входной буфер, и два выходных буферов. `run` Метод выполняет чтение из буфера источника сообщений в цикле и использует условный оператор, чтобы направить поток выполнения программы. Агент увеличивает один счетчик для отрицательных значений ненулевое значение и увеличивает значение счетчика, другой для положительных значений ненулевое значение. После того как агент получает нулевое значение-метку, он отправляет значения счетчиков сообщение в выходные буферы. `negatives` И `positives` методы позволяют приложению считывать число отрицательных и положительных значений из агента.

[!code-cpp[concrt-dataflow-agent#1](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_1.cpp)]

Несмотря на то, что в этом примере выполняет базовое использование потока управления в агенте, он демонстрирует особенностей последовательных программирования на основе потока управления. Каждое сообщение должно обрабатываться последовательно, несмотря на то, что несколько сообщений могут быть доступны в буфере входное сообщение. Модель потока данных позволяет обе ветви условного оператора, для оценки одновременно. Модель потоков данных также позволяет создавать более сложные сети обмена сообщениями, которые работают с данными, так как она станет доступной.

[[В начало](#top)]

##  <a name="dataflow"></a> Создание основного агента потока данных

В этом разделе показано, как преобразовать `control_flow_agent` класс для использования модели потока данных для выполнения той же задачи.

Агент потока данных работает путем создания сети буферов сообщений, каждый из которых служит определенной цели. Некоторые блоки сообщений использовать функцию фильтрации, чтобы принимать и отклонять сообщения в зависимости от его полезные данные. Функция фильтрации гарантирует, что блок сообщений получать только определенные значения.

#### <a name="to-convert-the-control-flow-agent-to-a-dataflow-agent"></a>Для преобразования потока управления агента для агента потоков данных

1. Скопируйте текст `control_flow_agent` класса в другой класс, например, `dataflow_agent`. Кроме того, вы можете переименовать `control_flow_agent` класса.

1. Удалите основную часть цикла, который вызывает `receive` из `run` метод.

[!code-cpp[concrt-dataflow-agent#2](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_2.cpp)]

1. В `run` метод после инициализации переменных `negative_count` и `positive_count`, добавьте `countdown_event` объект, который отслеживает число активных операций.

[!code-cpp[concrt-dataflow-agent#6](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_3.cpp)]

   `countdown_event` Класс показан далее в этом разделе.

1. Создайте сообщение в буфер объектов, которые будут участвовать в сети потока данных.

[!code-cpp[concrt-dataflow-agent#3](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_4.cpp)]

1. Подключите буферов сообщений для формирования сети.

[!code-cpp[concrt-dataflow-agent#4](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_5.cpp)]

1. Дождитесь `event` и `countdown event` установки объектов. Эти события указывают, что агент получил значение-метку, и что изучили все операции.

[!code-cpp[concrt-dataflow-agent#5](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_6.cpp)]

На следующей схеме показана полная сеть потока данных для `dataflow_agent` класса:

![Сети потока данных](../../parallel/concrt/media/concrt_dataflow.png "concrt_dataflow")

Следующая таблица описывает члены сети.

|Член|Описание|
|------------|-----------------|
|`increment_active`|Объект [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) объект, который увеличивает значение счетчика активных событий и передает входное значение к остальной части сети.|
|`negatives`, `positives`|[Concurrency::Call](../../parallel/concrt/reference/call-class.md) объекты, увеличивающие счетчик чисел и уменьшает значение счетчика активных событий. Все объекты используют фильтр принимать отрицательные или положительные числа.|
|`sentinel`|Объект [concurrency::call](../../parallel/concrt/reference/call-class.md) объекта, который принимает только значение-метку ноль и уменьшает значение счетчика активных событий.|
|`connector`|Объект [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) объект, который подключается к внутренней сети исходного буфера сообщений.|

Так как `run` метод вызывается в отдельном потоке, другие потоки могут отправлять сообщения в сеть до полностью подключение к сети. `_source` Член данных является `unbounded_buffer` объект, который буферизует все входные данные, отправленные из приложения к агенту. Чтобы убедиться в том, что сети обрабатывает все входные сообщения, агент сначала связывает внутренние узлы сети, а затем связывает начала этой сети, `connector`, `_source` данные-член. Это гарантирует, что сообщения не будут обрабатываться как формируется сети.

Поскольку сети в этом примере основан на потоке данных, а не в потоке управления, сети должны обмениваться данными агенту о завершении обработки каждого входного значения и что соответствующий узел получил его значение. В этом примере используется `countdown_event` чтобы сообщить, что все входные значения обработаны и [concurrency::event](../../parallel/concrt/reference/event-class.md) объекте, чтобы указать, что соответствующий узел получил его значение. `countdown_event` Класс использует `event` объекта, чтобы сообщить, что значение счетчика достигло нуля. Начало сети потока данных увеличивает значение счетчика, каждый раз, что он получает значение. Каждый конечный узел сети уменьшает счетчик после его обработки входных значений. Когда агент формирует сети потока данных, он ожидает sentinel узел, чтобы задать `event` объекта и для `countdown_event` чтобы сообщить, что его счетчика равно нулю.

В следующем примере показан `control_flow_agent`, `dataflow_agent`, и `countdown_event` классы. `wmain` Функция создает `control_flow_agent` и `dataflow_agent` и использует `send_values` функцию для отправки на агентах серию случайных значений.

[!code-cpp[concrt-dataflow-agent#7](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_7.cpp)]

В этом примере получается следующий результат:

```Output
Control-flow agent:
There are 500523 negative numbers.
There are 499477 positive numbers.
Dataflow agent:
There are 500523 negative numbers.
There are 499477 positive numbers.
```

### <a name="compiling-the-code"></a>Компиляция кода

Скопируйте код примера и вставьте его в проект Visual Studio или вставьте его в файл с именем `dataflow-agent.cpp` и выполните следующую команду в окне командной строки Visual Studio.

**поток данных/EHsc CL.exe-agent.cpp**

[[В начало](#top)]

##  <a name="logging"></a> Создание агента ведения журнала сообщений

В следующем примере показан `log_agent` класс, который напоминает `dataflow_agent` класса. `log_agent` Класс реализует асинхронные ведения журнала агента, который записывает журнал сообщений в файл и на консоль. `log_agent` Класс позволяет приложению классифицировать сообщения как информационное, предупреждение или ошибка. Он также позволяет приложению задавать журналы каждой категории, записываются ли файл и консоль. Этот пример записывает все сообщения журнала в файл и только сообщения об ошибках на консоль.

[!code-cpp[concrt-log-filter#1](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_8.cpp)]

Этот пример выводит следующие выходные данные на консоль.

```Output
error: This is a sample error message.
```

Этот пример также создает файл log.txt, который содержит следующий текст.

```Output
info: ===Logging started.===
warning: This is a sample warning message.
error: This is a sample error message.
info: ===Logging finished.===
```

### <a name="compiling-the-code"></a>Компиляция кода

Скопируйте код примера и вставьте его в проект Visual Studio или вставьте его в файл с именем `log-filter.cpp` и выполните следующую команду в окне командной строки Visual Studio.

**/ EHsc CL.exe log-filter.cpp**

[[В начало](#top)]

## <a name="see-also"></a>См. также

[Пошаговые руководства по среде выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-walkthroughs.md)

