---
title: Рекомендации по работе с библиотекой асинхронных агентов
ms.date: 11/04/2016
helpviewer_keywords:
- best practices, Asynchronous Agents Library
- Asynchronous Agents Library, best practices
- Asynchronous Agents Library, practices to avoid
- practices to avoid, Asynchronous Agents Library
ms.assetid: 85f52354-41eb-4b0d-98c5-f7344ee8a8cf
ms.openlocfilehash: 1cd6b54a014d35d17c732ed52f8529b05274585b
ms.sourcegitcommit: a8ef52ff4a4944a1a257bdaba1a3331607fb8d0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77142098"
---
# <a name="best-practices-in-the-asynchronous-agents-library"></a>Рекомендации по работе с библиотекой асинхронных агентов

В этом документе описывается, как эффективно использовать библиотеку асинхронных агентов. Библиотека агентов поддерживает модель программирования на основе субъектов и передачу сообщений внутри процесса для недетализированного потока данных и задач конвейеризации.

Дополнительные сведения о библиотеке агентов см. в разделе [Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md).

## <a name="top"></a> Разделы

Этот документ содержит следующие разделы.

- [Изоляция состояния с помощью агентов](#isolation)

- [Использование механизма регулирования для ограничения количества сообщений в конвейере данных](#throttling)

- [Не выполнять детализированную работу в конвейере данных](#fine-grained)

- [Не передавайте большие полезные данные сообщений по значению](#large-payloads)

- [Использование shared_ptr в сети данных, если владение не определено](#ownership)

## <a name="isolation"></a>Изоляция состояния с помощью агентов

Библиотека агентов предоставляет альтернативы общему состоянию, позволяя подключать изолированные компоненты через асинхронный механизм передачи сообщений. Асинхронные агенты наиболее эффективны, если они изолируют свое внутреннее состояние от других компонентов. При изоляции состояния несколько компонентов обычно не работают с общими данными. Изоляция состояния может позволить приложению масштабироваться, так как оно уменьшает состязание за общую память. Изоляция состояния также сокращает вероятность взаимоблокировок и состояний гонки, так как компоненты не должны синхронизировать доступ к общим данным.

Состояние в агенте обычно изолируется путем хранения элементов данных в `private` или `protected` разделах класса агента и с помощью буферов сообщений для передачи изменений состояния. В следующем примере показан класс `basic_agent`, производный от [Concurrency:: Agent](../../parallel/concrt/reference/agent-class.md). Класс `basic_agent` использует два буфера сообщений для взаимодействия с внешними компонентами. Один буфер сообщений содержит входящие сообщения; в другом буфере сообщений содержатся исходящие сообщения.

[!code-cpp[concrt-simple-agent#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_1.cpp)]

Полные примеры определения и использования агентов см. в разделе [Пошаговое руководство. Создание приложения на основе агента](../../parallel/concrt/walkthrough-creating-an-agent-based-application.md) и [Пошаговое руководство. Создание агента потоков](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)данных.

[[В начало](#top)]

## <a name="throttling"></a>Использование механизма регулирования для ограничения количества сообщений в конвейере данных

Многие типы буферов сообщений, например [Concurrency:: unbounded_buffer](reference/unbounded-buffer-class.md), могут содержать неограниченное количество сообщений. Когда производитель сообщений отправляет сообщения в конвейер данных быстрее, чем потребитель может обработать эти сообщения, приложение может ввести нехватка памяти или состояние нехватки памяти. Для ограничения количества сообщений, одновременно активных в конвейере данных, можно использовать механизм регулирования, например семафор.

В следующем примере показано использование семафора для ограничения количества сообщений в конвейере данных. Конвейер данных использует функцию [Concurrency:: wait](reference/concurrency-namespace-functions.md#wait) для имитации операции, которая занимает не менее 100 миллисекунд. Поскольку отправитель создает сообщения быстрее, чем потребитель может обработать эти сообщения, в этом примере определяется класс `semaphore`, позволяющий приложению ограничить количество активных сообщений.

[!code-cpp[concrt-message-throttling#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_2.cpp)]

Объект `semaphore` ограничивает обработку конвейера не более чем двумя сообщениями одновременно.

В этом примере производитель отправляет относительно недостаточное число сообщений потребителю. Поэтому в этом примере не демонстрируется потенциально нехватка памяти или нехватка памяти. Однако этот механизм полезен, если конвейер данных содержит относительно большое количество сообщений.

Дополнительные сведения о создании класса семафора, используемого в этом примере, см. в разделе [как использовать класс контекста для реализации параллельного семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md).

[[В начало](#top)]

## <a name="fine-grained"></a>Не выполнять детализированную работу в конвейере данных

Библиотека агентов наиболее полезна, если работа, выполняемая конвейером данных, достаточно детализирована. Например, один компонент приложения может считывать данные из файла или сетевого подключения и периодически передавать эти данные в другой компонент. Протокол, используемый библиотекой агентов для распространения сообщений, приводит к тому, что механизм передачи сообщений будет иметь больше издержек, чем конструкции параллельных задач, предоставляемые [библиотекой параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md) (PPL). Поэтому убедитесь, что работа, выполняемая конвейером данных, достаточно длинна, чтобы отменять эти затраты.

Хотя конвейер данных наиболее эффективен, когда его задачи детализированы, каждый этап конвейера данных может использовать конструкции PPL, такие как группы задач и параллельные алгоритмы, для выполнения более детализированной работы. Пример недетализированной сети данных, в которой используется детализированный параллелизм на каждом этапе обработки, см. в разделе [Пошаговое руководство. Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).

[[В начало](#top)]

## <a name="large-payloads"></a>Не передавайте большие полезные данные сообщений по значению

В некоторых случаях среда выполнения создает копию каждого сообщения, которое передается из одного буфера сообщений в другой. Например, класс [Concurrency:: overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) предлагает копию каждого сообщения, которое оно получает для каждой цели. Среда выполнения также создает копию данных сообщения при использовании таких функций передачи сообщений, как [Concurrency:: send](reference/concurrency-namespace-functions.md#send) и [Concurrency:: Receive](reference/concurrency-namespace-functions.md#receive) для записи сообщений в буфер сообщений и чтения сообщений из него. Хотя этот механизм помогает устранить риск одновременной записи в общие данные, это может привести к ухудшению производительности памяти, когда полезная нагрузка сообщения относительно велика.

Можно использовать указатели или ссылки для повышения производительности памяти при передаче сообщений с большими объемами полезных данных. В следующем примере сравниваются передача больших сообщений по значению для передачи указателей на один и тот же тип сообщений. В примере определяются два типа агентов: `producer` и `consumer`, которые работают с `message_data`ными объектами. В примере сравнивается время, требуемое производителю для отправки нескольких `message_data` объектов потребителю на время, необходимое агенту-производителю для отправки нескольких указателей на `message_data` объекты потребителю.

[!code-cpp[concrt-message-payloads#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_3.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
Using message_data...
took 437ms.
Using message_data*...
took 47ms.
```

Версия, использующая указатели, работает лучше, так как устраняет необходимость создания полной копии каждого `message_data` объекта, переданного от производителя к потребителю, в среде выполнения.

[[В начало](#top)]

## <a name="ownership"></a>Использование shared_ptr в сети данных, если владение не определено

При отправке сообщений по указателю через конвейер или сеть, передающие сообщения, обычно выделяется память для каждого сообщения в начале сети и освобождается память в конце сети. Несмотря на то, что этот механизм часто работает хорошо, бывают случаи, в которых это сложно или невозможно использовать. Например, рассмотрим случай, в котором сеть данных содержит несколько конечных узлов. В этом случае нет четкого расположения для освобождения памяти для сообщений.

Чтобы решить эту проблему, можно использовать механизм, например [std:: shared_ptr](../../standard-library/shared-ptr-class.md), который обеспечивает принадлежность указателя нескольким компонентам. Когда удаляется последний объект `shared_ptr`, владеющий ресурсом, ресурс также освобождается.

В следующем примере демонстрируется использование `shared_ptr` для совместного использования значений указателей между несколькими буферами сообщений. В примере объект [Concurrency:: overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) соединяется с тремя объектами [Concurrency:: Call](../../parallel/concrt/reference/call-class.md) . Класс `overwrite_buffer` предлагает сообщения для каждой цели. Так как в конце сети данных существует несколько владельцев данных, в этом примере используется `shared_ptr`, чтобы каждый объект `call` был совместно использовать владение сообщениями.

[!code-cpp[concrt-message-sharing#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_4.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
Creating resource 42...
receiver1: received resource 42
Creating resource 64...
receiver2: received resource 42
receiver1: received resource 64
Destroying resource 42...
receiver2: received resource 64
Destroying resource 64...
```

## <a name="see-also"></a>См. также раздел

[Рекомендации по работе со средой выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-best-practices.md)<br/>
[Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)<br/>
[Пошаговое руководство. Создание приложения на основе агента](../../parallel/concrt/walkthrough-creating-an-agent-based-application.md)<br/>
[Пошаговое руководство. Создание агента потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)<br/>
[Пошаговое руководство. Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)<br/>
[Рекомендации по работе с библиотекой параллельных шаблонов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md)<br/>
[Общие рекомендации в среде выполнения с параллелизмом](../../parallel/concrt/general-best-practices-in-the-concurrency-runtime.md)
