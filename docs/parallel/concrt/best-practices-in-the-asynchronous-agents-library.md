---
title: Рекомендации по работе с библиотекой асинхронных агентов
ms.date: 11/04/2016
helpviewer_keywords:
- best practices, Asynchronous Agents Library
- Asynchronous Agents Library, best practices
- Asynchronous Agents Library, practices to avoid
- practices to avoid, Asynchronous Agents Library
ms.assetid: 85f52354-41eb-4b0d-98c5-f7344ee8a8cf
ms.openlocfilehash: c61393957a63895a9ecbdaaae8d83a5fbd710de3
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62236565"
---
# <a name="best-practices-in-the-asynchronous-agents-library"></a>Рекомендации по работе с библиотекой асинхронных агентов

В этом документе описывается, как эффективно использовать библиотеку асинхронных агентов. Библиотека агентов поддерживает модель программирования на основе субъектов и в процессе передачи сообщений для недетализированного потока данных и задач по конвейеризации.

Дополнительные сведения о библиотеке агентов см. в разделе [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md).

##  <a name="top"></a> Разделы

Этот документ содержит следующие разделы.

- [Использовать агенты для изолирования состояния](#isolation)

- [Используйте механизм регулирования для ограничения количества сообщений в конвейере данных](#throttling)

- [Не выполняйте детализированную работу в конвейере данных](#fine-grained)

- [Не передавайте полезных данных больших сообщений по значению](#large-payloads)

- [Используйте в данных сети при владения является неопределенным shared_ptr](#ownership)

##  <a name="isolation"></a> Использовать агенты для изолирования состояния

Библиотека агентов предоставляет альтернативы общему состоянию, позволяя подключать изолированные компоненты через механизм асинхронной передачи сообщений. Асинхронные агенты наиболее эффективны, когда они изолировать свое внутреннее состояние от других компонентов. При изоляции состояний несколько компонентов обычно не работают с общими данными. Изоляция состояния позволяет приложению масштабироваться, так как он уменьшает конкуренцию внутри общей памяти. Изоляция состояния также уменьшает вероятность возникновения взаимоблокировок и состояния гонки, так как компоненты не имеют для синхронизации доступа к общим данным.

Обычно, чтобы изолировать состояние агента, удерживая данные-члены в `private` или `protected` разделах класса агента и с помощью буферов сообщений, чтобы сообщать об изменениях состояния. В следующем примере показан `basic_agent` класс, который является производным от [concurrency::agent](../../parallel/concrt/reference/agent-class.md). `basic_agent` Класс использует два буфера сообщений для взаимодействия с внешними компонентами. Один буфер сообщений содержит входящие сообщения; второй буфер сообщений — исходящие сообщения.

[!code-cpp[concrt-simple-agent#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_1.cpp)]

Полные примеры для определения и использования агентов, см. в разделе [Пошаговое руководство: Создание приложения с поддержкой агента](../../parallel/concrt/walkthrough-creating-an-agent-based-application.md) и [Пошаговое руководство: Создание агента потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md).

[[В начало](#top)]

##  <a name="throttling"></a> Используйте механизм регулирования для ограничения количества сообщений в конвейере данных

Многие типы буфер сообщений, таких как [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md), может содержать неограниченное число сообщений. Когда производитель отправляет сообщения в конвейер данных быстрее, чем получатель может обработать эти сообщения, приложения могут переходить в состояние нехватки памяти или из за памяти. Можно использовать механизм регулирования, например, семафор, чтобы ограничить количество сообщений, которые одновременно активны в конвейере данных.

Следующий пример демонстрирует использовать семафор, чтобы ограничить количество сообщений в конвейере данных. Конвейер данных использует [concurrency::wait](reference/concurrency-namespace-functions.md#wait) функции для имитации операцию, которая требуется по крайней мере 100 миллисекунд. Так как отправитель создает сообщения быстрее, чем получатель может обработать эти сообщения, в этом примере определяется `semaphore` класс этого приложения ограничить количество активных сообщений.

[!code-cpp[concrt-message-throttling#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_2.cpp)]

`semaphore` Объект ограничивает конвейер для обработки не более двух сообщений, в то же время.

В этом примере производитель отправляет сообщения относительно небольшого числа объекту-получателю. Таким образом этот пример не демонстрирует потенциальный нехватки памяти или из за памяти. Тем не менее этот механизм полезен, когда конвейер данных содержит относительно большое число сообщений.

Дополнительные сведения о создании semaphore-класс, который используется в этом примере, см. в разделе [как: Использование класса Context для реализации семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md).

[[В начало](#top)]

##  <a name="fine-grained"></a> Не выполняйте детализированную работу в конвейере данных

Библиотека агентов наиболее полезна в случаях, когда работа, выполняемая конвейер данных будет довольно грубый. Например один компонент приложения может считывать данные из файла или сетевого подключения и отправлять эти данные другому компоненту. Протокол, который использует библиотеки агентов для распространения сообщений вызывает механизм передачи сообщений к дополнительным затратам ресурсов, чем задача параллельные конструкции, которые предоставляются [библиотеку параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md) (PPL). Таким образом Убедитесь, что работа, выполняемая конвейер данных достаточно длинным, чтобы оправдать дополнительную нагрузку.

Несмотря на то, что конвейер данных наиболее эффективен при выполнении недетализированных задач, каждого этапа конвейера данных можно использовать PPL конструкций, таких как группы задач и параллельных алгоритмов для выполнения более детализированную работу. Пример сети недетализированного данных, использующей точного параллелизма на каждом этапе обработки, см. в разделе [Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).

[[В начало](#top)]

##  <a name="large-payloads"></a> Не передавайте полезных данных больших сообщений по значению

В некоторых случаях среда выполнения создает копию всех сообщений, передаваемых между буферами сообщений. Например [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) класс предлагает копию каждого сообщения, для каждого из его целевых объектов. Среда выполнения также создает копию данных сообщения при использовании функции передачи сообщений, таких как [concurrency::send](reference/concurrency-namespace-functions.md#send) и [concurrency::receive](reference/concurrency-namespace-functions.md#receive) для записи сообщений и чтения сообщений из сообщения буфер. Несмотря на то, что этот механизм помогает исключить опасность параллельной записи к общим данным, это может привести к падению производительности памяти, если полезные данные сообщения относительно велико.

Вы можете использовать указатели или ссылки для повышения производительности памяти, при передаче сообщений, имеют большой объем данных. В следующем примере сравнивается передача больших сообщений по значению передача указателей на тот же тип сообщений. В примере определяется два типа агента, `producer` и `consumer`, который действовать `message_data` объектов. В примере сравнивается время, необходимое для производителя для отправки нескольких `message_data` потребителю время, необходимое для производителя агента для отправки нескольких указателей на объекты `message_data` объекты объекту-получателю.

[!code-cpp[concrt-message-payloads#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_3.cpp)]

В этом примере получается следующий результат:

```Output
Using message_data...
took 437ms.
Using message_data*...
took 47ms.
```

Версии, использующей указатели работает лучше, поскольку это исключают потребность для среды выполнения для создания полной копии каждые `message_data` объектов, передаваемых от производителя к потребителю.

[[В начало](#top)]

##  <a name="ownership"></a> Используйте в данных сети при владения является неопределенным shared_ptr

При отправке сообщений по указателю через передачи сообщений конвейера или сети обычно выделения памяти для каждого сообщения в передней части сети и освободить память в конечной точке сети. Несмотря на то, что этот механизм часто работает хорошо, бывают случаи, в которых бывает трудно или невозможно использовать его. Например рассмотрим случай, в которой сеть данных содержит несколько конечных узлов. В этом случае есть нет определенного расположения, чтобы освободить память для сообщений.

Чтобы решить эту проблему, можно использовать механизм, например, [std::shared_ptr](../../standard-library/shared-ptr-class.md), который позволяет указатель может принадлежать нескольким компонентам. При последней `shared_ptr` является объект, которому принадлежит ресурс, ресурс также освобождается.

Следующий пример демонстрирует, как использовать `shared_ptr` для совместного использования значений указателей среди нескольких буферов сообщений. В примере устанавливается подключение [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) объекта до трех [concurrency::call](../../parallel/concrt/reference/call-class.md) объектов. `overwrite_buffer` Класс предлагает сообщений к каждому из его целевых объектов. Так как существует несколько владельцев данных в конце сети данных, в этом примере используется `shared_ptr` чтобы каждый из них `call` объект одним владельцем сообщений.

[!code-cpp[concrt-message-sharing#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-asynchronous-agents-library_4.cpp)]

В этом примере получается следующий результат:

```Output
Creating resource 42...
receiver1: received resource 42
Creating resource 64...
receiver2: received resource 42
receiver1: received resource 64
Destroying resource 42...
receiver2: received resource 64
Destroying resource 64...
```

## <a name="see-also"></a>См. также

[Рекомендации по работе со средой выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-best-practices.md)<br/>
[Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)<br/>
[Пошаговое руководство: Создание приложения на основе агента](../../parallel/concrt/walkthrough-creating-an-agent-based-application.md)<br/>
[Пошаговое руководство: Создание агента для обработки потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)<br/>
[Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)<br/>
[Рекомендации по работе с библиотекой параллельных шаблонов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md)<br/>
[Общие рекомендации в среде выполнения с параллелизмом](../../parallel/concrt/general-best-practices-in-the-concurrency-runtime.md)
