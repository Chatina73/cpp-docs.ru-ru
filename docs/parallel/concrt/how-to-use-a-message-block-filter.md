---
title: Практическое руководство. Использование фильтра блоков сообщений
ms.date: 11/04/2016
helpviewer_keywords:
- message-block filters, using [Concurrency Runtime]
- using message-block filters [Concurrency Runtime]
ms.assetid: db6b99fb-288d-4477-96dc-b9751772ebb2
ms.openlocfilehash: 074d3989ce48b0b6d69206e3f83c374a2ec65c93
ms.sourcegitcommit: a8ef52ff4a4944a1a257bdaba1a3331607fb8d0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77142819"
---
# <a name="how-to-use-a-message-block-filter"></a>Практическое руководство. Использование фильтра блоков сообщений

В этом документе показано, как использовать функцию фильтра, чтобы позволить асинхронному блоку сообщений принимать или отклонять сообщения на основе полезных данных этого сообщения.

При создании объекта блока сообщений, такого как [Concurrency:: unbounded_buffer](reference/unbounded-buffer-class.md), [Concurrency:: Call](../../parallel/concrt/reference/call-class.md)или [Concurrency:: transformer](../../parallel/concrt/reference/transformer-class.md), можно указать *функцию фильтра* , которая определяет, будет ли блок сообщений принимать или отклонять сообщение. Функция фильтра — это удобный способ гарантировать, что блок сообщений получает только определенные значения.

Функции фильтров важны, так как они позволяют подключать блоки сообщений для формирования *сетей потоков*данных. В сети потока данных блоки сообщений управляют ходом обработки сообщений, обрабатывая только те сообщения, которые удовлетворяют определенным условиям. Сравните это с моделью потока управления, где поток данных регулируется с помощью структур управления, таких как условные операторы, циклы и т. д.

В этом документе представлен простой пример использования фильтра сообщений. Дополнительные примеры использования фильтров сообщений и модели потоков данных для подключения блоков сообщений см. в разделе [Пошаговое руководство. Создание агента потоков](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md) данных и [Пошаговое руководство. Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).

## <a name="example"></a>Пример

Рассмотрим следующую функцию, `count_primes`, которая иллюстрирует базовое использование блока сообщений, который не фильтрует входящие сообщения. Блок сообщений добавляет простые числа к объекту [std:: Vector](../../standard-library/vector-class.md) . Функция `count_primes` отправляет несколько чисел в блок сообщений, получает выходные значения из блока сообщений и выводит эти числа, которые являются простыми в консоли.

[!code-cpp[concrt-primes-filter#1](../../parallel/concrt/codesnippet/cpp/how-to-use-a-message-block-filter_1.cpp)]

Объект `transformer` обрабатывает все входные значения; Однако для этого требуются только простые значения. Несмотря на то, что приложение может быть написано таким образом, чтобы отправитель сообщений отправлял только простые числа, требования получателя сообщений не всегда известны.

## <a name="example"></a>Пример

Следующая функция, `count_primes_filter`, выполняет ту же задачу, что и функция `count_primes`. Однако объект `transformer` в этой версии использует функцию Filter, чтобы принимать только те значения, которые являются простыми. Функция, которая выполняет действие, получает только простые числа; Поэтому не нужно вызывать функцию `is_prime`.

Поскольку объект `transformer` получает только простые числа, сам объект `transformer` может содержать простые числа. Иными словами, объект `transformer` в этом примере не требуется для добавления простых чисел в объект `vector`.

[!code-cpp[concrt-primes-filter#2](../../parallel/concrt/codesnippet/cpp/how-to-use-a-message-block-filter_2.cpp)]

Объект `transformer` теперь обрабатывает только простые значения. В предыдущем примере `transformer` объект обрабатывает все сообщения. Поэтому в предыдущем примере должно быть получено то же количество отправленных сообщений. В этом примере используется результат функции [Concurrency:: send](reference/concurrency-namespace-functions.md#send) , чтобы определить количество сообщений, получаемых из объекта `transformer`. Функция `send` возвращает **значение true** , если буфер сообщений принимает сообщение, и **значение false** , если буфер сообщений отклоняет сообщение. Таким образом, количество простых чисел в буфере сообщений соответствует числу значений.

## <a name="example"></a>Пример

Ниже приведен полный пример кода. В примере вызывается как функция `count_primes`, так и функция `count_primes_filter`.

[!code-cpp[concrt-primes-filter#3](../../parallel/concrt/codesnippet/cpp/how-to-use-a-message-block-filter_3.cpp)]

## <a name="compiling-the-code"></a>Компиляция кода

Скопируйте пример кода и вставьте его в проект Visual Studio или вставьте в файл с именем `primes-filter.cpp`, а затем выполните следующую команду в окне командной строки Visual Studio.

> **CL. exe/EHsc примес-филтер. cpp**

## <a name="robust-programming"></a>Отказоустойчивость

Функция фильтра может быть лямбда-функцией, указателем функции или объектом функции. Каждая функция фильтра имеет одну из следующих форм:

```Output
bool (T)
bool (T const &)
```

Чтобы исключить ненужное копирование данных, используйте вторую форму при наличии статистического типа, передаваемого по значению.

## <a name="see-also"></a>См. также раздел

[Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)<br/>
[Пошаговое руководство. Создание агента потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md)<br/>
[Пошаговое руководство. Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)<br/>
[Класс transformer](../../parallel/concrt/reference/transformer-class.md)
