---
title: Создание асинхронных операций в СЗ для приложений UWP
ms.date: 11/19/2018
helpviewer_keywords:
- Windows 8.x apps, creating C++ async operations
- Creating C++ async operations
ms.assetid: a57cecf4-394a-4391-a957-1d52ed2e5494
ms.openlocfilehash: 635a8c95a3801c6e88feff1cefa3ed27727a8f88
ms.sourcegitcommit: 89d9e1cb08fa872483d1cde98bc2a7c870e505e9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "82032191"
---
# <a name="creating-asynchronous-operations-in-c-for-uwp-apps"></a>Создание асинхронных операций в СЗ для приложений UWP

В этом документе описаны некоторые ключевые моменты, которые следует иметь в виду при использовании класса задач для создания асинхронных операций на основе Windows ThreadPool в приложении Universal Windows Runtime (UWP).

Использование асинхронного программирования является ключевым компонентом модели приложения Windows Runtime, поскольку позволяет приложениям сохранять реакцию на пользовательский ввод. Можно запустить длительную задачу без блокировки потока ИП и получить результаты выполнения задачи позже. Можно также отменять задачи и получать уведомления о ходе выполнения задач, выполняемых в фоновом режиме. В документе [Асинхронного программирования в СЗЗ](/windows/uwp/threading-async/asynchronous-programming-in-cpp-universal-windows-platform-apps) содержится обзор асинхронного шаблона, который доступен в Visual C е для создания приложений UWP. Этот документ учит, как как потреблять и создавать цепочки асинхронных операций Windows Runtime. В этом разделе описывается, как использовать типы в ppltasks.h для получения асинхронных операций, которые могут быть использованы другим компонентом Windows Runtime, и как контролировать, как выполняется асинхронная работа. Также рассмотрите возможность чтения [шаблонов программирования Async в Hilo (приложения магазина Windows, использующие C и XAML),](/previous-versions/windows/apps/jj160321(v=win.10)) чтобы узнать, как мы использовали класс задач для реализации асинхронных операций в Hilo, приложении Windows Runtime с использованием СЗ и XAML.

> [!NOTE]
> Библиотеку [параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md) (PPL) и [библиотеку асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md) можно использовать в приложении UWP. Однако невозможно использовать планировщик задач или диспетчер ресурсов. В этом документе описаны дополнительные функции, которые предоставляет PPL, которые доступны только приложению UWP, а не настольное приложение.

## <a name="key-points"></a>Ключевые моменты

- Используйте [concurrency::create_async](reference/concurrency-namespace-functions.md#create_async) для создания асинхронных операций, которые могут использоваться другими компонентами (которые могут быть написаны на языках, отличных от C++).

- Используйте [concurrency::progress_reporter](../../parallel/concrt/reference/progress-reporter-class.md) для передачи уведомлений о ходе выполнения компонентам, которые вызывают ваши асинхронные операции.

- Используйте токены отмены, чтобы обеспечить возможность отмены внутренних асинхронных операций.

- Поведение функции `create_async` зависит от передаваемого ей возвращаемого типа рабочей функции. Рабочая функция, которая возвращает задачу ( `task<T>` или `task<void>`) выполняется синхронно в контексте, который вызвал `create_async`. Рабочая функция, возвращающая `T` или `void` , выполняется в произвольном контексте.

- Можно использовать метод [concurrency::task::then](reference/task-class.md#then) для создания цепочки задач, выполняемых друг за другом. В приложении UWP контекст по умолчанию для продолжения задачи зависит от того, как была построена эта задача. Если задача была создана путем передачи асинхронного действия конструктору задачи, или путем передачи лямбда-выражения, возвращающего асинхронное действие, то контекстом по умолчанию для всех продолжений этой задачи будет текущий контекст. Если задача не построена из асинхронного действия, то произвольный контекст используется по умолчанию для продолжения задачи. Можно переопределить контекст по умолчанию с помощью класса [concurrency::task_continuation_context](../../parallel/concrt/reference/task-continuation-context-class.md) .

## <a name="in-this-document"></a>Содержание документа

- [Создание асинхронных операций](#create-async)

- [Пример: создание компонента среды выполнения Windows на C++](#example-component)

- [Управление потоком выполнения](#exethread)

- [Пример: Управление выполнением в приложении Для выполнения Windows с помощью C и XAML](#example-app)

## <a name="creating-asynchronous-operations"></a><a name="create-async"></a>Создание асинхронных операций

Можно использовать задачу и модель продолжения в библиотеке параллельных шаблонов (PPL) для определения фоновых задач, а также и дополнительных задач, выполняемых по завершении предыдущей задачи. Эта функциональность предоставляется классом [concurrency::task](../../parallel/concrt/reference/task-class.md) . Дополнительные сведения об этой модели и классе `task` см. в разделе [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md).

Windows Runtime — это интерфейс программирования, который можно использовать для создания приложений UWP, которые работают только в специальной среде операционной системы. Такие приложения используют авторизованные функции, типы данных и устройства и распространяются из Microsoft Store. Windows Runtime *представлена двоичным интерфейсом приложений* (ABI). ABI — это базовый двоичный контракт, который делает AIS Windows Runtime доступными для языков программирования, таких как Visual C .

Используя Windows Runtime, вы можете использовать лучшие возможности различных языков программирования и объединить их в одно приложение. Например, можно создать ИП в JavaScript и выполнять трудоемкую вычислительную логику приложения в компоненте, написанном на C++. Возможность выполнять такие ресурсоемкие операции в фоновом режиме является ключевым фактором в обеспечении скорости реагирования ИП. Поскольку `task` класс специфичен для C,, необходимо использовать интерфейс Windows Runtime для передачи асинхронных операций другим компонентам (которые могут быть написаны на языках, не втомаях, помимо СЗ). Windows Runtime предоставляет четыре интерфейса, которые можно использовать для представления асинхронных операций:

[Windows::Foundation::IAsyncAction](/uwp/api/windows.foundation.iasyncaction)<br/>
Представляет асинхронное действие.

[Окна::Источник::: Газета>\<](/uwp/api/windows.foundation.iasyncactionwithprogress-1)<br/>
Представляет асинхронное действие, сообщающее о ходе выполнения.

[Окна::Основа::::>\<](/uwp/api/windows.foundation.iasyncoperation-1)<br/>
Представляет асинхронную операцию, которая возвращает результат.

[Окна::Основа:::IAsyncOperationWithProgress\<TResult, TProgress>](/uwp/api/windows.foundation.iasyncoperationwithprogress-2)<br/>
Возвращает асинхронную операцию, которая возвращает результат и отчитывается о ходе выполнения.

Понятие *действие* означает, что асинхронная задача не создает значение (представьте функцию, которая возвращает `void`). Понятие *операция* означает, что асинхронная задача создает значение. Понятие *ход выполнения* означает, что задача может отправить сообщение о ходе выполнения вызывающему объекту. Языки JavaScript, .NET Framework и Visual C++ предоставляют свои собственные способы создания экземпляров таких интерфейсов для использования с переходом через границы ABI. Для Visual C++ PPL предоставляет функцию [concurrency::create_async](reference/concurrency-namespace-functions.md#create_async) . Эта функция создает асинхронное действие или операцию Windows Runtime, представляющую собой выполнение задачи. `create_async` Функция принимает функцию работы (обычно выражение lambda), внутренне создает `task` объект и заворачивает эту задачу в один из четырех асинхронных интерфейсов Windows Runtime.

> [!NOTE]
> Используйте `create_async` только тогда, когда вам нужно создать функциональность, доступ к которым можно получить с другого языка или другого компонента Runtime Windows. Используйте класс `task` напрямую, если известно, что операция и создается, и используется кодом C++ в том же компоненте.

Возвращаемый тип `create_async` определяется типом аргументов. Например, если рабочая функция не возвращает значение и не сообщает о ходе выполнения, `create_async` возвращает `IAsyncAction`. Если рабочая функция не возвращает значение и сообщает о ходе выполнения, `create_async` возвращает `IAsyncActionWithProgress`. Чтобы сообщить о ходе выполнения, укажите объект [concurrency::progress_reporter](../../parallel/concrt/reference/progress-reporter-class.md) в качестве параметра рабочей функции. Возможность уведомления о ходе выполнения позволяет отчитываться о выполненном объеме работы и оставшемся объеме (например, в процентах). Это также позволяет сообщать о результатах, как только они становятся доступными.

Интерфейсы `IAsyncAction`, `IAsyncActionWithProgress<TProgress>`, `IAsyncOperation<TResult>`, `IAsyncActionOperationWithProgress<TProgress, TProgress>` предоставляют метод `Cancel` , позволяющий отменить асинхронную операцию. Класс `task` работает с токенами отмены. При использовании токена отмены, чтобы отменить работу, среда выполнения не запускает новую работу, которая подписывается на этот токен. Уже выполняющаяся работа может отслеживать свой токен отмены и останавливаться, когда имеет такую возможность. Этот механизм описан подробнее в документе [Cancellation in the PPL](cancellation-in-the-ppl.md). Отмену задачи можно связать с`Cancel` методами Runtime Windows двумя способами. Во-первых, можно определить рабочую функцию, передаваемую `create_async` для получения объекта [concurrency::cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md) . При `Cancel` вызове метода этот маркер отмены отменяется, а `task` к базовому `create_async` объекту, поддерживающему вызов, применяются правила отмены. Если объект `cancellation_token` не предоставляется, базовый объект `task` определит его неявно. Определите объект `cancellation_token` при необходимости совместно реагировать на отмену в вашей рабочей функции. Пример [раздела: Управление выполнением в Windows Runtime App с C и XAML](#example-app) показывает пример того, как выполнять отмену в приложении Universal Windows Platform (UWP) с c и XAML, в использовании пользовательского компонента Windows Runtime C.

> [!WARNING]
> В цепочке продолжения задач всегда очищайте состояние, а затем вызывайте [параллелизм::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) когда токен отмены отменяется. Если возврат выполняется раньше вместо вызова `cancel_current_task`, операция переходит в состояние завершения вместо состояния отмены.

В следующей таблице приведены сочетания, которые можно использовать для определения асинхронных операций в приложении.

|Для создания этого интерфейса Windows Runtime|Верните этот тип из `create_async`|Передайте эти типы параметров рабочей функции для использования неявного токена отмены|Передайте эти типы параметров рабочей функции для использования явного токена отмены|
|----------------------------------------------------------------------------------|------------------------------------------|--------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
|`IAsyncAction`|`void` либо `task<void>`|(нет)|(`cancellation_token`)|
|`IAsyncActionWithProgress<TProgress>`|`void` либо `task<void>`|(`progress_reporter`)|(`progress_reporter`, `cancellation_token`)|
|`IAsyncOperation<TResult>`|`T` либо `task<T>`|(нет)|(`cancellation_token`)|
|`IAsyncActionOperationWithProgress<TProgress, TProgress>`|`T` либо `task<T>`|(`progress_reporter`)|(`progress_reporter`, `cancellation_token`)|

Можно вернуть значение или объект `task` из рабочей функции, которое было передано функции `create_async` . Эти различия обеспечивают различное поведение. Если возвращается значение, рабочая функция оборачивается в `task` , чтобы ее можно выполнить в фоновом потоке. Кроме того базовый объект `task` использует неявный токен отмены. И наоборот, если возвращается объект `task` , рабочая функция выполняется синхронно. Следовательно, если возвращается объект `task` , убедитесь, что все длительные операции в вашей рабочей функции выполняются как задачи, чтобы приложение быстро реагировало на действия пользователя. Кроме того базовый объект `task` не использует неявный токен отмены. Поэтому необходимо определить вашу рабочую функцию, чтобы она принимала объект `cancellation_token` , если необходима поддержка отмены при возврате объекта `task` из `create_async`.

Ниже приводится различные способы `IAsyncAction` создания объекта, который может быть использован другим компонентом Runtime Windows.

[!code-cpp[concrt-windowsstore-primes#100](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_1.cpp)]

## <a name="example-creating-a-c-windows-runtime-component-and-consuming-it-from-c"></a><a name="example-component"></a>Пример: Создание компонента времени выполнения Windows и потребление его от C\#

Рассмотрим приложение, которое использует XAML и C'для определения uI и компонента Runtime Windows для выполнения вычислительных операций. В этом примере компонент C++ обнаруживает простые числа в заданном диапазоне. Чтобы проиллюстрировать различия между четырьмя асинхронными интерфейсами задач Windows Runtime, начните `Primes`с Visual Studio с создания **пустого решения** и его именования. Затем добавьте в решение проект **Компонент среды выполнения Windows** и назовите его `PrimesLibrary`. Добавьте следующий код в создаваемый файл заголовка C++ (в примере Class1.h переименовывается в Primes.h). Каждый метод `public` определяет один из 4 асинхронных интерфейсов. Методы, возвращающие значение, возвращают [Windows:::: Коллекции:: IVector\<int>](/uwp/api/windows.foundation.collections.ivector-1) объект. Методы, которые уведомляют о ходе выполнения, генерируют значения `double` , которые показывают, какой процент общей работы завершен.

[!code-cpp[concrt-windowsstore-primes#1](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_2.h)]

> [!NOTE]
> По конвенции, асинхронные имена методов в Windows Runtime обычно заканчиваются "Async".

Добавьте следующий код в сгенерированный файл с исходным кодом C++ (в примере Class1.cpp переименовывается в Primes.cpp). Функция `is_prime` определяет, является ли входное число простым. Остальные методы реализуют класс `Primes` . Каждый вызов `create_async` использует сигнатуру, которая совместима с методом, из которого он вызывается. Например, поскольку `Primes::ComputePrimesAsync` возвращает `IAsyncAction`, рабочая функция, переданная в `create_async` , не возвращает значение и не принимает объект `progress_reporter` в качестве параметра.

[!code-cpp[concrt-windowsstore-primes#2](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_3.cpp)]

Каждый метод сначала выполняет проверку, чтобы убедиться, что параметры ввода не являются отрицательными. Если входное значение отрицательное, метод выдает исключение [Platform::InvalidArgumentException](../../cppcx/platform-invalidargumentexception-class.md). Обработка ошибок объясняется далее в этом разделе.

Чтобы использовать эти методы из приложения UWP, используйте шаблон Visual C' **Blank App (XAML),** чтобы добавить второй проект в решение Visual Studio. В этом примере проект называется `Primes`. Затем из проекта `Primes` добавьте ссылку на проект `PrimesLibrary` .

Добавьте следующий код в MainPage.xaml. Этот код определяет пользовательский интерфейс, чтобы можно было вызвать компонент на С++ и вывести результат.

[!code-xml[concrt-windowsstore-primes#3](../../parallel/concrt/codesnippet/xaml/creating-asynchronous-operations-in-cpp-for-windows-store-apps_4.xaml)]

Добавьте следующий код в класс `MainPage` в файле MainPage.xaml. Этот код определяет объект `Primes` и обработчики событий для кнопки.

[!code-cs[concrt-windowsstore-primes#4](../../parallel/concrt/codesnippet/csharp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_5.cs)]

Эти методы используют ключевые слова `async` и `await` для обновления пользовательского интерфейса после выполнения асинхронных операций. Для получения информации об асинхронном кодировании в приложениях UWP [см.](/windows/uwp/threading-async)

Методы `getPrimesCancellation` и `cancelGetPrimes` работают вместе, позволяя пользователю отменить операцию. Когда пользователь выбирает кнопку **Отмена,** `cancelGetPrimes` метод называет [IAsyncOperationWithProgress\<TResult, TProgress>::Отмена](/uwp/api/windows.foundation.iasyncinfo.cancel) для отмены операции. В Concurrency Runtime, который управляет основной асинхронной операцией, выбрасывает внутренний тип исключения, который пойман Windows Runtime, чтобы сообщить, что отмена завершена. Для получения дополнительной информации о модели отмены [см.](../../parallel/concrt/cancellation-in-the-ppl.md)

> [!IMPORTANT]
> Чтобы PPL мог правильно сообщить в Windows Runtime об отмене операции, не ловите этот внутренний тип исключения. Это означает, что не нужно перехватывать все исключения (`catch (...)`). Если необходимо поймать все исключения, перебросьте исключение, чтобы убедиться, что Windows Runtime может завершить операцию отмены.

На следующем рисунке показано приложение `Primes` после выбора каждого параметра.

![Приложение Windows Runtime Primes](../../parallel/concrt/media/concrt_windows_primes.png "Приложение Windows Runtime Primes")

Дополнительную информацию о примерах, которые применяют `create_async` для создания асинхронных задач, которые могут использоваться другими языками, см. в разделе [Использование C++ в примере Bing Maps Trip Optimizer](/previous-versions/windows/apps/hh699891(v=vs.140)) и [Асинхронные операции в Windows 8 в C++ с PPL](https://code.msdn.microsoft.com/windowsapps/windows-8-asynchronous-08009a0d).

## <a name="controlling-the-execution-thread"></a><a name="exethread"></a>Управление потоком выполнения

В Windows Runtime используется модель потоков COM. В этой модели объекты размещаются в различных подразделениях в зависимости от того, как они обрабатывают свою синхронизацию. Потокобезопасные объекты размещаются в многопотоковых подразделениях (MTA). Объекты, которые должны быть доступны из одного потока, размещаются в однопотоковых подразделениях (STA).

В приложении с пользовательским интерфейсом поток ASTA (STA приложения) отвечает за перенос сообщений окна и является единственным потоком в процессе, который может обновить размещенные в STA элементы управления пользовательского интерфейса. Это имеет два последствия. Во-первых, для быстрого реагирования приложения на ввод пользователя все вычислительно сложные операции и операции ввода-вывода не должны выполняться в потоке ASTA. Во-вторых, результаты, полученные из фоновых потоков, должны маршалироваться обратно в ASTA для обновления пользовательского интерфейса. В приложении СЗ UWP `MainPage` и других страницах XAML все работают на ATSA. Поэтому продолжения задачи, которые объявляются в ASTA, выполняются там по умолчанию, поэтому можно обновлять элементы управления напрямую в теле продолжения. Однако если вложить задачу в другую задачу, все продолжения в этой вложенной задаче выполняются в MTA. Поэтому необходимо рассмотреть, требуется ли явно указать, в каком контексте выполняются эти продолжения.

Задачи, которые создаются из асинхронной операции, такие как `IAsyncOperation<TResult>`, используют специальную семантику, которая поможет игнорировать детали многопоточной реализации. Хотя операция может выполняться в фоновом потоке (или может совсем не обеспечиваться потоком), гарантируется выполнение ее продолжений по умолчанию в подразделении, начавшем операции продолжения (другими словами, из подразделения, вызвавшего `task::then`). Можно использовать класс [concurrency::task_continuation_context](../../parallel/concrt/reference/task-continuation-context-class.md) для управления контекстом выполнения продолжения. Используйте эти статические вспомогательные методы для создания объектов `task_continuation_context` .

- Используйте [concurrency::task_continuation_context::use_arbitrary](reference/task-continuation-context-class.md#use_arbitrary) , чтобы указать, что продолжение выполняется в фоновом потоке.

- Используйте [concurrency::task_continuation_context::use_current](reference/task-continuation-context-class.md#use_current) , чтобы указать, что продолжение выполняется в потоке, который вызвал `task::then`.

Можно передать объект `task_continuation_context` в метод [task::then](reference/task-class.md#then) , чтобы явно управлять контекстом выполнения продолжения, или можно передать задачу в другое подразделение и затем вызвать метод `task::then` для неявного управления контекстом выполнения.

> [!IMPORTANT]
> Поскольку основной поток uI приложений UWP выполняется под STA, продолжения, которые создаются на STA по умолчанию, работают на STA. Соответственно, продолжения, созданные в MTA, выполняются в MTA.

В следующем разделе показано приложение, которое считывает файл с диска, находит наиболее распространенные слова в этом файле, а затем отображает результаты в пользовательском интерфейсе. Последняя операция, обновление пользовательского интерфейса, происходит в потоке ИП.

> [!IMPORTANT]
> Такое поведение характерно для приложений UWP. В приложениях для настольных систем не требуется контролировать, где выполняются продолжения. Вместо этого планировщик выбирает рабочий поток, в котором будет выполняться каждое продолжение.

> [!IMPORTANT]
> Не вызывайте [concurrency::task::wait](reference/task-class.md#wait) в теле продолжения, выполняемого в STA. В противном случае среда выполнения создает [concurrency::invalid_operation](../../parallel/concrt/reference/invalid-operation-class.md) так как этот метод блокирует текущий поток и может вызвать зависание приложения. Тем не менее можно вызвать метод [concurrency::task::get](reference/task-class.md#get) для получения результата из предшествующей задачи в потоке задач.

## <a name="example-controlling-execution-in-a-windows-runtime-app-with-c-and-xaml"></a><a name="example-app"></a>Пример: Управление выполнением в приложении Для выполнения Windows с помощью C и XAML

Рассмотрим приложение C++ XAML, которое считывает файл с диска, находит наиболее распространенные слова в этом файле, а затем отображает результаты в пользовательском интерфейсе. Чтобы создать это приложение, начните, в Visual Studio, создав проект `CommonWords`Blank App **(Universal Windows)** и назвав его. В манифесте приложения укажите возможность **Библиотека документов** , которая позволяет приложению обращаться к папке "Документы". Также добавьте текстовый тип файла (TXT) в раздел объявлений манифеста приложения. Для получения дополнительной информации о возможностях и декларациях [приложений см.](/windows/win32/appxpkg/appx-portal)

Обновите элемент `Grid` в MainPage.xaml для включения элемента `ProgressRing` и элемента `TextBlock` . `ProgressRing` показывает, что операция выполняется, а `TextBlock` отображает результаты вычислений.

[!code-xml[concrt-windowsstore-commonwords#1](../../parallel/concrt/codesnippet/xaml/creating-asynchronous-operations-in-cpp-for-windows-store-apps_6.xaml)]

Добавьте `#include` следующие инструкции к *pch.h*.

[!code-cpp[concrt-windowsstore-commonwords#2](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_7.h)]

Добавьте следующие объявления методов в класс `MainPage` (MainPage.h).

[!code-cpp[concrt-windowsstore-commonwords#3](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_8.h)]

Добавьте следующие выражения `using` в MainPage.cpp.

[!code-cpp[concrt-windowsstore-commonwords#4](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_9.cpp)]

В файле MainPage.cpp реализуйте методы `MainPage::MakeWordList`, `MainPage::FindCommonWords`и `MainPage::ShowResults` . `MainPage::MakeWordList` и `MainPage::FindCommonWords` выполняют ресурсоемкие вычислительные операции. Метод `MainPage::ShowResults` отображает результат вычисления в пользовательском интерфейсе.

[!code-cpp[concrt-windowsstore-commonwords#5](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_10.cpp)]

Измените конструктор `MainPage` для создания цепочки задач продолжения, которые будут отображать в пользовательском интерфейсе распространенные слова из книги Гомера *Илиада* . Первые две задачи продолжения, которые разделят текст на отдельные слова и найдут распространенные слова, могут занимать продолжительное время, поэтому для них явно задано выполнение в фоновом режиме. Последняя задача продолжения, которая обновляет пользовательский интерфейс, не определяет контекст продолжения, поэтому следует правилам потоковых подразделений.

[!code-cpp[concrt-windowsstore-commonwords#6](../../parallel/concrt/codesnippet/cpp/creating-asynchronous-operations-in-cpp-for-windows-store-apps_11.cpp)]

> [!NOTE]
> В этом примере показано, как определить контексты выполнения и как составить цепочку продолжений. Помните, что по умолчанию задача, созданная из асинхронной операции, выполняет свои продолжения в подразделении, которое вызвало `task::then`. Таким образом, в этом примере используется `task_continuation_context::use_arbitrary` для указания того, что операции, которые не используют пользовательский интерфейс, должны выполняться в фоновом потоке.

На следующем рисунке показаны результаты выполнения приложения `CommonWords` .

![Приложение Windows Runtime CommonWords](../../parallel/concrt/media/concrt_windows_common_words.png "Приложение Windows Runtime CommonWords")

В этом примере можно поддерживать отмену, поскольку `task` объекты, поддерживающие `create_async` использование неявного маркера отмены. Определите свою рабочую функцию для приема объекта `cancellation_token` , если задачи должны отвечать на отмену в режиме совместной работы. Дополнительные сведения об отмене в PPL см. в разделе [Cancellation in the PPL](cancellation-in-the-ppl.md).

## <a name="see-also"></a>См. также раздел

[Параллелизм Runtime](../../parallel/concrt/concurrency-runtime.md)
