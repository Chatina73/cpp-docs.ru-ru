---
title: Класс task_group
ms.date: 07/20/2018
f1_keywords:
- task_group
- PPL/concurrency::task_group
- PPL/concurrency::task_group::task_group
helpviewer_keywords:
- task_group class
ms.openlocfilehash: 545b368b3042da74a42db5a6ea30e97054d5fd03
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57294139"
---
# <a name="taskgroup-class"></a>Класс task_group

Класс `task_group` представляет коллекцию параллельной работы, для которой возможно ожидание или отмена.

## <a name="syntax"></a>Синтаксис

```
class task_group;
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание:|
|----------|-----------------|
|[task_group](#ctor)|Перегружен. Создает новый `task_group` объекта.|
|[~ task_group деструктор](#dtor)|Уничтожает объект `task_group`. Вы должны вызывать либо `wait` или `run_and_wait` метода объекта до выполнения деструктора, если деструктор не выполняется в результате из-за исключения очистки стека.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание:|
|----------|-----------------|
|[Отмена](#cancel)|Делает гарантируется и осуществляется попытка отменить поддерево с корнем в эту группу задач работы. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.|
|[is_canceling](#is_canceling)|Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно означает, что `cancel` метод был вызван для `task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Может оказаться так, `task_group` объекта выполняется встроено и в группу задач вверх в дереве рабочего была отменена. В случаях, например сред, среда выполнения может определить заранее, что отмена будет передаваться через этот `task_group` объекта, `true` будет возвращено.|
|[run](#run)|Перегружен. Планирует задачу на `task_group` объекта. Если `task_handle` объект передается в качестве параметра `run`, вызывающий объект отвечает за управление временем существования `task_handle` объекта. Версию метода, который принимает ссылку на объект функции, как параметр, включает выделение кучи внутри среды выполнения, который может быть медленнее чем версия, которая принимает ссылку на `task_handle` объекта. Версия, принимающая параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.|
|[run_and_wait](#run_and_wait)|Перегружен. Планирует задачу для выполнения встроено в контексте вызова с помощью `task_group` объекта для поддержки полной отмены. Функция затем ожидает, пока все работают на `task_group` объекта завершена или отменена. Если `task_handle` объект передается в качестве параметра `run_and_wait`, вызывающий объект отвечает за управление временем существования `task_handle` объекта.|
|[wait](#wait)|Ожидает, пока все работают на `task_group` объекта завершена или отменена.|

## <a name="remarks"></a>Примечания

В отличие от сильно ограниченными правами `structured_task_group` класса `task_group` класс является гораздо более общие конструкции. Он не имеет ограничений, описываемого [structured_task_group](structured-task-group-class.md). `task_group` объекты могут безопасно использовать в потоках и загруженные свободной формы способами. Недостатком `task_group` конструкция — что он не может выполнять, а также `structured_task_group` построения для задач, выполняющих небольшие объемы работы.

Дополнительные сведения см. в разделе [параллелизм задач](../task-parallelism-concurrency-runtime.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`task_group`

## <a name="requirements"></a>Требования

**Заголовок:** ppl.h

**Пространство имен:** concurrency

##  <a name="cancel"></a> Отмена

Делает гарантируется и осуществляется попытка отменить поддерево с корнем в эту группу задач работы. Все задачи, запланированные в группе задач отменяются транзитивно, если это возможно.

```
void cancel();
```

### <a name="remarks"></a>Примечания

Дополнительные сведения см. в разделе [отмены](../cancellation-in-the-ppl.md).

##  <a name="is_canceling"></a> is_canceling

Сообщает вызывающей стороне, находится ли группа задач состоянии отмены. Это не обязательно означает, что `cancel` метод был вызван для `task_group` объекта (хотя это определенно позволяет этот метод для возврата `true`). Может оказаться так, `task_group` объекта выполняется встроено и в группу задач вверх в дереве рабочего была отменена. В случаях, например сред, среда выполнения может определить заранее, что отмена будет передаваться через этот `task_group` объекта, `true` будет возвращено.

```
bool is_canceling();
```

### <a name="return-value"></a>Возвращаемое значение

Указание, следует ли `task_group` объекта, в процессе отмены (или гарантированно будет вскоре).

### <a name="remarks"></a>Примечания

Дополнительные сведения см. в разделе [отмены](../cancellation-in-the-ppl.md).

##  <a name="run"></a> запустить

Планирует задачу на `task_group` объекта. Если `task_handle` объект передается в качестве параметра `run`, вызывающий объект отвечает за управление временем существования `task_handle` объекта. Версию метода, который принимает ссылку на объект функции, как параметр, включает выделение кучи внутри среды выполнения, который может быть медленнее чем версия, которая принимает ссылку на `task_handle` объекта. Версия, принимающая параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.

```
template<
   typename _Function
>
void run(
   const _Function& _Func
);

template<
   typename _Function
>
void run(
   const _Function& _Func,
   location& _Placement
);

template<
   typename _Function
>
void run(
   task_handle<_Function>& _Task_handle
);

template<
   typename _Function
>
void run(
   task_handle<_Function>& _Task_handle,
   location& _Placement
);
```

### <a name="parameters"></a>Параметры

*_Function*<br/>
Тип объекта функции, который будет вызываться для выполнения основной дескриптор задач.

*_Func*<br/>
Функция, которая будет вызываться для вызова тела задачи. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()`.

*Р_азмещения*<br/>
Ссылка на расположение, в котором должна выполняться задача, представленная параметром `_Func`.

*_Task_handle*<br/>
Дескриптор запланированных работ. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения будет продолжать ожидать, что его срок жизни либо до `wait` или `run_and_wait` об этом будет вызван метод `task_group` объекта.

### <a name="remarks"></a>Примечания

Среда выполнения назначает предоставленную рабочую функцию для выполнения на более позднее время, которое может быть после возврата вызывающей функции. Этот метод использует [task_handle](task-handle-class.md) объект для хранения копии предоставленную рабочую функцию. Таким образом изменения состояния, которые происходят в объект функции, который передается этому методу будет отсутствовать в копии этого объекта функции. Кроме того убедитесь, что времени существования объектов, которые передают указатель или ссылку на рабочую функцию остаются действительными до возврата работы функции.

Если `task_group` destructs в результате очистки стека из исключения, вы не обязательно должны гарантировать, что вызовы выполнялись либо `wait` или `run_and_wait` метод. В этом случае деструктор будет соответствующим образом отменить и ожидать задачу, представленную `_Task_handle` параметра, чтобы завершить.

Метод вызывает [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) исключение, если задача обрабатывать предоставленное `_Task_handle` параметр уже был запланирован на объектом группы задач с помощью `run` метода и были не промежуточный вызов либо `wait` или `run_and_wait` метод для этой группы задач.

##  <a name="run_and_wait"></a> run_and_wait

Планирует задачу для выполнения встроено в контексте вызова с помощью `task_group` объекта для поддержки полной отмены. Функция затем ожидает, пока все работают на `task_group` объекта завершена или отменена. Если `task_handle` объект передается в качестве параметра `run_and_wait`, вызывающий объект отвечает за управление временем существования `task_handle` объекта.

```
template<
   class _Function
>
task_group_status run_and_wait(
   task_handle<_Function>& _Task_handle
);

template<
   class _Function
>
task_group_status run_and_wait(
   const _Function& _Func
);
```

### <a name="parameters"></a>Параметры

*_Function*<br/>
Тип объекта функции, который будет вызван для выполнения основной части задачи.

*_Task_handle*<br/>
Дескриптор задачу, которая будет запускаться встроенной в контексте вызова. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения будет продолжать ожидать доживают до `run_and_wait` метод завершает выполнение.

*_Func*<br/>
Функция, которая будет вызываться для вызова тела часть работы. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()`.

### <a name="return-value"></a>Возвращаемое значение

Указание того, было ли выполнено ожидания или группа задач была отменена, из-за явного Отмена операции или к возникновению исключения из одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md#task_group_status).

### <a name="remarks"></a>Примечания

Обратите внимание, что один или несколько задач, запланированных к этому `task_group` объекта может выполняться встроено в контекст вызова.

Если один или несколько задач, назначенных данному `task_group` объекта создает исключение, среда выполнения выбирает одно такое исключение и распространить из вызова `run_and_wait` метод.

После возврата из `run_and_wait` метод `task_group` объекта, среда выполнения сбрасывает объект в исходное состояние, где он может быть повторно использован. Это включает случай где `task_group` объекта была отменена.

В пути выполнения без поддержки исключений, имеется обязательное требование для вызова либо этот метод или `wait` метод до деструктора `task_group` выполняет.

##  <a name="ctor"></a> task_group

Создает новый `task_group` объекта.

```
task_group();

task_group(
   cancellation_token _CancellationToken
);
```

### <a name="parameters"></a>Параметры

*_CancellationToken*<br/>
Токен отмены для связывания с этой группой задач. Группа задач будет отменена, когда будет отменен токен.

### <a name="remarks"></a>Примечания

Конструктор, который принимает токен отмены, создает `task_group`, которая будет отменена, когда будет отменен источник, связанный с этим токеном. Предоставление явного токена отмены также изолирует эту группу задач от участия в неявной отмене из родительской группы с другим токеном или без токена.

##  <a name="dtor"></a> ~ task_group

Уничтожает объект `task_group`. Вы должны вызывать либо `wait` или `run_and_wait` метода объекта до выполнения деструктора, если деструктор не выполняется в результате из-за исключения очистки стека.

```
~task_group();
```

### <a name="remarks"></a>Примечания

Если деструктор выполняется как результат обычного выполнения (например, не очистки стека из-за исключения) и ни `wait` , ни `run_and_wait` был вызван метод, деструктор может вызвать [missing_wait](missing-wait-class.md) исключение.

##  <a name="wait"></a> Подождите

Ожидает, пока все работают на `task_group` объекта завершена или отменена.

```
task_group_status wait();
```

### <a name="return-value"></a>Возвращаемое значение

Указание того, было ли выполнено ожидания или группа задач была отменена, из-за явного Отмена операции или к возникновению исключения из одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md#task_group_status).

### <a name="remarks"></a>Примечания

Обратите внимание, что один или несколько задач, запланированных к этому `task_group` объекта может выполняться встроено в контекст вызова.

Если один или несколько задач, назначенных данному `task_group` объекта создает исключение, среда выполнения выбирает одно такое исключение и распространить из вызова `wait` метод.

Вызов `wait` на `task_group` объект сбрасывает его в исходное состояние, где он может быть повторно использован. Это включает случай где `task_group` объекта была отменена.

В пути выполнения без поддержки исключений, имеется обязательное требование для вызова либо этот метод или `run_and_wait` метод до деструктора `task_group` выполняет.

## <a name="see-also"></a>См. также

[Пространство имен concurrency](concurrency-namespace.md)<br/>
[Класс structured_task_group](structured-task-group-class.md)<br/>
[Класс task_handle](task-handle-class.md)
