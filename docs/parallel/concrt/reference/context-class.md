---
title: Класс Context
ms.date: 11/04/2016
f1_keywords:
- Context
- CONCRT/concurrency::Context
- CONCRT/concurrency::Context::Block
- CONCRT/concurrency::Context::CurrentContext
- CONCRT/concurrency::Context::GetId
- CONCRT/concurrency::Context::GetScheduleGroupId
- CONCRT/concurrency::Context::GetVirtualProcessorId
- CONCRT/concurrency::Context::Id
- CONCRT/concurrency::Context::IsCurrentTaskCollectionCanceling
- CONCRT/concurrency::Context::IsSynchronouslyBlocked
- CONCRT/concurrency::Context::Oversubscribe
- CONCRT/concurrency::Context::ScheduleGroupId
- CONCRT/concurrency::Context::Unblock
- CONCRT/concurrency::Context::VirtualProcessorId
- CONCRT/concurrency::Context::Yield
helpviewer_keywords:
- Context class
ms.assetid: c0d553f3-961d-4ecd-9a29-4fa4351673b8
ms.openlocfilehash: c6b219eabd008114f40401c64465e44607c2ee9b
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50555081"
---
# <a name="context-class"></a>Класс Context

Представляет абстракцию для контекста выполнения.

## <a name="syntax"></a>Синтаксис

```
class Context;
```

## <a name="members"></a>Участники

### <a name="protected-constructors"></a>Защищенные конструкторы

|Имя|Описание|
|----------|-----------------|
|[~ Деструктор контекста](#dtor)||

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[Block](#block)|Блокирует текущий контекст.|
|[CurrentContext](#currentcontext)|Возвращает указатель на текущий контекст.|
|[GetId](#getid)|Возвращает идентификатор для контекста, который уникален в пределах планировщика, к которому принадлежит контекст.|
|[GetScheduleGroupId](#getschedulegroupid)|Возвращает идентификатор для группы расписаний, контекст сейчас работает над.|
|[GetVirtualProcessorId](#getvirtualprocessorid)|Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.|
|[Идентификатор](#id)|Возвращает идентификатор для текущего контекста, который уникален в пределах планировщика, к которой принадлежит текущий контекст.|
|[IsCurrentTaskCollectionCanceling](#iscurrenttaskcollectioncanceling)|Возвращает значение, указывающее, следует ли коллекция задач, которая выполняется в данный момент встроено в текущем контексте, в процессе активной отмены (или будет вскоре).|
|[IsSynchronouslyBlocked](#issynchronouslyblocked)|Определяет, заблокирован ли контекст, синхронно. Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке.|
|[Превысить предел подписок](#oversubscribe)|Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.|
|[ScheduleGroupId](#schedulegroupid)|Возвращает идентификатор для группы расписаний, занимается текущего контекста.|
|[Разблокировать](#unblock)|Разблокирует контекст и приводит к запуску.|
|[VirtualProcessorId](#virtualprocessorid)|Возвращает идентификатор для виртуального процессора, исполняемой в текущем контексте.|
|[Yield](#yield)|Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.|

## <a name="remarks"></a>Примечания

Планировщик среды выполнения с параллелизмом (см. в разделе [планировщика](scheduler-class.md)) контекстов выполнения использует для выполнения работы в очереди на его в приложении. Поток Win32 является примером контекста выполнения в операционной системе Windows.

В любое время уровень параллелизма планировщика равно число виртуальных процессоров, предоставленные ему диспетчером ресурсов. Виртуальный процессор представляет собой абстракцию для обработки ресурсов и отображается в аппаратном потоке в базовой системе. В определенный момент времени только один контекст планировщика может выполняться на виртуальном процессоре.

Планировщик совместно по своей природе и выполняемый контекст может привести его виртуальный процессор в другом контексте в любое время, если он хочет перейдет в состояние ожидания. При удовлетворении его ожидания, его нельзя возобновить, пока доступный виртуальный процессор из планировщика не начнет его выполнения.

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`Context`

## <a name="requirements"></a>Требования

**Заголовок:** concrt.h

**Пространство имен:** concurrency

##  <a name="block"></a> Блок

Блокирует текущий контекст.

```
static void __cdecl Block();
```

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.

Если контекст вызова работает на виртуальном процессоре, виртуальный процессор найдет другого работоспособный контекст для выполнения или потенциально может создать новую.

После `Block` метод был вызван или будет вызываться, его необходимо настроить сопряжение с вызовом [Unblock](#unblock) метод из другого контекста выполнения в порядке для его повторный запуск. Имейте в виду, что имеется критический период между точкой, где код публикует его контекст для другого потока, чтобы иметь возможность вызывать `Unblock` метод и точки, где метод фактический вызов `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживать причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` -  `Unblock` пары.

Этот метод можно вызвать ряд исключений, включая [scheduler_resource_allocation_error](scheduler-resource-allocation-error-class.md).

##  <a name="dtor"></a> ~ Контекста

```
virtual ~Context();
```

##  <a name="currentcontext"></a> CurrentContext

Возвращает указатель на текущий контекст.

```
static Context* __cdecl CurrentContext();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на текущий контекст.

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.

##  <a name="getid"></a> GetId

Возвращает идентификатор для контекста, который уникален в пределах планировщика, к которому принадлежит контекст.

```
virtual unsigned int GetId() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Идентификатор контекста, который уникален в пределах планировщика, к которому принадлежит контекст.

##  <a name="getschedulegroupid"></a> GetScheduleGroupId

Возвращает идентификатор для группы расписаний, контекст сейчас работает над.

```
virtual unsigned int GetScheduleGroupId() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Идентификатор группы расписаний контекст в настоящее время работает над.

### <a name="remarks"></a>Примечания

Из этого метода возвращается выборка группы расписаний, контекст выполняется в данный момент. Если этот метод вызывается в контексте, отличном от текущего контекста, значение может быть устаревшим в момент возврата и полагаться на него нельзя. Как правило этот метод используется для только для целей отладки или трассировки.

##  <a name="getvirtualprocessorid"></a> GetVirtualProcessorId

Возвращает идентификатор для виртуального процессора, контекст выполняется в данный момент.

```
virtual unsigned int GetVirtualProcessorId() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Если контекст в данный момент на виртуальном процессоре, идентификатор виртуального процессора, выполняющийся в данный момент контекст; в в противном случае — значение `-1`.

### <a name="remarks"></a>Примечания

Из этого метода возвращается выборка виртуального процессора, контекст выполняется в данный момент. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.

##  <a name="id"></a> Идентификатор

Возвращает идентификатор для текущего контекста, который уникален в пределах планировщика, к которой принадлежит текущий контекст.

```
static unsigned int __cdecl Id();
```

### <a name="return-value"></a>Возвращаемое значение

Текущий контекст, подключенного к планировщик, идентификатор для текущего контекста, который уникален в пределах планировщика, к которому принадлежит текущий контекст; в противном случае — значение `-1`.

##  <a name="iscurrenttaskcollectioncanceling"></a> IsCurrentTaskCollectionCanceling

Возвращает значение, указывающее, следует ли коллекция задач, которая выполняется в данный момент встроено в текущем контексте, в процессе активной отмены (или будет вскоре).

```
static bool __cdecl IsCurrentTaskCollectionCanceling();
```

### <a name="return-value"></a>Возвращаемое значение

Если планировщик присоединен к вызывающему контексту и группа задач выполняет задачу встроено в этом контексте, указание, следует ли группа задач, в процессе активной отмены (или будет вскоре); в противном случае — значение `false`.

##  <a name="issynchronouslyblocked"></a> IsSynchronouslyBlocked

Определяет, заблокирован ли контекст, синхронно. Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке.

```
virtual bool IsSynchronouslyBlocked() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Является ли контекст синхронно блокируется.

### <a name="remarks"></a>Примечания

Контекст считается синхронно заблокировано, если он явно выполнил действие, которое привело к блокировке. В планировщике потоков это означает прямой вызов метода `Context::Block` или объекта синхронизации, который был создан с помощью метода `Context::Block`.

Возвращаемое значение из этого метода — это образец на данный момент ли контекст синхронно блокируется. Это значение может быть устаревшим в момент возвращается и может использоваться только в особых обстоятельствах.

##  <a name="operator_delete"></a> оператор delete

Объект `Context` объект уничтожается внутренним образом средой выполнения. Его невозможно удалить явно.

```
void operator delete(void* _PObject);
```

### <a name="parameters"></a>Параметры

*_PObject*<br/>
Указатель на объект для удаления.

##  <a name="oversubscribe"></a> Превысить предел подписок

Внедряет дополнительный виртуальный процессор в планировщике до конца блока кода при вызове контекста выполнения на одном из виртуальных процессоров в данном планировщике.

```
static void __cdecl Oversubscribe(bool _BeginOversubscription);
```

### <a name="parameters"></a>Параметры

*_BeginOversubscription*<br/>
Если **true**, указывает на то что дополнительный виртуальный процессор должны быть добавлены в течение превышения лимита подписки. Если **false**, указывает на то что должен заканчиваться на превышение лимита подписки, и должны быть удалены ранее добавленный виртуальный процессор.

##  <a name="schedulegroupid"></a> ScheduleGroupId

Возвращает идентификатор для группы расписаний, занимается текущего контекста.

```
static unsigned int __cdecl ScheduleGroupId();
```

### <a name="return-value"></a>Возвращаемое значение

Если текущий контекст присоединен к планировщик и работу над группой расписаний, идентификатор для планировщика группы, текущий контекст работает; в противном случае — значение `-1`.

##  <a name="unblock"></a> Разблокировать

Разблокирует контекст и приводит к запуску.

```
virtual void Unblock() = 0;
```

### <a name="remarks"></a>Примечания

Вполне допустимо для вызова `Unblock` метода должны быть до соответствующего вызова [блок](#block) метод. Как долго, как вызовы `Block` и `Unblock` методы правильно объединены в пару, среда выполнения правильно обрабатывает машинную гонку любого порядка. `Unblock` Вызовов, поступающих перед `Block` вызов просто отменяют эффект `Block` вызова.

Существует несколько исключений, которые могут создаваться из этого метода. Если контекст пытается вызвать `Unblock` метод для себя, [context_self_unblock](context-self-unblock-class.md) будет создано исключение. Если вызовы `Block` и `Unblock` объединены неправильно (например, два вызова к `Unblock` выполняются в контексте которой выполняется в данный момент), [context_unblock_unbalanced](context-unblock-unbalanced-class.md) будет создано исключение.

Имейте в виду, что имеется критический период между точкой, где код публикует его контекст для другого потока, чтобы иметь возможность вызывать `Unblock` метод и точки, где метод фактический вызов `Block` выполняется. Во время этого периода не следует вызывать ни один метод, который может блокировать и разблокировать по своим собственным причинам (например, получение блокировки). Вызовы `Block` и `Unblock` метод не отслеживать причины блокировки и разблокирования. Только один объект должен быть владельцем `Block` и `Unblock` пары.

##  <a name="virtualprocessorid"></a> VirtualProcessorId

Возвращает идентификатор для виртуального процессора, исполняемой в текущем контексте.

```
static unsigned int __cdecl VirtualProcessorId();
```

### <a name="return-value"></a>Возвращаемое значение

Если текущий контекст прикрепляется к планировщик, идентификатор виртуального процессора, выполняющего текущий контекст; в противном в противном случае — значение `-1`.

### <a name="remarks"></a>Примечания

Из этого метода возвращается выборка виртуального процессора, текущий контекст выполняется в данный момент. Это значение может быть устаревшим в момент возврата, и на него нельзя полагаться. Как правило этот метод используется для только для целей отладки или трассировки.

##  <a name="yield"></a> оператор yield

Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.

```
static void __cdecl Yield();
```

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.

##  <a name="yieldexecution"></a> YieldExecution

Уступает выполнение, чтобы мог выполняться другой контекст. Если доступных контекстов для уступки выполнения нет, планировщик может уступить выполнение другому потоку операционной системы.

```
static void __cdecl YieldExecution();
```

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.

Эта функция, впервые появился в Visual Studio 2015 и идентичен объекту [Yield](#yield) работать, но не конфликтует с макросом Yield в Windows.h.

## <a name="see-also"></a>См. также

[Пространство имен concurrency](concurrency-namespace.md)<br/>
[Класс Scheduler](scheduler-class.md)<br/>
[Планировщик задач](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)

