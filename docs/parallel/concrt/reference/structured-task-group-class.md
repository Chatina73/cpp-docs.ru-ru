---
title: Класс structured_task_group
ms.date: 11/04/2016
f1_keywords:
- structured_task_group
- PPL/concurrency::structured_task_group
- PPL/concurrency::structured_task_group::structured_task_group
- PPL/concurrency::structured_task_group::cancel
- PPL/concurrency::structured_task_group::is_canceling
- PPL/concurrency::structured_task_group::run
- PPL/concurrency::structured_task_group::run_and_wait
- PPL/concurrency::structured_task_group::wait
helpviewer_keywords:
- structured_task_group class
ms.assetid: 742afa8c-c7b6-482c-b0ba-04c809927b22
ms.openlocfilehash: 93dd79b755f79dcb4857c1b1c4856362b0bd45dd
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79427365"
---
# <a name="structured_task_group-class"></a>Класс structured_task_group

Класс `structured_task_group` представляет коллекцию параллельной работы со сложной структурой. Можно поместить в очередь `structured_task_group` отдельные параллельные задачи с помощью объектов `task_handle` и ожидать их выполнения или отменить группу задач до завершения выполнения, что приведет к отмене всех задач, которые не начали выполнение.

## <a name="syntax"></a>Синтаксис

```cpp
class structured_task_group;
```

## <a name="members"></a>Члены

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Description|
|----------|-----------------|
|[structured_task_group](#ctor)|Перегружен. Создает новый объект `structured_task_group`.|
|[Деструктор ~ structured_task_group](#dtor)|Уничтожает объект `structured_task_group`. Ожидается вызов метода `wait` или `run_and_wait` объекта до выполнения деструктора, если только деструктор не выполняется в результате очистки стека из-за исключения.|

### <a name="public-methods"></a>Открытые методы

|Имя|Description|
|----------|-----------------|
|[cancel](#cancel)|Предпринимает попытку отменить поддерево работы с корнем в этой группе задач. Если возможно, все задачи, запланированные в группе задач, будут отменены транзитивно.|
|[is_canceling](#is_canceling)|Информирует вызывающий объект о том, находится ли группа задач в данный момент в процессе отмены. Это не обязательно означает, что метод `cancel` был вызван для объекта `structured_task_group` (хотя, безусловно, этот метод должен возвращать **значение true**). Это может быть случай, когда объект `structured_task_group` выполняется встроенным, а группа задач в рабочем дереве была отменена. В таких случаях, где среда выполнения может заранее определить, что отмена будет проходить через этот `structured_task_group` объект, будет возвращено **значение true** .|
|[run](#run)|Перегружен. Планирует задачу для объекта `structured_task_group`. Вызывающий объект управляет временем существования объекта `task_handle`, переданного в параметре `_Task_handle`. Версия, которая принимает параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.|
|[run_and_wait](#run_and_wait)|Перегружен. Планирует выполнение задачи в вызывающем контексте с помощью объекта `structured_task_group` для полной поддержки отмены. Если объект `task_handle` передается в качестве параметра для `run_and_wait`, вызывающий объект отвечает за управление временем существования объекта `task_handle`. Затем функция ждет, пока вся работа над объектом `structured_task_group` не завершится или не будет отменена.|
|[ожидания](#wait)|Ожидает, пока вся работа на `structured_task_group` не завершится или не будет отменена.|

## <a name="remarks"></a>Remarks

Существует ряд строгих ограничений на использование объекта `structured_task_group`, чтобы повысить производительность:

- Один объект `structured_task_group` не может использоваться несколькими потоками. Все операции с объектом `structured_task_group` должны выполняться потоком, создавшим объект. Эти два исключения из этого правила являются функциями членов `cancel` и `is_canceling`. Объект может отсутствовать в списке записи лямбда-выражения и использоваться в задаче, если только задача не использует одну из операций отмены.

- Все задачи, запланированные на объект `structured_task_group`, планируются с помощью `task_handle` объектов, которые необходимо явно управлять временем существования.

- Несколько групп можно использовать только в порядке абсолютной вложенности. Если объявлено два `structured_task_group` объектов, второй объявленный (внутренний) должен уничтожения перед любым методом, за исключением `cancel` или `is_canceling` вызывается в первом (внешнем). Это условие имеет значение true в обоих случаях: просто объявляя несколько `structured_task_group` объектов в тех же или функционально вложенных областях, а также в случае задачи, которая была поставлена в очередь `structured_task_group` с помощью методов `run` или `run_and_wait`.

- В отличие от класса общего `task_group` все состояния в классе `structured_task_group` являются окончательными. После помещения задач в очередь группы и ожидания их завершения невозможно использовать ту же группу снова.

Дополнительные сведения см. в разделе [параллелизм задач](../../../parallel/concrt/task-parallelism-concurrency-runtime.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`structured_task_group`

## <a name="requirements"></a>Требования

**Заголовок:** PPL. h

**Пространство имен:** concurrency

## <a name="cancel"></a>Отмена

Предпринимает попытку отменить поддерево работы с корнем в этой группе задач. Если возможно, все задачи, запланированные в группе задач, будут отменены транзитивно.

```cpp
void cancel();
```

### <a name="remarks"></a>Remarks

Дополнительные сведения см. в разделе [Отмена](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).

## <a name="is_canceling"></a>is_canceling

Информирует вызывающий объект о том, находится ли группа задач в данный момент в процессе отмены. Это не обязательно означает, что метод `cancel` был вызван для объекта `structured_task_group` (хотя, безусловно, этот метод должен возвращать **значение true**). Это может быть случай, когда объект `structured_task_group` выполняется встроенным, а группа задач в рабочем дереве была отменена. В таких случаях, где среда выполнения может заранее определить, что отмена будет проходить через этот `structured_task_group` объект, будет возвращено **значение true** .

```cpp
bool is_canceling();
```

### <a name="return-value"></a>Возвращаемое значение

Указывает, находится ли объект `structured_task_group` в процессе отмены (или гарантированно будет вскоре).

### <a name="remarks"></a>Remarks

Дополнительные сведения см. в разделе [Отмена](../../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md#cancellation).

## <a name="run"></a>запуска

Планирует задачу для объекта `structured_task_group`. Вызывающий объект управляет временем существования объекта `task_handle`, переданного в параметре `_Task_handle`. Версия, которая принимает параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.

```cpp
template<class _Function>
void run(
    task_handle<_Function>& _Task_handle);

template<class _Function>
void run(
    task_handle<_Function>& _Task_handle,
    location& _Placement);
```

### <a name="parameters"></a>Параметры

*_Function*<br/>
Тип объекта функции, который будет вызываться для выполнения тела маркера задачи.

*_Task_handle*<br/>
Маркер запланированной работы. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения продолжит ожидать, пока для этого `structured_task_group` объекта не будет вызван метод `wait` или `run_and_wait`.

*_Placement*<br/>
Ссылка на расположение, в котором должна выполняться задача, представленная параметром `_Task_handle`.

### <a name="remarks"></a>Remarks

Среда выполнения создает копию рабочей функции, которая передается в этот метод. Любые изменения состояния, происходящие в объекте функции, который передается в этот метод, не будут отображаться в копии этого объекта функции.

Если `structured_task_group` деструкторы в результате очистки стека из исключения, нет необходимости гарантировать, что был сделан вызов метода `wait` или `run_and_wait`. В этом случае деструктор будет отменяться соответствующим образом и ожидать завершения задачи, представленной параметром `_Task_handle`.

Вызывает исключение [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) , если обработчик задач, заданный параметром `_Task_handle`, уже был запланирован в объекте группы задач с помощью метода `run` и отсутствует промежуточный вызов метода `wait` или `run_and_wait` в этой группе задач.

## <a name="run_and_wait"></a>run_and_wait

Планирует выполнение задачи в вызывающем контексте с помощью объекта `structured_task_group` для полной поддержки отмены. Если объект `task_handle` передается в качестве параметра для `run_and_wait`, вызывающий объект отвечает за управление временем существования объекта `task_handle`. Затем функция ждет, пока вся работа над объектом `structured_task_group` не завершится или не будет отменена.

```cpp
template<class _Function>
task_group_status run_and_wait(task_handle<_Function>& _Task_handle);

template<class _Function>
task_group_status run_and_wait(const _Function& _Func);
```

### <a name="parameters"></a>Параметры

*_Function*<br/>
Тип объекта функции, который будет вызываться для выполнения задачи.

*_Task_handle*<br/>
Обработчик для задачи, который будет выполняться встроенным в контекст вызывающего. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения будет продолжать ожидать, пока не завершится выполнение метода `run_and_wait`.

*_Func*<br/>
Функция, которая будет вызываться для вызова текста работы. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()`.

### <a name="return-value"></a>Возвращаемое значение

Значение, указывающее, было ли выполнено ожидание или отменена группа задач из-за явной операции отмены или исключения, вызываемого одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md)

### <a name="remarks"></a>Remarks

Обратите внимание, что одна или несколько задач, запланированных на этот `structured_task_group` объект, могут выполняться встроенным в контекст вызывающего.

Если одна или несколько задач, запланированных на этот `structured_task_group` объект, вызывают исключение, среда выполнения выберет одно такое исключение и распространяет его из вызова метода `run_and_wait`.

После возврата этой функции объект `structured_task_group` находится в конечном состоянии и не должен использоваться. Обратите внимание, что использование после возврата метода `run_and_wait` приводит к неопределенному поведению.

В неисключительном пути выполнения у вас есть требование вызвать этот метод или метод `wait` до выполнения деструктора `structured_task_group`.

## <a name="ctor"></a>structured_task_group

Создает новый объект `structured_task_group`.

```cpp
structured_task_group();

structured_task_group(cancellation_token _CancellationToken);
```

### <a name="parameters"></a>Параметры

*_CancellationToken*<br/>
Токен отмены, связываемый с этой структурной группой задач. Структурированная группа задач будет отменена при отмене маркера.

### <a name="remarks"></a>Remarks

Конструктор, который принимает токен отмены, создает `structured_task_group`, которая будет отменена, когда будет отменен источник, связанный с этим токеном. Предоставление явной лексемы отмены также изолирует эту структурированную группу задач от участия в неявной отмене из родительской группы с другим маркером или без токена.

## <a name="dtor"></a>~ structured_task_group

Уничтожает объект `structured_task_group`. Ожидается вызов метода `wait` или `run_and_wait` объекта до выполнения деструктора, если только деструктор не выполняется в результате очистки стека из-за исключения.

```cpp
~structured_task_group();
```

### <a name="remarks"></a>Remarks

Если деструктор выполняется как результат обычного выполнения (например, не происходит очистка стека из-за исключения) и не были вызваны методы `wait` и `run_and_wait`, деструктор может вызвать исключение [missing_wait](missing-wait-class.md) .

## <a name="wait"></a>ожидания

Ожидает, пока вся работа на `structured_task_group` не завершится или не будет отменена.

```cpp
task_group_status wait();
```

### <a name="return-value"></a>Возвращаемое значение

Значение, указывающее, было ли выполнено ожидание или отменена группа задач из-за явной операции отмены или исключения, вызываемого одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md)

### <a name="remarks"></a>Remarks

Обратите внимание, что одна или несколько задач, запланированных на этот `structured_task_group` объект, могут выполняться встроенным в контекст вызывающего.

Если одна или несколько задач, запланированных на этот `structured_task_group` объект, вызывают исключение, среда выполнения выберет одно такое исключение и распространяет его из вызова метода `wait`.

После возврата этой функции объект `structured_task_group` находится в конечном состоянии и не должен использоваться. Обратите внимание, что использование после возврата метода `wait` приводит к неопределенному поведению.

В неисключительном пути выполнения у вас есть требование вызвать этот метод или метод `run_and_wait` до выполнения деструктора `structured_task_group`.

## <a name="see-also"></a>См. также раздел

[Пространство имен concurrency](concurrency-namespace.md)<br/>
[Класс task_group](task-group-class.md)<br/>
[Класс task_handle](task-handle-class.md)
