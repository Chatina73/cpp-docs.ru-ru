---
title: Отмена в библиотеке параллельных шаблонов
ms.date: 11/19/2018
helpviewer_keywords:
- parallel algorithms, canceling [Concurrency Runtime]
- canceling parallel algorithms [Concurrency Runtime]
- parallel tasks, canceling [Concurrency Runtime]
- cancellation in the PPL
- parallel work trees [Concurrency Runtime]
- canceling parallel tasks [Concurrency Runtime]
ms.assetid: baaef417-b2f9-470e-b8bd-9ed890725b35
ms.openlocfilehash: 27c0ea3cfcf62060800c1c0b034dde7de6357250
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81368496"
---
# <a name="cancellation-in-the-ppl"></a>Отмена в библиотеке параллельных шаблонов

В этом документе рассматривается роль отмены в библиотеке параллельных шаблонов (PPL), а также объясняется, как отменить параллельную работу и как определить, что параллельная работа отменена.

> [!NOTE]
> Среда выполнения использует обработку исключений для реализации отмены. Не следует перехватывать или обрабатывать эти исключения в своем коде. Кроме того, рекомендуется писать безопасный в отношении исключений код в функциях для ваших задач. Например, можно использовать шаблон *«Приобретение ресурсов инициализации»* (RAII), чтобы гарантировать правильную обработку ресурсов при вбросе в тело задачи. Для полного примера, использующего шаблон RAII для очистки [Walkthrough: Removing Work from a User-Interface Thread](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md)ресурса в выполняемой задаче, см.

## <a name="key-points"></a>Основные моменты

- Отмена выполняется совместно и обеспечивает координацию между кодом, запрашивающим отмену запросов, и задачей, которая отвечает за отмену.

- Если возможно, используйте токены отмены, чтобы отменить работу. [Параллель::cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md) класс определяет токен отмены.

- При использовании токенов отмены используйте [параллелизм::cancellation_token_source:::отмена](reference/cancellation-token-source-class.md#cancel) метода для инициирования отмены и [параллелизма::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) функцию ответа на отмену. Используйте [параллел::cancellation_token::is_canceled](reference/cancellation-token-class.md#is_canceled) метод, чтобы проверить, является ли какая-либо другая задача просила отмены.

- Отмена не происходит немедленно. Хотя новая работа не запускается, если задача или группа задач отменены, активная работа должна проверяться и реагировать на отмену.

- Продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи. Продолжение на основе задачи никогда не наследует токен своей предшествующей задачи.

- Используйте [параллел::cancellation_token::ни один](reference/cancellation-token-class.md#none) метод, когда вы `cancellation_token` звоните конструктору или функции, которая принимает объект, но вы не хотите, чтобы операция была возможной. Кроме того, если вы не передаете токен отмены [в параллел::конструктор задачи](../../parallel/concrt/reference/task-class.md) или [параллел::create_task](reference/concurrency-namespace-functions.md#create_task) функции, эта задача не может быть возможной.

## <a name="in-this-document"></a><a name="top"></a>В этом документе

- [Деревья параллельной работы](#trees)

- [Отмена параллельных задач](#tasks)

  - [Использование токена отмены для отмены параллельной работы](#tokens)

  - [Использование метода cancel для отмены параллельной работы](#cancel)

  - [Использование исключений для отмены параллельной работы](#exceptions)

- [Отмена параллельных алгоритмов](#algorithms)

- [Когда не следует использовать отмену](#when)

## <a name="parallel-work-trees"></a><a name="trees"></a>Параллельные рабочие деревья

В PPL для управления детализированными задачами и вычислениями используются задачи и группы задач. Можно гнездить группы задач для формирования *деревьев* параллельной работы. На следующем рисунке показано дерево параллельной работы. На этом рисунке `tg1` и `tg2` представляют группы задач; `t1`, `t2`, `t3`, `t4` и `t5` представляют работы, которые выполняют группы задач.

![Дерево параллельной работы](../../parallel/concrt/media/parallelwork_trees.png "Дерево параллельной работы")

В следующем примере показан код, который необходим для создания дерева на рисунке. В этом `tg1` примере, и `tg2` [являются параллельными::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) объектов; `t1`, `t2` `t3`, `t4`, `t5` , и [являются параллелью::task_handle](../../parallel/concrt/reference/task-handle-class.md) объектов.

[!code-cpp[concrt-task-tree#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_1.cpp)]

Вы также можете использовать [параллелизм::task_group](reference/task-group-class.md) класс для создания аналогичного дерева работы. [Параллель::задача](../../parallel/concrt/reference/task-class.md) класс также поддерживает понятие дерева работы. Однако дерево `task` является деревом зависимостей. В дереве `task` следующие задания выполняются после текущих. В дереве группы задач внутренняя работа завершается до внешней работы. Для получения дополнительной информации о различиях [Task Parallelism](../../parallel/concrt/task-parallelism-concurrency-runtime.md)между задачами и группами задач см.

[Сверху](#top)

## <a name="canceling-parallel-tasks"></a><a name="tasks"></a>Отмена параллельных задач

Существует несколько способов отмены параллельной работы. Предпочтительный способ — использование токена отмены. Группы задач также поддерживают [параллелизм::task_group:::отмена](reference/task-group-class.md#cancel) метода и [параллел: structured_task_group:::::отмена](reference/structured-task-group-class.md#cancel) метода. Еще один способ — создать исключение в теле рабочей функции задачи. Какой бы метод вы ни выбрали, нужно понимать, что отмена не происходит немедленно. Хотя новая работа не запускается, если задача или группа задач отменены, активная работа должна проверяться и реагировать на отмену.

Для получения дополнительных примеров, которые отменяют параллельные задачи, смотрите [Пошаговая инструкция: Подключение С помощью задач и XML HTTP Запросы](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md), [Как: Использование Отмена для перерыва из параллельной петли](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md), и [Как: Использование обработки исключений для разрыва из параллельной петли](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).

### <a name="using-a-cancellation-token-to-cancel-parallel-work"></a><a name="tokens"></a>Использование маркера отмены для отмены параллельной работы

Классы `task`, `task_group` и `structured_task_group` поддерживают отмену посредством использования токенов отмены. PPL определяет [параллел::cancellation_token_source](../../parallel/concrt/reference/cancellation-token-source-class.md) и [параллел: cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md) классов для этой цели. При использовании токена отмены, чтобы отменить работу, среда выполнения не запускает новую работу, которая подписывается на этот токен. Работа, которая уже активна, может использовать функцию [is_canceled](../../parallel/concrt/reference/cancellation-token-class.md#is_canceled) для мониторинга маркера отмены и остановки, когда это возможно.

Чтобы инициировать отмену, позвоните в [параллел::cancellation_token_source::::отмену метода.](reference/cancellation-token-source-class.md#cancel) Можно реагировать на отмену следующими способами.

- Для `task` объектов используйте [параллелизм::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) функцию. `cancel_current_task` отменяет текущую задачу и любое ее продолжение, основанное на значении. (Он не отменяет *маркер* отмены, связанный с задачей или ее продолжением.)

- Для групп задач и параллельных алгоритмов используйте [параллелизм::is_current_task_group_canceling](reference/concurrency-namespace-functions.md#is_current_task_group_canceling) функцию для обнаружения отмены и возврата как можно скорее из тела задач, когда эта функция возвращается **верно.** (Не вызывайте `cancel_current_task` из группы задач.)

В следующем примере показан первый базовый шаблон для отмены задачи. Тело задачи время от времени проверяет, нет ли отмены внутри цикла.

[!code-cpp[concrt-task-basic-cancellation#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_2.cpp)]

Функция `cancel_current_task` создает исключение, поэтому нет необходимости явно возвращаться из текущего цикла или функции.

> [!TIP]
> Кроме того, вы можете назвать [параллелизм::interruption_point](reference/concurrency-namespace-functions.md#interruption_point) функции `cancel_current_task`вместо .

Необходимо вызвать `cancel_current_task` при реагировании на отмену, поскольку она переводит задачу в отмененное состояние. Если вы вернулись раньше вместо вызова `cancel_current_task`, операция переходит в состояние завершения, и все продолжения, основанные на значении, выполняются.

> [!CAUTION]
> Никогда не вызывайте исключение `task_canceled` из своего кода. Вместо него вызовите метод `cancel_current_task`.

Когда задача заканчивается в отмененном состоянии, [параллель::task::get](reference/task-class.md#get) метод бросает [параллель::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). (И наоборот, [параллелизм::task::wait](reference/task-class.md#wait) [возвращается task_status::отменено](reference/concurrency-namespace-enums.md#task_group_status) и не бросает.) Следующий пример иллюстрирует это поведение для продолжения задачи. Продолжение на основе задачи вызывается всегда, даже если предшествующая задача отменяется.

[!code-cpp[concrt-task-canceled#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_3.cpp)]

Поскольку продолжения, основанные на значении, наследуют токен их предшествующей задачи, если они не были созданы с явным токеном, продолжения немедленно входят в отмененное состояние, даже если предшествующая задача по-прежнему выполняется. Поэтому любое исключение, создаваемое предшествующей задачей после отмены, не распространяется задачам продолжения. Отмена всегда переопределяет состояние предшествующей задачи. Следующий пример похож на предыдущий, но показывает поведение продолжения, основанного на значении.

[!code-cpp[concrt-task-canceled#2](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_4.cpp)]

> [!CAUTION]
> Если вы не передаете маркер `task` отмены конструктору или [конпартю: create_task](reference/concurrency-namespace-functions.md#create_task) функция, эта задача не может быть возможной. Кроме того необходимо передать один и тот же токен отмены конструктору всех вложенных задач (т. е. задач, которые создаются в теле другой задачи), чтобы отменить все задачи одновременно.

Может понадобиться выполнить собственный код, когда токен отмены отменен. Например, если пользователь выбирает кнопку **Отмена** в пользовательском интерфейсе для отмены операции, эту кнопку можно отключить до тех пор, пока пользователь не запустит другую операцию. В следующем примере показано, как использовать [параллелизм::cancellation_token::register_callback](reference/cancellation-token-class.md#register_callback) метод регистрации функции обратного вызова, которая выполняется при отмене маркера отмены.

[!code-cpp[concrt-task-cancellation-callback#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_5.cpp)]

В документе [«Тачпартизм»](../../parallel/concrt/task-parallelism-concurrency-runtime.md) разъясняется разница между ценными и задачами. Если не предоставить объект `cancellation_token` задаче продолжения, продолжение наследует токен отмены из предшествующей задачи следующими способами.

- Продолжение, основанное на значении, всегда наследует токен отмены предшествующей задачи.

- Продолжение на основе задач никогда не наследует токен отмены предшествующей задачи. Единственный способ сделать продолжение на основе задач отменяемым — явно передать токен отмены.

Эти поведения не изменяются из-за сбоя задачи (той, которая создает исключение). В этом случае продолжение на основе значений отменяется; продолжение на основе задач не отменяется.

> [!CAUTION]
> Задача, которая создается внутри другой задачи (вложенная задача), не наследует токен отмены от родительской задачи. Только продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи.

> [!TIP]
> Используйте [параллел::cancellation_token::ни один](reference/cancellation-token-class.md#none) метод, когда вы `cancellation_token` звоните конструктору или функции, которая принимает объект, и вы не хотите, чтобы операция была возможной.

Также можно предоставить токен отмены конструктору объекта `task_group` или `structured_task_group`. Важным аспектом является то, что дочерние группы задач наследуют этот токен отмены. Например, демонстрируя эту концепцию с помощью [параллелизма::run_with_cancellation_token](reference/concurrency-namespace-functions.md#run_with_cancellation_token) функции для выполнения вызова, `parallel_for`см. [Отмена параллельных алгоритмов](#algorithms) позже в этом документе.

[Сверху](#top)

#### <a name="cancellation-tokens-and-task-composition"></a>Токены отмены и композиция задач

[Параллель::when_all](reference/concurrency-namespace-functions.md#when_all) и [параллелизм::when_any](reference/concurrency-namespace-functions.md#when_all) функции могут помочь вам составить несколько задач для реализации общих шаблонов. В этом разделе описывается, как эти функции работают с токенами отмены.

Когда маркер отмены предоставляется `when_all` как `when_any` и функции, то функция отменяется только тогда, когда этот маркер отмены отменяется или когда одна из задач участника заканчивается в отмененном состоянии или бросает исключение.

Функция `when_all` наследует токен отмены от каждой задачи, формирующей общую операцию, если ей не предоставляется токен отмены. Выиграное из `when_all` задачи отменяется, когда любой из этих маркеров отменяется и по крайней мере одна из задач участника еще не запущена или запущена. Аналогичное поведение происходит, когда одна из задач бросает исключение `when_all` - задача, из которого возвращается, немедленно отменяется за этим исключением.

Среда выполнения выбирает токен отмены для задачи, которая возвращается из функции `when_any`, когда эта задача завершается. Если ни одна из участвующих задач не заканчивается в завершенном состоянии или одна или более задач создают исключение, одна из создавших исключение задач выбирается для выполнения `when_any`, а ее токен выбирается как токен для окончательной задачи. Если более чем одна задача заканчивается в завершенном состоянии, задача, возвращаемая `when_any`, заканчивается в завершенном состоянии. Среда выполнения пытается выбрать завершенную задачу, токен которой не отменяется во время завершения, чтобы задача, которая возвращается из `when_any`, не отменялась сразу же, даже если остальные выполняющиеся задачи могут завершиться позднее.

[Сверху](#top)

### <a name="using-the-cancel-method-to-cancel-parallel-work"></a><a name="cancel"></a>Использование метода отмены параллельной работы для отмены параллельной работы

[Параллель::task_group::отмена](reference/task-group-class.md#cancel) и [параллель::structured_task_group:::отмена](reference/structured-task-group-class.md#cancel) методы установить группу задач в отмененном состоянии. После вызова метода `cancel` группа задач не начинает выполнение следующих задач. Методы `cancel` могут вызываться несколькими дочерними задачами. Отмененное задание вызывает [параллелизм::task_group:::ожидание](reference/task-group-class.md#wait) и [параллел::structured_task_group:::методы ожидания,](reference/structured-task-group-class.md#wait) чтобы вернуть [параллелизм::canceled](reference/concurrency-namespace-enums.md#task_group_status).

Если группа задач отменена, вызовы из каждой детской задачи в время выполнения могут вызвать *точку прерывания,* что приводит к тому, что время выполнения может бросить и поймать внутренний тип исключения для отмены активных задач. Среда выполнения с параллелизмом не определяет конкретные точки прерывания; они могут возникать в любом вызове среды выполнения. Среда выполнения должна обрабатывать исключения, которые она вызывает, чтобы выполнить отмену. Таким образом, не следует обрабатывать неизвестные исключения в теле задачи.

Если дочерняя задача выполняет длительную операцию и не выполняет вызовы, направленные в среду выполнения, необходимо периодически проверять ее для своевременной отмены и выхода. В следующем примере показывается один из способов определения, когда работа отменяется. Задача `t4` отменяет родительскую группу задач при обнаружении ошибки. Задача `t5` периодически вызывает метод `structured_task_group::is_canceling` для проверки отмены. Если родительская группа задач отменяется, задача `t5` выводит сообщение и завершает работу.

[!code-cpp[concrt-task-tree#6](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_6.cpp)]

Этот пример проверяет отмену на каждой<sup>100-й</sup> итерации цикла задач. Частота, с которой выполняется проверка отмены, зависит от объема работы, выполняемой задачей, и того, как быстро задачи должны реагировать на отмену.

Если у вас нет доступа к объекту родительской группы задач, позвоните в [concurrency::is_current_task_group_canceling](reference/concurrency-namespace-functions.md#is_current_task_group_canceling) функцию, чтобы определить, отменена ли родительская группа задач.

Метод `cancel` влияет только на дочерние задачи. Например, если отменить группу задач `tg1`, показанную на рисунке дерева параллельной работы, будут затронуты все задачи в дереве (`t1`, `t2`, `t3`, `t4` и `t5`). Если отменить вложенную группу задач `tg2`, будут затронуты только задачи `t4` и `t5`.

При вызове метода `cancel` будут также отменены все дочерние группы задач. Однако отмена не повлияет ни на какие родительские объекты группы задач в дереве параллельной работы. В следующих примерах это демонстрируется с опорой на иллюстрацию дерева параллельной работы.

В первом из этих примеров создается рабочая функция для задачи `t4`, которая является дочерним элементом группы задач `tg2`. Эта рабочая функция вызывает функцию `work` в цикле. Если какой-либо вызов `work` завершается неудачно, задача отменяет свою родительскую группу задач. В результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.

[!code-cpp[concrt-task-tree#2](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_7.cpp)]

Второй пример аналогичен первому, но за тем исключением, что задача отменяет группу задач `tg1`. Это влияет на все задачи в дереве (`t1`, `t2`, `t3`, `t4` и `t5`).

[!code-cpp[concrt-task-tree#3](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_8.cpp)]

Класс `structured_task_group` не является потокобезопасным. Таким образом, дочерняя задача, которая вызывает метод своего родительского объекта `structured_task_group`, приводит к непредсказуемому поведению. Исключением из этого правила `structured_task_group::cancel` являются и [параллелизм::structured_task_group:::is_canceling](reference/structured-task-group-class.md#is_canceling) методы. Дочерняя задача может вызывать эти методы для отмены родительской группы задач и проверки на предмет отмены.

> [!CAUTION]
> Хотя можно использовать токен отмены, чтобы отменить работу, выполняемую группой задач, которая выполняется как дочерний элемент объекта `task`, невозможно использовать методы `task_group::cancel` или `structured_task_group::cancel`, чтобы отменить объекты `task`, выполняемые в группе задач.

[Сверху](#top)

### <a name="using-exceptions-to-cancel-parallel-work"></a><a name="exceptions"></a>Использование исключений для отмены параллельной работы

Использование токенов отмены и метода `cancel` более эффективно, чем обработка исключений при отмене дерева параллельной работы. Токены отмены и метод `cancel` отменяют задачу и все дочерние задачи сверху вниз. И наоборот, обработка исключений работает в режиме «снизу вверх» и необходимо отменять каждую дочернюю группу задач независимо, поскольку исключение распространяется вверх. В теме [Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md) объясняет, как Concurrency Runtime использует исключения для передачи ошибок. Однако не все исключения указывают на ошибку. Например, алгоритм поиска может отменить связанную задачу при нахождении результата. Тем не менее, как упоминалось ранее, обработка исключений менее эффективна, чем использование метода `cancel` для отмены параллельной работы.

> [!CAUTION]
> Рекомендуется использовать исключения для отмены параллельной работы только при необходимости. Токены отмены и методы `cancel` группы задач более эффективны и менее подвержены возникновению ошибок.

При создании исключения в теле рабочей функции, передаваемой в группу задач, среда выполнения сохраняет это исключение и маршалирует его в контекст, ожидающий завершения этой группы задач. Как и в случае использования метода `cancel`, среда выполнения удаляет любые задачи, которые еще не были запущены, и не принимает новые задачи.

Третий пример напоминает второй, за исключением того, что задача `t4` создает исключение для отмены группы задач `tg2`. В этом `try` - `catch` примере используется блок для `tg2` проверки отмены, когда группа задач ждет завершения выполнения задач. Как и в первом примере, в результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.

[!code-cpp[concrt-task-tree#4](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_9.cpp)]

В четвертом примере используется обработка исключений для отмены всего дерева работы. В этом примере перехватывается исключение, когда группа задач `tg1` ожидает завершения своих дочерних задач вместо группы задач `tg2`, ожидающей своих дочерних задач. Как и во втором примере, это приводит к переходу в отмененное состояние обеих групп задач в дереве, `tg1` и `tg2`.

[!code-cpp[concrt-task-tree#5](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_10.cpp)]

Так как методы `task_group::wait` и `structured_task_group::wait` вызываются, когда дочерняя задача создает исключение, вы не получите от них возвращаемое значение.

[Сверху](#top)

## <a name="canceling-parallel-algorithms"></a><a name="algorithms"></a>Отмена параллельных алгоритмов

Параллельные алгоритмы в PPL (например, `parallel_for`) основаны на группах задач. Таким образом, многие из тех же способов можно использовать для для отмены параллельного алгоритма.

Следующие примеры иллюстрируют несколько способов отмены параллельного алгоритма.

В следующем примере функция `run_with_cancellation_token` используется для вызова алгоритма `parallel_for`. Функция `run_with_cancellation_token` принимает в качестве аргумента токен отмены и одновременно вызывает предоставленную рабочую функцию. Поскольку параллельные алгоритмы строятся на задачах, они наследуют токен отмены родительской задачи. Поэтому `parallel_for` может реагировать на отмену.

[!code-cpp[concrt-cancel-parallel-for#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_11.cpp)]

В следующем примере используется [параллел: structured_task_group::run_and_wait](reference/structured-task-group-class.md#run_and_wait) метод вызова алгоритма. `parallel_for` Метод `structured_task_group::run_and_wait` ожидает завершения предоставленной задачи. Объект `structured_task_group` позволяет рабочей функции отменить задачу.

[!code-cpp[concrt-task-tree#7](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_12.cpp)]

В этом примере формируются следующие данные:

```Output
The task group status is: canceled.
```

В следующем примере используется обработка исключений для отмены цикла `parallel_for`. Среда выполнения маршалирует исключение в вызывающий контекст.

[!code-cpp[concrt-task-tree#9](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_13.cpp)]

В этом примере формируются следующие данные:

```Output
Caught 50
```

В следующем примере используется логический флаг для координации отмены в цикле `parallel_for` Каждая задача выполняется, поскольку в этом примере не используется метод `cancel` или обработка исключений, чтобы отменить весь набор задач. Таким образом, этот метод может использовать больше вычислительных ресурсов, чем механизм отмены.

[!code-cpp[concrt-task-tree#8](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_14.cpp)]

Каждый метод отмены имеет свои преимущества по сравнению с другими. Выбирайте метод, который соответствует вашим конкретным требованиям.

[Сверху](#top)

## <a name="when-not-to-use-cancellation"></a><a name="when"></a>Когда не использовать Отмену

Использование отмены подходит в тех случаях, когда каждый член группы связанных задач может выполнить выход своевременно. Однако существуют некоторые сценарии, в которых отмена может не подойти для вашего приложения. Например, поскольку отмена задач осуществляется совместно, весь набор задач не будет отменен, если одна из задач заблокирована. Например, если одна задача еще не запущена, но разблокирует другую активную задачу, эта задача не запустится, если отменяется группа задач. Это может вызвать взаимоблокировку в приложении. Второй пример, когда использование отмены может не подойти: задача отменяется, но ее дочерняя задача выполняет важную операцию, например высвобождение ресурса. Так как при отмене родительской задачи отменяется весь набор задач, эта операция не будет выполнена. Например, иллюстрирующий этот момент, см. [Understand how Cancellation and Exception Handling Affect Object Destruction](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction)

[Сверху](#top)

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Практическое руководство. Использование отмены для выхода из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md)|Показывается, как использовать отмену для реализации алгоритма параллельного поиска.|
|[Практическое руководство. Использование обработки исключений для выхода из параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md)|Здесь приводятся способы использования класса `task_group` для записи алгоритма поиска для базовой структуры дерева.|
|[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)|В этом разделе описывается обработка в среде выполнения исключений, созданных группами задач, упрощенными задачами и асинхронными агентами, а также способы реагирования на исключения в приложениях.|
|[Параллельное выполнение задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)|В этом разделе описывается, как задачи связаны с группами задач и как можно использовать структурированные и неструктурированные задачи в приложениях.|
|[Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)|В этом разделе описываются параллельные алгоритмы, одновременно выполняющие работу с коллекциями данных.|
|[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)|Общие сведения о библиотеке параллельных задач.|

## <a name="reference"></a>Справочник

[Класс task (среда выполнения с параллелизмом)](../../parallel/concrt/reference/task-class.md)

[cancellation_token_source класс](../../parallel/concrt/reference/cancellation-token-source-class.md)

[класс cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md)

[Класс task_group](reference/task-group-class.md)

[Класс structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md)

[функция parallel_for](reference/concurrency-namespace-functions.md#parallel_for)
