---
title: Параллельные алгоритмы
ms.date: 11/19/2018
helpviewer_keywords:
- parallel algorithms [Concurrency Runtime]
ms.assetid: 045dca7b-4d73-4558-a44c-383b88a28473
ms.openlocfilehash: b8a08919ce6792babb9b8b1b809e242465a200f9
ms.sourcegitcommit: 9e891eb17b73d98f9086d9d4bfe9ca50415d9a37
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2018
ms.locfileid: "52176449"
---
# <a name="parallel-algorithms"></a>Параллельные алгоритмы

Библиотека параллельных шаблонов (PPL) предоставляет алгоритмы, одновременно выполняющие работу с коллекциями данных. Эти алгоритмы похожи стандартной библиотекой C++.

Параллельные алгоритмы, состоят из имеющихся функций в среде выполнения с параллелизмом. Например [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) алгоритм использует [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) объект для выполнения итераций параллельного цикла. `parallel_for` Алгоритм разделяет работу на оптимальным способом, учитывая количество доступных вычислительных ресурсов.

##  <a name="top"></a> Разделы

- [Алгоритм parallel_for](#parallel_for)

- [Алгоритм parallel_for_each](#parallel_for_each)

- [Алгоритм parallel_invoke](#parallel_invoke)

- [Алгоритмы parallel_transform и parallel_reduce](#parallel_transform_reduce)

    - [Алгоритм parallel_transform](#parallel_transform)

    - [Алгоритм parallel_reduce](#parallel_reduce)

    - [Пример: Выполнение сопоставления и уменьшения в параллельном режиме](#map_reduce_example)

- [Секционирование работы](#partitions)

- [Параллельная Сортировка](#parallel_sorting)

    - [Выбор алгоритма сортировки](#choose_sort)

##  <a name="parallel_for"></a> Алгоритм parallel_for

[Concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) алгоритм многократно выполняет ту же задачу в параллельном режиме. Каждый из этих задач параметризуется по значению итерации. Этот алгоритм полезен в тех случаях, когда у вас есть тело цикла, который не использует ресурсы между итерациями этого цикла.

`parallel_for` Алгоритм разделяет задачи, оптимальным образом для параллельного выполнения. В нем используется алгоритм переноса нагрузки и переноса диапазона для распределения этих секций в случае несбалансированной нагрузки. Когда одна итерация цикла выполняет совместную блокировку, среда выполнения перераспределяет диапазон итераций, назначенный текущему потоку для других потоков или процессоров. Аналогично Если поток завершает ряд итераций, среда выполнения перераспределяет нагрузку с других потоков в этот поток. `parallel_for` Алгоритм также поддерживает *вложенные параллелизма*. Если параллельный цикл содержит другой параллельный цикл, среда выполнения координирует ресурсы обработки между тел циклов наиболее эффективным образом для параллельного выполнения.

У алгоритма `parallel_for` существует несколько перегруженных версий. Первая версия принимает начальное значение, конечное значение и рабочая функция (лямбда-выражение, объект функции или указатель на функцию). Вторая версия принимает начальное значение, конечное значение, значение, на который шага и рабочей функции. Первая версия этой функции использует в качестве значение шага 1. Остальные версии принимают объекты-разделители, позволяющие указать, как алгоритм `parallel_for` должен разделять диапазоны между потоками. Разделители рассматриваются более подробно в разделе [секционирование работы](#partitions) в этом документе.

Вы можете преобразовать многие `for` циклов, позволяющие использовать `parallel_for`. Тем не менее `parallel_for` алгоритм отличается от `for` инструкции следующим образом:

- `parallel_for` Алгоритм `parallel_for` в заранее определенный порядок выполнения задач.

- `parallel_for` Алгоритм не поддерживает произвольные условия завершения. `parallel_for` Прекращается, когда текущее значение переменной итерации на единицу меньше, чем `last`.

- `_Index_type` Параметр типа должен быть целочисленный тип. Этот целочисленный тип может быть подписан или без знака.

- Итерация цикла должна быть вперед. `parallel_for` Алгоритм создает исключение типа [std::invalid_argument](../../standard-library/invalid-argument-class.md) Если `_Step` параметр имеет значение меньше 1.

- Механизм обработки исключений для `parallel_for` алгоритм отличается от `for` цикла. Если в теле параллельного цикла одновременно возникает несколько исключений, среда выполнения распространяет только одно из исключений в потоке, который вызвал `parallel_for`. Кроме того когда одна итерация цикла создает исключение, среда выполнения не останавливается сразу весь цикл. Вместо этого цикл переводится в состояние отмены, и среда выполнения удаляет любые задачи, которые еще не запущено. Дополнительные сведения об обработке исключений и параллельных алгоритмах см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

Несмотря на то что `parallel_for` алгоритм не поддерживает произвольные условия завершения, отмены можно использовать для остановки всех задач. Дополнительные сведения об отмене см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md).

> [!NOTE]
>  Затраты на планирование что преимущества параллельного выполнения тело цикла не могут компенсировать результаты балансировки нагрузки и поддержка функции, такие как отмены, особенно когда тело цикла относительно невелико. Эту дополнительную нагрузку можно минимизировать, используя разделитель в параллельном цикле. Дополнительные сведения см. в разделе [секционирование работы](#partitions) далее в этом документе.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру `parallel_for` алгоритм. Этот пример выводит на консоль, а каждое значение в диапазоне [1, 5] в параллельном режиме.

[!code-cpp[concrt-parallel-for-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_1.cpp)]

В этом примере получается следующий результат:

```Output
1 2 4 3 5
```

Так как `parallel_for` алгоритм воздействующей на каждый элемент в параллельном режиме, зависит от порядка, в котором значения выводятся в консоль.

Полный пример, использующий `parallel_for` алгоритм, см. в разделе [как: написание цикла parallel_for](../../parallel/concrt/how-to-write-a-parallel-for-loop.md).

[[В начало](#top)]

##  <a name="parallel_for_each"></a> Алгоритм parallel_for_each

[Concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) алгоритм выполняет задачи в итеративном контейнере, например предоставляемые компаниями стандартной библиотеки C++, в параллельном режиме. Он использует ту же логику секционирования, `parallel_for` алгоритмом.

`parallel_for_each` Алгоритм напоминает стандартной библиотеки C++ [std::for_each](../../standard-library/algorithm-functions.md#for_each) алгоритм, за исключением случаев, `parallel_for_each` алгоритм выполняет задачи параллельно. Другие параллельные алгоритмы, такие как `parallel_for_each` выполнения задач в определенном порядке.

Несмотря на то что `parallel_for_each` алгоритм работает как прямых итераторов, так и итераторы произвольного доступа, он более эффективен с итераторами произвольного доступа.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру `parallel_for_each` алгоритм. В этом примере выводит на консоль все значения в [std::array](../../standard-library/array-class-stl.md) объекта в параллельном режиме.

[!code-cpp[concrt-parallel-for-each-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_2.cpp)]

В этом примере получается следующий результат:

```Output
4 5 1 2 3
```

Так как `parallel_for_each` алгоритм воздействующей на каждый элемент в параллельном режиме, зависит от порядка, в котором значения выводятся в консоль.

Полный пример, использующий `parallel_for_each` алгоритм, см. в разделе [как: написание цикла parallel_for_each](../../parallel/concrt/how-to-write-a-parallel-for-each-loop.md).

[[В начало](#top)]

##  <a name="parallel_invoke"></a> Алгоритм parallel_invoke

[Concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм выполняет ряд задач в параллельном режиме. Он не возвращает до завершения каждой задачи. Этот алгоритм полезен в тех случаях, когда у вас есть несколько независимых задач, которые необходимо выполнить в то же время.

`parallel_invoke` Алгоритм принимает в качестве своих параметров ряд рабочих функций (лямбда-функции, объекты-функции или указатели на функции). `parallel_invoke` Алгоритм перегружен занимает от двух до десяти параметров. Каждая функция, передаваемый `parallel_invoke` должен принимать нулевое количество параметров.

Другие параллельные алгоритмы, такие как `parallel_invoke` выполнения задач в определенном порядке. Раздел [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) объясняет, каким образом `parallel_invoke` алгоритм связан с задачами и группами задач.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру `parallel_invoke` алгоритм. В этом примере параллельно вызываются `twice` функции на три локальные переменные и выводит результат на консоль.

[!code-cpp[concrt-parallel-invoke-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_3.cpp)]

В этом примере выводятся следующие данные:

```Output
108 11.2 HelloHello
```

Полные примеры, использующие `parallel_invoke` алгоритм, см. в разделе [как: использование функции parallel_invoke для написания параллельного сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) и [как: использование функции parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md).

[[В начало](#top)]

##  <a name="parallel_transform_reduce"></a> Алгоритмы parallel_transform и parallel_reduce

[Concurrency::parallel_transform](reference/concurrency-namespace-functions.md#parallel_transform) и [concurrency::parallel_reduce](reference/concurrency-namespace-functions.md#parallel_reduce) алгоритмы — это параллельные версии алгоритмов стандартной библиотеки C++ [std::transform](../../standard-library/algorithm-functions.md#transform)и [std::accumulate](../../standard-library/numeric-functions.md#accumulate), соответственно. Версии среды выполнения с параллелизмом ведут себя как версии стандартной библиотеки C++, за исключением того, что порядок операций не определен, поскольку они выполняются параллельно. Используйте эти алгоритмы при работе с набором, который достаточно велик для получения выигрыша в производительности и масштабируемости при параллельной обработке.

> [!IMPORTANT]
>  Алгоритмы `parallel_transform` и `parallel_reduce` поддерживают только итераторы произвольного доступа, двунаправленные и прямые итераторы, поскольку эти итераторы создают стабильные адреса памяти. Кроме того, эти итераторы должны создавать l-значения, отличные от `const`.

###  <a name="parallel_transform"></a> Алгоритм parallel_transform

Алгоритм `parallel transform` можно использовать для выполнения множества операций параллелизации данных. Например, с их помощью можно выполнять следующее.

- Настройка яркости изображения и другие операции обработки изображений.

- Суммирование или получение скалярного произведения двух векторов и выполнение других векторных вычислений.

- Трассировка трехмерных лучей, при которой каждая итерация относится к одному пикселю, подлежащему отображению.

В следующем примере показана базовая структура, используемая для вызова алгоритма `parallel_transform`. В этом примере инвертирует каждого элемента объект std::[вектор](../../standard-library/vector-class.md) объекта двумя способами. В первом способе используется лямбда-выражение. Во втором способе используется [std::negate](../../standard-library/negate-struct.md), который является производным от [std::unary_function](../../standard-library/unary-function-struct.md).

[!code-cpp[concrt-basic-parallel-transform#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_4.cpp)]

> [!WARNING]
>  В этом примере показано базовое использование функции `parallel_transform`. Поскольку рабочая функция выполняет незначительный объем работы, существенного прироста производительности в данном примере не ожидается.

Алгоритм `parallel_transform` имеет две перегрузки. Первая перегрузка принимает один входной диапазон и унарную функцию. Унарная функция может быть лямбда-выражением, принимающим один аргумент, объект функции или тип, производный от `unary_function`. Вторая перегрузка принимает два входных диапазона и бинарную функцию. Бинарная функция может быть лямбда-выражения, который принимает два аргумента, объект функции или тип, который является производным от [std::binary_function](../../standard-library/binary-function-struct.md). В следующем примере показаны эти различия.

[!code-cpp[concrt-parallel-transform-vectors#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_5.cpp)]

> [!IMPORTANT]
>  Итератор, предоставляемый для выходных данных алгоритма `parallel_transform`, должен полностью перекрывать итератор входных данных или не перекрывать его вообще. Если итераторы входных и выходных данных перекрываются частично, поведение этого алгоритма будет неопределенным.

###  <a name="parallel_reduce"></a> Алгоритм parallel_reduce

Алгоритм `parallel_reduce` эффективен при наличии последовательности операций, обладающих свойством ассоциативности. (Он не требует коммутативности). Ниже указано несколько операций, которые можно выполнять с помощью алгоритма `parallel_reduce`:

- умножение последовательности матриц для получения матрицы;

- умножение вектора на последовательность матриц для получения вектора;

- вычисление длины последовательности строк;

- объединение списка элементов, например строк, в один элемент.

В следующем базовом примере показано использование алгоритма `parallel_reduce` для объединения последовательности строк в одну строку. Как и в примерах для `parallel_transform`, в этом базовом примере не ожидается повышения производительности.

[!code-cpp[concrt-basic-parallel-reduce#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_6.cpp)]

Во многих случаях можно представить `parallel_reduce` как сокращенную запись для использования `parallel_for_each` алгоритм вместе с [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) класса.

###  <a name="map_reduce_example"></a> Пример: Выполнение сопоставления и уменьшения в параллельном режиме

Объект *карты* операции применяет функцию к каждому значению в последовательности. Объект *уменьшить* операция объединяет элементы последовательности в одно значение. Можно использовать стандартную библиотеку C++ [std::transform](../../standard-library/algorithm-functions.md#transform) и [std::accumulate](../../standard-library/numeric-functions.md#accumulate) функции для выполнения сопоставления и уменьшить объем операций. Однако для многих задач можно использовать алгоритм `parallel_transform` для параллельного выполнения операции сопоставления и алгоритм `parallel_reduce` для параллельного выполнения операции редукции.

В следующем примере сравнивается время, необходимое для последовательного и параллельного вычисления суммы простых чисел. На этапе сопоставления составные числа преобразуются в 0, а на этапе редукции производится суммирование значений.

[!code-cpp[concrt-parallel-map-reduce-sum-of-primes#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_7.cpp)]

Еще один пример, который выполняет карту и уменьшить количество операций в параллельном режиме, см. в разделе [как: выполнения сопоставления и уменьшения параллельные операции](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md).

[[В начало](#top)]

##  <a name="partitions"></a> Секционирование работы

При распараллеливании операции над источником данных, важным этапом является *секции* источника на несколько разделов, которые могут параллельно осуществлять несколько потоков. Разделитель определяет, как параллельный алгоритм должен разделять диапазоны между потоками. Как описано ранее в этом документе, PPL использует механизм секционирования по умолчанию, создающий начальную рабочую нагрузку, а затем применяет алгоритм переноса нагрузки и переноса диапазона для распределения нагрузки этих разделов при ее несбалансированности. Например, когда одна итерация цикла завершает ряд итераций, среда выполнения перераспределяет в этот поток нагрузку с других потоков. Однако в некоторых сценариях может потребоваться указать другой механизм секционирования, который лучше подходит для конкретной задачи.

Алгоритмы `parallel_for`, `parallel_for_each` и `parallel_transform` предоставляют перегруженные версии, принимающие дополнительный параметр `_Partitioner`. Этот параметр определяет тип разделителя, разделяющий работу. Ниже указаны типы разделителей, которые определяет PPL.

[Concurrency::affinity_partitioner](../../parallel/concrt/reference/affinity-partitioner-class.md)<br/>
Разделяет нагрузку на фиксированное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Этот тип разделителя напоминает `static_partitioner`, но повышает степень сходства кэша путем сопоставления диапазонов рабочим потокам. Такой тип разделителя может повысить производительность, если цикл выполняется над одним и тем же набором данных несколько раз (например, цикл в цикле) и данные размещаются в кэше. Этот разделитель не полностью участвует в отмене. Он также не использует согласованную семантику блокировки и поэтому не может использоваться с параллельными циклами, имеющими прямую зависимость.

[Concurrency::auto_partitioner](../../parallel/concrt/reference/auto-partitioner-class.md)<br/>
Разделяет нагрузку на начальное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Среда выполнения использует этот тип по умолчанию, если не вызывается перегруженный параллельный алгоритм, принимающий параметр `_Partitioner`. Каждый диапазон можно разделить на поддиапазоны, что обеспечивает распределение нагрузки. Когда диапазон работы завершается, среда выполнения перераспределяет поддиапазоны работы с других потоков в этот поток. Используйте этот разделитель, если рабочая нагрузка не попадает в другие категории или требуется полная поддержка отмены или совместной блокировки.

[Concurrency::simple_partitioner](../../parallel/concrt/reference/simple-partitioner-class.md)<br/>
Разделяет нагрузку на диапазоны так, чтобы каждый диапазон содержал по крайней мере такое число итераций, которое определено заданным размером блока. Этот тип разделителя участвует в распределении нагрузки; однако среда выполнения не делит диапазоны на поддиапазоны. Для каждого рабочего потока среда выполнения проверяет запрос отмены и выполняет распределение нагрузки после завершения числа итераций, определенных параметром `_Chunk_size`.

[Concurrency::static_partitioner](../../parallel/concrt/reference/static-partitioner-class.md)<br/>
Разделяет нагрузку на фиксированное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Этот разделитель может повысить производительность, поскольку не использует перенос нагрузки и, следовательно, содержит меньше побочной нагрузки. Используйте его, если при каждой итерации параллельного цикла выполняется фиксированный и одинаковый объем работы и нет необходимости поддержки отмены или прямой совместной блокировки.

> [!WARNING]
>  `parallel_for_each` И `parallel_transform` алгоритмы поддерживают только контейнеры, использующие итераторы произвольного доступа (например std::[вектор](../../standard-library/vector-class.md)) для средств секционирования static, простой и сходства. Применение контейнеров, использующих двунаправленные и прямые итераторы, приводит к ошибке во время компиляции. Разделитель по умолчанию `auto_partitioner` поддерживает все три типа итераторов.

Обычно эти разделители используются одинаково, за исключением `affinity_partitioner`. Большинство типов разделителей не поддерживают состояние и не изменяются средой выполнения. Поэтому эти объекты-разделители можно создавать в месте вызова, как показано в следующем примере.

[!code-cpp[concrt-static-partitioner#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_8.cpp)]

Однако необходимо передать объект `affinity_partitioner` как ссылку на I-значение, отличное от `const`, чтобы алгоритм мог сохранять состояние для повторного использования в последующих циклах. В следующем примере демонстрируется базовое приложение, параллельно выполняющее одну и ту же операцию над набором данных несколько раз. Использование `affinity_partitioner` позволяет повысить производительность, поскольку массив может размещаться в кэше.

[!code-cpp[concrt-affinity-partitioner#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_9.cpp)]

> [!CAUTION]
>  При изменении существующего кода, зависящего от семантики совместной блокировки при применении разделителей `static_partitioner` или `affinity_partitioner`, используйте с осторожностью. Эти разделители не используют распределение нагрузки и перенос диапазона и поэтому могут изменить поведение приложения.

Лучший способ определения необходимости использования разделителя в любом заданном сценарии — проведение экспериментов и измерение длительности выполнения операций при типичных нагрузках и конфигурациях компьютера. Например статическое секционирование может значительно ускорить работу на компьютере с небольшим количеством ядер, но привести к замедлению работы на компьютерах с относительно большим количеством ядер.

[[В начало](#top)]

##  <a name="parallel_sorting"></a> Параллельная Сортировка

PPL поддерживает три алгоритма сортировки: [concurrency::parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort), [concurrency::parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort), и [concurrency::parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort). Они эффективны при наличии набора данных, который выгоднее сортировать параллельно. В частности, параллельная сортировка эффективна при наличии большого набора данных и использовании операций сравнения, потребляющих много вычислительных ресурсов. Каждый из этих алгоритмов сортирует элементы на месте.

Алгоритмы `parallel_sort` и `parallel_buffered_sort` основаны на сравнениях. То есть они сравнивают элементы по значению. Алгоритм `parallel_sort` не требует дополнительной памяти и подходит для сортировки в общем случае. `parallel_buffered_sort` Алгоритма можно выполнять лучше, чем `parallel_sort`, но она требуется память o(n).

Алгоритм `parallel_radixsort` основан на хэше. То есть для сортировки элементов он использует целочисленные ключи. С помощью ключей этот алгоритм может определить место элемента непосредственно, а не использовать операции сравнения. Как и `parallel_buffered_sort`, этого алгоритма требуется память o(n).

В следующей таблице перечислены важные свойства трех параллельных алгоритмов сортировки.

|Алгоритм|Описание:|Механизм сортировки|Стабильность сортировки|Требования к памяти|Временная сложность|Доступ итераторов|
|---------------|-----------------|-----------------------|--------------------|-------------------------|---------------------|---------------------|
|`parallel_sort`|Основанная на сравнениях сортировка общего назначения.|На основе сравнений (по возрастанию)|Нестабильная|Нет|O((N/P)log(N/P) + 2N((P-1)/P))|Случайный|
|`parallel_buffered_sort`|Более быстрая сортировка общего назначения на основе сравнений, для которой требуется память O(N).|На основе сравнений (по возрастанию)|Нестабильная|Требуется дополнительное место O(N)|O((N/P)log(N))|Случайный|
|`parallel_radixsort`|Сортировка на основе целочисленных ключей, для которой требуется память О(N).|На основе хэша|стабильных|Требуется дополнительное место O(N)|O(N/P)|Случайный|

На следующем рисунке графически показаны важные свойства трех параллельных алгоритмов сортировки.

![Сравнение алгоритмов сортировки](../../parallel/concrt/media/concrt_parallel_sorting.png "сравнение алгоритмов сортировки")

Эти параллельные алгоритмы сортировки подчиняются правилам отмены и обработки исключений. Дополнительные сведения о Отмена и обработка исключений в среде выполнения с параллелизмом, см. в разделе [Отмена параллельных алгоритмов](../../parallel/concrt/cancellation-in-the-ppl.md#algorithms) и [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

> [!TIP]
>  Эти параллельные алгоритмы сортировки поддерживают семантику перемещений. Для более эффективного выполнения операций замены можно определить оператор присваивания перемещения. Дополнительные сведения о семантике перемещения и оператор присваивания перемещения см. в разделе [декларатор ссылки Rvalue: & &](../../cpp/rvalue-reference-declarator-amp-amp.md), и [конструкторы перемещения и операторы присваивания перемещения (C++)](../../cpp/move-constructors-and-move-assignment-operators-cpp.md). Если оператор присваивания перемещения или функция замены не предоставляется, алгоритмы сортировки используют конструктор копии.

В следующем базовом примере показано использование алгоритма `parallel_sort` для сортировки вектора `vector` значений типа `int`. По умолчанию `parallel_sort` использует [std::less](../../standard-library/less-struct.md) для сравнения значений.

[!code-cpp[concrt-basic-parallel-sort#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_10.cpp)]

В следующем примере показано, как реализовать пользовательскую функцию сравнения. Она использует [std::Complex:: Real](../../standard-library/complex-class.md#real) метод сортировки [std::complex\<double >](../../standard-library/complex-double.md) значений в возрастающем порядке.

[!code-cpp[concrt-basic-parallel-sort#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_11.cpp)]

В следующем примере показано, как реализовать хэш-функцию для алгоритма `parallel_radixsort`. В этом примере сортируются трехмерные точки. Они сортируются по расстоянию от опорной точки.

[!code-cpp[concrt-parallel-sort-points#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_12.cpp)]

Для иллюстрации в этом примере используется относительно небольшой набор данных. Первоначальный размер вектора можно увеличить, чтобы поэкспериментировать с увеличением производительности при больших наборах данных.

В этом примере лямбда-выражение используется в качестве хэш-функции. Можно также использовать один из встроенных реализаций класса std::[класс hash](../../standard-library/hash-class.md) или определить собственную специализацию. Кроме того, можно использовать пользовательский объект хэш-функции, как показано в следующем примере:

[!code-cpp[concrt-parallel-sort-points#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_13.cpp)]

[!code-cpp[concrt-parallel-sort-points#3](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_14.cpp)]

Хэш-функция должна возвращать целочисленный тип ([std::is_integral:: value](../../standard-library/is-integral-class.md) должно быть **true**). Этот целочисленный тип должен быть преобразуем в тип `size_t`.

###  <a name="choose_sort"></a> Выбор алгоритма сортировки

Во многих случаях алгоритм `parallel_sort` обеспечивает оптимальный баланс производительности памяти и быстродействия. Однако с увеличением размера набора данных, количества доступных процессоров и сложности функции сравнения алгоритм `parallel_buffered_sort` или `parallel_radixsort` может работать эффективнее. Лучший способ определения наиболее подходящего алгоритма сортировки в любом заданном сценарии — проведение экспериментов и измерение длительности выполнения сортировки типовых данных при типичных конфигурациях компьютера. Ниже приведены рекомендации по выбору стратегии сортировки.

- Размер набора данных. В этом документе *small* набор данных содержит менее 1 000 элементов *Средний* набор данных содержит между 10 000 до 100 000 элементов и *больших* содержит набор данных более чем 100 000 элементов.

- Объем работы, выполняемой функцией сравнения или хэш-функцией.

- Количество доступных вычислительных ресурсов.

- Характеристики набора данных. Например, один алгоритм может хорошо работать при частично отсортированных данных, но не так хорошо, когда данные совсем не сортированы.

- Размер блока. Необязательный аргумент `_Chunk_size` определяет, когда алгоритм переходит от параллельной к последовательной реализации сортировки по мере разделения всей задачи сортировки на меньшие единицы работы. Например, если указать 512, то алгоритм будет переходить на последовательную реализацию, когда единица работы содержит 512 или менее элементов. При последовательной реализации может повыситься общая производительность, поскольку исключается лишняя работа, необходимая для параллельной обработки данных.

Использовать параллельную сортировку небольшого набора данных может оказаться невыгодно даже при наличии большого количества вычислительных ресурсов или выполнении функцией сравнения или хэш-функцией относительно большого объема работы. Можно использовать [std::sort](../../standard-library/algorithm-functions.md#sort) функции для сортировки небольших наборов данных. (`parallel_sort` и `parallel_buffered_sort` вызвать `sort` при указании размера блока, больше, чем набор данных; Однако `parallel_buffered_sort` пришлось бы выделить место O(N), которая может занять дополнительное время из-за блокировки конфликтов или чрезмерного выделения памяти.)

Если необходимо сэкономить ресурсы памяти или распределитель памяти подвержен конфликтам при блокировках, то для сортировки набора данных среднего размера следует использовать алгоритм `parallel_sort`. `parallel_sort` требуется дополнительное пространство; другие алгоритмы требуют места O(N).

Используйте `parallel_buffered_sort` для сортировки наборов данных среднего размера и когда ваше приложение удовлетворяет Дополнительные требования к свободному месту O(N). Алгоритм `parallel_buffered_sort` особенно эффективен при большом количестве вычислительных ресурсов и ресурсоемкой функции сравнения или хэш-функции.

Используйте `parallel_radixsort` для сортировки больших наборов данных и когда ваше приложение удовлетворяет Дополнительные требования к свободному месту O(N). Алгоритм `parallel_radixsort` особенно эффективен при ресурсоемкой функции сравнения, а также в случае, если и функция сравнения, и хэш-функция ресурсоемки.

> [!CAUTION]
>  Для реализации хорошей хэш-функции требуется знание диапазона наборов данных и способа преобразования каждого элемента набора данных в соответствующее беззнаковое значение. Поскольку хэш-операции работают с беззнаковыми значениями, при невозможности получить беззнаковые хэш-значения рассмотрите другую стратегию сортировки.

В следующем примере сравнивается производительность алгоритмов `sort`, `parallel_sort`, `parallel_buffered_sort` и `parallel_radixsort` при одном и том же большом наборе случайных данных.

[!code-cpp[concrt-choosing-parallel-sort#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_15.cpp)]

В этом примере предполагается, что вполне допустимо для выделения пространства O(N) во время сортировки, `parallel_radixsort` дает наилучшие результаты для этого набора данных при заданной конфигурации компьютера.

[[В начало](#top)]

## <a name="related-topics"></a>См. также

|Заголовок|Описание:|
|-----------|-----------------|
|[Практическое руководство. Написание цикла parallel_for](../../parallel/concrt/how-to-write-a-parallel-for-loop.md)|Демонстрируется использование `parallel_for` алгоритм для умножения матриц.|
|[Практическое руководство. Написание цикла parallel_for_each](../../parallel/concrt/how-to-write-a-parallel-for-each-loop.md)|Демонстрируется использование `parallel_for_each` алгоритм для вычисления количества простых чисел в [std::array](../../standard-library/array-class-stl.md) объекта в параллельном режиме.|
|[Практическое руководство. Использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности алгоритма битонной сортировки.|
|[Практическое руководство. Использование функции parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности программы, выполняющей несколько операций с общим источником данных.|
|[Практическое руководство. Параллельное выполнение операций сопоставления и сокращения числа элементов](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md)|Демонстрируется использование алгоритмов `parallel_transform` и `parallel_reduce` для выполнения операций сопоставления и редукции, которые подсчитывают вхождения слов в файлах.|
|[Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)|Описывается Библиотека PPL, которая предоставляет императивную модель программирования, обеспечивающую масштабируемость и простота в использовании разработки параллельных приложений.|
|[Отмена в библиотеке параллельных шаблонов](cancellation-in-the-ppl.md)|Объясняет роль отмены в PPL, как отменить параллельную работу и как определить, когда группа задач отменяется.|
|[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)|Объясняется роль обработки исключений в среде выполнения с параллелизмом.|

## <a name="reference"></a>Ссылка

[Функция parallel_for](reference/concurrency-namespace-functions.md#parallel_for)

[Функция parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each)

[Функция parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke)

[Класс affinity_partitioner](../../parallel/concrt/reference/affinity-partitioner-class.md)

[Класс auto_partitioner](../../parallel/concrt/reference/auto-partitioner-class.md)

[Класс simple_partitioner](../../parallel/concrt/reference/simple-partitioner-class.md)

[Класс static_partitioner](../../parallel/concrt/reference/static-partitioner-class.md)

[Функция parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort)

[Функция parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort)

[Функция parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort)

