---
title: Параллельные алгоритмы
ms.date: 11/19/2018
helpviewer_keywords:
- parallel algorithms [Concurrency Runtime]
ms.assetid: 045dca7b-4d73-4558-a44c-383b88a28473
ms.openlocfilehash: c2d41ccdb8d70095f00cd18508fdff2b78392696
ms.sourcegitcommit: 9d4ffb8e6e0d70520a1e1a77805785878d445b8a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2019
ms.locfileid: "69631552"
---
# <a name="parallel-algorithms"></a>Параллельные алгоритмы

Библиотека параллельных шаблонов (PPL) предоставляет алгоритмы, выполняющие параллельную работу с коллекциями данных. Эти алгоритмы похожи на те, что C++ предоставляются стандартной библиотекой.

Параллельные алгоритмы состоят из существующих функциональных возможностей в среда выполнения с параллелизмом. Например, алгоритм [параллелизма::p arallel_for](reference/concurrency-namespace-functions.md#parallel_for) использует объект [Concurrency:: structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) для выполнения итераций параллельного цикла. `parallel_for` Алгоритмные секции работают оптимальным образом при наличии доступного количества вычислительных ресурсов.

##  <a name="top"></a> Разделы

- [Алгоритм parallel_for](#parallel_for)

- [Алгоритм parallel_for_each](#parallel_for_each)

- [Алгоритм parallel_invoke](#parallel_invoke)

- [Алгоритмы parallel_transform и parallel_reduce](#parallel_transform_reduce)

    - [Алгоритм parallel_transform](#parallel_transform)

    - [Алгоритм parallel_reduce](#parallel_reduce)

    - [Пример: Параллельное выполнение Map и reduce](#map_reduce_example)

- [Работа по секционированию](#partitions)

- [Параллельная сортировка](#parallel_sorting)

    - [Выбор алгоритма сортировки](#choose_sort)

##  <a name="parallel_for"></a>Алгоритм parallel_for

Алгоритм [параллелизма::p arallel_for](reference/concurrency-namespace-functions.md#parallel_for) многократно выполняет одну и ту же задачу параллельно. Каждая из этих задач параметризована значением итерации. Этот алгоритм полезен при наличии тела цикла, который не использует ресурсы совместно между итерациями этого цикла.

`parallel_for` Алгоритм разделяет задачи в оптимальном виде для параллельного выполнения. В нем используется алгоритм переноса нагрузки и переноса диапазона для распределения этих секций в случае несбалансированной нагрузки. Когда одна итерация цикла выполняет совместную блокировку, среда выполнения повторно распространяет диапазон итераций, назначенный текущему потоку другим потокам или процессорам. Аналогично, когда поток завершает диапазон итераций, среда выполнения перераспределяет работу из других потоков в этот поток. Алгоритм также поддерживает *вложенный параллелизм.* `parallel_for` Если один параллельный цикл содержит другой параллельный цикл, среда выполнения координирует вычислительные ресурсы между частями цикла эффективным способом параллельного выполнения.

У алгоритма `parallel_for` существует несколько перегруженных версий. Первая версия принимает начальное значение, конечное значение и рабочую функцию (лямбда-выражение, объект функции или указатель на функцию). Вторая версия принимает начальное значение, конечное значение, значение, по которому выполняется шаг, и рабочую функцию. Первая версия этой функции использует значение 1 в качестве значения шага. Остальные версии принимают объекты-разделители, позволяющие указать, как алгоритм `parallel_for` должен разделять диапазоны между потоками. Сведения о секционировании см. в разделе Работа с [секционированием](#partitions) в этом документе.

Многие `for` циклы можно преобразовать в использование `parallel_for`. Однако алгоритм отличается `for` от оператора следующим образом: `parallel_for`

- `parallel_for` Алгоритм`parallel_for` не выполняет задачи в предварительно определенном порядке.

- `parallel_for` Алгоритм не поддерживает произвольные условия завершения. Алгоритм останавливается, когда текущее значение переменной итерации равно единице `last`меньше. `parallel_for`

- Параметр `_Index_type` типа должен быть целочисленным типом. Этот целочисленный тип может быть подписан или без знака.

- Итерация цикла должна быть прямой. Алгоритм создает исключение типа [std:: invalid_argument](../../standard-library/invalid-argument-class.md) , `_Step` если параметр меньше 1. `parallel_for`

- Механизм обработки исключений для `parallel_for` алгоритма отличается от `for` механизма для цикла. Если несколько исключений встречаются одновременно в теле параллельного цикла, среда выполнения распространяет только один из исключений в поток, вызвавший `parallel_for`. Кроме того, когда одна итерация цикла создает исключение, среда выполнения не останавливает весь цикл немедленно. Вместо этого цикл помещается в отмененное состояние, и среда выполнения удаляет все задачи, которые еще не запущены. Дополнительные сведения об обработке исключений и параллельных алгоритмах см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

`parallel_for` Хотя алгоритм не поддерживает произвольные условия завершения, можно использовать отмену для завершения всех задач. Дополнительные сведения об отмене см. [в разделе Отмена в библиотеке PPL](cancellation-in-the-ppl.md).

> [!NOTE]
>  Затраты на планирование, полученные в результате балансировки нагрузки и поддержки таких функций, как отмена, могут не компенсировать преимущества параллельного выполнения тела цикла, особенно если тело цикла относительно мало. Эту дополнительную нагрузку можно минимизировать, используя разделитель в параллельном цикле. Дополнительные сведения см. в разделе [секционирование работы](#partitions) далее в этом документе.

### <a name="example"></a>Пример

В следующем примере показана базовая структура `parallel_for` алгоритма. В этом примере на консоль выводятся все значения в диапазоне [1, 5] параллельно.

[!code-cpp[concrt-parallel-for-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_1.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
1 2 4 3 5
```

Так как `parallel_for` алгоритм действует для каждого элемента параллельно, порядок, в котором значения выводятся на консоль, будет отличаться.

Полный пример использования `parallel_for` алгоритма см. в разделе [как Напишите цикл](../../parallel/concrt/how-to-write-a-parallel-for-loop.md)parallel_for.

[[В начало](#top)]

##  <a name="parallel_for_each"></a>Алгоритм parallel_for_each

Алгоритм [параллелизма::p arallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) выполняет задачи в итеративном контейнере, например, предоставляемые C++ стандартной библиотекой, параллельно. Он использует ту же логику секционирования, `parallel_for` которую использует алгоритм.

Алгоритм напоминает алгоритм C++ стандартной библиотеки [std:: for_each](../../standard-library/algorithm-functions.md#for_each) , за исключением того, что `parallel_for_each` алгоритм выполняет задачи параллельно. `parallel_for_each` Как и другие параллельные `parallel_for_each` алгоритмы, не выполняет задачи в определенном порядке.

Несмотря на `parallel_for_each` то, что алгоритм работает как с прямыми итераторами, так и с итераторами произвольного доступа, он обеспечивает лучшую производительность с итераторами произвольного доступа.

### <a name="example"></a>Пример

В следующем примере показана базовая структура `parallel_for_each` алгоритма. В этом примере каждое значение в объекте [std:: Array](../../standard-library/array-class-stl.md) выводится на консоль параллельно.

[!code-cpp[concrt-parallel-for-each-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_2.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
4 5 1 2 3
```

Так как `parallel_for_each` алгоритм действует для каждого элемента параллельно, порядок, в котором значения выводятся на консоль, будет отличаться.

Полный пример использования `parallel_for_each` алгоритма см. в разделе [как Напишите цикл](../../parallel/concrt/how-to-write-a-parallel-for-each-loop.md)parallel_for_each.

[[В начало](#top)]

##  <a name="parallel_invoke"></a>Алгоритм parallel_invoke

Алгоритм [параллелизма::p arallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) параллельно выполняет набор задач. Она не возвращает результат, пока не завершится каждая задача. Этот алгоритм полезен при наличии нескольких независимых задач, которые необходимо выполнить одновременно.

`parallel_invoke` Алгоритм принимает в качестве параметров ряд рабочих функций (лямбда-функции, объекты функций или указатели функций). `parallel_invoke` Алгоритм перегружается для выполнения двух и десяти параметров. Каждая функция, передаваемая в `parallel_invoke` , должна принимать нулевые параметры.

Как и другие параллельные `parallel_invoke` алгоритмы, не выполняет задачи в определенном порядке. В разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) объясняется, `parallel_invoke` как алгоритм относится к задачам и группам задач.

### <a name="example"></a>Пример

В следующем примере показана базовая структура `parallel_invoke` алгоритма. Этот пример параллельно вызывает `twice` функцию для трех локальных переменных и выводит результат на консоль.

[!code-cpp[concrt-parallel-invoke-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_3.cpp)]

В этом примере выводятся следующие данные:

```Output
108 11.2 HelloHello
```

Полные примеры использования `parallel_invoke` алгоритма см. в разделе [как Используйте parallel_invoke для написания параллельной подпрограммы](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) сортировки [и выполнения следующих действий: Используйте parallel_invoke для выполнения параллельных](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)операций.

[[В начало](#top)]

##  <a name="parallel_transform_reduce"></a>Алгоритмы parallel_transform и parallel_reduce

Алгоритмы [Concurrency::p arallel_transform](reference/concurrency-namespace-functions.md#parallel_transform) и [Concurrency::p arallel_reduce](reference/concurrency-namespace-functions.md#parallel_reduce) — это параллельные версии C++ стандартных алгоритмов библиотеки [std:: Transform](../../standard-library/algorithm-functions.md#transform) и [std:: accumulate](../../standard-library/numeric-functions.md#accumulate)соответственно. Среда выполнения с параллелизмом версии ведут себя как версии C++ стандартной библиотеки, за исключением того, что порядок операций не определяется, так как они выполняются параллельно. Используйте эти алгоритмы при работе с набором, который достаточно велик для получения выигрыша в производительности и масштабируемости при параллельной обработке.

> [!IMPORTANT]
>  Алгоритмы `parallel_transform` и `parallel_reduce` поддерживают только итераторы произвольного доступа, двунаправленные и прямые итераторы, поскольку эти итераторы создают стабильные адреса памяти. Кроме того, эти итераторы должны создавать l-значения, отличные от `const`.

###  <a name="parallel_transform"></a>Алгоритм parallel_transform

Алгоритм `parallel transform` можно использовать для выполнения множества операций параллелизации данных. Например, с их помощью можно выполнять следующее.

- Настройка яркости изображения и другие операции обработки изображений.

- Суммирование или получение скалярного произведения двух векторов и выполнение других векторных вычислений.

- Трассировка трехмерных лучей, при которой каждая итерация относится к одному пикселю, подлежащему отображению.

В следующем примере показана базовая структура, используемая для вызова алгоритма `parallel_transform`. В этом примере каждый элемент объекта std::[vector](../../standard-library/vector-class.md) инвертируется двумя способами. В первом способе используется лямбда-выражение. Второй способ использует [std:: отрицание](../../standard-library/negate-struct.md), который является производным от [std:: unary_function](../../standard-library/unary-function-struct.md).

[!code-cpp[concrt-basic-parallel-transform#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_4.cpp)]

> [!WARNING]
>  В этом примере показано базовое использование функции `parallel_transform`. Поскольку рабочая функция выполняет незначительный объем работы, существенного прироста производительности в данном примере не ожидается.

Алгоритм `parallel_transform` имеет две перегрузки. Первая перегрузка принимает один входной диапазон и унарную функцию. Унарная функция может быть лямбда-выражением, принимающим один аргумент, объект функции или тип, производный от `unary_function`. Вторая перегрузка принимает два входных диапазона и бинарную функцию. Двоичная функция может быть лямбда-выражением, которое принимает два аргумента, объект функции или тип, производный от [std:: binary_function](../../standard-library/binary-function-struct.md). В следующем примере показаны эти различия.

[!code-cpp[concrt-parallel-transform-vectors#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_5.cpp)]

> [!IMPORTANT]
>  Итератор, предоставляемый для выходных данных алгоритма `parallel_transform`, должен полностью перекрывать итератор входных данных или не перекрывать его вообще. Если итераторы входных и выходных данных перекрываются частично, поведение этого алгоритма будет неопределенным.

###  <a name="parallel_reduce"></a>Алгоритм parallel_reduce

Алгоритм `parallel_reduce` эффективен при наличии последовательности операций, обладающих свойством ассоциативности. (Он не требует коммутативности). Ниже указано несколько операций, которые можно выполнять с помощью алгоритма `parallel_reduce`:

- умножение последовательности матриц для получения матрицы;

- умножение вектора на последовательность матриц для получения вектора;

- вычисление длины последовательности строк;

- объединение списка элементов, например строк, в один элемент.

В следующем базовом примере показано использование алгоритма `parallel_reduce` для объединения последовательности строк в одну строку. Как и в примерах для `parallel_transform`, в этом базовом примере не ожидается повышения производительности.

[!code-cpp[concrt-basic-parallel-reduce#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_6.cpp)]

Во многих случаях можно представить себе `parallel_reduce` сокращение использования `parallel_for_each` алгоритма вместе с классом [Concurrency:: combinable](../../parallel/concrt/reference/combinable-class.md) .

###  <a name="map_reduce_example"></a>Например Параллельное выполнение Map и reduce

Операция *Map* применяет функцию к каждому значению в последовательности. Операция *сокращения* объединяет элементы последовательности в одно значение. Для выполнения операций Map C++ и reduce можно использовать стандартные библиотеки [std:: Transform](../../standard-library/algorithm-functions.md#transform) и [std:: accumulate](../../standard-library/numeric-functions.md#accumulate) . Однако для многих задач можно использовать алгоритм `parallel_transform` для параллельного выполнения операции сопоставления и алгоритм `parallel_reduce` для параллельного выполнения операции редукции.

В следующем примере сравнивается время, необходимое для последовательного и параллельного вычисления суммы простых чисел. На этапе сопоставления составные числа преобразуются в 0, а на этапе редукции производится суммирование значений.

[!code-cpp[concrt-parallel-map-reduce-sum-of-primes#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_7.cpp)]

Еще один пример, в котором параллельно выполняется операция Map и reduce, [см. в разделе как Параллельное](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md)выполнение операций Map и reduce.

[[В начало](#top)]

##  <a name="partitions"></a>Работа по секционированию

Для параллелизации операции в источнике данных необходимо *секционировать* источник на несколько разделов, к которым можно получить доступ одновременно из нескольких потоков. Разделитель определяет, как параллельный алгоритм должен разделять диапазоны между потоками. Как описано ранее в этом документе, PPL использует механизм секционирования по умолчанию, создающий начальную рабочую нагрузку, а затем применяет алгоритм переноса нагрузки и переноса диапазона для распределения нагрузки этих разделов при ее несбалансированности. Например, когда одна итерация цикла завершает ряд итераций, среда выполнения перераспределяет в этот поток нагрузку с других потоков. Однако в некоторых сценариях может потребоваться указать другой механизм секционирования, который лучше подходит для конкретной задачи.

Алгоритмы `parallel_for`, `parallel_for_each` и `parallel_transform` предоставляют перегруженные версии, принимающие дополнительный параметр `_Partitioner`. Этот параметр определяет тип разделителя, разделяющий работу. Ниже указаны типы разделителей, которые определяет PPL.

[concurrency::affinity_partitioner](../../parallel/concrt/reference/affinity-partitioner-class.md)<br/>
Разделяет нагрузку на фиксированное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Этот тип разделителя напоминает `static_partitioner`, но повышает степень сходства кэша путем сопоставления диапазонов рабочим потокам. Такой тип разделителя может повысить производительность, если цикл выполняется над одним и тем же набором данных несколько раз (например, цикл в цикле) и данные размещаются в кэше. Этот разделитель не полностью участвует в отмене. Он также не использует согласованную семантику блокировки и поэтому не может использоваться с параллельными циклами, имеющими прямую зависимость.

[Concurrency:: auto_partitioner](../../parallel/concrt/reference/auto-partitioner-class.md)<br/>
Разделяет нагрузку на начальное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Среда выполнения использует этот тип по умолчанию, если не вызывается перегруженный параллельный алгоритм, принимающий параметр `_Partitioner`. Каждый диапазон можно разделить на поддиапазоны, что обеспечивает распределение нагрузки. Когда диапазон работы завершается, среда выполнения перераспределяет поддиапазоны работы с других потоков в этот поток. Используйте этот разделитель, если рабочая нагрузка не попадает в другие категории или требуется полная поддержка отмены или совместной блокировки.

[Concurrency:: simple_partitioner](../../parallel/concrt/reference/simple-partitioner-class.md)<br/>
Разделяет нагрузку на диапазоны так, чтобы каждый диапазон содержал по крайней мере такое число итераций, которое определено заданным размером блока. Этот тип разделителя участвует в распределении нагрузки; однако среда выполнения не делит диапазоны на поддиапазоны. Для каждого рабочего потока среда выполнения проверяет запрос отмены и выполняет распределение нагрузки после завершения числа итераций, определенных параметром `_Chunk_size`.

[Concurrency:: static_partitioner](../../parallel/concrt/reference/static-partitioner-class.md)<br/>
Разделяет нагрузку на фиксированное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Этот разделитель может повысить производительность, поскольку не использует перенос нагрузки и, следовательно, содержит меньше побочной нагрузки. Используйте его, если при каждой итерации параллельного цикла выполняется фиксированный и одинаковый объем работы и нет необходимости поддержки отмены или прямой совместной блокировки.

> [!WARNING]
>  Алгоритмы `parallel_for_each` и `parallel_transform` поддерживают только те контейнеры, которые используют итераторы произвольного доступа (например, std::[vector](../../standard-library/vector-class.md)) для статических, простых и территориальных секционирований. Применение контейнеров, использующих двунаправленные и прямые итераторы, приводит к ошибке во время компиляции. Разделитель по умолчанию `auto_partitioner` поддерживает все три типа итераторов.

Обычно эти разделители используются одинаково, за исключением `affinity_partitioner`. Большинство типов разделителей не поддерживают состояние и не изменяются средой выполнения. Поэтому эти объекты-разделители можно создавать в месте вызова, как показано в следующем примере.

[!code-cpp[concrt-static-partitioner#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_8.cpp)]

Однако необходимо передать объект `affinity_partitioner` как ссылку на I-значение, отличное от `const`, чтобы алгоритм мог сохранять состояние для повторного использования в последующих циклах. В следующем примере демонстрируется базовое приложение, параллельно выполняющее одну и ту же операцию над набором данных несколько раз. Использование `affinity_partitioner` позволяет повысить производительность, поскольку массив может размещаться в кэше.

[!code-cpp[concrt-affinity-partitioner#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_9.cpp)]

> [!CAUTION]
>  При изменении существующего кода, зависящего от семантики совместной блокировки при применении разделителей `static_partitioner` или `affinity_partitioner`, используйте с осторожностью. Эти разделители не используют распределение нагрузки и перенос диапазона и поэтому могут изменить поведение приложения.

Лучший способ определения необходимости использования разделителя в любом заданном сценарии — проведение экспериментов и измерение длительности выполнения операций при типичных нагрузках и конфигурациях компьютера. Например статическое секционирование может значительно ускорить работу на компьютере с небольшим количеством ядер, но привести к замедлению работы на компьютерах с относительно большим количеством ядер.

[[В начало](#top)]

##  <a name="parallel_sorting"></a>Параллельная сортировка

PPL предоставляет три алгоритма сортировки: [Concurrency::p arallel_sort](reference/concurrency-namespace-functions.md#parallel_sort), [Concurrency::p arallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort)и [Concurrency::p arallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort). Они эффективны при наличии набора данных, который выгоднее сортировать параллельно. В частности, параллельная сортировка эффективна при наличии большого набора данных и использовании операций сравнения, потребляющих много вычислительных ресурсов. Каждый из этих алгоритмов сортирует элементы на месте.

Алгоритмы `parallel_sort` и `parallel_buffered_sort` основаны на сравнениях. То есть они сравнивают элементы по значению. Алгоритм `parallel_sort` не требует дополнительной памяти и подходит для сортировки в общем случае. Алгоритм может выполняться лучше, чем `parallel_sort`, но он требует O (N) пространства. `parallel_buffered_sort`

Алгоритм `parallel_radixsort` основан на хэше. То есть для сортировки элементов он использует целочисленные ключи. С помощью ключей этот алгоритм может определить место элемента непосредственно, а не использовать операции сравнения. Например `parallel_buffered_sort`, для этого алгоритма требуется диск O (N).

В следующей таблице перечислены важные свойства трех параллельных алгоритмов сортировки.

|Алгоритм|Описание|Механизм сортировки|Стабильность сортировки|Требования к памяти|Временная сложность|Доступ итераторов|
|---------------|-----------------|-----------------------|--------------------|-------------------------|---------------------|---------------------|
|`parallel_sort`|Основанная на сравнениях сортировка общего назначения.|На основе сравнений (по возрастанию)|Нестабильная|Отсутствуют|O ((N/P)-журнал (N/P) + 2N ((P-1)/P))|Случайный|
|`parallel_buffered_sort`|Более быстрая сортировка общего назначения на основе сравнений, для которой требуется память O(N).|На основе сравнений (по возрастанию)|Нестабильная|Требуется дополнительное пространство O (N)|O ((N/P) журнал (N))|Случайный|
|`parallel_radixsort`|Сортировка на основе целочисленных ключей, для которой требуется память О(N).|На основе хэша|стабильных|Требуется дополнительное пространство O (N)|O (N/P)|Случайный|

На следующем рисунке графически показаны важные свойства трех параллельных алгоритмов сортировки.

![Сравнение алгоритмов сортировки](../../parallel/concrt/media/concrt_parallel_sorting.png "Сравнение алгоритмов сортировки")

Эти параллельные алгоритмы сортировки подчиняются правилам отмены и обработки исключений. Дополнительные сведения об отмене и обработке исключений в среда выполнения с параллелизмом см. в разделе [Отмена параллельных алгоритмов](../../parallel/concrt/cancellation-in-the-ppl.md#algorithms) и [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

> [!TIP]
>  Эти параллельные алгоритмы сортировки поддерживают семантику перемещений. Для более эффективного выполнения операций замены можно определить оператор присваивания перемещения. Дополнительные сведения о семантике перемещения и операторе назначения перемещения см. в разделе [декларатор ссылок rvalue: & &](../../cpp/rvalue-reference-declarator-amp-amp.md), [конструкторы перемещения и операторы присваивания перемещенияC++()](../../cpp/move-constructors-and-move-assignment-operators-cpp.md). Если оператор присваивания перемещения или функция замены не предоставляется, алгоритмы сортировки используют конструктор копии.

В следующем базовом примере показано использование алгоритма `parallel_sort` для сортировки вектора `vector` значений типа `int`. По умолчанию `parallel_sort` использует [std:: less](../../standard-library/less-struct.md) для сравнения значений.

[!code-cpp[concrt-basic-parallel-sort#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_10.cpp)]

В следующем примере показано, как реализовать пользовательскую функцию сравнения. В нем используется метод [std:: Complex:: Real](../../standard-library/complex-class.md#real) для сортировки значений [std::\<Complex Double >](../../standard-library/complex-double.md) в возрастающем порядке.

[!code-cpp[concrt-basic-parallel-sort#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_11.cpp)]

В следующем примере показано, как реализовать хэш-функцию для алгоритма `parallel_radixsort`. В этом примере сортируются трехмерные точки. Они сортируются по расстоянию от опорной точки.

[!code-cpp[concrt-parallel-sort-points#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_12.cpp)]

Для иллюстрации в этом примере используется относительно небольшой набор данных. Первоначальный размер вектора можно увеличить, чтобы поэкспериментировать с увеличением производительности при больших наборах данных.

В этом примере лямбда-выражение используется в качестве хэш-функции. Можно также использовать одну из встроенных реализаций класса std::[hash](../../standard-library/hash-class.md) или определить собственную специализацию. Кроме того, можно использовать пользовательский объект хэш-функции, как показано в следующем примере:

[!code-cpp[concrt-parallel-sort-points#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_13.cpp)]

[!code-cpp[concrt-parallel-sort-points#3](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_14.cpp)]

Хэш-функция должна возвращать целочисленный тип ([std:: is_integral:: value](../../standard-library/is-integral-class.md) должен иметь значение **true**). Этот целочисленный тип должен быть преобразуем в тип `size_t`.

###  <a name="choose_sort"></a>Выбор алгоритма сортировки

Во многих случаях алгоритм `parallel_sort` обеспечивает оптимальный баланс производительности памяти и быстродействия. Однако с увеличением размера набора данных, количества доступных процессоров и сложности функции сравнения алгоритм `parallel_buffered_sort` или `parallel_radixsort` может работать эффективнее. Лучший способ определения наиболее подходящего алгоритма сортировки в любом заданном сценарии — проведение экспериментов и измерение длительности выполнения сортировки типовых данных при типичных конфигурациях компьютера. Ниже приведены рекомендации по выбору стратегии сортировки.

- Размер набора данных. В этом документе *небольшой* набор данных содержит менее 1 000 элементов, *средний* набор данных содержит от 10 000 до 100 000 элементов, а *большой* набор данных содержит более 100 000 элементов.

- Объем работы, выполняемой функцией сравнения или хэш-функцией.

- Количество доступных вычислительных ресурсов.

- Характеристики набора данных. Например, один алгоритм может хорошо работать при частично отсортированных данных, но не так хорошо, когда данные совсем не сортированы.

- Размер блока. Необязательный аргумент `_Chunk_size` определяет, когда алгоритм переходит от параллельной к последовательной реализации сортировки по мере разделения всей задачи сортировки на меньшие единицы работы. Например, если указать 512, то алгоритм будет переходить на последовательную реализацию, когда единица работы содержит 512 или менее элементов. При последовательной реализации может повыситься общая производительность, поскольку исключается лишняя работа, необходимая для параллельной обработки данных.

Использовать параллельную сортировку небольшого набора данных может оказаться невыгодно даже при наличии большого количества вычислительных ресурсов или выполнении функцией сравнения или хэш-функцией относительно большого объема работы. Для сортировки небольших наборов данных можно использовать функцию [std:: Sort](../../standard-library/algorithm-functions.md#sort) . (`parallel_sort` и `parallel_buffered_sort` вызываются `sort` при указании размера фрагмента, который больше, чем набор данных, `parallel_buffered_sort` однако ему пришлось бы выделить O (N) пространство, которое может занять дополнительное время из-за конфликта блокировки или выделения памяти.)

Если необходимо сэкономить ресурсы памяти или распределитель памяти подвержен конфликтам при блокировках, то для сортировки набора данных среднего размера следует использовать алгоритм `parallel_sort`. `parallel_sort`не требует дополнительного пространства; другие алгоритмы нуждаются в пространстве O (N).

Используйте `parallel_buffered_sort` для сортировки наборов данных среднего размера и, если приложение соответствует требованиям к дополнительному свободному пространству (N). Алгоритм `parallel_buffered_sort` особенно эффективен при большом количестве вычислительных ресурсов и ресурсоемкой функции сравнения или хэш-функции.

Используйте `parallel_radixsort` для сортировки больших наборов данных и, если приложение соответствует требованиям к дополнительному свободному пространству (N). Алгоритм `parallel_radixsort` особенно эффективен при ресурсоемкой функции сравнения, а также в случае, если и функция сравнения, и хэш-функция ресурсоемки.

> [!CAUTION]
>  Для реализации хорошей хэш-функции требуется знание диапазона наборов данных и способа преобразования каждого элемента набора данных в соответствующее беззнаковое значение. Поскольку хэш-операции работают с беззнаковыми значениями, при невозможности получить беззнаковые хэш-значения рассмотрите другую стратегию сортировки.

В следующем примере сравнивается производительность алгоритмов `sort`, `parallel_sort`, `parallel_buffered_sort` и `parallel_radixsort` при одном и том же большом наборе случайных данных.

[!code-cpp[concrt-choosing-parallel-sort#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_15.cpp)]

В этом примере, в котором предполагается, что при сортировке допустимо выделить диск (N) пространства, `parallel_radixsort` выполняет лучшие в этом наборе данных конфигурацию этого компьютера.

[[В начало](#top)]

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Практическое руководство. Написание цикла parallel_for](../../parallel/concrt/how-to-write-a-parallel-for-loop.md)|Показывает, `parallel_for` как использовать алгоритм для перемножения матриц.|
|[Практическое руководство. Написание цикла parallel_for_each](../../parallel/concrt/how-to-write-a-parallel-for-each-loop.md)|Показывает, как использовать `parallel_for_each` алгоритм для вычисления числа простых чисел в объекте [std:: Array](../../standard-library/array-class-stl.md) параллельно.|
|[Практическое руководство. Использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности алгоритма битонной сортировки.|
|[Практическое руководство. Использование функции parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности программы, выполняющей несколько операций с общим источником данных.|
|[Практическое руководство. Параллельное выполнение операций сопоставления и редукции числа элементов](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md)|Демонстрируется использование алгоритмов `parallel_transform` и `parallel_reduce` для выполнения операций сопоставления и редукции, которые подсчитывают вхождения слов в файлах.|
|[Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)|Описывает библиотеку PPL, которая предоставляет императивную модель программирования, которая способствует масштабируемости и простоте использования при разработке параллельных приложений.|
|[Отмена в библиотеке параллельных шаблонов](cancellation-in-the-ppl.md)|Описание роли отмены в PPL, отмены параллельной работы и способа определения времени отмены группы задач.|
|[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)|Объясняет роль обработки исключений в среда выполнения с параллелизмом.|

## <a name="reference"></a>Ссылка

[parallel_for, функция](reference/concurrency-namespace-functions.md#parallel_for)

[parallel_for_each, функция](reference/concurrency-namespace-functions.md#parallel_for_each)

[parallel_invoke, функция](reference/concurrency-namespace-functions.md#parallel_invoke)

[Класс affinity_partitioner](../../parallel/concrt/reference/affinity-partitioner-class.md)

[Класс auto_partitioner](../../parallel/concrt/reference/auto-partitioner-class.md)

[Класс simple_partitioner](../../parallel/concrt/reference/simple-partitioner-class.md)

[Класс static_partitioner](../../parallel/concrt/reference/static-partitioner-class.md)

[Функция parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort)

[Функция parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort)

[Функция parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort)
