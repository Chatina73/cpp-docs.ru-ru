---
title: Параллельные алгоритмы
ms.date: 11/19/2018
helpviewer_keywords:
- parallel algorithms [Concurrency Runtime]
ms.assetid: 045dca7b-4d73-4558-a44c-383b88a28473
ms.openlocfilehash: a31787172c89e23e5eb32aa203b9f541584c0f68
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81363208"
---
# <a name="parallel-algorithms"></a>Параллельные алгоритмы

Библиотека параллельных шаблонов (PPL) предоставляет алгоритмы, которые одновременно выполняют работу над сбором данных. Эти алгоритмы напоминают алгоритмы, предоставленные Стандартной библиотекой СЗ.

Параллельные алгоритмы состоят из существующей функциональности в Параллельном Runtime. Например, [в алгоритме параллелизма::parallel для](reference/concurrency-namespace-functions.md#parallel_for) алгоритма используется [параллел::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) объект для выполнения параллельных итераций цикла. Алгоритмовые `parallel_for` перегородки работают оптимально, учитывая доступное количество вычислительных ресурсов.

## <a name="sections"></a><a name="top"></a>Разделы

- [Алгоритм parallel_for](#parallel_for)

- [Алгоритм parallel_for_each](#parallel_for_each)

- [Алгоритм parallel_invoke](#parallel_invoke)

- [Алгоритмы parallel_transform и parallel_reduce](#parallel_transform_reduce)

  - [Алгоритм parallel_transform](#parallel_transform)

  - [Алгоритм parallel_reduce](#parallel_reduce)

  - [Пример. Параллельное выполнение сопоставления и уменьшения](#map_reduce_example)

- [Секционирование работы](#partitions)

- [Параллельная сортировка](#parallel_sorting)

  - [Выбор алгоритма сортировки](#choose_sort)

## <a name="the-parallel_for-algorithm"></a><a name="parallel_for"></a>Алгоритм parallel_for

[Параллельно алгоритм параллелизм::parallel'для алгоритма.:parallel."](reference/concurrency-namespace-functions.md#parallel_for) выполняет одну и ту же задачу. Каждая из этих задач параметрызируется значением итерации. Этот алгоритм полезен, когда у вас есть тело цикла, которое не разделяет ресурсы между итерациями этого цикла.

Алгоритм `parallel_for` разгородки задач оптимальным способом для параллельного выполнения. В нем используется алгоритм переноса нагрузки и переноса диапазона для распределения этих секций в случае несбалансированной нагрузки. Когда одна итерация цикла блокируется совместно, время выполнения перераспределяет диапазон итераций, назначенных текущему потоку, другим потокам или процессорам. Аналогичным образом, когда поток завершает диапазон итераций, время выполнения перераспределяет работу от других потоков к этому потоку. Алгоритм `parallel_for` также поддерживает *вложенный параллелизм.* Когда одна параллельная петля содержит другой параллельный цикл, время выполнения координирует обработку ресурсов между телами циклов эффективным способом для параллельного выполнения.

У алгоритма `parallel_for` существует несколько перегруженных версий. Первая версия принимает начальное значение, конечную и рабочую функцию (выражение лямбда, объект функции или указатель функции). Вторая версия принимает начальное значение, конечную величину, значение, с помощью которого можно шагнуть, и функцию работы. Первая версия этой функции использует 1 в качестве значения шага. Остальные версии принимают объекты-разделители, позволяющие указать, как алгоритм `parallel_for` должен разделять диапазоны между потоками. Разделы более подробно разъясняются в разделе «Работа по [разделу»](#partitions) в этом документе.

Вы можете `for` преобразовать `parallel_for`много циклов для использования. Тем не `parallel_for` менее, алгоритм `for` отличается от оператора следующим образом:

- Алгоритм `parallel_for` `parallel_for` не выполняет задачи в заранее определенном порядке.

- Алгоритм `parallel_for` не поддерживает условия произвольного прекращения. Алгоритм `parallel_for` останавливается, когда текущее значение переменной итерации на один `last`меньше.

- Параметр `_Index_type` типа должен быть интегральным типом. Этот интегральный тип может быть подписан или не подписан.

- Итерация цикла должна быть впереди. Алгоритм `parallel_for` бросает исключение типа [std::invalid_argument](../../standard-library/invalid-argument-class.md) если `_Step` параметр меньше 1.

- Механизм обработки исключений `parallel_for` `for` для алгоритма отличается от механизма цикла. Если несколько исключений происходят одновременно в параллельном корпусе цикла, время выполнения `parallel_for`распространяется только одно из исключений из называетсяго потока. Кроме того, когда одна итерация цикла бросает исключение, время выполнения не сразу останавливает общий цикл. Вместо этого цикл помещается в отмененное состояние, и время выполнения отбрасывает все задачи, которые еще не начались. Для получения дополнительной информации об обработке [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)исключений и параллельных алгоритмах см.

Хотя `parallel_for` алгоритм не поддерживает условия произвольного прекращения, можно использовать отмену, чтобы остановить все задачи. Для получения дополнительной информации об отмене, см [Отмена в PPL](cancellation-in-the-ppl.md).

> [!NOTE]
> Затраты на планирование, которые являются результатом балансировки нагрузки и поддержки таких функций, как отмена, могут не преодолеть преимущества выполнения тела цикла параллельно, особенно когда тело цикла относительно невелико. Эту дополнительную нагрузку можно минимизировать, используя разделитель в параллельном цикле. Для получения дополнительной информации в этом документе можно ознакомиться на примере [раздела «Работа с разделами».](#partitions)

### <a name="example"></a>Пример

Ниже приводится базовая структура `parallel_for` алгоритма. Этот пример печатает на консоли каждое значение в диапазоне «1, 5» параллельно.

[!code-cpp[concrt-parallel-for-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_1.cpp)]

Этот пример приводит следующий выход из выборки:

```Output
1 2 4 3 5
```

Поскольку `parallel_for` алгоритм действует на каждый элемент параллельно, порядок, в котором значения печатаются на консоль, будет меняться.

Для полного примера, который использует `parallel_for` алгоритм, см. [Как: Написать parallel_for петлю](../../parallel/concrt/how-to-write-a-parallel-for-loop.md).

[Сверху](#top)

## <a name="the-parallel_for_each-algorithm"></a><a name="parallel_for_each"></a>Алгоритм parallel_for_each

[Алгоритм параллелизма::parallel-для-каждый](reference/concurrency-namespace-functions.md#parallel_for_each) выполняет задачи на итеративном контейнере, например, выполняемые Стандартной библиотекой СЗ. Он использует ту же логику `parallel_for` раздела, что алгоритм использует.

Алгоритм `parallel_for_each` напоминает [std](../../standard-library/algorithm-functions.md#for_each) Стандартной библиотеки C': for_each алгоритм, за исключением того, что `parallel_for_each` алгоритм выполняет задачи одновременно. Как и другие `parallel_for_each` параллельные алгоритмы, не выполняет задачи в определенном порядке.

Хотя `parallel_for_each` алгоритм работает как на передних итераторах, так и на итераторах случайного доступа, он лучше работает со случайными итераторами доступа.

### <a name="example"></a>Пример

Ниже приводится базовая структура `parallel_for_each` алгоритма. Этот пример печатает на консоли каждое значение в [std::](../../standard-library/array-class-stl.md) объект array параллельно.

[!code-cpp[concrt-parallel-for-each-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_2.cpp)]

Этот пример приводит следующий выход из выборки:

```Output
4 5 1 2 3
```

Поскольку `parallel_for_each` алгоритм действует на каждый элемент параллельно, порядок, в котором значения печатаются на консоль, будет меняться.

Для полного примера, который использует `parallel_for_each` алгоритм, см. [Как: Написать parallel_for_each петлю](../../parallel/concrt/how-to-write-a-parallel-for-each-loop.md).

[Сверху](#top)

## <a name="the-parallel_invoke-algorithm"></a><a name="parallel_invoke"></a>Алгоритм parallel_invoke

[Параллельной апартизм::pалгоритмаarallel'invoke](reference/concurrency-namespace-functions.md#parallel_invoke) выполняет набор задач параллельно. Он не возвращается до тех пор, пока каждая задача не завершится. Этот алгоритм полезен, когда у вас есть несколько независимых задач, которые вы хотите выполнить в то же время.

Алгоритм `parallel_invoke` берет в качестве своих параметров ряд рабочих функций (функции лямбда, объекты функций или указатели функций). Алгоритм `parallel_invoke` перегружен, чтобы взять от двух до десяти параметров. Каждая функция, `parallel_invoke` которую вы проходите, должна принимать нулевые параметры.

Как и другие `parallel_invoke` параллельные алгоритмы, не выполняет задачи в определенном порядке. Тема [«Параллельнос»](../../parallel/concrt/task-parallelism-concurrency-runtime.md) объясняет, как `parallel_invoke` алгоритм соотносится с задачами и группами задач.

### <a name="example"></a>Пример

Ниже приводится базовая структура `parallel_invoke` алгоритма. Этот пример одновременно `twice` вызывает функцию на трех локальных переменных и печатает результат на консоль.

[!code-cpp[concrt-parallel-invoke-structure#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_3.cpp)]

В этом примере выводятся следующие данные:

```Output
108 11.2 HelloHello
```

Для получения полных `parallel_invoke` примеров, которые используют алгоритм, см. [Как: Используйте parallel_invoke, чтобы написать параллельный сортировки и](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) [Как: Используйте parallel_invoke для выполнения параллельных операций.](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)

[Сверху](#top)

## <a name="the-parallel_transform-and-parallel_reduce-algorithms"></a><a name="parallel_transform_reduce"></a>Алгоритмы parallel_transform и parallel_reduce

[Параллелизм::parallel-transform](reference/concurrency-namespace-functions.md#parallel_transform) и [параллелизм::parallel-reduce](reference/concurrency-namespace-functions.md#parallel_reduce) алгоритмы параллельные версии алгоритмов стандартной библиотеки C's [std::transform](../../standard-library/algorithm-functions.md#transform) и [std::accumulate](../../standard-library/numeric-functions.md#accumulate), соответственно. Версии Concurrency Runtime ведут себя как версии Стандартной библиотеки, за исключением того, что порядок операции не определяется, поскольку они выполняются параллельно. Используйте эти алгоритмы при работе с набором, который достаточно велик для получения выигрыша в производительности и масштабируемости при параллельной обработке.

> [!IMPORTANT]
> Алгоритмы `parallel_transform` и `parallel_reduce` поддерживают только итераторы произвольного доступа, двунаправленные и прямые итераторы, поскольку эти итераторы создают стабильные адреса памяти. Кроме того, эти итераторы должны создавать l-значения, отличные от `const`.

### <a name="the-parallel_transform-algorithm"></a><a name="parallel_transform"></a>Алгоритм parallel_transform

Алгоритм `parallel transform` можно использовать для выполнения множества операций параллелизации данных. Например, администратор может сделать следующее:

- Настройка яркости изображения и другие операции обработки изображений.

- Суммирование или получение скалярного произведения двух векторов и выполнение других векторных вычислений.

- Трассировка трехмерных лучей, при которой каждая итерация относится к одному пикселю, подлежащему отображению.

В следующем примере показана базовая структура, используемая для вызова алгоритма `parallel_transform`. Этот пример сводит на нет каждый элемент std::[векторный](../../standard-library/vector-class.md) объект двумя способами. В первом способе используется лямбда-выражение. Второй способ использует [std::negate](../../standard-library/negate-struct.md), который происходит от [std::unary_function](../../standard-library/unary-function-struct.md).

[!code-cpp[concrt-basic-parallel-transform#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_4.cpp)]

> [!WARNING]
> В этом примере показано базовое использование функции `parallel_transform`. Поскольку рабочая функция выполняет незначительный объем работы, существенного прироста производительности в данном примере не ожидается.

Алгоритм `parallel_transform` имеет две перегрузки. Первая перегрузка принимает один входной диапазон и унарную функцию. Унарная функция может быть лямбда-выражением, принимающим один аргумент, объект функции или тип, производный от `unary_function`. Вторая перегрузка принимает два входных диапазона и бинарную функцию. Двоичная функция может быть выражением лямбды, которое занимает два аргумента, объект функции, или тип, который происходит от [std::binary_function](../../standard-library/binary-function-struct.md). В следующем примере показаны эти различия.

[!code-cpp[concrt-parallel-transform-vectors#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_5.cpp)]

> [!IMPORTANT]
> Итератор, предоставляемый для выходных данных алгоритма `parallel_transform`, должен полностью перекрывать итератор входных данных или не перекрывать его вообще. Если итераторы входных и выходных данных перекрываются частично, поведение этого алгоритма будет неопределенным.

### <a name="the-parallel_reduce-algorithm"></a><a name="parallel_reduce"></a>Алгоритм parallel_reduce

Алгоритм `parallel_reduce` эффективен при наличии последовательности операций, обладающих свойством ассоциативности. (Этот алгоритм не требует коммутативного свойства.) Вот некоторые из операций, которые `parallel_reduce`вы можете выполнить с:

- умножение последовательности матриц для получения матрицы;

- умножение вектора на последовательность матриц для получения вектора;

- вычисление длины последовательности строк;

- объединение списка элементов, например строк, в один элемент.

В следующем базовом примере показано использование алгоритма `parallel_reduce` для объединения последовательности строк в одну строку. Как и в примерах для `parallel_transform`, в этом базовом примере не ожидается повышения производительности.

[!code-cpp[concrt-basic-parallel-reduce#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_6.cpp)]

Во многих случаях можно `parallel_reduce` считать сокращением использования `parallel_for_each` алгоритма вместе с [параллелизмом:::комбинированный](../../parallel/concrt/reference/combinable-class.md) класс.

### <a name="example-performing-map-and-reduce-in-parallel"></a><a name="map_reduce_example"></a>Пример: Выполнение карты и сокращение параллельно

Операция *карты* применяет функцию к каждому значению в последовательности. Операция *уменьшения* объединяет элементы последовательности в одно значение. Вы можете использовать [std](../../standard-library/algorithm-functions.md#transform) Стандартной библиотеки C'::transform and [std::accumulate](../../standard-library/numeric-functions.md#accumulate) функции для выполнения карты и сокращения операций. Однако для многих задач можно использовать алгоритм `parallel_transform` для параллельного выполнения операции сопоставления и алгоритм `parallel_reduce` для параллельного выполнения операции редукции.

В следующем примере сравнивается время, необходимое для последовательного и параллельного вычисления суммы простых чисел. На этапе сопоставления составные числа преобразуются в 0, а на этапе редукции производится суммирование значений.

[!code-cpp[concrt-parallel-map-reduce-sum-of-primes#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_7.cpp)]

В другом примере, выполняемом карту и сокращаем операцию параллельно, [см.](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md)

[Сверху](#top)

## <a name="partitioning-work"></a><a name="partitions"></a>Работа по разделению

Для параллелии операции с источником данных важным шагом является *раздел* источника на несколько разделов, к которым можно получить доступ одновременно несколькими потоками. Разделитель определяет, как параллельный алгоритм должен разделять диапазоны между потоками. Как описано ранее в этом документе, PPL использует механизм секционирования по умолчанию, создающий начальную рабочую нагрузку, а затем применяет алгоритм переноса нагрузки и переноса диапазона для распределения нагрузки этих разделов при ее несбалансированности. Например, когда одна итерация цикла завершает ряд итераций, среда выполнения перераспределяет в этот поток нагрузку с других потоков. Однако в некоторых сценариях может потребоваться указать другой механизм секционирования, который лучше подходит для конкретной задачи.

Алгоритмы `parallel_for`, `parallel_for_each` и `parallel_transform` предоставляют перегруженные версии, принимающие дополнительный параметр `_Partitioner`. Этот параметр определяет тип разделителя, разделяющий работу. Ниже указаны типы разделителей, которые определяет PPL.

[concurrency::affinity_partitioner](../../parallel/concrt/reference/affinity-partitioner-class.md)<br/>
Разделяет нагрузку на фиксированное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Этот тип разделителя напоминает `static_partitioner`, но повышает степень сходства кэша путем сопоставления диапазонов рабочим потокам. Такой тип разделителя может повысить производительность, если цикл выполняется над одним и тем же набором данных несколько раз (например, цикл в цикле) и данные размещаются в кэше. Этот разделитель не полностью участвует в отмене. Он также не использует согласованную семантику блокировки и поэтому не может использоваться с параллельными циклами, имеющими прямую зависимость.

[concurrency::auto_partitioner](../../parallel/concrt/reference/auto-partitioner-class.md)<br/>
Разделяет нагрузку на начальное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Среда выполнения использует этот тип по умолчанию, если не вызывается перегруженный параллельный алгоритм, принимающий параметр `_Partitioner`. Каждый диапазон можно разделить на поддиапазоны, что обеспечивает распределение нагрузки. Когда диапазон работы завершается, среда выполнения перераспределяет поддиапазоны работы с других потоков в этот поток. Используйте этот разделитель, если рабочая нагрузка не попадает в другие категории или требуется полная поддержка отмены или совместной блокировки.

[concurrency::simple_partitioner](../../parallel/concrt/reference/simple-partitioner-class.md)<br/>
Разделяет нагрузку на диапазоны так, чтобы каждый диапазон содержал по крайней мере такое число итераций, которое определено заданным размером блока. Этот тип разделителя участвует в распределении нагрузки; однако среда выполнения не делит диапазоны на поддиапазоны. Для каждого рабочего потока среда выполнения проверяет запрос отмены и выполняет распределение нагрузки после завершения числа итераций, определенных параметром `_Chunk_size`.

[concurrency::static_partitioner](../../parallel/concrt/reference/static-partitioner-class.md)<br/>
Разделяет нагрузку на фиксированное число диапазонов (обычно число рабочих потоков, доступных для работы в цикле). Этот разделитель может повысить производительность, поскольку не использует перенос нагрузки и, следовательно, содержит меньше побочной нагрузки. Используйте его, если при каждой итерации параллельного цикла выполняется фиксированный и одинаковый объем работы и нет необходимости поддержки отмены или прямой совместной блокировки.

> [!WARNING]
> `parallel_for_each` Алгоритмы `parallel_transform` и алгоритмы поддерживают только контейнеры, которые используют случайные итераторы доступа (например, std::[вектор)](../../standard-library/vector-class.md)для статических, простых и разделительных перегородок. Применение контейнеров, использующих двунаправленные и прямые итераторы, приводит к ошибке во время компиляции. Разделитель по умолчанию `auto_partitioner` поддерживает все три типа итераторов.

Обычно эти разделители используются одинаково, за исключением `affinity_partitioner`. Большинство типов разделителей не поддерживают состояние и не изменяются средой выполнения. Поэтому эти объекты-разделители можно создавать в месте вызова, как показано в следующем примере.

[!code-cpp[concrt-static-partitioner#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_8.cpp)]

Однако необходимо передать объект `affinity_partitioner` как ссылку на I-значение, отличное от `const`, чтобы алгоритм мог сохранять состояние для повторного использования в последующих циклах. В следующем примере демонстрируется базовое приложение, параллельно выполняющее одну и ту же операцию над набором данных несколько раз. Использование `affinity_partitioner` позволяет повысить производительность, поскольку массив может размещаться в кэше.

[!code-cpp[concrt-affinity-partitioner#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_9.cpp)]

> [!CAUTION]
> При изменении существующего кода, зависящего от семантики совместной блокировки при применении разделителей `static_partitioner` или `affinity_partitioner`, используйте с осторожностью. Эти разделители не используют распределение нагрузки и перенос диапазона и поэтому могут изменить поведение приложения.

Лучший способ определения необходимости использования разделителя в любом заданном сценарии — проведение экспериментов и измерение длительности выполнения операций при типичных нагрузках и конфигурациях компьютера. Например статическое секционирование может значительно ускорить работу на компьютере с небольшим количеством ядер, но привести к замедлению работы на компьютерах с относительно большим количеством ядер.

[Сверху](#top)

## <a name="parallel-sorting"></a><a name="parallel_sorting"></a>Параллельная сортировка

PPL предоставляет три алгоритма сортировки: [параллелизм::parallel'sort](reference/concurrency-namespace-functions.md#parallel_sort), [параллел::parallel-buffered-sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort), и [параллел: :parallel'radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort). Они эффективны при наличии набора данных, который выгоднее сортировать параллельно. В частности, параллельная сортировка эффективна при наличии большого набора данных и использовании операций сравнения, потребляющих много вычислительных ресурсов. Каждый из этих алгоритмов сортирует элементы на месте.

Алгоритмы `parallel_sort` и `parallel_buffered_sort` основаны на сравнениях. То есть они сравнивают элементы по значению. Алгоритм `parallel_sort` не требует дополнительной памяти и подходит для сортировки в общем случае. Алгоритм `parallel_buffered_sort` может работать `parallel_sort`лучше, чем, но он требует O(N) пространства.

Алгоритм `parallel_radixsort` основан на хэше. То есть для сортировки элементов он использует целочисленные ключи. С помощью ключей этот алгоритм может определить место элемента непосредственно, а не использовать операции сравнения. Как, `parallel_buffered_sort`этот алгоритм требует O(N) пространства.

В следующей таблице перечислены важные свойства трех параллельных алгоритмов сортировки.

|Алгоритм|Описание|Механизм сортировки|Стабильность сортировки|Требования к памяти|Временная сложность|Доступ итераторов|
|---------------|-----------------|-----------------------|--------------------|-------------------------|---------------------|---------------------|
|`parallel_sort`|Основанная на сравнениях сортировка общего назначения.|На основе сравнений (по возрастанию)|Работает неустойчиво|Отсутствуют|O((N/P)log (N/P) 2N ((P-1)/P))|Случайные|
|`parallel_buffered_sort`|Более быстрая сортировка общего назначения на основе сравнений, для которой требуется память O(N).|На основе сравнений (по возрастанию)|Работает неустойчиво|Требуется дополнительное пространство O(N|O((N/P)log (N))|Случайные|
|`parallel_radixsort`|Сортировка на основе целочисленных ключей, для которой требуется память О(N).|На основе хэша|объем стабилен|Требуется дополнительное пространство O(N|O(N/P)|Случайные|

На следующем рисунке графически показаны важные свойства трех параллельных алгоритмов сортировки.

![Сравнение алгоритмов сортировки](../../parallel/concrt/media/concrt_parallel_sorting.png "Сравнение алгоритмов сортировки")

Эти параллельные алгоритмы сортировки подчиняются правилам отмены и обработки исключений. Для получения дополнительной информации об отмене и обработке исключений [Exception Handling](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)в Параллельном Runtime [см.](../../parallel/concrt/cancellation-in-the-ppl.md#algorithms)

> [!TIP]
> Эти параллельные алгоритмы сортировки поддерживают семантику перемещений. Для более эффективного выполнения операций замены можно определить оператор присваивания перемещения. Для получения дополнительной информации о семантике перемещения и операторе назначения [Move Constructors and Move Assignment Operators (C++)](../../cpp/move-constructors-and-move-assignment-operators-cpp.md)перемещения [ &&](../../cpp/rvalue-reference-declarator-amp-amp.md)см. Если оператор присваивания перемещения или функция замены не предоставляется, алгоритмы сортировки используют конструктор копии.

В следующем базовом примере показано использование алгоритма `parallel_sort` для сортировки вектора `vector` значений типа `int`. По умолчанию используется `parallel_sort` [std::less](../../standard-library/less-struct.md) для сравнения значений.

[!code-cpp[concrt-basic-parallel-sort#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_10.cpp)]

В следующем примере показано, как реализовать пользовательскую функцию сравнения. Он использует [std::complex::real](../../standard-library/complex-class.md#real) метод для сортировки [std::комплекс\<двойной>](../../standard-library/complex-double.md) значения в порядке возрастания.

[!code-cpp[concrt-basic-parallel-sort#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_11.cpp)]

В следующем примере показано, как реализовать хэш-функцию для алгоритма `parallel_radixsort`. В этом примере сортируются трехмерные точки. Они сортируются по расстоянию от опорной точки.

[!code-cpp[concrt-parallel-sort-points#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_12.cpp)]

Для иллюстрации в этом примере используется относительно небольшой набор данных. Первоначальный размер вектора можно увеличить, чтобы поэкспериментировать с увеличением производительности при больших наборах данных.

В этом примере лямбда-выражение используется в качестве хэш-функции. Вы также можете использовать одну из встроенных реализаций std:[хэш-класс](../../standard-library/hash-class.md) или определить собственную специализацию. Кроме того, можно использовать пользовательский объект хэш-функции, как показано в следующем примере:

[!code-cpp[concrt-parallel-sort-points#2](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_13.cpp)]

[!code-cpp[concrt-parallel-sort-points#3](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_14.cpp)]

Функция хэша должна вернуть интегральный тип[(std:::is_integral::value](../../standard-library/is-integral-class.md) должно быть **правдой).** Этот целочисленный тип должен быть преобразуем в тип `size_t`.

### <a name="choosing-a-sorting-algorithm"></a><a name="choose_sort"></a>Выбор алгоритма сортировки

Во многих случаях алгоритм `parallel_sort` обеспечивает оптимальный баланс производительности памяти и быстродействия. Однако с увеличением размера набора данных, количества доступных процессоров и сложности функции сравнения алгоритм `parallel_buffered_sort` или `parallel_radixsort` может работать эффективнее. Лучший способ определения наиболее подходящего алгоритма сортировки в любом заданном сценарии — проведение экспериментов и измерение длительности выполнения сортировки типовых данных при типичных конфигурациях компьютера. Ниже приведены рекомендации по выбору стратегии сортировки.

- Размер набора данных. В этом документе *небольшой* набор данных содержит менее 1000 элементов, *средний* набор данных содержит от 10 000 до 100 000 элементов, а *большой* набор данных содержит более 100 000 элементов.

- Объем работы, выполняемой функцией сравнения или хэш-функцией.

- Количество доступных вычислительных ресурсов.

- Характеристики набора данных. Например, один алгоритм может хорошо работать при частично отсортированных данных, но не так хорошо, когда данные совсем не сортированы.

- Размер блока. Необязательный аргумент `_Chunk_size` определяет, когда алгоритм переходит от параллельной к последовательной реализации сортировки по мере разделения всей задачи сортировки на меньшие единицы работы. Например, если указать 512, то алгоритм будет переходить на последовательную реализацию, когда единица работы содержит 512 или менее элементов. При последовательной реализации может повыситься общая производительность, поскольку исключается лишняя работа, необходимая для параллельной обработки данных.

Использовать параллельную сортировку небольшого набора данных может оказаться невыгодно даже при наличии большого количества вычислительных ресурсов или выполнении функцией сравнения или хэш-функцией относительно большого объема работы. Вы можете использовать [функцию std::sort](../../standard-library/algorithm-functions.md#sort) для сортировки небольших наборов данных. (`parallel_sort` `parallel_buffered_sort` и `sort` вызов, когда вы указываете размер куска, `parallel_buffered_sort` который больше, чем набор данных; однако, придется выделить O(N) пространство, которое может занять дополнительное время из-за блокировки раздора или распределения памяти.)

Если необходимо сэкономить ресурсы памяти или распределитель памяти подвержен конфликтам при блокировках, то для сортировки набора данных среднего размера следует использовать алгоритм `parallel_sort`. `parallel_sort`не требует дополнительного пространства; другие алгоритмы требуют пространства O(N).

Используйте `parallel_buffered_sort` для сортировки наборов данных среднего размера и при удовлетворении дополнительного требования пространства O/N. Алгоритм `parallel_buffered_sort` особенно эффективен при большом количестве вычислительных ресурсов и ресурсоемкой функции сравнения или хэш-функции.

Используйте `parallel_radixsort` для сортировки больших наборов данных и при удовлетворении дополнительного требования пространства O(N). Алгоритм `parallel_radixsort` особенно эффективен при ресурсоемкой функции сравнения, а также в случае, если и функция сравнения, и хэш-функция ресурсоемки.

> [!CAUTION]
> Для реализации хорошей хэш-функции требуется знание диапазона наборов данных и способа преобразования каждого элемента набора данных в соответствующее беззнаковое значение. Поскольку хэш-операции работают с беззнаковыми значениями, при невозможности получить беззнаковые хэш-значения рассмотрите другую стратегию сортировки.

В следующем примере сравнивается производительность алгоритмов `sort`, `parallel_sort`, `parallel_buffered_sort` и `parallel_radixsort` при одном и том же большом наборе случайных данных.

[!code-cpp[concrt-choosing-parallel-sort#1](../../parallel/concrt/codesnippet/cpp/parallel-algorithms_15.cpp)]

В этом примере, который предполагает, что допустимо выделять пространство `parallel_radixsort` O(N) во время сортировки, выполняет лучшие результаты в этом наборе данных в этой конфигурации компьютера.

[Сверху](#top)

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Практическое руководство. Написание цикла parallel_for](../../parallel/concrt/how-to-write-a-parallel-for-loop.md)|Показывает, как `parallel_for` использовать алгоритм для выполнения умножения матрицы.|
|[Практическое руководство. Написание цикла parallel_for_each](../../parallel/concrt/how-to-write-a-parallel-for-each-loop.md)|Показывает, как `parallel_for_each` использовать алгоритм для вычисления количества простого числа в [std::array](../../standard-library/array-class-stl.md) object параллельно.|
|[Практическое руководство. Использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности алгоритма битонной сортировки.|
|[Как: Используйте parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности программы, выполняющей несколько операций с общим источником данных.|
|[Практическое руководство. Параллельное выполнение операций сопоставления и сокращения числа элементов](../../parallel/concrt/how-to-perform-map-and-reduce-operations-in-parallel.md)|Демонстрируется использование алгоритмов `parallel_transform` и `parallel_reduce` для выполнения операций сопоставления и редукции, которые подсчитывают вхождения слов в файлах.|
|[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)|Описывает PPL, которая обеспечивает императивную модель программирования, которая способствует масштабируемости и простоте использования для разработки одновременных приложений.|
|[Отмена в библиотеке параллельных шаблонов](cancellation-in-the-ppl.md)|Объясняет роль отмены в PPL, как отменить параллельную работу и как определить, когда группа задач отменяется.|
|[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)|Объясняет роль обработки исключений в Времени выполнения параллелизма.|

## <a name="reference"></a>Справочник

[функция parallel_for](reference/concurrency-namespace-functions.md#parallel_for)

[Функция parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each)

[Функция parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke)

[affinity_partitioner класс](../../parallel/concrt/reference/affinity-partitioner-class.md)

[Класс auto_partitioner](../../parallel/concrt/reference/auto-partitioner-class.md)

[Класс simple_partitioner](../../parallel/concrt/reference/simple-partitioner-class.md)

[класс static_partitioner](../../parallel/concrt/reference/static-partitioner-class.md)

[Функция parallel_sort](reference/concurrency-namespace-functions.md#parallel_sort)

[Функция parallel_buffered_sort](reference/concurrency-namespace-functions.md#parallel_buffered_sort)

[Функция parallel_radixsort](reference/concurrency-namespace-functions.md#parallel_radixsort)
