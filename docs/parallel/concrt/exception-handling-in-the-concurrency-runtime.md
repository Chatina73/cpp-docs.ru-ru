---
title: Обработка исключений в среде выполнения с параллелизмом
ms.date: 11/04/2016
helpviewer_keywords:
- lightweight tasks, exception handling [Concurrency Runtime]
- exception handling [Concurrency Runtime]
- structured task groups, exception handling [Concurrency Runtime]
- agents, exception handling [Concurrency Runtime]
- task groups, exception handling [Concurrency Runtime]
ms.assetid: 4d1494fb-3089-4f4b-8cfb-712aa67d7a7a
ms.openlocfilehash: 8239913c369605503134a9ea4c99789528911868
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57272637"
---
# <a name="exception-handling-in-the-concurrency-runtime"></a>Обработка исключений в среде выполнения с параллелизмом

Среда выполнения с параллелизмом использует для взаимодействия различных видах ошибок обработки исключений C++. В число этих ошибок включено недопустимое использование исполняющей среды, такие ошибки исполняющей среды, как сбой в получении ресурса, а также ошибки в рабочих функциях, предоставляемых задачам и группам задач. Когда задача или группа задач создает исключение, исполняющая среда хранит это исключение и маршалирует его в контекст, ожидающий завершения задачи или группы задач. Для компонентов, таких как упрощенных задач и агентов среда выполнения не управляет исключениями для вас. В этом случае необходимо реализовать собственный механизм обработки исключений. В этом разделе описывается обработка в среде выполнения исключений, созданных задачами, группами задач, упрощенными задачами и асинхронными агентами, а также способы реагирования на исключения в приложениях.

## <a name="key-points"></a>Ключевые моменты

- Когда задача или группа задач создает исключение, исполняющая среда хранит это исключение и маршалирует его в контекст, ожидающий завершения задачи или группы задач.

- Если это возможно, окружите каждый вызов [Concurrency::Task:: Get](reference/task-class.md#get) и [Concurrency::Task:: wait](reference/task-class.md#wait) с `try` / `catch` блок для обработки ошибок, которые можно восстановить От. Среда выполнения завершает приложение, если задача создает исключение и это исключение не перехватывается задачей, одним из ее продолжений или основным приложением.

- Основанное на задаче продолжение выполняется всегда вне зависимости от того, завершилась ли предыдущая задача успешно, создала исключение или была отменена. Основанное на значении продолжение не выполняется, если предыдущая задача была отменена или создала исключение.

- Поскольку основанное на задаче продолжение задачи выполняется всегда, рассмотрите возможность добавления продолжения, основанного на задаче, в конец цепочки продолжения. Это позволяет гарантировать, что код проверяет все исключения.

- Среда выполнения создает [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) при вызове [Concurrency::Task:: Get](reference/task-class.md#get) и эта задача отменена.

- Среда выполнения не управляет исключениями для легковесных задач и агентов.

##  <a name="top"></a> В этом документе

- [Задачах и продолжениях](#tasks)

- [Группы задач и параллельных алгоритмов](#task_groups)

- [Исключения, создаваемые средой выполнения](#runtime)

- [Несколько исключений](#multiple)

- [Отмена](#cancellation)

- [Упрощенные задачи](#lwts)

- [Асинхронные агенты](#agents)

##  <a name="tasks"></a> Задачах и продолжениях

В этом разделе описывается, как среда выполнения обрабатывает исключения, вызываемые по [concurrency::task](../../parallel/concrt/reference/task-class.md) и их продолжениями. Дополнительные сведения о модели задач и продолжений см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md).

При создании исключения в теле рабочей функции, передаваемый `task` объекта, среда выполнения хранит это исключение и маршалирует его в контекст, вызывающий [Concurrency::Task:: Get](reference/task-class.md#get) или [параллелизма:: Task::wait](reference/task-class.md#wait). Документ [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) описывает на основе задач и продолжений, основанное на значении, но чтобы суммировать, продолжение на основе значения принимает параметр типа `T` и продолжение на основе задачи принимает параметр типа `task<T>`. Если задача, которая создает исключение, имеет одно или несколько продолжений, основанных на значении, эти продолжения не ставятся в очередь для запуска. Это демонстрируется в приведенном ниже примере.

[!code-cpp[concrt-eh-task#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_1.cpp)]

Продолжение на основе задачи позволяет обрабатывать любое исключение, созданное предшествующей задачей. Основанное на задаче продолжение выполняется всегда вне зависимости от того, завершилась ли задача успешно, создала исключение или была отменена. Если задача создает исключение, ее продолжения на основе задач вносятся в план для выполнения. В следующем примере показана задача, которая всегда создает исключение. У задачи два продолжения: одно основано на значении, а другое — на задаче. Продолжение на основе задачи выполняется всегда и, таким образом, может перехватить исключение, созданное предшествующей задачей. Если в примере ожидается завершение обоих продолжений, исключение создается повторно, поскольку исключение задачи всегда создается при вызове `task::get` или `task::wait`.

[!code-cpp[concrt-eh-continuations#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_2.cpp)]

Рекомендуется использовать продолжения на основе задачи, чтобы перехватывать исключения, которые вы можете обработать. Поскольку основанное на задаче продолжение задачи выполняется всегда, рассмотрите возможность добавления продолжения, основанного на задаче, в конец цепочки продолжения. Это позволяет гарантировать, что код проверяет все исключения. В следующем примере показана простая цепочка продолжений на основе значений. Третья задача в цепочке создает исключение, и поэтому все последующие продолжения на основе значений не выполняются. Однако последнее продолжение основано на задаче, и поэтому всегда выполняется. Последнее продолжение обрабатывает исключение, которое создается третьей задачей.

Рекомендуется перехватывать максимально конкретные исключения. Можно опустить это последнее продолжение на основе задачи, если у вас нет определенных исключений, которые необходимо перехватывать. Любое исключение останется необработанным и может завершить приложение.

[!code-cpp[concrt-eh-task-chain#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_3.cpp)]

> [!TIP]
>  Можно использовать [Concurrency::task_completion_event:: set_exception](../../parallel/concrt/reference/task-completion-event-class.md) метод должен быть сопоставлен исключение события завершения задачи. Документ [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) описывает [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) класс более подробно.

[Concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) является типом исключения важных среды выполнения, к которому относится `task`. Среда выполнения создает `task_canceled` при вызове `task::get`, если эта задача отменена. (И наоборот, `task::wait` возвращает [task_status::canceled](reference/concurrency-namespace-enums.md#task_group_status) и не создает исключение.) Можно перехватить и обработать данное исключение в продолжении на основе задачи или при вызове `task::get`. Дополнительные сведения об отмене задач см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md).

> [!CAUTION]
>  Никогда не вызывайте исключение `task_canceled` из своего кода. Вызовите [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) вместо этого.

Среда выполнения завершает приложение, если задача создает исключение и это исключение не перехватывается задачей, одним из ее продолжений или основным приложением. Если приложение аварийно завершается, можно настроить Visual Studio, чтобы прерывать выполнение при создании исключений C++. После выяснения расположения необработанного исключения используйте продолжение на основе задачи, чтобы обработать его.

Разделе [исключения, создаваемые средой выполнения](#runtime) в этом документе описывается, как работать с исключениями среды выполнения более подробно.

[[В начало](#top)]

##  <a name="task_groups"></a> Группы задач и параллельных алгоритмов

В этом разделе описывается, как среда выполнения обрабатывает исключения, создаваемые объектами группы задач. В этом разделе применяется также к параллельным алгоритмам, например [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), так как эти алгоритмы основаны на группах задач.

> [!CAUTION]
>  Убедитесь, что вы понимаете влияние исключений на зависимые задачи. Рекомендации по использованию обработки исключений с задачами или параллельными алгоритмами, см. в разделе [Общие сведения о том, как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) статьи рекомендации в параллельном режиме Раздел библиотеки шаблонов.

Дополнительные сведения о группах задач см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md). Дополнительные сведения об алгоритмах параллельных операций, см. в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

При создании исключения в теле рабочей функции, передаваемый [concurrency::task_group](reference/task-group-class.md) или [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) объекта, среда выполнения хранит это исключение и маршалирует его контекст, который вызывает [Concurrency::task_group:: wait](reference/task-group-class.md#wait), [Concurrency::structured_task_group:: wait](reference/structured-task-group-class.md#wait), [Concurrency::task_group:: run_and_wait](reference/task-group-class.md#run_and_wait), или [Concurrency::structured_task_group:: run_and_wait](reference/structured-task-group-class.md#run_and_wait). Среда выполнения также останавливает все активные задачи, которые находятся в группе задач (включая дочерние группы задач) и удаляет все задачи, которые еще не запущено.

Следующий пример показывает базовую структуру рабочую функцию, которая вызывает исключение. В примере используется `task_group` объекта для печати значения двух `point` объектов в параллельном режиме. `print_point` Рабочая функция печатает значения `point` на консоль. Рабочая функция создает исключение, если входное значение оценивается `NULL`. Среда выполнения хранит это исключение и маршалирует его в контекст, вызывающий `task_group::wait`.

[!code-cpp[concrt-eh-task-group#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_4.cpp)]

В этом примере формируются следующие данные:

```Output
X = 15, Y = 30Caught exception: point is NULL.
```

Полный пример, в котором используется обработка исключений в группу задач, см. в разделе [как: Использование обработки исключений для выхода из параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).

[[В начало](#top)]

##  <a name="runtime"></a> Исключения, создаваемые средой выполнения

Исключение может быть результатом вызова среды выполнения. Большинство типов исключений, за исключением [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) и [concurrency::operation_timed_out](../../parallel/concrt/reference/operation-timed-out-class.md), указывают на ошибку программирования. Эти ошибки обычно устранить нельзя и поэтому не должно перехвачено и обработано кодом приложения. Мы советуем использовать только перехватывать или обрабатывать неустранимые ошибки в коде приложения, при необходимости для диагностики ошибок программирования. Тем не менее понимание типов исключений, определенные средой выполнения может помочь диагностировать ошибки программирования.

Механизм обработки исключений для исключений, создаваемых средой выполнения как исключения, которые вызываются рабочие функции совпадает. Например [concurrency::receive](reference/concurrency-namespace-functions.md#receive) функция создает исключение `operation_timed_out` при не получает сообщение в указанный период времени. Если `receive` вызывает исключение в рабочей функции, что передаваемый группу задач, среда выполнения хранит это исключение и маршалирует его в контекст, вызывающий `task_group::wait`, `structured_task_group::wait`, `task_group::run_and_wait`, или `structured_task_group::run_and_wait`.

В следующем примере используется [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм для параллельного выполнения двух задач. Первая задача ждет пять секунд и затем отправляет сообщение в буфер сообщений. Вторая задача использует `receive` функции в течение трех секунд для получения сообщения из одного буфера сообщений. `receive` Функция создает исключение `operation_timed_out` если он не получает сообщение в течение периода времени.

[!code-cpp[concrt-eh-time-out#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_5.cpp)]

В этом примере формируются следующие данные:

```Output
The operation timed out.
```

Чтобы предотвратить ошибочное завершение работы приложения, убедитесь, что код обрабатывает исключения, при вызове в среду выполнения. Также можно обрабатывать исключения, при вызове внешний код, который использует среда выполнения с параллелизмом, например, сторонней библиотеки.

[[В начало](#top)]

##  <a name="multiple"></a> Несколько исключений

Если задача или параллельный алгоритм получает несколько исключений, среда выполнения маршалирует только одно из этих исключений для контекста вызова. Среда выполнения не гарантирует его маршалирует об исключении.

В следующем примере используется `parallel_for` алгоритм для печати номера на консоль. Он создает исключение, если входное значение меньше некоторых минимальное значение или больше, чем некоторое максимальное значение. В этом примере несколько рабочих функций может создавать исключения.

[!code-cpp[concrt-eh-multiple#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_6.cpp)]

Ниже приведен пример выходных данных для этого примера.

```Output
8293104567Caught exception: -5: the value is less than the minimum.
```

[[В начало](#top)]

##  <a name="cancellation"></a> Отмена

Не все исключения указывают на ошибку. Например алгоритм поиска может использовать обработку исключений для остановки связанной задачи при нахождении результата. Дополнительные сведения об использовании механизмов отмены в коде см. в разделе [Отмена в PPL](../../parallel/concrt/cancellation-in-the-ppl.md).

[[В начало](#top)]

##  <a name="lwts"></a> Упрощенные задачи

Упрощенная задача — это задача, планируемая непосредственно из [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) объекта. Упрощенные задачи дают меньше ресурсов, чем обычные задачи. Тем не менее среда выполнения не перехватывает исключения, вызываемые упрощенных задач. Вместо этого исключение перехватывается обработчиком необработанных исключений, который по умолчанию завершает процесс. Таким образом используйте соответствующий механизм обработки ошибок в приложении. Дополнительные сведения об упрощенных задач см. в разделе [планировщик](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

[[В начало](#top)]

##  <a name="agents"></a> Асинхронные агенты

Как и упрощенных задач среда выполнения не управляет исключений, создаваемых асинхронными агентами.

В примере показан один из способов обработки исключений в класс, производный от [concurrency::agent](../../parallel/concrt/reference/agent-class.md). В этом примере определяется `points_agent` класса. `points_agent::run` Операций чтения метод `point` объектов из буфера сообщений и выводит их на консоль. `run` Метод вызывает исключение, если он получает `NULL` указатель.

`run` Метод помещает всю работу в `try` - `catch` блока. `catch` Блок сохраняет исключение в буфере сообщений. Приложение проверяет ли агент обнаружил ошибку при чтении с данным буфером, после завершения работы агента.

[!code-cpp[concrt-eh-agents#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_7.cpp)]

В этом примере формируются следующие данные:

```Output
X: 10 Y: 20
X: 20 Y: 30
error occurred in agent: point must not be NULL
the status of the agent is: done
```

Так как `try` - `catch` блок находится за пределами `while` цикл, агент завершает обработку при обнаружении первой ошибки. Если `try` - `catch` блок находилась внутри `while` цикл, агент будет продолжен после возникновения ошибки.

В этом примере исключения хранятся в буфере сообщений другому компоненту можно наблюдать за агент на наличие ошибок во время выполнения. В этом примере используется [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) объект для хранения ошибки. В случае, если агент обрабатывает несколько исключений `single_assignment` класс хранит только первое сообщение, которое передается в него. Чтобы сохранить только последнее исключение, используйте [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) класса. Чтобы сохранить все исключения, используйте [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) класса. Дополнительные сведения об этих блоков сообщений см. в разделе [асинхронные блоки сообщений](../../parallel/concrt/asynchronous-message-blocks.md).

Дополнительные сведения об асинхронных агентов, см. в разделе [асинхронных агентов](../../parallel/concrt/asynchronous-agents.md).

[[В начало](#top)]

##  <a name="summary"></a> Сводка

[[В начало](#top)]

## <a name="see-also"></a>См. также

[Среда выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime.md)<br/>
[Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)<br/>
[Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)<br/>
[Отмена в библиотеке параллельных шаблонов](cancellation-in-the-ppl.md)<br/>
[Планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)<br/>
[Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)
