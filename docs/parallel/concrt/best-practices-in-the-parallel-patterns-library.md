---
title: Рекомендации по работе с библиотекой параллельных шаблонов
ms.date: 11/04/2016
helpviewer_keywords:
- Parallel Patterns Library, practices to avoid
- practices to avoid, Parallel Patterns Library
- best practices, Parallel Patterns Library
- Parallel Patterns Library, best practices
ms.assetid: e43e0304-4d54-4bd8-a3b3-b8673559a9d7
ms.openlocfilehash: fc120ecc122678b54c7dd27b95445f523bc114a6
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57293619"
---
# <a name="best-practices-in-the-parallel-patterns-library"></a>Рекомендации по работе с библиотекой параллельных шаблонов

В этом документе описано, как наиболее эффективно использовать библиотеку параллельных шаблонов (PPL). Библиотека PPL предоставляет алгоритмы, объекты и контейнеры общего назначения для выполнения детального параллелизма.

Дополнительные сведения о библиотеке параллельных Шаблонов, см. в разделе [библиотеки параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md).

##  <a name="top"></a> Разделы

Этот документ содержит следующие разделы.

- [Параллелизацию небольших циклов](#small-loops)

- [Реализуйте параллелизм на самом высоком уровне](#highest)

- [Использование функции parallel_invoke для разрешения разделяй и властвуй проблем](#divide-and-conquer)

- [Используйте отмену или обработки исключений для выхода из параллельного цикла](#breaking-loops)

- [Понять, как отмена и обработка исключений влияет на уничтожение объектов](#object-destruction)

- [Не блокируйте несколько раз в параллельном цикле](#repeated-blocking)

- [Не выполняйте операции блокировки при отмене параллельных работ](#blocking)

- [Не выполняйте запись в общие данные в параллельном цикле](#shared-writes)

- [По возможности избегайте ложного совместного доступа](#false-sharing)

- [Убедитесь, что переменные допустимы на протяжении времени существования задачи](#lifetime)

##  <a name="small-loops"></a> Параллелизацию небольших циклов

Распараллеливание относительно небольших тел циклов может привести к дополнительным издержкам при планировании, которые сведут на нет преимущества параллельной обработки. Рассмотрим следующий пример, в котором каждая пара элементов помещается в два массива.

[!code-cpp[concrt-small-loops#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_1.cpp)]

Нагрузка каждой итерации параллельного цикла слишком мала, чтобы почувствовать преимущества параллельной обработки. Можно повысить производительность этого цикла, выполняя больше работы в теле цикла или выполняя цикл последовательно.

[[В начало](#top)]

##  <a name="highest"></a> Реализуйте параллелизм на самом высоком уровне

При распараллеливании кода только на низком уровне можно ввести конструкцию ветвления-соединения, которая не масштабируется при увеличении числа процессоров. Объект *ветвления слияния* — это структура, где одна задача разделяет работу на более мелкие параллельные подзадачи и ожидает их завершения. Каждая подзадача может рекурсивно делиться на еще более мелкие подзадачи.

Хотя модель ветвления-соединения может быть полезна для решения различных проблем, существуют ситуации, когда затраты на синхронизацию могут снизить масштабируемость. Например, рассмотрим следующий последовательный код, обрабатывающий данные изображений.

[!code-cpp[concrt-image-processing-filter#20](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_2.cpp)]

Поскольку каждая итерация цикла независима, можно распараллеливать большую часть работы, как показано в следующем примере. В этом примере используется [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) алгоритм для параллелизации внешнего цикла.

[!code-cpp[concrt-image-processing-filter#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_3.cpp)]

В следующем примере показана конструкции ветвления-соединения путем вызова функции `ProcessImage` в цикле. Каждый вызов `ProcessImage` не возвращает данные до завершения подзадачи.

[!code-cpp[concrt-image-processing-filter#21](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_4.cpp)]

Если при каждой итерации параллельного цикла выполняется очень мало работы или работа, выполняемая параллельным циклом, несбалансирована (то есть некоторые итерации цикла выполняются дольше, чем другие), затраты на планирование, необходимое для частого ветвления и соединения работы, могут перевесить преимущества параллельного выполнения. Эти затраты растут по мере роста числа процессов.

Чтобы уменьшить объем затрат на планирование в этом примере, можно распараллелить внешние циклы перед внутренними или использовать другие параллельные конструкции, например конвейер. В следующем примере изменяется `ProcessImages` функцию, используемую [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) алгоритм для параллелизации внешнего цикла.

[!code-cpp[concrt-image-processing-filter#22](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_5.cpp)]

Аналогичный пример, в котором для параллельного выполнения обработки изображений используется конвейер, см. в разделе [Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).

[[В начало](#top)]

##  <a name="divide-and-conquer"></a> Использование функции parallel_invoke для разрешения разделяй и властвуй проблем

Объект *разделяй и властвуй* проблема — это форма конструкции ветвления соединения, которая использует рекурсию для разбиения задачи на подзадачи. В дополнение к [concurrency::task_group](reference/task-group-class.md) и [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) классы, можно также использовать [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм Устранение проблем, разделяй и властвуй. Алгоритм `parallel_invoke` имеет более сжатый синтаксис, чем объекты группы задач, и удобен при наличии фиксированного числа параллельных задач.

В следующем примере показано использование алгоритма `parallel_invoke` для реализации алгоритма битонной сортировки.

[!code-cpp[concrt-parallel-bitonic-sort#12](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_6.cpp)]

Для снижения затрат алгоритм `parallel_invoke` выполняет последний ряд задач в вызывающем контексте.

Полную версию этого примера, см. в разделе [как: Использование функции parallel_invoke для написания параллельного сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md). Дополнительные сведения о `parallel_invoke` алгоритм, см. в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

[[В начало](#top)]

##  <a name="breaking-loops"></a> Используйте отмену или обработки исключений для выхода из параллельного цикла

Библиотека PPL предоставляет два способа отмены параллельной работы, выполняемой группой задач или параллельным алгоритмом. Первый способ — использовать механизм отмены, предоставляемый [concurrency::task_group](reference/task-group-class.md) и [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) классы. Второй способ — создать исключение в теле рабочей функции задачи. Механизм отмены более эффективен, чем обработка исключений при отмене дерева параллельной работы. Объект *дерево параллельной работы* — это группа связанных групп задач в которых некоторые группы задач содержат другие группы задач. Механизм отмены отменяет группу задач и ее дочерние группы в порядке «сверху вниз». И наоборот, обработка исключений работает в режиме «снизу вверх» и необходимо отменять каждую дочернюю группу задач независимо, поскольку исключение распространяется вверх.

При работе непосредственно с объектом группы задач, используйте [Concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) или [Concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) для отмены работы, принадлежащей этой группе задач . Чтобы отменить параллельный алгоритм, например `parallel_for`, создайте родительскую группу задач и отмените ее. Например, рассмотрим следующую функцию, `parallel_find_any`, которая выполняет поиск значения в массиве в параллельном режиме.

[!code-cpp[concrt-parallel-array-search#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_7.cpp)]

Поскольку параллельные алгоритмы используют группы задач, когда одна из параллельных итераций отменяет родительскую группу задач, общая задача также отменяется. Полную версию этого примера, см. в разделе [как: Использование отмены для выхода из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md).

Хотя обработка исключений является менее эффективным способом отмены параллельной работы, чем механизм отмены, существуют случаи, в которых лучше применять обработку исключений. Например, следующий метод, `for_all`, рекурсивно выполняет рабочую функцию для каждого узла структуры `tree`. В этом примере `_children` член данных является [std::list](../../standard-library/list-class.md) , содержащий `tree` объектов.

[!code-cpp[concrt-task-tree-search#6](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_8.cpp)]

Вызывающий объект метода `tree::for_all` может создать исключение, если ему не требуется вызывать рабочую функцию для каждого элемента дерева. В следующем примере показана функция `search_for_value`, которая выполняет поиск значения в предоставленном объекте `tree`. Функция `search_for_value` использует рабочую функцию, которая создает исключение, если текущий элемент дерева соответствует предоставленному значению. Функция `search_for_value` использует блок `try-catch`, чтобы зафиксировать исключение и вывести результат на консоль.

[!code-cpp[concrt-task-tree-search#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_9.cpp)]

Полную версию этого примера, см. в разделе [как: Использование обработки исключений для выхода из параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).

Более общие сведения об отмене и механизмы обработки исключений, предоставляемых библиотекой PPL см. в разделе [Отмена в PPL](cancellation-in-the-ppl.md) и [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

[[В начало](#top)]

##  <a name="object-destruction"></a> Понять, как отмена и обработка исключений влияет на уничтожение объектов

В дереве параллельной работы отмененная задача предотвращает запуск дочерних задач. Это может привести к проблемам, если одна из дочерних задач выполняет операцию, важную для приложения, например высвобождает ресурс. Кроме того, отмена задачи может привести к тому, что исключение распространится через деструктор объектов и вызовет неопределенное поведение в приложении.

В следующем примере класс `Resource` описывает ресурс, а класс `Container` — контейнер, содержащий ресурсы. В его деструкторе класс `Container` вызывает метод `cleanup` для двух из его членов `Resource` в параллельном режиме, а затем вызывает метод `cleanup` для третьего члена `Resource`.

[!code-cpp[concrt-parallel-resource-destruction#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_10.h)]

Несмотря на то что эта схема сама по себе не представляет никаких проблем, рассмотрим следующий код, выполняющий две задачи параллельно. Первая задача создает объект `Container`, а вторая задача отменяет общую задачу. Для иллюстрации в примере используются два [concurrency::event](../../parallel/concrt/reference/event-class.md) объектов, чтобы убедиться в том, что Отмена происходила после `Container` объект создается и что `Container` объект уничтожается после отмены Операция выполняется.

[!code-cpp[concrt-parallel-resource-destruction#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_11.cpp)]

В этом примере выводятся следующие данные:

```Output
Container 1: Freeing resources...Exiting program...
```

Данный пример кода содержит следующие проблемы, которые могут привести к неожиданному поведению.

- Отмена родительской задачи приводит к дочерней задачи — вызова [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke), также отменяется. Таким образом, эти два ресурса не высвобождаются.

- Отмена родительской задачи приводит к тому, что дочерняя задача создает внутреннее исключение. Поскольку деструктор `Container` не обрабатывает это исключение, оно распространяется вверх и третий ресурс не высвобождается.

- Исключение, создаваемое дочерней задачей, распространяется по всему деструктору `Container`. Создание исключения из деструктора приводит приложение в неопределенное состояние.

Рекомендуется не выполнять важные операции, например высвобождение ресурсов, в задачах, если нельзя гарантировать, что эти задачи не будут отменены. Также рекомендуется не использовать функции среды выполнения, которые могут создавать исключение в деструкторе типов.

[[В начало](#top)]

##  <a name="repeated-blocking"></a> Не блокируйте несколько раз в параллельном цикле

Параллельный цикл, такой как [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) или [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) , в котором преобладают, блокируя операций могут вызвать выполнения создает много потоков за короткое время.

Среда выполнения с параллелизмом выполняет дополнительную работу, когда задача завершается или выполняет совместную блокировку либо выход. Когда одна итерация параллельного цикла блокируется, среда выполнения может начать другую итерацию. Если нет свободных бездействующих потоков, среда выполнения создает новый поток.

В случае блокировки тела параллельного цикла, этот механизм позволяет увеличить производительность общей задачи. Однако, если блокируется много итераций, среда выполнения может создавать много потоков для выполнения дополнительной работы. Это может привести к условиям нехватки памяти или неэффективного использования аппаратных ресурсов.

Рассмотрим следующий пример, который вызывает [concurrency::send](reference/concurrency-namespace-functions.md#send) функции в каждой итерации `parallel_for` цикла. Поскольку функция `send` выполняет совместную блокировку, среда выполнения создает новый поток для выполнения дополнительной работы при каждом вызове `send`.

[!code-cpp[concrt-repeated-blocking#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_12.cpp)]

Рекомендуется выполнить рефакторинг кода, чтобы избежать этой ситуации. В этом примере показано, как можно избежать создания дополнительных потоков, вызвав функцию `send` в последовательном цикле `for`.

[[В начало](#top)]

##  <a name="blocking"></a> Не выполняйте операции блокировки при отмене параллельных работ

По возможности не выполняйте операции блокировки до вызова [Concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) или [Concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) метод отмены параллельной работы.

Когда задача выполняет операцию совместной блокировки, среда выполнения может выполнять другую работу, пока первая задача ожидает получения данных. Среда выполнения переносит выполнение ожидающей задачи на момент после разблокирования. Как правило, среда выполнения сначала переносит выполнение задач, разблокированных недавно, а затем — задач, разблокированных ранее. Поэтому среда выполнения может запланировать лишнюю работу во время операции блокировки, что приводит к снижению производительности. Соответственно, при выполнении операции блокировки до отмены параллельной работы операция блокировки может задержать вызов метода `cancel`. В этом случае другие задачи выполняют лишнюю работу.

Рассмотрим следующий пример, определяющий функцию `parallel_find_answer`, которая выполняет поиск элемента указанного массива, удовлетворяющего заданной предикативной функции. Когда предикативная функция возвращает **true**, функция параллельной работы создает `Answer` и отменяет общую задачу.

[!code-cpp[concrt-blocking-cancel#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_13.cpp)]

Оператор `new` выполняет выделение кучи, которое может блокироваться. Среда выполнения выполняет другую работу, только в том случае, когда задача выполняет вызов совместной блокировки, например вызов [Concurrency::critical_section:: lock](reference/critical-section-class.md#lock).

В следующем примере показано, как предотвратить лишнюю работу и тем самым повысить производительность. Этот пример отменяет группу задач до выделения хранилища для объекта `Answer`.

[!code-cpp[concrt-blocking-cancel#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_14.cpp)]

[[В начало](#top)]

##  <a name="shared-writes"></a> Не выполняйте запись в общие данные в параллельном цикле

Среда выполнения с параллелизмом предоставляет несколько структур данных, например, [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md), синхронизирующих параллельный доступ к общим данным. Эти структуры данных удобны во многих случаях, например, если нескольким задачам нечасто нужен общий доступ к ресурсу.

Рассмотрим следующий пример, использующий [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) алгоритм и `critical_section` для вычисления количества простых чисел в [std::array](../../standard-library/array-class-stl.md) объекта. Этот пример нельзя масштабировать, так как каждый поток должен ждать доступа к общей переменной `prime_sum`.

[!code-cpp[concrt-parallel-sum-of-primes#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_15.cpp)]

Этот пример также может привести к снижению производительности, поскольку частое выполнение операции блокировки эффективно сериализует цикл. Кроме того, когда объект среды выполнения с параллелизмом выполняет операцию блокировки, планировщик может создавать дополнительный поток, чтобы выполнять другую работу, пока первый поток ожидает поступления данных. Если среда выполнения создает много потоков (поскольку многие задачи ожидают доступ к общим данным), может наблюдаться снижение производительности или переход приложения в состояние нехватки ресурсов.

Библиотека PPL определяет [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) класс, который помогает исключить общее состояние, предоставляя доступ к общим ресурсам без блокировок. Класс `combinable` предоставляет локальное для потока хранилище, которое позволяет выполнять детализированные вычисления и объединять их в общий результат. Объект `combinable` можно рассматривать как переменную уменьшения.

Следующий пример изменяет предыдущий, используя объект `combinable` вместо объекта `critical_section` для вычисления суммы. Этот пример масштабируется, так как каждый поток содержит свою собственную локальную копию суммы. В этом примере используется [Concurrency::combinable:: Combine](reference/combinable-class.md#combine) метод для слияния вычислений в конечный результат.

[!code-cpp[concrt-parallel-sum-of-primes#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_16.cpp)]

Полную версию этого примера, см. в разделе [как: Использование класса combinable для повышения производительности](../../parallel/concrt/how-to-use-combinable-to-improve-performance.md). Дополнительные сведения о `combinable` , представлена в разделе [параллельные контейнеры и объекты](../../parallel/concrt/parallel-containers-and-objects.md).

[[В начало](#top)]

##  <a name="false-sharing"></a> По возможности избегайте ложного совместного доступа

*Ложное совместное использование* возникает, когда несколько параллельных задач, которые выполняются на отдельных процессорах записи переменные, которые находятся в той же строке кэша. Когда одна задача записывает данные в одну из переменных, строка кэша для обоих переменных становится недействительной. Каждый процессор должен перезагружать строку кэша каждый раз, когда строка кэша становится недействительной. Таким образом, ложное совместное использование может привести к снижению производительности приложения.

Следующий простой пример демонстрирует две параллельные задачи, увеличивающие значение общей переменной счетчика.

[!code-cpp[concrt-false-sharing#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_17.cpp)]

Чтобы исключить совместное использование данных двумя задачами, можно изменить этот пример для использования двух переменных счетчика. В этом примере окончательное значение счетчика вычисляется после выполнения задач. Тем не менее этот пример иллюстрирует ложное совместное использование, так как переменные `count1` и `count2`, скорее всего, расположены в одной и той же строке кэша.

[!code-cpp[concrt-false-sharing#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_18.cpp)]

Одним из способов исключить ложное совместное использование является использование переменных счетчика в разных строках кэша. Следующий пример выравнивает переменные `count1` и `count2` в границах 64 байтов.

[!code-cpp[concrt-false-sharing#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_19.cpp)]

В этом примере предполагается, что размер кэша памяти — 64 байта или менее.

Мы рекомендуем использовать [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) класса вы должны обмениваться данными между задачами. Класс `combinable` создает локальные для потока переменные таким образом, что ложное совместное использование становится менее вероятным. Дополнительные сведения о `combinable` , представлена в разделе [параллельные контейнеры и объекты](../../parallel/concrt/parallel-containers-and-objects.md).

[[В начало](#top)]

##  <a name="lifetime"></a> Убедитесь, что переменные допустимы на протяжении времени существования задачи

При предоставлении лямбда-выражения группе задач или параллельному алгоритму предложение фиксации указывает, получает ли тело лямбда-выражения доступ к переменным во внешней области по значению или по ссылке. При передаче переменных в лямбда-выражение по ссылке необходимо обеспечить сохранение существования этой переменной до завершения задачи.

Рассмотрим следующий пример, определяющий класс `object` и функцию `perform_action`. Функция `perform_action` создает переменную `object` и выполняет некоторые действия с этой переменной асинхронно. Поскольку нет гарантий, что выполнение задачи завершится до возвращения данных функцией `perform_action`, можно ожидать сбой или непредвиденное поведение программы в случае уничтожения переменной `object` во время выполнения задачи.

[!code-cpp[concrt-lambda-lifetime#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_20.cpp)]

В зависимости от требований приложения можно использовать один из следующих способов, чтобы гарантировать, что переменные будут оставаться действительными на протяжении всего времени существования каждой задачи.

В следующем примере переменная `object` передается задаче по значению. Поэтому задача работает с собственной копией переменной.

[!code-cpp[concrt-lambda-lifetime#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_21.cpp)]

Поскольку переменная `object` передается по значению, любые изменения состояния этой переменной не отражаются в исходной копии.

В следующем примере используется [Concurrency::task_group:: wait](reference/task-group-class.md#wait) метод, чтобы убедиться в том, что до завершения задачи `perform_action` возврата функции.

[!code-cpp[concrt-lambda-lifetime#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_22.cpp)]

Так как задача завершается до возвращения данных функцией, функция `perform_action` больше не может обеспечить асинхронное поведение.

В следующем примере демонстрируется изменение функции `perform_action`, чтобы использовать ссылку на переменную `object`. Вызывающий объект должен гарантировать, что время существования переменной `object` будет действительно до завершения задачи.

[!code-cpp[concrt-lambda-lifetime#4](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_23.cpp)]

Кроме того, для управления временем существования объекта, передаваемого в группу задач или параллельный алгоритм, можно использовать указатель.

Дополнительные сведения о лямбда-выражениях см. в разделе [Лямбда-выражения](../../cpp/lambda-expressions-in-cpp.md).

[[В начало](#top)]

## <a name="see-also"></a>См. также

[Рекомендации по работе со средой выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-best-practices.md)<br/>
[Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)<br/>
[Параллельные контейнеры и объекты](../../parallel/concrt/parallel-containers-and-objects.md)<br/>
[Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)<br/>
[Отмена в библиотеке параллельных шаблонов](cancellation-in-the-ppl.md)<br/>
[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)<br/>
[Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)<br/>
[Практическое руководство. Использование функции parallel_invoke для написания программы параллельной сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)<br/>
[Практическое руководство. Использование отмены для выхода из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md)<br/>
[Практическое руководство. Использование класса combinable для повышения производительности](../../parallel/concrt/how-to-use-combinable-to-improve-performance.md)<br/>
[Рекомендации по работе с библиотекой асинхронных агентов](../../parallel/concrt/best-practices-in-the-asynchronous-agents-library.md)<br/>
[Общие рекомендации в среде выполнения с параллелизмом](../../parallel/concrt/general-best-practices-in-the-concurrency-runtime.md)
