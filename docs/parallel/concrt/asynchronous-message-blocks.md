---
title: Асинхронные блоки сообщений
ms.date: 11/04/2016
helpviewer_keywords:
- non-greedy join [Concurrency Runtime]
- asynchronous message blocks
- greedy join [Concurrency Runtime]
ms.assetid: 79c456c0-1692-480c-bb67-98f2434c1252
ms.openlocfilehash: de6a433ab733207d5c56b46e693837056a0cd8b1
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57274171"
---
# <a name="asynchronous-message-blocks"></a>Асинхронные блоки сообщений

Библиотека агентов предоставляет несколько типов блоков сообщений, которые позволяют передавать сообщения между компонентами приложения в виде поточно ориентированными. Эти типы блоков сообщений часто используются с различные процедуры передачи сообщений, таких как [concurrency::send](reference/concurrency-namespace-functions.md#send), [concurrency::asend](reference/concurrency-namespace-functions.md#asend), [concurrency::receive](reference/concurrency-namespace-functions.md#receive), и [concurrency::try_receive](reference/concurrency-namespace-functions.md#try_receive). Дополнительные сведения о процедурах, определенные библиотекой агентов передачи сообщений, см. в разделе [функции передачи сообщений](../../parallel/concrt/message-passing-functions.md).

##  <a name="top"></a> Разделы

В этом разделе содержатся следующие подразделы.

- [Исходные и целевые объекты](#sources_and_targets)

- [Распространение сообщений](#propagation)

- [Обзор типов блоков сообщений](#overview)

- [Класс unbounded_buffer](#unbounded_buffer)

- [Класс overwrite_buffer](#overwrite_buffer)

- [Класс single_assignment](#single_assignment)

- [Класс call](#call)

- [Класс transformer](#transformer)

- [Класс choice](#choice)

- [Классы соединения и multitype_join](#join)

- [Класс timer](#timer)

- [Фильтрация сообщений](#filtering)

- [Резервирование сообщений](#reservation)

##  <a name="sources_and_targets"></a> Исходные и целевые объекты

Источники и целевые объекты являются два важных участника передачи сообщений. Объект *источника* — это конечная точка связи, который отправляет сообщения. Объект *целевой* — это конечная точка связи, который получает сообщения. Можно представить как конечную точку, которая считывается из источника и целевой конечной точки, предназначенный для. Приложения подключаться исходные и целевые объекты вместе форму *сети обмена сообщениями*.

Библиотека агентов использует два абстрактных классов для представления исходные и целевые объекты: [concurrency::ISource](../../parallel/concrt/reference/isource-class.md) и [concurrency::ITarget](../../parallel/concrt/reference/itarget-class.md). Типы блоков сообщений, выполняющие роль источников, являются производными от `ISource`; типы блоков сообщений, действующие как целевые объекты являются производными от `ITarget`. Типы блоков сообщений, действующие в качестве источников и целевых объектов являются производными от обоих `ISource` и `ITarget`.

[[В начало](#top)]

##  <a name="propagation"></a> Распространение сообщений

*Сообщения* — это процесс отправки сообщения из одного компонента в другой. Когда блок сообщений предлагается сообщение, он может принять, отклонить или отложить его. Типы блоков сообщений сохраняют и передают сообщения по-разному. Например `unbounded_buffer` класс хранит неограниченное число сообщений, `overwrite_buffer` класс хранит одно сообщение за раз, а класс transformer сохраняет измененную версию каждого сообщения. Эти типы блоков сообщений описаны более подробно далее в этом документе.

Когда блок сообщений принимает сообщение, его можно при необходимости выполнения работы и, если блок сообщения является источником, передать результирующее сообщение другому члену сети. Блок сообщений можно использовать функцию фильтрации, чтобы отказаться от сообщения, которые не нужно получать. Фильтры описаны более подробно далее в этом разделе, в разделе [фильтрацию сообщений](#filtering). Блок сообщений, откладывающий сообщения можно зарезервировать и использовать его позже. Резервирование сообщений описан более подробно далее в этом разделе, в разделе [резервирование сообщений](#reservation).

Библиотека агентов позволяет блокам сообщений асинхронно или синхронно передавать сообщения. При передаче сообщения в блок сообщений синхронно, например, с помощью `send` функции, среда выполнения блокирует текущий контекст, пока в целевой блок принимает или отклоняет сообщение. При передаче сообщения в блок сообщений асинхронно, например, с помощью `asend` функция, среда выполнения предлагает сообщение целевому объекту, и если целевой объект принимает сообщение, планирует асинхронную задачу, распространяющую сообщение в приемник. Среда выполнения использует упрощенных задач передавать сообщения по принципу совместной работы. Дополнительные сведения об упрощенных задач см. в разделе [планировщик](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

Исходные и целевые объекты подключения приложений друг с другом сети обмена сообщениями. Как правило, вы свяжете в сети и вызвать `send` или `asend` для передачи данных в сети. Чтобы подключиться блок сообщений источника к целевому объекту, вызовите [concurrency::ISource::link_target](reference/isource-class.md#link_target) метод. Чтобы отключить блок источника от целевого объекта, вызовите [concurrency::ISource::unlink_target](reference/isource-class.md#unlink_target) метод. Чтобы разорвать подключение блок источника всех его целей, вызовите [concurrency::ISource::unlink_targets](reference/isource-class.md#unlink_targets) метод. Когда один из предопределенных типов блоков сообщений покидает область или уничтожается, он автоматически отключает сам от любого целевым блокам. Некоторые типы блоков сообщений ограничить максимальное число целевых объектов, которые могут быть записаны. Следующий раздел описывает ограничения, которые применяются для предопределенных типов блоков сообщений.

[[В начало](#top)]

##  <a name="overview"></a> Обзор типов блоков сообщений

В следующей таблице кратко описывается роль типов важных блоков сообщений.

[unbounded_buffer](#unbounded_buffer)<br/>
Хранит очередь сообщений.

[overwrite_buffer](#overwrite_buffer)<br/>
Хранит одно сообщение, в которые записываются и чтение из несколько раз.

[single_assignment](#single_assignment)<br/>
Хранит одно сообщение, которое могут быть записаны один раз и чтение из несколько раз.

[Вызов](#call)<br/>
Выполняет работу, когда он получает сообщение.

[transformer](#transformer)<br/>
Выполняет работу, когда он получает данные и отправляет результат своей работы другому целевому блоку. `transformer` Класс может действовать на различные входные и выходные типы.

[Выбор](#choice)<br/>
Выбирает первое доступное сообщение из набора источников.

[соединение и возвращаемым соединение](#join)<br/>
Ожидания для всех сообщений, полученных из набора источников и затем объединяет эти сообщения в одно сообщение для другого блока сообщений.

[Таймера](#timer)<br/>
Отправляет сообщение в целевой блок на регулярной основе.

Эти типы блоков сообщений имеют разные характеристики, которые делают их полезными в различных ситуациях. Ниже перечислены некоторые характеристики:

- *Тип распространения*: Является ли блок сообщений выступает в качестве источника данных и приемником данных.

- *Упорядочение сообщений*: Сохраняет ли блок сообщений исходный порядок, в котором сообщения отправляются и не получаются. Каждый предопределенные типы блоков сообщений сохраняет исходный порядок, в котором он отправляет или получает сообщения.

- *Источник число*: Максимальное количество источников, которые могут считываться в блок сообщений.

- *Целевой числа*: Максимальное число целевых объектов, которые может производить запись в блок сообщений.

В следующей таблице показаны взаимосвязи этих характеристик различных типов блоков сообщений.

|Тип блока сообщений|Тип распространения (источник, целевой объект или оба)|Сообщение, упорядочение (Ordered или Unordered)|Число источников|Число целевых объектов|
|------------------------|--------------------------------------------------|-----------------------------------------------|------------------|------------------|
|`unbounded_buffer`|Оба|Упорядоченного|Unbounded|Unbounded|
|`overwrite_buffer`|Оба|Упорядоченного|Unbounded|Unbounded|
|`single_assignment`|Оба|Упорядоченного|Unbounded|Unbounded|
|`call`|целевого объекта|Упорядоченного|Unbounded|Не применимо|
|`transformer`|Оба|Упорядоченного|Unbounded|1|
|`choice`|Оба|Упорядоченного|10|1|
|`join`|Оба|Упорядоченного|Unbounded|1|
|`multitype_join`|Оба|Упорядоченного|10|1|
|`timer`|Исходный код|Не применимо|Не применимо|1|

Типы блоков сообщений, более подробно в следующих разделах.

[[В начало](#top)]

##  <a name="unbounded_buffer"></a> Класс unbounded_buffer

[Concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) класс представляет структуру общего назначения асинхронного обмена сообщениями. В этом классе хранится очередь сообщений типа «первым вошел — первым вышел» (FIFO), в которую могут записывать данные несколько источников и из которой могут читать данные несколько целевых объектов. Если целевой объект получает сообщение от `unbounded_buffer` объекта, это сообщение удаляется из очереди сообщений. Таким образом несмотря на то что `unbounded_buffer` объект может иметь несколько целевых объектов, только один целевой объект получит каждое сообщение. Класс `unbounded_buffer` удобен, если нужно передать несколько сообщений другому компоненту и этот компонент должен принять каждое сообщение.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `unbounded_buffer` класса. В этом примере отправляются три значения `unbounded_buffer` объекта, а затем эти значения считываются обратно из того же объекта.

[!code-cpp[concrt-unbounded_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_1.cpp)]

В этом примере выводятся следующие данные:

```Output
334455
```

Полный пример, показывающий, как использовать `unbounded_buffer` , представлена в разделе [как: Реализация различных шаблонов-приемник](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).

[[В начало](#top)]

##  <a name="overwrite_buffer"></a> Класс overwrite_buffer

[Concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) класс похож на `unbounded_buffer` класса, за исключением случаев, `overwrite_buffer` объект сохраняет только одно сообщение. Кроме того, в том случае, когда целевой объект получает сообщение от `overwrite_buffer` объекта, это сообщение не удаляется из буфера. Поэтому копию сообщения могут получить несколько целевых объектов.

`overwrite_buffer` Класс может быть полезен, когда требуется передать несколько сообщений другому компоненту, но этому компоненту нужно только самое последнее значение. Этот класс также может оказаться полезным при необходимости широковещательной передачи сообщения нескольким компонентам.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `overwrite_buffer` класса. В этом примере отправляются три значения `overwrite _buffer` объекта и затем считывает текущее значение из того же объекта три раза. Этот пример похож на пример для `unbounded_buffer` класса. Тем не менее `overwrite_buffer` класс сохраняет только одно сообщение. Кроме того, среда выполнения не удаляет сообщение из `overwrite_buffer` объекта после чтения.

[!code-cpp[concrt-overwrite_buffer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_2.cpp)]

В этом примере выводятся следующие данные:

```Output
555555
```

Полный пример, показывающий, как использовать `overwrite_buffer` , представлена в разделе [как: Реализация различных шаблонов-приемник](../../parallel/concrt/how-to-implement-various-producer-consumer-patterns.md).

[[В начало](#top)]

##  <a name="single_assignment"></a> Класс single_assignment

[Concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) класс похож на `overwrite_buffer` класса, за исключением случаев, `single_assignment` объект можно записать только один раз. Как и в случае с классом `overwrite_buffer`, когда целевой объект получает сообщение от объекта `single_assignment`, это сообщение не удаляется. Поэтому копию сообщения могут получить несколько целевых объектов. `single_assignment` Класс полезен при необходимости широковещательной передачи одного сообщения нескольким компонентам.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `single_assignment` класса. В этом примере отправляются три значения `single_assignment` объекта и затем считывает текущее значение из того же объекта три раза. Этот пример похож на пример для `overwrite_buffer` класса. Несмотря на то что как `overwrite_buffer` и `single_assignment` классы хранить одно сообщение, `single_assignment` класса могут быть записаны только один раз.

[!code-cpp[concrt-single_assignment-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_3.cpp)]

В этом примере выводятся следующие данные:

```Output
333333
```

Полный пример, показывающий, как использовать `single_assignment` , представлена в разделе [Пошаговое руководство: Реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md).

[[В начало](#top)]

##  <a name="call"></a> Класс Call

[Concurrency::call](../../parallel/concrt/reference/call-class.md) класс ведет себя как получатель сообщения, который выполняет рабочую функцию при получении данных. Эта рабочая функция может быть лямбда-выражение, объект функции или указатель функции. Объект `call` объекта отличается от вызова обычной функции ведет себя так, как он работает параллельно с другими компонентами, отправку сообщений. Если `call` объект выполняет работу при получении сообщения, он добавляет это сообщение в очередь. Каждый `call` объект обрабатывает сообщения в порядке, в котором они поступают из очереди.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `call` класса. В этом примере создается `call` объект, который выводит все значения, которые он получает на консоль. Затем в примере выполняется отправка три значения `call` объекта. Так как `call` объекта во время обработки сообщения в отдельном потоке, в этом примере также используется переменная счетчика и [событий](../../parallel/concrt/reference/event-class.md) объекта, чтобы убедиться, что `call` объект обрабатывает все сообщения до `wmain` функция возвращает.

[!code-cpp[concrt-call-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_4.cpp)]

В этом примере выводятся следующие данные:

```Output
334455
```

Полный пример, показывающий, как использовать `call` , представлена в разделе [как: Предоставление рабочих функций классам call и transformer](../../parallel/concrt/how-to-provide-work-functions-to-the-call-and-transformer-classes.md).

[[В начало](#top)]

##  <a name="transformer"></a> Класс transformer

[Concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) класс выступает в качестве получателя, так и в качестве отправителя сообщения. `transformer` Класс похож на `call` класса, так как он выполняет рабочую функцию определяемых пользователем, при получении данных. Тем не менее `transformer` класс также отправляет результат рабочей функции объектам-получателям. Как и `call` объекта, `transformer` действует параллельно с другими компонентами, отправку сообщений. Если `transformer` объект выполняет работу при получении сообщения, он добавляет это сообщение в очередь. Каждый `transformer` объекта во время обработки сообщения в порядке, в котором они поступают из своей очереди.

`transformer` Класс отправляет свои сообщения для одного целевого объекта. Если задать `_PTarget` параметра в конструктор для `NULL`, позже можно указать целевой объект, вызвав [concurrency::link_target](reference/source-block-class.md#link_target) метод.

В отличие от всех других асинхронных типов блоков сообщений, предоставляемых библиотекой агентов `transformer` класс может действовать на различные входные и выходные типы. Эта способность преобразовывать данные из одного типа в другой превращает `transformer` класса ключевым компонентом многих параллельных сетей. Кроме того, можно добавить возможность параллельной обработки более детальных в рабочая функция `transformer` объекта.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `transformer` класса. В этом примере создается `transformer` объекта, умножающий все введенные `int` значение 0,33, чтобы получить `double` значение в качестве выходных данных. Затем пример получает преобразованные значения из того же `transformer` объекта и выводит их на консоль.

[!code-cpp[concrt-transformer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_5.cpp)]

В этом примере выводятся следующие данные:

```Output
10.8914.5218.15
```

Полный пример, показывающий, как использовать `transformer` , представлена в разделе [как: Использование преобразователя в конвейере данных](../../parallel/concrt/how-to-use-transformer-in-a-data-pipeline.md).

[[В начало](#top)]

##  <a name="choice"></a> Класс Choice

[Concurrency::choice](../../parallel/concrt/reference/choice-class.md) класс выбирает первое доступное сообщение из набора источников. `choice` Класс представляет механизм потока управления вместо механизма потока данных (раздел [Asynchronous Agents Library](../../parallel/concrt/asynchronous-agents-library.md) описываются различия между потока данных и поток управления).

Чтение из объекта choice похоже на вызов функции Windows API `WaitForMultipleObjects` когда `bWaitAll` параметру присвоить `FALSE`. Тем не менее `choice` классе привязывает данные для событий, а не к внешнему объекту синхронизации.

Как правило, используется `choice` класса вместе с [concurrency::receive](reference/concurrency-namespace-functions.md#receive) функцию для использования потока управления в приложении. Используйте `choice` класса при наличии можно выбрать один из буферов сообщений, которые имеют разные типы. Используйте `single_assignment` класса при наличии можно выбрать один из буферов сообщений, которые имеют одинаковый тип.

Порядок связывания источников `choice` важен, поскольку он определяет какое сообщение. Например, рассмотрим случай, где можно связать несколько буферов сообщений, которые уже содержат сообщение `choice` объекта. `choice` Объекта выбирает сообщение из первого источника, связанного с ним. После привязки всех источников `choice` сохраняет порядок, в котором каждый источник получает сообщение.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `choice` класса. В этом примере используется [concurrency::make_choice](reference/concurrency-namespace-functions.md#make_choice) функцию для создания `choice` объект, который выбирает среди трех блоков сообщений. Затем в примере вычисляются различные числа Фибоначчи и каждый результат сохраняется в отдельном блоке сообщений. В примере затем выводится на консоль сообщения, основанный на операцию, которая завершается первой.

[!code-cpp[concrt-choice-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_6.cpp)]

В этом примере получается следующий результат:

```Output
fib35 received its value first. Result = 9227465
```

Так как задача, вычисляющая 35<sup>th</sup> число Фибоначчи не гарантируется, закончит первой, выходные данные этого примера могут различаться.

В этом примере используется [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм для вычисления чисел Фибоначчи в параллельном режиме. Дополнительные сведения о `parallel_invoke`, см. в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

Полный пример, показывающий, как использовать `choice` , представлена в разделе [как: Выбор среди завершенных задач](../../parallel/concrt/how-to-select-among-completed-tasks.md).

[[В начало](#top)]

##  <a name="join"></a> Классы соединения и multitype_join

[Concurrency::join](../../parallel/concrt/reference/join-class.md) и [concurrency::multitype_join](../../parallel/concrt/reference/multitype-join-class.md) классы позволяют ожидать каждый член набора источников для получения сообщения. `join` Класс предназначен для источника объектов, имеющих общий тип сообщений. `multitype_join` Класс предназначен для источника объектов, которые могут иметь разные типы сообщений.

Чтение из `join` или `multitype_join` похоже на вызов функции Windows API `WaitForMultipleObjects` когда `bWaitAll` параметру присвоить `TRUE`. Однако, как `choice` объекта, `join` и `multitype_join` объекты используют механизм событий, который выполняет привязку их данных к событию, а не к внешнему объекту синхронизации.

Чтение из `join` объект создает объект std::[вектор](../../standard-library/vector-class.md) объекта. Чтение из `multitype_join` объект создает объект std::[кортежа](../../standard-library/tuple-class.md) объекта. Элементы отображаются в эти объекты, в том же порядке, как их соответствующих буферов источника связаны с `join` или `multitype_join` объекта. Поскольку порядок, в котором связать источник выполняет буферизацию для `join` или `multitype_join` объект связан с порядком элементов в результирующей `vector` или `tuple` объекта, мы рекомендуем не отсоединять существующий исходный буфер из соединения. Это может привести к непредсказуемому поведению.

### <a name="greedy-versus-non-greedy-joins"></a>"Жадные" и нежадные объединения

`join` И `multitype_join` классы поддерживают концепцию жадный и нежадный соединения. Объект *жадное объединение* принимает сообщения от каждого из своих источников, как только сообщения станут доступными, пока не будут доступны все сообщения. Объект *нежадное объединение* получает сообщения в два этапа. Во-первых нежадное объединение ожидает, пока не предлагается сообщение из каждого из своих источников. Во-вторых после все исходные сообщения доступны, нежадное объединение пытается зарезервировать все эти сообщения. Если он может зарезервировать все сообщения, он потребляет все сообщения и распространяет их по целевым. В противном случае он операционной системы, или отменяет резервирование сообщений и снова ожидает каждый источник для получения сообщения.

Жадное объединение работает лучше, чем нежадные объединения, так как они немедленно принимать сообщения. Тем не менее в редких случаях жадное объединение может привести к взаимоблокировке. Используйте нежадное объединение, если у вас есть несколько соединений, которые содержат один или несколько объектов с общим исходным кодом.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `join` класса. В этом примере используется [concurrency::make_join](reference/concurrency-namespace-functions.md#make_join) функцию для создания `join` , получающий из трех `single_assignment` объектов. Этот пример вычисляет различные числа Фибоначчи, каждый результат сохраняется в другом `single_assignment` объекта, а затем выводит на консоль результатов, `join` содержащиеся в объекте. Этот пример похож на пример для `choice` класса, за исключением случаев, `join` класс ожидает все исходные блоки сообщений для получения сообщения.

[!code-cpp[concrt-join-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_7.cpp)]

В этом примере выводятся следующие данные:

```Output
fib35 = 9227465fib37 = 24157817half_of_fib42 = 1.33957e+008
```

В этом примере используется [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм для вычисления чисел Фибоначчи в параллельном режиме. Дополнительные сведения о `parallel_invoke`, см. в разделе [параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

Полные примеры, показывающие, как использовать `join` , представлена в разделе [как: Выбор среди завершенных задач](../../parallel/concrt/how-to-select-among-completed-tasks.md) и [Пошаговое руководство: Использование класса join для предотвращения взаимоблокировки](../../parallel/concrt/walkthrough-using-join-to-prevent-deadlock.md).

[[В начало](#top)]

##  <a name="timer"></a> Класс Timer

Параллелизм::[класс timer](../../parallel/concrt/reference/timer-class.md) выступает в качестве источника сообщений. Объект `timer` объект отправляет сообщение в целевой объект, по истечении указанного периода времени. `timer` Класс может быть полезен, когда требуется задержать отправку сообщения или вы хотите отправлять сообщение через равные промежутки времени.

`timer` Класс отправляет сообщение только один целевой объект. Если задать `_PTarget` параметра в конструктор для `NULL`, позже можно указать целевой объект, вызвав [concurrency::ISource::link_target](reference/source-block-class.md#link_target) метод.

Объект `timer` может быть повторяющихся или неповторяющихся. Чтобы создать повторяющийся таймер, передайте **true** для `_Repeating` параметра при вызове конструктора. В противном случае передайте **false** для `_Repeating` параметр, чтобы создать неповторяющегося таймера. Если повторяющийся таймер, он отправляет это же сообщение своей цели после каждого интервала.

Библиотека агентов создает `timer` объекты в состоянии-started. Чтобы запустить объект таймера, вызовите [Concurrency::Timer:: Start](reference/timer-class.md#start) метод. Чтобы остановить `timer` объекта, уничтожить объект или вызов [concurrency::timer::stop](reference/timer-class.md#stop) метод. Чтобы приостановить повторяющийся таймер, вызовите [concurrency::timer::pause](reference/timer-class.md#pause) метод.

### <a name="example"></a>Пример

Следующий пример показывает базовую структуру как работать с `timer` класса. В примере используется `timer` и `call` объектов, чтобы сообщить о ходе выполнения длительной операции.

[!code-cpp[concrt-timer-structure#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_8.cpp)]

В этом примере получается следующий результат:

```Output
Computing fib(42)..................................................result is 267914296
```

Полный пример, показывающий, как использовать `timer` , представлена в разделе [как: Отправлять сообщение через равные промежутки времени](../../parallel/concrt/how-to-send-a-message-at-a-regular-interval.md).

[[В начало](#top)]

##  <a name="filtering"></a> Фильтрация сообщений

При создании объекта блока сообщений, можно указать *filter, функция* , определяет, принимает или отклоняет сообщение в блок сообщений. Функции фильтра — это позволяет гарантировать, что блок сообщений получать только определенные значения.

В следующем примере показано, как создать `unbounded_buffer` объект, который использует функцию фильтрации, чтобы принимать только четные числа. `unbounded_buffer` Объект отклоняет нечетных чисел и поэтому не распространяет нечетных чисел его целевым блокам.

[!code-cpp[concrt-filter-function#1](../../parallel/concrt/codesnippet/cpp/asynchronous-message-blocks_9.cpp)]

В этом примере выводятся следующие данные:

```Output
0 2 4 6 8
```

Функции фильтра может быть лямбда-функцию, указатель на функцию или объект функции. Каждая функция filter принимает одно из следующих форм.

```Output
bool (T)
bool (T const &)
```

Чтобы избежать ненужных операций копирования данных, используйте вторую форму при наличии Агрегатный тип, который передается по значению.

Поддержка фильтрации сообщений *потока данных* модель программирования, в котором компоненты выполняют вычисления при получении данных. Примеры использования функций фильтрации для управления потоком данных в сети передачи сообщений, см. в разделе [как: Использовать фильтр блок сообщений](../../parallel/concrt/how-to-use-a-message-block-filter.md), [Пошаговое руководство: Создание агента потоков данных](../../parallel/concrt/walkthrough-creating-a-dataflow-agent.md), и [Пошаговое руководство: Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).

[[В начало](#top)]

##  <a name="reservation"></a> Резервирование сообщений

*Резервирование сообщений* позволяет блоку сообщений зарезервировать сообщение для последующего использования. Как правило резервирование сообщений не используется напрямую. Тем не менее понимание сообщений резервирования, чтобы лучше понять поведение некоторые из предопределенных типов блоков сообщений.

Рассмотрите соединения не "жадными" и "жадные". Они используют резервирование сообщений для резервирования сообщений для последующего использования. Как описано ранее, нежадное объединение получает сообщения в два этапа. Во время первой фазы нежадный `join` объект ожидает от каждого из своих источников, для получения сообщения. Нежадное объединение пытается зарезервировать все эти сообщения. Если он может зарезервировать все сообщения, он потребляет все сообщения и распространяет их по целевым. В противном случае он операционной системы, или отменяет резервирование сообщений и снова ожидает каждый источник для получения сообщения.

Жадное объединение, который также считывает входящие сообщения из нескольких источников, использует резервирование сообщений для чтения дополнительные сообщения, пока ожидается для получения сообщения из каждого источника. Например, рассмотрим жадное объединение, которое получает сообщения из блоков сообщений `A` и `B`. Если жадное объединение получает два сообщения от B, но еще не получил сообщение от `A`, жадное объединение сохраняет уникальный идентификатор сообщения для второе сообщение от `B`. После того как жадное объединение получает сообщение от `A` и распространяет эти сообщения, он использует идентификатор сохраненного сообщения ли второе сообщение от `B` по-прежнему доступна.

Резервирование сообщений можно использовать при реализации собственных типов блоков пользовательское сообщение. Например о том, как создать пользовательский тип блока сообщений, см. в разделе [Пошаговое руководство: Создание пользовательского блока сообщений](../../parallel/concrt/walkthrough-creating-a-custom-message-block.md).

[[В начало](#top)]

## <a name="see-also"></a>См. также

[Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)
