---
title: Общие рекомендации в среде выполнения с параллелизмом
ms.date: 11/04/2016
helpviewer_keywords:
- Concurrency Runtime, general best practices
ms.assetid: ce5c784c-051e-44a6-be84-8b3e1139c18b
ms.openlocfilehash: 15bae5ba25da4987b076cf3de67cd8484fe47df8
ms.sourcegitcommit: a8ef52ff4a4944a1a257bdaba1a3331607fb8d0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77141773"
---
# <a name="general-best-practices-in-the-concurrency-runtime"></a>Общие рекомендации в среде выполнения с параллелизмом

В этом документе описываются рекомендации, применяемые к нескольким областям среда выполнения с параллелизмом.

## <a name="top"></a> Разделы

Этот документ содержит следующие разделы.

- [Использовать конструкции совместной синхронизации по возможности](#synchronization)

- [Избегайте длительных задач, которые не дают](#yield)

- [Использование превышения лимита подписки для сдвига операций, которые блокируют или имеют высокую задержку](#oversubscription)

- [Используйте функции параллельного управления памятью, когда это возможно](#memory)

- [Используйте RAII для управления временем существования объектов параллелизма](#raii)

- [Не создавать объекты параллелизма в глобальной области](#global-scope)

- [Не используйте объекты параллелизма в общих сегментах данных](#shared-data)

## <a name="synchronization"></a>Использовать конструкции совместной синхронизации по возможности

Среда выполнения с параллелизмом предоставляет множество одновременных конструкций, не требующих внешнего объекта синхронизации. Например, класс [Concurrency:: concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) предоставляет одновременные операции добавления и доступа к элементам. В данном случае, безопасность с параллелизмом означает, что указатели или итераторы всегда действительны. Не гарантируется инициализация элементов или определенный порядок обхода. Однако в случаях, когда требуется эксклюзивный доступ к ресурсу, среда выполнения предоставляет классы [Concurrency:: critical_section](../../parallel/concrt/reference/critical-section-class.md), [concurrency:: reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md)и [Concurrency:: Event](../../parallel/concrt/reference/event-class.md) . Эти типы работают совместно. Таким образом, планировщик заданий может перераспределить ресурсы обработки в другой контекст, так как первая задача ожидает данные. По возможности используйте эти типы синхронизации вместо других механизмов синхронизации, например, предоставляемых Windows API, которые не работают совместно. Дополнительные сведения об этих типах синхронизации и пример кода см. в разделе [структуры данных синхронизации](../../parallel/concrt/synchronization-data-structures.md) и [Сравнение структур данных синхронизации с API Windows](../../parallel/concrt/comparing-synchronization-data-structures-to-the-windows-api.md).

[[В начало](#top)]

## <a name="yield"></a>Избегайте длительных задач, которые не дают

Поскольку планировщик заданий работает совместно, он не обеспечивает равноправие между задачами. Таким образом, задача может препятствовать запуску других задач. Хотя это приемлемо в некоторых случаях, в других случаях это может вызвать взаимоблокировку или нехватку ресурсов.

В следующем примере выполняется больше задач, чем количество выделенных вычислительных ресурсов. Первая задача не передается планировщику задач, поэтому вторая задача не запускается до тех пор, пока не завершится первая задача.

[!code-cpp[concrt-cooperative-tasks#1](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_1.cpp)]

В примере получается следующий вывод.

1: 250000000 1: 500000000 1: 750000000 1: 1000000000 2: 250000000 2: 500000000 2: 750000000 2: 1000000000

Существует несколько способов обеспечить совместную работу двух задач. Один из способов — время от времени можно получить планировщик заданий в долгосрочной задаче. В следующем примере функция `task` изменяется для вызова метода [Concurrency:: Context:: Yield](reference/context-class.md#yield) , который позволяет получить выполнение планировщику задач, чтобы можно было запустить другую задачу.

[!code-cpp[concrt-cooperative-tasks#2](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_2.cpp)]

В примере получается следующий вывод.

```Output
1: 250000000
2: 250000000
1: 500000000
2: 500000000
1: 750000000
2: 750000000
1: 1000000000
2: 1000000000
```

Метод `Context::Yield` выдает только другой активный поток в планировщике, к которому относится текущий поток, упрощенная задача или другой поток операционной системы. Этот метод не является результатом работы, запланированной для выполнения в объекте [Concurrency:: task_group](reference/task-group-class.md) или [concurrency:: structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) , но еще не запущен.

Существуют и другие способы обеспечения взаимодействия между долго выполняющимися задачами. Можно разбить большую задачу на более мелкие подзадачи. Можно также включить превышение лимита подписки во время длительной задачи. Превышение лимита подписки позволяет создать больше потоков, чем количество доступных аппаратных потоков. Превышение лимита подписки особенно полезно, если длительная задача содержит большое количество задержек, например чтение данных с диска или подключение к сети. Дополнительные сведения о упрощенных задачах и превышении лимита подписки см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

[[В начало](#top)]

## <a name="oversubscription"></a>Использование превышения лимита подписки для сдвига операций, которые блокируют или имеют высокую задержку

Среда выполнения с параллелизмом предоставляет примитивы синхронизации, такие как [Concurrency:: critical_section](../../parallel/concrt/reference/critical-section-class.md), которые позволяют задачам совместно блокироваться и возвращать друг другу. Когда одна задача совместно блокирует или выдает, планировщик задач может перераспределить ресурсы обработки в другой контекст, так как первая задача ожидает данные.

В некоторых случаях нельзя использовать механизм совместной блокировки, предоставляемый среда выполнения с параллелизмом. Например, используемая внешняя библиотека может использовать другой механизм синхронизации. Другой пример: при выполнении операции, которая может иметь большой объем задержки, например при использовании функции `ReadFile` Windows API для считывания данных из сетевого подключения. В таких случаях превышение лимита подписки может обеспечить выполнение других задач, когда другая задача бездействует. Превышение лимита подписки позволяет создать больше потоков, чем количество доступных аппаратных потоков.

Рассмотрим следующую функцию, `download`, которая скачивает файл по указанному URL-адресу. В этом примере используется метод [Concurrency:: Context:: resubscribe](reference/context-class.md#oversubscribe) для временного увеличения числа активных потоков.

[!code-cpp[concrt-download-oversubscription#4](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_3.cpp)]

Поскольку функция `GetHttpFile` выполняет потенциально скрытую операцию, превышение лимита подписки может обеспечить выполнение других задач, так как текущая задача ожидает данные. Полную версию этого примера см. в разделе [как использовать превышение лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).

[[В начало](#top)]

## <a name="memory"></a>Используйте функции параллельного управления памятью, когда это возможно

Используйте функции управления памятью [Concurrency:: Alloc](reference/concurrency-namespace-functions.md#alloc) и [Concurrency:: Free](reference/concurrency-namespace-functions.md#free), если у вас есть детализированные задачи, которые часто распределяют небольшие объекты с относительно коротким временем существования. Среда выполнения с параллелизмом содержит отдельный кэш памяти для каждого выполняющегося потока. Функции `Alloc` и `Free` выделяют и освобождают память из этих кэшей без использования блокировок или барьеров памяти.

Дополнительные сведения об этих функциях управления памятью см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md). Пример использования этих функций см. в разделе [как использовать Alloc и Free для повышения производительности памяти](../../parallel/concrt/how-to-use-alloc-and-free-to-improve-memory-performance.md).

[[В начало](#top)]

## <a name="raii"></a>Используйте RAII для управления временем существования объектов параллелизма

Среда выполнения с параллелизмом использует обработку исключений для реализации таких функций, как отмена. Поэтому при вызове среды выполнения или вызове другой библиотеки, которая вызывается в среде выполнения, следует писать код, защищенный с помощью исключений.

Шаблон " *получение ресурсов" — Инициализация* (RAII) — это один из способов безопасного управления жизненным циклом объекта параллелизма в заданной области. В шаблоне RAII структура данных выделяется в стеке. Эта структура данных Инициализирует или получает ресурс при его создании, а также уничтожает или освобождает этот ресурс при уничтожении структуры данных. Шаблон RAII гарантирует, что деструктор вызывается до выхода из охватывающей области. Этот шаблон полезен, если функция содержит несколько `return` инструкций. Этот шаблон также помогает написать код, защищенный с помощью исключений. Если инструкция `throw` вызывает очистку стека, вызывается деструктор для объекта RAII; Таким образом, ресурс всегда будет правильно удален или освобожден.

Среда выполнения определяет несколько классов, использующих шаблон RAII, например [Concurrency:: critical_section:: scoped_lock](../../parallel/concrt/reference/critical-section-class.md#critical_section__scoped_lock_class) и [concurrency:: reader_writer_lock:: scoped_lock](reference/reader-writer-lock-class.md#scoped_lock_class). Эти вспомогательные классы известны как *блокировки с областью действия*. Эти классы предоставляют несколько преимуществ при работе с объектами [Concurrency:: critical_section](../../parallel/concrt/reference/critical-section-class.md) или [concurrency:: reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md) . Конструктор этих классов получает доступ к предоставленному `critical_section` или `reader_writer_lock` объекту. Деструктор освобождает доступ к этому объекту. Так как блокировка с областью освобождает доступ к объекту взаимного исключения автоматически при его уничтожении, базовый объект не разблокируется вручную.

Рассмотрим следующий класс `account`, который определяется внешней библиотекой и поэтому не может быть изменен.

[!code-cpp[concrt-account-transactions#1](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_4.h)]

В следующем примере несколько транзакций для объекта `account` выполняется параллельно. В примере используется объект `critical_section` для синхронизации доступа к объекту `account`, так как класс `account` не является типобезопасным. Каждая параллельная операция использует объект `critical_section::scoped_lock`, чтобы гарантировать, что объект `critical_section` разблокируется при успешном или неудачном выполнении операции. Если баланс учетной записи отрицательный, то операция `withdraw` завершается сбоем, вызывая исключение.

[!code-cpp[concrt-account-transactions#2](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_5.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
Balance before deposit: 1924
Balance after deposit: 2924
Balance before withdrawal: 2924
Balance after withdrawal: -76
Balance before withdrawal: -76
Error details:
    negative balance: -76
```

Дополнительные примеры использования шаблона RAII для управления временем существования объектов параллелизма см. в разделе [Пошаговое руководство. Удаление работы из потока пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md), [Практическое руководство. Использование класса Context для реализации параллельного семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)и [Практическое руководство. Использование превышения лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).

[[В начало](#top)]

## <a name="global-scope"></a>Не создавать объекты параллелизма в глобальной области

При создании объекта параллелизма в глобальной области в приложении могут возникнуть такие проблемы, как взаимоблокировка или нарушение прав доступа к памяти.

Например, при создании объекта исполняющей среды с параллелизмом среда создает планировщик по умолчанию, если он еще не создан. Объект среды выполнения, созданный при конструировании глобального объекта, соответственно вызовет то, что среда выполнения создаст этот планировщик по умолчанию. Однако этот процесс принимает внутреннюю блокировку, которая может помешать инициализации других объектов, поддерживающих инфраструктуру исполняющей среды с параллелизмом. Эта внутренняя блокировка может потребоваться другому, еще не инициализированному, объекту инфраструктуры, и поэтому может привести к возникновению взаимоблокировки в приложении.

В следующем примере демонстрируется создание глобального объекта [Concurrency:: Scheduler](../../parallel/concrt/reference/scheduler-class.md) . Эта схема применяется не только к классу `Scheduler`, но и ко всем остальным типам, предоставленным исполняющей средой с параллелизмом. Рекомендуется не использовать эту схему, поскольку она может привести к неожиданному поведению в приложении.

[!code-cpp[concrt-global-scheduler#1](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_6.cpp)]

Примеры правильного создания объектов `Scheduler` см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

[[В начало](#top)]

## <a name="shared-data"></a>Не используйте объекты параллелизма в общих сегментах данных

Среда выполнения с параллелизмом не поддерживает использование объектов параллелизма в разделе общих данных, например раздел данных, созданный директивой [data_seg](../../preprocessor/data-seg.md)`#pragma`. Объект параллелизма, совместно используемый в границах процесса, может перевести среду выполнения в несогласованное или недопустимое состояние.

[[В начало](#top)]

## <a name="see-also"></a>См. также раздел

[Рекомендации по работе со средой выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-best-practices.md)<br/>
[Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md)<br/>
[Библиотека асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)<br/>
[Планировщик заданий](../../parallel/concrt/task-scheduler-concurrency-runtime.md)<br/>
[Структуры данных синхронизации](../../parallel/concrt/synchronization-data-structures.md)<br/>
[Сравнение структур данных синхронизации с интерфейсом Windows API](../../parallel/concrt/comparing-synchronization-data-structures-to-the-windows-api.md)<br/>
[Практическое руководство. Использование функций Alloc и Free для повышения производительности операций с памятью](../../parallel/concrt/how-to-use-alloc-and-free-to-improve-memory-performance.md)<br/>
[Практическое руководство. Использование лимита подписки для устранения задержек](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md)<br/>
[Практическое руководство. Использование класса Context для реализации семафора, поддерживающего параллельный доступ](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)<br/>
[Пошаговое руководство. Удаление задач из потока пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md)<br/>
[Рекомендации по работе с библиотекой параллельных шаблонов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md)<br/>
[Рекомендации по работе с библиотекой асинхронных агентов](../../parallel/concrt/best-practices-in-the-asynchronous-agents-library.md)
