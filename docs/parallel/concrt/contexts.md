---
title: Контексты
ms.date: 11/04/2016
helpviewer_keywords:
- contexts [Concurrency Runtime]
ms.assetid: 10c1d861-8fbb-4ba0-b2ec-61876b11176e
ms.openlocfilehash: 9eaf21a3d65ae891a48657de9d3e7aff78ce12b9
ms.sourcegitcommit: a8ef52ff4a4944a1a257bdaba1a3331607fb8d0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77142186"
---
# <a name="contexts"></a>Контексты

В этом документе описывается роль контекстов в среда выполнения с параллелизмом. Поток, присоединенный к планировщику, называется *контекстом выполнения*или просто *контекстом*. Функция [Concurrency:: wait](reference/concurrency-namespace-functions.md#wait) и класс Concurrency::[context](../../parallel/concrt/reference/context-class.md) позволяют управлять поведением контекстов. Используйте функцию `wait` для приостановки текущего контекста в течение заданного времени. Используйте класс `Context`, если требуется больший контроль над тем, когда контексты блокируются, разблокируются и выдают, или когда требуется переписывать текущий контекст.

> [!TIP]
> Среда выполнения с параллелизмом предоставляет планировщик по умолчанию, и таким образом не требуется создавать планировщик в приложении. Поскольку планировщик задач помогает точно настроить производительность приложений, рекомендуется начать с [библиотеки параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md) или [библиотеки асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md) , если вы не знакомы с среда выполнения с параллелизмом.

## <a name="the-wait-function"></a>Функция wait

Функция [Concurrency:: wait](reference/concurrency-namespace-functions.md#wait) выполняет совместное выполнение текущего контекста в течение указанного числа миллисекунд. Среда выполнения использует время получения для выполнения других задач. По истечении указанного времени среда выполнения перепланирует контекст для выполнения. Таким образом, функция `wait` может приостановить текущий контекст дольше, чем значение, указанное для параметра `milliseconds`.

Передача значения 0 (нуль) для параметра `milliseconds` приводит к тому, что среда выполнения приостанавливает текущий контекст до тех пор, пока всем остальным его активным не будет предоставлена возможность выполнения работы. Это позволяет получить задачу для всех других активных задач.

### <a name="example"></a>Пример

Пример, использующий функцию `wait` для получения текущего контекста и, таким образом, для выполнения других контекстов, см. в разделе [как использовать группы расписаний для влияния на порядок выполнения](../../parallel/concrt/how-to-use-schedule-groups-to-influence-order-of-execution.md).

## <a name="the-context-class"></a>Класс контекста

Класс Concurrency::[context](../../parallel/concrt/reference/context-class.md) обеспечивает абстракцию программирования для контекста выполнения и предлагает две важные функции: возможность совместно блокировать, разблокировать и выдавать текущий контекст, а также возможность переписывать текущий контекст.

### <a name="cooperative-blocking"></a>Совместное блокирование

Класс `Context` позволяет блокировать или выдавать текущий контекст выполнения. Блокировка или передается, если текущий контекст не может продолжить работу, так как ресурс недоступен.

Метод [Concurrency:: Context:: Block](reference/context-class.md#block) блокирует текущий контекст. Заблокированный контекст выдает ресурсы для обработки, чтобы среда выполнения могла выполнять другие задачи. Метод [Concurrency:: Context:: reblock](reference/context-class.md#unblock) разблокирует Заблокированный контекст. Метод `Context::Unblock` должен вызываться из контекста, отличного от того, который вызывал `Context::Block`. Среда выполнения вызывает метод [Concurrency:: context_self_unblock](../../parallel/concrt/reference/context-self-unblock-class.md) , если контекст пытается разблокировать себя.

Для совместного блокирования и разблокировки контекста обычно вызывается [Concurrency:: Context:: CurrentContext](reference/context-class.md#currentcontext) , чтобы получить указатель на объект `Context`, связанный с текущим потоком, и сохранить результат. Затем вызывается метод `Context::Block` для блокировки текущего контекста. Затем вызовите `Context::Unblock` из отдельного контекста, чтобы разблокировать заблокированный контекст.

Необходимо сопоставить каждую пару вызовов с `Context::Block` и `Context::Unblock`. Среда выполнения порождает [Concurrency:: context_unblock_unbalanced](../../parallel/concrt/reference/context-unblock-unbalanced-class.md) , когда метод `Context::Block` или `Context::Unblock` вызывается последовательно без соответствующего вызова другого метода. Однако не нужно вызывать `Context::Block` перед вызовом `Context::Unblock`. Например, если один контекст вызывает `Context::Unblock` до того, как другой контекст вызывает `Context::Block` для того же контекста, этот контекст остается незаблокированным.

Метод [Concurrency:: Context:: Yield](reference/context-class.md#yield) выдает выполнение, чтобы среда выполнения могла выполнять другие задачи, а затем перепланировать контекст для выполнения. При вызове метода `Context::Block` среда выполнения не перепланирует контекст.

#### <a name="example"></a>Пример

Пример использования методов `Context::Block`, `Context::Unblock`и `Context::Yield` для реализации класса семафора с совместным использованием см. в разделе [как использовать класс контекста для реализации параллельного семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md).

##### <a name="oversubscription"></a>Превышение лимита подписки

Планировщик по умолчанию создает то же число потоков, что и доступные аппаратные потоки. *Превышение лимита подписки* можно использовать для создания дополнительных потоков для данного аппаратного потока.

Для ресурсоемких операций превышение лимита подписки обычно не масштабируется, так как в нем реализованы дополнительные издержки. Однако для задач с большим количеством задержек, например считывания данных с диска или с сетевого подключения, превышение лимита подписки может повысить общую эффективность некоторых приложений.

> [!NOTE]
> Разрешать превышение лимита подписки следует только в потоке, созданном средой выполнения с параллелизмом. Превышение лимита подписки не имеет силы при вызове из потока, который не был создан средой выполнения (включая основной поток).

Чтобы включить превышение лимита подписки в текущем контексте, вызовите метод [Concurrency:: Context:: resubscribe](reference/context-class.md#oversubscribe) с параметром `_BeginOversubscription`, для которого установлено значение **true**. При включении превышения лимита подписки для потока, созданного среда выполнения с параллелизмом, среда выполнения создает еще один дополнительный поток. После выполнения всех задач, требующих завершения превышения лимита подписки, вызовите `Context::Oversubscribe` с параметром `_BeginOversubscription`, для которого задано значение **false**.

Превышение лимита подписки можно включить несколько раз из текущего контекста, но необходимо отключить это количество раз, когда она была включена. Превышение лимита подписки также может быть вложенным; Это значит, что задача, созданная другой задачей, использующей превышение лимита подписки, также может быть переподписана ее контекстом. Однако если как вложенная задача, так и ее родитель относятся к одному и тому же контексту, только внешний вызов `Context::Oversubscribe` вызывает создание дополнительного потока.

> [!NOTE]
> Среда выполнения вызывает метод [Concurrency:: invalid_oversubscribe_operation](../../parallel/concrt/reference/invalid-oversubscribe-operation-class.md) , если превышение лимита подписки отключено перед включением.

###### <a name="example"></a>Пример

Пример использования превышения лимита подписки для смещения задержки, вызванной считыванием данных из сетевого подключения, см. [в разделе как использовать превышение лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).

## <a name="see-also"></a>См. также раздел

[Планировщик заданий](../../parallel/concrt/task-scheduler-concurrency-runtime.md)<br/>
[Практическое руководство. Использование групп планирования для определения порядка выполнения](../../parallel/concrt/how-to-use-schedule-groups-to-influence-order-of-execution.md)<br/>
[Практическое руководство. Использование класса Context для реализации семафора, поддерживающего параллельный доступ](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)<br/>
[Практическое руководство. Использование лимита подписки для устранения задержек](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md)
