---
title: ': Многопоточность использование классов синхронизации MFC'
ms.date: 08/27/2018
helpviewer_keywords:
- MFC [C++], multithreading
- threading [MFC], synchronization classes
- resources [C++], multithreading
- thread-safe classes [C++]
- synchronization classes [C++]
- synchronization [C++], multithreading
- threading [MFC], thread-safe class design
- threading [C++], synchronization
- multithreading [C++], synchronization classes
- threading [C++], thread-safe class design
ms.assetid: f266d4c6-0454-4bda-9758-26157ef74cc5
ms.openlocfilehash: 0f8304c3b45f87dadc2317de95a0b30b54baffa0
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50604169"
---
# <a name="multithreading-how-to-use-the-mfc-synchronization-classes"></a>: Многопоточность использование классов синхронизации MFC

Синхронизация доступа к ресурсам между потоками является распространенной проблемой при записи многопоточных приложений. Наличие двух или более потоков, одновременно доступ, и тех же данных может привести к нежелательным и непредсказуемые результаты. Например один поток может обновлять содержимое структуры во время другой поток считывает содержимое с одинаковой структурой. Неизвестно, какие данные будут получать поток чтения: старые данные, данные, записываемые или возможно сочетание обоих. MFC предоставляет ряд синхронизации и классы синхронного доступа для помощи в решении этой проблемы. В этом разделе объясняется, доступные классы и как их использовать для создания потокобезопасные классы обычно многопоточного приложения.

Типичное многопоточное приложение содержит класс, представляющий ресурс для совместного использования потоками. Правильно спроектированное, полностью потокобезопасный класс не требуется вызывать любые функции синхронизации. Все обрабатывается внутри к классу, что позволяет сосредоточиться на том, как наиболее эффективно использовать класс, а не о том, как он может быть поврежден. Метод для создания полностью потокобезопасного класса является объединение класс синхронизации в классе ресурса. Объединение классов синхронизации в общий класс представляет собой простой процесс.

Например рассмотрим приложение, поддерживающее связанный список учетных записей. Это приложение позволяет до трех учетных записей в отдельных окнах, но можно обновить в любой момент времени только один. При обновлении учетной записи, обновленные данные отправляются по сети в архив данных.

В этом примере приложения используются все три типа классов синхронизации. Так как она допускает до трех учетных записей за один раз, он использует [CSemaphore](../mfc/reference/csemaphore-class.md) для ограничения доступа к трем объектам просмотра. При попытке просмотра четвертой учетной записи приложение находится в ожидании одной из первых трех windows закрывает или завершается с ошибкой. При обновлении учетной записи, приложение использует [CCriticalSection](../mfc/reference/ccriticalsection-class.md) чтобы убедиться, что только одна учетная запись обновляется одновременно. После успешного обновления, он сообщает о [CEvent](../mfc/reference/cevent-class.md), который освобождает поток ожидает события. Этот поток отправляет новые данные в архив данных.

##  <a name="_mfc_designing_a_thread.2d.safe_class"></a> Разработка потокобезопасного класса

Чтобы полностью потокобезопасный класс, сначала добавьте соответствующий класс синхронизации для общих классов как члена данных. В предыдущем примере управления учетными записями `CSemaphore` элемент данных будут добавлены в представление класса `CCriticalSection` класс связанного списка, будут добавлены данные-член и `CEvent` элемент данных будут добавлены класс хранения данных.

Затем добавьте вызовы синхронизации для всех функций-членов, которые изменяют данные в классе или получить доступ к контролируемому ресурсу. В каждой функции, необходимо создать [CSingleLock](../mfc/reference/csinglelock-class.md) или [CMultiLock](../mfc/reference/cmultilock-class.md) объекта и вызовите этот объект `Lock` функции. Если уничтожается объект блокировки выходит за пределы области, вызывает деструктор объекта `Unlock` освобождая ресурс. Конечно, вы можете вызвать `Unlock` напрямую, если требуется.

Разработка вашего класса поточно ориентированными, таким образом позволяет использовать в многопоточном приложении так же легко, как класс не являющихся потокобезопасными, но с более высоким уровнем безопасности. Инкапсулировать в классе ресурса объекта синхронизации и объекта синхронизации доступа предоставляет все преимущества полностью потокобезопасный программирования без недостаток поддержания кода синхронизации.

В следующем примере кода демонстрируется этот метод с помощью элемента данных, `m_CritSection` (типа `CCriticalSection`), объявленные в классе общедоступного ресурса и `CSingleLock` объекта. Общего ресурса синхронизации (производный от `CWinThread`) выполняется путем создания `CSingleLock` объекта с помощью адреса `m_CritSection` объекта. Предпринята попытка заблокировать ресурс, и получения задачи выполняются в общий объект. По окончании работы ресурс разблокируется вызовом `Unlock`.

```
CSingleLock singleLock(&m_CritSection);
singleLock.Lock();
// resource locked
//.usage of shared resource...

singleLock.Unlock();
```

> [!NOTE]
> `CCriticalSection`, в отличие от других классов синхронизации MFC, не имеет параметра запроса на блокировку по времени. Период ожидания для освобождения потока является бесконечным.

Недостатком этого подхода является то, что класс будет немного медленнее, чем тот же класс без добавления объектов синхронизации. Кроме того Если есть вероятность того, что только один поток может удалить объект, объединенный подход может не всегда работать. В этом случае лучше поддерживать отдельные объекты синхронизации.

Чтобы узнать, какой класс синхронизации для использования в различных ситуациях, см. в разделе [Многопоточность: использование классов синхронизации](multithreading-when-to-use-the-synchronization-classes.md). Дополнительные сведения о синхронизации см. в разделе [синхронизации](/windows/desktop/Sync/synchronization) в пакете Windows SDK. Дополнительные сведения о поддержке многопоточности в MFC, см. в разделе [многопоточность с помощью C++ и MFC](multithreading-with-cpp-and-mfc.md).

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)