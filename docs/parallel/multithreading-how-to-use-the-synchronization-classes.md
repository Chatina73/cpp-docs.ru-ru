---
description: Дополнительные сведения о многопоточности. Использование классов синхронизации MFC
title: Многопоточность. Использование классов синхронизации MFC
ms.date: 08/27/2018
helpviewer_keywords:
- MFC [C++], multithreading
- threading [MFC], synchronization classes
- resources [C++], multithreading
- thread-safe classes [C++]
- synchronization classes [C++]
- synchronization [C++], multithreading
- threading [MFC], thread-safe class design
- threading [C++], synchronization
- multithreading [C++], synchronization classes
- threading [C++], thread-safe class design
ms.assetid: f266d4c6-0454-4bda-9758-26157ef74cc5
ms.openlocfilehash: a62bdba992ef8b65c14991da26e098f545c30ccd
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97149920"
---
# <a name="multithreading-how-to-use-the-mfc-synchronization-classes"></a>Многопоточность. Использование классов синхронизации MFC

Синхронизация доступа к ресурсам между потоками является распространенной проблемой при написании многопоточных приложений. Наличие двух или более потоков, одновременно обращающихся к одним и тем же данным, может привести к нежелательным и непредсказуемым результатам. Например, один поток может обновлять содержимое структуры, в то время как другой поток считывает содержимое той же структуры. Неизвестно, какие данные получит поток чтения: старые данные, новые записанные данные или, возможно, смесь обоих. MFC предоставляет ряд классов синхронизации и синхронизации, помогающих в решении этой проблемы. В этом разделе объясняются доступные классы и способы их использования для создания потокобезопасных классов в типичном многопоточном приложении.

Типичное многопоточное приложение имеет класс, представляющий ресурс, который будет совместно использоваться потоками. Правильно спроектированный, полностью потокобезопасный класс не требует вызова каких-либо функций синхронизации. Все обрабатывается внутри класса, что позволяет сосредоточиться на том, как лучше использовать класс, а не о том, как он может быть поврежден. Эффективным методом создания полностью потокобезопасного класса является объединение класса синхронизации с классом ресурсов. Объединение классов синхронизации в общий класс — это простой процесс.

В качестве примера возьмем приложение, которое поддерживает связанный список учетных записей. Это приложение позволяет проверять до трех учетных записей в отдельных окнах, но только одно из них может быть Обновлено в определенный момент времени. При обновлении учетной записи обновленные данные передаются по сети в архив данных.

В этом примере приложения используются все три типа классов синхронизации. Так как он позволяет проверять до трех учетных записей одновременно, он использует [ксемафоре](../mfc/reference/csemaphore-class.md) для ограничения доступа к трем объектам представления. При попытке просмотра четвертой учетной записи приложение либо ждет, пока одно из первых трех окон не закроется, либо не завершится ошибкой. При обновлении учетной записи приложение использует [ккритикалсектион](../mfc/reference/ccriticalsection-class.md) , чтобы гарантировать обновление только одной учетной записи за раз. После завершения обновления он сигнализирует [цевент](../mfc/reference/cevent-class.md), освобождая поток, ожидающий сигнала о событии. Этот поток отправляет новые данные в архив данных.

## <a name="designing-a-thread-safe-class"></a><a name="_mfc_designing_a_thread.2d.safe_class"></a> Разработка класса Thread-Safe

Чтобы сделать класс полностью потокобезопасным, сначала добавьте соответствующий класс синхронизации в общие классы в качестве члена данных. В предыдущем примере управления учетной записью в `CSemaphore` класс представления будет добавлен элемент данных, в `CCriticalSection` класс связанного списка будет добавлен элемент данных, а в `CEvent` класс хранения данных будет добавлен элемент данных.

Затем добавьте вызовы синхронизации для всех функций-членов, которые изменяют данные в классе или обращаются к контролируемому ресурсу. В каждой функции следует создать объект [ксинглелокк](../mfc/reference/csinglelock-class.md) или [кмултилокк](../mfc/reference/cmultilock-class.md) и вызвать функцию этого объекта `Lock` . Когда объект блокировки выходит за пределы области и уничтожается, деструктор объекта вызывается `Unlock` , освобождая ресурс. Разумеется, вы можете вызвать `Unlock` напрямую, если хотите.

Разработка потокобезопасного класса позволяет использовать его в многопоточном приложении так же легко, как и не потокобезопасный класс, но с более высоким уровнем безопасности. Инкапсуляция объекта синхронизации и объекта доступа синхронизации в класс ресурса предоставляет все преимущества полностью потокобезопасного программирования без недостатка поддержки кода синхронизации.

В следующем примере кода этот метод демонстрируется с помощью элемента данных `m_CritSection` (типа `CCriticalSection` ), объявленного в классе общего ресурса и `CSingleLock` объекта. Выполняется повторная синхронизация общего ресурса (производного от `CWinThread` ) путем создания `CSingleLock` объекта с использованием адреса `m_CritSection` объекта. Предпринята попытка заблокировать ресурс, и при его получении работа над общим объектом будет выполнена. По завершении работы ресурс разблокируется с помощью вызова `Unlock` .

```cpp
CSingleLock singleLock(&m_CritSection);
singleLock.Lock();
// resource locked
//.usage of shared resource...

singleLock.Unlock();
```

> [!NOTE]
> `CCriticalSection`в отличие от других классов синхронизации MFC не имеет параметра запроса на блокировку по времени. Период ожидания, в течение которого поток станет свободным, бесконечно.

Недостатком этого подхода является то, что класс будет немного медленнее, чем тот же класс без добавления объектов синхронизации. Кроме того, если есть вероятность, что несколько потоков могут удалить объект, объединенный подход может не всегда работать. В этом случае лучше поддерживать отдельные объекты синхронизации.

Сведения о том, как определить, какой класс синхронизации следует использовать в различных ситуациях, см. в разделе [многопоточность. когда следует использовать классы синхронизации](multithreading-when-to-use-the-synchronization-classes.md). Дополнительные сведения о синхронизации см. в разделе [Синхронизация](/windows/win32/Sync/synchronization) в Windows SDK. Дополнительные сведения о поддержке многопоточности в MFC см. в статье [многопоточность в C++ и MFC](multithreading-with-cpp-and-mfc.md).

## <a name="see-also"></a>См. также раздел

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
