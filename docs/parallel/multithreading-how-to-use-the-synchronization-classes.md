---
title: Многопоточность. Использование классов синхронизации MFC
ms.date: 08/27/2018
helpviewer_keywords:
- MFC [C++], multithreading
- threading [MFC], synchronization classes
- resources [C++], multithreading
- thread-safe classes [C++]
- synchronization classes [C++]
- synchronization [C++], multithreading
- threading [MFC], thread-safe class design
- threading [C++], synchronization
- multithreading [C++], synchronization classes
- threading [C++], thread-safe class design
ms.assetid: f266d4c6-0454-4bda-9758-26157ef74cc5
ms.openlocfilehash: 26a059e378edb92f5ff7f4e788ded90678e0c129
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69511868"
---
# <a name="multithreading-how-to-use-the-mfc-synchronization-classes"></a>Многопоточность. Использование классов синхронизации MFC

Синхронизация доступа к ресурсам между потоками является распространенной проблемой при написании многопоточных приложений. Наличие двух или более потоков, одновременно обращающихся к одним и тем же данным, может привести к нежелательным и непредсказуемым результатам. Например, один поток может обновлять содержимое структуры, в то время как другой поток считывает содержимое той же структуры. Неизвестно, какие данные получит поток чтения: старые данные, новые записанные данные или, возможно, смесь обоих. MFC предоставляет ряд классов синхронизации и синхронизации, помогающих в решении этой проблемы. В этом разделе объясняются доступные классы и способы их использования для создания потокобезопасных классов в типичном многопоточном приложении.

Типичное многопоточное приложение имеет класс, представляющий ресурс, который будет совместно использоваться потоками. Правильно спроектированный, полностью потокобезопасный класс не требует вызова каких-либо функций синхронизации. Все обрабатывается внутри класса, что позволяет сосредоточиться на том, как лучше использовать класс, а не о том, как он может быть поврежден. Эффективным методом создания полностью потокобезопасного класса является объединение класса синхронизации с классом ресурсов. Объединение классов синхронизации в общий класс — это простой процесс.

В качестве примера возьмем приложение, которое поддерживает связанный список учетных записей. Это приложение позволяет проверять до трех учетных записей в отдельных окнах, но только одно из них может быть Обновлено в определенный момент времени. При обновлении учетной записи обновленные данные передаются по сети в архив данных.

В этом примере приложения используются все три типа классов синхронизации. Так как он позволяет проверять до трех учетных записей одновременно, он использует [ксемафоре](../mfc/reference/csemaphore-class.md) для ограничения доступа к трем объектам представления. При попытке просмотра четвертой учетной записи приложение либо ждет, пока одно из первых трех окон не закроется, либо не завершится ошибкой. При обновлении учетной записи приложение использует [ккритикалсектион](../mfc/reference/ccriticalsection-class.md) , чтобы гарантировать обновление только одной учетной записи за раз. После завершения обновления он сигнализирует [цевент](../mfc/reference/cevent-class.md), освобождая поток, ожидающий сигнала о событии. Этот поток отправляет новые данные в архив данных.

##  <a name="_mfc_designing_a_thread.2d.safe_class"></a>Проектирование потокобезопасного класса

Чтобы сделать класс полностью потокобезопасным, сначала добавьте соответствующий класс синхронизации в общие классы в качестве члена данных. В предыдущем примере `CSemaphore` управления учетной записью в класс представления будет добавлен элемент данных `CCriticalSection` , в класс связанного `CEvent` списка будет добавлен элемент данных, а в класс хранения данных будет добавлен элемент данных.

Затем добавьте вызовы синхронизации для всех функций-членов, которые изменяют данные в классе или обращаются к контролируемому ресурсу. В каждой функции следует создать объект [ксинглелокк](../mfc/reference/csinglelock-class.md) или [кмултилокк](../mfc/reference/cmultilock-class.md) и вызвать `Lock` функцию этого объекта. Когда объект блокировки выходит за пределы области и уничтожается, деструктор объекта вызывается `Unlock` , освобождая ресурс. Разумеется, вы можете `Unlock` вызвать напрямую, если хотите.

Разработка потокобезопасного класса позволяет использовать его в многопоточном приложении так же легко, как и не потокобезопасный класс, но с более высоким уровнем безопасности. Инкапсуляция объекта синхронизации и объекта доступа синхронизации в класс ресурса предоставляет все преимущества полностью потокобезопасного программирования без недостатка поддержки кода синхронизации.

В следующем примере кода этот метод демонстрируется с помощью элемента `m_CritSection` данных (типа `CCriticalSection`), объявленного в классе `CSingleLock` общего ресурса и объекта. Выполняется повторная синхронизация общего ресурса (производного `CWinThread`от) путем `CSingleLock` создания объекта `m_CritSection` с использованием адреса объекта. Предпринята попытка заблокировать ресурс, и при его получении работа над общим объектом будет выполнена. По завершении работы ресурс разблокируется с помощью вызова `Unlock`.

```
CSingleLock singleLock(&m_CritSection);
singleLock.Lock();
// resource locked
//.usage of shared resource...

singleLock.Unlock();
```

> [!NOTE]
> `CCriticalSection`в отличие от других классов синхронизации MFC не имеет параметра запроса на блокировку по времени. Период ожидания, в течение которого поток станет свободным, бесконечно.

Недостатком этого подхода является то, что класс будет немного медленнее, чем тот же класс без добавления объектов синхронизации. Кроме того, если есть вероятность, что несколько потоков могут удалить объект, объединенный подход может не всегда работать. В этом случае лучше поддерживать отдельные объекты синхронизации.

Сведения о том, как определить, какой класс синхронизации следует использовать в различных [ситуациях, см. в разделе Многопоточность. Когда следует использовать классы](multithreading-when-to-use-the-synchronization-classes.md)синхронизации. Дополнительные сведения о синхронизации см. в разделе [Синхронизация](/windows/win32/Sync/synchronization) в Windows SDK. Дополнительные сведения о поддержке многопоточности в MFC см. в статье [Многопоточное использование с C++ и MFC](multithreading-with-cpp-and-mfc.md).

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
