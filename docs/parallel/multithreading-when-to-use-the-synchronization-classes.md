---
title: 'Реализация многопоточности на языке: Использование классов синхронизации MFC'
ms.date: 08/27/2018
helpviewer_keywords:
- threading [MFC], synchronization classes
- resources [C++], multithreading
- synchronization classes [C++]
- synchronization [C++], multithreading
- controlled resource access [C++]
- synchronization access classes [C++]
- threading [C++], synchronization
- multithreading [C++], synchronization classes
ms.assetid: 4914f54e-68ac-438f-93c9-c013455a657e
ms.openlocfilehash: 72cf5310704c1ae959cc012146a03dd32cff4068
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62407657"
---
# <a name="multithreading-when-to-use-the-mfc-synchronization-classes"></a>Реализация многопоточности на языке: Использование классов синхронизации MFC

Многопоточные классы, предоставляемые MFC делятся на две категории: объекты синхронизации ([CSyncObject](../mfc/reference/csyncobject-class.md), [CSemaphore](../mfc/reference/csemaphore-class.md), [CMutex](../mfc/reference/cmutex-class.md), [ CCriticalSection](../mfc/reference/ccriticalsection-class.md), и [CEvent](../mfc/reference/cevent-class.md)) и синхронизации доступ к объектам ([CMultiLock](../mfc/reference/cmultilock-class.md) и [CSingleLock](../mfc/reference/csinglelock-class.md)).

Классы синхронизации используются в том случае, когда необходимо контролировать доступ к ресурсу для обеспечения целостности ресурса. Классы синхронного доступа используются для получения доступа к этим ресурсам управляемой. В этом разделе приводится описание использования каждого класса.

Чтобы определить, какой класс синхронизации, следует использовать, ответьте на следующие вопросы:

1. Приложение нужно ждать, что-то произошло. Прежде чем он может получить доступ к ресурсу (например, данные должны быть получены из COM-портом перед его записью в файл)?

   Если Да, используйте `CEvent`.

2. Можно более одного потока в те же права доступа приложения этого ресурса за один раз (например, приложение позволяет windows до 5 с представлениями в том же документе)?

   Если Да, используйте `CSemaphore`.

3. Более одного приложения можно использовать этот ресурс (например, ресурс находится в библиотеке DLL)?

   Если Да, используйте `CMutex`.

   Если нет, используйте `CCriticalSection`.

`CSyncObject` никогда не используется напрямую. Это базовый класс для других четырех классов синхронизации.

## <a name="example-1-using-three-synchronization-classes"></a>Пример 1: С помощью трех классов синхронизации

Например рассмотрим приложение, поддерживающее связанный список учетных записей. Это приложение позволяет до трех учетных записей в отдельных окнах, но можно обновить в любой момент времени только один. При обновлении учетной записи, обновленные данные отправляются по сети в архив данных.

В этом примере приложения используются все три типа классов синхронизации. Так как она допускает до трех учетных записей за один раз, он использует `CSemaphore` для ограничения доступа к трем объектам просмотра. При попытке просмотра четвертой учетной записи приложение находится в ожидании одной из первых трех windows закрывает или завершается с ошибкой. При обновлении учетной записи, приложение использует `CCriticalSection` чтобы убедиться, что только одна учетная запись обновляется одновременно. После успешного обновления, он сообщает о `CEvent`, который освобождает поток ожидает события. Этот поток отправляет новые данные в архив данных.

## <a name="example-2-using-synchronization-access-classes"></a>Пример 2: С помощью классов доступа к синхронизации

Выбор используемого класса доступа синхронизации использовать еще проще. Если приложение отвечает за доступ к только один управляемый ресурс, используйте `CSingleLock`. Если ему требуется доступ к одному из нескольких управляемых ресурсов, используйте `CMultiLock`. В примере 1 `CSingleLock` будет использоваться, так как в каждом конкретном случае требуется только один ресурс в любой момент времени.

Сведения об использовании классов синхронизации, см. в разделе [Многопоточность: Практическое использование классов синхронизации](multithreading-how-to-use-the-synchronization-classes.md). Сведения о синхронизации см. в разделе [синхронизации](/windows/desktop/Sync/synchronization) в пакете Windows SDK. Сведения о поддержке многопоточности в MFC, см. в разделе [многопоточность с помощью C++ и MFC](multithreading-with-cpp-and-mfc.md).

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
