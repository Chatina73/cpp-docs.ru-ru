---
title: Многопоточность. Когда следует использовать классы синхронизации MFC
ms.date: 08/27/2018
helpviewer_keywords:
- threading [MFC], synchronization classes
- resources [C++], multithreading
- synchronization classes [C++]
- synchronization [C++], multithreading
- controlled resource access [C++]
- synchronization access classes [C++]
- threading [C++], synchronization
- multithreading [C++], synchronization classes
ms.assetid: 4914f54e-68ac-438f-93c9-c013455a657e
ms.openlocfilehash: cb68487e036093ce4718c39c18c9d1e75afe0f7c
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69511998"
---
# <a name="multithreading-when-to-use-the-mfc-synchronization-classes"></a>Многопоточность. Когда следует использовать классы синхронизации MFC

Многопоточные классы, предоставляемые MFC, делятся на две категории: объекты синхронизации ([ксинкобжект](../mfc/reference/csyncobject-class.md), [ксемафоре](../mfc/reference/csemaphore-class.md), [кмутекс](../mfc/reference/cmutex-class.md), [ккритикалсектион](../mfc/reference/ccriticalsection-class.md)и [цевент](../mfc/reference/cevent-class.md)) и объекты доступа к синхронизации ([ Кмултилокк](../mfc/reference/cmultilock-class.md) и [ксинглелокк](../mfc/reference/csinglelock-class.md)).

Классы синхронизации используются, когда доступ к ресурсу должен контролироваться для обеспечения целостности ресурса. Классы доступа к синхронизации используются для получения доступа к этим контролируемым ресурсам. В этом разделе описывается, когда следует использовать каждый класс.

Чтобы определить, какой класс синхронизации следует использовать, задайте следующие серии вопросов:

1. Должно ли приложение ожидать чего-либо, прежде чем он сможет получить доступ к ресурсу (например, данные должны быть получены с порта связи, прежде чем его можно будет записать в файл)?

   Если да, используйте `CEvent`.

2. Может ли несколько потоков в одном приложении одновременно обращаться к этому ресурсу (например, приложение позволяет использовать до пяти окон с представлениями в одном и том же документе)?

   Если да, используйте `CSemaphore`.

3. Может ли более одного приложения использовать этот ресурс (например, ресурс находится в библиотеке DLL)?

   Если да, используйте `CMutex`.

   Если нет, используйте `CCriticalSection`.

`CSyncObject`никогда не используется напрямую. Это базовый класс для четырех остальных классов синхронизации.

## <a name="example-1-using-three-synchronization-classes"></a>Пример 1: Использование трех классов синхронизации

В качестве примера возьмем приложение, которое поддерживает связанный список учетных записей. Это приложение позволяет проверять до трех учетных записей в отдельных окнах, но только одно из них может быть Обновлено в определенный момент времени. При обновлении учетной записи обновленные данные передаются по сети в архив данных.

В этом примере приложения используются все три типа классов синхронизации. Так как он позволяет проверять до трех учетных записей одновременно, он использует `CSemaphore` для ограничения доступа к трем объектам представления. При попытке просмотра четвертой учетной записи приложение либо ждет, пока одно из первых трех окон не закроется, либо не завершится ошибкой. При обновлении учетной записи приложение использует `CCriticalSection` , чтобы гарантировать обновление только одной учетной записи за раз. После завершения обновления он сигнализирует `CEvent`, что освобождает поток, ожидающий сигнала о событии. Этот поток отправляет новые данные в архив данных.

## <a name="example-2-using-synchronization-access-classes"></a>Пример 2 Использование классов для доступа к синхронизации

Выбор используемого класса доступа к синхронизации еще проще. Если приложение имеет дело с доступом только к одному управляемому ресурсу, `CSingleLock`используйте. Если требуется доступ к какому-либо из нескольких управляемых ресурсов, используйте `CMultiLock`. В примере 1 `CSingleLock` было бы использовано, так как в каждом конкретном время требуется только один ресурс.

Дополнительные сведения об использовании классов синхронизации см. в разделе [многопоточность. Использование классов](multithreading-how-to-use-the-synchronization-classes.md)синхронизации. Сведения о синхронизации см. в разделе [Синхронизация](/windows/win32/Sync/synchronization) в Windows SDK. Дополнительные сведения о поддержке многопоточности в MFC см. в статье [Многопоточное использование C++ с и MFC](multithreading-with-cpp-and-mfc.md).

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
