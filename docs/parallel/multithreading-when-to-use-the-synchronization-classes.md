---
description: 'Дополнительные сведения о многопоточности: использование классов синхронизации MFC'
title: Многопоточность. когда следует использовать классы синхронизации MFC
ms.date: 08/27/2018
helpviewer_keywords:
- threading [MFC], synchronization classes
- resources [C++], multithreading
- synchronization classes [C++]
- synchronization [C++], multithreading
- controlled resource access [C++]
- synchronization access classes [C++]
- threading [C++], synchronization
- multithreading [C++], synchronization classes
ms.assetid: 4914f54e-68ac-438f-93c9-c013455a657e
ms.openlocfilehash: 02776bc61ed702ee81ce0f7373dd442a9fc3d446
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97149855"
---
# <a name="multithreading-when-to-use-the-mfc-synchronization-classes"></a>Многопоточность. когда следует использовать классы синхронизации MFC

Многопоточные классы, предоставляемые MFC, делятся на две категории: объекты синхронизации ([ксинкобжект](../mfc/reference/csyncobject-class.md), [ксемафоре](../mfc/reference/csemaphore-class.md), [кмутекс](../mfc/reference/cmutex-class.md), [ккритикалсектион](../mfc/reference/ccriticalsection-class.md)и [цевент](../mfc/reference/cevent-class.md)) и объекты доступа к синхронизации ([кмултилокк](../mfc/reference/cmultilock-class.md) и [ксинглелокк](../mfc/reference/csinglelock-class.md)).

Классы синхронизации используются, когда доступ к ресурсу должен контролироваться для обеспечения целостности ресурса. Классы доступа к синхронизации используются для получения доступа к этим контролируемым ресурсам. В этом разделе описывается, когда следует использовать каждый класс.

Чтобы определить, какой класс синхронизации следует использовать, задайте следующие серии вопросов:

1. Должно ли приложение ожидать чего-либо, прежде чем он сможет получить доступ к ресурсу (например, данные должны быть получены с порта связи, прежде чем его можно будет записать в файл)?

   Если да, используйте `CEvent` .

2. Может ли несколько потоков в одном приложении одновременно обращаться к этому ресурсу (например, приложение позволяет использовать до пяти окон с представлениями в одном и том же документе)?

   Если да, используйте `CSemaphore` .

3. Может ли более одного приложения использовать этот ресурс (например, ресурс находится в библиотеке DLL)?

   Если да, используйте `CMutex` .

   Если нет, используйте `CCriticalSection` .

`CSyncObject` никогда не используется напрямую. Это базовый класс для четырех остальных классов синхронизации.

## <a name="example-1-using-three-synchronization-classes"></a>Пример 1. использование трех классов синхронизации

В качестве примера возьмем приложение, которое поддерживает связанный список учетных записей. Это приложение позволяет проверять до трех учетных записей в отдельных окнах, но только одно из них может быть Обновлено в определенный момент времени. При обновлении учетной записи обновленные данные передаются по сети в архив данных.

В этом примере приложения используются все три типа классов синхронизации. Так как он позволяет проверять до трех учетных записей одновременно, он использует `CSemaphore` для ограничения доступа к трем объектам представления. При попытке просмотра четвертой учетной записи приложение либо ждет, пока одно из первых трех окон не закроется, либо не завершится ошибкой. При обновлении учетной записи приложение использует, `CCriticalSection` чтобы гарантировать обновление только одной учетной записи за раз. После завершения обновления он сигнализирует `CEvent` , что освобождает поток, ожидающий сигнала о событии. Этот поток отправляет новые данные в архив данных.

## <a name="example-2-using-synchronization-access-classes"></a>Пример 2. Использование классов для доступа к синхронизации

Выбор используемого класса доступа к синхронизации еще проще. Если приложение имеет дело с доступом только к одному управляемому ресурсу, используйте `CSingleLock` . Если требуется доступ к какому-либо из нескольких управляемых ресурсов, используйте `CMultiLock` . В примере 1 было `CSingleLock` бы использовано, так как в каждом конкретном время требуется только один ресурс.

Дополнительные сведения об использовании классов синхронизации см. в разделе [многопоточность. Использование классов синхронизации](multithreading-how-to-use-the-synchronization-classes.md). Сведения о синхронизации см. в разделе [Синхронизация](/windows/win32/Sync/synchronization) в Windows SDK. Сведения о поддержке многопоточности в MFC см. в статье [многопоточность в C++ и MFC](multithreading-with-cpp-and-mfc.md).

## <a name="see-also"></a>См. также раздел

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
