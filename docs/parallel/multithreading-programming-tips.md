---
title: Многопоточность. Советы по программированию MFC
ms.date: 08/27/2018
helpviewer_keywords:
- multithreading [C++], programming tips
- handle maps [C++]
- access control [C++], multithreading
- objects [C++], multiple threads and
- non-MFC threads [C++]
- threading [MFC], programming tips
- critical sections [C++]
- synchronization [C++], multithreading
- programming [C++], multithreaded
- communications [C++], between threads
- threading [C++], best practices
- troubleshooting [C++], multithreading
- Windows handle maps [C++]
ms.assetid: ad14cc70-c91c-4c24-942f-13a75e58bf8a
ms.openlocfilehash: 79e7d440b478c759c5d4fd683d6af3423e7e8661
ms.sourcegitcommit: a8ef52ff4a4944a1a257bdaba1a3331607fb8d0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77140449"
---
# <a name="multithreading-mfc-programming-tips"></a>Многопоточность. Советы по программированию MFC

Многопоточные приложения нуждаются в более тщательной работе, чем в многопоточных приложениях, чтобы гарантировать, что операции выполняются в нужном порядке, а все данные, к которым обращается несколько потоков, не повреждены. В этом разделе рассматриваются методы предотвращения потенциальных проблем при программировании многопоточных приложений с помощью библиотеки Microsoft Foundation Class (MFC).

- [Доступ к объектам из нескольких потоков](#_core_accessing_objects_from_multiple_threads)

- [Доступ к объектам MFC из потоков, отличных от MFC](#_core_accessing_mfc_objects_from_non.2d.mfc_threads)

- [Карты Windows Handle](#_core_windows_handle_maps)

- [Обмен данными между потоками](#_core_communicating_between_threads)

## <a name="_core_accessing_objects_from_multiple_threads"></a>Доступ к объектам из нескольких потоков

Объекты MFC не являются потокобезопасными. Два отдельных потока не могут манипулировать одним и тем же объектом, если не используются классы синхронизации MFC и (или) соответствующие объекты синхронизации Win32, такие как критические разделы. Дополнительные сведения о критических разделах и других связанных объектах см. в разделе [Синхронизация](/windows/win32/Sync/synchronization) в Windows SDK.

Библиотека классов использует критически важные разделы для защиты глобальных структур данных, например тех, которые используются при выделении памяти для отладки.

## <a name="_core_accessing_mfc_objects_from_non.2d.mfc_threads"></a>Доступ к объектам MFC из потоков, отличных от MFC

При наличии многопоточного приложения, создающего поток способом, отличным от использования объекта [CWinThread](../mfc/reference/cwinthread-class.md) , доступ к другим объектам MFC из этого потока будет невозможен. Иными словами, если требуется получить доступ к любому объекту MFC из вторичного потока, необходимо создать этот поток с одним из методов, описанных в разделе [многопоточность: создание потоков пользовательского интерфейса](multithreading-creating-user-interface-threads.md) или [многопоточность: создание рабочих потоков](multithreading-creating-worker-threads.md). Это единственные методы, позволяющие библиотеке классов инициализировать внутренние переменные, необходимые для обработки многопоточных приложений.

## <a name="_core_windows_handle_maps"></a>Карты Windows Handle

Как правило, поток может получить доступ только к созданным им объектам MFC. Это связано с тем, что временные и постоянные карты обработки Windows хранятся в локальном хранилище потоков для обеспечения защиты от одновременного доступа из нескольких потоков. Например, Рабочий поток не может выполнить вычисление, а затем вызвать функцию-член `UpdateAllViews` документа, чтобы иметь окна, содержащие представления для новых измененных данных. Это не влияет на все, так как Map из `CWnd` объектов в HWND является локальным для основного потока. Это означает, что один поток может иметь сопоставление из обработчика Windows с C++ объектом, но другой поток может сопоставить этот же обработчик с другим C++ объектом. Изменения, внесенные в одном потоке, не будут отражаться в другом.

Существует несколько способов решения этой проблемы. Первый заключается в передаче отдельных дескрипторов (например, HWND), а не C++ объектов в рабочий поток. Затем рабочий поток добавляет эти объекты к временной карте, вызывая соответствующую функцию члена `FromHandle`. Можно также добавить объект в постоянную карту потока, вызвав `Attach`, но это следует делать только в том случае, если гарантируется, что объект будет существовать дольше, чем поток.

Другой способ заключается в создании новых определяемых пользователем сообщений, соответствующих различным задачам, которые будут выполняться рабочими потоками, и публикации этих сообщений в главном окне приложения с помощью `::PostMessage`. Этот метод связи аналогичен двум различным приложениям, за исключением того, что оба потока выполняются в одном адресном пространстве.

Дополнительные сведения о картах маркеров см. в [техническом примечании 3](../mfc/tn003-mapping-of-windows-handles-to-objects.md). Дополнительные сведения о локальном хранилище потоков см. в разделе [локальная память](/windows/win32/ProcThread/thread-local-storage) потока и [использование локального хранилища потока](/windows/win32/ProcThread/using-thread-local-storage) в Windows SDK.

## <a name="_core_communicating_between_threads"></a>Обмен данными между потоками

MFC предоставляет ряд классов, которые позволяют потокам синхронизировать доступ к объектам для поддержания потокобезопасности. Использование этих классов описывается в разделе [многопоточность: использование классов синхронизации](multithreading-how-to-use-the-synchronization-classes.md) и [многопоточность. когда следует использовать классы синхронизации](multithreading-when-to-use-the-synchronization-classes.md). Дополнительные сведения об этих объектах см. в разделе [Синхронизация](/windows/win32/Sync/synchronization) в Windows SDK.

## <a name="see-also"></a>См. также раздел

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
