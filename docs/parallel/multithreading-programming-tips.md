---
title: 'Реализация многопоточности на языке: Советы по программированию MFC'
ms.date: 08/27/2018
helpviewer_keywords:
- multithreading [C++], programming tips
- handle maps [C++]
- access control [C++], multithreading
- objects [C++], multiple threads and
- non-MFC threads [C++]
- threading [MFC], programming tips
- critical sections [C++]
- synchronization [C++], multithreading
- programming [C++], multithreaded
- communications [C++], between threads
- threading [C++], best practices
- troubleshooting [C++], multithreading
- Windows handle maps [C++]
ms.assetid: ad14cc70-c91c-4c24-942f-13a75e58bf8a
ms.openlocfilehash: e89d0d534638f7216f142bc3f86633a59b8b0ff7
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2019
ms.locfileid: "57290808"
---
# <a name="multithreading-mfc-programming-tips"></a>Реализация многопоточности на языке: Советы по программированию MFC

Многопоточные приложения требуют больше внимания, чем однопоточные приложения, чтобы убедиться, что операции выполняются в последовательности и любые данные, к которому обращаются несколько потоков не поврежден. В этом разделе описаны способы предотвращения потенциальных проблем, при программировании многопоточных приложений с помощью библиотеки Microsoft Foundation Class (MFC).

- [Доступ к объектам из нескольких потоков](#_core_accessing_objects_from_multiple_threads)

- [Доступ к объектам MFC из потоков не являющихся MFC](#_core_accessing_mfc_objects_from_non.2d.mfc_threads)

- [Дескриптор карты Windows](#_core_windows_handle_maps)

- [Взаимодействие между потоками](#_core_communicating_between_threads)

##  <a name="_core_accessing_objects_from_multiple_threads"></a> Доступ к объектам из нескольких потоков

MFC-объекты не являются поточно ориентированными сами по себе. Два отдельных потока не может управлять тот же объект, если вы не используете классов MFC синхронизации и/или соответствующих объектов синхронизации Win32, таких как критические секции. Дополнительные сведения о критических секциях и других связанных объектов, см. в разделе [синхронизации](/windows/desktop/Sync/synchronization) в пакете Windows SDK.

Библиотека классов использует критические секции для защиты глобальные структуры данных, таких как выделение памяти отладки.

##  <a name="_core_accessing_mfc_objects_from_non.2d.mfc_threads"></a> Доступ к объектам MFC из потоков не являющихся MFC

Если у вас есть многопоточного приложения, которое создает поток не с помощью с [CWinThread](../mfc/reference/cwinthread-class.md) объекта, воспользоваться другими объектами MFC из этого потока. Другими словами, если вы хотите получить доступ к любому объекту MFC из второго потока, необходимо создать этот поток с одним из методов, описанных в [Многопоточность: Создание потоков пользовательского интерфейса](multithreading-creating-user-interface-threads.md) или [многопоточности: Создание рабочих потоков](multithreading-creating-worker-threads.md). Эти методы являются единственными, позволяющие библиотеке классов для инициализации внутренних переменных, необходимых для многопоточных приложений.

##  <a name="_core_windows_handle_maps"></a> Дескриптор карты Windows

Как правило поток может получить доступ к только объектов MFC, созданные им. Это обусловлено временных и постоянных maps дескриптор Windows, хранятся в локальном хранилище потока в целях обеспечения защиты от одновременного доступа нескольких потоков. Например, рабочий поток не производят вычисление и затем вызвать документа `UpdateAllViews` функцию-член для окон, которые содержат новые измененные данные. Это не влияет, так как сопоставление от `CWnd` объектов HWND является локальным для основного потока. Это означает, что один поток может иметь сопоставление из дескриптора Windows для объекта C++, но другой поток может сопоставить тот же дескриптор другому объекту C++. Изменения, внесенные в одном потоке не будут отражаться в другом.

Существует несколько способов решения проблемы. Первый — для передачи отдельных дескрипторов (HWND) вместо того, чтобы объекты C++ на рабочий поток. Рабочий поток затем добавит эти объекты во временное сопоставление, вызывая соответствующий `FromHandle` функция-член. Можно также добавить объект постоянное сопоставление потока путем вызова `Attach`, но это следует делать только в том случае, если гарантируется, что объект будет существовать дольше, чем поток.

Другой метод заключается в создании новых определяемых пользователем сообщений, соответствующих различным задачам рабочих потоков будет и помещают эти сообщения в главное окно приложения с помощью `::PostMessage`. Данный метод взаимодействия аналогична два разных приложения, обменивающиеся данными, за исключением того, что оба потока выполняются в том же адресном пространстве.

Дополнительные сведения о сопоставлении дескрипторов см. в разделе [технические Примечание 3](../mfc/tn003-mapping-of-windows-handles-to-objects.md). Дополнительные сведения о локальной памяти потока, см. в разделе [локальное хранилище потока](/windows/desktop/ProcThread/thread-local-storage) и [с помощью локального хранилища потока](/windows/desktop/ProcThread/using-thread-local-storage) в пакете Windows SDK.

##  <a name="_core_communicating_between_threads"></a> Взаимодействие между потоками

MFC предоставляет ряд классов, которые позволяют потокам синхронизировать доступ к объектам, для обеспечения безопасности потока. Описывается использование этих классов в [Многопоточность: Практическое использование классов синхронизации](multithreading-how-to-use-the-synchronization-classes.md) и [многопоточности: Использование классов синхронизации](multithreading-when-to-use-the-synchronization-classes.md). Дополнительные сведения об этих объектах см. в разделе [синхронизации](/windows/desktop/Sync/synchronization) в пакете Windows SDK.

## <a name="see-also"></a>См. также

[Реализация многопоточности на языке C++ с помощью классов MFC](multithreading-with-cpp-and-mfc.md)
