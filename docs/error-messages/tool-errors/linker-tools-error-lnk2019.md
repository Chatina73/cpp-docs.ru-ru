---
title: Ошибка средств компоновщика LNK2019
ms.date: 12/15/2017
f1_keywords:
- LNK2019
helpviewer_keywords:
- nochkclr.obj
- LNK2019
- _check_commonlanguageruntime_version
ms.openlocfilehash: 0ef0bfd565b8c76816cc1f8a20b1521da238cdfc
ms.sourcegitcommit: 7d64c5f226f925642a25e07498567df8bebb00d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/08/2019
ms.locfileid: "65447708"
---
# <a name="linker-tools-error-lnk2019"></a>Ошибка средств компоновщика LNK2019

неразрешенный внешний символ "*символ*«referenced in function»*функция*"

Законченный код для *функция* делает ссылки или вызов *символ*, но это символ не определен ни в одной библиотеки или объектные файлы, указанные в компоновщик.

Это сообщение об ошибке сопровождается Неустранимая ошибка [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md). Необходимо устранить ошибки все LNK2001 и LNK2019, чтобы устранить ошибку LNK1120.

## <a name="possible-causes"></a>Возможные причины

Существует много способов, чтобы получить эту ошибку, но все они включают в себя ссылку на функцию или переменную, компоновщик не поддерживает *устранить*, или найти определение для. Компилятор может определить, когда символ не *объявлен*, но не когда это не *определенные*, так как определение может быть в другом файле исходного кода или в библиотеке. Если символ имеется ссылка, но никогда не определяется, компоновщик создает ошибку неразрешенный внешний символ.

Ниже приведены некоторые распространенные проблемы, вызывающие ошибку LNK2019.

### <a name="the-object-file-or-library-that-contains-the-definition-of-the-symbol-is-not-linked"></a>Не связан файл объекта или библиотеки, который содержит определение символа

В Visual Studio убедитесь, что исходный файл, содержащий определение построения и связать как часть проекта. В командной строке убедитесь, что исходный файл, содержащий определение компилируется, и что итоговый объектный файл включен в список файлов для связывания.

### <a name="the-declaration-of-the-symbol-is-not-spelled-the-same-as-the-definition-of-the-symbol"></a>Объявления символа указано так же, как определение символа

Проверьте правильное написание и регистр букв используется в объявлении и определении и везде, где используется или именем символа.

### <a name="a-function-is-used-but-the-type-or-number-of-the-parameters-do-not-match-the-function-definition"></a>Используется функция, но тип или количество параметров не соответствует определению функции

Объявление функции должно соответствовать определению. Убедитесь в том, что вызов функции совпадает с объявлением, а объявление совпадает с определением. Код, который вызывает функции шаблона, также должен иметь совпадающие объявления функции шаблона, включающие те же параметры шаблона, что и определение. Пример несоответствия объявление шаблона см. в разделе Пример LNK2019e.cpp в подразделе «примеры».

### <a name="a-function-or-variable-is-declared-but-not-defined"></a>Функция или переменная объявлена, но не определен

Это обычно означает объявление существует в файле заголовка, но отсутствует соответствующее определение реализуется. Для функций-членов и статических элементов данных реализация должна содержать селектор области класса. Пример см. в разделе [Missing Function Body or Variable](../../error-messages/tool-errors/missing-function-body-or-variable.md).

### <a name="the-calling-convention-is-different-between-the-function-declaration-and-the-function-definition"></a>Соглашение о вызове отличается от соглашения в объявлении и определении функции

Соглашения о вызовах ([__cdecl](../../cpp/cdecl.md), [__stdcall](../../cpp/stdcall.md), [__fastcall](../../cpp/fastcall.md)или [__vectorcall](../../cpp/vectorcall.md)) кодируются в составе декорированного имени. Убедитесь в том, что соглашение о вызовах одно и то же.

### <a name="a-symbol-is-defined-in-a-c-file-but-declared-without-using-extern-c-in-a-c-file"></a>Символ определен в файле C, но объявлен без использования модификатора extern «C» в файле C++

Декорированные имена символов, определенные в файле, который компилируется как C, будут отличаться от имен символов, объявленных в файле C++, до тех пор, пока не будет использоваться модификатор [extern "C"](../../cpp/using-extern-to-specify-linkage.md) . Убедитесь в том, что объявление соответствует компоновке компиляции для каждого символа. Аналогично, если символ определяется в файле C++, который будет использоваться программой C, в определении следует использовать `extern "C"` .

### <a name="a-symbol-is-defined-as-static-and-then-later-referenced-outside-the-file"></a>Символ определяется как статический и затем используется за пределами файла

В C++, в отличие от C, [глобальные константы](../../error-messages/tool-errors/global-constants-in-cpp.md) имеют компоновку `static` . Чтобы обойти это ограничение, можно включить инициализации `const` в заголовок файла и ввести этот заголовок в CPP-файлы или можно присвоить переменной неконстантное значение и использовать для доступа к ней константную ссылку.

### <a name="a-static-member-of-a-class-is-not-defined"></a>Не определен статический член класса

Статический член класса должен иметь уникальное определение. В противном случае он будет нарушать правило одного определения. Статический член класса, который не может быть определен как встроенный, должен быть определен в одном исходном файле с помощью его полного имени. Если он не определен вообще, компоновщик создает ошибку LNK2019.

### <a name="a-build-dependency-is-only-defined-as-a-project-dependency-in-the-solution"></a>Зависимость сборки определена только как зависимость проекта в решении

В более ранних версиях Visual Studio этого уровня зависимости было достаточно. Тем не менее, начиная с Visual Studio 2010, Visual Studio требуется [ссылки проекта на проект](/visualstudio/ide/managing-references-in-a-project). Если в проекте отсутствует ссылка на другой проект, может возникнуть эта ошибка компоновщика. Чтобы устранить ошибку, добавьте ссылку одного проекта на другой.

### <a name="you-build-a-console-application-by-using-settings-for-a-windows-application"></a>Создание консольного приложения с использованием параметров для приложения Windows

Если сообщение об ошибке аналогично **неразрешенный внешний символ WinMain referenced в функции** *имя_функции*, компоновку с помощью **/SUBSYSTEM: Console** вместо **/SUBSYSTEM: Windows**. Дополнительные сведения об этом параметре и инструкции о том, как задать это свойство в Visual Studio, см. в статье [/SUBSYSTEM (Specify Subsystem)](../../build/reference/subsystem-specify-subsystem.md).

### <a name="you-attempt-to-link-64-bit-libraries-to-32-bit-code-or-32-bit-libraries-to-64-bit-code"></a>При попытке привязывать 64-разрядной библиотеки на 32-разрядного кода, или 32-разрядной библиотеки для 64-разрядного кода

Библиотеки и файлы объектов, чтобы ваш код должен быть скомпилирован для ту же архитектуру, что ваш код. Убедитесь, что ссылки проекта компилируются на ту же архитектуру, что и проект библиотеки. Убедитесь, что [/LIBPATH](../../build/reference/libpath-additional-libpath.md) или **Дополнительные каталоги библиотек** параметр пути, используемые точками компоновщика для библиотек, разработанных для обеспечения правильной архитектуры.

### <a name="you-use-different-compiler-options-for-function-inlining-in-different-source-files"></a>Для встраивания функции в различные исходные файлы используются разные параметры компилятора

Использование встроенных функций, определенных в CPP-файлах, и смешение в различных исходных файлах параметров компилятора для встраивания функций может привести к возникновению ошибки LNK2019. Для получения дополнительной информации см. [Function Inlining Problems](../../error-messages/tool-errors/function-inlining-problems.md).

### <a name="you-use-automatic-variables-outside-their-scope"></a>Автоматические переменные используются за пределами их области видимости

Автоматические переменные (области видимости функции) могут использоваться только в области видимости данной функции. Эти переменные не могут объявляться `extern` и использоваться в других исходных файлах. Пример см. в разделе [Automatic (Function Scope) Variables](../../error-messages/tool-errors/automatic-function-scope-variables.md).

### <a name="you-call-instrinsic-functions-or-pass-argument-types-to-intrinsic-functions-that-are-not-supported-on-your-target-architecture"></a>Выполняется вызов встроенных функций или передача типов аргументов встроенные функции, которые не поддерживаются в целевой архитектуре

Например, если используется встроенная функция AVX2, но не указан параметр компилятора [/ARCH:AVX2](../../build/reference/arch-x86.md) , компилятор предполагает, что встроенная функция является внешней. Вместо создания встроенной инструкции компилятор создает вызов внешнего символа с тем же именем, что и у встроенного. Когда компоновщик пытается найти определение этой отсутствующей функции, он создает ошибку LNK2019. Убедитесь в том, что используются только встроенные функции и типы, поддерживаемые целевой архитектурой.

### <a name="you-mix-code-that-uses-native-wchart-with-code-that-doesnt"></a>Код, который использует собственный wchar смешан\_t с кодом, который не

C++язык по согласованию, выполненной в Visual Studio 2005, привели `wchar_t` собственный тип по умолчанию. Необходимо использовать [/Zc:wchar_t-](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md) параметр компилятора для создания кода, совместимого с файлами библиотек и объектов, скомпилированными с помощью более ранних версиях Visual Studio. Если не все файлы были скомпилированы с использованием тех же **/Zc:wchar\_t** параметры, тип ссылки не может разрешить в совместимые типы. Убедитесь в том, что типы `wchar_t` во всех файлах библиотек и объектов являются совместимыми. Для этого обновите используемые типы или используйте согласованные параметры **/Zc:wchar_t** при компиляции.

## <a name="third-party-library-issues-and-vcpkg"></a>Проблемы стороннюю библиотеку и Vcpkg

Если вы видите эту ошибку при попытке настроить стороннюю библиотеку как часть сборки, рассмотрите возможность использования [Vcpkg](../../vcpkg.md), диспетчер пакетов C++ Visual, чтобы установить и выполнить сборку библиотеки. Vcpkg поддерживает большого и постоянно растущего [список библиотек сторонних](https://github.com/Microsoft/vcpkg/tree/master/ports)и задает все свойства конфигурации и зависимости, необходимые для успешной сборки как часть проекта. Дополнительные сведения см. в разделе связанных [блог о Visual C++](https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/) блога.

## <a name="diagnosis-tools"></a>Средства диагностики

Выяснение причин, по которым компоновщику не удается найти определение конкретного символа, может оказаться трудной задачей. Часто проблема заключается в том, что код, который содержит определение сборки, не включены или сборки, параметры, которые создали различные декорированные имена для внешних символов. Существует несколько средств и параметров, которые помогут диагностировать ошибку LNK2019.

- С помощью параметра компоновщика [/VERBOSE](../../build/reference/verbose-print-progress-messages.md) можно определить, на какие файлы ссылается компоновщик. Это поможет проверить, включен ли файл, содержащий определения символа, в сборку.

- [/EXPORTS](../../build/reference/dash-exports.md) и [/SYMBOLS](../../build/reference/symbols.md) параметры **DUMPBIN** программы помогут вам узнать, какие символы определены в файлах DLL и объекта или библиотеки. Убедитесь в том, что экспортированные декорированные имена совпадают со ссылками, которые ищет компоновщик.

- **UNDNAME** служебная программа может показывать эквивалентный недекорированный внешний символ для декорированного имени.

## <a name="examples"></a>Примеры

Далее приводится несколько примеров кода, вызывающего ошибку LNK2019, а также сведения о том, как устранить ошибку.

### <a name="a-symbol-is-declared-but-not-defined"></a>Символ объявлен, но не определен

В этом примере Внешняя переменная объявлена, но не определен:

```cpp
// LNK2019.cpp
// Compile by using: cl /EHsc /W4 LNK2019.cpp
// LNK2019 expected
extern char B[100];   // B is not available to the linker
int main() {
   B[0] = ' ';   // LNK2019
}
```

Вот еще один пример, где переменных и функций объявляются как `extern` , но определение не предоставляется:

```cpp
// LNK2019c.cpp
// Compile by using: cl /EHsc LNK2019c.cpp
// LNK2019 expected
extern int i;
extern void g();
void f() {
   i++;
   g();
}
int main() {}
```

Если не `i` и `g` определяются в одном из файлов, включенных в построение, компоновщик создает ошибку LNK2019. Чтобы исправить ошибки, включите файл исходного кода, который содержит определения, в процесс компиляции. Кроме того можно передать OBJ- или LIB-файлы, содержащие определения в компоновщик.

### <a name="a-static-data-member-is-declared-but-not-defined"></a>Статические данные-член объявлены, но не определены

Ошибка LNK2019 также может возникнуть в том случае, если статические данные-член объявлены, но не определены. В следующем примере показано возникновение ошибки LNK2019 и приводятся сведения по ее устранению.

```cpp
// LNK2019b.cpp
// Compile by using: cl /EHsc LNK2019b.cpp
// LNK2019 expected
struct C {
   static int s;
};

// Uncomment the following line to fix the error.
// int C::s;

int main() {
   C c;
   C::s = 1;
}
```

### <a name="declaration-parameters-do-not-match-definition"></a>Параметры объявления не совпадают с определением

Код, который вызывает функции шаблона, должен иметь совпадающие объявления функции шаблона. Объявления должны содержать те же параметры шаблона, что и определение. В следующем примере показано возникновение ошибки LNK2019 для определяемого пользователем оператора и приводятся сведения по ее устранению.

```cpp
// LNK2019e.cpp
// compile by using: cl /EHsc LNK2019e.cpp
// LNK2019 expected
#include <iostream>
using namespace std;

template<class T> class
Test {
   // The operator<< declaration does not match the definition below:
   friend ostream& operator<<(ostream&, Test&);
   // To fix, replace the line above with the following:
   // template<typename T> friend ostream& operator<<(ostream&, Test<T>&);
};

template<typename T>
ostream& operator<<(ostream& os, Test<T>& tt) {
   return os;
}

int main() {
   Test<int> t;
   cout << "Test: " << t << endl;   // LNK2019 unresolved external
}
```

### <a name="inconsistent-wchart-type-definitions"></a>Несогласованные определения типа wchar_t

Этот пример создает библиотеки DLL с экспортом, использующим `WCHAR`, который разрешается в `wchar_t`.

```cpp
// LNK2019g.cpp
// compile with: cl /EHsc /LD LNK2019g.cpp
#include "windows.h"
// WCHAR resolves to wchar_t
__declspec(dllexport) void func(WCHAR*) {}
```

Следующий пример использует библиотеку DLL в предыдущем примере и создает ошибку LNK2019, поскольку неподписанные типы short * и WCHAR\* не совпадают.

```cpp
// LNK2019h.cpp
// compile by using: cl /EHsc LNK2019h LNK2019g.lib
// LNK2019 expected
__declspec(dllimport) void func(unsigned short*);

int main() {
   func(0);
}
```

Чтобы устранить эту ошибку, измените `unsigned short` для `wchar_t` или `WCHAR`, или выполните компиляцию с помощью LNK2019g.cpp **/Zc:wchar_t-**.

## <a name="additional-resources"></a>Дополнительные ресурсы

Дополнительные сведения о возможных причинах проблем и решениях для LNK2001, см. в разделе по вопросу переполнения стека [что представляет ошибка неопределенной ссылки или неразрешенного внешнего символа и как ее устранить?](http://stackoverflow.com/q/12573816/2002113).

