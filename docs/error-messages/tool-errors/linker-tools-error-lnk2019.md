---
title: Ошибка средств компоновщика LNK2019
description: Все сведения об ошибке компоновщика Microsoft Visual Studio LNK2019 и об их диагностике и исправлении в коде C и C++.
ms.date: 01/15/2020
f1_keywords:
- LNK2019
helpviewer_keywords:
- nochkclr.obj
- LNK2019
- _check_commonlanguageruntime_version
no-loc:
- main
- WinMain
- wmain
- wWinMain
- __cdecl
- __stdcall
- __fastcall
- __vectorcall
- extern
- static
- const
- ARCH
- AVX2
- wchar_t
- VERBOSE
- EXPORTS
- SYMBOLS
- DUMPBIN
- UNDNAME
ms.openlocfilehash: d09e232b934761d138fee7324c462c915d919959
ms.sourcegitcommit: a1676bf6caae05ecd698f26ed80c08828722b237
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2020
ms.locfileid: "91509743"
---
# <a name="linker-tools-error-lnk2019"></a>Ошибка средств компоновщика LNK2019

> неразрешенный extern символ Al "*symbol*", на который ссылается функция "*функция*"

Скомпилированный код *функции* создает ссылку или вызов *символа*, но компоновщик не может найти определение символа в любой из библиотек или объектных файлов для связи.

Это сообщение об ошибке после неустранимой ошибки [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md). Чтобы устранить ошибку LNK1120, необходимо сначала устранить все ошибки LNK2001 и LNK2019.

## <a name="possible-causes"></a>Возможные причины

Существует множество способов получения этой ошибки. Все они используют ссылку на функцию или переменную, которую компоновщику не удалось *Разрешить*, или найти определение для. Компилятор может определить, когда символ не *объявлен*, но не может определить, не *определен*ли символ. Это связано с тем, что определение может находиться в другом исходном файле или библиотеке. Если символ упоминается, но не определен, компоновщик создает неразрешенную extern ошибку символа Al.

Ниже приведены некоторые распространенные проблемы, вызывающие ошибку LNK2019.

### <a name="the-source-file-that-contains-the-definition-of-the-symbol-isnt-compiled"></a>Исходный файл, содержащий определение символа, не скомпилирован

В Visual Studio убедитесь, что исходный файл, определяющий символ, компилируется как часть проекта. Проверьте промежуточный каталог выходных данных сборки на наличие соответствующего OBJ-файла. Если исходный файл не компилируется, щелкните его правой кнопкой мыши в обозреватель решений и выберите пункт **Свойства** , чтобы проверить свойства файла. На странице **Свойства конфигурации**  >  **Общие** должен отображаться **тип элемента** **компилятора C/C++**. В командной строке убедитесь, что исходный файл, содержащий определение, скомпилирован.

### <a name="the-object-file-or-library-that-contains-the-definition-of-the-symbol-isnt-linked"></a>Объектный файл или библиотека, содержащие определение символа, не связаны

Убедитесь, что в Visual Studio объектный файл или библиотека, содержащие определение символа, связаны как часть проекта. В командной строке убедитесь, что список файлов для связывания содержит объектный файл или библиотеку.

### <a name="the-declaration-of-the-symbol-isnt-spelled-the-same-as-the-definition-of-the-symbol"></a>Объявление символа написано не так, как определение символа

Проверьте правильность написания и регистра символов в объявлении и определении, а также в любом месте, где используется или вызывается символ.

### <a name="a-function-is-used-but-the-type-or-number-of-the-parameters-dont-match-the-function-definition"></a>Используется функция, но тип или число параметров не соответствуют определению функции

Объявление функции должно соответствовать определению. Убедитесь, что вызов функции соответствует объявлению и что объявление соответствует определению. Код, который вызывает функции шаблона, также должен иметь совпадающие объявления функции шаблона, включающие те же параметры шаблона, что и определение. Пример несоответствия объявления шаблона см. в разделе Sample LNK2019e. cpp статьи "примеры".

### <a name="a-function-or-variable-is-declared-but-not-defined"></a>Функция или переменная объявлена, но не определена

Ошибка LNK2019 может возникать, если объявление существует в файле заголовка, но соответствующее определение не реализовано. Для функций элементов или static элементов данных реализация должна включать селектор области класса. Пример см. в разделе [Missing Function Body or Variable](../../error-messages/tool-errors/missing-function-body-or-variable.md).

### <a name="the-calling-convention-is-different-between-the-function-declaration-and-the-function-definition"></a>Соглашение о вызовах отличается между объявлением функции и определением функции.

Соглашения о вызовах ( [__cdecl](../../cpp/cdecl.md) , [__stdcall](../../cpp/stdcall.md) , [__fastcall](../../cpp/fastcall.md) или [__vectorcall](../../cpp/vectorcall.md) ) кодируются как часть декорированного имени. Убедитесь, что соглашение о вызовах одинаково.

### <a name="a-symbol-is-defined-in-a-c-file-but-declared-without-using-no-locextern-c-in-a-c-file"></a>Символ определен в файле C, но объявлен без использования extern "C" в файле C++

Символы, определенные в файле, который компилируется как C, имеют разные декорированные имена, чем символы, объявленные в файле C++, если не используется модификатор [ extern "C"](../../cpp/extern-cpp.md) . Убедитесь, что объявление соответствует компоновке компиляции для каждого символа. Аналогично, если символ определяется в файле C++, который будет использоваться программой C, в определении следует использовать `extern "C"` .

### <a name="a-symbol-is-defined-as-no-locstatic-and-then-later-referenced-outside-the-file"></a>Символ определяется как static , а затем на него указывает ссылка за пределами файла

В C++, в отличие от C, [Глобальная const Ants](../../error-messages/tool-errors/global-constants-in-cpp.md) имеет **`static`** компоновку. Чтобы обойти это ограничение, можно включить **`const`** инициализацию в файл заголовка и включить этот заголовок в cpp-файлы. Кроме того, можно сделать переменную const Ant и использовать const ссылку Ant для доступа к ней.

### <a name="a-no-locstatic-member-of-a-class-isnt-defined"></a>staticЧлен класса не определен

staticЧлен класса должен иметь уникальное определение или будет нарушать правило одного определения. staticЧлен класса, который не может быть определен как встроенный, должен быть определен в одном исходном файле с помощью его полного имени. Если он не определен вообще, компоновщик создает ошибку LNK2019.

### <a name="a-build-dependency-is-only-defined-as-a-project-dependency-in-the-solution"></a>Зависимость сборки определяется только в качестве зависимости проекта в решении

В более ранних версиях Visual Studio было достаточно этого уровня зависимостей. Однако начиная с Visual Studio 2010 для Visual Studio требуется [ссылка между](/visualstudio/ide/managing-references-in-a-project)проектами. Если в проекте нет ссылки проекта на проект, может возникнуть Эта ошибка компоновщика. Чтобы устранить ошибку, добавьте ссылку одного проекта на другой.

### <a name="an-entry-point-isnt-defined"></a>Точка входа не определена

Код приложения должен определять соответствующую точку входа: `main` или `wmain` для консольных приложений, `WinMain` или `wWinMain` для приложений Windows. Дополнительные сведения см. в разделе [ main функция и аргументы командной строки](../../cpp/main-function-command-line-args.md) или [ WinMain функция](/windows/win32/api/winbase/nf-winbase-winmain). Чтобы использовать настраиваемую точку входа, укажите параметр компоновщика [/Entry (символ точки входа)](../../build/reference/entry-entry-point-symbol.md) .

### <a name="you-build-a-console-application-by-using-settings-for-a-windows-application"></a>Построение консольного приложения с помощью параметров для приложения Windows

Если сообщение об ошибке похоже на **неразрешенный extern символ Al, WinMain указанный в функции** *function_name*, СВЯЖИТЕ с помощью параметра **/SUBSYSTEM: Console** вместо **/SUBSYSTEM: Windows**. Дополнительные сведения об этом параметре и инструкции о том, как задать это свойство в Visual Studio, см. в статье [/SUBSYSTEM (Specify Subsystem)](../../build/reference/subsystem-specify-subsystem.md).

### <a name="you-attempt-to-link-64-bit-libraries-to-32-bit-code-or-32-bit-libraries-to-64-bit-code"></a>Вы пытаетесь связать 64-разрядные библиотеки с 32-битным кодом или 32-bit Library в 64-разрядный код.

Библиотеки и объектные файлы, связанные с вашим кодом, должны быть скомпилированы для той же архитектуры, что и код. Убедитесь, что библиотеки, на которые ссылается проект, компилируются для той же архитектуры, что и проект. Убедитесь, что свойство [/libpath](../../build/reference/libpath-additional-libpath.md) или **Дополнительные каталоги библиотек** указывает на библиотеки, созданные для правильной архитектуры.

### <a name="you-use-different-compiler-options-for-function-inlining-in-different-source-files"></a>Для встраивания функций в разные исходные файлы используются различные параметры компилятора

Использование встроенных функций, определенных в CPP-файлах, и смешение в различных исходных файлах параметров компилятора для встраивания функций может привести к возникновению ошибки LNK2019. Для получения дополнительной информации см. [Function Inlining Problems](../../error-messages/tool-errors/function-inlining-problems.md).

### <a name="you-use-automatic-variables-outside-their-scope"></a>Автоматические переменные используются вне области действия

Автоматические переменные (области видимости функции) могут использоваться только в области видимости данной функции. Эти переменные нельзя объявлять **`extern`** и использовать в других исходных файлах. Пример см. в разделе [Automatic (Function Scope) Variables](../../error-messages/tool-errors/automatic-function-scope-variables.md).

### <a name="you-call-intrinsic-functions-or-pass-argument-types-to-intrinsic-functions-that-arent-supported-on-your-target-architecture"></a>Вы вызываете встроенные функции или передайте типы аргументов в встроенные функции, которые не поддерживаются в целевой архитектуре.

Например, если вы используете AVX2 встроенную функцию, но не указываете параметр компилятора [ / ARCH : AVX2 ](../../build/reference/arch-x86.md) , компилятор предполагает, что встроенная функция является extern функцией Al. Вместо создания встроенной инструкции компилятор создает вызов extern символа Al с тем же именем, что и встроенная инструкция. Когда компоновщик пытается найти определение этой отсутствующей функции, он создает ошибку LNK2019. Убедитесь, что используются только встроенные функции и типы, поддерживаемые целевой архитектурой.

### <a name="you-mix-code-that-uses-native-no-locwchar_t-with-code-that-doesnt"></a>Вы занимаетесь смешением кода, который использует собственный wchar_t код с кодом, который не

Действия по согласованности языка C++, выполненные в Visual Studio 2005, сделали **`wchar_t`** собственный тип по умолчанию. Если не все файлы были скомпилированы с использованием одних и тех же параметров **/Zc: wchar_t ** , ссылки типа могут не разрешаться в совместимые типы. Убедитесь **`wchar_t`** , что типы во всех файлах библиотек и объектов совместимы. Либо обновите из **`wchar_t`** определения типа, либо используйте соответствующие параметры **/Zc: wchar_t ** при компиляции.

## <a name="third-party-library-issues-and-vcpkg"></a>Проблемы с библиотекой сторонних производителей и vcpkg

Если вы видите эту ошибку при попытке настроить библиотеку стороннего производителя в рамках сборки, рассмотрите возможность использования [vcpkg](../../build/vcpkg.md), диспетчера пакетов C++ для установки и сборки библиотеки. vcpkg поддерживает большой и растущей [список библиотек сторонних производителей](https://github.com/Microsoft/vcpkg/tree/master/ports). Он задает все свойства конфигурации и зависимости, необходимые для успешной сборки в рамках проекта.

## <a name="diagnosis-tools"></a>Средства диагностики

Иногда трудно определить, почему компоновщику не удается найти определенное определение символа. Часто проблема заключается в том, что в сборку не включен код, содержащий определение. Или же параметры сборки создали разные декорированные имена для extern символов Al. Существует несколько средств и параметров, которые могут помочь в диагностике ошибок LNK2019.

- С помощью [/VERBOSE](../../build/reference/verbose-print-progress-messages.md) параметра компоновщика можно определить, на какие файлы ссылается компоновщик. С помощью этого параметра можно проверить, включен ли в сборку файл, содержащий определение символа.

- [/EXPORTS](../../build/reference/dash-exports.md)Параметры и [/SYMBOLS](../../build/reference/symbols.md) **DUMPBIN** программы позволяют определить, какие символы определены в библиотеке DLL, а также в файлах объектов или библиотек. Убедитесь, что экспортированные декорированные имена соответствуют декорированным именам, которые ищет компоновщик.

- **UNDNAME** Программа может отобразить эквивалентный недекорированный extern символ Al для декорированного имени.

## <a name="examples"></a>Примеры

Далее приводится несколько примеров кода, вызывающего ошибку LNK2019, а также сведения о том, как устранить ошибку.

### <a name="a-symbol-is-declared-but-not-defined"></a>Символ объявлен, но не определен

В этом примере extern переменная Al объявлена, но не определена:

```cpp
// LNK2019.cpp
// Compile by using: cl /EHsc /W4 LNK2019.cpp
// LNK2019 expected
extern char B[100];   // B isn't available to the linker
int main() {
   B[0] = ' ';   // LNK2019
}
```

Ниже приведен еще один пример, где переменная и функция объявляются как, **`extern`** но определение не предоставляется:

```cpp
// LNK2019c.cpp
// Compile by using: cl /EHsc LNK2019c.cpp
// LNK2019 expected
extern int i;
extern void g();
void f() {
   i++;
   g();
}
int main() {}
```

Если `i` и не `g` определены в одном из файлов, входящих в сборку, компоновщик создает ошибку LNK2019. Чтобы исправить ошибки, включите файл исходного кода, который содержит определения, в процесс компиляции. Кроме того, можно передать OBJ-файлы или LIB-файлы, содержащие определения, в компоновщик.

### <a name="a-no-locstatic-data-member-is-declared-but-not-defined"></a>staticЭлемент данных объявлен, но не определен

Ошибка LNK2019 также может возникать, если static элемент данных объявлен, но не определен. В следующем примере показано возникновение ошибки LNK2019 и приводятся сведения по ее устранению.

```cpp
// LNK2019b.cpp
// Compile by using: cl /EHsc LNK2019b.cpp
// LNK2019 expected
struct C {
   static int s;
};

// Uncomment the following line to fix the error.
// int C::s;

int main() {
   C c;
   C::s = 1;
}
```

### <a name="declaration-parameters-dont-match-the-definition"></a>Параметры объявления не соответствуют определению

Код, который вызывает функции шаблона, должен иметь совпадающие объявления функции шаблона. Объявления должны содержать те же параметры шаблона, что и определение. В следующем примере показано возникновение ошибки LNK2019 для определяемого пользователем оператора и приводятся сведения по ее устранению.

```cpp
// LNK2019e.cpp
// compile by using: cl /EHsc LNK2019e.cpp
// LNK2019 expected
#include <iostream>
using namespace std;

template<class T> class
Test {
   // The operator<< declaration doesn't match the definition below:
   friend ostream& operator<<(ostream&, Test&);
   // To fix, replace the line above with the following:
   // template<typename T> friend ostream& operator<<(ostream&, Test<T>&);
};

template<typename T>
ostream& operator<<(ostream& os, Test<T>& tt) {
   return os;
}

int main() {
   Test<int> t;
   cout << "Test: " << t << endl;   // LNK2019 unresolved external
}
```

### <a name="inconsistent-no-locwchar_t-type-definitions"></a>Непротиворечивые wchar_t определения типов

В этом примере создается библиотека DLL с экспортом, который `WCHAR` разрешается в **`wchar_t`** .

```cpp
// LNK2019g.cpp
// compile with: cl /EHsc /LD LNK2019g.cpp
#include "windows.h"
// WCHAR resolves to wchar_t
__declspec(dllexport) void func(WCHAR*) {}
```

В следующем примере используется библиотека DLL из предыдущего примера и создается LNK2019, так как типы `unsigned short*` и `WCHAR*` не совпадают.

```cpp
// LNK2019h.cpp
// compile by using: cl /EHsc LNK2019h LNK2019g.lib
// LNK2019 expected
__declspec(dllimport) void func(unsigned short*);

int main() {
   func(0);
}
```

Чтобы устранить эту ошибку, измените **`unsigned short`** значение на **`wchar_t`** или `WCHAR` или скомпилируйте LNK2019g. cpp с помощью **/Zc: wchar_t - **.

## <a name="additional-resources"></a>Дополнительные ресурсы

Дополнительные сведения о возможных причинах и решениях ошибки LNK2001 см. в Stack Overflow вопросе, [что является неопределенной ссылкой или неразрешенной extern ошибкой символа Al и как ее исправить?](https://stackoverflow.com/q/12573816/2002113).
