---
title: Ошибка средств компоновщика LNK2019
description: Все сведения об ошибке компоновщика Microsoft Visual Studio LNK2019 и об их диагностике и исправлении в C++ C и коде.
ms.date: 01/15/2020
f1_keywords:
- LNK2019
helpviewer_keywords:
- nochkclr.obj
- LNK2019
- _check_commonlanguageruntime_version
no-loc:
- main
- WinMain
- wmain
- wWinMain
- __cdecl
- __stdcall
- __fastcall
- __vectorcall
- extern
- static
- const
- ARCH
- AVX2
- wchar_t
- VERBOSE
- EXPORTS
- SYMBOLS
- DUMPBIN
- UNDNAME
ms.openlocfilehash: 0e741c1442f9762c4cf5f9b891c4cd7c38103dfe
ms.sourcegitcommit: e93f3e6a110fe38bc642055bdf4785e620d4220f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/16/2020
ms.locfileid: "76123920"
---
# <a name="linker-tools-error-lnk2019"></a>Ошибка средств компоновщика LNK2019

> неразрешенный внешний символ "*symbol*", на который указывает ссылка в функции "*функция*"

Скомпилированный код *функции* создает ссылку или вызов *символа*, но компоновщик не может найти определение символа в любой из библиотек или объектных файлов для связи.

Это сообщение об ошибке после неустранимой ошибки [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md). Чтобы устранить ошибку LNK1120, необходимо сначала устранить все ошибки LNK2001 и LNK2019.

## <a name="possible-causes"></a>Возможные причины

Существует множество способов получения этой ошибки. Все они используют ссылку на функцию или переменную, которую компоновщику не удалось *Разрешить*, или найти определение для. Компилятор может определить, когда символ не *объявлен*, но не может определить, не *определен*ли символ. Это связано с тем, что определение может находиться в другом исходном файле или библиотеке. Если символ упоминается, но не определен, компоновщик создает ошибку неразрешенного внешнего символа.

Ниже приведены некоторые распространенные проблемы, вызывающие ошибку LNK2019.

### <a name="the-source-file-that-contains-the-definition-of-the-symbol-isnt-compiled"></a>Исходный файл, содержащий определение символа, не скомпилирован

В Visual Studio убедитесь, что исходный файл, определяющий символ, компилируется как часть проекта. Проверьте промежуточный каталог выходных данных сборки на наличие соответствующего OBJ-файла. Если исходный файл не компилируется, щелкните его правой кнопкой мыши в обозреватель решений и выберите пункт **Свойства** , чтобы проверить свойства файла. На странице " **Свойства конфигурации** > " **Общие** "должен отображаться **тип элемента** **CC++ /Compiler**. В командной строке убедитесь, что исходный файл, содержащий определение, скомпилирован.

### <a name="the-object-file-or-library-that-contains-the-definition-of-the-symbol-isnt-linked"></a>Объектный файл или библиотека, содержащие определение символа, не связаны

Убедитесь, что в Visual Studio объектный файл или библиотека, содержащие определение символа, связаны как часть проекта. В командной строке убедитесь, что список файлов для связывания содержит объектный файл или библиотеку.

### <a name="the-declaration-of-the-symbol-isnt-spelled-the-same-as-the-definition-of-the-symbol"></a>Объявление символа написано не так, как определение символа

Проверьте правильность написания и регистра символов в объявлении и определении, а также в любом месте, где используется или вызывается символ.

### <a name="a-function-is-used-but-the-type-or-number-of-the-parameters-dont-match-the-function-definition"></a>Используется функция, но тип или число параметров не соответствуют определению функции

Объявление функции должно соответствовать определению. Убедитесь, что вызов функции соответствует объявлению и что объявление соответствует определению. Код, который вызывает функции шаблона, также должен иметь совпадающие объявления функции шаблона, включающие те же параметры шаблона, что и определение. Пример несоответствия объявления шаблона см. в разделе Sample LNK2019e. cpp статьи "примеры".

### <a name="a-function-or-variable-is-declared-but-not-defined"></a>Функция или переменная объявлена, но не определена

Ошибка LNK2019 может возникать, если объявление существует в файле заголовка, но соответствующее определение не реализовано. Для функций элементов или элементов данных static реализация должна включать селектор области класса. Пример см. в разделе [Missing Function Body or Variable](../../error-messages/tool-errors/missing-function-body-or-variable.md).

### <a name="the-calling-convention-is-different-between-the-function-declaration-and-the-function-definition"></a>Соглашение о вызовах отличается между объявлением функции и определением функции.

Соглашения о вызовах ([__cdecl](../../cpp/cdecl.md), [__stdcall](../../cpp/stdcall.md), [__fastcall](../../cpp/fastcall.md)или [__vectorcall](../../cpp/vectorcall.md)) кодируются как часть декорированного имени. Убедитесь, что соглашение о вызовах одинаково.

### <a name="a-symbol-is-defined-in-a-c-file-but-declared-without-using-opno-locextern-c-in-a-c-file"></a>Символ определен в файле C, но объявлен без использования extern "C" в C++ файле

Символы, определенные в файле, который компилируется как C, имеют разные декорированные имена, чем C++ символы, объявленные в файле, если не используется модификатор [extern "C"](../../cpp/using-extern-to-specify-linkage.md) . Убедитесь, что объявление соответствует компоновке компиляции для каждого символа. Аналогично, если символ определяется в файле C++, который будет использоваться программой C, в определении следует использовать `extern "C"` .

### <a name="a-symbol-is-defined-as-opno-locstatic-and-then-later-referenced-outside-the-file"></a>Символ определяется как static, а затем на него указывает ссылка за пределами файла

В C++, в отличие от C, [глобальные константы](../../error-messages/tool-errors/global-constants-in-cpp.md) имеют компоновку `static` . Чтобы обойти это ограничение, можно включить инициализации `const` в заголовок файла и ввести этот заголовок в CPP-файлы или можно присвоить переменной неконстантное значение и использовать для доступа к ней константную ссылку.

### <a name="a-opno-locstatic-member-of-a-class-isnt-defined"></a>Элемент static класса не определен

Член класса static должен иметь уникальное определение или будет нарушать правило одного определения. Член класса static, который не может быть определен как встроенный, должен быть определен в одном исходном файле с помощью его полного имени. Если он не определен вообще, компоновщик создает ошибку LNK2019.

### <a name="a-build-dependency-is-only-defined-as-a-project-dependency-in-the-solution"></a>Зависимость сборки определяется только в качестве зависимости проекта в решении

В более ранних версиях Visual Studio было достаточно этого уровня зависимостей. Однако начиная с Visual Studio 2010 для Visual Studio требуется [ссылка между](/visualstudio/ide/managing-references-in-a-project)проектами. Если в проекте нет ссылки проекта на проект, может возникнуть Эта ошибка компоновщика. Чтобы устранить ошибку, добавьте ссылку одного проекта на другой.

### <a name="an-entry-point-isnt-defined"></a>Точка входа не определена

Код приложения должен определять соответствующую точку входа: `main` или `wmain` для консольных приложений, а также `WinMain` или `wWinMain` для приложений Windows. Дополнительные сведения см. в разделе [main функция и аргументы командной строки](../../cpp/main-function-command-line-args.md) или [функцияWinMain](/windows/win32/api/winbase/nf-winbase-winmain). Чтобы использовать настраиваемую точку входа, укажите параметр компоновщика [/Entry (символ точки входа)](../../build/reference/entry-entry-point-symbol.md) .

### <a name="you-build-a-console-application-by-using-settings-for-a-windows-application"></a>Построение консольного приложения с помощью параметров для приложения Windows

Если сообщение об ошибке похоже на **неразрешенный внешний символ WinMain на который ссылается функция** *function_name*, свяжите с помощью параметра **/SUBSYSTEM: Console** вместо **/SUBSYSTEM: Windows**. Дополнительные сведения об этом параметре и инструкции о том, как задать это свойство в Visual Studio, см. в статье [/SUBSYSTEM (Specify Subsystem)](../../build/reference/subsystem-specify-subsystem.md).

### <a name="you-attempt-to-link-64-bit-libraries-to-32-bit-code-or-32-bit-libraries-to-64-bit-code"></a>Вы пытаетесь связать 64-разрядные библиотеки с 32-битным кодом или 32-bit Library в 64-разрядный код.

Библиотеки и объектные файлы, связанные с вашим кодом, должны быть скомпилированы для той же архитектуры, что и код. Убедитесь, что библиотеки, на которые ссылается проект, компилируются для той же архитектуры, что и проект. Убедитесь, что свойство [/libpath](../../build/reference/libpath-additional-libpath.md) или **Дополнительные каталоги библиотек** указывает на библиотеки, созданные для правильной архитектуры.

### <a name="you-use-different-compiler-options-for-function-inlining-in-different-source-files"></a>Для встраивания функций в разные исходные файлы используются различные параметры компилятора

Использование встроенных функций, определенных в CPP-файлах, и смешение в различных исходных файлах параметров компилятора для встраивания функций может привести к возникновению ошибки LNK2019. Для получения дополнительной информации см. [Function Inlining Problems](../../error-messages/tool-errors/function-inlining-problems.md).

### <a name="you-use-automatic-variables-outside-their-scope"></a>Автоматические переменные используются вне области действия

Автоматические переменные (области видимости функции) могут использоваться только в области видимости данной функции. Эти переменные не могут объявляться `extern` и использоваться в других исходных файлах. Пример см. в разделе [Automatic (Function Scope) Variables](../../error-messages/tool-errors/automatic-function-scope-variables.md).

### <a name="you-call-intrinsic-functions-or-pass-argument-types-to-intrinsic-functions-that-arent-supported-on-your-target-architecture"></a>Вы вызываете встроенные функции или передайте типы аргументов в встроенные функции, которые не поддерживаются в целевой архитектуре.

Например, если используется встроенная AVX2, но не задан параметр компилятора [/ARCH:AVX2](../../build/reference/arch-x86.md) , компилятор предполагает, что встроенная функция является внешней. Вместо создания встроенной инструкции компилятор создает вызов внешнего символа с тем же именем, что и у встроенного. Когда компоновщик пытается найти определение этой отсутствующей функции, он создает ошибку LNK2019. Убедитесь, что используются только встроенные функции и типы, поддерживаемые целевой архитектурой.

### <a name="you-mix-code-that-uses-native-opno-locwchar_t-with-code-that-doesnt"></a>Вы смешатье код, использующий собственный wchar_t, с кодом, который не

C++работа по согласованности языков, выполненная в Visual Studio 2005, сделана по умолчанию **wchar_t** собственного типа. Если не все файлы были скомпилированы с использованием одних и тех же параметров **/Zc:wchar_t** , ссылки типа не могут разрешаться в совместимые типы. Убедитесь, что типы **wchar_t** во всех файлах библиотек и объектов совместимы. Либо обновите из **wchar_t** typedef, либо используйте соответствующие параметры **/Zc:wchar_t** при компиляции.

## <a name="third-party-library-issues-and-vcpkg"></a>Проблемы с библиотекой сторонних производителей и Vcpkg

Если вы видите эту ошибку при попытке настроить библиотеку стороннего производителя в рамках сборки, рассмотрите возможность использования [Vcpkg](../../vcpkg.md), диспетчера пакетов Visual C++ , для установки и сборки библиотеки. Vcpkg поддерживает большой и растущей [список библиотек сторонних производителей](https://github.com/Microsoft/vcpkg/tree/master/ports). Он задает все свойства конфигурации и зависимости, необходимые для успешной сборки в рамках проекта. Дополнительные сведения см. в соответствующей записи [блога C++ Visual](https://blogs.msdn.microsoft.com/vcblog/2016/09/19/vcpkg-a-tool-to-acquire-and-build-c-open-source-libraries-on-windows/) .

## <a name="diagnosis-tools"></a>Средства диагностики

Иногда трудно определить, почему компоновщику не удается найти определенное определение символа. Часто проблема заключается в том, что в сборку не включен код, содержащий определение. Или же параметры сборки создали разные декорированные имена для внешних символов. Существует несколько средств и параметров, которые могут помочь в диагностике ошибок LNK2019.

- Параметр компоновщика [/VERBOSE](../../build/reference/verbose-print-progress-messages.md) помогает определить, на какие файлы ссылается компоновщик. С помощью этого параметра можно проверить, включен ли в сборку файл, содержащий определение символа.

- Параметры [/EXPORTS](../../build/reference/dash-exports.md) и [/SYMBOLS](../../build/reference/symbols.md) программы **DUMPBIN** помогут вам определить, какие символы определены в DLL-файлах и файлах объектов или библиотек. Убедитесь, что экспортированные декорированные имена соответствуют декорированным именам, которые ищет компоновщик.

- Программа **UNDNAME** может отобразить эквивалентный недекорированный внешний символ для декорированного имени.

## <a name="examples"></a>Примеры

Далее приводится несколько примеров кода, вызывающего ошибку LNK2019, а также сведения о том, как устранить ошибку.

### <a name="a-symbol-is-declared-but-not-defined"></a>Символ объявлен, но не определен

В этом примере внешняя переменная объявлена, но не определена:

```cpp
// LNK2019.cpp
// Compile by using: cl /EHsc /W4 LNK2019.cpp
// LNK2019 expected
extern char B[100];   // B isn't available to the linker
int main() {
   B[0] = ' ';   // LNK2019
}
```

Ниже приведен еще один пример, где переменная и функция объявляются как `extern` но определение не предоставляется:

```cpp
// LNK2019c.cpp
// Compile by using: cl /EHsc LNK2019c.cpp
// LNK2019 expected
extern int i;
extern void g();
void f() {
   i++;
   g();
}
int main() {}
```

Если `i` и `g` не определены в одном из файлов, входящих в сборку, компоновщик создает ошибку LNK2019. Чтобы исправить ошибки, включите файл исходного кода, который содержит определения, в процесс компиляции. Кроме того, можно передать OBJ-файлы или LIB-файлы, содержащие определения, в компоновщик.

### <a name="a-opno-locstatic-data-member-is-declared-but-not-defined"></a>Элемент данных static объявлен, но не определен

Ошибка LNK2019 также может возникать, если элемент данных static объявлен, но не определен. В следующем примере показано возникновение ошибки LNK2019 и приводятся сведения по ее устранению.

```cpp
// LNK2019b.cpp
// Compile by using: cl /EHsc LNK2019b.cpp
// LNK2019 expected
struct C {
   static int s;
};

// Uncomment the following line to fix the error.
// int C::s;

int main() {
   C c;
   C::s = 1;
}
```

### <a name="declaration-parameters-dont-match-the-definition"></a>Параметры объявления не соответствуют определению

Код, который вызывает функции шаблона, должен иметь совпадающие объявления функции шаблона. Объявления должны содержать те же параметры шаблона, что и определение. В следующем примере показано возникновение ошибки LNK2019 для определяемого пользователем оператора и приводятся сведения по ее устранению.

```cpp
// LNK2019e.cpp
// compile by using: cl /EHsc LNK2019e.cpp
// LNK2019 expected
#include <iostream>
using namespace std;

template<class T> class
Test {
   // The operator<< declaration doesn't match the definition below:
   friend ostream& operator<<(ostream&, Test&);
   // To fix, replace the line above with the following:
   // template<typename T> friend ostream& operator<<(ostream&, Test<T>&);
};

template<typename T>
ostream& operator<<(ostream& os, Test<T>& tt) {
   return os;
}

int main() {
   Test<int> t;
   cout << "Test: " << t << endl;   // LNK2019 unresolved external
}
```

### <a name="inconsistent-opno-locwchar_t-type-definitions"></a>Несоответствие определений типов wchar_t

В этом примере создается библиотека DLL с экспортом, в котором используется `WCHAR`, который разрешается в `wchar_t`.

```cpp
// LNK2019g.cpp
// compile with: cl /EHsc /LD LNK2019g.cpp
#include "windows.h"
// WCHAR resolves to wchar_t
__declspec(dllexport) void func(WCHAR*) {}
```

В следующем примере используется библиотека DLL из предыдущего примера и создается LNK2019, так как типы `unsigned short*` и `WCHAR*` не совпадают.

```cpp
// LNK2019h.cpp
// compile by using: cl /EHsc LNK2019h LNK2019g.lib
// LNK2019 expected
__declspec(dllimport) void func(unsigned short*);

int main() {
   func(0);
}
```

Чтобы устранить эту ошибку, измените `unsigned short` на `wchar_t` или `WCHAR`или скомпилируйте LNK2019g. cpp с помощью метода **/Zc:wchar_t-** .

## <a name="additional-resources"></a>Дополнительные ресурсы

Дополнительные сведения о возможных причинах и решениях ошибки LNK2001 см. в Stack Overflow вопросе, [что такое неопределенная ссылка или неразрешенный внешний символ, а также как ее исправить?](https://stackoverflow.com/q/12573816/2002113).
