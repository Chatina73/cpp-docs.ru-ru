---
title: Ошибка времени выполнения C R6035
ms.date: 11/04/2016
f1_keywords:
- R6035
helpviewer_keywords:
- R6035
ms.assetid: f8fb50b8-18bf-4258-b96a-b0a9de468d16
ms.openlocfilehash: ff3cd0259df92aa5cdade3f78a240e69f8f6f7de
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81377478"
---
# <a name="c-runtime-error-r6035"></a>Ошибка времени выполнения C R6035

Библиотека Runtime, Ошибка R6035 — Модуль в этом приложении инициализирует файлы глобальной безопасности модуля, в то время как функция, опирающаяся на это файлы cookie безопасности, активна.  Звоните __security_init_cookie раньше.

[__security_init_cookie](../../c-runtime-library/reference/security-init-cookie.md) должны быть вызваны до первого использования глобального файла cookie безопасности.

Глобальное файлы cookie безопасности используются для защиты буфера перевыполнения в коде, компилированном с [/GS (Buffer Security Check)](../../build/reference/gs-buffer-security-check.md) и в коде, использующем структурированную обработку исключений. По существу, при входе в функцию, защищенную от перенадох, файл cookie помещается в стек, а на выходе значение в стеке сравнивается с глобальным файлом cookie. Любая разница между ними указывает на то, что перезапуск буфера произошел и приводит к немедленному прекращению программы.

Ошибка R6035 указывает на `__security_init_cookie` то, что вызов был сделан после ввода защищенной функции. Если выполнение будет продолжено, будет обнаружен перезапуск ложного буфера, поскольку файл cookie в стеке больше не будет соответствовать глобальному файлу cookie.

Рассмотрим следующий пример DLL. Точка входа DLL установлена на DllEntryPoint через опцию linker [/ENTRY (Символ входа-точки).](../../build/reference/entry-entry-point-symbol.md) Это обходит инициализацию CRT, которая обычно инициализирует файлы глобального `__security_init_cookie`файла безопасности, поэтому сам DLL должен вызываться.

```
// Wrong way to call __security_init_cookie
DllEntryPoint(...) {
   DllInitialize();
   ...
   __try {
      ...
   } __except()... {
      ...
   }
}

void DllInitialize() {
   __security_init_cookie();
}
```

Этот пример будет генерировать ошибку R6035, потому что DllEntryPoint использует структурированную обработку исключений и, следовательно, использует файлы cookie безопасности для обнаружения перерасхода буферов. К тому времени, когда называется DllInitialize, файл ытекса глобальной безопасности уже был помещен в стек.

Правильный способ демонстрируется в этом примере:

```
// Correct way to call __security_init_cookie
DllEntryPoint(...) {
   __security_init_cookie();
   DllEntryHelper();
}

void DllEntryHelper() {
   ...
   __try {
      ...
   } __except()... {
      ...
   }
}
```

В этом случае DllEntryPoint не защищен от перерасхода буферов (он не имеет локальных буферов строки и не использует структурированную обработку исключений); поэтому он может `__security_init_cookie`безопасно вызвать . Затем он вызывает функцию помощника, которая защищена.

> [!NOTE]
> Сообщение об ошибке R6035 генерируется только отладить x86 и только для структурированной обработки исключений, но условие является ошибкой на всех платформах, а также для всех форм обработки исключений, таких как C'EH.

## <a name="see-also"></a>См. также раздел

[Особенности безопасности в MSVC](https://blogs.msdn.microsoft.com/vcblog/2017/06/28/security-features-in-microsoft-visual-c/)
