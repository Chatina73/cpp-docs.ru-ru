---
title: Ошибка времени выполнения C R6035
ms.date: 11/04/2016
f1_keywords:
- R6035
helpviewer_keywords:
- R6035
ms.assetid: f8fb50b8-18bf-4258-b96a-b0a9de468d16
ms.openlocfilehash: 9b92b1e2e123201d4f50422754b77f62b2ec943b
ms.sourcegitcommit: 6b3d793f0ef3bbb7eefaf9f372ba570fdfe61199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2020
ms.locfileid: "86404402"
---
# <a name="c-runtime-error-r6035"></a>Ошибка времени выполнения C R6035

Библиотека времени выполнения Microsoft Visual C++, ошибка R6035 — Модуль в этом приложении инициализирует глобальный файл cookie безопасности модуля, в то время как функция, которая полагается на этот файл cookie безопасности, активна.  Вызовите __security_init_cookie ранее.

[__security_init_cookie](../../c-runtime-library/reference/security-init-cookie.md) необходимо вызвать перед первым использованием глобального файла cookie безопасности.

Глобальный файл cookie безопасности используется для защиты от переполнения буфера в коде, скомпилированном с параметром [/GS (проверка безопасности буфера)](../../build/reference/gs-buffer-security-check.md) и в коде, который использует структурированную обработку исключений. По сути, при входе в функцию, защищенную с помощью переполнения, файл cookie помещается в стек, а при выходе значение в стеке сравнивается с глобальным файлом cookie. Любое различие между ними указывает на то, что произошло переполнение буфера, что приводит к немедленному завершению работы программы.

Ошибка R6035 указывает, что `__security_init_cookie` был выполнен вызов после того, как была указана Защищенная функция. Если выполнение было продолжено, будет обнаружено ложное переполнение буфера, так как файл cookie в стеке больше не соответствует глобальному файлу cookie.

Рассмотрим следующий пример библиотеки DLL. Точка входа DLL имеет значение Дллентрипоинт с параметром компоновщика [/Entry (символ точки входа)](../../build/reference/entry-entry-point-symbol.md) . Это обходит инициализацию CRT, которая обычно инициализирует глобальный файл cookie безопасности, поэтому сама библиотека DLL должна вызывать `__security_init_cookie` .

```
// Wrong way to call __security_init_cookie
DllEntryPoint(...) {
   DllInitialize();
   ...
   __try {
      ...
   } __except()... {
      ...
   }
}

void DllInitialize() {
   __security_init_cookie();
}
```

В этом примере создается ошибка R6035, так как Дллентрипоинт использует структурированную обработку исключений и, таким образом, использует файл cookie безопасности для обнаружения переполнений буфера. По времени вызова Дллинитиализе глобальный файл cookie безопасности уже помещен в стек.

В этом примере демонстрируется правильный способ:

```
// Correct way to call __security_init_cookie
DllEntryPoint(...) {
   __security_init_cookie();
   DllEntryHelper();
}

void DllEntryHelper() {
   ...
   __try {
      ...
   } __except()... {
      ...
   }
}
```

В этом случае Дллентрипоинт не защищен от переполнения буфера (он не содержит локальных буферов строк и не использует структурированную обработку исключений). Поэтому он может безопасно вызывать `__security_init_cookie` . Затем вызывается вспомогательная функция, которая является защищенной.

> [!NOTE]
> Сообщение об ошибке R6035 создается только библиотекой CRT отладки x86 и только для структурированной обработки исключений, но условие является ошибкой на всех платформах, а также для всех форм обработки исключений, таких как C++ EH.

## <a name="see-also"></a>См. также раздел

[Функции безопасности в КОМПИЛЯТОРОМ MSVC](https://devblogs.microsoft.com/cppblog/security-features-in-microsoft-visual-c/)
