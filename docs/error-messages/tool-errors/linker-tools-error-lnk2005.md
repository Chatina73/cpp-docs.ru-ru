---
title: Ошибка средств компоновщика LNK2005
ms.date: 11/04/2016
f1_keywords:
- LNK2005
helpviewer_keywords:
- LNK2005
ms.assetid: d9587adc-68be-425c-8a30-15dbc86717a4
ms.openlocfilehash: 6090478c3761c477250b6706a350e261b51f2a05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81353240"
---
# <a name="linker-tools-error-lnk2005"></a>Ошибка средств компоновщика LNK2005

> *символ,* уже определенный в объекте

*Символ* символа определялся не раз.

Эта ошибка сопровождается фатальной ошибкой [LNK1169](../../error-messages/tool-errors/linker-tools-error-lnk1169.md).

### <a name="possible-causes-and-solutions"></a>Возможные причины и решения

Как правило, эта ошибка означает, что вы нарушили *одно правило определения,* которое позволяет только одно определение для любого используемого шаблона, функции, типа или объекта в данном файле объекта, и только одно определение во всем исполняемом для внешне видимых объектов или функций.

Вот некоторые распространенные причины этой ошибки.

- Эта ошибка может возникнуть, когда файл заголовка определяет переменную. Например, если вы включили этот файл заголовка в более чем один исходный файл в проекте, результаты ошибки:

    ```h
    // LNK2005_global.h
    int global_int;  // LNK2005
    ```

   Ниже представлены возможные решения.

  - Объявите `extern` переменную в файле заголовка: `extern int global_int;`, затем определите ее и факультативно инициализируем в одном исходном файле: `int global_int = 17;`. Эта переменная теперь глобальна, которую можно `extern`использовать в любом исходном файле, объявив ее, например, путем включения файла заголовка. Мы рекомендуем это решение для переменных, которые должны быть глобальными, но хорошая практика разработки программного обеспечения сводит к минимуму глобальные переменные.

  - Объявить переменную `static int static_int = 17;` [статические](../../cpp/storage-classes-cpp.md#static): . Это ограничивает область определения текущим файлом объекта и позволяет нескольким файлам объектов иметь свою собственную копию переменной. Мы не рекомендуем определять статические переменные в файлах заголовков из-за возможности путаницы с глобальными переменными. Предпочитаю перемещать статические переменные определения в исходные файлы, которые их используют.

  - Объявить переменную `__declspec(selectany) int global_int = 17;` [selectany](../../cpp/selectany.md): . Это говорит связующее выбрать одно определение для использования всеми внешними ссылками и отказаться от остальных. Это решение иногда полезно при объединении библиотек импорта. В противном случае, мы не рекомендуем его как способ избежать ошибок linker.

- Эта ошибка может возникнуть, когда файл заголовка `inline`определяет функцию, которая не является. Если вы включите этот файл заголовка в более чем один исходный файл, вы получите несколько определений функции в исполняемой.

    ```h
    // LNK2005_func.h
    int sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   Ниже представлены возможные решения.

  - Добавьте `inline` ключевое слово в функцию:

    ```h
    // LNK2005_func_inline.h
    inline int sample_function(int k) { return 42 * (k % 167); }
    ```

  - Удалите тело функции из файла заголовка и оставьте только декларацию, а затем реализуйте функцию в одном исходном файле:

    ```h
    // LNK2005_func_decl.h
    int sample_function(int);
    ```

    ```cpp
    // LNK2005_func_impl.cpp
    int sample_function(int k) { return 42 * (k % 167); }
    ```

- Эта ошибка также может возникнуть, если вы определяете функции участника за пределами объявления класса в файле заголовка:

    ```h
    // LNK2005_member_outside.h
    class Sample {
    public:
        int sample_function(int);
    };
    int Sample::sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   Чтобы устранить эту проблему, переместите определения функции участника внутри класса. Функции участника, определенные внутри объявления класса, неявно поднижаются.

    ```h
    // LNK2005_member_inline.h
    class Sample {
    public:
        int sample_function(int k) { return 42 * (k % 167); }
    };
    ```

- Эта ошибка может произойти, если вы свяжете несколько версий стандартной библиотеки или CRT. Например, если вы попытаетесь связать как розничные и отладные библиотеки CRT, так и статические и динамические версии библиотеки или две различные версии стандартной библиотеки с исполняемой, эта ошибка может быть сообщена много раз. Чтобы исправить эту проблему, удалите все, кроме одной копии каждой библиотеки, из команды ссылок. Мы не рекомендуем смешивать библиотеки розничной торговли и отладки или различные версии библиотеки в одних и тех же исполняемых.

   Чтобы сообщить связующим звену об использовании библиотек, не вкоторыхяных по умолчанию, в командной строке укажите библиотеки для использования и используйте опцию [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) для отсрочения библиотек по умолчанию. В IDE добавьте ссылки на проект, чтобы указать библиотеки для использования, а затем откройте диалог **страниц свойств для** вашего проекта, а на странице **Linker**, **Input property,** установите либо **игнорировать все библиотеки по умолчанию,** либо **игнорировать конкретные свойства по умолчанию,** чтобы отключить библиотеки по умолчанию.

- Эта ошибка может возникнуть при смешивании статических и динамических библиотек при использовании опции [/clr.](../../build/reference/clr-common-language-runtime-compilation.md) Например, эта ошибка может возникнуть, если вы создахотите DLL для использования в исполняемой связи в статической CRT. Чтобы исправить эту проблему, используйте только статические библиотеки или только динамические библиотеки для всего исполняемого и для любых библиотек, которые вы строите, чтобы использовать в исполняемых.

- Эта ошибка может произойти, если символ является упакованной функцией (созданной путем компиляции с [/Gy)](../../build/reference/gy-enable-function-level-linking.md)и включен в более чем один файл, но был изменен между компиляциями. Чтобы исправить эту проблему, пересовывайте все файлы, которые включают упакованную функцию.

- Эта ошибка может возникнуть, если символ определен по-разному в двух объектах-членах в разных библиотеках, и оба объекта-члена используются. Одним из способов устранения этой проблемы при статичном подключении библиотек является использование объекта-члена из одной библиотеки и включение этой библиотеки сначала в командную строку linker. Чтобы использовать оба символа, необходимо создать способ различать их. Например, если можно построить библиотеки из источника, можно обернуть каждую библиотеку в уникальное пространство имен. Кроме того, можно создать новую библиотеку оберток, которая использует уникальные имена, чтобы обернуть ссылки на одну из оригинальных библиотек, связать новую библиотеку с оригинальной библиотекой, а затем связать исполняемую с новой библиотекой вместо оригинальной библиотеки.

- Эта ошибка может `extern const` произойти, если переменная определена дважды и имеет различное значение в каждом определении. Чтобы исправить эту проблему, определите константу `enum class` только один раз, или используйте пространства имен или определения, чтобы различать константы.

- Эта ошибка может возникнуть, если вы используете uuid.lib в сочетании с другими файлами .lib, которые определяют GUID (например, oledb.lib и adsiid.lib). Пример:

    ```Output
    oledb.lib(oledb_i.obj) : error LNK2005: _IID_ITransactionObject
    already defined in uuid.lib(go7.obj)
    ```

   Чтобы исправить эту проблему, добавьте [/FORCE:MULTIPLE](../../build/reference/force-force-file-output.md) в параметры командной строки linker и убедитесь, что uuid.lib является первой библиотекой, на которую ссылается.
