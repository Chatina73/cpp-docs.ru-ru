---
title: Ошибка средств компоновщика LNK2005
ms.date: 11/04/2016
f1_keywords:
- LNK2005
helpviewer_keywords:
- LNK2005
ms.assetid: d9587adc-68be-425c-8a30-15dbc86717a4
ms.openlocfilehash: 278f05b8338ac4238d6862fd7b9bd7744f6c8ee5
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87225219"
---
# <a name="linker-tools-error-lnk2005"></a>Ошибка средств компоновщика LNK2005

> *символ* уже определен в объекте

*Символ* символа был определен несколько раз.

За этой ошибкой следует Неустранимая ошибка [LNK1169](../../error-messages/tool-errors/linker-tools-error-lnk1169.md).

### <a name="possible-causes-and-solutions"></a>Возможные причины и решения

Как правило, эта ошибка означает, что вы нарушили *одно правило определения*, которое допускает только одно определение любого используемого шаблона, функции, типа или объекта в данном объектном файле и только одно определение во всем исполняемом объекте для внешних видимых объектов или функций.

Ниже приведены некоторые распространенные причины этой ошибки.

- Эта ошибка может возникать, когда заголовочный файл определяет переменную. Например, если включить этот файл заголовка в более чем один исходный файл в проекте, возникает ошибка:

    ```h
    // LNK2005_global.h
    int global_int;  // LNK2005
    ```

   Ниже представлены возможные решения.

  - Объявите переменную **`extern`** в файле заголовка: `extern int global_int;` , затем определите ее и при необходимости инициализируйте ее в одном и только одном исходном файле: `int global_int = 17;` . Теперь эта переменная является глобальной, которую можно использовать в любом исходном файле путем объявления ее, например **`extern`** , путем включения файла заголовка. Мы рекомендуем использовать это решение для переменных, которые должны быть глобальными, но хорошей практикой разработки программного обеспечения является сокращение числа глобальных переменных.

  - Объявите переменную [static](../../cpp/storage-classes-cpp.md#static): `static int static_int = 17;` . Это ограничивает область определения текущим объектным файлом и позволяет нескольким файловым файлам иметь собственную копию переменной. Не рекомендуется определять статические переменные в файлах заголовков из-за возможности путаницы с глобальными переменными. Предпочитают перемещать определения статических переменных в исходные файлы, которые их используют.

  - Объявите переменную [selectany](../../cpp/selectany.md): `__declspec(selectany) int global_int = 17;` . Это предписывает компоновщику выбрать одно определение для использования всеми внешними ссылками и отменить остальные. Это решение иногда полезно при объединении библиотек импорта. В противном случае мы не рекомендуем использовать его как способ избежать ошибок компоновщика.

- Эта ошибка может возникать, когда файл заголовка определяет функцию, которая не является **`inline`** . Если включить этот заголовочный файл в более чем один исходный файл, вы получите несколько определений функции в исполняемом файле.

    ```h
    // LNK2005_func.h
    int sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   Ниже представлены возможные решения.

  - Добавьте **`inline`** ключевое слово в функцию:

    ```h
    // LNK2005_func_inline.h
    inline int sample_function(int k) { return 42 * (k % 167); }
    ```

  - Удалите тело функции из файла заголовка и оставьте только объявление, а затем реализуйте функцию в одном и только одном исходном файле:

    ```h
    // LNK2005_func_decl.h
    int sample_function(int);
    ```

    ```cpp
    // LNK2005_func_impl.cpp
    int sample_function(int k) { return 42 * (k % 167); }
    ```

- Эта ошибка также может возникать при определении функций-членов вне объявления класса в файле заголовка:

    ```h
    // LNK2005_member_outside.h
    class Sample {
    public:
        int sample_function(int);
    };
    int Sample::sample_function(int k) { return 42 * (k % 167); }  // LNK2005
    ```

   Чтобы устранить эту проблему, переместите определения функций члена внутри класса. Функции-члены, определенные внутри объявления класса, неявно встроены.

    ```h
    // LNK2005_member_inline.h
    class Sample {
    public:
        int sample_function(int k) { return 42 * (k % 167); }
    };
    ```

- Эта ошибка может возникать при связывании более одной версии стандартной библиотеки или CRT. Например, при попытке связать как розничную, так и отладочную библиотеки CRT либо статическую и динамическую версии библиотеки, или две различные версии стандартной библиотеки для исполняемого файла, эта ошибка может быть сообщена много раз. Чтобы устранить эту проблему, удалите все копии каждой библиотеки, кроме одной, из команды link. В одном исполняемом файле не рекомендуется смешивать библиотеки розничной и отладочной версий, а также разные версии библиотеки.

   Чтобы указать компоновщику использовать библиотеки, отличные от параметров по умолчанию, в командной строке укажите используемые библиотеки и используйте параметр [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) , чтобы отключить библиотеки по умолчанию. В интегрированной среде разработки добавьте ссылки на проект, чтобы указать используемые библиотеки, а затем откройте диалоговое окно **страницы свойств** для проекта, а затем на странице **компоновщика**, **входные** свойства задайте значение **игнорировать все библиотеки по умолчанию**или **игнорировать определенные свойства библиотек** по умолчанию, чтобы отключить библиотеки по умолчанию.

- Эта ошибка может возникать, если при использовании параметра [/CLR](../../build/reference/clr-common-language-runtime-compilation.md) используется сочетание статических и динамических библиотек. Например, эта ошибка может возникнуть при создании библиотеки DLL для использования в исполняемом файле, который ссылается на статическую библиотеку CRT. Чтобы устранить эту проблему, используйте только статические библиотеки или только динамические библиотеки для всего исполняемого файла и для всех библиотек, которые вы создаете для использования в исполняемом файле.

- Эта ошибка может возникать, если символ является упакованной функцией (созданной путем компиляции с параметром [/Gy](../../build/reference/gy-enable-function-level-linking.md)) и включен в несколько файлов, но был изменен между компиляциями. Чтобы устранить эту проблему, перекомпилируются все файлы, содержащие упакованную функцию.

- Эта ошибка может возникать, если символ определен по-разному в двух объектах-членах в разных библиотеках и используются оба объекта-члена. Один из способов устранить эту проблему, если библиотеки статически связаны, — использовать объект-член только из одной библиотеки и сначала включить эту библиотеку в командную строку компоновщика. Чтобы использовать оба символа, необходимо создать способ их различения. Например, если вы можете построить библиотеки из источника, можно создать оболочку для каждой библиотеки в уникальном пространстве имен. Кроме того, можно создать новую библиотеку оболочек, использующую уникальные имена для переноса ссылок на одну из исходных библиотек, связать новую библиотеку с исходной библиотекой, а затем связать исполняемый объект с новой библиотекой вместо исходной библиотеки.

- Эта ошибка может возникать `extern const` , если переменная определена дважды и имеет другое значение в каждом определении. Чтобы устранить эту проблему, определите константу только один раз или используйте пространства имен или **`enum class`** определения для различения констант.

- Эта ошибка может возникать, если вы используете UUID. lib в сочетании с другими lib-файлами, определяющими идентификаторы GUID (например, OLEDB. lib и адсиид. lib). Например:

    ```Output
    oledb.lib(oledb_i.obj) : error LNK2005: _IID_ITransactionObject
    already defined in uuid.lib(go7.obj)
    ```

   Чтобы устранить эту проблему, добавьте параметр [/Force: Multiple](../../build/reference/force-force-file-output.md) в параметры командной строки компоновщика и убедитесь, что UUID. lib является первой библиотекой, на которую имеется ссылка.
