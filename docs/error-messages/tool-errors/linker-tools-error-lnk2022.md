---
title: Ошибка средств компоновщика LNK2022
ms.date: 11/04/2016
f1_keywords:
- LNK2022
helpviewer_keywords:
- LNK2022
ms.assetid: d2128c73-dde3-4b8e-a9b2-0a153acefb3b
ms.openlocfilehash: e55202274c5ec3982f784ad6cdf074a5a99e922f
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50491394"
---
# <a name="linker-tools-error-lnk2022"></a>Ошибка средств компоновщика LNK2022

> Сбой операции с метаданными (*HRESULT*): *error_message*

Компоновщик обнаружил ошибку при слиянии метаданных. Ошибки в метаданных должны быть разрешены для связывания успешно.

Для диагностики этой проблемы рекомендуется запустить **ildasm-маркеры** для объектных файлов для определения типов токенов в списке в `error_message`и выполните поиск различий.  В метаданных два разных типа с таким именем не допускается, даже если только атрибут LayoutType отличается.

Одной из причин для LNK2022 является, если тип (например, структура) существует в нескольких единиц компиляции, с тем же именем, но с конфликтующие определения и при компиляции с параметром [/CLR](../../build/reference/clr-common-language-runtime-compilation.md).  В этом случае убедитесь, что тип имеет совпадают во всех компилируемых объектах.  Имя типа должно содержаться в `error_message`.

Другая возможная причина LNK2022 — когда компоновщик находит файл метаданных в другом месте, чем было указано в компилятор (с [#using](../../preprocessor/hash-using-directive-cpp.md) ). Убедитесь, что файл метаданных (.dll или .netmodule) — там же, при передаче в компоновщик, на момент, когда он был передан в компилятор.

При сборке приложения ATL, использование макроса `_ATL_MIXED` требуется в все компилируемые объекты, в том случае, если он используется по крайней мере одним.

## <a name="example"></a>Пример

В следующем примере определяется пустой тип.

```cpp
// LNK2022_a.cpp
// compile with: /clr /c
public ref class Test {};
```

## <a name="example"></a>Пример

В этом примере показано, что нельзя связать двух файлов исходного кода, которые содержат типы, тем же именем, но разных определений.

Следующий пример приводит к возникновению ошибки LNK2022.

```cpp
// LNK2022_b.cpp
// compile with: LNK2022_a.cpp /clr /LD
// LNK2022 expected
public ref class Test {
   void func() {}
   int var;
};
```