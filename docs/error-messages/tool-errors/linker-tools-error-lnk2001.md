---
title: Ошибка средств компоновщика LNK2001
ms.date: 05/17/2017
f1_keywords:
- LNK2001
helpviewer_keywords:
- LNK2001
ms.assetid: dc1cf267-c984-486c-abd2-fd07c799f7ef
ms.openlocfilehash: 824fa9108e6322b1bcf77d6c28c7fb843b743833
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62161021"
---
# <a name="linker-tools-error-lnk2001"></a>Ошибка средств компоновщика LNK2001

неразрешенный внешний символ "*символ*"

Скомпилированный код делает ссылки или вызов *символ*, но этот символ не определен ни в одной библиотеки или объектные файлы, указанные в компоновщик.

Это сообщение об ошибке сопровождается Неустранимая ошибка [LNK1120](../../error-messages/tool-errors/linker-tools-error-lnk1120.md). Необходимо устранить ошибки все LNK2001 и LNK2019, чтобы устранить ошибку LNK1120.

## <a name="possible-causes"></a>Возможные причины

Существует много способов, чтобы получить эту ошибку, но все они включают в себя ссылку на функцию или переменную, компоновщик не поддерживает *устранить*, или найти определение для. Компилятор может определить, когда символ не *объявлен*, но не когда это не *определенные*, так как определение может быть в другом файле исходного кода или в библиотеке. Если символ имеется ссылка, но никогда не определяется, компоновщик создает ошибку.

### <a name="coding-issues"></a>Проблемы кода

Эта ошибка может быть вызвана несоответствующие регистром в исходный код или определения модуля (DEF) файла. Например, если вы используете имя переменной `var1` в C++ один исходный файл и получить доступ к его как `VAR1` в другом, возникает эта ошибка. Чтобы устранить эту проблему, используйте согласованно написание и регистр имен.

Эта ошибка может быть вызвана в проект, использующий [встраивания функции](../../error-messages/tool-errors/function-inlining-problems.md) при определении функции в исходном файле, а не в файле заголовка. Встроенные функции не будут отображаться за пределами исходного файла, содержащего определения. Чтобы устранить эту проблему, определите встроенных функций в заголовках которых они объявлены.

Эта ошибка может быть вызвана, если вызов функции C из программы на языке C++ без использования `extern "C"` объявление функции C. Компилятор использует соглашения об именовании различных внутренних символов для кода C и C++, и это имя внутреннего символа, которое ищет компоновщик, при разрешении символы. Чтобы устранить эту проблему, используйте `extern "C"` оболочку вокруг всех объявлений функций C, используемых в коде C++, который дает компилятору указание использовать внутренний соглашение об именовании C для этих символов. Параметры компилятора [/Tp](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) и [/Tc](../../build/reference/tc-tp-tc-tp-specify-source-file-type.md) компилятор для компиляции как C++ или C, соответственно, независимо от того, расширение имени файла. Эти параметры могут привести к имена внутренних функций отличаются от ожидаемых.

Эта ошибка может быть вызвана попытка ссылки на функции или данные, которые не имеют внешнюю компоновку. В C++ встраиваемые функции и `const` данных имеют внутреннюю компоновку, если не указано явным образом как `extern`. Чтобы устранить эту проблему, используйте явные `extern` называется объявления на символы за пределами определяющей исходного файла.

Эта ошибка может быть вызвана [отсутствует тело функции или переменная](../../error-messages/tool-errors/missing-function-body-or-variable.md) определения. Всего эта ошибка происходит, когда объявление, но не определить, переменные, функции или классы в коде. Компилятор должен только прототип функции или `extern` объявление переменной для создания файла объекта без ошибок, но компоновщик не удается разрешить вызов функции или ссылку на переменную, поскольку нет места кода или переменной функции зарезервировано. Чтобы устранить эту проблему, убедитесь, что все функции и переменной полностью определен в исходном файле или в библиотеке, включенные в ссылке.

Эта ошибка может быть вызвана вызов функции, которая использует типы возврата и параметров или соглашения о вызовах, которые не совпадают в определении функции. В C++ файлы объектов [имя decoration](../../error-messages/tool-errors/name-decoration.md) включает соглашение о вызовах, областью класса или пространства имен и типы возврата и параметров функции в окончательное дополненное имя функции, который используется как символ для сопоставления, когда вызовы разрешаются функции из других объектных файлов. Чтобы устранить эту проблему, убедитесь, что объявление, определение и вызовы все функции используется теми же областями, типы и соглашения о вызовах.

Это ошибка может быть вызвана в коде C++, когда включается прототип функции в определение класса, но не смогут [включать реализацию](../../error-messages/tool-errors/missing-function-body-or-variable.md) функции, а затем вызвать его. Чтобы устранить эту проблему, не забудьте предоставить определение для всех вызывается объявленных членов класса.

Эта ошибка может вызываться попытка вызова чистой виртуальной функции из абстрактного базового класса. Чистой виртуальной функции не имеет базового класса реализации. Чтобы устранить эту проблему, убедитесь, что все виртуальные функции вызывается реализованы.

Эта ошибка может быть вызвана, пытаясь использовать переменная, объявленная внутри функции ([локальной переменной](../../error-messages/tool-errors/automatic-function-scope-variables.md)) выходит за рамки этой функции. Чтобы устранить эту проблему, удалите ссылку на переменную, которая не находится в области, или переместить переменную в области более высокого уровня.

Эта ошибка может возникать при сборке финальной версии проекта ATL, создания сообщений, что необходим код запуска CRT. Чтобы устранить эту проблему, выполните одно из следующих значений,

- Удалить `_ATL_MIN_CRT` из списка препроцессор определяет, чтобы разрешить включение кода запуска CRT. См. в разделе [свойств "Общие" (проект)](../../build/reference/general-property-page-project.md) Дополнительные сведения.

- Если это возможно удалите вызовы функций CRT, требующие код запуска CRT. Вместо этого используйте эквиваленты для Win32. Например, используйте `lstrcmp` вместо `strcmp`. Известные функции, требующие код запуска CRT приведены некоторые строки и функции с плавающей запятой.

### <a name="compilation-and-link-issues"></a>Проблемы компиляции и ссылки

Эта ошибка может возникать, если в проекте отсутствует ссылка на библиотеку (. LIB) или объекта (. Файл OBJ). Чтобы устранить эту проблему, добавьте ссылку на библиотеку, необходимую или объектный файл в проект. Дополнительные сведения см. в разделе [LIB-файлы в качестве входных данных компоновщика](../../build/reference/dot-lib-files-as-linker-input.md).

Эта ошибка может возникать, если вы используете [/NODEFAULTLIB](../../build/reference/nodefaultlib-ignore-libraries.md) или [/Zl](../../build/reference/zl-omit-default-library-name.md) параметры. При указании этих параметров, библиотеки, содержащие необходимый код не связаны в проект, если не включены явно. Чтобы устранить эту проблему, явным образом включите все библиотеки, используемых в командную строку компоновки. Если вы видите многих отсутствующие имена функций CRT и стандартной библиотеки, при использовании этих параметров, явно включают файлы CRT и стандартной библиотеки DLL или библиотеке в ссылке.

Если компиляция выполняется с помощью **/CLR** , то может существовать отсутствует ссылка на .cctor. Чтобы устранить эту проблему, см. в разделе [Инициализация смешанных сборок](../../dotnet/initialization-of-mixed-assemblies.md) Дополнительные сведения.

Эта ошибка может возникать, если связать с библиотеками в режиме выпуска, когда построение отладочной версии приложения. Аналогичным образом при использовании параметров **/MTd** или **/MDd** или определить `_DEBUG` и свяжите версию библиотеки, следует ожидать многих потенциальных неразрешенных внешних элементов, помимо прочих проблем. Связывание построения в режиме выпуска с отладочными библиотеками вызывает подобных проблем. Чтобы устранить эту проблему, убедитесь, что использовать отладочные библиотеки в отладочных построениях, розничной торговли библиотеки в приложении retail построений.

Эта ошибка может возникать, если код ссылается на символ из одной версии библиотеки, но укажите другую версию библиотеки для компоновщика. Как правило нельзя смешивать файлов объектов или библиотек, разработанных для разных версий компилятора. В библиотеках, поставляемых в новой версии может содержать символы, которые не удается найти в библиотеках предыдущих версий и наоборот. Чтобы устранить эту проблему, построения всех объектных файлов и библиотек с той же версией компилятора, прежде чем связывать их друг с другом.

- Средства &#124; параметры &#124; проекты &#124; каталоги VC ++ диалоговое окно, в списке выбора файлов библиотеки, можно изменить порядок поиска библиотеки. Папка "компоновщик" в диалоговом окне страницы свойств проекта может также содержать путей, которые могут быть устаревшими.

- Такая проблема может возникнуть при установке нового пакета SDK (возможно в другом месте), а порядок поиска не обновляется, чтобы он указывал на новое расположение. Как правило, необходимо указать путь для нового пакета SDK директорий перед расположение по умолчанию Visual C++. Кроме того проект, содержащий внедренные пути, по-прежнему может указывать на старого пути, допустимые, но устаревшими для новой функциями, добавленными в новой версии, которая устанавливается в другое расположение.

- Если построение из командной строки и создали собственные переменные среды, убедитесь, что пути к средства, библиотеки и заголовочные файлы ведут согласованность версий. Дополнительные сведения см. в разделе [задать пути и переменных среды в построении из командной строки](../../build/setting-the-path-and-environment-variables-for-command-line-builds.md)

В данный момент стандарт [именования C++](../../error-messages/tool-errors/name-decoration.md) между поставщиками компиляторов и даже между различными версиями одного компилятора. Таким образом компоновке объектных файлов с помощью других компиляторов может не создавать схемы именования, что и таким образом вызвать ошибка LNK2001.

[Совместное использование встроенной и не являющиеся встроенными параметров компиляции](../../error-messages/tool-errors/function-inlining-problems.md) в различных модулях может вызвать ошибку LNK2001. Если библиотеки C++ создается с функциональная возможность встраивания включена (**/Ob1** или **/Ob2**), но соответствующий файл заголовка, описывающие функции встраивания отключено (не `inline` ключевое слово), эта ошибка имеет место. Чтобы устранить эту проблему, определите функции `inline` в файле заголовка, добавляемых в других файлах исходного кода.

Если вы используете `#pragma inline_depth` компилятора директив, убедитесь, что у вас есть [значение 2 или более](../../error-messages/tool-errors/function-inlining-problems.md)и убедитесь, что можно также использовать [/Ob1](../../build/reference/ob-inline-function-expansion.md) или [/Ob2](../../build/reference/ob-inline-function-expansion.md) параметр компилятора.

Эта ошибка может возникать, если ССЫЛКУ не указан параметр/NOENTRY при создании библиотеки DLL ресурсов. Чтобы устранить эту проблему, добавьте параметр/NOENTRY к команде link.

Эта ошибка может возникать, если вы используете неверный параметр/SUBSYSTEM или/Entry параметров в проекте. Например, если консольное приложение и указать/SUBSYSTEM: Windows, неразрешенная внешняя ошибка создается для `WinMain`. Чтобы устранить эту проблему, убедитесь, что соответствуют параметрам для типа проекта. Дополнительные сведения об этих параметрах и точек входа, см. в разделе [/SUBSYSTEM](../../build/reference/subsystem-specify-subsystem.md) и [/Entry](../../build/reference/entry-entry-point-symbol.md) параметры компоновщика.

### <a name="exported-symbol-issues"></a>Экспортированному символу проблемы

Эта ошибка возникает, когда операцию экспорта, перечисленные в DEF-файл не найден. Возможно, он не существует, неверно указан или использует внутреннее имя C++. Вступают декорированные имена в DEF-файл. Чтобы устранить эту проблему, удалите ненужные экспорты и используйте `extern "C"` объявления для экспортированных символов.

## <a name="what-is-an-unresolved-external-symbol"></a>Что такое неразрешенном внешнем символе?

Объект *символ* — это имя для функции или глобальная переменная, используемая внутренне, скомпилированный объектный файл или библиотеку. Символ — *определенные* в объектном файле где выделяется память для глобальной переменной или функции, где размещается скомпилированный код тела функции. *Внешний символ* — это символ, что все *упоминаемого*, то есть используется или вызывается в файле один объект, но определенные в другом файле библиотеки или объекта. *Экспортировать символ* — это приложения, доступны публично файл объекта или библиотеки, который его определяет. Компоновщик должен *устранить*, или найти соответствующее определение для каждого внешнего символа, который ссылается на объектный файл, если он связан с приложением или библиотекой DLL. Компоновщик создает ошибку при невозможности разрешить внешнего символа путем нахождения соответствия экспортированному символу во всех связанных файлов.

## <a name="use-the-decorated-name-to-find-the-error"></a>Использовать декорированное имя для поиска ошибок

Используйте компилятор и компоновщик C++ [Декорирование имен](../../error-messages/tool-errors/name-decoration.md), также известных как *изменением имени*, для кодирования дополнительных сведений о тип переменной или тип возвращаемого значения, типы параметров, область действия и вызова метода соглашение о функции в имя символа. Это внутреннее имя является имя символа, которое ищет компоновщик для разрешения внешних символов.

Поскольку нужные дополнительные данные становится частью имени символа, если объявление функции или переменная полностью соответствует определению функции или переменной может привести ошибка связи. Это может произойти, если один и тот же файл заголовка используется в вызывающий код и определение кода, если при компиляции исходных файлов, используются флаги компилятора. Например, может появиться следующая ошибка при компиляции кода для использования `__vectorcall` соглашение о вызовах, но ссылка на библиотеку, которая ожидает, что клиентам вызывать его, используя значение по умолчанию `__cdecl` или `__fastcall` соглашение о вызовах. В этом случае символы, не соответствует из-за разных соглашения о вызовах

Чтобы помочь вам найти причину этого типа ошибки, сообщение об ошибке компоновщика показано, как «понятное имя,» имя, используемое в исходный код и имя декорированного (в скобках) неразрешенный внешний символ. Не нужно знать, как перевести внутреннее имя, чтобы иметь возможность сравнить его с другими декорированные имена. Можно использовать средства командной строки, которые входят в состав компилятор для сравнения ожидаемого имени и имени фактического символа:

- [/EXPORTS](../../build/reference/dash-exports.md) и [/SYMBOLS](../../build/reference/symbols.md) возможностей средства командной строки программы DUMPBIN помогут определить, какие символы определены в файлах DLL и объекта или библиотеки. Это можно использовать, чтобы убедиться, что экспортированные декорированные имена совпадают, декорированные имена компоновщик ищет.

В некоторых случаях Компоновщик сообщает только о декорированное имя символа. Средство командной строки UNDNAME можно использовать для получения недекорированных декорированного имени.

## <a name="additional-resources"></a>Дополнительные ресурсы

Дополнительные сведения о возможных причинах проблем и решениях для LNK2001, см. в разделе по вопросу переполнения стека [что представляет ошибка неопределенной ссылки или неразрешенного внешнего символа и как ее устранить?](http://stackoverflow.com/q/12573816/2002113).

