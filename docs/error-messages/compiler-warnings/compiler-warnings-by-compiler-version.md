---
title: Предупреждения компилятора по версиям компилятора
ms.date: 10/24/2018
helpviewer_keywords:
- warnings, by compiler version
- cl.exe compiler, setting warning options
ms.openlocfilehash: ae5d1957694abe09d1e04fba5ccfd2cd87d36940
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50530186"
---
# <a name="compiler-warnings-by-compiler-version"></a>Предупреждения компилятора по версиям компилятора

Компилятор можно подавить предупреждения, появившиеся позднее версии, используя [/wv](../../build/reference/compiler-option-warning-level.md) параметр компилятора. Это полезно для управления процесс сборки, когда вы представляете новой версии набора инструментов и хотите временно отключить новые предупреждения. Этот параметр не подавляет новое сообщение об ошибке. Мы не рекомендуем отключить все новые предупреждения без возможности восстановления! Мы рекомендуем всегда компиляции на высшем уровне предупреждение регулярных, __/W4__и удалите __/wv__ параметр в сборке как можно скорее.

Эти версии компилятора введены новые предупреждения:

| Продукт | Номер версии компилятора |
|-|-|
| Visual C++ 2002 | 13.00.9466 |
| Visual C++ 2003 | 13.10.3077 |
| Visual C++ 2005 | 14.00.50727.762 |
| Visual C++ 2008 | 15.00.21022.08 |
| Visual C++ 2010 | 16.00.40219.01 |
| Visual C++ 2012 | 17.00.51106.1 |
| Visual C++ 2013 | 18.00.21005.1 |
| Visual C++ 2015 RTM | 19.00.23026.0 |
| Visual C++ 2015 с обновлением 1 | 19.00.23506.0 |
| Visual C++ 2015 с обновлением 2 | 19.00.23918.0 |
| Visual C++ 2015 с обновлением 3 | 19.00.24215.1 |
| Visual C++ 2017 RTM | 19.10.25017.0 |
| Visual C++ 2017 версии 15.3 | 19.11.25506.0 |
| Visual C++ 2017 версии 15.5 | 19.12.25830.0 |
| Visual C++ 2017 версии 15.6 | 19.13.26128.0 |
| Visual C++ 2017 версии 15.7 | 19.14.26428.0 |
| Visual C++ 2017 версии 15.8 | 19.15.26726.0 |

Можно указать только основной номер, основные и дополнительные номера или основной и дополнительный номера, а номеров сборок для __/wv__ параметр. Компилятор выводит все предупреждения, в которых совпадает с версией, которые начинаются с указанным номером и отключает все предупреждения для версий старше указанного числа. Например __/Wv:17__ выводит все предупреждения, появившиеся во время или до любой версии Visual Studio 2012 и отключает все предупреждения, появившиеся в любой компилятор из Visual Studio 2013 (версия 18) или более поздней версии. Чтобы отключить предупреждения, появившиеся в Visual Studio 2015 с обновлением 2 и более поздней версии, вы можете использовать __/Wv:19.00.23506__. Используйте __/Wv:19.11__ сообщить все предупреждения в любой версии Visual Studio до Visual Studio 2017 версии 15.5, но также подавляет предупреждения, появившиеся в Visual Studio 2017 версии 15.5 и более поздних версий.

В следующих разделах перечислены предупреждения, появившиеся в каждую версию Visual C++, можно отключить с помощью __/wv__ параметр компилятора. __/Wv__ параметр нельзя было подавить предупреждения, которые не перечислены, которые предшествуют указанной версии компилятора.

## <a name="warnings-introduced-in-visual-c-2017-version-158-compiler-version-1915267260"></a>Предупреждения, появившиеся в Visual C++ 2017 версии 15.8 (версия компилятора 19.15.26726.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.14__.

|||
|-|-|
C5046|"*функция*": символ с участием типа с внутренней компоновкой не определен|

## <a name="warnings-introduced-in-visual-c-2017-version-157-compiler-version-1914264280"></a>Предупреждения, появившиеся в Visual C++ 2017 версии 15.7 (версия компилятора 19.14.26428.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.13__.

|||
|-|-|
C4642|"*проблема*": не удалось импортировать ограничения для универсального параметра "*параметр*"
C5045|Компилятор вставит устранение рисков Spectre для загрузки памяти, если переключатель/qspectre указанной

## <a name="warnings-introduced-in-visual-c-2017-version-156-compiler-version-1913261280"></a>Предупреждения, появившиеся в Visual C++ 2017 версии 15.6 (версия компилятора 19.13.26128.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.12__.

|||
|-|-|
C5044|Аргумент для параметра командной строки *параметр* указывает на путь "*путь*", не существует

## <a name="warnings-introduced-in-visual-c-2017-version-155-compiler-version-1912258300"></a>Предупреждения, появившиеся в Visual C++ 2017 версии 15.5 (версия компилятора 19.12.25830.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.11__.

|||
|-|-|
C4843|"*тип1*": недоступен обработчик исключений, ссылки на тип массива или функции, используйте "*тип2*" вместо
C4844|"модуль экспорта *module_name*;" теперь синтаксис является предпочтительным для объявления интерфейса модуля
C5039|"*функция*": указатель или ссылка, которая может вызвать функцию, передаваемое функции extern C с параметром-EHc. Если эта функция создает исключение, может возникнуть неопределенное поведение.
C5040|спецификации динамических исключений являются допустимыми только в C ++ 14 и более ранних версий. как noexcept(false)
C5041|"*определение*": определение вне строки для статического члена данных constexpr не требуется и является устаревшим в C ++ 17
C5042|"*объявление*": объявления функций в области видимости блока не может быть указанного «inline» в стандартном языке C++; удалите спецификатор «inline»
C5043|"*спецификации*": спецификация исключения не соответствует предыдущему объявлению

## <a name="warnings-introduced-in-visual-c-2017-version-153-compiler-version-1911255060"></a>Предупреждения, появившиеся в Visual C++ 2017 версии 15.3 (версия компилятора 19.11.25506.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.10__.

|||
|-|-|
C4597|неопределенное поведение: *описание*
C4604|"*тип*": передачи аргумента по значению через границы собственного и управляемого требуется действительный конструктор копии. В противном случае поведение среды выполнения не определено
C4749|условно поддерживается: *описание*
C4768|атрибуты __declspec перед спецификацией компоновки игнорируются
C4834|Отмена возвращаемого значения функции с атрибутом «nodiscard»
C4841|использовано нестандартное расширение: *расширения*
C4842|результат offsetof применен к типу, использующему множественное наследование не обязательно будут согласованы между версиями компилятора
C4869|«nodiscard» можно применять только к классам, перечислениям и функции с возвращаемым типом отличный от void
C5033|"*класса хранения*" больше не является поддерживаемым классом хранилища
C5034|Использование встроенной функции "*внутренние*" функция *функция* компилируется как гостевого кода
C5035|Использование функции "*функция*" функция *функция* компилируется как гостевого кода
C5036|преобразование указателя на функцию VarArgs при компиляции с параметром/Hybrid: x86arm64 "*тип1*«to»*тип2*"
C5037|"*функции члена*": определение вне строки члена шаблона класса не может иметь аргументы по умолчанию
C5038|элемент данных "*член1*«будет инициализирован после элемента данных»*член2*"

## <a name="warnings-introduced-in-visual-c-2017-rtm-compiler-version-1910250170"></a>Предупреждения, появившиеся в Visual C++ 2017 RTM (версия компилятора 19.10.25017.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00__.

|||
|-|-|
C4468|«fallthrough»: атрибут может стоять метку case или метку по умолчанию
C4698|"*функция*" для оценки только и подлежит изменению или удален в будущих обновлениях.
C4839|Нестандартное использование класса*класс*"как аргумент для функции с переменным числом аргументов
C4840|непереносимое использование класса*класс*"как аргумент для функции с переменным числом аргументов

## <a name="warnings-introduced-in-visual-c-2015-update-3-compiler-version-1900242151"></a>Предупреждения, появившиеся в Visual C++ 2015 с обновлением 3 (версия компилятора 19.00.24215.1)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00.23918__.

|||
|-|-|
C4467|Использование атрибутов библиотеки ATL является устаревшим
C4596|"*имя*": Недопустимое полное имя в объявлении члена
C4598|"#include \< *заголовок*\>": номер заголовка *номер* в *источника* не соответствует *источника* по этому положение
C4599|"*аргумент*": *источника* номер аргумента *номер* не соответствует *источника*

## <a name="warnings-introduced-in-visual-c-2015-update-2-compiler-version-1900239180"></a>Предупреждения, появившиеся в Visual C++ 2015 с обновлением 2 (версия компилятора 19.00.23918.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00.23506__.

|||
|-|-|
C4466|Не удалось выполнить пропуск кучи соподпрограммы
C4595|"*класс*": не являющиеся членами функций operator new или delete не могут объявляться встроенный
C4828|Файл содержит знак, начинающийся со смещения 0 x*значение* , является недопустимым в текущей исходной кодировке (кодовая страница *номер*).
C4868|компилятор не может принудительно применить порядок вычисления слева направо в списке инициализации в фигурных скобках

## <a name="warnings-introduced-in-visual-c-2015-update-1-compiler-version-1900235060"></a>Предупреждения, появившиеся в Visual C++ 2015 с обновлением 1 (версия компилятора 19.00.23506.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:19.00.23026__.

|||
|-|-|
C4426|флагов оптимизации после включения заголовка может быть связано с #pragma optimize()
C4654|Код, помещенный перед включают предкомпилированного заголовка строки будут пропущены. Добавьте код для предкомпилированного заголовка.
C5031|#pragma warning(pop): несоответствие, состояние всплывающего предупреждения передано в другой файл
C5032|Обнаружено #pragma warning(push) без соответствующего выражения #pragma warning(POP)

## <a name="warnings-introduced-in-visual-c-2015-rtm-compiler-version-1900230260"></a>Предупреждения, появившиеся в Visual C++ 2015 RTM (версия компилятора 19.00.23026.0)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:18__.

|||
|-|-|
C4427|"*ошибка*": переполнение при делении константы, приведет к неопределенному поведению
C4438|"*тип*": не может безопасно вызываться / await: clrcompat режим. Если "*тип*" вызовы в среду CLR, может произойти повреждение заголовка CLR
C4455|"оператор *имя*": идентификаторы литеральных суффиксов, которые не начинаются с символа подчеркивания, зарезервированы
C4456|объявление "*имя*" скрывает предыдущее локальное объявление
C4457|объявление "*имя*" скрывает параметр функции
C4458|объявление "*имя*" скрывает член класса
C4459|объявление "*имя*" скрывает глобальное объявление
C4462|"*тип*": не удается определить GUID типа. Программа может завершиться ошибкой во время выполнения.
C4463|переполнения; Назначение *значение* к битовому полю может содержать только значения из *значение* для *значение*
C4473|"*функция*": передано недостаточно аргументов для строки формата
C4474|"*функция*": передано слишком много аргументов для строки формата
C4475|"*функция*": модификатор длины "*модификатор*«не может использоваться с символом поля типа»*символ*" в описателе формата
C4476|"*функция*": неизвестный символ поля типа "*символ*" в описателе формата
C4477|"*функция*": строка формата "*строка*«требуется аргумент типа»*тип*", но вариативный аргумент *номер* имеет тип "*тип*"
C4478|"*функция*": позиционные и непозиционные заполнители не может содержаться в строке формата одновременно
C4494|"*тип*": __declspec(allocator) пропускается, так как возвращаемый функцией тип не является указатель или ссылка
C4495|нестандартное расширение «__super»: замените явное имя базового класса
C4496|используется нестандартное расширение «for each»: Замените на оператор ranged-for
C4497|нестандартное расширение «sealed»: замените «final»
C4498|использовано нестандартное расширение: "*расширение*"
C4499|"*специализации*": явная специализация не может иметь класс хранилища (пропускается)
C4576|заключенный в скобки тип, за которым следует список инициализаторов является синтаксисом преобразования нестандартные явный тип
C4577|«noexcept» используемые с без указания; режима обработки исключений Прекращение по исключению не гарантируется. Задайте параметр/EHsc
C4578|«abs»: преобразование из "*тип*«to»*тип*", возможна потеря данных (подразумевался вызов "*имя*" или #include \<cmath >?)
C4582|"*тип*": конструктор не вызывается неявно
C4583|"*тип*": деструктор не вызывается неявно
C4587|"*тип*": изменение поведения: конструктор является больше не вызывается неявно
C4588|"*тип*": изменение поведения: деструктор является больше не вызывается неявно
C4589|Конструктор абстрактного класса*тип*«пропускает инициализатор для виртуального базового класса»*тип*"
C4591|ограничение глубина вызова «constexpr» *номер* превышено (/ constexpr: Depth\<номер >)
C4592|"*тип*": символ будет динамически инициализирован (ограничение реализации)
C4593|"*тип*": «constexpr» вызов evaluation шаг ограничение *значение* превышено; используйте /constexpr:steps\<номер > Чтобы увеличить предел
C4647|Изменение поведения: __is_pod (*типа*) имеет различное значение в предыдущих версиях
C4648|стандартный атрибут «carries_dependency» пропускается
C4649|атрибуты учитываются в этом контексте
C4753|Не удается найти границы для указателя; Функция MPX пропускается
C4771|Границы должны быть созданы с помощью простого указателя; Функция MPX пропускается
C4774|"*описание*": ожидаемая в аргументе строки формата *номер* — не строковый литерал
C4775|нестандартное расширение в строке формата "*строка*«функции»*функция*"
C4776|"%*символ*«не допускается в строке форматирования функции»*функция*"
C4777|"*описание*": строка формата "*строка*«требуется аргумент типа»*тип*", но вариативный аргумент *номер* имеет тип "*тип*"
C4778|"*описание*": незавершенная строка форматирования "*строка*"
C4838|преобразование из "*тип*«to»*тип*" требует сужающего преобразования
C5022|"*тип*": указано несколько конструкторов перемещения
C5023|"*тип*": заданы несколько операторов присваивания перемещения
C5024|"*объявление*": переместить конструктор неявно определен как удаленный
C5025|"*объявление*": переместить оператор присваивания неявно определен как удаленный
C5026|"*тип*": переместить конструктор неявно определен как удаленный
C5027|"*тип*": переместить оператор присваивания неявно определен как удаленный
C5028|"*имя*": выравнивание указанное в предыдущем объявлении (*номер*) не указан в определении
C5029|использовано нестандартное расширение: атрибуты выравнивания в C++ применяются к переменным, элементам данных и только типы тегов
C5030|атрибут "*атрибут*" не распознан

## <a name="warnings-introduced-in-visual-c-2013-compiler-version-1800210051"></a>Предупреждения, появившиеся в Visual C++ 2013 (версия компилятора 18.00.21005.1)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:17__.

|||
|-|-|
C4301|"*тип*": переопределение виртуальной функции отличается от "*объявление*" квалификатором const или volatile
C4316|"*тип*": объект, размещенный в куче может быть не выровнен *номер*
C4380|"*тип*": конструктор по умолчанию не может быть нерекомендуемым
C4388|"*маркера*": несоответствие со знаком и без
C4423|«std::bad_alloc»: будет перехвачен классом ("*тип*") в строке *номер*
C4424|catch для "*тип*«предшествует»*тип*" в строке *номер*; непредсказуемое поведение могло произойти, если создается исключение «std::bad_alloc»
C4425|SAL-аннотации не может применяться к «...»
C4464|относительный путь включения содержит ".."
C4575|соглашение «__vectorcall» несовместимо с "/ clr" параметр: преобразование к «__stdcall»
C4609|"*тип*«является производным от интерфейса по умолчанию»*тип*«в типе»*тип*". Используйте интерфейс по умолчанию для "*тип*", или к разрыву связи базовый/производный.
C4754|Правила преобразования арифметических операций в сравнении по *описание*(*номер*) означает, что одна ветвь не может быть выполнена. Приведение "*тип*«to»*тип*" (или к аналогичному типу из *номер* байт).
C4755|Правила преобразования арифметических операций в сравнении по *описание*(*номер*) означает, что одна ветвь не может быть выполнена встроенной функции. Приведение "*тип*«to»*тип*" (или к аналогичному типу из *номер* байт).
C4767|Имя раздела "*имя*" длиннее, чем 8 символов и будет усечено компоновщиком
C4770|частично проверенное перечисление "*имя*" используется в качестве индекса
C4827|Открытый метод «ToString» с 0 параметров должен быть помечен как виртуальный и переопределить
C4882|Передача функторы с операторами вызова неконстантной concurrency::parallel_for_each устарел
C4973|"*тип*": помечен как нерекомендованный
C4974|"*тип*": помечен как нерекомендованный
C4981|Warbird: функция "*объявление*" помеченная как __forceinline не встроена, так как она содержит семантику исключения
C4990|Warbird: *сообщения*
C4991|Warbird: функция "*объявление*", помеченная как __forceinline не встроена, так как уровень защиты встраиваемого объекта больше, чем у родительского объекта
C4992|Warbird: функция "*объявление*" помеченная как __forceinline не встроена, так как она содержит встроенную сборку, которая не может быть защищен

## <a name="warnings-introduced-in-visual-c-2012-compiler-version-1700511061"></a>Предупреждения, появившиеся в Visual C++ 2012 (версия компилятора 17.00.51106.1)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:16__.

|||
|-|-|
C4330|атрибут "*атрибут*«для раздела»*разделе*" игнорируется
C4415|повторяющиеся __declspec (code_seg ("*имя*"))
C4416|"__declspec(code_seg(...))" содержит пустую строку: игнорируется
C4417|явное создание экземпляров шаблона не может иметь "__declspec(code_seg(...))": игнорируется
C4418|"__declspec(code_seg(...))" игнорируется для перечисления
C4419|"*имя*«не действует при применении к закрытый класс ссылки»*тип*".
C4435|"*тип*": структура объекта в/vd2 изменится из-за виртуального базового "*тип*"
C4436|приведение dynamic_cast из виртуального базового "*тип*«to»*тип*" в конструктор или деструктор могут возникать ошибки с частично сконструированного объекта
C4437|приведение dynamic_cast из виртуального базового "*тип*«to»*тип*" может завершиться ошибкой в некоторых контекстах
C4443|требуется параметр директивы pragma "0", "1" или "2"
C4446|"*тип*": невозможно сопоставить член "*имя*" в этот тип, из-за конфликта с именем типа. Метод был переименован в "*имя*"
C4447|Обнаруженная без потоковая модель «main» сигнатура метода. Рассмотрите возможность использования "int основной (Platform::Array\<Platform::String ^ > ^ args)".
C4448|"*тип*" не поддерживает интерфейс по умолчанию, указанные в метаданных. Комплектации: "*тип*", который может завершиться ошибкой во время выполнения.
C4449|"*тип*" незапечатанный тип должен быть помечен как «[WebHostHidden]»
C4450|"*тип*«должен быть помечен как «[WebHostHidden]», так как он является производным от»*тип*"
C4451|"*тип*": использование класса ref*тип*"внутри этого контекста может привести к неправильному маршалингу объекта между контекстами
C4452|"*тип*": открытый тип не может быть в глобальной области. Он должен быть в пространстве имен, которое является дочерним элементом имя выходному файлу winmd.
C4453|"*тип*": не следует использовать тип «[WebHostHidden]» на опубликованной поверхности открытого типа, который не является «[WebHostHidden]»
C4454|"*тип*" перегружен превышает число входных параметров без необходимости [DefaultOverload] указан. Выбор "*объявление*" как перегрузка по умолчанию
C4471|"*имя*": у прямого объявления неограниченного перечисления должен иметь базовый тип (предполагается int)
C4472|"*имя*" является собственным перечислением: добавьте спецификатор доступа (private/public), чтобы объявить перечисление управляемых/WinRT
C4492|"*тип*": соответствует базовый метод класса ref "*тип*", но не помечен «override»
C4493|выражение DELETE не действует как деструктор класса "*тип*" не имеет доступа «public»
C4585|"*тип*': WinRT «открытый класс ссылки» должны быть запечатанными или производными от существующего незапечатанного класса
C4586|"*тип*": открытый тип не может объявляться в пространство имен верхнего уровня с именем «Windows»
C4695|#pragma кодировка_выполнения: "*аргумент*" не является поддерживаемой аргументом: поддерживается в настоящее время единственным «UTF-8"
C4703|потенциально неинициализированная локальная переменная-указатель "*имя*" используется
C4728|/ Yl-игнорируется, так как ссылка PCH
C4745|переменное обращение "*имя*" невозможно обработать из-за его размера
C4746|переменное обращение "*имя*" регулируется/volatile:\<iso\|ms > параметр; рекомендуется использовать встроенные функции __iso_volatile_load/store
C4872|с плавающей запятой операция деления на ноль, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*описание*"
C4880|приведение из "*тип*«to»*тип*": приведение снимает постоянство из указателя или ссылки может привести к неопределенному поведению в функции, ограниченной amp
C4881|конструктор или деструктор не будет вызываться для переменной tile_static "*тип*"
C4966|"*описание*" содержит примечание __code_seg с неподдерживаемым именем сегмента; игнорируется
C4988|"*тип*": переменная объявлена вне области класса или функции
C4989|"*описание*": тип имеет конфликтующие определения.

## <a name="warnings-introduced-in-visual-c-2010-compiler-version-16004021901"></a>Предупреждения, появившиеся в Visual C++ 2010 (версия компилятора 16.00.40219.01)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:15__.

|||
|-|-|
C4352|"*имя*": подставляемая функция уже определена
C4573|Использование "*тип*" требует, чтобы компилятор передал «this» но не разрешается текущим режимом отслеживания по умолчанию
C4574|"*имя*«определяется как" 0": вы имели в виду использование" #if *имя*"?
C4689|"*символ*": Неподдерживаемый знак в #pragma detect_mismatch; #pragma ignored
C4751|флаг/arch AVX не применяется к расширениям Intel(R) Streaming SIMD в пределах встроенного ASM
C4752|найти Intel(R) Advanced Vector Extensions; Рассмотрите возможность использования соответствующий флаг/arch AVX
C4837|Обнаружен триграф: "?? *символ*«заменено»*символ*"
C4986|"*объявление*": спецификация исключения не соответствует предыдущему объявлению
C4987|используется нестандартное расширение: throw (...)

## <a name="warnings-introduced-in-visual-c-2008-compiler-version-15002102208"></a>Предупреждения, появившиеся в Visual C++ 2008 (версия компилятора 15.00.21022.08)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:14__.

|||
|-|-|
C4396|"*тип*": если дружественное объявление ссылается на специализацию функции-шаблона, встроенный спецификатор не может использоваться
C4413|"*объявление*": ссылочный член инициализируется во временный объект, который не сохраняется после выхода из конструктора
C4491|"*описание*": имеет недопустимый формат версии IDL
C4603|"*имя*": макрос не определен или определение изменилось после использования предкомпилированного заголовка
C4627|"*описание*": пропущен при поиске использования предкомпилированного заголовка
C4750|"*описание*": функция с _alloca() включена в цикл
C4910|"*тип*": «__declspec(dllexport)» и «extern» несовместимы при явном создании экземпляра
C4985|"*объявление*": атрибуты отсутствуют в предыдущем объявлении.

## <a name="warnings-introduced-in-visual-c-2005-compiler-version-140050727762"></a>Предупреждения, появившиеся в Visual C++ 2005 (версия компилятора 14.00.50727.762)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:13__.

|||
|-|-|
C4000|НЕИЗВЕСТНОЕ предупреждение выберите команду технической поддержки в меню справки Visual C++ или откройте Справочный файл технической поддержки, Дополнительные сведения
C4272|"*тип*": помечается как __declspec(dllimport); при импорте функции необходимо указать собственное соглашение о вызове.
C4333|"*выражение*": сдвиг вправо слишком большое значение, потери данных
C4334|"*выражение*": результат 32-разрядного смещения неявно преобразуется в 64 бита (был 64-разрядное смещение?)
C4335|Обнаружен файл в формате Mac: преобразуйте исходный файл в формат DOS или UNIX
C4342|Изменение поведения: "*тип*" вызван, но был вызван оператор-член в предыдущих версиях
C4350|Изменение поведения: "*объявление*«вызывается вместо»*объявление*"
C4357|найден аргумент массива параметров в списке формальных аргументов для делегата "*объявление*«не учитывается при создании»*тип*"
C4358|"*выражение*": тип возвращаемого значения объединенных делегатов не может быть «void», возвращаемое значение не определено
C4359|"*тип*": описатель выравнивания меньше, чем текущее выравнивание (*номер*) и будет игнорироваться.
C4362|"*тип*": выравнивание, превышающее 8 байт не поддерживается в среде CLR
C4364|#using для сборки "*имя*" ранее использовалась в *описание*(*номер*) без атрибута as_friend; as_friend не применяется
C4365|"*выражение*": преобразование из "*тип*«to»*тип*", несоответствие со знаком и без
C4366|Результатом унарного "*оператор*" оператор может быть невыровненным
C4367|Преобразование из "*тип*«to»*тип*" может вызвать исключение неверного выравнивания типа данных
C4368|не удается определить "*имя*«как управляемую является членом»*тип*": смешанные типы не поддерживаются.
C4369|"*тип*": значение перечислителя "*номер*«не может быть представлено как»*тип*«, значение —»*номер*"
C4374|"*объявление*": метод интерфейса не будет реализован невиртуальным методом "*объявление*"
C4375|не являющийся открытым метод "*объявление*«не переопределяет»*объявление*"
C4376|спецификатор доступа "*описатель*:" больше не поддерживается: используйте "*описатель*:" вместо
C4377|собственные типы являются закрытыми по умолчанию; -d1PrivateNativeTypes запрещен
C4378|Необходимо получить указатели функций для запуска инициализаторов; Рассмотрите вариант System::ModuleHandle::
C4379|Версия *версии* общий язык среды выполнения не поддерживается на этом компьютере. С помощью этой версии может привести к непредвиденным результатам
C4381|"*объявление*": метод интерфейса не будет реализован методом закрытые "*объявление*"
C4382|Создание "*тип*": тип с деструктором __clrcall или конструктором копий можно перехватить только в/CLR: pure модуля
C4383|"*тип*": значение разыменования дескриптора может измениться, когда определяемый пользователем "*оператор*" оператор существует; запишите оператор в виде статической функции явное операнд
C4384|#pragma "*директива*" следует использовать только в глобальной области видимости
C4393|"*тип*": const не влияет на *описание* данные-член; игнорируется
C4394|"*тип*": символ по доменам приложения не должны быть помечены __declspec (*значение*)
C4395|"*тип*": функция-член будет вызываться для копии данных initonly "*тип*"
C4397|DefaultCharSetAttribute игнорируется
C4398|"*тип*": глобальный объект для каждого процесса, могут работать неправильно с несколькими доменами приложений; рассмотрите возможность использования __declspec(appdomain)
C4399|"*тип*": символ для каждого процесса не должны быть помечены __declspec (*значение*) при компиляции с параметром/clr: pure
C4400|"*тип*": квалификаторы const или volatile для этого типа не поддерживаются.
C4412|"*объявление*": подпись функции содержит тип "*тип*"; Объекты C++ небезопасно передавать между кодом чистого и смешанного или собственного.
C4429|Возможные неполные или неправильно сформированный универсальное имя символа
C4430|отсутствует спецификатор типа — предполагается int. Примечание: C++ не поддерживает int по умолчанию
C4431|отсутствует спецификатор типа — предполагается int. Примечание. C++ не поддерживает тип int по умолчанию
C4434|статический конструктор должен иметь режим доступа private; закрытый доступ
C4439|"*тип*": определение функции с управляемым типом в сигнатуре должно иметь соглашение вызова __clrcall
C4441|соглашение вызова "*соглашение*" игнорируется; "*соглашение*" использовано
C4445|"*объявление*": в типе WinRT или управляемого виртуальный метод не может быть закрытым
C4460|Оператор CLR или WinRT "*тип*", имеет параметр, передаваемый по ссылке. Оператор CLR или WinRT "*оператор*«имеет разные семантики оператора C++»*оператор*", предполагается ли передавать по значению?
C4461|"*тип*": этот класс содержит метод завершения "! *Тип*", но нет деструктора" ~*тип*"
C4470|директивы pragma контроля плавающей учитывается в/CLR
C4480|использовано нестандартное расширение: указание базового типа для перечисления "*тип*"
C4481|использовано нестандартное расширение: спецификатор переопределения "*описатель*"
C4482|использовано нестандартное расширение: перечисление "*тип*" использован в полном имени
C4483|Синтаксическая ошибка: требуется ключевое слово C++
C4484|"*тип*": соответствует базовый метод класса ref "*тип*", но не помечен как «virtual», «new» или «override»; предполагается «new» (и не «virtual»)
C4485|"*тип*": соответствует базовый метод класса ref "*тип*", но не помеченные «new» или «override»; предполагается «new» (и «virtual»)
C4486|"*тип*": закрытый виртуальный метод класса ref или класса значений должен быть помечен как «sealed»
C4487|"*тип*": совпадения наследуется невиртуальному методу "*тип*", но не помечен явно как «new»
C4488|"*тип*": требуется "*ключевое слово*«ключевое слово для реализации метода интерфейса»*тип*"
C4489|"*ключевое слово*": не допускается в методе интерфейса "*имя*"; спецификаторы допустимы только в методы класса ref класса и значение переопределения
C4490|"*ключевое слово*": Неправильное использование спецификатора переопределения; "*тип*" не соответствует методу базового класса
C4538|"*тип*": квалификаторы const или volatile для этого типа не поддерживаются.
C4559|"*тип*": переопределение; __declspec прирост функция (*значение*)
C4565|"*тип*": переопределение; символ был объявлен ранее при помощи __declspec (*значение*)
C4566|символ, представленный универсальное имя символа "*символ*" не могут быть представлены в текущей кодовой странице (*номер*)
C4568|"*тип*": не член не соответствует сигнатуре явного переопределения
C4569|"*тип*": не член не соответствует сигнатуре явного переопределения
C4570|"*тип*": не был объявлен явно как абстрактный, однако содержит абстрактные функции
C4571|Сведению: семантика catch(...) изменилась Visual C++ 7.1; структурированные исключения (SEH) более не перехватываются
C4572|Атрибут [ParamArray] не рекомендуется использовать с параметром/CLR, используйте «...» вместо
C4580|[attribute] рекомендуется; Вместо этого укажите *указанного*атрибут в качестве базового класса
C4581|Рекомендуется использовать поведение: "»*имя*«" Заменить "*имя*" для обработки атрибута
C4606|#pragma warning: "*номер*" игнорируется; Предупреждения анализа кода не связаны с уровнями предупреждений
C4631|MSXML или XPath недоступны, комментарии XML-документа не будут обработаны. *description*
C4632|Комментарий XML-документа: *описание* -отказано в доступе: *описание*
C4633|Комментарий XML-документа*описание*: ошибка: *описание*
C4634|Комментарий XML-документа*описание*: невозможно применить: *описание*
C4635|Комментарий XML-документа*описание*: неправильно сформированный XML: *описание*
C4636|Комментарий XML-документа*описание*: тегу необходим непустой "*описание*" атрибута.
C4637|Комментарий XML-документа*описание*: \<включают > тега удаляется. *description*
C4638|Комментарий XML-документа*описание*: ссылка на неизвестный символ "*описание*".
C4639|Ошибка MSXML, не будут обрабатываться комментарии XML-документа. *description*
C4641|Документирующем комментарии XML присутствует неоднозначная перекрестная ссылка:
C4678|базовый класс*объявление*«является менее доступным, чем»*имя*"
C4679|"*описание*": не удается импортировать член
C4687|"*тип*": Запечатанный абстрактный класс не может реализовывать интерфейс "*тип*"
C4688|"*имя*": список ограничений содержит частный тип сборки "*объявление*"
C4690|\[ emitidl (pop)]: занесений
C4691|"*тип*": ожидался в неиспользуемых *модуль* "*описание*", тип, определенный в текущей записи преобразования вместо этого использовать
C4692|"*имя*": подпись не частного члена содержит частный собственный тип сборки "*объявление*"
C4693|"*тип*": Запечатанный абстрактный класс не может быть членов экземпляра*имя*"
C4694|"*тип*": Запечатанный абстрактный класс не может иметь базового класса*тип*"
C4720|в отчеты встроенного ассемблера: "*описание*"
C4721|"*описание*": недоступен, так как встроенная функция
C4722|"*описание*": деструктор не возвращает ресурсы, возможна утечка памяти
C4726|ARM arch4/4T поддерживается только "\<cpsr_f > или \<spsr_f >" со значением интерпретации
C4727|PCH-ФАЙЛ с именем *имя* с одинаковой меткой времени в *имя* и *имя*.  Используется первый PCH.
C4729|слишком большая функция для предупреждений, основанных на оптимизации структуры кода
C4730|"*описание*": смешение _m64 и с плавающей запятой, выражения могут стать неправильный код
C4731|"*описание*": регистр указателя фрейма "*зарегистрировать*" изменено встроенного кода ассемблера
C4732|функция "*внутренние*" не поддерживается в этой архитектуре
C4733|Присваивание для «FS:0»: обработчик не зарегистрирован как безопасный
C4734|Более чем 64k номера строк в формате COFF отладку, info; остановить, создающие номеров строк отладки COFF для модуля "*модуль*"
C4738|хранение результатов в памяти в 32-разрядном формате с плавающей запятой, возможно снижение производительности
C4739|ссылка на переменную "*переменной*" пределы ее области хранения
C4740|поток в или встроенного ассемблерного кода препятствуют глобальной оптимизации
C4742|"*переменной*«имеет различное выравнивание»*расположение*«и»*расположение*": *номер* и *номер*
C4743|"*имя*«имеет различный размер»*расположение*«и»*расположение*": *номер* и *номер* байт
C4744|"*имя*«имеет другой тип»*расположение*«и»*расположение*": "*тип*«и»*тип*"
C4747|Вызов управляемого "*тип*": управляемый код может не выполняться во время блокировки загрузчика, точки входа библиотеки DLL и поступившим из них вызовам
C4761|Несоответствие полного размера в аргументе; преобразование
C4764|Для перехваченных объектов выравнивание не может превышать 16 байт
C4788|"*идентификатор*": идентификатор усечен до "*номер*" символов
C4789|буфер "*имя*" размера *номер* байт будет переполнен; *номер* байт будет записано начиная с позиции *номер*
C4801|Возврат по ссылке не поддается проверке: *описание*
C4819|Файл содержит символ, который невозможно представить в текущей кодовой странице (*номер*). Сохраните файл в формате Юникода для предотвращения потери данных
C4826|Преобразование из "*тип*«to»*тип*" выполняется с расширением знака. Это может привести к непредсказуемому поведению среды выполнения.
C4829|Возможно, неверные параметры для функции main. Рассмотрите возможность "int основной (Platform::Array\<Platform::String ^ > ^ argv)"
C4835|"*тип*": инициализатор экспортированных данных не будет выполнено до управляемого кода сначала в базовой сборке
C4867|"*тип*": нестандартный синтаксис; используйте «&», чтобы создать указатель на член
C4936|Данный __declspec поддерживается только при компиляции с параметрами /clr или /clr:pure
C4937|"*имя*«и»*имя*«неразличимы как аргументы для»*параметр*"
C4938|"*тип*": переменная сокращения плавающей точки может привести к несогласованным результатам/fp: strict или #pragma fenv_access
C4939|не рекомендуется использовать директиву #pragma vtordisp, в следующих версиях Visual C++ ее не будет
C4947|"*тип*": помечен как устаревший
C4949|директивы pragma «managed» и «unmanaged» имеют смысл только в том случае, при компиляции с "/ clr [: option]"
C4950|"*тип*": помечен как устаревший
C4955|"*описание*": Импорт игнорируется; уже импортирован из "*источника*"
C4956|"*тип*": этот тип недоступен
C4957|"*выражение*": явное приведение из "*тип*«to»*тип*" недоступен
C4958|"*выражение*": арифметика указателей не поддается проверке
C4959|не удается определить неуправляемый *класс* "*тип*" в/CLR: safe, поскольку доступ к ее членам выдает код, недоступный для проверки
C4960|"*описание*" слишком велик для профилирования
C4961|Данные профилирования не были включены в "*расположение*", оптимизация, зависимая от профиля, отключена
C4962|"*описание*": оптимизация, зависимая от профиля, отключена, поскольку операции оптимизации приводят к несогласованности данных профиля
C4963|"*описание*": данные профилирования не найдены; в сборке инструментария использовались разные параметры компилятора
C4964|Параметры оптимизации не указаны; сведения о профиле не будут собраны.
C4965|неявная упаковка целого числа 0; используйте nullptr или явное приведение
C4970|конструктор делегата: целевой объект учитывается с момента "*объявление*" является статическим
C4971|Порядок аргументов: \<целевой объект >, \<Целевая функция > для конструктора делегата является устаревшим, используйте \<Целевая функция >, \<целевой объект >
C4972|Прямое изменение или обработка результатов операции распаковки в виде левостороннего значения недоступны для проверки

## <a name="warnings-introduced-in-visual-c-2003-compiler-version-13103077"></a>Предупреждения, появившиеся в Visual C++ 2003 (версия компилятора 13.10.3077)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:13.00.9466__.

|||
|-|-|
C4343|#pragma optimize (*описание*, off) переопределяет параметр /Og
C4344|Изменение поведения: использование явного шаблона приводит аргументы в вызове "*объявление*"
C4346|"*тип*": зависимое имя не является типом
C4348|"*объявление*": переопределение параметра по умолчанию: параметр *номер*
C4356|"*тип*": статические данные-член не могут быть инициализированы в производном классе
C4408|анонимные *структуры* не объявляет никаких элементов данных
C4544|"*объявление*": аргумент шаблона, пропускается в этом объявлении шаблона по умолчанию
C4545|вычисление выражения перед запятой дает функцию, в которой отсутствует список аргументов
C4546|в вызове функции перед запятой отсутствует список аргументов
C4547|"*выражение*": оператор перед запятой не имеет результата; требуется оператор с побочным действием
C4548|выражение перед запятой не имеет результата; требуется выражение с побочным действием
C4549|"*выражение*": оператор перед запятой не имеет результата; вы хотели "*выражение*"?
C4628|диграфы не поддерживаются при наличии параметра -Ze. Последовательность символов "*последовательности*«не интерпретируется как альтернативную лексему»*маркера*"
C4629|использован диграф, последовательность знаков "*последовательности*«интерпретируется как маркер»*маркера*" (Вставить пробел между двумя символами, если это необходимо)
C4671|"*описание*": конструктор копий недоступен
C4676|"*описание*": деструктор недоступен
C4677|"*имя*": подпись не частного члена содержит частный тип сборки "*объявление*"
C4686|"*тип*": возможное изменение поведения, изменение возвращаемого значения UDT соглашение о вызовах
C4812|устаревший стиль объявления: используйте "*тип*::*имя*" вместо
C4813|"*тип*": дружественная функция локального класса должна быть предварительно объявлена
C4821|Не удалось определить тип кодировки Юникод; сохраните файл с сигнатурой (BOM)
C4822|"*тип*": функция-член локального класса не имеет тела
C4823|"*тип*": использует закрепленные указатели, но очистки семантика не включены. Рассмотрите возможность использования/EHa
C4913|пользовательский двоичный оператор "," существует, но ни одной перегрузке не удалось преобразовать все операнды, по умолчанию использован встроенный двоичный оператор ","
C4948|Тип возвращаемого значения "*объявление*" не соответствует последнему типу параметра задающей функции
C4951|"*описание*" была изменена после сбора данных профилирования данные профиля функции не используются
C4952|"*описание*": данные профилирования не найдены в базе данных программы "*описание*"
C4953|Встраиваемого метода "*описание*" изменена после профилирования были собраны данные, данные профилирования не используются
C4954|"*описание*": не профилироваться (содержит выражение switch __int64)

## <a name="warnings-introduced-in-visual-c-2002-compiler-version-13009466"></a>Предупреждения, появившиеся в Visual C++ 2002 (версия компилятора 13.00.9466)

Эти предупреждения и все предупреждения в более поздних версиях, подавляются с помощью параметра компилятора __/Wv:12__.

|||
|-|-|
C4096|"*тип*": интерфейс не является COM-интерфейса; он не будет передан в IDL
C4097|требуется параметр директивы pragma: "restore" или "off"
C4165|«HRESULT» преобразуется в «bool»; Вы уверены, что это то, что нужно?
C4183|"*имя*": отсутствие возвращаемого типа; предполагается, что функция-член, возвращающая «int»
C4199|*description*
C4255|"*имя*": не представлен прототип функции: преобразование «()» в «(void)»
C4256|"*объявление*": конструктор класса с виртуальными базами содержит «...»; вызовы могут оказаться несовместимыми с более ранними версиями Visual C++
C4258|"*имя*": определение из цикла for игнорируется; используется определение из внешней области видимости
C4263|"*объявление*": функция-член не переопределяет ни одной функции виртуальный член базового класса
C4264|"*объявление*": нет доступного переопределения для виртуальной функции-члена базового класса "*класс*"; функция скрыта
C4265|"*тип*": класс имеет виртуальные функции, но деструктор не является виртуальным экземпляры этого класса не может быть корректно уничтожены
C4266|"*объявление*": нет доступного переопределения для виртуальной функции-члена базового класса "*класс*"; функция скрыта
C4267|"*выражение*": преобразование из «size_t» в "*тип*", возможна потеря данных
C4274|#ident игнорируется; см. документацию для #pragma comment (exestr, "string")
C4277|импортированный элемент "*тип*::*имя*" существует как элемент данных и функции-члена; пропуск данных-члена
C4278|"*имя*": идентификатор в библиотеке типов "*описание*" уже является макроопределением; используйте квалификатор «rename»
C4279|"*имя*": идентификатор в библиотеке типов "*описание*" является зарезервированным словом; используйте квалификатор «rename»
C4287|"*выражение*": несовпадение константы без знака или отрицательной
C4288|использовано нестандартное расширение: "*имя*": переменная цикла, объявленная в цикле for используется снаружи цикла; это противоречит объявлению во внешней области
C4289|использовано нестандартное расширение: "*имя*": переменная цикла, объявленная в цикле for, используется вне области цикла for
C4293|"*выражение*": отрицательное или слишком велик, неопределенное поведение
C4295|"*тип*": массив слишком мал, чтобы включить завершающий нуль-символ
C4296|"*выражение*": выражение всегда имеет *значение*
C4297|"*тип*": ожидается, что функция не будет выдавать исключение, но не
C4298|"*имя*": идентификатор в библиотеке типов "*описание*" уже является макроопределением; переименование в "__*имя*"
C4299|"*имя*": идентификатор в библиотеке типов "*описание*" является зарезервированным словом; переименование в "__*имя*"
C4302|"*выражение*": усечение из "*тип*«to»*тип*"
C4303|*преобразование* из "*тип*«to»*тип*" является устаревшим, используйте static_cast, __try_cast или dynamic_cast
C4314|требуется параметр директивы pragma "32" или "64"
C4315|"*тип*": указатель «this» для элемента "*тип*" может быть не выровнен *номер* правильно с помощью конструктора
C4318|Передача нулевой константы в качестве длины memset
C4319|"*выражение*": ноль расширение "*тип*«to»*тип*" большего размера
C4321|Автоматическое создание IID для интерфейса "*тип*"
C4322|Автоматическое создание CLSID для класса*тип*"
C4323|повторное использование CLSID для класса*тип*"
C4324|"*тип*": структура была дополнена нулями из-за описателя выравнивания
C4325|атрибуты для стандартного раздела "*описание*" игнорируется
C4326|Тип возвращаемого значения "*имя*«должно быть»*тип*«вместо of»*тип*"
C4327|"*выражение*": выравнивание косвенного обращения LHS (*номер*) больше, чем RHS (*номер*)
C4328|"*описание*": выравнивание косвенного обращения для формального параметра *номер* (*номер*) больше, чем выравнивание реального аргумента (*номер*)
C4329|Описатель выравнивания игнорируется для перечисления
C4336|Импорт библиотеки типов "*библиотеки*«прежде чем импортировать»*описание*"
C4337|Библиотека типов "*библиотеки*«in»*описание*" автоматически импортируется
C4338|#pragma *описание*: стандартного раздела "*разделе*" используется
C4339|"*тип*": обнаружено использование неопределенного типа в метаданных среды CLR или WinRT применение этого типа может вызвать исключение времени выполнения
C4353|использовано нестандартное расширение: константа 0 в качестве выражения функции.  Вместо этого используйте функцию «__noop»
C4370|"*объявление*": размещение класса изменилось с предыдущей версией компилятора из-за улучшенной упаковки
C4371|"*объявление*": размещение класса могло измениться с предыдущей версии компилятора из-за улучшенной упаковки члена "*член*"
C4373|"*тип*": переопределения виртуальных функций*объявление*", предыдущие версии компилятора не выполняли переопределение, когда параметры только квалификаторами const или volatile
C4387|"*описание*": считалось
C4389|"*выражение*": несоответствие со знаком и без
C4391|"*объявление*": неправильный возвращаемый тип для подставляемой функции; ожидается "*тип*"
C4392|"*объявление*": неверное число аргументов для подставляемой функции; ожидается "*номер*" аргументов
C4407|приведение между разных представлениями указателя на член, компилятор может создать неправильный код
C4420|"*имя*": оператор недоступен, используется "*имя*"; проверки во время выполнения могут быть скомпрометированы
C4440|переопределения соглашения о вызове "*описание*«to»*описание*" игнорируется
C4442|внедренные завершающий нуль-символ в аргументе __annotation.  Значение будет усечено.
C4444|"*имя*": верхнего уровня «__unaligned» не реализована в этом контексте
C4526|"*тип*": статическая функция-член не может переопределить виртуальную функцию "*объявление*" игнорируются, переопределение виртуальной функции будет скрыта
C4531|Обработка исключений C++ не доступна в Windows CE. Использование структурированной обработки исключений
C4532|"*описание*": выйти из *наконец* блок не определено поведение при обработке завершения
C4533|Инициализация "*объявление*" пропускается "goto *объявление*"
C4534|"*объявление*" не будет конструктором по умолчанию для *класс* "*тип*" из-за аргумента по умолчанию
C4535|для Calling _set_se_translator() требуется/EHa
C4536|"*описание*": имя типа превышает ограничение метаданных "*номер*" символов
C4537|"*объявление*": "." применен к типу не UDT
C4542|Пропуск автоматического создания объединенного файла подставляемого текста, не удается записать *тип* файл: "*filename*": *ошибка*
C4543|Введенный текст запрещен атрибутом "не\_injected_text"
C4555|выражение не имеет результата; требуется выражение с побочным действием
C4557|«__assume» содержит эффект "*эффект*"
C4558|значение операнда "*номер*«выходит за пределы диапазона»*номер* - *номер*"
C4561|соглашение «__fastcall» несовместимо с "/ clr" параметр: преобразование к «__stdcall»
C4562|требуются полные прототипы функций с "/ clr" параметр: преобразование «()» в «(void)»
C4564|метод "*имя*" из *класс* "*тип*«определяет неподдерживаемый параметр по умолчанию»*параметр*"
C4584|"*тип*": базовый класс*объявление*«уже является базовым классом для»*объявление*"
C4608|Инициализация нескольких элементов объединения: "*тип*«и»*тип*"
C4619|#pragma warning: нет предупреждения с номером "*номер*"
C4623|"*тип*": конструктор по умолчанию неявно определен как удаленный
C4624|"*тип*": деструктор неявно определен как удаленный
C4625|"*тип*": конструктор копий неявно определен как удаленный
C4626|"*тип*": оператор присваивания неявно определен как удаленный
C4645|функция, объявленная с атрибутом «noreturn» имеет оператор return
C4646|функция, объявленная с атрибутом «noreturn» имеет тип возвращаемого значения, отличные от void
C4659|#pragma "*описание*": использовании зарезервированного сегмента "*имя*" поведение не определено; используйте #pragma comment (linker,...)
C4667|"*объявление*": функция шаблон не определен, соответствующий принудительному созданию экземпляра
C4668|"*имя*«не определен в качестве макроса препроцессора, замена на"0"для»*значение*"
C4669|"*выражение*": небезопасное преобразование: "*тип*" является объектом типа управляемых/WinRT
C4674|"*имя*" должен быть объявлен как «static» и иметь ровно один параметр
C4680|"*тип*": компонентный класс не указывает интерфейс по умолчанию
C4681|"*тип*": компонентный класс не указывает интерфейс по умолчанию, который является источником событий
C4682|"*тип*": не указан атрибут параметра направления, по умолчанию принимается [in]
C4683|"*объявление*": у источника события имеется «out»-параметра; соблюдайте осторожность при использовании нескольких обработчиков события
C4684|"*описание*": предупреждение!! атрибут может привести к недействительного кода: используйте с осторожностью
C4685|требуется "> >", имеется ">>" в результате синтаксического разбора параметров шаблона
C4700|неинициализированная локальная переменная "*имя*" используется
C4701|потенциально неинициализированная локальная переменная "*имя*" используется
C4702|недостижимый код
C4711|функция "*имя*" выбрана для автоматического подстановки
C4714|функция "*объявление*" помеченная как __forceinline, не встроена
C4715|"*функция*": не все пути возвращают значение
C4716|"*функция*": должен возвращать значение
C4717|"*функция*": рекурсия на всех путях, функция вызовет переполнение стека среды выполнения
C4718|"*функция*": рекурсивный вызов не имеет побочных эффектов, удаление
C4719|Обнаружена при указанном параметре Qfast - используйте «f» в качестве суффикса для задания одинарной точности Double константа
C4723|возможное деление на 0
C4724|возможный остаток от деления на 0
C4725|инструкция может оказаться неправильной на некоторых процессорах Pentium
C4757|Индекс является большое значение без знака, предполагалась отрицательная константа?
C4772|#import ссылается на тип из отсутствующей библиотеки типов; "*описание*" используется в качестве заполнителя
C4792|функция "*функция*" объявлен с использованием sysimport и на которые имеются ссылки из машинного кода; импортируйте библиотеку, необходимую для связывания
C4794|Сегмент переменной локальное хранилище потока "*имя*«изменилось с»*сегмент*«to»*сегмент*"
C4798|машинный код, созданный для функции p-code "*имя*" с обработчиком исключений или семантику очистки
C4799|функция "*имя*" не имеет инструкции EMMS
C4803|"*объявление*": класс хранения, отличную от события, имеет метода raise "*объявление*"
C4810|значение pragma pack(show) == *номер*
C4811|значение pragma conform (forScope, show) == *значение*
C4820|"*тип*": "*номер*" байтовые поля добавлены после *тип* "*тип*"
C4905|приведение двухбайтового строкового литерала к "*тип*"
C4906|приведение строкового литерала к "*тип*"
C4912|"*атрибут*": атрибут приводит к неопределенному поведению во вложенных UDT
C4916|Чтобы получить идентификатор dispid, "*тип*": должна быть вызваны интерфейс
C4917|"*тип*": идентификатор GUID может быть связан только с классом, интерфейсом или пространством имен
C4918|"*символ*": недопустимый символ в списке оптимизации директивы pragma
C4920|Перечисление *имя* член *имя*=*номер* уже появлялся в перечислении *имя* как *имя* = *номер*
C4921|"*имя*": значение атрибута "*значение*" указывать не нужно умножить значения
C4925|"*объявление*": метод disp-интерфейса нельзя вызвать из скрипта
C4926|"*объявление*": символ уже определен: атрибуты пропущены
C4927|Недопустимое преобразование; неявно применены несколько пользовательских преобразований
C4928|недопустимая инициализация копии; неявно применено несколько пользовательских преобразований
C4929|"*описание*": библиотека типов содержит объединение; пропуск квалификатора «embedded_idl»
C4930|"*объявление*": функция с прототипом не вызвана (был предполагалось определение переменной?)
C4931|предполагается, библиотека типов была собрана для *номер*-разрядных указателей
C4932|__identifier (*описание*) и __identifier (*описание*) неразличимы
C4934|«__delegate(multicast)» является устаревшим, используйте «__delegate»
C4935|спецификатор уровня доступа сборки изменен из "*описание*"
C4944|"*имя*": не удается импортировать символ из "*источника*": как*объявление*"уже существует в текущей области
C4945|"*имя*": не удается импортировать символ из "*источника*": как*объявление*«уже был импортирован из другой сборки»*источника*"
C4946|reinterpret_cast между связанными классами: "*объявление*«и»*объявление*"
C4995|"*имя*": имя помечено как #pragma deprecated
C4996|"*проблема*": *описание*
C4997|"*тип*": компонентный класс не реализует COM-интерфейс или псевдоинтерфейс
C4998|Ошибка ОЖИДАНИЯ: *описание*(*номер*)

## <a name="see-also"></a>См. также

- [Параметр компилятора/wv](../../build/reference/compiler-option-warning-level.md)
- [Выключенные по умолчанию предупреждения компилятора](../../preprocessor/compiler-warnings-that-are-off-by-default.md)
- [warning](../../preprocessor/warning.md)
