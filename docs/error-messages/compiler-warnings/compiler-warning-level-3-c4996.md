---
title: Предупреждение компилятора (уровень 3) C4996 | Документация Майкрософт
ms.custom: ''
ms.date: 11/17/2017
ms.technology:
- cpp-diagnostics
ms.topic: error-reference
f1_keywords:
- C4996
dev_langs:
- C++
helpviewer_keywords:
- C4996
ms.assetid: 926c7cc2-921d-43ed-ae75-634f560dd317
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 4ed220aad7dd90ff2b5ca97c4cf5160fd4d00ed4
ms.sourcegitcommit: a3c9e7888b8f437a170327c4c175733ad9eb0454
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/29/2018
ms.locfileid: "50204578"
---
# <a name="compiler-warning-level-3-c4996"></a>Предупреждение компилятора (уровень 3) C4996

Компилятор обнаружил устаревшее объявление. **Это предупреждение всегда является намеренным сообщение от автора библиотеки или файле заголовка, что не следует использовать нерекомендуемый символ ясны не.** Фактический предупреждающее сообщение указывается модификатор устаревания или атрибут на сайте объявления.

Ниже приведены некоторые распространенные C4996 сообщения, создаваемые библиотеки времени выполнения C и стандартной библиотеки, но не является исчерпывающим. Перейдите по ссылкам, или ознакомьтесь со способами для устранения проблемы или отключить это предупреждение.

- [Имя POSIX для этого элемента устарело. Вместо этого используйте имя, соответствующее стандарту ISO C и C++: *новое_имя*. See online help for details.](#posix-function-names) (Функция или переменная может быть небезопасной. Используйте strncpy_s. Дополнительные сведения см. в справке.)

- [Эта функция или переменная может быть небезопасным. Рассмотрите возможность использования *safe_version* вместо этого. Чтобы отключить об устаревании, используйте \_CRT\_SECURE\_нет\_ПРЕДУПРЕЖДЕНИЯ.  See online help for details.](#unsafe-crt-library-functions) (Функция или переменная может быть небезопасной. Используйте strncpy_s. Дополнительные сведения см. в справке.)

- ["std::*имя_функции*::\_Unchecked\_итераторы::\_Deprecate" вызов std::*имя_функции*с параметрами, которые могут быть небезопасными — этот вызов подразумевает вызывающий объект для проверки правильности переданных значений. Чтобы отключить это предупреждение, используйте -D_SCL_SECURE_NO_WARNINGS. См. в разделе документации по использованию Visual C++ «Проверяемых итераторов»](#unsafe-standard-library-functions)

- [Эта функция или переменная было заменено более новые функциональные возможности библиотеки или операционной системы. Рассмотрите возможность использования *new_item* вместо этого. See online help for details.](#obsolete-crt-functions-and-variables) (Функция или переменная может быть небезопасной. Используйте strncpy_s. Дополнительные сведения см. в справке.)

## <a name="cause"></a>Причина

Предупреждение C4996 возникает, когда компилятор обнаруживает функцию или переменную, помеченную как [устаревшим](../../cpp/deprecated-cpp.md) с помощью `__declspec(deprecated)` модификатор, или при попытке получить доступ к функции, член класса или типа с C ++ 14 [ \[ \[устаревшим\] \] ](../../cpp/attributes.md) атрибута. Можно использовать `__declspec(deprecated)` модификатор или `[[deprecated]]` атрибут самостоятельно в библиотеки и файлов заголовков, чтобы предупреждать клиентов о устаревшие функции, переменные, члены и определения типов.

## <a name="remarks"></a>Примечания

Многие функции, функции-члены, функции шаблонов и глобальных переменных в библиотеках в Visual Studio, помечаются как *устаревшим*. Эти функции являются устаревшими, так как они могут иметь разные предпочтительные имена, могут небезопасными или иметь более безопасный вариант, либо могут быть устаревшими. Многие сообщения об устаревании входить предложенная замена устаревшей функции или глобальной переменной.

Чтобы устранить эту проблему, мы обычно рекомендуем изменить код, чтобы вместо этого используйте предложенные безопаснее или добавлены следующие функции и глобальные переменные. Если необходимо использовать существующие функции или переменные в целях переносимости, предупреждение можно отключить.

### <a name="to-turn-the-warning-off-without-fixing-the-issue"></a>Чтобы отключить это предупреждение без исправления проблемы

Предупреждение для определенной строки кода можно отключить с помощью [предупреждение](../../preprocessor/warning.md) директивы pragma `#pragma warning(suppress : 4996)`. Можно также отключить предупреждения в файле с помощью директивы #pragma warning `#pragma warning(disable : 4996)`.

Можно отключить предупреждение глобально в сборках командной строки с помощью **/wd4996** параметр командной строки.

Чтобы отключить предупреждения для всего проекта в Интегрированной среде разработки Visual Studio:

- Откройте **страницы свойств** диалоговое окно для вашего проекта. Сведения о том, как с помощью диалогового окна страницы свойств, см. в разделе [страницы свойств](../../ide/property-pages-visual-cpp.md).
- Выберите **свойства конфигурации**, **C/C++**, **Дополнительно** страницы.
- Изменить **отключить некоторые предупреждения** свойство, добавляемое `4996`. Выберите **ОК** для применения изменений.

Можно также использовать макросы препроцессора для отключения определенных классов, определенных для предупреждения о нерекомендуемых функциях, которые используются в библиотеках. Ниже приведено описание этих макросов.

Определение макроса препроцессора в Visual Studio:

- Откройте **страницы свойств** диалоговое окно для вашего проекта. Сведения о том, как с помощью диалогового окна страницы свойств, см. в разделе [страницы свойств](../../ide/property-pages-visual-cpp.md).
- Разверните **свойства конфигурации > C/C++ > препроцессор**.
- В **определения препроцессора** свойства, добавьте имя макроса. Нажмите кнопку **ОК** для сохранения изменений, а затем выполните повторную сборку проекта.

Чтобы определить макрос только в определенных исходных файлах, добавьте строку, такие как `#define EXAMPLE_MACRO_NAME` перед любой строкой, которая включает файл заголовка.

## <a name="specific-c4996-messages"></a>Определенные сообщения C4996

Ниже приведены некоторые распространенные источники ошибки и предупреждения C4996.

### <a name="posix-function-names"></a>Имена POSIX-функция

**Имя POSIX для этого элемента устарело. Вместо этого используйте имя, соответствующее стандарту ISO C и C++:** *новое_имя*. **См. в разделе сведений о справке в Интернете.**

Microsoft переименовала некоторые функции POSIX в CRT для обеспечения соответствия с C99 и правила C ++ 03 для имен глобальных функций, задаваемых в реализации. Только исходные имена POSIX являются устаревшими, не сами функции. В большинстве случаев к имени функции POSIX добавляется символ подчеркивания в начале, чтобы создать имя, соответствующее стандартам. Компилятор выдает предупреждение об устаревании первоначальное имя функции и предлагает предпочтительное имя.

Чтобы устранить эту проблему, мы обычно рекомендуем изменить код, чтобы вместо этого используйте имена функций, предлагаемых. Тем не менее новые имена, характерные для Майкрософт. Если необходимо использовать существующие имена функций в целях переносимости, то отключить эти предупреждения. Функции POSIX по-прежнему доступны в библиотеке в разделе первоначальные имена.

Чтобы отключить предупреждения об устаревании для этих функций, задайте макрос препроцессора  **\_CRT\_NONSTDC\_нет\_ПРЕДУПРЕЖДЕНИЯ**. Можно определить этот макрос в командной строке, включив параметр `/D_CRT_NONSTDC_NO_WARNINGS`.

### <a name="unsafe-crt-library-functions"></a>Небезопасные функции библиотеки CRT

**Эта функция или переменная может быть небезопасным. Рассмотрите возможность использования** *safe_version* **вместо этого. Чтобы отключить об устаревании, используйте \_CRT\_SECURE\_нет\_ПРЕДУПРЕЖДЕНИЯ.  See online help for details.** (Функция или переменная может быть небезопасной. Используйте strncpy_s. Дополнительные сведения см. в справке.)

Корпорация Майкрософт объявила устаревшими, некоторые функции CRT и стандартной библиотеки C++ и глобальные переменные в пользу более безопасные версии. В большинстве случаев устаревшие функции позволяют unchecked чтения или записи в буферы, что может привести к серьезным уязвимостей. Компилятор выдает предупреждение об устаревании для этих функций и предлагает предпочтительную функцию.

Чтобы устранить эту проблему, мы рекомендуем использовать функцию или переменную *safe_version* вместо этого. Если вы убедились, что невозможно для перезаписи буфера или overread в коде и не может изменить код для переносимости причинам, можно отключить предупреждение.

Чтобы отключить предупреждения об устаревании для этих функций в CRT, задайте  **\_CRT\_SECURE\_нет\_ПРЕДУПРЕЖДЕНИЯ**. Чтобы отключить предупреждения об устаревших глобальных переменных, определите  **\_CRT\_SECURE\_нет\_ПРЕДУПРЕЖДЕНИЯ\_GLOBALS**. Дополнительные сведения об этих устаревших функциях и глобальных переменных см. в разделе [функции безопасности в CRT](../../c-runtime-library/security-features-in-the-crt.md) и [безопасные библиотеки: стандартная библиотека C++](../../standard-library/safe-libraries-cpp-standard-library.md).

### <a name="unsafe-standard-library-functions"></a>Небезопасных функций стандартной библиотеки

__"std::__*имя_функции*__::\_Unchecked\_итераторы::\_Deprecate" вызов std::__*имя_функции* **с параметрами, которые могут быть небезопасными — этот вызов зависит от вызывающего объекта для проверки правильности переданных значений. Чтобы отключить это предупреждение, используйте -D\_SCL\_SECURE\_нет\_ПРЕДУПРЕЖДЕНИЯ. См. в разделе документации по использованию Visual C++ «Проверяемых итераторов»**

Это предупреждение появляется в отладочных построениях, так как некоторые функции стандартной библиотеки C++ не проверяют правильность параметров. В большинстве случаев это, поскольку не хватает информация доступна функция для проверки границ контейнера или итераторов может использоваться неправильно с функцией. Это предупреждение помогает определить эти функции используется, так как они могут стать источником серьезных уязвимостей в программе. Для получения дополнительной информации см. [Checked Iterators](../../standard-library/checked-iterators.md).

Например, это предупреждение появляется в режиме отладки, если передать указатель элемента для `std::copy` вместо обычного массива. Чтобы устранить эту проблему, используйте массив соответствующим образом объявленный, поэтому библиотеке можно проверить массиве экстентов и выполнять проверки границ.

```cpp
// C4996_copyarray.cpp
// compile with: cl /c /W4 /D_DEBUG C4996_copyarray.cpp
#include <algorithm>

void example(char const * const src) {
    char dest[1234];
    char * pdest3 = dest + 3;
    std::copy(src, src + 42, pdest3); // C4996
    std::copy(src, src + 42, dest);   // OK, copy can tell that dest is 1234 elements
}
```

Несколько алгоритмов стандартной библиотеки были обновлены для версии «dual диапазон» в C ++ 14. Если вы используете два диапазона, второго диапазона предоставляет необходимые проверки границ:

```cpp
// C4996_containers.cpp
// compile with: cl /c /W4 /D_DEBUG C4996_containers.cpp
#include <algorithm>

bool example(
    char const * const left,
    const size_t leftSize,
    char const * const right,
    const size_t rightSize)
{
    bool result = false;
    result = std::equal(left, left + leftSize, right); // C4996
    // To fix, try this form instead:
    // result = std::equal(left, left + leftSize, right, right + rightSize); // OK
    return result;
}
```

В этом примере показано несколько способов дополнительные, стандартная библиотека может использоваться для проверки использования итератора, и если снят флажок использования может быть опасной:

```cpp
// C4996_standard.cpp
// compile with: cl /EHsc /W4 /MDd C4996_standard.cpp
#include <algorithm>
#include <array>
#include <iostream>
#include <iterator>
#include <numeric>
#include <string>
#include <vector>

using namespace std;

template <typename C> void print(const string& s, const C& c) {
    cout << s;

    for (const auto& e : c) {
        cout << e << " ";
    }

    cout << endl;
}

int main()
{
    vector<int> v(16);
    iota(v.begin(), v.end(), 0);
    print("v: ", v);

    // OK: vector::iterator is checked in debug mode
    // (i.e. an overrun triggers a debug assertion)
    vector<int> v2(16);
    transform(v.begin(), v.end(), v2.begin(), [](int n) { return n * 2; });
    print("v2: ", v2);

    // OK: back_insert_iterator is marked as checked in debug mode
    // (i.e. an overrun is impossible)
    vector<int> v3;
    transform(v.begin(), v.end(), back_inserter(v3), [](int n) { return n * 3; });
    print("v3: ", v3);

    // OK: array::iterator is checked in debug mode
    // (i.e. an overrun triggers a debug assertion)
    array<int, 16> a4;
    transform(v.begin(), v.end(), a4.begin(), [](int n) { return n * 4; });
    print("a4: ", a4);

    // OK: Raw arrays are checked in debug mode
    // (i.e. an overrun triggers a debug assertion)
    // NOTE: This applies only when raw arrays are
    // given to C++ Standard Library algorithms!
    int a5[16];
    transform(v.begin(), v.end(), a5, [](int n) { return n * 5; });
    print("a5: ", a5);

    // WARNING C4996: Pointers cannot be checked in debug mode
    // (i.e. an overrun triggers undefined behavior)
    int a6[16];
    int * p6 = a6;
    transform(v.begin(), v.end(), p6, [](int n) { return n * 6; });
    print("a6: ", a6);

    // OK: stdext::checked_array_iterator is checked in debug mode
    // (i.e. an overrun triggers a debug assertion)
    int a7[16];
    int * p7 = a7;
    transform(v.begin(), v.end(),
        stdext::make_checked_array_iterator(p7, 16),
        [](int n) { return n * 7; });
    print("a7: ", a7);

    // WARNING SILENCED: stdext::unchecked_array_iterator
    // is marked as checked in debug mode, but it performs no checking,
    // so an overrun triggers undefined behavior
    int a8[16];
    int * p8 = a8;
    transform( v.begin(), v.end(),
        stdext::make_unchecked_array_iterator(p8),
        [](int n) { return n * 8; });
    print("a8: ", a8);
}
```

Если вы убедились, что ваш код не может иметь ошибки в функциях стандартной библиотеки, которые активируют это предупреждение переполнение буфера, можно отключить это предупреждение. Чтобы отключить предупреждения для этих функций, задайте  **\_SCL\_SECURE\_нет\_ПРЕДУПРЕЖДЕНИЯ**.

### <a name="checked-iterators-enabled"></a>Проверяемые итераторы включены

Предупреждение C4996 также может возникать, если вы не используете проверенный итератор при компиляции с параметром `_ITERATOR_DEBUG_LEVEL` 1 или 2. Он имеет значение 2 по умолчанию для сборок в режиме отладки или значение 0 в розничных сборках. Дополнительные сведения см. в разделе [Checked Iterators](../../standard-library/checked-iterators.md) .

```cpp
// C4996_checked.cpp
// compile with: /EHsc /W4 /MDd C4996_checked.cpp
#define _ITERATOR_DEBUG_LEVEL 2

#include <algorithm>
#include <iterator>

using namespace std;
using namespace stdext;

int main() {
    int a[] = { 1, 2, 3 };
    int b[] = { 10, 11, 12 };
    copy(a, a + 3, b + 1);   // C4996
    // try the following line instead:
    // copy(a, a + 3, checked_array_iterator<int *>(b, 3));   // OK
}
```

### <a name="unsafe-mfc-or-atl-code"></a>Код небезопасный MFC или ATL

Предупреждение C4996 также может возникать при использовании функций библиотек MFC или ATL, устаревших по соображениям безопасности.

Чтобы устранить эту проблему, мы настоятельно рекомендуем изменить код, чтобы вместо этого используйте обновленных функций.

Сведения о том, как отключить эти предупреждения, см. в разделе [_AFX_SECURE_NO_WARNINGS](../../mfc/reference/diagnostic-services.md#afx_secure_no_warnings).

### <a name="obsolete-crt-functions-and-variables"></a>Устаревшие функции CRT и переменные

**Эта функция или переменная было заменено более новые функциональные возможности библиотеки или операционной системы. Рассмотрите возможность использования** *new_item* **вместо этого. See online help for details.** (Функция или переменная может быть небезопасной. Используйте strncpy_s. Дополнительные сведения см. в справке.)

Некоторые функции и глобальные переменные библиотеки устарели. Эти функции и переменные могут быть удалены в будущей версии библиотеки. Компилятор выдает предупреждение об устаревании для этих элементов и предлагает предпочтительную альтернативу.

Чтобы устранить эту проблему, мы рекомендуем изменить код, чтобы использовать предлагаемые функции или переменной.

Чтобы отключить предупреждения об устаревании для этих элементов, задайте  **\_CRT\_OBSOLETE\_нет\_ПРЕДУПРЕЖДЕНИЯ**. Дополнительные сведения см. в документации по устаревшей функции или переменной.

### <a name="marshalling-errors-in-clr-code"></a>Ошибки маршалинга в коде CLR

Предупреждение C4996 также может возникать при использовании библиотеки маршалинга среды CLR. В этом случае C4996 будет ошибкой, а не предупреждением. Эта ошибка возникает при использовании [marshal_as](../../dotnet/marshal-as.md) для преобразования между двумя типами данных, требующих [класс marshal_context](../../dotnet/marshal-context-class.md). Кроме того, эта ошибка может возникнуть, когда библиотека маршалинга не поддерживает преобразование. Дополнительные сведения о библиотеке маршалинга см. в статье [Overview of Marshaling in C++](../../dotnet/overview-of-marshaling-in-cpp.md).

Этот пример создает C4996, поскольку библиотеке маршалинга требуется контекст для преобразования из `System::String` для `const char *`.

```cpp
// C4996_Marshal.cpp
// compile with: /clr
// C4996 expected
#include <stdlib.h>
#include <string.h>
#include <msclr\marshal.h>

using namespace System;
using namespace msclr::interop;

int main() {
   String^ message = gcnew String("Test String to Marshal");
   const char* result;
   result = marshal_as<const char*>( message );
   return 0;
}
```

## <a name="example-user-defined-deprecated-function"></a>Пример: Пользовательской устаревшие функции

Предупреждать об вызывающим объектам использовать некоторые функции больше не рекомендуется, можно использовать устаревший атрибут в собственном коде. В этом случае C4996 создается строка, в котором объявлена устаревшей функции, а строки, в которой используется функция.

```cpp
// C4996.cpp
// compile with: /W3
// C4996 warning expected
#include <stdio.h>

// #pragma warning(disable : 4996)
void func1(void) {
   printf_s("\nIn func1");
}

__declspec(deprecated) void func1(int) {
   printf_s("\nIn func2");
}

int main() {
   func1();
   func1(1);    // C4996
}
```
