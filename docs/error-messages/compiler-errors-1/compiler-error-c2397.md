---
title: Ошибка компилятора C2397
ms.date: 11/04/2016
f1_keywords:
- C2397
ms.assetid: b418cf5a-d50d-4a6c-98a7-994ae35046d1
ms.openlocfilehash: 61f23269e0b6ed65a485f11e49e492d2248b8a42
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62378938"
---
# <a name="compiler-error-c2397"></a>Ошибка компилятора C2397

Преобразование «type_1» в «type_2» требует сужающего преобразования

Неявное сужающее преобразование найден, при использовании единообразная инициализация.

Языка C разрешает неявные сужающие преобразования в назначения и инициализации и C++ соответствует масти, несмотря на то, что Непредвиденная сужающим является причиной многих ошибок кода. Чтобы сделать код безопаснее, стандарт языка C++ требует диагностическое сообщение при возникновении сужающего преобразования в списке инициализации. В Visual C++ диагностики — Ошибка компилятора C2397 при использовании синтаксиса поддерживается начало единообразная инициализация в Visual Studio 2015. Компилятор создает [Предупреждение компилятора (уровень 1) C4838](../../error-messages/compiler-warnings/compiler-warning-level-1-c4838.md) при использовании списка или синтаксиса агрегатной инициализации, поддерживаемых Visual Studio 2013.

Сужающее преобразование может быть допустимо, если известно, что возможный диапазон значений может поместиться в целевом объекте. В этом случае вы знаете более, чем компилятор. Если сужающее преобразование намеренно, предметными свои намерения с помощью приведения статический. В противном случае это сообщение об ошибке почти всегда указывает, что у вас есть ошибки в коде. Вы можете исправить, убедившись, что объекты, которые необходимо инициализировать имеют типы, которые достаточно велики для обработки входных данных.

Следующий пример приводит к возникновению ошибки C2397 и показан один из способов ее устранения:

```
// C2397.cpp -- C++ narrowing conversion diagnostics
// Compile by using: cl /EHsc C2397.cpp
#include <vector>

struct S1 {
    int m1;
    double m2, m3;
};

void function_C2397(double d1) {
    char c1 { 127 };          // OK
    char c2 { 513 };          // error C2397

    std::vector<S1> vS1;
    vS1.push_back({ d1, 2, 3 }); // error C2397

    // Possible fix if you know d1 always fits in an int
    vS1.push_back({ static_cast<int>(d1), 2, 3 });
}
```