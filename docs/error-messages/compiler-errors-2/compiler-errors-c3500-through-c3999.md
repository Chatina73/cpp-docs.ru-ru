---
title: Ошибки компилятора с C3500 по C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: c5cb482804dac90a278036d594dc92e7be33e2bf
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62281339"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Ошибки компилятора с C3500 по C3999

Статьи в этом разделе документации объясняется подмножество сообщения об ошибках, создаваемых компилятором.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Сообщения об ошибках

|Error|Сообщение|
|-----------|-------------|
|[Ошибка компилятора C3500](compiler-error-c3500.md)|Недопустимый ProgID "*progid*"|
|[Ошибка компилятора C3501](compiler-error-c3501.md)|нет библиотеки типов, зарегистрированной для ProgID "*progid*"|
|Ошибка компилятора C3502|Невозможно получить LIBID для ProgID "*progid*"|
|Ошибка компилятора C3503|символ "0 x*значение*" не допускается в необработанный строковый литерал|
|Ошибка компилятора C3504|не удается создать идентификатор GUID из строки "*строка*"|
|[Ошибка компилятора C3505](compiler-error-c3505.md)|не удается загрузить библиотеку типов "*библиотеки*"|
|[Ошибка компилятора C3506](compiler-error-c3506.md)|нет библиотеки типов, зарегистрированной для LIBID "*библиотеки*"|
|[Ошибка компилятора C3507](compiler-error-c3507.md)|ProgID не может иметь больше 39 символов*progid*"; не содержать знаки пунктуации '.'; и не может начинаться с цифры|
|[Ошибка компилятора C3508](compiler-error-c3508.md)|"*тип*": не является допустимым типом автоматизации|
|[Ошибка компилятора C3509](compiler-error-c3509.md)|"*тип*": недопустимый возвращаемый тип автоматизации; когда параметр помечен как «retval», тип возвращаемого значения должен быть «void», «HRESULT» или «SCODE»|
|[Ошибка компилятора C3510](compiler-error-c3510.md)|не удается найти библиотеку зависимых типов *библиотеки*|
|Ошибка компилятора C3511|"*идентификатор*": вызов делегирующего конструктора должен быть единственным инициализатором члена|
|Ошибка компилятора C3512|последовательность символов-разделителей для необработанные строковые литералы должны иметь не более 16 символов|
|Ошибка компилятора C3513|"*строка*": неподдерживаемый символ-разделитель литерала необработанной строки|
|Ошибка компилятора C3514|"*символ*" (*значение*): неподдерживаемый символ-разделитель литерала необработанной строки|
|Ошибка компилятора C3515|Если аргумент частичной специализации шаблона класса является раскрытием пакета, он должен быть последним аргументом|
|Ошибка компилятора C3516|непредвиденный конец файла найден при обработке необработанного строкового литерала; последовательность разделителей "*строка*" не соответствует|
|Ошибка компилятора C3517|"*идентификатор*": объявление псевдонима не может иметь тип, содержащий «auto»|
|Ошибка компилятора C3518|"*идентификатор*": в контексте direct-list-initialization тип для "*тип*" можно вывести только из выражения с одним инициализатором|
|[Ошибка компилятора C3519](compiler-error-c3519.md)|"*параметр*": недопустимый параметр атрибута embedded_idl|
|Ошибка компилятора C3520|"*идентификатор*": пакет параметров должен раскрываться в этом контексте|
|Ошибка компилятора C3521|"*идентификатор*" не является пакетом параметров|
|Ошибка компилятора C3522|"*тип*": пакет параметров не может раскрываться в этом контексте|
|Ошибка компилятора C3523|«sizeof...» требует в качестве аргумента нераскрытый пакет параметров|
|Ошибка компилятора C3524|"*идентификатор*": «sizeof» не может использоваться для пакета параметров. Имелось в виду использование «sizeof...»?|
|Ошибка компилятора C3525|"*параметр*": Если в шаблоне класса имеется пакет параметров шаблона, он должен располагаться в конце списка параметров шаблона|
|Ошибка компилятора C3526|«...» не может применяться к «this»|
|Ошибка компилятора C3527|"*идентификатор*" не является допустимым операндом для «sizeof...». Имелось в виду использование «sizeof»?|
|Ошибка компилятора C3528|"*идентификатор1*": количество элементов в раскрытии пакета не соответствует числу элементов в "*идентификатор2*"|
|Ошибка компилятора C3529|"*параметр*": пакет параметров шаблона не может иметь аргумент по умолчанию|
|[Ошибка компилятора C3530](compiler-error-c3530.md)|"*тип*" нельзя использовать вместе с любой другими описателями типа|
|[Ошибка компилятора C3531](compiler-error-c3531.md)|"*идентификатор*": символ, тип которого содержит "*тип*" должно иметь инициализатор|
|[Ошибка компилятора C3532](compiler-error-c3532.md)|Тип элемента массива не может быть типом, содержащим "*тип*"|
|[Ошибка компилятора C3533](compiler-error-c3533.md)|параметр не может иметь тип, содержащий "*тип*"|
|Ошибка компилятора C3534|Является устаревшей.|
|[Ошибка компилятора C3535](compiler-error-c3535.md)|Невозможно вывести тип для "*тип1*«from»*тип2*"|
|[Ошибка компилятора C3536](compiler-error-c3536.md)|"*идентификатор*": нельзя использовать до инициализации|
|[Ошибка компилятора C3537](compiler-error-c3537.md)|не может быть приведен к типу, содержащему "*тип*"|
|[Ошибка компилятора C3538](compiler-error-c3538.md)|в списке объявлений "*тип*" всегда должен вывести к одному типу|
|[Ошибка компилятора C3539](compiler-error-c3539.md)|аргумент шаблона не может быть типом, содержащим "*тип*"|
|[Ошибка компилятора C3540](compiler-error-c3540.md)|Невозможно применить sizeof к типу, который содержит "*тип*"|
|[Ошибка компилятора C3541](compiler-error-c3541.md)|typeid нельзя применять к типу, содержащему "*тип*"|
|Ошибка компилятора C3542|"*идентификатор*": виртуальная функция-член не должен иметь тип возврата, который содержит "*тип*"|
|Ошибка компилятора C3543|"*тип*": не содержит пакет параметров|
|Ошибка компилятора C3544|"*параметр*": пакет параметров ожидает аргумент шаблона типа|
|Ошибка компилятора C3545|"*параметр*": пакет параметров ожидает аргумент шаблона не являющегося типом|
|Ошибка компилятора C3546|«...»: нет доступных для раскрытия пакетов параметров|
|Ошибка компилятора C3547|параметр шаблона "*параметр*«нельзя использовать, так как он пакет параметров шаблона и не может быть выведен из параметров функции»*функция*"|
|Ошибка компилятора C3548|"*идентификатор*": пакет параметров не может использоваться в этом контексте|
|Ошибка компилятора C3549|"*значение*": пакет параметров функции не может иметь аргумент по умолчанию|
|[Ошибка компилятора C3550](compiler-error-c3550.md)|только неструктурированный описатель "decltype(auto)" разрешен в этом контексте|
|[Ошибка компилятора C3551](compiler-error-c3551.md)|Если используется завершающий возвращаемый тип, то начальный возвращаемый тип должен быть одним спецификатором типа «auto» (не "*тип*")|
|[Ошибка компилятора C3552](compiler-error-c3552.md)|Ожидается «decltype(auto)»|
|[Ошибка компилятора C3553](compiler-error-c3553.md)|для "decltype" требуется выражение, а не тип|
|[Ошибка компилятора C3554](compiler-error-c3554.md)|"*тип*" нельзя использовать вместе с любой другими описателями типа|
|[Ошибка компилятора C3555](compiler-error-c3555.md)|неправильный аргумент для "decltype"|
|[Ошибка компилятора C3556](compiler-error-c3556.md)|"*выражение*": неправильный аргумент для «decltype»|
|Ошибка компилятора C3557|Является устаревшей.|
|Ошибка компилятора C3558|Является устаревшей.|
|Ошибка компилятора C3559|рекурсивный вызов "*функция*": рекурсия обнаруживается при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3560|"*функция*": Встраивание недоступно при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3561|Операция нарушения барьера найден в потоке управления с неравномерными не при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3562|Встроенная функция "*функция*" ограничены не более чем *номер* параметров|
|Ошибка компилятора C3563|Обнаружен бесконечный цикл при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3564|чтение неинициализированного значения при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3565|Общий объем памяти tile_static (*номер* байт) превышает ограничение в *номер* байт при компиляции графа вызовов Concurrency::parallel_for_each по|
|Ошибка компилятора C3566|блоки с побочными эффектами вложены слишком глубоко при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3567|деление на ноль или остаток от деления на ноль, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3568|Сумма регистров превышает предел *номер* при компиляции графа вызовов Concurrency::parallel_for_each по. Упростите программы|
|Ошибка компилятора C3569|гонки, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|Ошибка компилятора C3570|Недопустимое использование amp ограниченные области при компиляции с параметром/CLR|
|Ошибка компилятора C3571|"*тип*": недопустимый аргумент домена вычислений; не тип класса|
|Ошибка компилятора C3572|"*тип*": недопустимый аргумент домена вычислений; отсутствует открытый член: «static const int rank» или значение ранга неположительно|
|Ошибка компилятора C3573|Количество экземпляров Concurrency::Graphics:: sampler, передаваемых в concurrency::parallel_for_each, не может превышать *номер*|
|Ошибка компилятора C3574|"*тип*": недопустимые размеры плитки: должны быть положительными и (1) Z < = *номер*; (2) Z*Y*X < = *номер*|
|Ошибка компилятора C3575|"*тип*": недопустимый аргумент домена вычислений; отсутствует открытый член: "concurrency::index <*номер*> _map_index (const concurrency::index <*номер*> &) restrict(amp) "|
|Ошибка компилятора C3576|"*тип*": аргумента Concurrency::Details:: #*номер* имеет неподдерживаемый тип|
|Ошибка компилятора C3577|Аргумент ядра Concurrency::parallel_for_each: не удается разрешить вызов члена "void operator() (*типа*) restrict(amp)"|
|Ошибка компилятора C3578|Размер объекта функции, передаваемых в concurrency::parallel_for_each, не может превышать *номер* байт|
|Ошибка компилятора C3579|Не может превышать число только для чтения экземпляров concurrency::array и Concurrency::Graphics:: Texture, передаваемых в concurrency::parallel_for_each *номер*|
|Ошибка компилятора C3580|Не может превышать количество доступных для записи экземпляров concurrency::array и Concurrency::Graphics:: Texture, передаваемых в concurrency::parallel_for_each *номер*|
|Ошибка компилятора C3581|"*тип*": неподдерживаемый тип в amp коде, ограниченном|
|Ошибка компилятора C3582|Является устаревшей.|
|Ошибка компилятора C3583|"*идентификатор*": размер переменной (*номер* байт) превышает максимальный размер (*номер* байт) поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3584|не поддерживается использование tile_static в "*идентификатор*"|
|Ошибка компилятора C3585|"*идентификатор*" класс хранения не поддерживается в amp ограничил кода|
|Ошибка компилятора C3586|"*идентификатор*": Использование глобальных или статических переменных не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3587|dynamic_cast не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3588|приведение из "*тип1*«to»*тип2*" не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3589|"*строка*": неподдерживаемое использование строковых литералов в amp коде, ограниченном|
|Ошибка компилятора C3590|"*маркера*": по ссылке записи или записи «this» не поддерживается, если лямбда-выражение ограничено amp|
|Ошибка компилятора C3591|оператор typeid не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3592|Встраиваемая Машинная сборка (__asm) не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3593|Оператор «goto» не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3594|исключение обработки (try, catch, throw и т.д.) не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3595|постоянное значение находится вне допустимого диапазона в коде, ограниченном amp|
|Ошибка компилятора C3596|"*параметр*" ("*тип*"): переменная, захваченные лямбда-выражение имеет неподдерживаемый тип в коде, ограниченном amp|
|Ошибка компилятора C3597|"*параметр*": "*идентификатор*" не может быть захваченными значениями, если лямбда-выражение ограничено amp|
|Ошибка компилятора C3598|выражения меток не поддерживаются в коде, ограниченном amp|
|Ошибка компилятора C3599|"*оператор*": не удается выполнить расчеты с указателями на указатель на bool в коде, ограниченном amp|
|Ошибка компилятора C3600|"*функция*": используйте плитку\_статической памяти, обнаруженных при компиляции графа вызовов негруппируемого concurrency::parallel\_for_each в: "*функция*"|
|Ошибка компилятора C3601|"*тип*": недопустимый тип аргумента для диагностической функции amp "*функция*"|
|Ошибка компилятора C3602|Неподдерживаемая операция управления потоком, обнаруженных при компиляции графа вызовов Concurrency::parallel_for_each по адресу: "*функция*"|
|[Ошибка компилятора C3603](compiler-error-c3603.md)|"*символ*": тип "*тип*" еще не поддерживается|
|Ошибка компилятора C3604|"*идентификатор*": управляемый объект можно создать только в куче сборщика мусора|
|Ошибка компилятора C3605|Общее количество образцов (*номер* фиксируются и *номер* предопределенные) превышает *номер* при компиляции графа вызовов Concurrency::parallel_for_each по адресу: " *функция*"|
|Ошибка компилятора C3606|Является устаревшей.|
|Ошибка компилятора C3607|Является устаревшей.|
|Ошибка компилятора C3608|Является устаревшей.|
|[Ошибка компилятора C3609](compiler-error-c3609.md)|"*идентификатор*": функция «запечатанным или конечное» должна быть виртуальной|
|[Ошибка компилятора C3610](compiler-error-c3610.md)|"*идентификатор*": тип значения должен быть «упакован» перед методом "*метод*" может быть вызван|
|[Ошибка компилятора C3611](compiler-error-c3611.md)|"*идентификатор*": запечатанная функция не может иметь чистый спецификатор|
|[Ошибка компилятора C3612](compiler-error-c3612.md)|"*идентификатор*": у запечатанного класса не может быть чистые виртуальные методы|
|Ошибка компилятора C3613|отсутствует тип возвращаемого значения после «->» («предполагается int)|
|Ошибка компилятора C3614|Разные значения для размера пакета в рамках одного класса: предыдущим значением "*значение*«, новое значение —»*значение*"|
|[Ошибка компилятора C3615](compiler-error-c3615.md)|функция constexpr "*функция*" не может быть константным выражением|
|Ошибка компилятора C3616|Является устаревшей.|
|Ошибка компилятора C3617|Является устаревшей.|
|[Ошибка компилятора C3618](compiler-error-c3618.md)|"*объявление*": не может быть определен метод, помеченный как DllImport|
|[Ошибка компилятора C3619](compiler-error-c3619.md)|шаблон не может объявляться внутри типа управляемых/WinRT|
|Ошибка компилятора C3620|"*тип*": Задание выравнивания не допускается в типах WinRT|
|Ошибка компилятора C3621|"*тип*": только значение упаковки по умолчанию (*номер*) допускается для типов WinRT|
|[Ошибка компилятора C3622](compiler-error-c3622.md)|*Тип*": класс, объявленный как"*ключевое слово*"не может быть создан|
|[Ошибка компилятора C3623](compiler-error-c3623.md)|"*идентификатор*": битовые поля не поддерживаются в типах управляемых/WinRT|
|[Ошибка компилятора C3624](compiler-error-c3624.md)|"*тип*": использование этого типа необходима ссылка на сборки или модуля "*идентификатор*"|
|[Ошибка компилятора C3625](compiler-error-c3625.md)|"*класс*": собственный тип не может быть производным от типа управляемого/WinRT "*тип*"|
|[Ошибка компилятора C3626](compiler-error-c3626.md)|"*идентификатор*": "*ключевое слово*" ключевое слово может использоваться только в интерфейсах COM, функции-члены и члены данных, которые являются указателями на делегаты|
|[Ошибка компилятора C3627](compiler-error-c3627.md)|Только типы значений допускает упаковку-преобразование|
|[Ошибка компилятора C3628](compiler-error-c3628.md)|"*класс*': WinRT/управляемые классы поддерживают только открытое наследование|
|Ошибка компилятора C3629|"*маркера*": передаваемый параметр по умолчанию может использоваться только в начале списка захвата лямбда-выражения|
|[Ошибка компилятора C3630](compiler-error-c3630.md)|Ошибка при обработке лексемы "*маркера*"|
|[Ошибка компилятора C3631](compiler-error-c3631.md)|"*событий*": Невозможно перегрузить события управляемых/WinRT|
|[Ошибка компилятора C3632](compiler-error-c3632.md)|"*событий*": недопустимый тип события для *построения*|
|[Ошибка компилятора C3633](compiler-error-c3633.md)|не удается определить "*идентификатор*«как управляемую является членом»*класс*"|
|[Ошибка компилятора C3634](compiler-error-c3634.md)|"*член*": невозможно определить абстрактный метод класса управляемых/WinRT|
|Ошибка компилятора C3635|"*идентификатор*": не может применяться к классу управляемых/WinRT (используйте "*идентификатор*" вместо)|
|Ошибка компилятора C3636|"*идентификатор*": не может использоваться для этого типа|
|[Ошибка компилятора C3637](compiler-error-c3637.md)|"*функция*": определение дружественной функции не может быть специализацией функции шаблона или универсального класса|
|[Ошибка компилятора C3638](compiler-error-c3638.md)|"*оператор*": стандартный упаковки-преобразования и распаковки-операторы преобразования не может быть переопределен|
|Ошибка компилятора C3639|Является устаревшей.|
|[Ошибка компилятора C3640](compiler-error-c3640.md)|"*член*": функция адресуемая или виртуальная член локального класса должна быть определена|
|[Ошибка компилятора C3641](compiler-error-c3641.md)|"*функция*": недопустимое соглашение вызова "*соглашение*" для функции, скомпилированные с параметром/clr: pure или/CLR: safe|
|[Ошибка компилятора C3642](compiler-error-c3642.md)|"*функция*": невозможно вызвать функцию с соглашением вызова из машинного кода __clrcall|
|Ошибка компилятора C3643|Является устаревшей.|
|[Ошибка компилятора C3644](compiler-error-c3644.md)|"*функция*": не удается скомпилировать функцию для создания управляемого кода|
|[Ошибка компилятора C3645](compiler-error-c3645.md)|"*функция*": __clrcall невозможно использовать с функциями, скомпилированными в машинный код|
|[Ошибка компилятора C3646](compiler-error-c3646.md)|"*идентификатор*": Неизвестный спецификатор переопределения|
|Ошибка компилятора C3647|Является устаревшей.|
|[Ошибка компилятора C3648](compiler-error-c3648.md)|Этот синтаксис явного переопределения не поддерживается для управляемых типов|
|Ошибка компилятора C3649|Этот синтаксис явного переопределения нельзя использовать с параметром/zw|
|[Ошибка компилятора C3650](compiler-error-c3650.md)|"*член*": не может использоваться как явное переопределение, должен быть виртуальная функция-член базового класса|
|[Ошибка компилятора C3651](compiler-error-c3651.md)|"*член*": не может использоваться как явное переопределение, должен быть членом базового класса|
|[Ошибка компилятора C3652](compiler-error-c3652.md)|"*член*": явно переопределяющая функция должна быть виртуальной|
|[Ошибка компилятора C3653](compiler-error-c3653.md)|"*идентификатор*": нельзя использовать в качестве именованного переопределения: переопределяемая функция не найдена; возможно, вы забыли имя функции явно, с помощью ответ: оператор?|
|[Ошибка компилятора C3654](compiler-error-c3654.md)|"*маркера*": синтаксическая ошибка в явном переопределении|
|[Ошибка компилятора C3655](compiler-error-c3655.md)|"*член*": функция уже явно переопределена|
|[Ошибка компилятора C3656](compiler-error-c3656.md)|"*ключевое слово*": переопределение невозможно повторить, описатель|
|[Ошибка компилятора C3657](compiler-error-c3657.md)|деструктор или метод завершения не может явно переопределять или явно переопределяться|
|Ошибка компилятора C3658|Является устаревшей.|
|Ошибка компилятора C3659|"*член*": спецификатор переопределения "*ключевое слово*" не поддерживается|
|Ошибка компилятора C3660|"*член1*": скрывает унаследованный член "*член2*"|
|[Ошибка компилятора C3661](compiler-error-c3661.md)|в списке явных переопределений не обнаружил никаких методов для переопределения|
|[Ошибка компилятора C3662](compiler-error-c3662.md)|"*член*": спецификатор переопределения "*ключевое слово*" допустим только для функций-членов классов управляемых/WinRT|
|Ошибка компилятора C3663|Является устаревшей.|
|Ошибка компилятора C3664|"*член*": не может использоваться как явное переопределение, должен иметь режим доступа «public» или «защищенный»|
|[Ошибка компилятора C3665](compiler-error-c3665.md)|"*член*": спецификатор переопределения "*ключевое слово*" не разрешена для деструктора или метода завершения|
|[Ошибка компилятора C3666](compiler-error-c3666.md)|"*конструктор*": спецификатор переопределения "*ключевое слово*" не допускается в конструкторе|
|Ошибка компилятора C3667|"*атрибут*": атрибут не поддерживает расширение пакета|
|[Ошибка компилятора C3668](compiler-error-c3668.md)|"*член*": метод со спецификатором переопределения «override» не выполняли переопределение методов базового класса|
|[Ошибка компилятора C3669](compiler-error-c3669.md)|"*член*": спецификатор переопределения «override» не допускаются статические функции-члены или конструкторы|
|[Ошибка компилятора C3670](compiler-error-c3670.md)|"*член*": невозможно переопределить недоступный метод базового класса "*член*"|
|[Ошибка компилятора C3671](compiler-error-c3671.md)|"*член*": функция не переопределяет "*член*"|
|[Ошибка компилятора C3672](compiler-error-c3672.md)|выражение псевдо-деструктора можно использовать только как часть вызова функции|
|[Ошибка компилятора C3673](compiler-error-c3673.md)|"*класс*": класс не имеет конструктор копии|
|Ошибка компилятора C3674|не удалось найти модуль стандартной библиотеки "*модуль*"|
|[Ошибка компилятора C3675](compiler-error-c3675.md)|"*функция*": зарезервировано, поскольку "*свойство*" определяется|
|Ошибка компилятора C3676|"*класс*": класс ссылки и базовый класс имеют несовместимые атрибуты "[*атрибут*]"|
|Ошибка компилятора C3677|строковый литерал после «operator» не может иметь кодирующий префикс|
|Ошибка компилятора C3678|строковый литерал после «operator» должен быть пустая строка "»»»"|
|Ошибка компилятора C3679|Ожидается идентификатор литерального суффикса после "operator «»»"|
|Ошибка компилятора C3680|Невозможно объединить определенные пользователем строковые литералы с несоответствующими идентификаторами литеральных суффиксов|
|Ошибка компилятора C3681|«fallthrough»: атрибут может стоять только в закрывающем операторе switch|
|Ошибка компилятора C3682|"оператор *идентификатор*": шаблон оператора литерала оператор/literal не могут объявляться как «компоновку C»|
|Ошибка компилятора C3683|Невозможно определить необработанный литеральный оператор и шаблон литерального оператора с одинаковым идентификатором литерального суффикса|
|Ошибка компилятора C3684|"оператор *идентификатор*": объявление литерального оператора имеет недопустимый список параметров|
|Ошибка компилятора C3685|"оператор *идентификатор*": шаблон литерального оператора не может иметь параметры функции|
|Ошибка компилятора C3686|"оператор *идентификатор*": шаблон литерального оператора должен иметь ровно один параметр шаблона, — это пакет параметров|
|Ошибка компилятора C3687|"оператор *идентификатор*": шаблон литерального оператора должен иметь параметр шаблона не являющийся типом, имеющий тип «char»|
|Ошибка компилятора C3688|Недопустимый литеральный суффикс "*суффикс*"; литерала оператор или литеральный шаблон оператора ' оператор *идентификатор*"не найден|
|Ошибка компилятора C3689|"оператор *идентификатор*": шаблон оператора литерала оператора или литерала должно быть в области глобальных или пространства имен|
|Ошибка компилятора C3690|ожидается строковый литерал, но обнаружен пользовательскую строку литерала вместо|
|Ошибка компилятора C3691|Недопустимый префикс литерала "*префикс*"|
|Ошибка компилятора C3692|Является устаревшей.|
|Ошибка компилятора C3693|Является устаревшей.|
|Ошибка компилятора C3694|Является устаревшей.|
|Ошибка компилятора C3695|Является устаревшей.|
|Ошибка компилятора C3696|"*ключевое слово*": этот квалификатор невозможно использовать на устройстве «%»|
|[Ошибка компилятора C3697](compiler-error-c3697.md)|"*ключевое слово*": этот квалификатор невозможно использовать для "^"|
|[Ошибка компилятора C3698](compiler-error-c3698.md)|"*тип*": нельзя использовать этот тип в качестве аргумента "*оператор*"|
|[Ошибка компилятора C3699](compiler-error-c3699.md)|"*оператор*": нельзя использовать перенаправление для типа "*тип*"|
|Ошибка компилятора C3700|Является устаревшей.|
|[Ошибка компилятора C3701](compiler-error-c3701.md)|"*функция*": источник событий не имеет событий|
|[Ошибка компилятора C3702](compiler-error-c3702.md)|Для событий COM требуется ATL|
|[Ошибка компилятора C3703](compiler-error-c3703.md)|"*event_handler*": метод обработчика событий должен возвращать такой же класс хранения, как и исходный "*событий*"|
|[Ошибка компилятора C3704](compiler-error-c3704.md)|"*член*": метод vararg не может порождать события|
|[Ошибка компилятора C3705](compiler-error-c3705.md)|"*функция*": невозможно найти интерфейс событий|
|[Ошибка компилятора C3706](compiler-error-c3706.md)|"*функция*": должен быть COM-интерфейс для порождения COM-событий|
|[Ошибка компилятора C3707](compiler-error-c3707.md)|"*член*": метод disp-интерфейса должен иметь dispid|
|[Ошибка компилятора C3708](compiler-error-c3708.md)|"*функция*": Неправильное использование "*ключевое слово*"; требуется член совместимого источника события|
|[Ошибка компилятора C3709](compiler-error-c3709.md)|"*функция*": неправильный синтаксис для задания события в __hook или __unhook|
|[Ошибка компилятора C3710](compiler-error-c3710.md)|"*функция*": неправильный синтаксис для задания обработчика событий в __hook или __unhook|
|[Ошибка компилятора C3711](compiler-error-c3711.md)|"*событий*": исходный метод неуправляемого события должен возвращать void или целый тип|
|[Ошибка компилятора C3712](compiler-error-c3712.md)|"*event_handler*": метод обработчика событий должен возвращать один и тот же тип как источник "*событий*"|
|[Ошибка компилятора C3713](compiler-error-c3713.md)|"*event_handler*": метод обработчика событий должен иметь такие же параметры функции в качестве источника "*событий*"|
|[Ошибка компилятора C3714](compiler-error-c3714.md)|"*event_handler*": метод обработчика событий должен возвращать соглашение о вызове как и исходный "*событий*"|
|[Ошибка компилятора C3715](compiler-error-c3715.md)|"*указатель*": должен быть указателем на "*тип*"|
|Ошибка компилятора C3716|Является устаревшей.|
|[Ошибка компилятора C3717](compiler-error-c3717.md)|"*член*": метод, порождающий события не может быть определен|
|[Ошибка компилятора C3718](compiler-error-c3718.md)|можно только вызов "__*ключевое слово*" в контексте функции-члена принимающего класса|
|[Ошибка компилятора C3719](compiler-error-c3719.md)|"*член*": источник событий на основе интерфейса может использоваться только для COM-событий|
|Ошибка компилятора C3720|"*тип*": IDispatch может реализовать только на двух или disp-интерфейс|
|[Ошибка компилятора C3721](compiler-error-c3721.md)|"*подписи*": несовместимая сигнатура для события|
|[Ошибка компилятора C3722](compiler-error-c3722.md)|Универсальное событие не допускается|
|[Ошибка компилятора C3723](compiler-error-c3723.md)|"*функция*": не удается разрешить событие|
|[Ошибка компилятора C3724](compiler-error-c3724.md)|необходимо #include \<windows.h > для использования многопоточности в событиях|
|Ошибка компилятора C3725|Является устаревшей.|
|Ошибка компилятора C3726|Является устаревшей.|
|[Ошибка компилятора C3727](compiler-error-c3727.md)|"*событий*": управляемое событие должно быть функция-член или член данных, являющийся указателем на делегата|
|[Ошибка компилятора C3728](compiler-error-c3728.md)|"*событий*": событие не имеет метода raise|
|Ошибка компилятора C3729|Является устаревшей.|
|Ошибка компилятора C3730|Является устаревшей.|
|[Ошибка компилятора C3731](compiler-error-c3731.md)|несовместимые событие "*событий*«и обработчик»*event_handler*"; источник события и обработчик событий должен иметь один и тот же тип события|
|[Ошибка компилятора C3732](compiler-error-c3732.md)|"*интерфейс*": настраиваемый интерфейс, порождающий COM-события не может наследовать от интерфейса IDispatch|
|[Ошибка компилятора C3733](compiler-error-c3733.md)|"*событий*": неправильный синтаксис для задания COM-события; возможно, отсутствует «__interface»?|
|[Ошибка компилятора C3734](compiler-error-c3734.md)|"*класс*": класс управляемого/WinRT не может быть коклассом|
|Ошибка компилятора C3735|Является устаревшей.|
|[Ошибка компилятора C3736](compiler-error-c3736.md)|"*член*": должен быть методом или, в случае управляемых событий, при необходимости элемент данных|
|[Ошибка компилятора C3737](compiler-error-c3737.md)|"*идентификатор*": делегат не может иметь явное соглашение о вызове|
|[Ошибка компилятора C3738](compiler-error-c3738.md)|"*соглашение*": соглашение о вызове явном создании экземпляров должно совпадать со значением шаблона создаваемых экземпляров|
|[Ошибка компилятора C3739](compiler-error-c3739.md)|"*класс*": синтаксис является только поддерживается при "макет\_зависимые" параметр event_receiver имеет значение true|
|[Ошибка компилятора C3740](compiler-error-c3740.md)|"*шаблона*": шаблоны не источниками или приемниками событий|
|[Ошибка компилятора C3741](compiler-error-c3741.md)|"*класс*": должен быть компонентным классом при "макет\_зависимые" для event_receiver возвращает значение параметра равно true|
|Ошибка компилятора C3742|"*токен1*": Несбалансированная последовательность токенов в аргументе атрибута "*атрибут*«, ожидалось»*токен2*"|
|[Ошибка компилятора C3743](compiler-error-c3743.md)|можно только обработчик/откреплять весь интерфейс при «layout_dependent» для event_receiver имеет значение true|
|[Ошибка компилятора C3744](compiler-error-c3744.md)|для __unhook требуется по крайней мере 3 аргумента в случае управляемых событий|
|[Ошибка компилятора C3745](compiler-error-c3745.md)|"*функция*": только событие может быть «raised»|
|Ошибка компилятора C3746|стандартный атрибут "*идентификатор*" может отображаться не более одного раза в списке атрибутов|
|[Ошибка компилятора C3747](compiler-error-c3747.md)|отсутствует шаблон или универсальный параметр по умолчанию: параметр *номер*|
|[Ошибка компилятора C3748](compiler-error-c3748.md)|"*интерфейс*": неуправляемые интерфейсы не могут порождать события|
|[Ошибка компилятора C3749](compiler-error-c3749.md)|"*атрибут*": настраиваемый атрибут не может использоваться внутри функции|
|Ошибка компилятора C3750|"*маркера*": непредвиденный токен в список атрибутов|
|Ошибка компилятора C3751|"*идентификатор*": непредвиденный идентификатор в список атрибутов|
|[Ошибка компилятора C3752](compiler-error-c3752.md)|"*атрибут*": не удается классифицировать атрибут; "*ключевое слово*" не следует использовать в этом контексте|
|[Ошибка компилятора C3753](compiler-error-c3753.md)|универсальное свойство не допускается|
|[Ошибка компилятора C3754](compiler-error-c3754.md)|конструктор делегата: функцию-член "*член*«не может вызываться для экземпляра типа»*тип*"|
|[Ошибка компилятора C3755](compiler-error-c3755.md)|"*идентификатор*": делегат не могут быть определены|
|Ошибка компилятора C3756|Является устаревшей.|
|Ошибка компилятора C3757|"*тип*": тип не допускается для функции «constexpr»|
|Ошибка компилятора C3758|"*член*": виртуальная функция не может объявляться как «constexpr»|
|Ошибка компилятора C3759|"*член*": функция-член нелитерального типа не могут объявляться как «constexpr»|
|Ошибка компилятора C3760|Используйте ключевое слово __property для объявления свойства в управляемых/WinRT "*класс*"|
|[Ошибка компилятора C3761](compiler-error-c3761.md)|"*функция*": «retval» может присутствовать только в последнем аргументе функции|
|[Ошибка компилятора C3762](compiler-error-c3762.md)|не удается обработать атрибут "*атрибут*"|
|[Ошибка компилятора C3763](compiler-error-c3763.md)|"*тип*": «retval» и «out» могут использоваться только в тип данных указателя|
|[Ошибка компилятора C3764](compiler-error-c3764.md)|"*член*": невозможно переопределить метод базового класса "*член*"|
|[Ошибка компилятора C3765](compiler-error-c3765.md)|"*событий*": не удается определить события в классе или структуре "*тип*" с пометкой event_receiver|
|[Ошибка компилятора C3766](compiler-error-c3766.md)|"*тип*«необходимо обеспечить реализацию для метода интерфейса»*функция*"|
|[Ошибка компилятора C3767](compiler-error-c3767.md)|"*функция*": функции-кандидаты недоступны|
|[Ошибка компилятора C3768](compiler-error-c3768.md)|Невозможно получить адрес функции виртуального vararg в полностью управляемого кода|
|[Ошибка компилятора C3769](compiler-error-c3769.md)|"*идентификатор*": вложенный класс не может иметь имя, совпадающее с именем немедленно включающего класса|
|Ошибка компилятора C3770|"*тип*": не является допустимым базовым классом|
|[Ошибка компилятора C3771](compiler-error-c3771.md)|"*идентификатор*": в ближайшей области пространства имен не удалось найти дружественное объявление|
|[Ошибка компилятора C3772](compiler-error-c3772.md)|"*идентификатор*": Недопустимое объявление дружественного шаблона|
|Ошибка компилятора C3773|можно использовать параметр компилятора / await Чтобы включить соподпрограммы|
|Ошибка компилятора C3774|не удается найти "*область*::*идентификатор*": Пожалуйста, включите *заголовок* заголовка|
|Ошибка компилятора C3775|Тип возвращаемого значения "*функция*«не следует»*тип*"|
|Ошибка компилятора C3776|Невозможно вернуть выражение типа void в соподпрограмме с типом возвращаемого отличный от void|
|Ошибка компилятора C3777|"*функция*": соподпрограмма не может принимать переменное число аргументов|
|Ошибка компилятора C3778|alloca: невозможно использовать в соподпрограмме|
|Ошибка компилятора C3779|"*функция*": функция, возвращающая "*тип*" не может использоваться, пока она определена|
|Ошибка компилятора C3780|"*функция*": преобразование функции, которая возвращает*тип*"не может использоваться, пока она определена|
|Ошибка компилятора C3781|"*ключевое слово*": нельзя использовать в соподпрограмме типа "*тип*". Либо *ключевое слово* или *ключевое слово* должен присутствовать в связанных типе обещания promise_type|
|Ошибка компилятора C3782|*Тип*: обещание соподпрограммы не может одновременно содержать *ключевое слово* и *ключевое слово*|
|Ошибка компилятора C3783|"*идентификатор*": не может быть соподпрограммой|
|Ошибка компилятора C3784|*Ключевое слово* выражение не может указываться в этом контексте|
|Ошибка компилятора C3785|Первый аргумент шаблона для «std::integer_sequence» должен быть целочисленный тип|
|Ошибка компилятора C3786|Второй аргумент шаблона для «std::make_integer_sequence» должен быть целочисленной константой больше или равно нулю|
|Ошибка компилятора C3787|Невозможно вывести тип возвращаемого значения этой сопрограммы|
|Ошибка компилятора C3788|Является устаревшей.|
|Ошибка компилятора C3789|Является устаревшей.|
|Ошибка компилятора C3790|Является устаревшей.|
|Ошибка компилятора C3791|Является устаревшей.|
|Ошибка компилятора C3792|Является устаревшей.|
|Ошибка компилятора C3793|Является устаревшей.|
|Ошибка компилятора C3794|Является устаревшей.|
|Ошибка компилятора C3795|Является устаревшей.|
|Ошибка компилятора C3796|Является устаревшей.|
|[Ошибка компилятора C3797](compiler-error-c3797.md)|"*ключевое слово*": объявление события не может содержать спецификатор переопределения (должен быть размещен в методах добавления/remove/raise событий вместо)|
|[Ошибка компилятора C3798](compiler-error-c3798.md)|"*ключевое слово*": объявление свойства не может содержать спецификатор переопределения (должен быть размещен в свойства вместо get/set методы)|
|[Ошибка компилятора C3799](compiler-error-c3799.md)|индексированные свойства не может иметь пустой список параметров|
|[Ошибка компилятора C3800](compiler-error-c3800.md)|"*объявление*": нельзя смешивать свойства и события|
|Ошибка компилятора C3801|"*атрибут*": атрибут не может быть предложения аргумента|
|Ошибка компилятора C3802|Является устаревшей.|
|[Ошибка компилятора C3803](compiler-error-c3803.md)|"*свойство*": свойство имеет тип, который несовместим с одной из его методов доступа*доступа*"|
|[Ошибка компилятора C3804](compiler-error-c3804.md)|"*член*": методы доступа для свойства должны либо быть статическими, либо не статическими|
|[Ошибка компилятора C3805](compiler-error-c3805.md)|"*маркера*": непредвиденная лексема, требуется либо "} «, либо»,"|
|Ошибка компилятора C3806|"*маркера*": непредвиденная лексема, требуется либо "{" или инициализатор члена|
|[Ошибка компилятора C3807](compiler-error-c3807.md)|"*тип*": класс с атрибутом ComImport не может наследовать от "*тип*", допускается только реализация интерфейса|
|[Ошибка компилятора C3808](compiler-error-c3808.md)|"*тип*": класс с атрибутом ComImport не может определять член "*член*", только абстрактный или функции dllimport разрешены|
|[Ошибка компилятора C3809](compiler-error-c3809.md)|"*тип*": тип управляемых/WinRT не может иметь любой дружественные функции, классы и интерфейсы|
|Ошибка компилятора C3810|Является устаревшей.|
|Ошибка компилятора C3811|Является устаревшей.|
|[Ошибка компилятора C3812](compiler-error-c3812.md)|«__property» должна быть первой лексемой в объявлении свойства|
|[Ошибка компилятора C3813](compiler-error-c3813.md)|объявление свойства может присутствовать только в определение типа управляемых/WinRT|
|Ошибка компилятора C3814|Является устаревшей.|
|[Ошибка компилятора C3815](compiler-error-c3815.md)|Тип возвращаемого значения метода "*член*" должен соответствовать типу последнего параметра метода задания|
|[Ошибка компилятора C3816](compiler-error-c3816.md)|"класс или структура *член*" ранее объявлен или определен с другим модификатором управляемых/WinRT|
|[Ошибка компилятора C3817](compiler-error-c3817.md)|"*объявление*": свойство может применяться только к функции|
|[Ошибка компилятора C3818](compiler-error-c3818.md)|объявление свойства массива "*свойство*«не будет перегружать свойство индекса»*свойство*"|
|Ошибка компилятора C3819|Является устаревшей.|
|[Ошибка компилятора C3820](compiler-error-c3820.md)|"*идентификатор*": инициализаторы должны быть управляемыми|
|[Ошибка компилятора C3821](compiler-error-c3821.md)|"*функция*": управляемый тип или функция не может использоваться в неуправляемую функцию|
|Ошибка компилятора C3822|Является устаревшей.|
|Ошибка компилятора C3823|Является устаревшей.|
|[Ошибка компилятора C3824](compiler-error-c3824.md)|"*тип*": этот тип не может использоваться в этом контексте (параметр функции, тип возвращаемого значения или статический член)|
|[Ошибка компилятора C3825](compiler-error-c3825.md)|"*тип*": класс управляемого/WinRT поддерживает только управляемые/WinRT события|
|Ошибка компилятора C3826|Является устаревшей.|
|Ошибка компилятора C3827|стандартный атрибут «deprecated» может иметь без аргументов или один строковый литерал, описывающий причину|
|[Ошибка компилятора C3828](compiler-error-c3828.md)|аргументы размещения невозможно указать для "*ключевое слово*«выражение для типа»*тип*"|
|Ошибка компилятора C3829|стандартный атрибут «noreturn» можно применять только к функциям|
|[Ошибка компилятора C3830](compiler-error-c3830.md)|"*тип1*": не может наследовать от "*тип2*", типы значений могут наследовать только от классов интерфейсов|
|[Ошибка компилятора C3831](compiler-error-c3831.md)|"*идентификатор*": "*тип*" не может иметь закрепленные данные-член или функция-член, возвращающую закрепляющий указатель|
|[Ошибка компилятора C3832](compiler-error-c3832.md)|"*typelib*": тип библиотеки выглядит так, как если бы оно было создано для 32-разрядных указателей; измените квалификатор «ptrsize»|
|[Ошибка компилятора C3833](compiler-error-c3833.md)|"*тип*": недопустимый целевой тип для *идентификатор*|
|[Ошибка компилятора C3834](compiler-error-c3834.md)|недопустимое явное приведение к Закрепляющему указателю; Вместо этого используйте закрепленную локальную переменную|
|Ошибка компилятора C3835|Является устаревшей.|
|[Ошибка компилятора C3836](compiler-error-c3836.md)|статический конструктор не должна содержать список инициализации членов|
|Ошибка компилятора C3837|атрибуты не допускаются в этом контексте|
|[Ошибка компилятора C3838](compiler-error-c3838.md)|не может наследовать от "*тип*"|
|[Ошибка компилятора C3839](compiler-error-c3839.md)|Нельзя изменять выравнивание в типе управляемых/WinRT|
|Ошибка компилятора C3840|Является устаревшей.|
|Ошибка компилятора C3841|Является устаревшей.|
|[Ошибка компилятора C3842](compiler-error-c3842.md)|"*идентификатор*": квалификаторы «const» и «volatile» для функций-членов управляемых/WinRT типов не поддерживаются.|
|Ошибка компилятора C3843|"*идентификатор*": квалификаторы ref в функциях-членах типов управляемых/WinRT не поддерживаются.|
|Ошибка компилятора C3844|"*идентификатор*": не удается импортировать символ из "*источника*": как*идентификатор*"уже существует в текущей области|
|Ошибка компилятора C3845|Является устаревшей.|
|[Ошибка компилятора C3846](compiler-error-c3846.md)|"*идентификатор*": не удается импортировать символ из "*источника*": как*идентификатор*«уже был импортирован из другой сборки»*сборки*'|
|Ошибка компилятора C3847|Является устаревшей.|
|[Ошибка компилятора C3848](compiler-error-c3848.md)|выражение, имеющее тип "*тип*«потеряет некоторые квалификаторы const или volatile для вызова»*идентификатор*"|
|[Ошибка компилятора C3849](compiler-error-c3849.md)|вызов в стиле функции выражения типа "*тип*" будут потеряны квалификаторы const и volatile для всех *номер* доступных перегрузок операторов|
|[Ошибка компилятора C3850](compiler-error-c3850.md)|"*маркера*": универсальное имя символа определяет недопустимый символ.|
|[Ошибка компилятора C3851](compiler-error-c3851.md)|"*маркера*": универсальное имя символа не может обозначать символ в базовом наборе символов|
|[Ошибка компилятора C3852](compiler-error-c3852.md)|"*член*«с типом»*тип*": агрегатной инициализации не удалось инициализировать этот член|
|[Ошибка компилятора C3853](compiler-error-c3853.md)|«=»: повторная инициализация ссылки или присвоение через ссылку на функцию не допускается|
|[Ошибка компилятора C3854](compiler-error-c3854.md)|выражение слева от «=» дает функцию. Не удается назначить функцию (функция не является l значение)|
|[Ошибка компилятора C3855](compiler-error-c3855.md)|"*функция*": шаблон или универсальный параметр "*идентификатор*" несовместим с объявлением|
|[Ошибка компилятора C3856](compiler-error-c3856.md)|"*класс*": класс не является шаблон класса или универсальный|
|[Ошибка компилятора C3857](compiler-error-c3857.md)|"*шаблона*": не допускается несколько списки вложенных или универсальных параметров|
|[Ошибка компилятора C3858](compiler-error-c3858.md)|"*идентификатор*": невозможно повторно объявить в текущей области|
|[Ошибка компилятора C3859](compiler-error-c3859.md)|диапазон виртуальной памяти для PCH превышено; Повторите компиляцию с параметром командной строки "-Zm*номер*" или более поздней версии|
|[Ошибка компилятора C3860](compiler-error-c3860.md)|список аргументов шаблона или универсальный после имени шаблона или универсальный класс параметры должны перечисляться в порядок, используемый в списке или универсальных параметров|
|[Ошибка компилятора C3861](compiler-error-c3861.md)|"*идентификатор*": идентификатор не найден|
|[Ошибка компилятора C3862](compiler-error-c3862.md)|"*функция*": не удается скомпилировать неуправляемую функцию с параметром/clr: pure или/CLR: safe|
|Ошибка компилятора C3863|тип массива "*тип*" не может быть назначен|
|Ошибка компилятора C3864|Является устаревшей.|
|[Ошибка компилятора C3865](compiler-error-c3865.md)|"*ключевое слово*": может использоваться только в собственных функциях-членах|
|[Ошибка компилятора C3866](compiler-error-c3866.md)|отсутствует список аргументов вызова деструктора или метода завершения|
|[Ошибка компилятора C3867](compiler-error-c3867.md)|"*функция*": нестандартный синтаксис; используйте «&», чтобы создать указатель на член|
|[Ошибка компилятора C3868](compiler-error-c3868.md)|"*тип*": ограничения на универсальный параметр "*параметр*" отличаются от ограничений на объявление|
|[Ошибка компилятора C3869](compiler-error-c3869.md)|в ограничении gcnew отсутствует пустой параметр list «()»|
|Ошибка компилятора C3870|"*параметр*": "__declspec (*описатель*)" может применяться только к параметрам целочисленных типов|
|Ошибка компилятора C3871|"*параметр*": «__declspec(guard(overflow))» поддерживается только для первых 64 параметров функции|
|[Ошибка компилятора C3872](compiler-error-c3872.md)|"0 x*значение*": этот символ невозможно использовать в идентификаторе|
|[Ошибка компилятора C3873](compiler-error-c3873.md)|"0 x*значение*": этот символ недопустим как первый символ идентификатора|
|[Ошибка компилятора C3874](compiler-error-c3874.md)|Тип возвращаемого значения "*идентификатор*«должно быть»*тип1*«вместо of»*тип2*"|
|Ошибка компилятора C3875|вызов-нестатической функции члена отсутствует список аргументов|
|Ошибка компилятора C3876|Является устаревшей.|
|Ошибка компилятора C3877|Является устаревшей.|
|Ошибка компилятора C3878|Является устаревшей.|
|Ошибка компилятора C3879|"*член*": не может быть данными-членом initonly|
|[Ошибка компилятора C3880](compiler-error-c3880.md)|"*член*": не может быть данными-членом литерала|
|Ошибка компилятора C3881|конструктор может наследовать только от прямого базового|
|Ошибка компилятора C3882|"*класс*": конструктор уже унаследован от "*класс*"|
|Ошибка компилятора C3883|"*член*": статические данные-член initonly должен быть инициализирован|
|Ошибка компилятора C3884|"*тип*": Массив неизвестного размера не может инициализироваться значением|
|Ошибка компилятора C3885|"*тип*": Не удается инициализировать массив неизвестного размера с помощью пустого списка инициализаторов|
|[Ошибка компилятора C3886](compiler-error-c3886.md)|"*член*": данные-член литерала должны инициализироваться|
|[Ошибка компилятора C3887](compiler-error-c3887.md)|"*член*": инициализатор данные-член литерала должно быть константным выражением|
|[Ошибка компилятора C3888](compiler-error-c3888.md)|"*член*": выражение константы, связанное с этом данными-членом литерала не поддерживается C++выполняет|
|Ошибка компилятора C3889|Является устаревшей.|
|[Ошибка компилятора C3890](compiler-error-c3890.md)|"*член*": невозможно получить адрес данные-член литерала|
|[Ошибка компилятора C3891](compiler-error-c3891.md)|"*член*": данные-член литерала нельзя использовать в качестве левого операнда|
|[Ошибка компилятора C3892](compiler-error-c3892.md)|"*переменной*": Невозможно присвоить переменной, которая является константным выражением|
|[Ошибка компилятора C3893](compiler-error-c3893.md)|"*член*": l значения можно использовать данные-член initonly допускается только в конструкторе экземпляра класса*класс*"|
|[Ошибка компилятора C3894](compiler-error-c3894.md)|"*член*": l значения можно использовать статические данные-член initonly допускается только в конструкторе класса для класса*класс*"|
|[Ошибка компилятора C3895](compiler-error-c3895.md)|"*член*": *тип* элементы данных не может быть «volatile»|
|[Ошибка компилятора C3896](compiler-error-c3896.md)|"*член*": недопустимый инициализатор: этот член данных литерала можно инициализировать только с «nullptr»|
|Ошибка компилятора C3897|Является устаревшей.|
|[Ошибка компилятора C3898](compiler-error-c3898.md)|"*член*": *тип* данные-члены могут быть только членами управляемых типов|
|[Ошибка компилятора C3899](compiler-error-c3899.md)|"*член*": l значения можно использовать данные-член initonly не допускается непосредственно внутри параллельной области в классе*класс*"|
|[Ошибка компилятора C3900](compiler-error-c3900.md)|"*член*": не допускается в текущей области|
|[Ошибка компилятора C3901](compiler-error-c3901.md)|"*функция*": должен иметь тип возвращаемого значения "*тип*"|
|[Ошибка компилятора C3902](compiler-error-c3902.md)|"*функция*": тип последнего параметра должен быть "*тип*"|
|[Ошибка компилятора C3903](compiler-error-c3903.md)|"*свойство*": does не установлен или get-метод|
|[Ошибка компилятора C3904](compiler-error-c3904.md)|"*свойство*": необходимо указать *номер* следующими параметрами:|
|Ошибка компилятора C3905|Невыровненные обращения не поддерживаются для подставляемого типа "*тип*"|
|Ошибка компилятора C3906|подставляемого типа "*тип*" не является поддерживаемым типом возврата или аргумент для функции с переменным количеством аргументов или без прототипа|
|Ошибка компилятора C3907|Является устаревшей.|
|[Ошибка компилятора C3908](compiler-error-c3908.md)|менее строгие, чем уровень доступа "*идентификатор*"|
|[Ошибка компилятора C3909](compiler-error-c3909.md)|объявление события WinRT или управляемого должно находиться в типе управляемых/WinRT|
|[Ошибка компилятора C3910](compiler-error-c3910.md)|"*событий*": должен определять член "*член*"|
|[Ошибка компилятора C3911](compiler-error-c3911.md)|"*член*": функция должна иметь тип "*тип*"|
|[Ошибка компилятора C3912](compiler-error-c3912.md)|"*событий*": тип события должен быть типом делегата|
|[Ошибка компилятора C3913](compiler-error-c3913.md)|свойство по умолчанию должно быть индексировано|
|[Ошибка компилятора C3914](compiler-error-c3914.md)|свойство по умолчанию не может быть статическим|
|[Ошибка компилятора C3915](compiler-error-c3915.md)|"*идентификатор*" имеет по умолчанию индексированное свойство (индексатора класса)|
|Ошибка компилятора C3916|Является устаревшей.|
|[Ошибка компилятора C3917](compiler-error-c3917.md)|"*маркера*": устаревшие *создания* стиль объявления (предполагалось использовать "[" "]" вместо?)|
|[Ошибка компилятора C3918](compiler-error-c3918.md)|требует использования "*идентификатор*" в качестве члена данных|
|[Ошибка компилятора C3919](compiler-error-c3919.md)|"*функция*": функция должна иметь тип "*return_type* (*типа*)"|
|[Ошибка компилятора C3920](compiler-error-c3920.md)|"*оператор*": не удается определить постфиксный увеличить или уменьшить значение вызове постфиксного оператора CLR или WinRT оператор CLR или WinRT будет вызов соответствующего префиксного CLR или WinRT оператор (op_Increment/op_Decrement), но со постфиксный семантика|
|Ошибка компилятора C3921|Является устаревшей.|
|Ошибка компилятора C3922|Является устаревшей.|
|[Ошибка компилятора C3923](compiler-error-c3923.md)|"*член*": определения локальных классов, структуры или объединения не разрешены в функции-члене класса WinRT или управляемого|
|Ошибка компилятора C3924|Ошибка в аргументе #*номер* вызова конструктора делегата "*конструктор*":|
|Ошибка компилятора C3925|Ожидался тип (for, while или do) следующих "*директива*" директива|
|Ошибка компилятора C3926|Недопустимая константа в директиве «parallel»|
|Ошибка компилятора C3927|«->»: завершающего возвращаемого типа не допускается после декларатора функции, не являющейся|
|Ошибка компилятора C3928|«->»: завершающего возвращаемого типа не допускается после декларатора в скобках|
|Ошибка компилятора C3929|Является устаревшей.|
|Ошибка компилятора C3930|"*функция*": нет перегруженной функции имеет описатели ограничений, совместимых с внешним контекстом "*контекст*"|
|Ошибка компилятора C3931|"*тип*": невозможно вызвать функцию, имеющую спецификаторы ограничений, несовместимые с внешним контекстом|
|Ошибка компилятора C3932|Является устаревшей.|
|Ошибка компилятора C3933|"*класс*": спецификаторы ограничения деструктора должны покрывать объединение ограничений для всех конструкторов|
|Ошибка компилятора C3934|функция, которая находится в любой форме «main» не может быть спецификаторов ограничений, отличных от restrict(cpu)|
|Ошибка компилятора C3935|"*идентификатор*": переопределение; перекрывающиеся спецификаторы ограничений|
|Ошибка компилятора C3936|"*идентификатор*": нераспознаваемый спецификатор ограничений|
|Ошибка компилятора C3937|пустой спецификатор ограничений не допускается|
|Ошибка компилятора C3938|"*идентификатор*": несколько описателей ограничений не поддерживаются для функций \042C\042 extern|
|Ошибка компилятора C3939|"*идентификатор*": указатель на функции-члены, указатели функций, ссылки на функции с описателем ограничения «amp» не допускаются|
|Ошибка компилятора C3940|"*идентификатор*": идентификатор не найден - возможное несоответствие между компилятора и версии библиотек. Следует обеспечить соответствие vccorlib.h/.lib, vccorlib120.dll и c1xx.dll|
|Ошибка компилятора C3941|"*условие*": требуется "/ clr" параметр командной строки|
|Ошибка компилятора C3942|Является устаревшей.|
|Ошибка компилятора C3943|Является устаревшей.|
|Ошибка компилятора C3944|Является устаревшей.|
|Ошибка компилятора C3945|"*тип*": невозможно выдать или перехватить объект winrt, не являющийся производным от Platform::Exception|
|Ошибка компилятора C3946|"*тип*": typeid невозможно применять к этому типу|
|Ошибка компилятора C3947|"*typeid*": typeid невозможно применять к раскрытию пакета|
|Ошибка компилятора C3948|"*ключевое слово*": раскрытие пакета не может использоваться в этом контексте|
|Ошибка компилятора C3949|Раскрытие пакета, «...», не может использоваться в абстрактного декларатора в скобках|
|Ошибка компилятора C3950|Является устаревшей.|
|Ошибка компилятора C3951|Нельзя использовать указатель на член в проецированном типе WinRT "*тип*". Вместо этого используйте делегат.|
|Ошибка компилятора C3952|"*тип*": WinRT не поддерживает «in/out» массивы. Используйте "const Array<T>^" для «in» и "WriteOnlyArray<T>" или "Array<T>^ *" для «out» в открытых API|
|Ошибка компилятора C3953|Нельзя использовать управляемый класс*тип*"в модуле WinRT.|
|Ошибка компилятора C3954|"*тип*": Массив, возвращаемый опубликованным методом в типе WinRT не может использовать форму "Array<T>^"|
|Ошибка компилятора C3955|"*тип*": Открытый конструктор не может содержать параметр «out» или "WriteOnlyArray<T>"|
|Ошибка компилятора C3956|"*тип*": Тип помечен как эксклюзивный для "*тип*«и не может использоваться в качестве базового тип»*производный_тип*"|
|Ошибка компилятора C3957|"*тип*": невозможно использовать «new» для WinRT типа; вместо этого используйте «ref new»|
|Ошибка компилятора C3958|"*тип*": нельзя использовать «gcnew» на WinRT типа; вместо этого используйте «ref new»|
|Ошибка компилятора C3959|«ref new» может использоваться только для создания объекта типа WinRT|
|Ошибка компилятора C3960|Является устаревшей.|
|Ошибка компилятора C3961|статический конструктор не поддерживается.|
|Ошибка компилятора C3962|Универсальный класс не поддерживается.|
|Ошибка компилятора C3963|многомерный массив не поддерживается.|
|Ошибка компилятора C3964|Массив массивов не поддерживается.|
|Ошибка компилятора C3965|Массив параметров не поддерживается.|
|Ошибка компилятора C3966|"*функция*": универсальная функция не поддерживается.|
|Ошибка компилятора C3967|Ошибка при импорте "*идентификатор*«из модуля»*модуль*"|
|Ошибка компилятора C3968|токен "*маркера*" является недопустимым разделителем имени модуля; использовать точку (".") вместо|
|Ошибка компилятора C3969|несогласованные имена модулей: "*module1*«и»*module1*"|
|Ошибка компилятора C3970|"*идентификатор*": "*ключевое слово*" может применяться только к «ref class» или «ref struct» в глобальной области или области видимости пространства имен|
|Ошибка компилятора C3971|"*тип*": разделяемое определение не может располагаться после полного определения|
|Ошибка компилятора C3972|"*тип*": «partial» может применяться только к объявлениям и определениям классов|
|Ошибка компилятора C3973|Является устаревшей.|
|Ошибка компилятора C3974|Является устаревшей.|
|Ошибка компилятора C3975|"класс или структура *идентификатор*" был ранее объявлен или определен с другим модификатором|
|Ошибка компилятора C3976|"*идентификатор1*«должен быть объявлен как 'public' для использования»*идентификатор2*"|
|Ошибка компилятора C3977|Использование необходима ссылка на сборку, определяющую "*идентификатор*"|
|Ошибка компилятора C3978|"*идентификатор*": статические свойства не допускается в качестве члена типа значения или интерфейса WinRT|
|Ошибка компилятора C3979|"*тип*": используйте атрибут "*атрибут*«вместо of»*значение*"|
|Ошибка компилятора C3980|"*тип*" нельзя передать в метаданных|
|Ошибка компилятора C3981|"*тип*": тип значения не может иметь любые статические данные-члены*идентификатор*"|
|Ошибка компилятора C3982|"*тип*": тип значения не может иметь любые данные, не являющиеся открытыми члены*идентификатор*"|
|Ошибка компилятора C3983|"*тип*": тип значения не может иметь любой общедоступный членов данных не*идентификатор*"|
|Ошибка компилятора C3984|"*тип*": незначимый тип не может иметь открытых элементов данных*идентификатор*"|
|Ошибка компилятора C3985|"*идентификатор*": сигнатура открытого члена содержит частный тип "*член*"|
|Ошибка компилятора C3986|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*член*"|
|Ошибка компилятора C3987|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*тип*"|
|Ошибка компилятора C3988|"*тип*": собственный тип не может быть открытым|
|Ошибка компилятора C3989|"*тип*": вложенный тип не может быть открытым|
|Ошибка компилятора C3990|"*тип*": атрибут "*атрибут*" не может быть закрытым или вложенным|
|Ошибка компилятора C3991|"*тип*": невозможно реализовать неоткрытый или вложенный интерфейс "*интерфейс*"|
|Ошибка компилятора C3992|"*идентификатор*": сигнатура открытого члена содержит недопустимый тип "*тип*"|
|Ошибка компилятора C3993|"*тип*": тип значения должен содержать по крайней мере одно открытое поле|
|Ошибка компилятора C3994|"*тип*": тип значения не может реализовывать интерфейсы или иметь виртуальные функции|
|Ошибка компилятора C3995|"*тип*": у типа значений не может быть членов событий*идентификатор*"|
|Ошибка компилятора C3996|Является устаревшей.|
|Ошибка компилятора C3998|"c ++*версии*": неподдерживаемая версия C++; по умолчанию принимается "c ++*версии*"|
|Ошибка компилятора C3999|НЕИЗВЕСТНАЯ ошибка выберите команду технической поддержки в меню справки Visual C++ или откройте Справочный файл технической поддержки, Дополнительные сведения|

## <a name="see-also"></a>См. также

[C /C++ ошибки и предупреждения средств компиляции и построения](../compiler-errors-1/c-cpp-build-errors.md) \
[Ошибки компилятора с C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
