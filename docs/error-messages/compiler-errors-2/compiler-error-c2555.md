---
title: Ошибка компилятора C2555
description: Ссылка на Visual Studio C' компилятор ошибка C2555.
ms.date: 03/30/2020
f1_keywords:
- C2555
helpviewer_keywords:
- C2555
ms.assetid: 5e49ebb8-7c90-457a-aa12-7ca7ab6574b2
ms.openlocfilehash: fe0e6379e783387506e6098c9b14a047baa8e6c8
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81374174"
---
# <a name="compiler-error-c2555"></a>Ошибка компилятора C2555

> '*class1*::*function1*': переопределение виртуального типа возврата функций отличается и не является covariant от '*class2*::*function2*'

Виртуальная функция и производная функция имеют одинаковые списки параметров, но различные типы возврата.

## <a name="remarks"></a>Remarks

В СЗ преобладающая функция в производном классе не может отличаться только по типу возврата от виртуальной функции в базовом классе.

Для определенных типов возврата есть исключение из этого правила. Когда производный класс переопределяет общедоступный базовый класс, он может вернуть указатель или ссылку на производный класс вместо указателя или ссылки базового класса. Эти типы возврата называются *covariant*, потому что они меняются вместе с типом. Это исключение правила не позволяет covariant ссылка на указатель или указатель к указателю типов.

Одним из способов устранения ошибки является возвращение того же типа, что и базовый класс. Затем отбросьте значение возврата после вызова виртуальной функции. Другой вариант заключается в том, чтобы также изменить список параметров, чтобы сделать функцию производного класса перегрузкой вместо переопределения.

## <a name="examples"></a>Примеры

Вы можете увидеть эту ошибку, если вы компилируете с **`/clr`**. Например, си-з эквивалент следующей декларации СЗ:

```csharp
Guid[] CheckSources(Guid sourceID, Guid[] carouselIDs);
```

is

```cpp
Guid CheckSources(Guid sourceID, Guid carouselIDs[]) [];
```

Следующий образец генерирует C2555:

```cpp
// C2555.cpp
// compile with: /c
struct X {
   virtual void func();
};
struct Y : X {
   char func();  // C2555
   void func2();   // OK
};
```

Чтобы исправить это, измените `Y::func` `void`тип возврата на .
