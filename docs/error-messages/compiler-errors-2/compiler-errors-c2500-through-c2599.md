---
title: Ошибки компилятора с C2500 по C2599
ms.date: 04/21/2019
f1_keywords:
- C2501
- C2508
- C2515
- C2519
- C2520
- C2522
- C2525
- C2527
- C2536
- C2538
- C2539
- C2546
- C2547
- C2559
- C2560
- C2564
- C2565
- C2576
- C2578
- C2580
- C2590
- C2591
- C2595
- C2596
helpviewer_keywords:
- C2501
- C2508
- C2515
- C2519
- C2520
- C2522
- C2525
- C2527
- C2536
- C2538
- C2539
- C2546
- C2547
- C2559
- C2560
- C2564
- C2565
- C2576
- C2578
- C2580
- C2590
- C2591
- C2595
- C2596
ms.assetid: a869aaed-e9f6-49e3-b273-00ea7f45bed7
ms.openlocfilehash: 87728c2d7055715b7e7d986d5ab8792ceba5c450
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62386594"
---
# <a name="compiler-errors-c2500-through-c2599"></a>Ошибки компилятора с C2500 по C2599

Статьи в этом разделе документации объясняется подмножество сообщения об ошибках, создаваемых компилятором.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Сообщения об ошибках

|Error|Сообщение|
|-----------|-------------|
|[Ошибка компилятора C2500](compiler-error-C2500.md)|"*идентификатор1*": "*идентификатор2*" уже является прямым базовым классом|
|Ошибка компилятора C2501|"*идентификатор*": "__declspec (*описатель*)" может применяться только для структур, объединений, классов или беззнаковых битовых поля элементов|
|[Ошибка компилятора C2502](compiler-error-C2502.md)|"*идентификатор*": слишком много модификаторов доступа для базового класса|
|[Ошибка компилятора C2503](compiler-error-C2503.md)|"*класс*": базовые классы не могут содержать массивы нулевого размера|
|[Ошибка компилятора C2504](compiler-error-C2504.md)|"*класс*": базовый класс не определен|
|[Ошибка компилятора C2505](compiler-error-C2505.md)|"*символ*": "__declspec (*описатель*)" может применяться только в объявлениях или определениях глобальных объектов или статические данные-члены|
|[Ошибка компилятора C2506](compiler-error-C2506.md)|"*член*": "__declspec (*описатель*)" не может применяться к этому символу|
|[Ошибка компилятора C2507](compiler-error-C2507.md)|"*идентификатор*": слишком много виртуальных модификаторов для базового класса|
|Ошибка компилятора C2508|"*идентификатор*": "__declspec (*спецификатор1*)" нельзя использовать вместе с "__declspec (*спецификатор2*)"|
|[Ошибка компилятора C2509](compiler-error-C2509.md)|"*идентификатор*": функция-член не объявлена в "*класс*"|
|[Ошибка компилятора C2510](compiler-error-C2510.md)|"*идентификатор*": выражение слева от "::" должен быть классом, структурой или объединением|
|[Ошибка компилятора C2511](compiler-error-C2511.md)|"*идентификатор*": перегруженная функция-член не найдена в "*класс*"|
|[Ошибка компилятора C2512](compiler-error-C2512.md)|"*идентификатор*": нет подходящего конструктора по умолчанию доступны|
|[Ошибка компилятора C2513](compiler-error-C2513.md)|"* тип": нет переменных, объявленных перед «=»|
|[Ошибка компилятора C2514](compiler-error-C2514.md)|"*класс*": класс не имеет конструкторов|
|Ошибка компилятора C2515|"*идентификатор*": «vtguard» может применяться только к объявлениям и определениям классов|
|[Ошибка компилятора C2516](compiler-error-C2516.md)|"*класс*": не является допустимым базовым классом|
|[Ошибка компилятора C2517](compiler-error-C2517.md)|"*идентификатор*": справа от "::" не определено|
|[Ошибка компилятора C2518](compiler-error-C2518.md)|Ключевое слово "*ключевое слово*" недопустим в списке базовых классов; пропускается|
|Ошибка компилятора C2519|"*идентификатор*": Атрибуты WinRT могут содержать только открытые поля|
|Ошибка компилятора C2520|"*класс*": нет неявных конструкторов для неявного преобразования|
|[Ошибка компилятора C2521](compiler-error-C2521.md)|метод завершения или деструктор не принимает аргументов|
|Ошибка компилятора C2522|"*идентификатор*": Идентификатор перегрузки не может использоваться для "*идентификатор1*«, так как он уже указан в»*идентификатор2*"|
|[Ошибка компилятора C2523](compiler-error-C2523.md)|"*класс*:: ~*идентификатор*": несовпадение тегов деструктора или метода завершения|
|[Ошибка компилятора C2524](compiler-error-C2524.md)|"*идентификатор*": метод завершения или деструктор должен иметь список параметров «void»|
|Ошибка компилятора C2525|"*идентификатор*": Параметр "*идентификатор1*«имеет имя»*идентификатор2*" на основе функции и должны совпадать в опубликованной реализации|
|[Ошибка компилятора C2526](compiler-error-C2526.md)|"*идентификатор1*": Функция с компоновкой C не может возвращать C++ класса*идентификатор2*"|
|Ошибка компилятора C2527|"*идентификатор*": Нельзя указывать defaultOverload на обоих "*функция1*«и»*функция2*". Удалите одну спецификацию или переименуйте функцию на этапе реализации|
|[Ошибка компилятора C2528](compiler-error-C2528.md)|"*идентификатор*": недопустимый указатель на ссылку|
|[Ошибка компилятора C2529](compiler-error-C2529.md)|"*идентификатор*": ссылка на ссылку недопустима|
|[Ошибка компилятора C2530](compiler-error-C2530.md)|"*идентификатор*": ссылки должны быть инициализированы|
|[Ошибка компилятора C2531](compiler-error-C2531.md)|"*идентификатор*": ссылка на битовое поле недопустима|
|[Ошибка компилятора C2532](compiler-error-C2532.md)|"*идентификатор*": недопустимый модификатор для ссылки|
|[Ошибка компилятора C2533](compiler-error-C2533.md)|"*идентификатор*": конструкторы не разрешены для возвращаемого типа|
|[Ошибка компилятора C2534](compiler-error-C2534.md)|"*идентификатор*": конструктор не может возвращать значение|
|[Ошибка компилятора C2535](compiler-error-C2535.md)|"*идентификатор*": функция-член уже определена или объявлена|
|Ошибка компилятора C2536|Является устаревшей.|
|[Ошибка компилятора C2537](compiler-error-C2537.md)|"*описатель*": Недопустимая спецификация компоновки|
|Ошибка компилятора C2538|Является устаревшей.|
|Ошибка компилятора C2539|Является устаревшей.|
|[Ошибка компилятора C2540](compiler-error-C2540.md)|неконстантное выражение в качестве границы массива|
|[Ошибка компилятора C2541](compiler-error-C2541.md)|"*идентификатор*": не удается удалить объекты, которые не являются указателями|
|[Ошибка компилятора C2542](compiler-error-C2542.md)|"*идентификатор*": класс не имеет конструктора для инициализации|
|[Ошибка компилятора C2543](compiler-error-C2543.md)|ожидается "]" для оператора «[]»|
|[Ошибка компилятора C2544](compiler-error-C2544.md)|Ожидалось ")" для оператора «()»|
|[Ошибка компилятора C2545](compiler-error-C2545.md)|"*оператор*": не удается найти перегруженный оператор|
|Ошибка компилятора C2546|"*идентификатор*": Если тип определен в сборках PIA и no-PIA, основная сборка ВЗАИМОДЕЙСТВИЯ должна быть указана первой|
|Ошибка компилятора C2547|"*идентификатор*": Все параметры опубликованного метода должны быть явно заданы в объявлении|
|[Ошибка компилятора C2548](compiler-error-C2548.md)|"*функция*": отсутствующий параметр по умолчанию для параметра *параметр*|
|[Ошибка компилятора C2549](compiler-error-C2549.md)|определенное пользователем преобразование невозможно указать тип возвращаемого значения|
|[Ошибка компилятора C2550](compiler-error-C2550.md)|"*идентификатор*": список инициализации конструктора допустимы только в месте определения конструктора|
|[Ошибка компилятора C2551](compiler-error-C2551.md)|для типа "void *" требуется явное приведение|
|[Ошибка компилятора C2552](compiler-error-C2552.md)|"*идентификатор*": не агрегированных нельзя инициализировать с помощью списка инициализаторов|
|[Ошибка компилятора C2553](compiler-error-C2553.md)|"*тип* *derived_class*::*функция*": переопределение тип возвращаемого значения виртуальной функции отличается от "*тип* *base_ Класс*::*функция*"|
|[Ошибка компилятора C2555](compiler-error-C2555.md)|"*derived_class*::*функция*": переопределение виртуальной функции возвращают тип отличается и не является ковариантным из "*base_class*::*функция*'|
|[Ошибка компилятора C2556](compiler-error-C2556.md)|"*тип1* *класс*::*функция*": перегруженная функция отличается только типом возвращаемого значения из "*тип2* *класс*::*функция*"|
|[Ошибка компилятора C2557](compiler-error-C2557.md)|"*идентификатор*": закрытые и защищенные члены нельзя инициализировать без конструктора|
|[Ошибка компилятора C2558](compiler-error-C2558.md)|Класс*класс*": нет доступных конструкторов копии или конструктор копии объявлен как «explicit»|
|Ошибка компилятора C2559|"*идентификатор*": нельзя перегрузить функцию-член без квалификатора ref функцией-членом с квалификатором ref|
|Ошибка компилятора C2560|"*идентификатор*": нельзя перегрузить функцию-член с квалификатором ref функцией-членом без квалификатора ref|
|[Ошибка компилятора C2561](compiler-error-C2561.md)|"*функция*": функция должна возвращать значение|
|[Ошибка компилятора C2562](compiler-error-C2562.md)|"*функция*": «void» функция, возвращающая значение|
|[Ошибка компилятора C2563](compiler-error-C2563.md)|Несоответствие в списке формальных параметров|
|Ошибка компилятора C2564|Является устаревшей.|
|Ошибка компилятора C2565|"*идентификатор*": квалификатор ref недопустим для конструкторов и деструкторов|
|[Ошибка компилятора C2566](compiler-error-C2566.md)|перегруженная функция в условном выражении|
|[Ошибка компилятора C2567](compiler-error-C2567.md)|не удается открыть метаданные в "*filename*", *possible_reason*|
|[Ошибка компилятора C2568](compiler-error-C2568.md)|"*идентификатор*": не удалось разрешить перегрузку функции|
|[Ошибка компилятора C2569](compiler-error-C2569.md)|"*идентификатор*": перечисление или объединение не может использоваться в качестве базового класса|
|[Ошибка компилятора C2570](compiler-error-C2570.md)|"*идентификатор*": объединение не может иметь базовые классы|
|[Ошибка компилятора C2571](compiler-error-C2571.md)|"*идентификатор*": виртуальная функция не может быть в объединении "*объединение*"|
|[Ошибка компилятора C2572](compiler-error-C2572.md)|"*функция*": переопределение параметра по умолчанию: параметр *номер*|
|[Ошибка компилятора C2573](compiler-error-C2573.md)|"*класс*": невозможно удалить указатели на объекты этого типа; в классе есть ни одна из перегрузок «operator delete» без аргументов размещения. Используйте:: удалить или добавить к классу «operator delete(void*)»|
|[Ошибка компилятора C2574](compiler-error-C2574.md)|"*деструктор*": нельзя объявлять как статическое|
|[Ошибка компилятора C2575](compiler-error-C2575.md)|"*идентификатор*": только функции-члены и базовые классы могут быть виртуальными|
|Ошибка компилятора C2576|"*идентификатор*": не удается внести нового виртуального метода как «public». Попробуйте сделать метод невиртуальным или измените специальные возможности «internal» или «protected private»|
|[Ошибка компилятора C2577](compiler-error-C2577.md)|"*идентификатор*": деструктор или метод завершения не может иметь тип возвращаемого значения|
|Ошибка компилятора C2578|"*класс*": тип не может иметь «protected» или «protected общедоступный» конструктор|
|[Ошибка компилятора C2579](compiler-error-C2579.md)|не удалось разрешить тип *тип* (*смещение*). Ожидается в *имя файла*|
|Ошибка компилятора C2580|"*идентификатор*": несколько версий установленных по умолчанию специальные функции-члены не допускаются.|
|[Ошибка компилятора C2581](compiler-error-C2581.md)|"*тип*": статические "оператор =" функция является недопустимым|
|[Ошибка компилятора C2582](compiler-error-C2582.md)|"оператор *оператор*«функция недоступна в»*тип*"|
|[Ошибка компилятора C2583](compiler-error-C2583.md)|"*идентификатор*": «const или volatile» указатель «this» является недопустимым для конструкторов и деструкторов|
|[Ошибка компилятора C2584](compiler-error-C2584.md)|"*класс*": прямым базовым классом "*base_class2*" недоступен; уже является базовым "*base_class1*"|
|[Ошибка компилятора C2585](compiler-error-C2585.md)|явное преобразование в "*тип*" является неоднозначным|
|[Ошибка компилятора C2586](compiler-error-C2586.md)|синтаксис неверное преобразование определяемых пользователем: недопустимые косвенные обращения|
|[Ошибка компилятора C2587](compiler-error-C2587.md)|"*идентификатор*": Недопустимое использование локальной переменной в качестве параметра по умолчанию|
|[Ошибка компилятора C2588](compiler-error-C2588.md)|":: ~*идентификатор*": недопустимый глобальный деструктор или метод завершения|
|[Ошибка компилятора C2589](compiler-error-C2589.md)|"*идентификатор*": недопустимая лексема справа от "::"|
|Ошибка компилятора C2590|"*идентификатор*": только конструктор может иметь список инициализации базового класса или члена|
|Ошибка компилятора C2591|ExclusiveTo не может использовать "*тип*" как аргумент. Только «ref class» является допустимым аргументом|
|[Ошибка компилятора C2592](compiler-error-C2592.md)|"*класс*": "*base_class2*«наследуется от»*base_class1*" и не может быть указан повторно|
|[Ошибка компилятора C2593](compiler-error-C2593.md)|"оператор *идентификатор*" является неоднозначным|
|[Ошибка компилятора C2594](compiler-error-C2594.md)|"*оператор*": неоднозначные преобразования из "*тип1*«to»*тип2*"|
|Ошибка компилятора C2595|"*идентификатор*" тип атрибута WinRT должен быть запечатан|
|Ошибка компилятора C2596|"*идентификатор*" поле атрибута WinRT может быть только «public enum class», «int», «unsigned int», «bool», «Platform::Type», «Platform::String» или «Windows: Foundation:: HResult»|
|[Ошибка компилятора C2597](compiler-error-C2597.md)|Недопустимая ссылка на нестатический член "*идентификатор*"|
|[Ошибка компилятора C2598](compiler-error-C2598.md)|компоновки должен определяться в глобальной области видимости|
|[Ошибка компилятора C2599](compiler-error-C2599.md)|"*идентификатор*": опережающее объявление перечисления управляемых/WinRT не допускается|

## <a name="see-also"></a>См. также

[C /C++ ошибки и предупреждения средств компиляции и построения](../compiler-errors-1/c-cpp-build-errors.md) \
[Ошибки компилятора с C2000 - C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
