---
description: 'Дополнительные сведения о: Ошибка компилятора C2672'
title: Ошибка компилятора C2672
ms.date: 10/24/2017
f1_keywords:
- C2672
helpviewer_keywords:
- C2672
ms.assetid: 7e86338a-2d4b-40fe-9dd2-ac6886f3f31a
ms.openlocfilehash: 2de901eaa416f3ee675c7b09c342de74dc7207fe
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97282085"
---
# <a name="compiler-error-c2672"></a>Ошибка компилятора C2672

> "*функция*": не найдена соответствующая перегруженная функция

Компилятору не удалось найти перегруженную функцию, которая соответствует заданной функции. Не удалось найти функцию, которая принимает совпадающие параметры, или ни одна соответствующая функция не имеет требуемого уровня доступа в контексте.

При использовании определенных контейнеров или алгоритмов стандартной библиотеки типы должны предоставлять доступ к доступным членам или дружественным функциям, которые удовлетворяют требованиям контейнера или алгоритма. Например, типы итераторов должны быть производными от `std::iterator<>` . Для операций сравнения или использования других операторов в типах элементов контейнера может потребоваться, чтобы тип рассматривался как левый и правый операнд. Использование типа в качестве правого операнда может потребовать реализации оператора в качестве функции, не являющейся членом типа.

## <a name="example"></a>Пример

Версии компилятора перед тем, как Visual Studio 2017 не выполняла проверку доступа к полным именам в некоторых контекстах шаблонов. Это может помешать ожидаемой работе SFINAE там, где подстановка должна завершиться ошибкой из-за отсутствия доступа к имени. Такая ситуация может приводить к сбою или неожиданному поведению во время выполнения из-за того, что компилятор неправильно вызывает неверную перегрузку оператора. В Visual Studio 2017 выводится ошибка компилятора.

Этот пример компилируется в Visual Studio 2015, но вызывает ошибку в Visual Studio 2017. Чтобы устранить эту проблему, сделайте член параметра шаблона доступным в том месте, где он вычисляется.

```cpp
#include <type_traits>

template <class T> class S {
// public:    // Uncomment this line to fix
    typedef typename T type;
};

template <class T, std::enable_if<std::is_integral<typename S<T>::type>::value, T> * = 0>
bool f(T x)
{
    return (x == 0);
}

int main()
{
    f(10); // C2672: No matching overloaded function found.
}
```
