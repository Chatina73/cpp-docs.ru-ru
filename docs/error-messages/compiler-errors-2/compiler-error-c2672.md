---
title: Ошибка компилятора C2672
ms.date: 10/24/2017
f1_keywords:
- C2672
helpviewer_keywords:
- C2672
ms.assetid: 7e86338a-2d4b-40fe-9dd2-ac6886f3f31a
ms.openlocfilehash: 9f844b54285a7df69bfb4387a7afcc82dfef9252
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80177135"
---
# <a name="compiler-error-c2672"></a>Ошибка компилятора C2672

> "*функция*": не найдена соответствующая перегруженная функция

Компилятору не удалось найти перегруженную функцию, которая соответствует заданной функции. Не удалось найти функцию, которая принимает совпадающие параметры, или ни одна соответствующая функция не имеет требуемого уровня доступа в контексте.

При использовании определенных контейнеров или алгоритмов стандартной библиотеки типы должны предоставлять доступ к доступным членам или дружественным функциям, которые удовлетворяют требованиям контейнера или алгоритма. Например, типы итераторов должны быть производными от `std::iterator<>`. Для операций сравнения или использования других операторов в типах элементов контейнера может потребоваться, чтобы тип рассматривался как левый и правый операнд. Использование типа в качестве правого операнда может потребовать реализации оператора в качестве функции, не являющейся членом типа.

## <a name="example"></a>Пример

Версии компилятора перед тем, как Visual Studio 2017 не выполняла проверку доступа к полным именам в некоторых контекстах шаблонов. Это может помешать ожидаемой работе SFINAE там, где подстановка должна завершиться ошибкой из-за отсутствия доступа к имени. Такая ситуация может приводить к сбою или неожиданному поведению во время выполнения из-за того, что компилятор неправильно вызывает неверную перегрузку оператора. В Visual Studio 2017 выводится ошибка компилятора.

Этот пример компилируется в Visual Studio 2015, но вызывает ошибку в Visual Studio 2017. Чтобы устранить эту проблему, сделайте член параметра шаблона доступным в том месте, где он вычисляется.

```cpp
#include <type_traits>

template <class T> class S {
// public:    // Uncomment this line to fix
    typedef typename T type;
};

template <class T, std::enable_if<std::is_integral<typename S<T>::type>::value, T> * = 0>
bool f(T x)
{
    return (x == 0);
}

int main()
{
    f(10); // C2672: No matching overloaded function found.
}
```
