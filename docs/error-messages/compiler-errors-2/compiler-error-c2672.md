---
title: Ошибка компилятора C2672
ms.date: 10/24/2017
f1_keywords:
- C2672
helpviewer_keywords:
- C2672
ms.assetid: 7e86338a-2d4b-40fe-9dd2-ac6886f3f31a
ms.openlocfilehash: df0f656c9db23739ec62629088b9cc5f7950a92d
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50570447"
---
# <a name="compiler-error-c2672"></a>Ошибка компилятора C2672

> "*функция*": не совпадающая перегруженная функция найдена.

Компилятору не удалось найти перегруженной функции, соответствующий указанной функции. Функция не найден, что принимает соответствующие параметры, или ни одна из функций сопоставления имеет необходимые специальных возможностей в контексте.

При использовании определенных контейнеры стандартной библиотеки или алгоритмы, типов необходимо указать доступные члены и дружественные функции, которые удовлетворяют требованиям контейнера или алгоритм. Например, типы итератора должен быть производным от `std::iterator<>`. Операции сравнения или использование других операторов на типы элемента контейнера может потребоваться тип рассматриваться как левый и правый операнд. Используется тип как правый операнд может потребоваться реализация оператора как функцию не являющиеся членами типа.

## <a name="example"></a>Пример

Проверка доступа к полным именам в некоторых контекстах шаблонов не выполнил версии компилятора до Visual Studio 2017. Это может помешать ожидаемой работе SFINAE там, где подстановка должна завершиться ошибкой из-за отсутствия доступа к имени. Такая ситуация может приводить к сбою или неожиданному поведению во время выполнения из-за того, что компилятор неправильно вызывает неверную перегрузку оператора. В Visual Studio 2017 выводится ошибка компилятора.

В этом примере компилируется в Visual Studio 2015, но вызывает ошибку в Visual Studio 2017. Чтобы устранить эту проблему, сделайте элемент параметра шаблона, доступного где оно вычисляется.

```cpp
#include <type_traits>

template <class T> class S {
// public:    // Uncomment this line to fix
    typedef typename T type;
};

template <class T, std::enable_if<std::is_integral<typename S<T>::type>::value, T> * = 0>
bool f(T x)
{
    return (x == 0);
}

int main()
{
    f(10); // C2672: No matching overloaded function found.
}
```