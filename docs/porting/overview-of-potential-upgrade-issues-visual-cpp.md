---
title: Общие сведения о возможных проблемах, возникающих при обновлении (Visual C++) | Документы Майкрософт
ms.custom: ''
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 2c99a8cb-098f-4a9d-bf2c-b80fd06ace43
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 742d722033d0fb2e686861d0e09fc45c73540ade
ms.sourcegitcommit: a9dcbcc85b4c28eed280d8e451c494a00d8c4c25
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/25/2018
ms.locfileid: "50075766"
---
# <a name="overview-of-potential-upgrade-issues-visual-c"></a>Общие сведения о возможных проблемах, возникающих при обновлении (Visual C++)

За прошедшие годы компилятор Microsoft Visual C++ претерпел множество изменений, кроме того, изменения были внесены и в сам язык C++, стандартную библиотеку C++, среду выполнения C (CRT) и другие библиотеки, например MFC и ATL. В результате при обновлении приложения с более ранней версии Visual Studio могут возникнуть ошибки компилятора и компоновщика, а также появиться предупреждения в коде, который ранее компилировался без проблем. Чем старше исходная база кода, тем больше вероятность таких ошибок. Этот обзор охватывает наиболее распространенные виды проблем, с которыми вы можете столкнуться, а также содержит ссылки на более подробные сведения.

> [!NOTE]
> Раньше мы рекомендовали выполнять обновления, охватывающие несколько версий Visual Studio, последовательно, переходя от версии к версии. Однако теперь это не так. Мы обнаружили, что в подавляющем большинстве случаев проще выполнить обновление до самой новой версии Visual Studio независимо от возраста базы кода.

Вопросы и комментарии о процессе обновления можно отправить на адрес vcupgrade@microsoft.com.

## <a name="library-and-toolset-dependencies"></a>Зависимости библиотек и наборов средств

При обновлении приложения до новой версии Visual Studio настоятельно рекомендуется, а во многих случаях — необходимо, обновить также все библиотеки и библиотеки DLL, на которые ссылается приложение. Для этого вам требуется иметь доступ к исходному коду либо получить от поставщика библиотеки новые двоичные файлы, скомпилированные в компиляторе с таким же основным номером версии. Если одно из этих условий соблюдено, можете пропустить данный раздел со сведениями о совместимости двоичных данных. Если ни одно из условий не выполняется, возможно, что использовать библиотеки в обновленном приложении вы не сможете. Приведенные в этом разделе сведения помогут вам понять, можно ли продолжать обновление.

### <a name="toolset"></a>Набор инструментов

Форматы файлов OBJ и LIB четко определены и редко изменяются. Иногда в них вносятся дополнения, однако они обычно не препятствуют использованию объектных файлов и библиотек, созданных в более старых наборах инструментов. Одним важным исключением здесь является компиляция с помощью [/GL (оптимизация всей программы)](../build/reference/gl-whole-program-optimization.md). При компиляции с помощью `/GL` итоговый объектный файл может быть связан только с тем набором инструментов, который использовался для его создания. Таким образом, если вы создаете объектный файл, используя `/GL` и компилятор Visual Studio 2017 (версии 141), нужно скомпоновать его с помощью компоновщика Visual Studio 2017 (версии 141). Это вызвано тем, что внутренние структуры данных в объектных файлах не являются стабильными в разных основных номерах версий набора инструментов, поэтому более новые наборы инструментов не поддерживают старые форматы данных.

У C++ нет стабильного двоичного интерфейса приложений (ABI). Visual Studio предоставляет стабильный ABI C++ для всех дополнительных номеров версий выпуска. Например, среда Visual Studio 2017 и все ее обновления совместимы на уровне двоичного кода. Но ABI не всегда совместим в разных основных номерах версий Visual Studio (кроме версий 2015 и 2017, которые _являются_ совместимыми на уровне двоичного кода). Например, мы можем вносить критические изменения в макет типа C++, декорирование имен, обработку исключений и другие компоненты ABI C++. Поэтому объектный файл, содержащий внешние символы с компоновкой C++, может неправильно связываться с объектными файлами, созданными с помощью другого основного номера версии набора инструментов. Обратите внимание, что под словами "может не работать" здесь подразумевается много возможных ситуаций: связь полностью не работает (например, при изменении декорирования имен), связь завершается успешно, но компоненты не работают во время выполнения (например, при изменении макета типа) либо все может работать правильно. Обратите внимание, что хотя ABI C++ не является стабильным, ABI C и подмножество ABI C++, необходимые для модели COM, стабильны.

При компоновке с библиотекой импорта любые более поздние версии библиотек распространяемых компонентов Visual Studio, которые сохраняют совместимость с ABI, можно использовать во время выполнения. Например, если приложение скомпилировано и скомпоновано с помощью набора инструментов Visual Studio 2015 с обновлением 3, вы можете использовать любой распространяемый компонент Visual Studio 2017, так как библиотеки 2015 и 2017 сохранили обратную совместимость двоичного кода. Обратная совместимость невозможна. Вы не можете использовать распространяемый компонент для версии набора инструментов, предшествующей той, которую вы использовали для создания кода, даже если он содержал совместимый ABI.

### <a name="libraries"></a>Библиотеки

При компиляции исходного файла с помощью определенной версии файлов заголовков библиотек C++ Visual Studio (заголовки включаются посредством #including) полученный объектный файл должен быть скомпонован с использованием той же версии библиотек. Например, при компиляции файла исходного кода с использованием \<immintrin.h> из Visual Studio 2015 с обновлением 3 необходима компоновка с библиотекой vcruntime Visual Studio 2015 с обновлением 3. Аналогичным образом, если файл исходного кода компилируется с помощью \<iostream> из Visual Studio 2017 версии 15.5, нужна компоновка со стандартной библиотекой C++ Visual Studio 2017 версии 15.5 — msvcprt. Комбинирование по своему усмотрению не поддерживается.

Для стандартной библиотеки C++ комбинирование по своему усмотрению явно запрещено за счет применения `#pragma detect_mismatch` в стандартных заголовках со времени выпуска Visual Studio 2010. Если попытаться скомпоновать несовместимые объектные файлы либо выполнить компоновку с неподходящей стандартной библиотекой, такая компоновка завершается ошибкой.

Для CRT комбинирование по своему усмотрению никогда не поддерживалось, но часто работало, по крайней мере до появления Visual Studio 2015 и универсальной CRT, так как поверхность API изменялась не слишком сильно. В универсальной CRT такая обратная совместимость была нарушена, чтобы мы могли обеспечивать обратную совместимость в будущем. Другими словами, у нас пока нет планов для введения новых двоичных файлов с разными версиями для универсальной CRT. Вместо этого существующая универсальная CRT теперь обновляется на месте.

Чтобы обеспечить частичную совместимость компоновки с объектными файлами (и библиотеками), скомпилированными с использованием более старых версий заголовков среды выполнения Microsoft C, мы предоставляем библиотеку legacy_stdio_definitions.lib, входящую в состав Visual Studio 2015 и более поздних версий. Эта библиотека содержит символы совместимости для большинства функций и экспортов данных, которые были удалены из универсальной CRT. Предоставляемого legacy_stdio_definitions.lib набора символов совместимости достаточно для большинства зависимости, включая все зависимости в библиотеках, входящих в пакет Windows SDK. Однако для некоторых символов, удаленных из универсальной CRT, невозможно предоставить подобные символы совместимости. В таким символам относятся некоторые функции (например, \_\_iob\_func) и экспорты данных (например, \_\_imp\_\_\_iob, \_\_imp\_\_\_pctype, \_\_imp\_\_\_mb\_cur\_max).

При наличии статической библиотеки, которая была создана с более старой версии заголовков библиотеки времени выполнения C, мы рекомендуем следующие действия (в указанном порядке):

1. Перестройте статическую библиотеку с помощью Visual Studio 2017 и заголовков универсальной CRT, чтобы обеспечить поддержку компоновки с универсальной CRT. Это вариант полностью поддерживается (и поэтому является наиболее оптимальным).

1. Если вы не можете (или не хотите) перестраивать статическую библиотеку, можно попробовать выполнить компоновку с legacy\_stdio\_definitions.lib. Если этот компонент удовлетворяет зависимостям времени компоновки для вашей статической библиотеки, потребуется тщательно протестировать использование статической библиотеки в двоичном коде, чтобы убедиться, что ее не затрагивают все те [поведенческие изменения, которые были внесены в универсальную CRT](visual-cpp-change-history-2003-2015.md#BK_CRT).

1. Если зависимости статической библиотеки не совместимы с legacy\_stdio\_definitions.lib или библиотека не работает с универсальной CRT из-за вышеупомянутых изменений поведения, рекомендуется инкапсулировать статическую библиотеку в библиотеку DLL, которую можно связать с нужной версией среды выполнения Microsoft C. Например, если статическая библиотека создана с помощью Visual Studio 2013, следует создать такую библиотеку DLL с помощью Visual Studio 2013 и библиотек C++ Visual Studio 2013. Встроив библиотеку в библиотеку DLL, вы инкапсулируете сведения о реализации, представляющие ее зависимость от определенной версии среды выполнения Microsoft C. (При этом вам потребуется следить за тем, чтобы интерфейс DLL не вызывал "утечку" сведений об используемой среде выполнения C, например, возвращая FILE* через границу библиотеки DLL либо возвращая выделенный указатель malloc и ожидая, что вызывающий объект освободит его.)

Использование нескольких библиотек CRT в одном процессе само по себе не вызывает проблем (ведь большинство процессов вызывает загрузку нескольких библиотек DLL CRT; например, компоненты операционной системы Windows будут зависеть от msvcrt.dll, а среда CLR будет зависеть от собственной закрытой CRT). Проблемы возникают, когда вы смешиваете состояния из разных CRT. Например, не следует выделять память с помощью msvcr110.dll!malloc и попытаться освободить ее с помощью msvcr120.dll!free либо открывать файл с помощью msvcr110! fopen и пытаться считать его с помощью msvcr120! fread. Если же вы не делаете это, то можете безопасно использовать несколько CRT, загруженных в одном процессе.

Дополнительные сведения см. в разделе [Обновление кода для универсальной среды выполнения C](upgrade-your-code-to-the-universal-crt.md).

## <a name="errors-due-to-project-settings"></a>Ошибки, вызванные параметрами проекта

Чтобы начать процесс обновления, просто откройте старую версию проекта, решения или рабочей области в последней версии Visual Studio. Visual Studio создаст новый проект на основе старых параметров проекта. Если старый проект содержит библиотеку или пути, жестко заданные с нестандартными расположениями, возможно, что при использовании параметров проекта по умолчанию находящиеся по этим путям файлы не будут видны компилятору. Дополнительные сведения см. в разделе [Параметр OutputFile компоновщика](porting-guide-spy-increment.md#linker_output_settings).

В общем случае сейчас уместно правильно упорядочить код проекта, чтобы упростить обслуживание проекта и ускорить компиляцию кода. Если исходный код уже хорошо структурирован, а старый проект скомпилирован с помощью Visual Studio 2010 или более поздней версии, можно вручную изменить файл проекта, чтобы обеспечить поддержку компиляции как в старом, так в новом компиляторе. Следующий пример демонстрирует компиляцию для Visual Studio 2015 и Visual Studio 2017:

```xml
<PlatformToolset Condition="'$(VisualStudioVersion)'=='14.0'">v140</PlatformToolset>
<PlatformToolset Condition="'$(VisualStudioVersion)'=='15.0'">v141</PlatformToolset>
```

### <a name="lnk2019-unresolved-external"></a>LNK2019: неразрешенные внешние элементы

Для неразрешенных символов вам может потребоваться исправить параметры проекта.

- Если исходный файл находится не в расположении по умолчанию, добавили ли вы этот путь в число каталогов проекта?

- Если внешний элемент определен в LIB-файле, указали ли вы путь к этому файлу в свойствах проекта и находится ли там правильная версия LIB-файла?

- Вы пытаетесь выполнить компоновку с LIB-файлом, скомпилированным с помощью другой версии Visual Studio? Если это так, см. предыдущий раздел о зависимостях наборов инструментов и библиотек.

- Типы аргументов в месте вызова соответствуют существующей перегрузке функции? Убедитесь, что базовые типы для всех определений типов в сигнатуре функции и коде, который вызывает эту функцию, соответствуют вашим ожиданиям.

Для устранения неполадок с неразрешенным символом попробуйте использовать dumpbin.exe для изучения символов, определенных в двоичном файле. Попробуйте выполнить следующую команду для просмотра символов, определенных в библиотеке:

```cmd
dumpbin.exe /LINKERMEMBER somelibrary.lib
```

### <a name="zcwchart-wchart-is-native-type"></a>/Zc:wchar_t (wchar_t – это собственный тип)

(В Microsoft Visual C++ 6.0 и более ранней версии **wchar_t** не был реализован как встроенный тип, а объявлялся в файле wchar.h как определение типа для короткого числа без знака.) Стандарт C++ требует, чтобы **wchar_t** был встроенным типом. Использование версии определения типа может вызывать проблемы переносимости. Если при обновлении с более ранней версии Visual Studio возникает ошибка компилятора C2664 в связи с тем, что код пытается выполнить неявное преобразование типа **wchar_t** в тип **unsigned short**, рекомендуется изменить код, чтобы устранить ошибку, но не менять значение параметра `/Zc:wchar_t-`. Дополнительные сведения см. в разделе [/Zc:wchar_t (wchar_t — это собственный тип)](../build/reference/zc-wchar-t-wchar-t-is-native-type.md).

### <a name="upgrading-with-the-linker-options-nodefaultlib-entry-and-noentry"></a>Обновление при использовании параметров компоновщика /NODEFAULTLIB, /ENTRY и /NOENTRY

Параметр компоновщика `/NODEFAULTLIB` (или свойство компоновщика "Игнорировать все стандартные библиотеки") указывает компоновщику не выполнять автоматическую компоновку в библиотеках по умолчанию, таких как CRT. Это означает, что каждую библиотеку нужно отдельно указать в качестве входных данных. Этот список библиотек представлен в свойстве **Дополнительные зависимости** в разделе **Компоновщик** диалогового окна **Свойства проекта**.

Проекты, использующие этот параметр, вызывают проблемы при обновлении, связанные с изменением имен некоторых библиотек по умолчанию. Так как требуется указать каждую библиотеку в свойстве **Дополнительные зависимости** или в командной строке компоновщика, нужно обновить список библиотек, чтобы использовать актуальные имена.

В следующей таблице приведены библиотеки, имена которых были изменены, начиная с Visual Studio 2015. Для обновления нужно заменить имена в первом столбце на имена во втором столбце. Некоторые из этих библиотек являются библиотеками импорта, однако это не должно иметь никакого значения.

|||
|-|-|
|При использовании:|Нужно заменить на:|
|libcmt.lib|libucrt.lib, libvcruntime.lib|
|libcmtd.lib|libucrtd.lib, libvcruntimed.lib|
|msvcrt.lib|ucrt.lib, vcruntime.lib|
|msvcrtd.lib|ucrtd.lib, vcruntimed.lib|

Аналогичная проблема возникает и при использовании параметра `/ENTRY` или `/NOENTRY`, которые также позволяют обойти библиотеки по умолчанию.

## <a name="errors-due-to-improved-language-conformance"></a>Ошибки, вызванные улучшенным соответствием языку

Доработка компилятора Microsoft Visual C++, призванная улучшить его соответствие стандарту C++, ведется уже много лет. Код, скомпилированный в предыдущих версиях, может не компилироваться в Visual Studio 2017, так как теперь компилятор корректно выдает ошибку, которую ранее игнорировал либо явно допускал.

Например, параметр `/Zc:forScope` появился в MSVC уже очень давно. Он разрешает несоответствующее поведение для переменных цикла. Теперь этот параметр является нерекомендуемым и может быть удален в будущих версиях. Настоятельно рекомендуется не использовать этот параметр при обновлении кода. Дополнительные сведения см. в разделе [/Zc:forScope использовать не рекомендуется](porting-guide-spy-increment.md#deprecated_forscope).

Одним из примеров распространенных ошибок компилятора, с которыми можно столкнуться при обновлении, является передача неконстантного аргумента в константный параметр. Более старые версии компилятора не всегда считали это ошибкой. Дополнительные сведения см. в разделе [Более строгие преобразования компилятора](porting-guide-spy-increment.md#stricter_conversions).

Дополнительные сведения о конкретных улучшениях соответствия см. в разделах [Журнал изменений Visual C++ 2003–2015](visual-cpp-change-history-2003-2015.md) и [Улучшения соответствия C++ в Visual Studio 2017](../cpp-conformance-improvements-2017.md).

## <a name="errors-involving-stdinth-integral-types"></a>Ошибки, связанные с целочисленными типами \<stdint.h>

Заголовок \<stdint.h> задает определения типов и макросы, которые, в отличие от встроенных целочисленных типов, гарантированно имеют указанную длину на всех платформах. Примеры: `uint32_t` и `int64_t`. Заголовок \<stdint.h> был добавлен в Visual Studio 2010. Код, написанный в более раннем выпуске (до 2010), может предоставлять для этих типов частные определения , которые не всегда согласуются с определениями \<stdint.h>.

Если возникает ошибка C2371, связанная с типом `stdint`, это, скорее всего, означает, что тип определен в заголовке — либо в коде, либо в LIB-файле стороннего разработчика. При обновлении вам следует удалить все пользовательские определения типов \<stdint.h>, предварительно сравнив их со стандартными определениями, чтобы убедиться, что последние не приводят к новым проблемам.

Вы можете нажать клавишу **F12** (**Перейти к определению**), чтобы узнать, где определен соответствующий тип.

При этом может пригодиться параметр компилятора [/showIncludes](../build/reference/showincludes-list-include-files.md). В диалоговом окне **Страницы свойств** проекта откройте страницу **C/C++** > **Дополнительно** и задайте для параметра **Показывать включаемые файлы** значение **Да**. Затем перестройте проект и просмотрите список `#include` в окне вывода. Каждый заголовок отображается с отступом под тем заголовком, который включает его.

## <a name="errors-involving-crt-functions"></a>Ошибки, связанные с функциями CRT

За прошедшие годы в среду выполнения C было внесено множество изменений. Были добавлены многие безопасные версии функций, а некоторые были удалены. Кроме того, как уже упоминалось в этой статье, в Visual Studio 2015 корпорацией Майкрософт была оптимизирована реализация CRT, в результате чего стали использоваться новые двоичные файлы и связанные LIB-файлы.

Если ошибка связана с функцией CRT, обратитесь к разделу [Журнал изменений Visual C++ 2003–2015](visual-cpp-change-history-2003-2015.md) или [Улучшения соответствия C++ в Visual Studio 2017](../cpp-conformance-improvements-2017.md) для поиска дополнительной информации. Если возникла ошибка LNK2019, связанная с неразрешенными внешними элементами, убедитесь, что соответствующая функция не была удалена. Если вы уверены, что функция по-прежнему существует, а вызывающий код является правильным, проверьте, использует ли проект параметр `/NODEFAULTLIB`. Если это так, нужно обновить список библиотек, чтобы проект использовал новые универсальные библиотеки (UCRT). Дополнительные сведения см. в разделе о библиотеках и зависимостях выше.

Если ошибка связана с `printf` или `scanf`, убедитесь, что не применяется частное определение любой из этих функций без включения stdio.h. Если оно имеет место, удалите все частные определения или связь с legacy\_stdio\_definitions.lib. Это можно указать в свойстве **Additional Dependencies**, находящемся в разделе **Свойства конфигурации** > **Компоновщик** > **Входные данные** диалогового окна **Страницы свойств**. Если вы выполняете компоновку с использованием пакета Windows SDK 8.1 или более ранней версии, добавьте legacy\_stdio\_definitions.lib.

Если ошибка связана с аргументами строки форматирования, вероятно, это вызвано тем, что компилятор строже соответствует стандарту. Дополнительные сведения см. в журнале изменений. Отнеситесь к указанным здесь ошибкам с особым вниманием, так как они могут представлять угрозу безопасности.

## <a name="errors-due-to-changes-in-the-c-standard"></a>Ошибки, вызванные изменениями в стандарте C++

Путь развития самого стандарта C++ не всегда подразумевает обратную совместимость. Введение семантики перемещения C++11, новых ключевых слов и других функций языка и стандартных библиотек потенциально может привести к ошибкам компилятора и даже иному поведению во время выполнения.

Например, старая программа C++ может включать заголовок iostream.h. Этот заголовок C++ был признан нерекомендуемым уже довольно давно и был полностью удален из Visual Studio. В этом случае вам потребуется использовать \<iostream> и переписать код. Дополнительные сведения см. в статье [Обновление старого кода iostream](porting-guide-spy-increment.md#updating_iostreams_code).

### <a name="c4838-narrowing-conversion-warning"></a>C4838: предупреждение о сужающих преобразованиях

Теперь стандарт языка C++ указывает, что преобразования целочисленных значений без знака в значения с знаком считаются сужающими преобразованиями. До Visual Studio 2015 компилятор не выдавал подобное предупреждение. Следует проверить каждое вхождение, чтобы убедиться, что подобное сужение не влияет на правильность работы кода.

## <a name="warnings-to-use-secure-crt-functions"></a>Предупреждения об использовании безопасных функций CRT

Постепенно стали появляться безопасные версии функций для среды выполнения C. Хотя старые небезопасные версии по-прежнему доступны, рекомендуется изменить код, чтобы использовать безопасные версии. При наличии небезопасных версий компилятор выдает предупреждение. Вы можете отключить или игнорировать эти предупреждения. Чтобы отключить предупреждения для всех проектов в решении, откройте **Вид** > **Диспетчер свойств**, выберите все проекты, для которых требуется отключить предупреждения, а затем щелкните эти элементы правой кнопкой мыши и выберите **Свойства**. В разделе **Свойства конфигурации** > **C/C++** > **Дополнительно** диалогового окна **Страницы свойств** выберите **Отключить некоторые предупреждения**. Щелкните стрелку раскрывающегося списка и выберите **Изменить**. Введите 4996 в текстовом поле. (Не указывайте префикс "C".) Дополнительные сведения см. в разделе [Перенос для использования Secure CRT](porting-guide-spy-increment.md#porting_to_secure_crt).

## <a name="errors-due-to-changes-in-windows-apis-or-obsolete-sdks"></a>Ошибки, вызванные изменениями в API Windows или устаревших пакетах SDK

Со временем в среду добавлялись новые API Windows и типы данных, а также изменялись или удалялись уже существующие. Кроме того, добавлялись и удалялись другие пакеты SDK, не относящиеся к базовой операционной системе. Таким образом, старые программы могут содержать вызовы несуществующих API. Они также могут содержать вызовы API в других пакетах SDK корпорации Майкрософт, которые больше не поддерживаются. Если возникает ошибка, связанная с API Windows или API из старого пакета SDK корпорации Майкрософт, возможно, что эти API были удалены или заменены на новые, более безопасные функции.

Для получения дополнительных сведений о текущем наборе API и минимально поддерживаемых операционных системах для определенного API Windows откройте [каталог API (Microsoft) и справочных материалов](https://msdn.microsoft.com/library) и перейдите к нужному API.

### <a name="windows-version"></a>Версия Windows

При обновлении программы, прямо или косвенно использующей API Windows, потребуется выбрать минимальную поддерживаемую версию Windows. В большинстве случаев оптимальным выбором является Windows 7. Дополнительные сведения см. в разделе [Проблемы с файлами заголовков](porting-guide-spy-increment.md#header_file_problems). Макрос `WINVER` определяет самую старую версию Windows, в которой ваша программа может выполняться. Если ваша программа MFC задает для WINVER значение 0x0501 (Windows XP), вы получите предупреждение, так как MFC больше не поддерживает выпуск XP, хотя сам компилятор и имеет режим XP.

Дополнительные сведения см. в разделах [Обновление целевой версии Windows](porting-guide-spy-increment.md#updating_winver) и [Более устаревшие файлы заголовков](porting-guide-spy-increment.md#outdated_header_files).

## <a name="atl--mfc"></a>ATL/MFC

ATL и MFC являются относительно стабильными API, однако и в них периодически вносятся изменения. Дополнительные сведения см. в разделе [Журнал изменений Visual C++ 2003–2015](visual-cpp-change-history-2003-2015.md), а также разделах [Новые возможности Visual C++ в Visual Studio 2017](../what-s-new-for-visual-cpp-in-visual-studio.md) и [Улучшения соответствия C++ в Visual Studio 2017](../cpp-conformance-improvements-2017.md).

### <a name="lnk-2005-dllmain12-already-defined-in-msvcrtdlib"></a>LNK 2005 _DllMain@12 уже определен в MSVCRTD.lib

Эта ошибка может возникать в приложениях MFC. Она указывает на проблему очередности между библиотекой CRT и библиотеки MFC. Сначала нужно связывать MFC, чтобы она предоставляла операторы new и delete. Чтобы устранить ошибку, используйте параметр `/NODEFAULTLIB` для пропуска этих библиотек по умолчанию: MSVCRTD.lib и mfcs140d.lib. Затем добавьте эти библиотеки в качестве дополнительных зависимостей.

## <a name="32-vs-64-bit"></a>32-разрядные и 64-разрядные версии

Если исходный код скомпилирован для 32-разрядных систем, вы можете создать 64-разрядную версию приложения вместо 32-разрядной или в дополнение к ней. В общем случае следует сначала скомпилировать программу в 32-разрядном режиме, а затем попробовать 64-разрядный режим. Компиляция в 64-разрядном режиме не вызывает трудностей, однако в некоторых случаях может выявлять ошибки, скрытые в 32-разрядных сборках.

Кроме того, следует помнить о возможных проблемах во время компиляции и выполнения, связанных с размером указателя, значениями времени и размера, а также описателями формата в функциях printf и scanf. Дополнительные сведения см. в разделах [Настройка Visual C++ для 64-разрядных целевых объектов с архитектурой x64](../build/configuring-programs-for-64-bit-visual-cpp.md) и [Общие вопросы использования Visual C++ для 64-разрядных систем](../build/common-visual-cpp-64-bit-migration-issues.md). Дополнительные советы по миграции см. в [руководстве по программированию для 64-разрядных версий Windows](/windows/desktop/WinProg64/programming-guide-for-64-bit-windows).

## <a name="unicode-vs-mbcsascii"></a>Юникод и MBCS/ASCII

До стандартизации Юникода для представления символов, не включенных в набор символов ASCII, многие программы использовали многобайтовую кодировку (MBCS). В старых проектах MFC кодировка MBCS использовалась по умолчанию, поэтому при обновлении такой программы выводятся предупреждения, где рекомендуется использовать Юникод. Вы можете отключить или проигнорировать такое предупреждение, если считаете переход на Юникод нецелесообразным. Чтобы отключить его для всех проектов в решении, откройте **Вид** > **Диспетчер свойств**, выберите все проекты, для которых требуется отключить предупреждения, а затем щелкните эти элементы правой кнопкой мыши и выберите **Свойства**. В диалоговом окне **Страницы свойств** выберите **Свойства конфигурации** > **C/C++** > **Дополнительно**. Откройте раскрывающийся список в свойстве **Отключить некоторые предупреждения** и выберите **Изменить**. Введите 4996 в текстовом поле. (Не указывайте префикс "C".) Нажмите кнопку **ОК** для сохранения свойства, а затем нажмите кнопку **ОК** для сохранения изменений.

Дополнительные сведения см. в разделе [Перенос из MBCS в Юникод](porting-guide-spy-increment.md#porting_to_unicode). Общие сведения о различиях MBCS и Юникода см. в разделах [Текст и строки в Visual C++](../text/text-and-strings-in-visual-cpp.md) и [Интернационализация](../c-runtime-library/internationalization.md).

## <a name="see-also"></a>См. также

[Обновление проектов, созданных в предыдущих версиях Visual C++](upgrading-projects-from-earlier-versions-of-visual-cpp.md)<br/>
[Улучшения соответствия C++ в Visual Studio 2017](../cpp-conformance-improvements-2017.md)