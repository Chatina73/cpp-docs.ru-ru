---
title: Перенос приложений из UNIX в Win32
ms.date: 08/02/2018
helpviewer_keywords:
- APIs [C++], porting to Win32
- Windows API [C++], migrating from UNIX
- migration [C++]
- UNIX [C++], porting to Win32
- porting to Win32 [C++], from UNIX
- porting to Win32 [C++]
- Win32 applications [C++], migrating from UNIX
ms.assetid: 3837e4fe-3f96-4f24-b2a1-7be94718a881
ms.openlocfilehash: 3146c94879532a5c58208369bb6d131a3a027c33
ms.sourcegitcommit: 90817d9d78fbaed8ffacde63f3add334842e596f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58278493"
---
# <a name="porting-from-unix-to-win32"></a>Перенос приложений из UNIX в Win32

При миграции приложений из UNIX в Windows можно использовать несколько вариантов:

- Использование библиотек UNIX для переноса приложений из UNIX в Win32

- Перенос приложений из UNIX в Win32 в машинном коде

- Запуск приложений из UNIX в Windows с помощью подсистемы POSIX

## <a name="unix-libraries"></a>Библиотеки UNIX

Обычно программисты UNIX применяют следующий вариант: компиляция кода UNIX с помощью UNIX-подобных библиотек сторонних производителей как исполняемого файла Win32. Это делают некоторые коммерческие библиотеки (и по крайней мере одна общедоступная). Такой вариант возможен для некоторых приложений. Преимущество этого способа переноса библиотек заключается в том, что они позволяют минимизировать начальные усилия по переносу. Главный недостаток для конкурентоспособного программного продукта — собственный порт Win32 приложения обычно будет работать быстрее и неизбежно будет располагать большими функциональными возможностями. Для приложения может оказаться неудобным вариант выхода за пределы своей оболочки UNIX, если ему необходимо отправлять вызовы Win32 для получения дополнительных вычислительных ресурсов из Windows.

В следующем списке указаны ресурсы корпорации Майкрософт и сторонних производителей по переносу и поддержке миграции из UNIX в Visual C++:

### <a name="unix-migration-guides"></a>Руководства по миграции из UNIX

[Руководство по переносу настраиваемых приложений UNIX](https://technet.microsoft.com/library/bb656290.aspx) содержит технические рекомендации по переносу кода из UNIX в среду Win32.

[Руководство по проекту переноса из Unix](https://technet.microsoft.com/library/bb656287.aspx) дополняет руководство по переносу настраиваемых приложений UNIX и содержит высокоуровневые справочные сведения о переносе важных проектов из UNIX в Win32. Руководство содержит рекомендации, которые следует учитывать на каждом этапе миграции проекта.

### <a name="interopsystemscom"></a>InteropSystems.com

[http://www.interopsystems.com/](http://www.interopsystems.com/)

Сайт стороннего разработчика для компании, предоставляющей программные решения для переноса приложений из UNIX в Win32.

### <a name="c-boost-web-site"></a>Веб-сайт C++ Boost

[http://boost.sourceforge.net/regression-logs/](http://boost.sourceforge.net/regression-logs/)

[http://boost.sourceforge.net/boost-build2/](http://boost.sourceforge.net/boost-build2/)

## <a name="porting-unix-applications-directly-to-win32"></a>Перенос приложений UNIX прямо в Win32

Другим вариантом является перенос приложений из UNIX прямо в Win32. Благодаря применению библиотек ANSI C/C++ и коммерческих библиотек компилятора C многие стандартные системные вызовы, используемые в приложениях UNIX, доступны в приложениях Win32.

Модель вывода приложений на основе **stdio** изменять не нужно, так как API-интерфейсы консоли Win32 имитируют модель **stdio**, при этом существуют версии *curses*, в которых применяются API-интерфейсы консоли Win32. Дополнительные сведения см. в разделе [SetConsoleCursorPosition](/windows/console/setconsolecursorposition).

Для работы в качестве приложений Win32 в приложения на основе сокетов Беркли необходимо внести лишь незначительные изменения. Интерфейс сокетов Windows предназначен для обеспечения переносимости с помощью сокетов BSD. В него нужно внести минимальные изменения, которые указаны во вводных разделах спецификации WinSock.

Windows поддерживает DCE-совместимый протокол RPC, поэтому можно легко использовать приложения на основе RPC. См. раздел [Функции RPC](/windows/desktop/Rpc/rpc-functions).

Одно из самых значимых отличий заключается в модели процессов. UNIX имеет `fork`, а Win32 — нет. В зависимости от способа применения `fork` и кодовой базы, Win32 имеет два API-интерфейса, которые можно использовать: `CreateProcess` и `CreateThread`. Приложение UNIX, которое разветвляется на несколько копий самого себя, можно переработать в Win32 так, чтобы оно имело несколько процессов или одиночный процесс с несколькими потоками. Если используются несколько процессов, можно использовать различные методы IPC для взаимодействия между процессами (и, возможно, для обновления кода и данных нового процесса, чтобы они совпадали с родительским объектом, если требуются функциональные возможности, которые предоставляет `fork`). Дополнительные сведения о IPC см в разделе [Межпроцессное взаимодействие](/windows/desktop/ipc/interprocess-communications).

Графические модели Windows и UNIX очень сильно отличаются друг от друга. В UNIX используется пользовательский интерфейс системы X Window, а в Windows — GDI. Хотя они концептуально похожи друг на друга, простое соответствие между X API и GDI API отсутствует. Но OpenGL поддерживает миграцию приложений на основе UNIX OpenGL. А для Windows имеются X-клиенты и X-серверы. Дополнительные сведения о GDI см. в разделе [Контексты устройств](/windows/desktop/gdi/device-contexts).

Базовые приложения UNIX, включая большинство приложений CGI, должны легко переноситься в среду Visual C++, работающую под управлением Windows. Такие функции, как `open`, `fopen`, `read`, `write` и другие, доступны в библиотеке среды выполнения Visual C++. Кроме того, существует сопоставление один к одному между API C UNIX и API Win32: `open` и `CreateFile`, `read` и `ReadFile`, `write` и `WriteFile`, `ioctl` и `DeviceIOControl`, `close` и `CloseFile` и т. д.

## <a name="windows-posix-subsystem"></a>Подсистема Windows POSIX

Программисты UNIX могут использовать еще один вариант — подсистему Windows POSIX. Но она поддерживает только POSIX 1003.1, которая была единственной стандартизованной версией POSIX на момент создания Windows NT. С тех пор расширение этой подсистемы практически не требовалось, так как большинство приложений были преобразованы в Win32. Для полнофункциональных приложений система 1003.1 используется крайне редко, так как она ограничена по своим возможностям (например, в ней отсутствуют возможности 1003.2, сетевая поддержка и т. д). Полнофункциональные приложения, выполняемые под управлением подсистемы Windows POSIX, не имеют доступа к функциям Windows, предназначенным для приложений Win32, таким как отображенные в память файлы, сетевые подключения и графика. Основными целевыми объектами для подсистемы Windows POSIX являются такие приложения, как VI, LS и GREP.

## <a name="see-also"></a>См. также

[Руководство по переносу и обновлению Visual C++](visual-cpp-change-history-2003-2015.md)<br/>
[UNIX](../c-runtime-library/unix.md)<br/>
[Правила вывода](../build/reference/inference-rules.md)
