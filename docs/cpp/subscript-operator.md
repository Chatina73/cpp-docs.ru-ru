---
title: Подстрочный оператор]
ms.date: 11/04/2016
f1_keywords:
- '[]'
helpviewer_keywords:
- operators [C++], subscript
- postfix operators [C++]
- '[] operator'
- subscript operator [C++], syntax
ms.assetid: 69c31494-52da-4dd0-8bbe-6ccbfd50f197
ms.openlocfilehash: 2d55c18d2c9faa1a704bea129f2551937e76133c
ms.sourcegitcommit: 5cecccba0a96c1b4ccea1f7a1cfd91f259cc5bde
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/01/2019
ms.locfileid: "58767929"
---
# <a name="subscript-operator-"></a>Подстрочный оператор]

## <a name="syntax"></a>Синтаксис

```
postfix-expression [ expression ]
```

## <a name="remarks"></a>Примечания

Постфиксное выражение (который также может быть основным выражением) следуют оператор индекса, **[]**, задает индексирование массива.

Сведения об управляемых массивов в C + +/ CLI, см. в разделе [массивы](../extensions/arrays-cpp-component-extensions.md).

Как правило, значение, представленное *Постфиксное выражение* значение указателя, например идентификатор массива, и *выражение* является целочисленным значением (включая перечисляемые типы). Однако все, что необходимо синтаксически, — это чтобы одно из выражений имело тип указателя, а другие — целочисленный тип. Таким образом, целочисленное значение может находиться в *Постфиксное выражение* позиции, а значение указателя может находиться в квадратных скобках в *выражение* или позиции индекса. Рассмотрим следующий фрагмент кода:

```cpp
int nArray[5] = { 0, 1, 2, 3, 4 };
cout << nArray[2] << endl;            // prints "2"
cout << 2[nArray] << endl;            // prints "2"
```

В предыдущем примере выражение `nArray[2]` совпадает с `2[nArray]`. Причиной является то, что результат выражения индекса `e1[e2]` определяется формулой:

`*((e2) + (e1))`

Адрес, предоставленный этим выражением не *e2* байт из адреса *e1*. Вместо этого адрес масштабируется так, чтобы выдавать следующий объект в массиве *e2*. Пример:

```cpp
double aDbl[2];
```

Адреса `aDb[0]` и `aDb[1]` различаются 8 байтами — размером объекта типа **двойные**. Это масштабирование в соответствии с типом объекта выполняется автоматически в языке C++ и определяется в [Аддитивные операторы](../cpp/additive-operators-plus-and.md) которых рассматриваются сложение и вычитание операндов типа указателя.

Индексное выражение также может иметь несколько индексов, как показано ниже:

*expression1* **[** *expression2* **] [** *expression3* **]** ...

Индексные выражения связываются в направлении слева направо. Сначала вычисляется левое индексное выражение, *expression1* **[** *expression2* **]**. Адрес, получающийся в результате сложения *expression1* и *expression2*, формирует выражение указателя. Затем к этому выражению указателя добавляется выражение *expression3*, чтобы образовать новое выражение указателя. Эти операции повторяются до тех пор, пока не будет добавлено последнее индексное выражение. Оператор косвенного обращения (<strong>\*</strong>) применяется после вычисления последнего индексного выражения выполняется, если последний значение указателя указывает на тип массива.

Выражения с несколькими индексами ссылаются на элементы многомерных массивов. Многомерный массив — это массив, элементы которого сами являются массивами. Например, первый элемент трехмерного массива является двумерным массивом. В следующем примере объявляется и инициализируется простой двухмерный массив символов.

```cpp
// expre_Subscript_Operator.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
#define MAX_ROWS 2
#define MAX_COLS 2

int main() {
  char c[ MAX_ROWS ][ MAX_COLS ] = { { 'a', 'b' }, { 'c', 'd' } };
  for ( int i = 0; i < MAX_ROWS; i++ )
     for ( int j = 0; j < MAX_COLS; j++ )
        cout << c[ i ][ j ] << endl;
}
```

## <a name="positive-and-negative-subscripts"></a>Положительные и отрицательные индексы

Первым элементом массива является элемент с номером 0. Диапазон для массива C++ составляет от *массива*[0] для *массива*[*размер* - 1]. Однако C++ поддерживает положительные и отрицательные индексы. Отрицательные индексы не должны выходить за границы массива; в противном случае результаты непредсказуемы. В следующем примере кода показаны положительные и отрицательные индексы массива:

```cpp
#include <iostream>
using namespace std;

int main() {
    int intArray[1024];
    for (int i = 0, j = 0; i < 1024; i++)
    {
        intArray[i] = j++;
    }

    cout << intArray[512] << endl;   // 512

    cout << 257[intArray] << endl;   // 257

    int *midArray = &intArray[512];  // pointer to the middle of the array

    cout << midArray[-256] << endl;  // 256

    cout << intArray[-256] << endl;  // unpredictable, may crash
}
```

Отрицательный индекс в последней строке может вызывать ошибку времени выполнения, так как он указывает на адрес 256 **int** позиций нижней в памяти, чем начало массива. Указатель `midArray` инициализируется в середину `intArray`; это возможно (но опасного) таким образом использовать оба положительные и отрицательные индексы массива на нем. Ошибки индексов массивов не создают ошибки времени компиляции, но дают непредсказуемые результаты.

Оператор индекса коммутативен. Поэтому выражения *массива*[*индекс*] и *индекс*[*массива*] гарантированно эквивалентное условии, что индекс оператор не перегружен (см. в разделе [перегруженные операторы](../cpp/operator-overloading.md)). Программисты чаще всего используют первую форму, но вторая форма также правильна.

## <a name="see-also"></a>См. также

[Постфиксные выражения](../cpp/postfix-expressions.md)<br/>
[Встроенные операторы C++, приоритет и ассоциативность](../cpp/cpp-built-in-operators-precedence-and-associativity.md)<br/>
[Массивы](../cpp/arrays-cpp.md)<br/>
[Одномерные массивы](../c-language/one-dimensional-arrays.md)<br/>
[Многомерные массивы](../c-language/multidimensional-arrays-c.md)<br/>
