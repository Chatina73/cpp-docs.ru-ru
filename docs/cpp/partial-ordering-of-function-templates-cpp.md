---
title: Частичное упорядочение шаблонов функций (C++)
ms.date: 07/30/2019
helpviewer_keywords:
- partial ordering of function templates
ms.assetid: 0c17347d-0e80-47ad-b5ac-046462d9dc73
ms.openlocfilehash: 0c4f11b4b3e02504c4786ea34441362b542959d6
ms.sourcegitcommit: 725e86dabe2901175ecc63261c3bf05802dddff4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/31/2019
ms.locfileid: "68682429"
---
# <a name="partial-ordering-of-function-templates-c"></a>Частичное упорядочение шаблонов функций (C++)

Может быть доступно несколько шаблонов функций, соответствующих списку аргументов в вызове функции. В C++ определено частичное упорядочение шаблонов функции, что позволяет указать, какую функцию необходимо вызвать. Упорядочение выполняется частично, поскольку может быть несколько шаблонов, которые считаются в равной мере специализированными.

Компилятор выбирает функцию наиболее специализированного шаблона среди всех возможных совпадений. Например, если шаблон функции принимает тип `T` и существует другой шаблон функции, который принимает `T*` доступ, то `T*` версия считается более специализированной. Он предпочтительнее для универсальной `T` версии, когда аргумент является типом указателя, хотя оба могут быть допустимыми.

Чтобы определить, является ли один кандидатов — шаблонов функций — более специализированным, используйте следующую процедуру:

1. Рассмотрим два шаблона функции, T1 и T2.

1. Замените параметры в шаблоне T1 на гипотетический уникальный тип X.

1. Пользуясь списком параметров из шаблона T1, проверьте, является ли T2 допустимым шаблоном для этого списка параметров. Любые неявные преобразования пропускайте.

1. Повторите ту же самую процедуру, поменяв шаблоны T1 и T2 местами.

1. Если один шаблон является допустимым списком аргументов шаблона для другого шаблона, но наоборот не имеет значения, этот шаблон считается менее специализированным, чем другой шаблон. Если с помощью предыдущего шага оба шаблона формируют допустимые аргументы для друг друга, они считаются одинаково специализированными, и при попытке их использования происходит неоднозначный вызов.

1. При проведении процедуры руководствуйтесь следующими правилами:

   1. Шаблон для определенного типа является более специализированным, чем шаблон, принимающий аргумент универсального типа.

   1. `T*` Шаблон только `X` более специализирован `T`, чем один, поскольку гипотетический тип `X*` является допустимым аргументом для `T` аргумента шаблона, но не является допустимым аргументом для элемента `T*`аргумент шаблона.

   1. `const T`является более специализированным `T`, чем `const X` , поскольку является допустимым аргументом для `T` аргумента `X` шаблона, `const T` но не является допустимым аргументом для аргумента шаблона.

   1. `const T*`является более специализированным `T*`, чем `const X*` , поскольку является допустимым аргументом для `T*` аргумента `X*` шаблона, `const T*` но не является допустимым аргументом для аргумента шаблона.

## <a name="example"></a>Пример

Следующий пример работает, как указано в стандарте:

```cpp
// partial_ordering_of_function_templates.cpp
// compile with: /EHsc
#include <iostream>

template <class T> void f(T) {
   printf_s("Less specialized function called\n");
}

template <class T> void f(T*) {
   printf_s("More specialized function called\n");
}

template <class T> void f(const T*) {
   printf_s("Even more specialized function for const T*\n");
}

int main() {
   int i =0;
   const int j = 0;
   int *pi = &i;
   const int *cpi = &j;

   f(i);   // Calls less specialized function.
   f(pi);  // Calls more specialized function.
   f(cpi); // Calls even more specialized function.
   // Without partial ordering, these calls would be ambiguous.
}
```

### <a name="output"></a>Вывод

```Output
Less specialized function called
More specialized function called
Even more specialized function for const T*
```

## <a name="see-also"></a>См. также

[Шаблоны функций](../cpp/function-templates.md)
