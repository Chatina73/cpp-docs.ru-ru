---
title: Обработка ошибок и исключений (современный C++)
ms.date: 09/17/2018
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: d6192ab800667ceb35bf2e18dcbdc0be95ec70f5
ms.sourcegitcommit: afd6fac7c519dbc47a4befaece14a919d4e0a8a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2018
ms.locfileid: "51523292"
---
# <a name="errors-and-exception-handling-modern-c"></a>Обработка ошибок и исключений (современный C++)

В современном C++, в большинстве случаев предпочтительный способ уведомления и обработки логических ошибок и ошибок среды выполнения — использование исключений. Это особенно важно в тех случаях, когда стек может содержать несколько вызовов функции между функцией, которая обнаруживает ошибку и функцией, которая содержит контекст о том, как обрабатывать его. Исключения предоставляют формальный, четко определенный способ для кода, который обнаруживает ошибки для передачи информации вверх по стеку вызовов.

Ошибки программы обычно делятся на две категории: логические ошибки, вызванные ошибками программирования к примеру, ошибка «индекс вне допустимого диапазона» и ошибки времени выполнения, которые не может контролировать программист, например, «сетевая служба недоступна» Ошибка. Управляется в стиле программирования C и в модели COM отчеты об ошибках, возвращая значение, представляющее код ошибки или код статуса для определенной функции, либо задав глобальной переменной, которая вызывающий объект может дополнительно извлекаться после каждого вызова функции, см. в разделе ли ошибки. К примеру программирование COM использует возвращаемое значение HRESULT для сообщения об ошибках вызывающему объекту, и в API Win32 есть функция GetLastError для извлечения последней ошибки, сообщил стек вызовов. В обоих случаях именно вызывающему объекту признать ли код и ответить на него соответственно. Если вызывающий объект не явным образом обрабатывает код ошибки, программа может сбой без предупреждения или продолжить выполнение с некорректными данными и привести к неверному результату.

Исключения являются предпочтительными в современном C++ по следующим причинам:

- Исключение вынуждает вызывающий код признать состояние ошибки и обработать его. Необработанные исключения останавливают выполнение программы.

- Исключение перескакивает в точку в стеке вызовов, который может обработать ошибку. Промежуточные функции могут разрешить распространение исключения. У них нет в соответствии с другими уровнями.

- Механизм освобождения стека исключения уничтожает все объекты в области в соответствии с правилами чётким после возникает исключение.

- Исключение обеспечивает четкое разделение между кодом, который обнаруживает ошибку и код, который обрабатывает ошибку.

Следующий упрощенный пример показывает синтаксис, необходимые для создания и перехвата исключений в C++.

```cpp

#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

Исключения в C++ аналогичны в таких языках, таких как C# и Java. В **попробуйте** заблокировать, если исключение *исключение* будет *перехвачено* связанным первым **catch** блок, тип которого соответствует исключение. Другими словами, выполнение переходит из **throw** инструкцию, чтобы **catch** инструкции. Если блок catch можно использовать не найден, `std::terminate` вызывается и программа завершает работу. В C++ может быть вызвано любой тип; Тем не менее, мы рекомендуем создать тип, производный прямо или косвенно от `std::exception`. В предыдущем примере, тип исключения, [invalid_argument](../standard-library/invalid-argument-class.md), определенные в стандартной библиотеке в [ \<stdexcept >](../standard-library/stdexcept.md) файл заголовка. C++ не предоставляет и не требуется, **наконец** блок, чтобы убедиться в том, что все ресурсы будут освобождены, если возникает исключение. Получение ресурса является идиомой инициализации (RAII), который использует интеллектуальные указатели, предоставляет необходимую функциональность для очистки ресурсов. Дополнительные сведения см. в разделе [как: разработка с учетом безопасности исключений](../cpp/how-to-design-for-exception-safety.md). Сведения о механизме развертывания стека C++ см. в разделе [исключения и очистки стека](../cpp/exceptions-and-stack-unwinding-in-cpp.md).

## <a name="basic-guidelines"></a>Основные рекомендации

Надежная обработка ошибок сложна на любом языке программирования. Несмотря на то, что исключения предоставляют несколько функций, которые поддерживают корректную обработку ошибок, они не могут делать всю работу автоматически. Чтобы реализовать преимущества механизма исключения, помните исключения при разработке кода.

- Использование утверждений для проверки ошибок, которые не должны происходить. Используйте исключения для проверки ошибок, которые могут возникнуть, например, ошибки при проверке ввода параметров открытых функций. Дополнительные сведения см. в разделе **vs исключения. Утверждения**.

- Используйте исключения, если код, который обрабатывает ошибки может быть отделен от кода, который обнаруживает ошибку, не вызовы функций. Рассмотрите возможность использования коды ошибок вместо этого в циклах, важных для производительности, когда обрабатывающий ошибку код тесно связан код, который определяет его.

- Для каждой функции, которая может создавать и распространять исключение, предоставляют один из трех гарантий исключения: строгую гарантию, базовую гарантию или гарантию nothrow (noexcept). Дополнительные сведения см. в разделе [как: разработка с учетом безопасности исключений](../cpp/how-to-design-for-exception-safety.md).

- Создает исключения по значению, перехватывает их по ссылке. Не перехватывайте исключения, которые невозможно обработать.

- Не используйте спецификации исключений, которые являются нерекомендуемыми в C ++ 11. Дополнительные сведения см. в разделе **спецификации исключений и noexcept**.

- Используйте стандартные библиотеки типов исключений, если они применяются. Наследование пользовательских типов исключений из [класс exception](../standard-library/exception-class.md) иерархии.

- Не разрешайте исключениям уклоняться от обработки деструкторами или функциями освобождения памяти.

## <a name="exceptions-and-performance"></a>Исключения и производительность

Механизм исключения имеет очень минимальное снижение производительности, если исключение не создается. Если создается исключение, стоимость обхода стека и очистки мало сравнимы с затраты на вызов функции. Дополнительные структуры данных необходимые для отслеживания стека вызова после **попробуйте** введен блок и необходимы дополнительные инструкции для раскручивания стека в том случае, если создается исключение. Однако в большинстве случаев затраты на производительность и объем памяти не имеет значения. Скорее всего, будет значительным только при очень ограниченных в памяти системах неблагоприятное влияние на производительность исключений, или в важных для производительности циклы где ошибка вероятнее всего выполняются регулярно, и код для обработки, он тесно связан с код, который сообщает об этом. В любом случае невозможно знать фактические затраты исключений без профилирование и измерения. Даже в тех редких случаях, когда затраты существенны, вы уравновешиваются повышением корректности, упрощением сопровождения и другие преимущества, предоставляемые обеспечиваемыми продуманной политикой исключений.

## <a name="exceptions-vs-assertions"></a>Исключения и проверочные утверждения

Исключения и проверочные утверждения, два разных механизма для обнаружения ошибок времени выполнения в программе. Использование утверждений для проверки условий во время разработки, никогда не должно быть значение true, если ваш код является правильным. Нет смысла в обработке такой ошибки с помощью исключения, так как эта ошибка означает, что что-то в коде должно быть зафиксировано и не представляют собой условие, которое программе следует выйти из во время выполнения. Утверждение останавливает выполнение на операторе, таким образом, чтобы можно было проверить состояние программы в отладчике; исключение продолжает выполнение из первого соответствующий обработчика catch. Используйте исключения для проверки условия ошибок, которые могут возникнуть во время выполнения, даже если код является правильным, например, «файл не найден» или «нехватка памяти». Может потребоваться выйти из этих условий, даже в том случае, если восстановление только выводит сообщение в журнал и завершает выполнение программы. Всегда проверяйте аргументы открытых функций с помощью исключения. Даже если функции без ошибок, полный контроль над аргументами, которые пользователь может передать не возможно.

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>Исключения C++ и исключениями Windows SEH

Программы на языках C и C++ могут использовать механизм структурированной обработки исключений (SEH) в операционной системе Windows. Основные понятия в SEH напоминают эти исключения в C++, за исключением того, что SEH использует **__try**, **__except**, и **__finally** вместо конструкции **повторите** и **catch**. В Visual C++ исключения C++ реализованы для SEH. Тем не менее при написании кода C++, используйте синтаксис исключения C++.

Дополнительные сведения о SEH см. в разделе [структурированная обработка исключений (C/C++)](../cpp/structured-exception-handling-c-cpp.md).

## <a name="exception-specifications-and-noexcept"></a>Спецификации исключений и noexcept

Спецификации исключений были введены в C++ как способ определения исключений, которые может создавать функция. Однако спецификации исключений оказался проблематичными на практике и являются устаревшими в стандарте C ++ 11 черновик. Мы рекомендуем не использовать спецификации исключений, за исключением `throw()`, что означает, что функция не позволяет исключений для выхода. Если необходимо использовать спецификации исключений типа `throw(` *тип*`)`, имейте в виду, что Visual C++ стандарту определенными способами. Дополнительные сведения см. в разделе [спецификации исключений (throw)](../cpp/exception-specifications-throw-cpp.md). `noexcept` Описатель представлена в C ++ 11 как основная альтернатива `throw()`.

## <a name="see-also"></a>См. также

[Практическое руководство. Интерфейс между кодом с исключениями и без исключений](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[Возвращение к C++](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)