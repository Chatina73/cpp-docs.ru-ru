---
title: Современные рекомендации по C++ для исключений и обработки ошибок
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: 6995867813bfb65848f179cb56b358de68fa63f2
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227534"
---
# <a name="modern-c-best-practices-for-exceptions-and-error-handling"></a>Современные рекомендации по C++ для исключений и обработки ошибок

В современных C++ в большинстве случаев предпочтительным способом сообщить и обрабатывались как логические ошибки, так и ошибки времени выполнения — использовать исключения. Это особенно важно, если в стеке может содержаться несколько вызовов функций между функцией, которая обнаруживает ошибку, и функцией, которая имеет контекст, чтобы получить сведения об их обработке. Исключения предоставляют формальный, четко определенный способ для кода, который обнаруживает ошибки для передачи информации вверх по стеку вызовов.

Ошибки программы обычно делятся на две категории: логические ошибки, вызванные ошибками программирования, например, ошибкой «индекс вне диапазона», а также ошибки времени выполнения, которые выходят за пределы элемента управления программиста, например ошибки «сетевая служба недоступна». В программировании в стиле C и в COM Управление отчетами об ошибках осуществляется либо путем возвращения значения, представляющего код ошибки, либо кода состояния для конкретной функции, либо путем установки глобальной переменной, которую вызывающий может дополнительно получить после каждого вызова функции, чтобы проверить, были ли обнаружены ошибки. Например, при программировании COM используется возвращаемое значение HRESULT для передачи ошибок вызывающему объекту, а API Win32 содержит функцию GetLastError для получения последней ошибки, о которой сообщил стек вызовов. В обоих случаях для распознавания кода и реагирования на него требуется вызывающая сторона. Если вызывающий объект не обрабатывает код ошибки явным образом, программа может аварийно завершить работу без предупреждения или продолжить выполнение с неверными данными и получить неверные результаты.

Исключения являются предпочтительными в современных C++ по следующим причинам:

- Исключение приводит к тому, что вызывающий код распознает состояние ошибки и обрабатывает его. Необработанные исключения останавливают выполнение программы.

- Исключение переходит к точке в стеке вызовов, которая может справиться с ошибкой. Промежуточные функции могут позволить распространить исключение. Они не должны координироваться с другими уровнями.

- Механизм обратной записи исключений уничтожает все объекты в области в соответствии с четко определенными правилами после возникновения исключения.

- Исключение позволяет четко отделить код, который определяет ошибку, и код, обрабатывающий ошибку.

В следующем упрощенном примере показан синтаксис, необходимый для генерации и перехвата исключений в C++.

```cpp

#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

Исключения в C++ похожи на такие языки, как C# и Java. В **`try`** блоке при *возникновении* исключения оно будет *перехвачено* первым связанным **`catch`** блоком, тип которого совпадает с типом исключения. Иными словами, выполнение переходит от **`throw`** оператора к **`catch`** оператору. Если подходящий блок catch не найден, `std::terminate` вызывается метод и программа завершает работу. В C++ может быть вызван любой тип; Однако рекомендуется создавать тип, прямо или косвенно производный от `std::exception` . В предыдущем примере тип исключения, [invalid_argument](../standard-library/invalid-argument-class.md), определен в стандартной библиотеке в [\<stdexcept>](../standard-library/stdexcept.md) файле заголовка. C++ не предоставляет и не требует блока **finally** , чтобы гарантировать освобождение всех ресурсов при возникновении исключения. Идиома получения ресурсов — инициализация (RAII), которая использует интеллектуальные указатели, предоставляет необходимые функции для очистки ресурсов. Дополнительные сведения см. [в разделе руководство. проектирование безопасности исключений](how-to-design-for-exception-safety.md). Дополнительные сведения о механизме развертывания стека C++ см. в разделе [исключения и очистка стека](exceptions-and-stack-unwinding-in-cpp.md).

## <a name="basic-guidelines"></a>Основные рекомендации

Надежная обработка ошибок является сложной задачей в любом языке программирования. Хотя исключения предоставляют несколько функций, которые поддерживают хорошую обработку ошибок, они не могут выполнить всю работу. Чтобы реализовать преимущества механизма исключения, помните об исключениях при проектировании кода.

- Используйте утверждения, чтобы проверить наличие ошибок, которые не должны возникать. Используйте исключения для проверки ошибок, которые могут возникать, например, ошибок при проверке входных данных для параметров открытых функций. Дополнительные сведения см. в разделе **исключения и утверждения**.

- Используйте исключения, если код, обрабатывающий ошибку, может быть отделен от кода, который обнаруживает ошибку одним или несколькими промежуточными вызовами функций. Рассмотрите возможность использования кодов ошибок в циклах, критических для производительности, когда код, обрабатывающий ошибку, тесно связан с кодом, который его обнаруживает.

- Для каждой функции, которая может выдавать или распространять исключение, следует предоставить одно из трех гарантий исключений: строгая гарантия, Базовая гарантия или "Throw" (Except). Дополнительные сведения см. [в разделе руководство. проектирование безопасности исключений](how-to-design-for-exception-safety.md).

- Вызывайте исключения по значению, перехватите их по ссылке. Не перехватывайте объекты, которые не могут быть обработаны.

- Не используйте спецификации исключений, которые являются устаревшими в C++ 11. Дополнительные сведения см. в разделе **спецификации исключений и Кроме**.

- Используйте типы исключений стандартной библиотеки при их применении. Наследовать пользовательские типы исключений от иерархии [классов исключений](../standard-library/exception-class.md) .

- Не разрешать исключения для экранирования из деструкторов или функций освобождения памяти.

## <a name="exceptions-and-performance"></a>Исключения и производительность

Механизм исключения имеет очень минимальные затраты на производительность, если исключение не создается. При возникновении исключения стоимость прохода стека и его очистки приблизительно сравнима с затратами на вызов функции. Дополнительные структуры данных необходимы для контроля стека вызовов после того **`try`** , как был выполнен блок, и при возникновении исключения требуются дополнительные инструкции для очистки стека. Однако в большинстве случаев затраты на производительность и объем памяти не являются существенными. Негативное воздействие исключений на производительность может быть значительным только в системах с ограниченным объемом памяти или в циклах, критических с точки зрения производительности, в которых возникает ошибка регулярно, и код для его обработки тесно связан с кодом, который его сообщает. В любом случае невозможно понять фактическую стоимость исключений без профилирования и измерения. Даже в редких случаях, когда стоимость существенна, можно взвесить ее на более высокую правильность, упростить обслуживание и другие преимущества, предоставляемые хорошо спроектированной политикой исключений.

## <a name="exceptions-vs-assertions"></a>Исключения и утверждения

Исключения и утверждения — это два отдельных механизма для обнаружения ошибок во время выполнения в программе. Используйте утверждения для проверки условий во время разработки, которые никогда не должны быть истинными, если весь код правильный. Нет смысла в обработке такой ошибки с помощью исключения, поскольку ошибка указывает на то, что что-то в коде должно быть исправлено, и не представляет условие, которое программа может восстанавливать из среды выполнения. Утверждение останавливает выполнение на инструкции, чтобы можно было проверить состояние программы в отладчике. исключение продолжит выполнение из первого соответствующего обработчика catch. Используйте исключения для проверки ошибок, которые могут возникнуть во время выполнения, даже если код правильный, например "файл не найден" или "недостаточно памяти". Может потребоваться выполнить восстановление из этих условий, даже если при восстановлении только сообщение выводится в журнал и завершает программу. Всегда проверяйте аргументы для открытых функций с помощью исключений. Даже если функция бесплатна, вы можете не иметь полного контроля над аргументами, которые пользователь может передать ему.

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>Исключения C++ и исключения SEH Windows

Программы C и C++ могут использовать механизм структурированной обработки исключений (SEH) в операционной системе Windows. Понятия SEH похожи на исключения C++, за исключением того, что SEH использует **__try**, **`__except`** и конструкции, а **`__finally`** не **`try`** и **`catch`** . В компиляторе Microsoft C++ (КОМПИЛЯТОРОМ MSVC) исключения C++ реализуются для SEH. Однако при написании кода C++ используйте синтаксис исключения C++.

Дополнительные сведения о SEH см. в разделе [структурированная обработка исключений (C/C++)](structured-exception-handling-c-cpp.md).

## <a name="exception-specifications-and-noexcept"></a>Спецификации исключений и, Кроме

Спецификации исключений были введены в C++ как способ указания исключений, которые может вызывать функция. Однако спецификации исключений выдают проблемы на практике и являются устаревшими в стандарте "черновик C++ 11". Не рекомендуется использовать спецификации исключений, за исключением `throw()` , что указывает, что функция не допускает исключений для экранирования. Если необходимо использовать спецификации исключений `throw(` *типа*Type `)` , имейте в виду, что компилятором MSVC отчасти от стандарта определенным образом. Дополнительные сведения см. в разделе [спецификации исключений (throw)](exception-specifications-throw-cpp.md). **`noexcept`** Описатель вводится в c++ 11 в качестве предпочтительного варианта `throw()` .

## <a name="see-also"></a>См. также статью

[Как взаимодействовать с исключительным и неисключительным кодом](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
