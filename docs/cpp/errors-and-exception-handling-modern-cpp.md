---
title: Современные C++ рекомендации по исключениям и обработке ошибок
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: 85a8bf0f64681387cbee63f273fda5ce93ab7ad5
ms.sourcegitcommit: 654aecaeb5d3e3fe6bc926bafd6d5ace0d20a80e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74245864"
---
# <a name="modern-c-best-practices-for-exceptions-and-error-handling"></a>Современные C++ рекомендации по исключениям и обработке ошибок

В современном C++, в большинстве случаев предпочтительным способом сообщить и обменять логические ошибки и ошибки во время выполнения является использование исключений. Это особенно важно, если в стеке может содержаться несколько вызовов функций между функцией, которая обнаруживает ошибку, и функцией, которая имеет контекст, чтобы получить сведения об их обработке. Исключения предоставляют формальный, четко определенный способ для кода, который обнаруживает ошибки для передачи информации вверх по стеку вызовов.

Ошибки программы обычно делятся на две категории: логические ошибки, вызванные ошибками программирования, например, ошибкой «индекс вне диапазона», а также ошибки времени выполнения, которые выходят за пределы элемента управления программиста, например «сетевая служба недоступна». план. В программировании в стиле C и в COM Управление отчетами об ошибках осуществляется либо путем возвращения значения, представляющего код ошибки, либо кода состояния для конкретной функции, либо путем установки глобальной переменной, которую вызывающий может дополнительно получить после каждого вызова функции, чтобы просмотреть Указывает, были ли сообщения об ошибках. Например, при программировании COM используется возвращаемое значение HRESULT для передачи ошибок вызывающему объекту, а API Win32 содержит функцию GetLastError для получения последней ошибки, о которой сообщил стек вызовов. В обоих случаях для распознавания кода и реагирования на него требуется вызывающая сторона. Если вызывающий объект не обрабатывает код ошибки явным образом, программа может аварийно завершить работу без предупреждения или продолжить выполнение с неверными данными и получить неверные результаты.

Исключения являются предпочтительными в C++ современном по следующим причинам:

- Исключение приводит к тому, что вызывающий код распознает состояние ошибки и обрабатывает его. Необработанные исключения останавливают выполнение программы.

- Исключение переходит к точке в стеке вызовов, которая может справиться с ошибкой. Промежуточные функции могут позволить распространить исключение. Они не должны координироваться с другими уровнями.

- Механизм обратной записи исключений уничтожает все объекты в области в соответствии с четко определенными правилами после возникновения исключения.

- Исключение позволяет четко отделить код, который определяет ошибку, и код, обрабатывающий ошибку.

В следующем упрощенном примере показан синтаксис, необходимый для генерации и перехвата C++исключений в.

```cpp

#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

Исключения C++ похожи на такие языки, как C# и Java. В блоке **try** *при возникновении исключения оно будет* *перехвачено* первым связанным блоком **catch** , тип которого совпадает с типом исключения. Иными словами, выполнение переходит от оператора **throw** к оператору **catch** . Если ни один из возможных блоков catch не найден, вызывается `std::terminate` и программа завершает работу. В C++может быть вызван любой тип; Однако рекомендуется создавать тип, прямо или косвенно производный от `std::exception`. В предыдущем примере тип исключения, [invalid_argument](../standard-library/invalid-argument-class.md), определен в стандартной библиотеке в файле [\<stdexcept >](../standard-library/stdexcept.md) заголовка. C++не предоставляет и не требует блока **finally** , чтобы гарантировать освобождение всех ресурсов при возникновении исключения. Идиома получения ресурсов — инициализация (RAII), которая использует интеллектуальные указатели, предоставляет необходимые функции для очистки ресурсов. Дополнительные сведения см. [в разделе руководство. проектирование безопасности исключений](how-to-design-for-exception-safety.md). Дополнительные сведения о механизме деповорота стека см. в C++ разделе [исключения и очистка стека](exceptions-and-stack-unwinding-in-cpp.md).

## <a name="basic-guidelines"></a>Основные рекомендации

Надежная обработка ошибок является сложной задачей в любом языке программирования. Хотя исключения предоставляют несколько функций, которые поддерживают хорошую обработку ошибок, они не могут выполнить всю работу. Чтобы реализовать преимущества механизма исключения, помните об исключениях при проектировании кода.

- Используйте утверждения, чтобы проверить наличие ошибок, которые не должны возникать. Используйте исключения для проверки ошибок, которые могут возникать, например, ошибок при проверке входных данных для параметров открытых функций. Дополнительные сведения см. в разделе **исключения и утверждения**.

- Используйте исключения, если код, обрабатывающий ошибку, может быть отделен от кода, который обнаруживает ошибку одним или несколькими промежуточными вызовами функций. Рассмотрите возможность использования кодов ошибок в циклах, критических для производительности, когда код, обрабатывающий ошибку, тесно связан с кодом, который его обнаруживает.

- Для каждой функции, которая может выдавать или распространять исключение, следует предоставить одно из трех гарантий исключений: строгая гарантия, Базовая гарантия или "Throw" (Except). Дополнительные сведения см. [в разделе руководство. проектирование безопасности исключений](how-to-design-for-exception-safety.md).

- Вызывайте исключения по значению, перехватите их по ссылке. Не перехватывайте объекты, которые не могут быть обработаны.

- Не используйте спецификации исключений, которые являются устаревшими в C++ 11. Дополнительные сведения см. в разделе **спецификации исключений и Кроме**.

- Используйте типы исключений стандартной библиотеки при их применении. Наследовать пользовательские типы исключений от иерархии [классов исключений](../standard-library/exception-class.md) .

- Не разрешать исключения для экранирования из деструкторов или функций освобождения памяти.

## <a name="exceptions-and-performance"></a>Исключения и производительность

Механизм исключения имеет очень минимальные затраты на производительность, если исключение не создается. При возникновении исключения стоимость прохода стека и его очистки приблизительно сравнима с затратами на вызов функции. Дополнительные структуры данных необходимы для трассировки стека вызовов после того, как будет выполнен вход в блок **try** , а дополнительные инструкции необходимы для очистки стека при возникновении исключения. Однако в большинстве случаев затраты на производительность и объем памяти не являются существенными. Негативное воздействие исключений на производительность может быть значительным только в системах с ограниченным объемом памяти или в циклах, критических с точки зрения производительности, в которых возникает ошибка регулярно, и код для его обработки тесно связан с кодом, который его сообщает. В любом случае невозможно понять фактическую стоимость исключений без профилирования и измерения. Даже в редких случаях, когда стоимость существенна, можно взвесить ее на более высокую правильность, упростить обслуживание и другие преимущества, предоставляемые хорошо спроектированной политикой исключений.

## <a name="exceptions-vs-assertions"></a>Исключения и утверждения

Исключения и утверждения — это два отдельных механизма для обнаружения ошибок во время выполнения в программе. Используйте утверждения для проверки условий во время разработки, которые никогда не должны быть истинными, если весь код правильный. Нет смысла в обработке такой ошибки с помощью исключения, поскольку ошибка указывает на то, что что-то в коде должно быть исправлено, и не представляет условие, которое программа может восстанавливать из среды выполнения. Утверждение останавливает выполнение на инструкции, чтобы можно было проверить состояние программы в отладчике. исключение продолжит выполнение из первого соответствующего обработчика catch. Используйте исключения для проверки ошибок, которые могут возникнуть во время выполнения, даже если код правильный, например "файл не найден" или "недостаточно памяти". Может потребоваться выполнить восстановление из этих условий, даже если при восстановлении только сообщение выводится в журнал и завершает программу. Всегда проверяйте аргументы для открытых функций с помощью исключений. Даже если функция бесплатна, вы можете не иметь полного контроля над аргументами, которые пользователь может передать ему.

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>C++исключения и исключения SEH Windows

C и C++ программы могут использовать механизм структурированной обработки исключений (SEH) в операционной системе Windows. Понятия SEH похожи на C++ исключения, за исключением того, что SEH использует конструкции **__try**, **__except**и **__finally** вместо **try** и **catch**. В Microsoft C++ COMPILER (компилятором MSVC) C++ исключения реализуются для SEH. Однако при написании C++ кода используйте синтаксис C++ исключения.

Дополнительные сведения о SEH см. в разделе [структурированная обработка исключений (C++C/)](structured-exception-handling-c-cpp.md).

## <a name="exception-specifications-and-noexcept"></a>Спецификации исключений и, Кроме

Спецификации исключений были введены C++ в качестве способа указания исключений, которые могут выдаваться функцией. Однако спецификации исключений выдают проблемы на практике и являются устаревшими в стандарте "черновик C++ 11". Не рекомендуется использовать спецификации исключений, кроме `throw()`, что означает, что функция не разрешает исключения для экранирования. Если необходимо использовать спецификации исключений типа `throw(`*type*`)`, имейте в виду, что компилятором MSVC отчасти от стандарта определенным образом. Дополнительные сведения см. в разделе [спецификации исключений (throw)](exception-specifications-throw-cpp.md). Описатель `noexcept` введен в C++ 11 в качестве предпочтительного варианта `throw()`.

## <a name="see-also"></a>См. также:

[Практическое руководство. Интерфейс между кодом с исключениями и без исключений](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
