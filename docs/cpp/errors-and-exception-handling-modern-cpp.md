---
title: Современные рекомендации по C++ для исключений и обработки ошибок
description: Как современные C++ поддерживают исключительные стили программирования по кодам ошибок.
ms.date: 08/24/2020
ms.topic: conceptual
ms.assetid: a6c111d0-24f9-4bbb-997d-3db4569761b7
ms.openlocfilehash: b402c93ea5af3cc7dab418b6dea58446ae300c67
ms.sourcegitcommit: efc8c32205c9d610f40597556273a64306dec15d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/26/2020
ms.locfileid: "88898374"
---
# <a name="modern-c-best-practices-for-exceptions-and-error-handling"></a>Современные рекомендации по C++ для исключений и обработки ошибок

В современных C++ в большинстве случаев предпочтительным способом сообщить и обрабатывались как логические ошибки, так и ошибки времени выполнения — использовать исключения. Особенно это касается того, что стек может содержать несколько вызовов функций между функцией, которая обнаруживает ошибку, и функцией, которая имеет контекст для ее устранения. Исключения предоставляют формальный, четко определенный способ для кода, который обнаруживает ошибки для передачи информации вверх по стеку вызовов.

## <a name="use-exceptions-for-exceptional-code"></a>Использовать исключения для кода исключительного пользования

Ошибки программы часто делятся на две категории: логические ошибки, вызванные ошибками программирования, например, ошибкой «индекс вне диапазона». И ошибки времени выполнения, которые выходят за рамки управления программистом, например "ошибка" Сетевая служба недоступна ". В программировании в стиле C и в COM Управление отчетами об ошибках осуществляется либо путем возвращения значения, представляющего код ошибки, либо кода состояния для конкретной функции, либо путем установки глобальной переменной, которую вызывающий может дополнительно получить после каждого вызова функции, чтобы проверить, были ли обнаружены ошибки. Например, при программировании COM для передачи ошибок вызывающему объекту используется возвращаемое значение HRESULT. API-интерфейс Win32 содержит `GetLastError` функцию для получения последней ошибки, о которой сообщил стек вызовов. В обоих случаях для распознавания кода и реагирования на него требуется вызывающая сторона. Если вызывающий объект не обрабатывает код ошибки явным образом, программа может аварийно завершить работу без предупреждения. Или можно продолжить выполнение с использованием неверных данных и получить неверные результаты.

Исключения являются предпочтительными в современных C++ по следующим причинам:

- Исключение приводит к тому, что вызывающий код распознает состояние ошибки и обрабатывает его. Необработанные исключения останавливают выполнение программы.

- Исключение переходит к точке в стеке вызовов, которая может справиться с ошибкой. Промежуточные функции могут позволить распространить исключение. Они не должны координироваться с другими уровнями.

- Механизм обратной записи исключений уничтожает все объекты в области действия после возникновения исключения в соответствии с четко определенными правилами.

- Исключение позволяет четко отделить код, который определяет ошибку, и код, обрабатывающий ошибку.

В следующем упрощенном примере показан синтаксис, необходимый для генерации и перехвата исключений в C++.

```cpp
#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits< char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

Исключения в C++ похожи на такие языки, как C# и Java. В **`try`** блоке при *возникновении* исключения оно будет *перехвачено* первым связанным **`catch`** блоком, тип которого совпадает с типом исключения. Иными словами, выполнение переходит от **`throw`** оператора к **`catch`** оператору. Если подходящий блок catch не найден, `std::terminate` вызывается метод и программа завершает работу. В C++ может быть вызван любой тип; Однако рекомендуется создавать тип, прямо или косвенно производный от `std::exception` . В предыдущем примере тип исключения [`invalid_argument`](../standard-library/invalid-argument-class.md) определен в стандартной библиотеке в [`<stdexcept>`](../standard-library/stdexcept.md) файле заголовка. C++ не предоставляет или не требует **`finally`** блока, чтобы гарантировать освобождение всех ресурсов при возникновении исключения. Идиома получения ресурсов — инициализация (RAII), которая использует интеллектуальные указатели, предоставляет необходимые функции для очистки ресурсов. Дополнительные сведения см. [в разделе руководство. проектирование безопасности исключений](how-to-design-for-exception-safety.md). Дополнительные сведения о механизме развертывания стека C++ см. в разделе [исключения и очистка стека](exceptions-and-stack-unwinding-in-cpp.md).

## <a name="basic-guidelines"></a>Основные рекомендации

Надежная обработка ошибок является сложной задачей в любом языке программирования. Хотя исключения предоставляют несколько функций, которые поддерживают хорошую обработку ошибок, они не могут выполнить всю работу. Чтобы реализовать преимущества механизма исключения, помните об исключениях при проектировании кода.

- Используйте утверждения, чтобы проверить наличие ошибок, которые не должны возникать. Используйте исключения для проверки ошибок, которые могут возникать, например, ошибок при проверке входных данных для параметров открытых функций. Дополнительные сведения см. в разделе [исключения и утверждения](#exceptions_versus_assertions) .

- Используйте исключения, если код, обрабатывающий ошибку, отделен от кода, который обнаруживает ошибку одним или несколькими промежуточными вызовами функций. Рассмотрите возможность использования кодов ошибок в циклах, критических для производительности, когда код, обрабатывающий ошибку, тесно связан с кодом, который его обнаруживает.

- Для каждой функции, которая может выдавать или распространять исключение, следует предоставить одно из трех гарантий исключений: строгая гарантия, Базовая гарантия или "Throw" (Except). Дополнительные сведения см. [в разделе руководство. проектирование безопасности исключений](how-to-design-for-exception-safety.md).

- Вызывайте исключения по значению, перехватите их по ссылке. Не перехватывайте объекты, которые не могут быть обработаны.

- Не используйте спецификации исключений, которые являются устаревшими в C++ 11. Дополнительные сведения см. в разделе [спецификации исключений и `noexcept` ](#exception_specifications_and_noexcept) раздел.

- Используйте типы исключений стандартной библиотеки при их применении. Наследовать пользовательские типы исключений от иерархии [ `exception` классов](../standard-library/exception-class.md) .

- Не разрешать исключения для экранирования из деструкторов или функций освобождения памяти.

## <a name="exceptions-and-performance"></a>Исключения и производительность

Механизм исключения имеет минимальные затраты на производительность, если исключение не создается. При возникновении исключения стоимость прохода стека и его очистки приблизительно сравнима с затратами на вызов функции. Дополнительные структуры данных необходимы для контроля стека вызовов после того **`try`** , как был выполнен блок, и при возникновении исключения требуются дополнительные инструкции для очистки стека. Однако в большинстве случаев затраты на производительность и объем памяти не являются существенными. Негативное воздействие исключений на производительность может быть значительным только для систем с ограниченным объемом памяти. Кроме того, в циклах, критических с точки зрения производительности, часто возникает ошибка, и существует тесная связь между кодом и его обработкой. В любом случае невозможно понять фактическую стоимость исключений без профилирования и измерения. Даже в редких случаях, когда стоимость существенна, можно взвесить ее на более высокую правильность, упростить обслуживание и другие преимущества, предоставляемые хорошо спроектированной политикой исключений.

## <a name="exceptions-versus-assertions"></a><a name="exceptions_versus_assertions"></a> Исключения и утверждения

Исключения и утверждения — это два отдельных механизма для обнаружения ошибок во время выполнения в программе. Используйте `assert` инструкции для проверки условий во время разработки, которые никогда не должны быть истинными, если весь код правильный. Нет никакой точки в обработке такой ошибки с помощью исключения, так как эта ошибка указывает на то, что что-то в коде должно быть исправлено. Он не представляет условие, которое программа может восстанавливать из среды выполнения. `assert`Останавливает выполнение на инструкции, чтобы можно было проверить состояние программы в отладчике. Исключение продолжит выполнение из первого соответствующего обработчика catch. Используйте исключения для проверки ошибок, которые могут возникнуть во время выполнения, даже если код правильный, например "файл не найден" или "недостаточно памяти". Исключения могут обработаны, даже если восстановление просто выводит сообщение в журнал и завершает программу. Всегда проверяйте аргументы для открытых функций с помощью исключений. Даже если функция бесплатна, вы можете не иметь полного контроля над аргументами, которые пользователь может передать ему.

## <a name="c-exceptions-versus-windows-seh-exceptions"></a>Исключения C++ и исключения SEH Windows

Программы C и C++ могут использовать механизм структурированной обработки исключений (SEH) в операционной системе Windows. Понятия SEH похожи на объекты в исключениях C++, за исключением того, что SEH **`__try`** использует **`__except`** конструкции, и, а **`__finally`** не **`try`** и **`catch`** . В компиляторе Microsoft C++ (КОМПИЛЯТОРОМ MSVC) исключения C++ реализуются для SEH. Однако при написании кода C++ используйте синтаксис исключения C++.

Дополнительные сведения о SEH см. в разделе [структурированная обработка исключений (C/C++)](structured-exception-handling-c-cpp.md).

## <a name="exception-specifications-and-noexcept"></a><a name="exception_specifications_and_noexcept"></a> Спецификации исключений и `noexcept`

Спецификации исключений были введены в C++ как способ указания исключений, которые может вызывать функция. Однако спецификации исключений выдают проблемы на практике и являются устаревшими в стандарте "черновик C++ 11". Мы рекомендуем не использовать **`throw`** спецификации исключений `throw()` , кроме, что указывает, что функция не допускает исключений для экранирования. Если необходимо использовать спецификации исключений устаревшей формы `throw( type-name )` , Поддержка компилятором MSVC ограничена. Дополнительные сведения см. в разделе [спецификации исключений (throw)](exception-specifications-throw-cpp.md). **`noexcept`** Описатель вводится в c++ 11 в качестве предпочтительного варианта `throw()` .

## <a name="see-also"></a>См. также

[Как взаимодействовать с исключительным и неисключительным кодом](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
