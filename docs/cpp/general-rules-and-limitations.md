---
title: Общие правила и ограничения
ms.date: 11/04/2016
ms.assetid: 6c48902d-4259-4761-95d4-e421d69aa050
ms.openlocfilehash: 3bd8956b08d3e5f2109c5574802a3a8a72fba537
ms.sourcegitcommit: a6d63c07ab9ec251c48bc003ab2933cf01263f19
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74857532"
---
# <a name="general-rules-and-limitations"></a>Общие правила и ограничения

**Блок, относящийся только к системам Майкрософт**

- При объявлении функции или объекта без атрибута **DllImport** или **dllexport** функция или объект не считаются частью интерфейса DLL. Поэтому объявление функции или объекта должно находиться в том же самом модуле или в другом модуле той же программы. Чтобы сделать функцию или объект частью интерфейса DLL, необходимо объявить определение функции или объекта в другом модуле как **dllexport**. В противном случае возникает ошибка компоновщика.

   Если объявить функцию или объект с атрибутом **dllexport** , его определение должно появиться в некоторых модулях той же программы. В противном случае возникает ошибка компоновщика.

- Если один модуль в программе содержит объявления **DllImport** и **dllexport** для одной и той же функции или объекта, атрибут **dllexport** имеет приоритет над атрибутом **DllImport** . Однако компилятор создает предупреждение. Например:

    ```cpp
    __declspec( dllimport ) int i;
    __declspec( dllexport ) int i;   // Warning; inconsistent;
                                     // dllexport takes precedence.
    ```

- В C++можно инициализировать глобально объявленный или статический указатель локальных данных или адрес объекта данных, объявленного с помощью атрибута **DllImport** , который создает ошибку в C. Кроме того, можно инициализировать статический указатель локальной функции с адресом функции, объявленной с помощью атрибута **DllImport** . В C такое присваивание задает указатель на адрес преобразователя импорта библиотеки DLL (заглушки кода, передающей контроль функции), а не адрес функции. В C++ оно задает указатель на адрес функции. Например:

    ```cpp
    __declspec( dllimport ) void func1( void );
    __declspec( dllimport ) int i;

    int *pi = &i;                             // Error in C
    static void ( *pf )( void ) = &func1;     // Address of thunk in C,
                                              // function in C++

    void func2()
    {
       static int *pi = &i;                  // Error in C
       static void ( *pf )( void ) = &func1; // Address of thunk in C,
                                             // function in C++
    }
    ```

   Однако поскольку программа, включающая атрибут **dllexport** в объявлении объекта, должна предоставлять определение для этого объекта в программе, можно инициализировать глобальный или локальный указатель на статическую функцию с адресом функции **dllexport** . Аналогичным образом можно инициализировать глобальный или локальный указатель на статические данные с адресом объекта данных **dllexport** . Например, следующий код не создает ошибки в C или C++:

    ```cpp
    __declspec( dllexport ) void func1( void );
    __declspec( dllexport ) int i;

    int *pi = &i;                              // Okay
    static void ( *pf )( void ) = &func1;      // Okay

    void func2()
    {
        static int *pi = &i;                   // Okay
        static void ( *pf )( void ) = &func1;  // Okay
    }
    ```

- При применении **dllexport** к обычному классу с базовым классом, который не помечен как **dllexport**, компилятор создаст C4275.

   Компилятор создает то же самое предупреждение, если базовый класс является специализацией шаблона классов. Чтобы обойти это, пометьте базовый класс на **dllexport**. Проблема с специализацией шаблона класса заключается в том, куда поместить **__declspec (dllexport)** ; Вам запрещено помечать шаблон класса. Вместо этого следует явно создать экземпляр шаблона класса и пометить это явное создание экземпляра с помощью **dllexport**. Например:

    ```cpp
    template class __declspec(dllexport) B<int>;
    class __declspec(dllexport) D : public B<int> {
    // ...
    ```

   Этот обходной путь завершается сбоем, если аргумент шаблона — это производный класс. Например:

    ```cpp
    class __declspec(dllexport) D : public B<D> {
    // ...
    ```

   Поскольку это распространенный шаблон с шаблонами, компилятор изменил семантику **dllexport** при применении к классу с одним или несколькими базовыми классами и когда один или несколько базовых классов являются специализацией шаблона класса. В этом случае компилятор неявно применяет **dllexport** к специализациям шаблонов классов. Вы можете выполнять следующие действия и не получать предупреждения:

    ```cpp
    class __declspec(dllexport) D : public B<D> {
    // ...
    ```

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также:

[dllexport, dllimport](../cpp/dllexport-dllimport.md)