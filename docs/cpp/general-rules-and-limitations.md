---
title: Общие правила и ограничения
ms.date: 11/04/2016
ms.assetid: 6c48902d-4259-4761-95d4-e421d69aa050
ms.openlocfilehash: 931ae04ef47262f15d037a2b5eeb35bd01a8419d
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50439238"
---
# <a name="general-rules-and-limitations"></a>Общие правила и ограничения

## <a name="microsoft-specific"></a>Блок, относящийся только к системам Microsoft

- При объявлении функции или объекта без **dllimport** или **dllexport** атрибут, функция или объект не считается частью интерфейса DLL. Поэтому объявление функции или объекта должно находиться в том же самом модуле или в другом модуле той же программы. Чтобы сделать функции или объекта частью интерфейса DLL, необходимо объявить определение функции или объекта в другом модуле **dllexport**. В противном случае возникает ошибка компоновщика.

   Если в объявлении функции или объекта с **dllexport** атрибут, его определение должно отображаться в каком-либо модуле той же программы. В противном случае возникает ошибка компоновщика.

- Если один модуль в программе содержит оба **dllimport** и **dllexport** объявления для одной и той же функции или объекта, **dllexport** атрибут имеет приоритет над **dllimport** атрибута. Однако компилятор создает предупреждение. Пример:

    ```cpp
    __declspec( dllimport ) int i;
    __declspec( dllexport ) int i;   // Warning; inconsistent;
                                     // dllexport takes precedence.
    ```

- В C++ можно инициализировать указатель на глобально объявленный или статический локальных данных или с адресом объекта данных, объявленного с **dllimport** атрибут, который приводит к ошибке на языке C. Кроме того, можно инициализировать статический указатель локальной функции с адресом функции с **dllimport** атрибута. В C такое присваивание задает указатель на адрес преобразователя импорта библиотеки DLL (заглушки кода, передающей контроль функции), а не адрес функции. В C++ оно задает указатель на адрес функции. Пример:

    ```cpp
    __declspec( dllimport ) void func1( void );
    __declspec( dllimport ) int i;

    int *pi = &i;                             // Error in C
    static void ( *pf )( void ) = &func1;     // Address of thunk in C,
                                              // function in C++

    void func2()
    {
       static int *pi = &i;                  // Error in C
       static void ( *pf )( void ) = &func1; // Address of thunk in C,
                                             // function in C++
    }
    ```

   Тем не менее поскольку программа с **dllexport** атрибутом в объявлении объекта должна содержать определение для этого объекта где-нибудь в программе, можно инициализировать указатель на глобальную или локальную статическую функцию с адрес **dllexport** функции. Аналогичным образом, можно инициализировать указатель на глобальные или локальные статические данные с адресом **dllexport** объекта данных. Например, следующий код не создает ошибки в C или C++:

    ```cpp
    __declspec( dllexport ) void func1( void );
    __declspec( dllexport ) int i;

    int *pi = &i;                              // Okay
    static void ( *pf )( void ) = &func1;      // Okay

    void func2()
    {
        static int *pi = &i;                   // Okay
        static void ( *pf )( void ) = &func1;  // Okay
    }
    ```

- Если применить **dllexport** к регулярному классу, который имеет базовый класс, который не помечен как **dllexport**, компилятор создает ошибку C4275.

   Компилятор создает то же самое предупреждение, если базовый класс является специализацией шаблона классов. Чтобы обойти эту проблему, пометьте базовый класс с **dllexport**. Проблема при специализации шаблона класса является размещение **__declspec(dllexport)**; помечать шаблон классов не разрешено. Вместо этого явно создать экземпляр шаблона классов и пометить это явное создание экземпляра с **dllexport**. Пример:

    ```cpp
    template class __declspec(dllexport) B<int>;
    class __declspec(dllexport) D : public B<int> {
    // ...
    ```

   Этот обходной путь завершается сбоем, если аргумент шаблона — это производный класс. Пример:

    ```cpp
    class __declspec(dllexport) D : public B<D> {
    // ...
    ```

   Поскольку это общая схема для шаблонов, компилятор изменил семантику **dllexport** при его применении к классу, который имеет один или несколько базовых классов, и если один или несколько базовых классов является специализацией шаблона класса . В этом случае компилятор неявно применяет **dllexport** для специализаций шаблонов классов. Можно выполнить следующие и не получить предупреждение:

    ```cpp
    class __declspec(dllexport) D : public B<D> {
    // ...
    ```

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[dllexport, dllimport](../cpp/dllexport-dllimport.md)