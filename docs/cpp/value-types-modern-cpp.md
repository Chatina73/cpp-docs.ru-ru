---
title: Классы C++ в качестве типов значений
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: f63bb62c-60da-40d5-ac14-4366608fe260
ms.openlocfilehash: 1aabcad46e848e1a499a142adaba5002a829bbf5
ms.sourcegitcommit: 654aecaeb5d3e3fe6bc926bafd6d5ace0d20a80e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74246024"
---
# <a name="c-classes-as-value-types"></a>Классы C++ в качестве типов значений

C++классы являются типами значений по умолчанию. Они могут быть указаны в виде ссылочных типов, что позволяет использовать полиморфизмы для поддержки объектно-ориентированного программирования. Типы значений иногда просматриваются с точки зрения памяти и элемента управления макета, тогда как ссылочные типы — это базовые классы и виртуальные функции для polybase. По умолчанию типы значений являются копируемыми, что означает, что всегда существует конструктор копии и оператор присваивания копии. Для ссылочных типов можно сделать класс недоступным для копирования (отключить конструктор копирования и оператор присваивания копирования) и использовать виртуальный деструктор, который поддерживает предполагаемый полиморфизм. Типы значений также относятся к содержимому, которое при копировании всегда дает два независимых значения, которые могут быть изменены отдельно. Ссылочные типы относятся к идентификатору — какой тип объекта он представляет? По этой причине «ссылочные типы» также называются «полиморфизмами».

Если вам действительно нужен ссылочный тип (базовый класс, виртуальные функции), необходимо явно отключить копирование, как показано в классе `MyRefType` в следующем коде.

```cpp
// cl /EHsc /nologo /W4

class MyRefType {
private:
    MyRefType & operator=(const MyRefType &);
    MyRefType(const MyRefType &);
public:
    MyRefType () {}
};

int main()
{
    MyRefType Data1, Data2;
    // ...
    Data1 = Data2;
}
```

Компиляция приведенного выше кода приведет к следующей ошибке:

```Output
test.cpp(15) : error C2248: 'MyRefType::operator =' : cannot access private member declared in class 'MyRefType'
        meow.cpp(5) : see declaration of 'MyRefType::operator ='
        meow.cpp(3) : see declaration of 'MyRefType'
```

## <a name="value-types-and-move-efficiency"></a>Типы значений и эффективность перемещения

В связи с новыми оптимизациями копирования не рекомендуется выполнять копирование ресурсов. Например, при вставке строки в середину вектора строк нет дополнительных затрат на повторное выделение копий, а только перемещение, даже если оно приводит к росту самого вектора. Это также относится к другим операциям, например к экземпляру, выполняющему операцию добавления двух очень больших объектов. Как вы включаете эти оптимизации операций со значениями? В некоторых C++ компиляторах это позволит компилятору сделать это неявно, точно так же, как конструкторы копий могут быть автоматически созданы компилятором. Тем не менее C++в необходимо, чтобы ваш класс поместит назначение и конструкторы, объявляя их в определении класса. Для этого используется ссылка на правостороннее амперсанд (& &) в соответствующих объявлениях функции-члена и определяющая методы перемещения конструктора и перемещения.  Кроме того, необходимо вставить правильный код, чтобы "украсть отступив" из исходного объекта.

Как решить, требуется ли переход? Если вы уже уверены, что построение копии включено, вы, вероятно, хотите включить перемещение, если это возможно дешевле, чем глубокая копия. Однако если вам известно, что требуется поддержка перемещения, это не обязательно означает, что вы хотите включить копирование. Последний случай называется "типом только для перемещения". Пример, уже имеющийся в стандартной библиотеке, `unique_ptr`. В качестве побочной заметки старая `auto_ptr` устарела и была заменена `unique_ptr` точно из-за отсутствия поддержки семантики перемещения в предыдущей версии C++.

С помощью семантики перемещения можно вернуть значение по значению или вставить в середину. Move — это оптимизация копирования. В качестве обходного пути требуется выделить кучу. Рассмотрим следующий псевдокод:

```cpp
#include <set>
#include <vector>
#include <string>
using namespace std;

//...
set<widget> LoadHugeData() {
    set<widget> ret;
    // ... load data from disk and populate ret
    return ret;
}
//...
widgets = LoadHugeData();   // efficient, no deep copy

vector<string> v = IfIHadAMillionStrings();
v.insert( begin(v)+v.size()/2, "scott" );   // efficient, no deep copy-shuffle
v.insert( begin(v)+v.size()/2, "Andrei" );  // (just 1M ptr/len assignments)
//...
HugeMatrix operator+(const HugeMatrix& , const HugeMatrix& );
HugeMatrix operator+(const HugeMatrix& ,       HugeMatrix&&);
HugeMatrix operator+(      HugeMatrix&&, const HugeMatrix& );
HugeMatrix operator+(      HugeMatrix&&,       HugeMatrix&&);
//...
hm5 = hm1+hm2+hm3+hm4+hm5;   // efficient, no extra copies
```

### <a name="enabling-move-for-appropriate-value-types"></a>Включение функции Move для соответствующих типов значений

Для класса, похожего на значение, в котором перемещение может быть дешевле, чем при глубоком копировании, включите построение перемещения и назначение перемещения для повышения эффективности. Рассмотрим следующий псевдокод:

```cpp
#include <memory>
#include <stdexcept>
using namespace std;
// ...
class my_class {
    unique_ptr<BigHugeData> data;
public:
    my_class( my_class&& other )   // move construction
        : data( move( other.data ) ) { }
    my_class& operator=( my_class&& other )   // move assignment
    { data = move( other.data ); return *this; }
    // ...
    void method() {   // check (if appropriate)
        if( !data )
            throw std::runtime_error("RUNTIME ERROR: Insufficient resources!");
    }
};
```

Если включить конструкцию копирования или назначение, также включите создание и назначение Move, если это может быть дешевле, чем глубокая копия.

Некоторые типы, *не являющиеся значениями* , являются только перемещением, например, если не удается клонировать ресурс, перенесите только владение. Пример: `unique_ptr`.

## <a name="see-also"></a>См. также:

[C++система типов](../cpp/cpp-type-system-modern-cpp.md)<br/>
[Добро пожаловать обратно вC++](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
