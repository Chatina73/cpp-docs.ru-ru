---
title: Типы значений (современный C++)
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: f63bb62c-60da-40d5-ac14-4366608fe260
ms.openlocfilehash: 32cdb29ec1c59081ad7e0493888f290f21561d2b
ms.sourcegitcommit: a1fad0a266b20b313364a74b16c9ac45d089b1e9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/11/2019
ms.locfileid: "54220352"
---
# <a name="value-types-modern-c"></a>Типы значений (современный C++)

Классы C++, типы значений по умолчанию. В этом разделе Вводный обзор типов значений и проблем, связанных с их использования.

## <a name="value-vs-reference-types"></a>Значения и ссылочные типы

Как указывалось ранее, являются классы C++, типы значений по умолчанию. Их можно указать как ссылочные типы, которые позволяют полиморфизма для поддержки объектно ориентированное программирование. Типы значений иногда просмотра с точки зрения памяти и макета элемента управления, тогда как ссылочные типы являются о базовых классов и виртуальных функций для полиморфного целей. По умолчанию типы значений являются копируемыми, означающее, что всегда существует конструктор копии и оператор присваивания копии. Для ссылочных типов, чтобы сделать класс некопируемых (отключить конструктор копии и оператор присваивания копии) и воспользовавшись виртуальным деструктором, которая поддерживает их предполагаемого полиморфизм. Типы значений также связаны с содержимым, то есть, когда они копируются, всегда дает два независимых значения, которые можно изменять отдельно. Ссылочные типы являются об удостоверении - тип объекта является его? По этой причине «ссылочные типы», также называются «полиморфных типов».

При желании тип ссылки по принципу (базовый класс, виртуальные функции), необходимо явно отключить копирование, как показано в `MyRefType` класс в следующем коде.

```cpp
// cl /EHsc /nologo /W4

class MyRefType {
private:
    MyRefType & operator=(const MyRefType &);
    MyRefType(const MyRefType &);
public:
    MyRefType () {}
};

int main()
{
    MyRefType Data1, Data2;
    // ...
    Data1 = Data2;
}
```

Компиляции приведенного выше кода приведет к следующей ошибки:

```Output
test.cpp(15) : error C2248: 'MyRefType::operator =' : cannot access private member declared in class 'MyRefType'
        meow.cpp(5) : see declaration of 'MyRefType::operator ='
        meow.cpp(3) : see declaration of 'MyRefType'
```

## <a name="value-types-and-move-efficiency"></a>Типы значений и переместить эффективность

Издержки при распределении копирования исключается из-за новых способов оптимизации копирования. Например при вставке Строка посередине вектор строк, будет не копирования повторное выделение издержек только move - даже если он приводит увеличение самого вектора. Это также относится к другие операции, например выполняя операцию добавить два очень большие объекты. Как включить эти операции оптимизации значение? В некоторых компиляторах C++ компилятор будет использовать данную функцию для вы неявно, примерно так же, что конструкторы копии можно автоматически создается компилятором. Тем не менее в Visual C++, класс должен «согласиться» для перемещения присваивания и конструкторы, объявив ее в определении класса. Это достигается с помощью двойной амперсанд (& &) ссылку rvalue в соответствующий член функции, объявления и определяющего конструктор перемещения и перемещение методов назначения.  Также необходимо вставить правильный код для «кражи внутренностях» за пределы исходного объекта.

Как же решить, если требуется переместить включена? Если уже известно, что требуется скопировать конструкции включена, вероятно вы хотите переместить включена, если он может быть дешевле, чем глубокую копию. Тем не менее если вы знаете, что требуется переместить поддержки, его не обязательно означает, что требуется включить копии. Последний случай будет называться «тип только для перемещения». Пример уже в стандартной библиотеке — `unique_ptr`. Заметим, старый `auto_ptr` является устаревшим и было заменено `unique_ptr` именно из-за отсутствия поддержки семантики перемещения в предыдущей версии языка C++.

С помощью семантики перемещения можно возврата по значению или вставки в середине. Перемещение является оптимизацией копирования. Нет необходимости для выделения кучи в качестве обходного решения. Рассмотрим следующий псевдокод:

```cpp
#include <set>
#include <vector>
#include <string>
using namespace std;

//...
set<widget> LoadHugeData() {
    set<widget> ret;
    // ... load data from disk and populate ret
    return ret;
}
//...
widgets = LoadHugeData();   // efficient, no deep copy

vector<string> v = IfIHadAMillionStrings();
v.insert( begin(v)+v.size()/2, "scott" );   // efficient, no deep copy-shuffle
v.insert( begin(v)+v.size()/2, "Andrei" );  // (just 1M ptr/len assignments)
//...
HugeMatrix operator+(const HugeMatrix& , const HugeMatrix& );
HugeMatrix operator+(const HugeMatrix& ,       HugeMatrix&&);
HugeMatrix operator+(      HugeMatrix&&, const HugeMatrix& );
HugeMatrix operator+(      HugeMatrix&&,       HugeMatrix&&);
//...
hm5 = hm1+hm2+hm3+hm4+hm5;   // efficient, no extra copies
```

### <a name="enabling-move-for-appropriate-value-types"></a>Включение перемещения для типов соответствующее значение

Для класса значение like, где перемещения может быть дешевле, чем глубокую копию включите конструкции перемещения и перемещение назначения для повышения эффективности. Рассмотрим следующий псевдокод:

```cpp
#include <memory>
#include <stdexcept>
using namespace std;
// ...
class my_class {
    unique_ptr<BigHugeData> data;
public:
    my_class( my_class&& other )   // move construction
        : data( move( other.data ) ) { }
    my_class& operator=( my_class&& other )   // move assignment
    { data = move( other.data ); return *this; }
    // ...
    void method() {   // check (if appropriate)
        if( !data )
            throw std::runtime_error("RUNTIME ERROR: Insufficient resources!");
    }
};
```

При включении конструкции копирования и присваивания, также включите конструкции перемещения и присваивания, если он может быть дешевле, чем глубокую копию.

Некоторые *незначимый* типы перемещения только, например когда нельзя клонировать ресурс, только передать владение. Пример: `unique_ptr`.

## <a name="section"></a>Раздел

Content

## <a name="see-also"></a>См. также

[Тип системы C++ (современный C++)](../cpp/cpp-type-system-modern-cpp.md)<br/>
[Возвращение к C++ (современный C++)](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
