---
title: Организация исходного кода (шаблоны C++)
ms.date: 11/04/2016
ms.assetid: 50569c5d-0219-4966-9bcf-a8689074ad1d
ms.openlocfilehash: 592f17c08b9d4de0f67f17c60521d6e9a11dfc3a
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2019
ms.locfileid: "65222004"
---
# <a name="source-code-organization-c-templates"></a>Организация исходного кода (шаблоны C++)

При определении шаблона класса, необходимо организовать исходный код так, что определения членов являются видимыми для компилятора, когда они нужны.   Вы можете выбрать с помощью *модель включения* или *явное создание экземпляра* модели. В модели включения включают определения членов в любом файле, который использует шаблон. Этот подход является простым и обеспечивает максимальную гибкость с точки зрения, какие конкретные типы можно использовать вместе с шаблоном. Его недостатком является то, что он может увеличить время компиляции. Влияние могут оказаться значительными в том случае, если проект и/или включенные файлы сами велики. Явное создание экземпляра при использовании сам шаблон создает конкретные классы или члены класса для определенных типов.  Этот подход может ускорить время компиляции, но оно ограничивает использование только те классы, которые средство реализации шаблона включил заранее. Как правило рекомендуется использовать модель включения, если время компиляции стать проблемой.

## <a name="background"></a>Фон

Шаблоны, как и обычные классы, в том смысле, что компилятор не создает объектный код для шаблона или любого из его элементов. Нет ничего для создания до создания экземпляра шаблона с помощью конкретных типов. Когда компилятор обнаруживает создание экземпляра шаблона, такие как `MyClass<int> mc;` и нет класса с этой сигнатурой еще не создана, он создает новый класс. Он также пытается создать код для любой функции-члены, которые используются. Если эти определения находятся в файле, не #included, прямо или косвенно, в CPP-файле, который компилируется, компилятор не видны.  С точки зрения компилятора это обязательно не ошибка, так как функции может быть определено в другой записи преобразования, в котором регистр компоновщик найдет их.  Если компоновщику не удается найти этот код, он выдает **неразрешенный внешний** ошибки.

## <a name="the-inclusion-model"></a>Включение модели

Простейший и наиболее распространенный способ сделать видимым во всем блоке трансляции определения шаблонов — поместите определения в файле заголовка, сам.  Любой CPP-файл, который использует шаблон просто надо #include заголовок. Это подход, используемый в стандартной библиотеке.

```cpp
#ifndef MYARRAY
#define MYARRAY
#include <iostream>

template<typename T, size_t N>
class MyArray
{
    T arr[N];
public:
    // Full definitions:
    MyArray(){}
    void Print()
    {
        for (const auto v : arr)
        {
            std::cout << v << " , ";
        }
    }

    T& operator[](int i)
   {
       return arr[i];
   }
};
#endif
```

В этом случае компилятор имеет доступ к определению полный шаблон и можно создавать экземпляры шаблонов по требованию для любого типа. Это простой и довольно простые в обслуживании. Тем не менее Включение модели со стоимостью с точки зрения времени компиляции.   Эти затраты могут оказаться значительными в больших программах, особенно в том случае, если сам заголовок шаблона #includes другие заголовки. Каждый CPP-файл, #includes заголовок получит свою собственную копию шаблонов функций и все определения. Компоновщик, обычно будет на Выяснение, что вы не получите несколько определений для функции, но требуется время для выполнения этих задач. В небольших программ, что лишние компиляции, вероятно, не имеет значения.

## <a name="the-explicit-instantiation-model"></a>Явное создание экземпляра модели

Если вы точно знаете набор типов, которые будут использоваться для создания экземпляра шаблона включения модель не может быть приемлемым для вашего проекта, можно отделить код шаблона в h и CPP-файл и в CPP-файле явно создавать экземпляры шаблонов. В результате для создаваемого объекта кода, компилятор поймет, когда он встречает экземпляров пользователя.

Явное создание экземпляра, создаваемых с помощью шаблона ключевое слово, следуют подпись для создания экземпляра сущности. Это может быть типом или членом. Если вы явно создать экземпляр типа, создаются все члены.

```cpp
template MyArray<double, 5>;
```

```cpp
//MyArray.h
#ifndef MYARRAY
#define MYARRAY

template<typename T, size_t N>
class MyArray
{
    T arr[N];
public:
    MyArray();
    void Print();
    T& operator[](int i);
};
#endif

//MyArray.cpp
#include <iostream>
#include "MyArray.h"

using namespace std;

template<typename T, size_t N>
MyArray<T,N>::MyArray(){}

template<typename T, size_t N>
void MyArray<T,N>::Print()
{
    for(const auto v : arr)
    {
        cout << v << "'";
    }
    cout << endl;
}

template MyArray<double, 5>;template MyArray<string, 5>;
```

В предыдущем примере явное создание экземпляров, в нижней части CPP-файл. Объект `MyArray` может использоваться только для **двойные** или `String` типов.

> [!NOTE]
> В C ++ 11 **Экспорт** ключевое слово был объявлен устаревшим в рамках определения шаблона. На практике это мало влияет, так как большинство компиляторов они никогда не поддерживаются.