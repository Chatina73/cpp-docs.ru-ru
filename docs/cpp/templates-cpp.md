---
title: Шаблоны (C++)
ms.date: 12/27/2019
f1_keywords:
- template_cpp
helpviewer_keywords:
- templates, C++
- templates [C++]
ms.assetid: 90fcc14a-2092-47af-9d2e-dba26d25b872
ms.openlocfilehash: e47f00c7e387974c7d1756cf3ee3865f892e6951
ms.sourcegitcommit: 89d9e1cb08fa872483d1cde98bc2a7c870e505e9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "82032347"
---
# <a name="templates-c"></a>Шаблоны (C++)

Шаблоны являются основой для общего программирования в СЗ. Как сильно типированный язык, СЗ требует, чтобы все переменные имели определенный тип, либо прямо объявленный программистом, либо выведенный компилятором. Тем не менее, многие структуры данных и алгоритмы выглядят одинаково независимо от того, на каком типе они работают. Шаблоны позволяют определить операции класса или функции, и позволяют пользователю указать, над какими конкретными типами должны работать эти операции.

## <a name="defining-and-using-templates"></a>Определение и использование шаблонов

Шаблон — это конструкция, которая генерирует обычный тип или функцию во время компиляции на основе аргументов, которые пользователь поставляет для параметров шаблона. Например, можно определить шаблон функции следующим образом:

```cpp
template <typename T>
T minimum(const T& lhs, const T& rhs)
{
    return lhs < rhs ? lhs : rhs;
}
```

Вышеуказанный код описывает шаблон для универсальной функции с одним параметром типа *T,* значение возврата и параметры вызова (lhs и rhs) все этого типа. Вы можете назвать тип параметра все, что вам нравится, но по конвенции одного верхнего корпуса буквы наиболее часто используются. *T* является параметром шаблона; ключевое слово **typename** говорит, что этот параметр является заполнителем для типа. Когда функция вызывается, компилятор заменит `T` каждый экземпляр с аргументом конкретного типа, который либо указан пользователем, либо выведен компилятором. Процесс, в котором компилятор генерирует класс или функцию из шаблона, называется *мгновенное создание шаблона;* `minimum<int>` является мгновенное создание шаблона. `minimum<T>`

В другом месте пользователь может объявить экземпляр шаблона, который специализируется на int. Предположим, что get_a () и get_b() являются функциями, которые возвращают int:

```cpp
int a = get_a();
int b = get_b();
int i = minimum<int>(a, b);
```

Однако, поскольку это шаблон функции и компилятор может вывести тип `T` из аргументов *a* и *b*, вы можете назвать его так же, как обычная функция:

```cpp
int i = minimum(a, b);
```

Когда компилятор сталкивается с последним утверждением, он генерирует новую функцию, в которой каждое появление *T* в шаблоне заменяется **int:**

```cpp
int minimum(const int& lhs, const int& rhs)
{
    return lhs < rhs ? lhs : rhs;
}
```

Правила выполнения компилятором вычета типа в шаблонах функций основаны на правилах для обычных функций. Для получения дополнительной [информации см. Разрешение перегрузки вызовов шаблонов функций.](../cpp/overload-resolution-of-function-template-calls.md)

## <a name="type-parameters"></a><a id="type_parameters"></a>Параметры типа

В `minimum` приведенном выше шаблоне обратите внимание, что параметр типа *T* никоим образом не квалифицируется до тех пор, пока он не будет использован в параметрах вызова функции, где добавляются конст и квалификаторы ссылки.

Количество параметров типа не ограничено. Разделите несколько параметров по запятым:

```cpp
template <typename T, typename U, typename V> class Foo{};
```

**Класс** ключевых слов эквивалентен **имени типа** в этом контексте. Вы можете выразить предыдущий пример следующим:

```cpp
template <class T, class U, class V> class Foo{};
```

Оператор эллипсиса (...) можно использовать для определения шаблона, который принимает произвольное количество параметров типа ноль или более:

```cpp
template<typename... Arguments> class vtclass;

vtclass< > vtinstance1;
vtclass<int> vtinstance2;
vtclass<float, bool> vtinstance3;
```

Любой встроенный или пользовательский тип может быть использован в качестве аргумента типа. Например, можно использовать [std::vector](../standard-library/vector-class.md) в Стандартной библиотеке для хранения переменных типа **Int,** **double,** [std::string](../standard-library/basic-string-class.md), `MyClass` **const** `MyClass`q, `MyClass&`и так далее. Основное ограничение при использовании шаблонов состоит в том, что аргумент типа должен поддерживать любые операции, применяемые к параметрам типа. Например, если `minimum` мы `MyClass` вызываем использование, как в этом примере:

```cpp
class MyClass
{
public:
    int num;
    std::wstring description;
};

int main()
{
    MyClass mc1 {1, L"hello"};
    MyClass mc2 {2, L"goodbye"};
    auto result = minimum(mc1, mc2); // Error! C2678
}
```

Ошибка компилятора `MyClass` будет сгенерирована, **<** поскольку не обеспечивает перегрузку для оператора.

Нет врожденного требования о том, что аргументы типа для какого-либо конкретного шаблона принадлежат к одной и той же иерархии объектов, хотя можно определить шаблон, который обеспечивает такое ограничение. Можно комбинировать объектно-ориентированные методы с шаблонами; например, можно хранить полученный в\<векторной базе\*>.    Обратите внимание, что аргументы должны быть указателями

```cpp
vector<MyClass*> vec;
   MyDerived d(3, L"back again", time(0));
   vec.push_back(&d);

   // or more realistically:
   vector<shared_ptr<MyClass>> vec2;
   vec2.push_back(make_shared<MyDerived>());
```

Основные требования, которые `std::vector` и другие стандартные контейнеры библиотеки налагают на элементы, `T` которые `T` могут быть скопируемыми и конструируемыми.

## <a name="non-type-parameters"></a>Параметры типа не типовые

В отличие от общих типов на других языках, таких как C и Java, шаблоны СЗ поддерживают *параметры типа,* также называемые параметрами значений. Например, можно указать постоянную интегральное значение для указания длины массива, как в этом примере, похожем на [класс std::array](../standard-library/array-class-stl.md) класса в Стандартной библиотеке:

```cpp
template<typename T, size_t L>
class MyArray
{
    T arr[L];
public:
    MyArray() { ... }
};
```

Обратите внимание на синтаксис в декларации шаблонов. Значение `size_t` передается в качестве аргумента шаблона во время компиляции и должно быть **конст или** выражение **constexpr.** Вы используете его так:

```cpp
MyArray<MyClass*, 10> arr;
```

Другие типы значений, включая указатели и ссылки, могут передаваться в качестве параметров типа. Например, можно передать указатель объекту функции или функции для настройки операции внутри кода шаблона.

### <a name="type-deduction-for-non-type-template-parameters"></a>Вычет типа для параметров шаблона типа

В Visual Studio 2017 и позже, в **режиме /std:c'17** компилятор выводит тип нетипного шаблона аргумент, который объявляется с **авто:**

```cpp
template <auto x> constexpr auto constant = x;

auto v1 = constant<5>;      // v1 == 5, decltype(v1) is int
auto v2 = constant<true>;   // v2 == true, decltype(v2) is bool
auto v3 = constant<'a'>;    // v3 == 'a', decltype(v3) is char
```

## <a name="templates-as-template-parameters"></a><a id="template_parameters"></a>Шаблоны как параметры шаблона

Шаблон может быть параметром шаблона. В этом примере MyClass2 имеет два параметра шаблона: параметр типа *T* и параметр шаблона *Arr:*

```cpp
template<typename T, template<typename U, int I> class Arr>
class MyClass2
{
    T t; //OK
    Arr<T, 10> a;
    U u; //Error. U not in scope
};
```

Поскольку сам параметр *Arr* не имеет тела, его параметры не нужны. В самом деле, это ошибка для ссылки на *Arr*'s typename или тип параметра имена из нутритела `MyClass2`. По этой причине имена параметров типа *Arr*могут быть опущены, как показано в этом примере:

```cpp
template<typename T, template<typename, int> class Arr>
class MyClass2
{
    T t; //OK
    Arr<T, 10> a;
};
```

## <a name="default-template-arguments"></a>Аргументы шаблона по умолчанию

Шаблоны классов и функций могут иметь аргументы по умолчанию. Если шаблон имеет аргумент по умолчанию, вы можете оставить его неопределенным при его использовании. Например, шаблон std:vector имеет аргумент по умолчанию для аллигатора:

```cpp
template <class T, class Allocator = allocator<T>> class vector;
```

В большинстве случаев по умолчанию std::класс аллокатора является приемлемым, поэтому вы используете вектор, как это:

```cpp
vector<int> myInts;
```

Но при необходимости вы можете указать пользовательский распределитель следующим образом:

```cpp
vector<int, MyAllocator> ints;
```

При наличии нескольких аргументов шаблона все аргументы после первого аргумента по умолчанию должны иметь аргументы по умолчанию.

При использовании шаблона, параметры которого по умолчанию, используйте пустые угловые скобки:

```cpp
template<typename A = int, typename B = double>
class Bar
{
    //...
};
...
int main()
{
    Bar<> bar; // use all default type arguments
}
```

## <a name="template-specialization"></a>Специализация шаблонов

В некоторых случаях шаблон не может или не желал бы определить точно такой же код для любого типа. Например, можно определить путь кода, который должен быть выполнен, только если аргумент типа является указателем, или std::wstring или типом, полученным из определенного базового класса.  В таких случаях можно определить *специализацию* шаблона для этого конкретного типа. Когда пользователь мгновенно использует шаблон с этим типом, компилятор использует специализацию для генерации класса, а для всех других типов компилятор выбирает более общий шаблон. Специализация, в которой все параметры специализируются, являются *полными специализациями.* Если только некоторые параметры являются специализированными, это называется *частичной специализацией.*

```cpp
template <typename K, typename V>
class MyMap{/*...*/};

// partial specialization for string keys
template<typename V>
class MyMap<string, V> {/*...*/};
...
MyMap<int, MyClass> classes; // uses original template
MyMap<string, MyClass> classes2; // uses the partial specialization
```

Шаблон может иметь любое количество специализаций до тех пор, пока каждый специализированный параметр типа уникален. Только шаблоны класса могут быть частично специализированными. Все полные и частичные специализации шаблона должны быть объявлены в том же пространстве имен, что и исходный шаблон.

Для получения дополнительной [информации см.](../cpp/template-specialization-cpp.md)
