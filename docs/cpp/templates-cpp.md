---
title: Шаблоны (C++)
ms.date: 11/04/2016
f1_keywords:
- template_cpp
helpviewer_keywords:
- templates, C++
- templates [C++]
ms.assetid: 90fcc14a-2092-47af-9d2e-dba26d25b872
ms.openlocfilehash: f1532b5aa4ea712feab08b49b7c035187ca0d042
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62330496"
---
# <a name="templates-c"></a>Шаблоны (C++)

Шаблоны являются основой для обобщенное программирование в C++. Как строго типизированным языком C++ необходимо использовать все переменные для определенного типа, явно объявленные программистом или выведен компилятором. Тем не менее многие структур данных и алгоритмов выглядят одинаково, независимо от того, какой тип, они применяются к. Шаблоны позволяют определять операции класса или функции и позволяет пользователю задать какие конкретный типы этих операций должен работать в.

## <a name="defining-and-using-templates"></a>Определение и использование шаблонов

Шаблон — это конструкция, которая формирует обычного типа или функции во время компиляции, на основе аргументов, введенные пользователем, для параметров шаблона. Например можно определить шаблона функции следующим образом:

```cpp
template <typename T>
T minimum(const T& lhs, const T& rhs)
{
    return lhs < rhs ? lhs : rhs;
}
```

Приведенный выше код описывает шаблон для универсальной функции с помощью одного параметра типа *T*, возвращаемое значение и параметры (lhs и rhs) вызова которого имеют этот тип. Можно задать имя параметра типа все, что чаще всего используются, например, но по соглашению единый букв верхнего регистра. *T* является параметром шаблона; **typename** ключевое слово говорит, что этот параметр — это заполнитель для типа. При вызове функции, компилятор заменяет каждое вхождение `T` с аргументом конкретный тип, указанный пользователем или выведен компилятором. Процесс, в котором компилятор создает класс или функция на основе шаблона называется *создание экземпляра шаблона*; `minimum<int>` является реализацией шаблона `minimum<T>`.

В другом месте пользователь может объявить экземпляр шаблона, предназначенного для int. Предполагается, что get_a() и get_b() — функции, возвращающие значение типа int:

```cpp
int a = get_a();
int b = get_b();
int i = minimum<int>(a, b);
```

Тем не менее, поскольку это шаблон функции и компилятор может вывести тип `T` из аргументов *a* и *b*, его можно вызвать так же, как и обычной функции:

```cpp
int i = minimum(a, b);
```

Когда компилятор обнаруживает, что последняя инструкция, он создает новую функцию, в которых каждое вхождение *T* в шаблоне заменяется **int**:

```cpp
int minimum(const int& lhs, const int& rhs)
{
    return lhs < rhs ? lhs : rhs;
}
```

Как компилятор выполняет выведение типа в шаблонах функций правила основаны на правилах для обычных функций. Дополнительные сведения см. в разделе [перегружать разрешения из вызовов шаблонов функций](../cpp/overload-resolution-of-function-template-calls.md).

## <a id="type_parameters"></a> Параметры типа

В `minimum` шаблона выше, обратите внимание, что параметр типа *T* не обработаны квалификатором никоим образом до использования в параметры вызова функции, где добавляются const и квалификаторов ссылки.

Нет практических ограничений на число параметров типа. Несколько параметров разделите запятыми:

```cpp
template <typename T, typename U, typename V> class Foo{};
```

Ключевое слово **класс** эквивалентен **typename** в данном контексте. Можно выразить как предыдущего примера:

```cpp
template <class T, class U, class V> class Foo{};
```

Можно использовать оператор кнопку с многоточием (...) для определения шаблона, который принимает произвольное число ноль или несколько параметров типа:

```cpp
template<typename... Arguments> class vtclass;

vtclass< > vtinstance1;
vtclass<int> vtinstance2;
vtclass<float, bool> vtinstance3;
```

Любой тип встроенных или пользовательских может использоваться как аргумент типа. Например, можно использовать std::vector в стандартной библиотеке для хранения целых чисел, тип Double, строки, MyClass, const MyClass *, MyClass &. Основной ограничение при использовании шаблонов является то, что аргумент типа должен поддерживать все операции, которые применяются к параметрам типа. Например, если мы называем минимальное с помощью "MyClass" как в следующем примере:

```cpp
class MyClass
{
public:
    int num;
    std::wstring description;
};

int main()
{
    MyClass mc1 {1, L"hello"};
    MyClass mc2 {2, L"goodbye"};
    auto result = minimum(mc1, mc2); // Error! C2678
}
```

Ошибка компилятора будет создаваться, так как MyClass не поддерживает перегрузки для < оператора.

Нет необходимости присущие, аргументы типа для любого конкретного шаблона все принадлежать той же иерархии объекта, несмотря на то, что можно определить шаблон, который обеспечивает выполнение такого ограничения. Вы можете объединить объектно ориентированных приемов с шаблонами; Например, можно хранить Derived * в векторе\<базы\*>.    Обратите внимание, что аргументы должны быть указателями

```cpp
vector<MyClass*> vec;
   MyDerived d(3, L"back again", time(0));
   vec.push_back(&d);

   // or more realistically:
   vector<shared_ptr<MyClass>> vec2;
   vec2.push_back(make_shared<MyDerived>());
```

Основные требования, которые вектора и другие контейнеры стандартной библиотеки налагаемые на элементы `T` является то, что `T` может быть назначен копирования и копирования конструируемый.

## <a name="non-type-parameters"></a>Не являющиеся типами параметров

В отличие от универсальных типов в других языках, например C# и Java C++ шаблоны поддерживают параметры типа, также называемые параметрами значение. Например можно предоставить постоянное целочисленное значение, чтобы указать длину массива, как и в этом примере, аналогичную классу std::array в стандартной библиотеке:

```cpp
template<typename T, size_t L>
class MyArray
{
    T arr[L];
public:
    MyArray() { ... }
};
```

Обратите внимание на синтаксис в объявлении шаблона. Значение size_t передается в качестве аргумента шаблона во время компиляции и должен быть константой или выражением constexpr. Используйте его следующим образом:

```cpp
MyArray<MyClass*, 10> arr;
```

Другие виды значений, включая указатели и ссылки на можно передать в качестве параметров, не являющегося типом. Например можно передать в указатель функции или объекта функции для настройки какой-либо операции в коде шаблона.

## <a id="template_parameters"></a> Шаблоны в качестве параметров шаблона

Шаблон может быть параметром шаблона. В этом примере MyClass2 имеет два параметра-шаблона: параметр typename *T* и параметр шаблона *Arr*:

```cpp
template<typename T, template<typename U, int I> class Arr>
class MyClass2
{
    T t; //OK
    Arr<T, 10> a;
    U u; //Error. U not in scope
};
```

Так как *Arr* сам параметр не имеет текста, его имена параметров не требуются. На самом деле является ошибкой для ссылки на *Arr*имя типа или класс имена параметров из тела `MyClass2`. По этой причине *Arr*его можно опустить имена параметров-типов, как показано в следующем примере:

```cpp
template<typename T, template<typename, int> class Arr>
class MyClass2
{
    T t; //OK
    Arr<T, 10> a;
};
```

## <a name="default-template-arguments"></a>Аргументы шаблонов по умолчанию

Шаблоны классов и функций могут иметь аргументы по умолчанию. Если шаблон содержит аргумент по умолчанию, можно оставить его не указано, при его использовании. Например шаблон std::vector имеет аргумент распределителя по умолчанию:

```cpp
template <class T, class Allocator = allocator<T>> class vector;
```

В большинстве случаев класс std::allocator по умолчанию является допустимым, поэтому использовать вектор следующим образом:

```cpp
vector<int> myInts;
```

Но при необходимости можно указать пользовательский распределитель следующим образом:

```cpp
vector<int, MyAllocator> ints;
```

При наличии нескольких аргументов шаблона все аргументы после первого аргумента по умолчанию должны иметь аргументы по умолчанию.

При использовании шаблона, параметры которого задаются все по умолчанию, используйте пустые угловые скобки:

```cpp
template<typename A = int, typename B = double>
class Bar
{
    //...
};
...
int main()
{
    Bar<> bar; // use all default type arguments
}
```

## <a name="template-specialization"></a>Специализация шаблона

В некоторых случаях это не невозможно или нежелательно для шаблона для определения именно тот же код для любого типа. Например вы можете для определения пути кода для выполнения только в том случае, если аргумент типа является указателем, или объект типа std::wstring или тип, производный от определенного базового класса.  В таких случаях можно определить *специализации* шаблона для этого типа. Когда пользователь создает экземпляр шаблона с этим типом, компилятор использует специализации, чтобы создать класс, и для всех других типов, компилятор выбирает более общего шаблона. Специализации, в которых специализируются все параметры являются *завершения специализации*. Если только некоторые параметры специализированный диск, он называется *частичной специализации*.

```cpp
template <typename K, typename V>
class MyMap{/*...*/};

// partial specialization for string keys
template<typename V>
class MyMap<string, V> {/*...*/};
...
MyMap<int, MyClass> classes; // uses original template
MyMap<string, MyClass> classes2; // uses the partial specialization
```

Шаблон может иметь любое количество специализации, до тех пор, пока каждый параметр специализированным типом является уникальным. Только шаблоны классов могут быть частично специализировать. Все полной и частичной специализации шаблона должен быть объявлен в пространстве имен, исходный шаблон.

Дополнительные сведения см. в разделе [специализации шаблона](../cpp/template-specialization-cpp.md).