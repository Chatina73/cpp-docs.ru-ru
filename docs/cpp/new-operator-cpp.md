---
title: Оператор new (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- new keyword [C++]
ms.assetid: 69fee812-1c28-4882-8fda-d1ad17860004
ms.openlocfilehash: bcb7784e59966510970bd9b3ae0157ae982e462d
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62245391"
---
# <a name="new-operator-c"></a>Оператор new (C++)

Выделяет память для объекта или массива объектов *имя типа* из свободного хранилища и возвращает подходящим образом типизированный ненулевой указатель на объект.

> [!NOTE]
>  Расширения компонентов C++ Майкрософт обеспечивает поддержку для **новый** ключевое слово для добавления записей слота vtable. Дополнительные сведения см. в разделе [new (новый слот в vtable)](../extensions/new-new-slot-in-vtable-cpp-component-extensions.md)

## <a name="syntax"></a>Синтаксис

```
[::] new [placement] new-type-name [new-initializer]
[::] new [placement] ( type-name ) [new-initializer]
```

## <a name="remarks"></a>Примечания

Если операция завершилась неудачей, **новый** возвращает ноль или создает исключение; см. в разделе [новых и удаленных операторах](../cpp/new-and-delete-operators.md) Дополнительные сведения. Это поведение по умолчанию можно изменить, создав пользовательскую процедуру обработки исключений и вызвав [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) функции библиотеки времени выполнения с именем функции в качестве аргумента.

Сведения о том, как создать объект в управляемой куче, см. в разделе [gcnew](../extensions/ref-new-gcnew-cpp-component-extensions.md).

Когда **новый** — используется для выделения памяти для объекта класса C++, в конструктор объекта вызывается после выделения памяти.

Используйте [удалить](../cpp/delete-operator-cpp.md) оператор для освобождения памяти, выделенной с помощью **новый** оператор.

В следующем примере выделяется и затем освобождается двумерный массив символов размером `dim` на 10. При выделении многомерного массива все измерения, кроме первого, должны быть константными выражениями, которые возвращают положительные значения; самое левое измерение массива может являться любым выражением, результатом которого является положительное значение. При выделении массива с помощью **новый** оператор, первое измерение может быть равным нулю, **новый** оператор возвращает уникальный указатель.

```cpp
char (*pchar)[10] = new char[dim][10];
delete [] pchar;
```

*Имя типа* не может содержать **const**, **volatile**, объявления класса или объявления перечислений. Таким образом, следующее выражение является недопустимым:

```cpp
volatile char *vch = new volatile char[20];
```

**Новый** оператор не выделяет ссылочные типы, так как они не являются объектами.

**Новый** оператор не может использоваться для выделения функции, но его можно использовать для выделения указателей на функции. В следующем примере выделяется и затем освобождается массив из семи указателей на функции, которые возвращают целые числа.

```cpp
int (**p) () = new (int (*[7]) ());
delete *p;
```

Если вы используете оператор **новый** без дополнительных аргументов и выполните компиляцию с [/GX](../build/reference/gx-enable-exception-handling.md), [/EHa](../build/reference/eh-exception-handling-model.md), или [/EHs](../build/reference/eh-exception-handling-model.md) параметр, компилятор будет создать код, вызывающий оператор **удалить** Если конструктор вызывает исключение.

В следующем списке описываются грамматические элементы **новый**:

*Размещение*<br/>
Предоставляет способ передачи дополнительных аргументов при перегрузке **новый**.

*Имя типа*<br/>
Определяет тип для распределения; может быть встроенным или пользовательским типом. Если спецификация типа является сложной, она может быть окружена круглыми скобками, чтобы принудительно реализовать порядок привязки.

*initializer*<br/>
Предоставляет значение для инициализированного объекта. Инициализаторы невозможно задать для массивов. **Новый** оператор создает массив объектов только в том случае, если класс имеет конструктор по умолчанию.

## <a name="example"></a>Пример

В следующем примере кода выделяется и освобождается массив символов и объект класса `CName`.

```cpp
// expre_new_Operator.cpp
// compile with: /EHsc
#include <string.h>

class CName {
public:
   enum {
      sizeOfBuffer = 256
   };

   char m_szFirst[sizeOfBuffer];
   char m_szLast[sizeOfBuffer];

public:
   void SetName(char* pszFirst, char* pszLast) {
     strcpy_s(m_szFirst, sizeOfBuffer, pszFirst);
     strcpy_s(m_szLast, sizeOfBuffer, pszLast);
   }

};

int main() {
   // Allocate memory for the array
   char* pCharArray = new char[CName::sizeOfBuffer];
   strcpy_s(pCharArray, CName::sizeOfBuffer, "Array of characters");

   // Deallocate memory for the array
   delete [] pCharArray;
   pCharArray = NULL;

   // Allocate memory for the object
   CName* pName = new CName;
   pName->SetName("Firstname", "Lastname");

   // Deallocate memory for the object
   delete pName;
   pName = NULL;
}
```

## <a name="example"></a>Пример

При использовании новой формы размещения **новый** оператор, формы с аргументами в дополнение к размеру выделения, компилятор не поддерживает форму размещения **удалить** оператор Если конструктор создает исключение. Пример:

```cpp
// expre_new_Operator2.cpp
// C2660 expected
class A {
public:
   A(int) { throw "Fail!"; }
};
void F(void) {
   try {
      // heap memory pointed to by pa1 will be deallocated
      // by calling ::operator delete(void*).
      A* pa1 = new A(10);
   } catch (...) {
   }
   try {
      // This will call ::operator new(size_t, char*, int).
      // When A::A(int) does a throw, we should call
      // ::operator delete(void*, char*, int) to deallocate
      // the memory pointed to by pa2.  Since
      // ::operator delete(void*, char*, int) has not been implemented,
      // memory will be leaked when the deallocation cannot occur.

      A* pa2 = new(__FILE__, __LINE__) A(20);
   } catch (...) {
   }
}

int main() {
   A a;
}
```

## <a name="initializing-object-allocated-with-new"></a>Инициализация объектов, выделенных с помощью оператора new

Необязательный *инициализатор* поле включено в грамматику **новый** оператор. Это позволяет инициализировать новые объекты с помощью пользовательских конструкторов. Дополнительные сведения о том, как выполняется инициализация, см. в разделе [инициализаторы](../cpp/initializers.md). В следующем примере демонстрируется использование выражения инициализации с **новый** оператор:

```cpp
// expre_Initializing_Objects_Allocated_with_new.cpp
class Acct
{
public:
    // Define default constructor and a constructor that accepts
    //  an initial balance.
    Acct() { balance = 0.0; }
    Acct( double init_balance ) { balance = init_balance; }
private:
    double balance;
};

int main()
{
    Acct *CheckingAcct = new Acct;
    Acct *SavingsAcct = new Acct ( 34.98 );
    double *HowMuch = new double ( 43.0 );
    // ...
}
```

В этом примере объект `CheckingAcct` выделяется с помощью **новый** указывается оператор, но инициализация по умолчанию. Поэтому вызывается конструктор по умолчанию для класса `Acct()`. Затем аналогичным образом выделяется объект `SavingsAcct` с единственным отличием: он явно инициализируется значением 34,98. Поскольку значение 34,98 принадлежит типу **двойные**, для обработки инициализации вызывается конструктор, принимающий аргумент этого типа. Наконец, неклассовый тип `HowMuch` инициализируется значением 43,0.

Если объект является типом класса и этот класс содержит конструкторы (как в предыдущем примере), объект можно инициализировать с **новый** оператор только в том случае, если выполнено одно из следующих условий:

- Аргументы, предоставленные в инициализаторе, согласуются с аргументами конструктора.

- Класс имеет конструктор по умолчанию (конструктор, который можно вызвать без аргументов).

Инициализация не явные элемент можно сделать при выделении массивов с **новый** оператор; только конструктор по умолчанию, при его наличии, вызывается. См. в разделе [аргументы по умолчанию](../cpp/default-arguments.md) Дополнительные сведения.

Если выделение памяти завершается сбоем (**оператор new** возвращает значение 0), то инициализация не выполняется. Это обеспечивает защиту от попыток инициализировать данные, которые не существуют.

Как и в случае вызова функций, порядок вычисления выражений инициализации не определен. Кроме того, не следует полагаться на то, что эти выражения полностью вычислены до выделения памяти. Если выделение памяти завершается сбоем и **новый** оператор возвращает нуль, некоторые выражения в инициализаторе могут быть вычислены не полностью.

## <a name="lifetime-of-objects-allocated-with-new"></a>Время жизни объектов, выделенных с помощью оператора new

Объектов, выделенных с помощью оператора **новый** оператор, не удаляются при выходе из области, в котором они определены. Так как **новый** оператор возвращает указатель на объекты, выделяется память, программа должна определить указатель с соответствующей областью видимости для доступа к этим объектам. Пример:

```cpp
// expre_Lifetime_of_Objects_Allocated_with_new.cpp
// C2541 expected
int main()
{
    // Use new operator to allocate an array of 20 characters.
    char *AnArray = new char[20];

    for( int i = 0; i < 20; ++i )
    {
        // On the first iteration of the loop, allocate
        //  another array of 20 characters.
        if( i == 0 )
        {
            char *AnotherArray = new char[20];
        }
    }

    delete [] AnotherArray; // Error: pointer out of scope.
    delete [] AnArray;      // OK: pointer still in scope.
}
```

После того как указатель `AnotherArray` в этом примере вышел за пределы области видимости, объект невозможно удалить.

## <a name="how-new-works"></a>Принцип работы оператора new

*Выражение выделения* — выражение, содержащее **новый** оператор — выполняет три действия:

- Находит и резервирует хранилище для объекта или объектов, которым нужно выделить память. После завершения этого этапа выделен требуемый объем памяти, но это еще не объект.

- Инициализирует объекты. После завершения инициализации имеется достаточно информации, чтобы выделенная память являлась объектом.

- Возвращает указатель на объекты типа указателя, производный от *новым именем типа* или *имя типа*. Программа использует этот указатель для доступа к новому объекту, которому выделена память.

**Новый** оператор вызывает функцию **оператор new**. Для массивов любого типа, а также для объектов, которые не имеют **класс**, **структуры**, или **объединение** типы, глобальная функция **:: оператор new**, — вызывается для выделения памяти. Объекты типа класса могут определять свои собственные **оператор new** статической функции-члена на основе каждого класса.

Когда компилятор обнаруживает **новый** оператор выделить объект типа **тип**, оно отправляет вызов `type` **:: оператор new (sizeof (** `type` **))** или, если нет пользовательских **оператор new** определен, **:: оператор new (sizeof (** `type` **))**. Таким образом **новый** оператор может выделите нужный объем памяти для объекта.

> [!NOTE]
>  Аргумент **оператор new** имеет тип `size_t`. Этот тип определен в \<direct.h >, \<malloc.h >, \<memory.h >, \<search.h >, \<stddef.h >, \<stdio.h >, \<stdlib.h >, \<string.h >, и \<time.h >.

Параметр в грамматике позволяет *размещения* (см. грамматику для [оператор new](../cpp/new-operator-cpp.md)). *Размещения* параметр может использоваться только для пользовательских реализаций **оператор new**; она позволяет дополнительной информации, должны быть переданы **оператор new**. Выражение с *размещения* поля, такие как `T *TObject = new ( 0x0040 ) T;` , преобразуется в `T *TObject = T::operator new( sizeof( T ), 0x0040 );` Если класс T должен оператор-член нового, в противном случае `T *TObject = ::operator new( sizeof( T ), 0x0040 );`.

Первоначальное предназначение *размещения* поле было позволяют аппаратно зависимым объектам память по адресам, определенным пользователем.

> [!NOTE]
>  Несмотря на то, что в предыдущем примере показан только один аргумент в *размещения* поле, нет никаких ограничений на количество дополнительных аргументов могут передаваться **оператор new** таким образом.

Даже в том случае, когда **оператор new** был определен для типа класса, глобальный оператор может использоваться с помощью формы в этом примере:

```cpp
T *TObject =::new TObject;
```

Оператор разрешения области действия (`::`) принудительное использование глобального **новый** оператор.

## <a name="see-also"></a>См. также

[Выражения с унарными операторами](../cpp/expressions-with-unary-operators.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[новые и удаление операторов](../cpp/new-and-delete-operators.md)