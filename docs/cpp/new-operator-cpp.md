---
title: Оператор new (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- new keyword [C++]
ms.assetid: 69fee812-1c28-4882-8fda-d1ad17860004
ms.openlocfilehash: ac89bf37b8aaaa9d77393b714a233f8a4c998139
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81367876"
---
# <a name="new-operator-c"></a>Оператор new (C++)

Выделяет память для объекта или массива объектов *типа-имя* из свободного хранилища и возвращает соответствующим образом набранный, ненулевой указатель на объект.

> [!NOTE]
> Расширение компонентов Microsoft C' обеспечивает поддержку **нового** ключевого слова для добавления записей слотов vtable. Для получения дополнительной информации, [см. новый (новый слот в vtable)](../extensions/new-new-slot-in-vtable-cpp-component-extensions.md)

## <a name="syntax"></a>Синтаксис

```
[::] new [placement] new-type-name [new-initializer]
[::] new [placement] ( type-name ) [new-initializer]
```

## <a name="remarks"></a>Remarks

В случае **неудачи, новые** возвращаетнул нулю или бросает исключение; для получения дополнительной информации [см.](../cpp/new-and-delete-operators.md) Вы можете изменить это поведение по умолчанию, написав пользовательскую процедуру обработки исключений и назвав [функцию _set_new_handler](../c-runtime-library/reference/set-new-handler.md) время выполнения с именем функции функции функции функции.

Для получения информации о том, как создать [gcnew](../extensions/ref-new-gcnew-cpp-component-extensions.md)объект на управляемой куче, см.

Когда **новая** используется для выделения памяти для объекта класса СЗ, конструктор объекта вызывается после выделения памяти.

Используйте оператора [удаления](../cpp/delete-operator-cpp.md) для дераспределения памяти, выделенной с **новым** оператором.

В следующем примере выделяется и затем освобождается двумерный массив символов размером `dim` на 10. При выделении многомерного массива все измерения, кроме первого, должны быть константными выражениями, которые возвращают положительные значения; самое левое измерение массива может являться любым выражением, результатом которого является положительное значение. При распределении массива с помощью **нового** оператора первое измерение может быть нулевым - **новый** оператор возвращает уникальный указатель.

```cpp
char (*pchar)[10] = new char[dim][10];
delete [] pchar;
```

*Имя типа* не может содержать **конст,** **летучие,** классные декларации или декларации о перечислении. Таким образом, следующее выражение является недопустимым:

```cpp
volatile char *vch = new volatile char[20];
```

**Новый** оператор не выделяет типы ссылок, поскольку они не являются объектами.

**Новый** оператор не может быть использован для выделения функции, но он может быть использован для выделения указателей на функции. В следующем примере выделяется и затем освобождается массив из семи указателей на функции, которые возвращают целые числа.

```cpp
int (**p) () = new (int (*[7]) ());
delete *p;
```

Если вы используете **новый** оператор без каких-либо дополнительных аргументов, и компилировать с [/GX](../build/reference/gx-enable-exception-handling.md), [/EHa](../build/reference/eh-exception-handling-model.md), или [/EHs](../build/reference/eh-exception-handling-model.md) вариант, компилятор будет генерировать код для вызова оператора **удалить,** если конструктор бросает исключение.

В следующем списке описаны элементы грамматики **новых:**

*Размещения*<br/>
Предоставляет способ передачи дополнительных аргументов, если вы перегружаете **новые**.

*имя типа*<br/>
Определяет тип для распределения; может быть встроенным или пользовательским типом. Если спецификация типа является сложной, она может быть окружена круглыми скобками, чтобы принудительно реализовать порядок привязки.

*Инициализатор*<br/>
Предоставляет значение для инициализированного объекта. Инициализаторы невозможно задать для массивов. **Новый** оператор будет создавать массивы объектов только в том случае, если класс имеет конструктор по умолчанию.

## <a name="example"></a>Пример

В следующем примере кода выделяется и освобождается массив символов и объект класса `CName`.

```cpp
// expre_new_Operator.cpp
// compile with: /EHsc
#include <string.h>

class CName {
public:
   enum {
      sizeOfBuffer = 256
   };

   char m_szFirst[sizeOfBuffer];
   char m_szLast[sizeOfBuffer];

public:
   void SetName(char* pszFirst, char* pszLast) {
     strcpy_s(m_szFirst, sizeOfBuffer, pszFirst);
     strcpy_s(m_szLast, sizeOfBuffer, pszLast);
   }

};

int main() {
   // Allocate memory for the array
   char* pCharArray = new char[CName::sizeOfBuffer];
   strcpy_s(pCharArray, CName::sizeOfBuffer, "Array of characters");

   // Deallocate memory for the array
   delete [] pCharArray;
   pCharArray = NULL;

   // Allocate memory for the object
   CName* pName = new CName;
   pName->SetName("Firstname", "Lastname");

   // Deallocate memory for the object
   delete pName;
   pName = NULL;
}
```

## <a name="example"></a>Пример

Если вы используете новую форму размещения **нового** оператора, форму с аргументами в дополнение к размеру распределения, компилятор не поддерживает форму размещения оператора **удаления,** если конструктор бросает исключение. Пример:

```cpp
// expre_new_Operator2.cpp
// C2660 expected
class A {
public:
   A(int) { throw "Fail!"; }
};
void F(void) {
   try {
      // heap memory pointed to by pa1 will be deallocated
      // by calling ::operator delete(void*).
      A* pa1 = new A(10);
   } catch (...) {
   }
   try {
      // This will call ::operator new(size_t, char*, int).
      // When A::A(int) does a throw, we should call
      // ::operator delete(void*, char*, int) to deallocate
      // the memory pointed to by pa2.  Since
      // ::operator delete(void*, char*, int) has not been implemented,
      // memory will be leaked when the deallocation cannot occur.

      A* pa2 = new(__FILE__, __LINE__) A(20);
   } catch (...) {
   }
}

int main() {
   A a;
}
```

## <a name="initializing-object-allocated-with-new"></a>Инициализация объектов, выделенных с помощью оператора new

В грамматику нового **оператора** включено факультативное поле *инициализатора.* Это позволяет инициализировать новые объекты с помощью пользовательских конструкторов. Для получения дополнительной информации о том, как инициализация осуществляется, [см.](../cpp/initializers.md) Следующий пример иллюстрирует, как использовать выражение инициализации с **новым** оператором:

```cpp
// expre_Initializing_Objects_Allocated_with_new.cpp
class Acct
{
public:
    // Define default constructor and a constructor that accepts
    //  an initial balance.
    Acct() { balance = 0.0; }
    Acct( double init_balance ) { balance = init_balance; }
private:
    double balance;
};

int main()
{
    Acct *CheckingAcct = new Acct;
    Acct *SavingsAcct = new Acct ( 34.98 );
    double *HowMuch = new double ( 43.0 );
    // ...
}
```

В этом примере `CheckingAcct` объект выделяется с помощью **нового** оператора, но инициализация по умолчанию не указана. Поэтому вызывается конструктор по умолчанию для класса `Acct()`. Затем аналогичным образом выделяется объект `SavingsAcct` с единственным отличием: он явно инициализируется значением 34,98. Поскольку 34.98 имеет **двойной**тип, конструктор, который принимает аргумент этого типа, призван обрабатывать инициализацию. Наконец, неклассовый тип `HowMuch` инициализируется значением 43,0.

Если объект имеет тип класса и что класс имеет конструкторов (как в предыдущем примере), объект может быть инициализирован **новым** оператором только в том случае, если одно из этих условий выполнено:

- Аргументы, предоставленные в инициализаторе, согласуются с аргументами конструктора.

- Класс имеет конструктор по умолчанию (конструктор, который можно вызвать без аргументов).

Явная инициализация на элемент не может быть выполнена при распределении массивов с помощью **нового** оператора; только конструктор по умолчанию, если присутствует, называется. Для получения дополнительной информации смотрите [аргументы «Аргументы по умолчанию».](../cpp/default-arguments.md)

Если выделение памяти не удается **(оператор новый** возвращает значение 0), инициализация не выполняется. Это обеспечивает защиту от попыток инициализировать данные, которые не существуют.

Как и в случае вызова функций, порядок вычисления выражений инициализации не определен. Кроме того, не следует полагаться на то, что эти выражения полностью вычислены до выделения памяти. Если выделение памяти не удается и **новый** оператор возвращаетнулно, некоторые выражения в инициаторе могут быть полностью оценены.

## <a name="lifetime-of-objects-allocated-with-new"></a>Время жизни объектов, выделенных с помощью оператора new

Объекты, выделенные **новым** оператором, не уничтожаются при выходе области, в которой они определены. Поскольку **новый** оператор возвращает указатель на объекты, которые он выделяет, программа должна определить указатель с подходящим объемом для доступа к этим объектам. Пример:

```cpp
// expre_Lifetime_of_Objects_Allocated_with_new.cpp
// C2541 expected
int main()
{
    // Use new operator to allocate an array of 20 characters.
    char *AnArray = new char[20];

    for( int i = 0; i < 20; ++i )
    {
        // On the first iteration of the loop, allocate
        //  another array of 20 characters.
        if( i == 0 )
        {
            char *AnotherArray = new char[20];
        }
    }

    delete [] AnotherArray; // Error: pointer out of scope.
    delete [] AnArray;      // OK: pointer still in scope.
}
```

После того как указатель `AnotherArray` в этом примере вышел за пределы области видимости, объект невозможно удалить.

## <a name="how-new-works"></a>Принцип работы оператора new

Выражение *распределения* - выражение, содержащее **нового** оператора - делает три вещи:

- Находит и резервирует хранилище для объекта или объектов, которым нужно выделить память. После завершения этого этапа выделен требуемый объем памяти, но это еще не объект.

- Инициализирует объекты. После завершения инициализации имеется достаточно информации, чтобы выделенная память являлась объектом.

- Возвращает указатель на объект (ы) типа указателя, полученного из *нового типа или* имени *типа.* Программа использует этот указатель для доступа к новому объекту, которому выделена память.

**Новый** оператор вызывает оператора функции **нового.** Для массивов любого типа, а также для объектов, не **относясь**к **классу,** структурировать или типам **соединения,** глобальная **функция::оператор новый,** вызывается для выделения хранилища. Объекты типа класса могут определять свою собственную **функцию нового статического** члена оператора на основе одного класса.

Когда компилятор сталкивается с **новым** оператором для выделения объекта **типа,** он выдает `type` **вызов::оператор новый (sizeof(** `type` **) или,** если нет пользовательского оператора **новый** определяется, **::оператор новый (sizeof)** `type` **)**. Таким образом, **новый** оператор может выделить правильный объем памяти для объекта.

> [!NOTE]
> Аргумент для **оператора новый** имеет тип `size_t`. Этот тип определяется \<в direct.h>, \< \<malloc.h \<>, memory.h>, search.h \<>, stddef.h>, \< \< \<stdio.h>, \<stdlib.h>, string.h> и time.h>.

Вариант в грамматике позволяет спецификации *размещения* (см. Грамматику для [нового оператора).](../cpp/new-operator-cpp.md) Параметр *размещения* может быть использован только для пользовательских реализаций **оператора нового;** это позволяет передавать дополнительную информацию **оператору новый.** Выражение с полем *размещения,* `T *TObject = new ( 0x0040 ) T;` например, переводится на, `T *TObject = T::operator new( sizeof( T ), 0x0040 );` если `T *TObject = ::operator new( sizeof( T ), 0x0040 );`класс T имеет оператора-члена нового, в противном случае .

Первоначальная цель поля *размещения* состояла в том, чтобы разрешить выделение аппаратно зависимых объектов по указанным пользователям адресам.

> [!NOTE]
> Хотя предыдущий пример показывает только один аргумент в поле *размещения,* нет никаких ограничений на то, сколько дополнительных аргументов может быть передано **оператору новый** таким образом.

Даже если **новый оператор** был определен для типа класса, глобальный оператор может быть использован с помощью формы этого примера:

```cpp
T *TObject =::new TObject;
```

Оператор разрешения сферы`::`() заставляет использовать **нового** глобального оператора.

## <a name="see-also"></a>См. также раздел

[Выражения с унарными операторами](../cpp/expressions-with-unary-operators.md)<br/>
[Keywords](../cpp/keywords-cpp.md)<br/>
[Операторы new и delete](../cpp/new-and-delete-operators.md)
