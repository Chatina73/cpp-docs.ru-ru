---
title: main аргументы функции и командной строки (C++)
description: mainФункция является точкой входа для программы C++.
ms.date: 01/15/2019
ms.assetid: c6568ee6-40ab-4ae8-aa44-c99e232f64ac
no-loc:
- main
- wmain
- inline
- static
- _tmain
- void
- exit
- argc
- argv
- envp
- CreateProcess
- GetModuleFileName
- char
- wchar_t
- extern
ms.openlocfilehash: b27668c3c7ce77e4369af144bb8be4efb695e522
ms.sourcegitcommit: a1676bf6caae05ecd698f26ed80c08828722b237
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/29/2020
ms.locfileid: "91499810"
---
# <a name="no-locmain-function-and-command-line-arguments"></a>main аргументы функции и командной строки

Все программы на C++ должны иметь `main` функцию. При попытке скомпилировать проект C++ *. exe* без main функции компилятор вызовет ошибку. (Библиотеки и библиотеки динамической компоновки static не имеют `main` функции.) `main` Функция заключается в том, где исходный код начинает выполнение, но до того, как программа введет `main` функцию, всем static членам класса без явных инициализаторов присваивается нулевое значение. В Microsoft C++ глобальные static объекты также инициализируются перед записью в `main` . К `main` функции, которая не применяется к другим функциям C++, применяются некоторые ограничения. `main`Функция:

- Не может быть перегружен (см. [перегрузку функции](function-overloading.md)).
- Не может быть объявлен как **`inline`** .
- Не может быть объявлен как **`static`** .
- Не может иметь адрес взятым.
- Вызвать невозможно.

mainФункция не имеет объявления, так как она встроена в язык. Если это так, синтаксис объявления для `main` будет выглядеть следующим образом:

```cpp
int main();
int main(int argc, char *argv[], char *envp[]);
```

**Блок, относящийся только к системам Microsoft**

Если исходные файлы используют Юникод Wide char актерс, можно использовать `wmain` , который является char актер версией `main` . Синтаксис объявления функции `wmain` выглядит следующим образом:

```cpp
int wmain( );
int wmain(int argc, wchar_t *argv[], wchar_t *envp[]);
```

Можно также использовать `_tmain` , который определен в t char . h. `_tmain` разрешается в, `main` если не определено _UNICODE. В противном случае функция `_tmain` разрешается в функцию `wmain`.

Если возвращаемое значение не указано, компилятор предоставляет возвращаемое значение, равное нулю. Кроме того, `main` `wmain` функции и могут быть объявлены как возвращаемые **`void`** (без возвращаемого значения). Если объявляется `main` или `wmain` возвращается **`void`** , то нельзя вернуть exit код в родительский процесс или операционную систему с помощью оператора [return](./program-termination.md) . Чтобы вернуть exit код, если `main` или `wmain` объявлен как **`void`** , необходимо использовать [exit](./program-termination.md) функцию.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="command-line-arguments"></a>Аргументы командной строки

Аргументы для `main` или `wmain` предоставляют удобный синтаксический анализ аргументов в командной строке и, при необходимости, доступ к переменным среды. Типы для параметров `argc` и `argv` определяются языком. Имена `argc` , `argv` и `envp` являются традиционными, но их можно называть любым из них.

```cpp
int main( int argc, char* argv[], char* envp[]);
int wmain( int argc, wchar_t* argv[], wchar_t* envp[]);
```

Используются следующие определения аргументов.

*argc*<br/>
Целое число, содержащее число аргументов, следующих за *argv* . *argc* Параметр всегда больше или равен 1.

*argv*<br/>
Массив завершающихся null строк, представляющих введенные пользователем программы аргументы командной строки. По соглашению `argv[0]` — это команда, с помощью которой вызывается программа, `argv[1]` является первым аргументом командной строки и т. д., до `argv[argc]` которой всегда имеет значение null. Сведения о подавлении обработки из командной строки см. в разделе [Настройка обработки командной строки]() .

Первый аргумент командной строки — всегда `argv[1]`, а последний — `argv[argc - 1]`.

> [!NOTE]
> По соглашению `argv[0]` — это команда, с помощью которой вызывается программа. Однако можно создать процесс с помощью [CreateProcess](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) и, если вы используете как первый, так и второй аргумент (*Лпаппликатионнаме* и *лпкоммандлине*), `argv[0]` не может быть именем исполняемого файла; используйте [GetModuleFileName](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) для получения имени исполняемого файла и его полного пути.

**Блок, относящийся только к системам Microsoft**

*envp*<br/>
*envp* Массив, являющийся общим расширением во многих системах UNIX, используется в Microsoft C++. Это массив строк, представляющих переменные, заданные в среде пользователя. Этот массив завершается записью NULL. Он может быть объявлен как массив указателей на **`char`** ( `char *envp[]` ) или как указатель на указатели на **`char`** ( `char **envp` ). Если программа использует `wmain` вместо `main` , используйте **`wchar_t`** тип данных вместо **`char`** . Блок среды, переданный в `main` и `wmain` , является замороженной копией текущей среды. При последующем изменении среды с помощью вызова `putenv` или `_wputenv` , текущая среда (как и переменная или, возвращаемая `getenv` переменной или) изменится `_wgetenv` `_environ`  `_wenviron` , но блок, на который указывает, envp не изменится. Сведения о подавлении обработки среды см. в разделе [Настройка обработки командной строки]() . Этот аргумент совместим с ANSI в C, но не в C++.

**Завершение блока, относящегося только к системам Майкрософт**

### <a name="example"></a>Пример

В следующем примере показано, как использовать *argc* аргументы, *argv* и *envp* в следующих `main` случаях:

```cpp
// argument_definitions.cpp
// compile with: /EHsc
#include <iostream>
#include <string.h>

using namespace std;
int main( int argc, char *argv[], char *envp[] ) {
    int iNumberLines = 0;    // Default is no line numbers.

    // If /n is passed to the .exe, display numbered listing
    // of environment variables.

    if ( (argc == 2) && _stricmp( argv[1], "/n" ) == 0 )
         iNumberLines = 1;

    // Walk through list of strings until a NULL is encountered.
    for( int i = 0; envp[i] != NULL; ++i ) {
        if( iNumberLines )
            cout << i << ": " << envp[i] << "\n";
    }
}
```

## <a name="parsing-c-command-line-arguments"></a>Синтаксический анализ аргументов командной строки C++

**Блок, относящийся только к системам Microsoft**

В коде запуска Microsoft C/C++ используются следующие правила при обработке аргументов, вводимых в командной строке операционной системы.

- Аргументы разделяются пробелами (пробел или табуляция).

- Курсор char актер (^) не распознается как escape- char актер или разделитель. charАктер полностью обрабатывается анализатором командной строки в операционной системе перед передачей в `argv` массив в программе.

- Строка, заключенная в двойные кавычки ("*строка*"), интерпретируется как один аргумент, независимо от пробелов, содержащихся в. Строку в кавычках можно встроить в аргумент.

- Двойная кавычка с предшествующей обратной косой чертой ( \\ ") интерпретируется как литеральная двойная кавычка char актер (").

- Символы обратной косой черты обрабатываются буквально, если только им не предшествует двойная кавычка.

- Если после четного числа символов обратной косой черты стоит двойная кавычка, в массив `argv` помещается по одному символу обратной косой черты (\) для каждой пары символов обратной косой черты (\\), а двойная кавычка (") обрабатывается как разделитель строки.

- Если после нечетного числа знаков обратной косой черты стоит двойная кавычка, то одна обратная косая черта помещается в `argv` массив для каждой пары символов обратной косой черты, а двойные кавычки — в escape-последовательности main , что приводит к помещению символа двойной кавычки (") в качестве литерала `argv` .

### <a name="example"></a>Пример

В следующем примере программы показана передача аргументов командной строки:

```cpp
// command_line_arguments.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
int main( int argc,      // Number of strings in array argv
          char *argv[],   // Array of command-line argument strings
          char *envp[] )  // Array of environment variable strings
{
    int count;

    // Display each command-line argument.
    cout << "\nCommand-line arguments:\n";
    for( count = 0; count < argc; count++ )
         cout << "  argv[" << count << "]   "
                << argv[count] << "\n";
}
```

В следующей таблице показаны примеры входных данных и ожидаемые выходные данные, иллюстрирующие применение правил из приведенного выше списка.

### <a name="results-of-parsing-command-lines"></a>Результаты синтаксического анализа командных строк

|Данные в командной строке|argv[1]|argv[2]|argv3-5|
|-------------------------|---------------|---------------|---------------|
|`"abc" d e`|`abc`|`d`|`e`|
|`a\\b d"e f"g h`|`a\\b`|`de fg`|`h`|
|`a\\\"b c d`|`a\"b`|`c`|`d`|
|`a\\\\"b c" d e`|`a\\b c`|`d`|`e`|

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="wildcard-expansion"></a>Развертывание подстановочных знаков

**Блок, относящийся только к системам Microsoft**

Задавать имена файлов и пути к ним в аргументах командной строки можно при помощи знаков подстановки — вопросительного знака (?) и звездочки (*).

Аргументы командной строки обрабатываются подсистемой `_setargv` (или `_wsetargv` в среде Wide- char актер), которая по умолчанию не расширяет подстановочные знаки в отдельные строки в `argv` массиве строк. Дополнительные сведения о включении расширения с подстановочными знаками см. в разделе [расширение аргументов-шаблонов](../c-language/expanding-wildcard-arguments.md).

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="customizing-c-command-line-processing"></a>Настройка обработки командной строки C++

**Блок, относящийся только к системам Microsoft**

Если программа не принимает аргументы командной строки, можно сохранить небольшой объем пространства, подавив использование подпрограммы библиотеки, выполняющей обработку командной строки. Эта подпрограммы вызывается `_setargv` и описывается в разделе [расширение подстановочных знаков](). Чтобы подавить его использование, определите подпрограммы, которая ничего не делает с файлом `main` , содержащим функцию, и назовите ее `_setargv` . Затем вызов метода `_setargv` удовлетворяет вашему определению `_setargv` , а версия библиотеки не загружается.

Аналогично, если вы никогда не обращаетесь к таблице окружения через `envp` аргумент, можно предоставить собственную пустую подпрограммы, которая будет использоваться вместо `_setenvp` , подпрограммы обработки среды. Как и в `_setargv` случае функции, `_setenvp` должен быть объявлен как ** extern "C"**.

Программа может вызывать `spawn` или `exec` семейство подпрограмм в библиотеке времени выполнения C. Если это так, не следует подавлять подпрограммы обработки среды, так как эта процедура используется для передачи среды из родительского процесса в дочерний процесс.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Основные понятия](../cpp/basic-concepts-cpp.md)
