---
title: '`main` аргументы функции и командной строки (C++)'
description: '`main`Функция является точкой входа для программы C++.'
ms.date: 12/16/2020
no-loc:
- main
- wmain
- inline
- static
- _tmain
- void
- exit
- argc
- argv
- envp
- CreateProcess
- GetModuleFileName
- char
- wchar_t
- extern
ms.openlocfilehash: a9c68f199d4169c02260542a9730472e4ab397bd
ms.sourcegitcommit: 387ce22a3b0137f99cbb856a772b5a910c9eba99
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/17/2020
ms.locfileid: "97645076"
---
# <a name="no-locmain-function-and-command-line-arguments"></a>`main` аргументы функции и командной строки

Все программы на C++ должны иметь `main` функцию. При попытке компиляции программы C++ без `main` функции компилятор вызывает ошибку. (Библиотеки и библиотеки динамической компоновки static не имеют `main` функции.) `main` Функция заключается в том, где исходный код начинает выполнение, но до того, как программа введет `main` функцию, всем static членам класса без явных инициализаторов присваивается нулевое значение. В Microsoft C++ глобальные static объекты также инициализируются перед записью в `main` . К `main` функции, которая не применяется к другим функциям C++, применяются некоторые ограничения. Функция `main`:

- Не может быть перегружен (см. [перегрузку функции](./function-overloading.md)).
- Не может быть объявлен как **`inline`** .
- Не может быть объявлен как **`static`** .
- Адрес не может быть создан.
- Невозможно вызвать из программы.

## <a name="the-no-locmain-function-signature"></a>`main`Сигнатура функции

`main`Функция не имеет объявления, так как она встроена в язык. Если это так, синтаксис объявления для `main` будет выглядеть следующим образом:

```cpp
int main();
int main(int argc, char *argv[]);
```

Если возвращаемое значение не указано в `main` , компилятор предоставляет возвращаемое значение, равное нулю.

## <a name="standard-command-line-arguments"></a>Стандартные аргументы командной строки

Аргументы для `main` обеспечения удобного анализа аргументов в командной строке. Типы для параметров `argc` и `argv` определяются языком. Имена `argc` и `argv` являются традиционными, но их можно называть по своему усмотрению.

Используются следующие определения аргументов.

*`argc`*\
Целое число, содержащее число аргументов, следующих за *argv* . *argc* Параметр всегда больше или равен 1.

*`argv`*\
Массив завершающихся null строк, представляющих введенные пользователем программы аргументы командной строки. По соглашению `argv[0]` — это команда, с помощью которой вызывается программа. `argv[1]` Первый аргумент командной строки. Последним аргументом из командной строки является `argv[argc - 1]` , и `argv[argc]` всегда имеет значение null.

Сведения о подавлении обработки в командной строке см. в разделе [Настройка обработки командной строки C++](#customize).

> [!NOTE]
> По соглашению `argv[0]` — это имя файла программы. Однако в Windows можно создать процесс с помощью [`CreateProcess`](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) . Если вы используете и первый, и второй аргументы ( *`lpApplicationName`* и *`lpCommandLine`* ), `argv[0]` не может быть именем исполняемого файла. С помощью можно [`GetModuleFileName`](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) получить имя исполняемого файла и его полный путь.

## <a name="microsoft-specific-extensions"></a>Расширения, относящиеся к Microsoft

В следующих разделах описывается поведение, характерное для Майкрософт.

## <a name="the-no-locwmain-function-and-no-loc_tmain-macro"></a>`wmain`Функция и `_tmain` макрос

Если вы разрабатываете исходный код для использования Юникода Wide char актерс, можно использовать `wmain` точку входа, относящуюся к Microsoft, которая является char актер версией `main` . Ниже приведен эффективный синтаксис объявления для `wmain` :

```cpp
int wmain();
int wmain(int argc, wchar_t *argv[]);
```

Кроме того, можно использовать Microsoft-Специальный `_tmain` макрос, определенный в *`tchar.h`* . `_tmain` разрешается в, `main` Если `_UNICODE` не определен. В противном случае функция `_tmain` разрешается в функцию `wmain`. `_tmain`Макрос и другие макросы, начинающиеся с, `_t` полезны для кода, который должен создавать отдельные версии для узких и широких char наборов актер. Дополнительные сведения см. [в разделе Использование универсальных текстовых сопоставлений](../c-runtime-library/using-generic-text-mappings.md).

## <a name="returning-no-locvoid-from-no-locmain"></a>Возврат `void` из main

Как расширение Майкрософт, `main` `wmain` функции и могут быть объявлены как возвращаемые **`void`** (без возвращаемого значения). Это расширение также доступно в некоторых других компиляторах, но его использование не рекомендуется. Он доступен для симметрии, если `main` не возвращает значение.

Если объявляется `main` или `wmain` возвращается **`void`** , то нельзя вернуть exit код в родительский процесс или операционную систему с помощью [`return`](./program-termination.md) инструкции. Чтобы вернуть exit код, если `main` или `wmain` объявлен как **`void`** , необходимо использовать [`exit`](./program-termination.md) функцию.

## <a name="the-no-locenvp-command-line-argument"></a>`envp`Аргумент командной строки

`main` `wmain` Сигнатуры или позволяют дополнительному расширению для доступа к переменным среды, относящимся к Microsoft. Это расширение также распространено в других компиляторах для систем Windows и UNIX. Имя *`envp`* является традиционным, но вы можете присвоить параметру среды любое имя. Ниже приведены эффективные объявления для списков аргументов, включающих параметр среды:

```cpp
int main(int argc, char* argv[], char* envp[]);
int wmain(int argc, wchar_t* argv[], wchar_t* envp[]);
```

*`envp`*\
Необязательный *`envp`* параметр представляет собой массив строк, представляющих переменные, заданные в среде пользователя. Этот массив завершается записью NULL. Он может быть объявлен как массив указателей на **`char`** ( `char *envp[]` ) или как указатель на указатели на **`char`** ( `char **envp` ). Если программа использует `wmain` вместо `main` , используйте **`wchar_t`** тип данных вместо **`char`** .

Блок среды, переданный в `main` и `wmain` , является замороженной копией текущей среды. Если впоследствии среда будет изменена путем вызова `putenv` или `_wputenv` , то текущая среда (как возвращаемая `getenv` переменной или, `_wgetenv` а также `_environ` переменная или) изменится  `_wenviron` , но блок, на который указывает, *`envp`* не изменится. Дополнительные сведения о подавлении обработки среды см. в разделе [Настройка обработки командной строки C++](#customize). *`envp`* Аргумент совместим с стандартом C89, но не с стандартами C++.

### <a name="example-arguments-to-no-locmain"></a>Примеры аргументов для `main`

В следующем примере показано, как использовать *`argc`* аргументы, *`argv`* и *`envp`* в следующих `main` случаях:

```cpp
// argument_definitions.cpp
// compile with: /EHsc
#include <iostream>
#include <string.h>

using namespace std;
int main( int argc, char *argv[], char *envp[] )
{
    bool numberLines = false;    // Default is no line numbers.

    // If /n is passed to the .exe, display numbered listing
    // of environment variables.
    if ( (argc == 2) && _stricmp( argv[1], "/n" ) == 0 )
         numberLines = true;

    // Walk through list of strings until a NULL is encountered.
    for ( int i = 0; envp[i] != NULL; ++i )
    {
        if ( numberLines )
            cout << i << ": "; // Prefix with numbers if /n specified
        cout << envp[i] << "\n";
    }
}
```

## <a name="parsing-c-command-line-arguments"></a>Анализ аргументов командной строки C++

Правила синтаксического анализа командной строки, используемые кодом Microsoft C/C++, специфичны для Microsoft. Код запуска среды выполнения использует эти правила при интерпретации аргументов, заданных в командной строке операционной системы:

- Аргументы разделяются пробелами (пробел или табуляция).

- Первый аргумент (`argv[0]`) обрабатывается особым образом. Он представляет имя программы. Это должен быть допустимый путь, поэтому разрешены части, заключенные в двойные кавычки ( **`"`** ). Эти знаки двойных кавычек не включаются в выходные данные `argv[0]`. Части, заключенные в двойные кавычки, не позволяют интерпретировать пробел или знак табуляции char актер в качестве конца аргумента. Последующие правила в этом списке не применяются.

- Строка, заключенная в двойные кавычки, интерпретируется как один аргумент, который может содержать пробелы в char актерс. Строку в кавычках можно встроить в аргумент. Курсор ( **`^`** ) не распознается как escape- char актер или разделитель. Внутри заключенной в кавычки строки пара двойных кавычек интерпретируется как одна экранированная двойная кавычка. Если командная строка заканчивается до тех пор, пока не будет найдена закрывающая двойная кавычка, то все char прочитанные актерс будут выводиться в качестве последнего аргумента.

- Символ двойной кавычки после обратной косой черты ( **`\"`** ) интерпретируется как литеральный символ двойной кавычки ( **`"`** ).

- Символы обратной косой черты считаются литералами, если сразу за ними не стоит двойная кавычка.

- Если двойная кавычка стоит после четного числа символов обратной косой черты, в массив `argv` помещается по одному символу обратной косой черты ( **`\`** ) для каждой пары символов обратной косой черты ( **`\\`** ), а сама двойная кавычка ( **`"`** ) интерпретируется как разделитель строк.

- Если двойная кавычка стоит после нечетного числа символов обратной косой черты, в массив `argv` помещается по одному символу обратной косой черты ( **`\`** ) для каждой пары символов обратной косой черты ( **`\\`** ). Двойная кавычка интерпретируется как escape-последовательность путем main обратной косой черты, что приводит к тому, что литеральная двойная кавычка ( **`"`** ) будет помещена в `argv` .

### <a name="example-of-command-line-argument-parsing"></a>Пример синтаксического анализа аргументов командной строки

В следующем примере программы показана передача аргументов командной строки:

```cpp
// command_line_arguments.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
int main( int argc,      // Number of strings in array argv
          char *argv[],   // Array of command-line argument strings
          char *envp[] )  // Array of environment variable strings
{
    int count;

    // Display each command-line argument.
    cout << "\nCommand-line arguments:\n";
    for( count = 0; count < argc; count++ )
         cout << "  argv[" << count << "]   "
                << argv[count] << "\n";
}
```

### <a name="results-of-parsing-command-lines"></a>Результаты синтаксического анализа командных строк

В следующей таблице показаны примеры входных данных и ожидаемые выходные данные, иллюстрирующие применение правил из приведенного выше списка.

| Входные данные командной строки | argv[1] | argv[2] | argv3-5 |
|--|--|--|--|
| `"abc" d e` | `abc` | `d` | `e` |
| `a\\b d"e f"g h` | `a\\b` | `de fg` | `h` |
| `a\\\"b c d` | `a\"b` | `c` | `d` |
| `a\\\\"b c" d e` | `a\\b c` | `d` | `e` |
| `a"b"" c d` | `ab" c d` |  |  |

## <a name="wildcard-expansion"></a>Развертывание подстановочных знаков

Кроме того, компилятор Майкрософт позволяет использовать *подстановочный* знак char актерс, вопросительный знак ( **`?`** ) и звездочку ( **`*`** ), чтобы указать аргументы filename и Path в командной строке.

Аргументы командной строки обрабатываются внутренней подпрограммой в коде запуска среды выполнения, который по умолчанию не расширяет подстановочные знаки в отдельные строки в `argv` массиве строк. Можно включить расширение подстановочных знаков, включив *`setargv.obj`* файл ( *`wsetargv.obj`* файл для `wmain` ) в **`/link`** параметрах компилятора или в **`LINK`** командной строке.

Дополнительные сведения о параметрах компоновщика для запуска среды выполнения см. в статье [Параметры ссылок](../c-runtime-library/link-options.md).

## <a name="customize-c-command-line-processing"></a><a name="customize"/> Настройка обработки командной строки C++

Если программа не принимает аргументы командной строки, можно сохранить небольшой объем пространства, подавив подпрограмму обработки командной строки. Для этого включите файл *`noarg.obj`* (для `main` и `wmain`) в параметры компилятора **`/link`** или командную строку **`LINK`** .

Аналогичным образом, если вы никогда не использовали таблицу среды для доступа к аргументу *`envp`* , можно подавить внутреннюю подпрограмму обработки среды. Для этого включите файл *`noenv.obj`* (для `main` и `wmain`) в параметры компилятора **`/link`** или командную строку **`LINK`** .

Программа может вызывать семейство подпрограмм `spawn` или `exec` в библиотеке среды выполнения C. В этом случае не следует подавлять подпрограмму обработки среды, так как она используется для передачи данных о среде из родительского процесса в дочерний.

## <a name="see-also"></a>См. также раздел

[Основные понятия](../cpp/basic-concepts-cpp.md)
