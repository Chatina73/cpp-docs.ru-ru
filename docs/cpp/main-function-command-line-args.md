---
title: функция Main и аргументы командной строки (C++)
description: Функция Main — это точка входа для C++ программы.
ms.date: 12/10/2019
ms.assetid: c6568ee6-40ab-4ae8-aa44-c99e232f64ac
ms.openlocfilehash: 95e774700c63dc815f6d814bfda84a38a38d4e6e
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75302412"
---
# <a name="main-function-and-command-line-arguments"></a>функция Main и аргументы командной строки

Все C++ программы должны иметь функцию `main`. При попытке компиляции C++ *exe* -проекта без функции Main компилятор вызовет ошибку. (Библиотеки динамической компоновки и статические библиотеки не имеют функции `main`.) Функция `main`, где начинается выполнение исходного кода, но до того, как программа войдет в функцию `main`, всем членам статического класса без явных инициализаторов присваивается нулевое значение. В корпорации C++Майкрософт глобальные статические объекты также инициализируются перед записью в `main`. К функции `main`, которая не применяется к другим C++ функциям, применяются некоторые ограничения. Функция `main`:

- Не может быть перегружен (см. [перегрузку функции](function-overloading.md)).
- Не может быть объявлен как **inline**.
- Не может быть объявлен как **static**.
- Не может иметь адрес взятым.
- Вызвать невозможно.

Синтаксис объявления функции `main` выглядит следующим образом:

```cpp
int main();
int main(int argc, char *argv[], char *envp[]);
```

**Блок, относящийся только к системам Майкрософт**

Если исходные файлы используют Юникод-символы в Юникоде, можно использовать `wmain`, которая является версией `main`для расширенных символов. Синтаксис объявления функции `wmain` выглядит следующим образом:

```cpp
int wmain( );
int wmain(int argc, wchar_t *argv[], wchar_t *envp[]);
```

Можно также использовать `_tmain`, который определен в файле Tchar. h. `_tmain` разрешается в `main`, если не определено _UNICODE. В противном случае функция `_tmain` разрешается в функцию `wmain`.

Если возвращаемое значение не указано, компилятор предоставляет возвращаемое значение, равное нулю. Кроме того, функции `main` и `wmain` могут быть объявлены как возвращающая значение **void** (без возвращаемого значения). При объявлении `main` или `wmain` в качестве возвращаемого значения **void**нельзя вернуть код выхода в родительский процесс или операционную систему с помощью оператора [return](../cpp/return-statement-in-program-termination-cpp.md) . Чтобы вернуть код выхода, если `main` или `wmain` объявлены как **void**, необходимо использовать функцию [Exit](../cpp/exit-function.md) .

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="command-line-arguments"></a>Аргументы командной строки

Аргументы для `main` или `wmain` обеспечивают удобный синтаксический анализ аргументов в командной строке и, при необходимости, доступ к переменным среды. Типы для параметров `argc` и `argv` определяются языком. Имена `argc`, `argv`и `envp` являются традиционными, но их можно присвоить имя по своему усмотрению.

```cpp
int main( int argc, char* argv[], char* envp[]);
int wmain( int argc, wchar_t* argv[], wchar_t* envp[]);
```

Используются следующие определения аргументов.

*argc*<br/>
Целое число, которое содержит число аргументов, следующих за *argv*. Параметр *argc* всегда больше или равен 1.

*argv*<br/>
Массив завершающихся null строк, представляющих введенные пользователем программы аргументы командной строки. По соглашению `argv[0]` — это команда, с помощью которой вызывается программа, `argv[1]` является первым аргументом командной строки и т. д., до `argv[argc]`, которая всегда имеет значение NULL. Сведения о подавлении обработки из командной строки см. в разделе [Настройка обработки командной строки](../cpp/customizing-cpp-command-line-processing.md) .

Первый аргумент командной строки — всегда `argv[1]`, а последний — `argv[argc - 1]`.

> [!NOTE]
> По соглашению `argv[0]` — это команда, с помощью которой вызывается программа. Однако можно создать процесс с помощью [CreateProcess](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) и при использовании обоих аргументов (*лпаппликатионнаме* и *лпкоммандлине*), `argv[0]` может не быть именем исполняемого файла; Используйте [GetModuleFileName](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) , чтобы получить имя исполняемого файла и его полный путь.

**Блок, относящийся только к системам Майкрософт**

*envp*<br/>
Массив *envp* , который является общим расширением во многих системах UNIX, используется в корпорации Майкрософт C++. Это массив строк, представляющих переменные, заданные в среде пользователя. Этот массив завершен записью NULL. Он может быть объявлен как массив указателей на **char** (`char *envp[]`) или как указатель на указатели на **char** (`char **envp`). Если программа использует `wmain` вместо `main`, используйте тип данных **wchar_t** , а не **char**. Блок среды, переданный `main` и `wmain`, является "замороженной" копией текущей среды. При последующем изменении среды с помощью вызова `putenv` или `_wputenv`текущая среда (возвращенная `getenv` или `_wgetenv` и переменная `_environ` или `_wenviron`) изменится, но блок, на который указывает envp, не изменится. Сведения о подавлении обработки среды см. в разделе [Настройка обработки командной строки](../cpp/customizing-cpp-command-line-processing.md) . Этот аргумент совместим с ANSI в C, но не в C++.

**Завершение блока, относящегося только к системам Майкрософт**

### <a name="example"></a>Пример

В следующем примере показано, как использовать аргументы *argc*, *argv*и *envp* для `main`:

```cpp
// argument_definitions.cpp
// compile with: /EHsc
#include <iostream>
#include <string.h>

using namespace std;
int main( int argc, char *argv[], char *envp[] ) {
    int iNumberLines = 0;    // Default is no line numbers.

    // If /n is passed to the .exe, display numbered listing
    // of environment variables.

    if ( (argc == 2) && _stricmp( argv[1], "/n" ) == 0 )
         iNumberLines = 1;

    // Walk through list of strings until a NULL is encountered.
    for( int i = 0; envp[i] != NULL; ++i ) {
        if( iNumberLines )
            cout << i << ": " << envp[i] << "\n";
    }
}
```

## <a name="parsing-c-command-line-arguments"></a>Синтаксический C++ анализ аргументов командной строки

**Блок, относящийся только к системам Майкрософт**

В коде запуска Microsoft C/C++ используются следующие правила при обработке аргументов, вводимых в командной строке операционной системы.

- Аргументы разделяются пробелами (пробел или табуляция).

- Символ каретки (^) не воспринимается как escape-символ или разделитель. Этот символ полностью обрабатывается синтаксическим анализатором командной строки в операционной системе, прежде чем передается в массив `argv` программы.

- Строка, заключенная в двойные кавычки ("*строка*"), интерпретируется как один аргумент, независимо от пробелов, содержащихся в. Строку в кавычках можно встроить в аргумент.

- Символ двойной кавычки после обратной косой черты (\\") обрабатывается как символ двойной кавычки литерала (").

- Символы обратной косой черты обрабатываются буквально, если только им не предшествует двойная кавычка.

- Если после четного числа символов обратной косой черты стоит двойная кавычка, в массив `argv` помещается по одному символу обратной косой черты (\) для каждой пары символов обратной косой черты (\\), а двойная кавычка (") обрабатывается как разделитель строки.

- Если после нечетного числа символов обратной косой черты стоит двойная кавычка, в массив `argv` помещается по одному символу обратной косой черты (\) для каждой пары символов обратной косой черты (\\), а символ двойной кавычки с оставшимся символом обратной косой черты интерпретируется как escape-последовательность, в результате чего в массив `argv` помещается литеральный символ двойной кавычки (").

### <a name="example"></a>Пример

В следующем примере программы показана передача аргументов командной строки:

```cpp
// command_line_arguments.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
int main( int argc,      // Number of strings in array argv
          char *argv[],   // Array of command-line argument strings
          char *envp[] )  // Array of environment variable strings
{
    int count;

    // Display each command-line argument.
    cout << "\nCommand-line arguments:\n";
    for( count = 0; count < argc; count++ )
         cout << "  argv[" << count << "]   "
                << argv[count] << "\n";
}
```

В следующей таблице показаны примеры входных данных и ожидаемые выходные данные, иллюстрирующие применение правил из приведенного выше списка.

### <a name="results-of-parsing-command-lines"></a>Результаты синтаксического анализа командных строк

|Данные в командной строке|argv[1]|argv[2]|argv[3]|
|-------------------------|---------------|---------------|---------------|
|`"abc" d e`|`abc`|`d`|`e`|
|`a\\b d"e f"g h`|`a\\b`|`de fg`|`h`|
|`a\\\"b c d`|`a\"b`|`c`|`d`|
|`a\\\\"b c" d e`|`a\\b c`|`d`|`e`|

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="wildcard-expansion"></a>Развертывание подстановочных знаков

**Блок, относящийся только к системам Майкрософт**

Задавать имена файлов и пути к ним в аргументах командной строки можно при помощи знаков подстановки — вопросительного знака (?) и звездочки (*).

Аргументы командной строки обрабатываются с помощью подпрограммы, именуемой `_setargv` (или `_wsetargv` в среде расширенных символов), которая по умолчанию не расширяет подстановочные знаки в отдельные строки в `argv` массиве строк. Дополнительные сведения о включении расширения с подстановочными знаками см. в разделе [расширение аргументов-шаблонов](../c-language/expanding-wildcard-arguments.md).

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="customizing-c-command-line-processing"></a>Настройка обработки командной строки C++

**Блок, относящийся только к системам Майкрософт**

Если программа не принимает аргументы командной строки, можно сохранить небольшой объем пространства, подавив использование подпрограммы библиотеки, выполняющей обработку командной строки. Эта подпрограммы называется `_setargv` и описывается в разделе [расширение подстановочных знаков](../cpp/wildcard-expansion.md). Чтобы подавить его использование, определите подпрограммы, которая не выполняет никаких действий в файле, содержащем функцию `main`, и назовите ее `_setargv`. Вызов `_setargv` будет удовлетворен определением `_setargv`, а версия библиотеки не загружается.

Аналогично, если вы никогда не обращаетесь к таблице окружения с помощью аргумента `envp`, можно предоставить собственную пустую подпрограммы, которая будет использоваться вместо `_setenvp`, подпрограммы обработки среды. Как и в случае функции `_setargv`, `_setenvp` должны быть объявлены как **extern "C"** .

Программа может вызывать `spawn` или `exec` семейства подпрограмм в библиотеке времени выполнения C. В этом случае не следует подавлять подпрограмму обработки среды, поскольку она используется для передачи среды из родительского процесса в дочерний процесс.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также:

[Основные понятия](../cpp/basic-concepts-cpp.md)