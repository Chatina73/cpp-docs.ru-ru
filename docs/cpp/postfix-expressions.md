---
title: Постфиксные выражения
ms.date: 11/04/2016
helpviewer_keywords:
- operators [C++], postfix
- postfix expressions
- expressions [C++], postfix
ms.assetid: 7ac62a57-06df-422f-b012-a75b37d7cb9b
ms.openlocfilehash: 897eb80c713f786ecf0f7e6c9cf24cd8bdfc0aa8
ms.sourcegitcommit: 89d9e1cb08fa872483d1cde98bc2a7c870e505e9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/22/2020
ms.locfileid: "82032282"
---
# <a name="postfix-expressions"></a>Постфиксные выражения

Постфиксные выражения состоят из основных выражений или выражений, в которых постфиксные операторы следуют за основным выражением. Постфиксные операторы перечислены в следующей таблице.

### <a name="postfix-operators"></a>Постфиксные операторы

|Имя оператора|Нотация оператора|
|-------------------|-----------------------|
|[Оператор субскриптов](../cpp/subscript-operator.md)|**[ ]**|
|[Оператор вызова функции](../cpp/function-call-operator-parens.md)|**( )**|
|[Оператор явного преобразования типа](../cpp/explicit-type-conversion-operator-parens.md)|*имя ()* **( )**|
|[Оператор доступа к элементу](../cpp/member-access-operators-dot-and.md)|**.** Или**->**|
|[Постфиксный оператор приращения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**++**|
|[Постфиксный оператор уменьшения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**--**|

Следующий синтаксис описывает возможные постфиксные выражения:

```
primary-expression
postfix-expression[expression]postfix-expression(expression-list)simple-type-name(expression-list)postfix-expression.namepostfix-expression->namepostfix-expression++postfix-expression--cast-keyword < typename > (expression )typeid ( typename )
```

*Постфикс-выражение* выше может быть основным выражением или другим выражением postfix.  Посмотреть **первичные выражения**.  Постфиксные выражения группируются слева направо, делая возможным следующее связывание выражений.

```cpp
func(1)->GetValue()++
```

В вышеупомянутом `func` выражении, `func(1)` является основным выражением, `func(1)->GetValue` является функция постфикс выражение, является `func(1)->GetValue()` выражением postfix с указанием члена класса, является еще одной функцией postfix выражение, и все выражение является выражением postfix, прибавивая значение возврата GetValue.  Значение выражения в целом имеет следующий смысл: "вызовите функцию, передающую 1 в качестве аргумента, и получите указатель на класс в качестве возвращаемого значения.  Затем `GetValue()` позвоните в этот класс, а затем приравнь возвращаемые значения.

Перечисленные выше выражения — это выражения присваивания, что означает, что результат этих выражений должен представлять собой r-значение.

Форма постфиксного выражения

```cpp
simple-type-name ( expression-list )
```

показывает вызов конструктора.  Если simple-type-name — это фундаментальный тип, список выражений должен представлять собой отдельное выражение, и это выражение обозначает приведение значения выражения к фундаментальному типу.  Данный тип выражения приведения копирует конструктор.  Поскольку эта форма позволяет создавать фундаментальные типы и классы с использованием одного и того же синтаксиса, эта форма особенно полезна при определении шаблонных классов.

*Литые ключевые слова* является одним из **dynamic_cast,** **static_cast** или **reinterpret_cast**.  Более подробную информацию можно найти в **dynamic_cast,** **static_cast** и **reinterpet_cast**.

Оператор **typeid** считается выражением postfix.  Смотрите **типид оператора**.

## <a name="formal-and-actual-arguments"></a>Формальные и фактические аргументы

При вызове программ сведения передаются в вызываемую функцию в фактических аргументах. Вызываемые функции получают доступ к сведениям с помощью соответствующих формальных аргументов.

При вызове функции выполняются следующие задачи.

- Вычисляются все фактические аргументы (предоставляемые вызывающим объектом). Эти аргументы вычисляются в произвольном порядке, но все аргументы вычисляются и все побочные эффекты завершаются перед переходом в функцию.

- Каждый формальный аргумент инициализируется с соответствующим фактическим аргументом в списке выражений. (Формальный аргумент — это аргумент, который объявляется в заголовке функции и используется в теле функции.) Преобразования выполняются как бы путем инициализации - как стандартные, так и пользовательские преобразования выполняются при преобразовании фактического аргумента в правильный тип. В общем виде выполненная инициализация показана в следующем коде.

    ```cpp
    void Func( int i ); // Function prototype
    ...
    Func( 7 );          // Execute function call
    ```

   Ниже представлены концептуальные инициализации до вызова.

    ```cpp
    int Temp_i = 7;
    Func( Temp_i );
    ```

   Обратите внимание, что инициализация выполняется таким образом, как если бы использовался синтаксис со знаком равенства, а не синтаксис с круглыми скобками. Копия `i` создается до передачи значения в функцию. (Для получения дополнительной информации [см. Инициаторы](../cpp/initializers.md) и [преобразования).](../cpp/user-defined-type-conversions-cpp.md)

   Таким образом, если прототип функции (декларация) требует аргумент типа **долго,** и если программа вызова поставляет фактический аргумент типа **Int**, фактический аргумент повышается с помощью стандартного преобразования типа для ввода **долго** (см. [Стандартные преобразования](../cpp/standard-conversions.md)).

   Предоставление фактического аргумента при отсутствии стандартного или пользовательского преобразования в тип формального аргумента будет ошибкой.

   В случае фактических аргументов типа класса формальный аргумент инициализируется путем вызова конструктора класса. (См. [Конструкторы](../cpp/constructors-cpp.md) для получения дополнительной информации об этих специальных функций члена класса.)

- Выполняется вызов функции.

В следующем фрагменте программного кода показан вызов функции.

```cpp
// expre_Formal_and_Actual_Arguments.cpp
void func( long param1, double param2 );

int main()
{
    long i = 1;
    double j = 2;

    // Call func with actual arguments i and j.
    func( i, j );
}

// Define func with formal parameters param1 and param2.
void func( long param1, double param2 )
{
}
```

При `func` вызове из `param1` основного, `i` `i` `j` формальный параметр инициализируется со значением (преобразуется в тип `param2` **долго,** чтобы соответствовать правильному типу с помощью стандартного преобразования), а формальный параметр инициализируется со значением (преобразуется`j` в два типа **с** помощью стандартного преобразования).

## <a name="treatment-of-argument-types"></a>Работа с типами аргументов

Формальные аргументы, объявленные как типы const, невозможно изменить в теле функции. Функции могут изменить любой аргумент, который не является **типом const**. Однако изменение является локальным для функции и не влияет на значение фактического аргумента, если фактический аргумент не является ссылкой на объект, не тип **const.**

Некоторые из этих понятий показаны на примере следующих функций.

```cpp
// expre_Treatment_of_Argument_Types.cpp
int func1( const int i, int j, char *c ) {
   i = 7;   // C3892 i is const.
   j = i;   // value of j is lost at return
   *c = 'a' + j;   // changes value of c in calling function
   return i;
}

double& func2( double& d, const char *c ) {
   d = 14.387;   // changes value of d in calling function.
   *c = 'a';   // C3892 c is a pointer to a const object.
    return d;
}
```

## <a name="ellipsis-and-default-arguments"></a>Аргументы Эллипсиса и по умолчанию

Чтобы функции принимали меньше аргументов, чем указано в определении функции, их можно определять, используя многоточие (`...`) или аргументы по умолчанию.

Ellipsis означает, что аргументы могут потребоваться, но что число и типы не указаны в декларации. Это обычно плохой стиль программирования на языке C++, поскольку он сводит на нет одно из преимуществ этого языка: безопасность типа. Различные преобразования применяются к функциям, объявленным с эллипсисом, чем к тем функциям, для которых известны формальные и фактические типы аргументов:

- Если фактический аргумент типа **плавает,** он повышается для ввода **двойной** до вызова функции.

- Любой подписанный или неподписанный **символ,** **короткий,** перечисленный тип или битовое поле преобразуется либо в подписанное, либо в неподписанное **int** с использованием интегрального продвижения.

- Любой аргумент типа класса передается по значению в виде структуры данных; копия создается путем двоичного копирования, а не путем вызова конструктора копии класса (если он имеется).

Ellipsis, если используется, должны быть объявлены последними в списке аргументов. Для получения дополнительной информации о прохождении переменного числа аргументов, см [va_list va_start va_arg.](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) *Run-Time Library Reference*

Для получения информации о аргументах по умолчанию в программировании CLR [см.](../extensions/variable-argument-lists-dot-dot-dot-cpp-cli.md)

Аргументы по умолчанию позволяют задать значение, которое должен принять аргумент, если в вызове функции значение не передано. В следующем фрагменте кода показано, как работают аргументы по умолчанию. Для получения дополнительной информации об ограничениях [Default Arguments](../cpp/default-arguments.md)на указание аргументов по умолчанию см.

```cpp
// expre_Ellipsis_and_Default_Arguments.cpp
// compile with: /EHsc
#include <iostream>

// Declare the function print that prints a string,
// then a terminator.
void print( const char *string,
            const char *terminator = "\n" );

int main()
{
    print( "hello," );
    print( "world!" );

    print( "good morning", ", " );
    print( "sunshine." );
}

using namespace std;
// Define print.
void print( const char *string, const char *terminator )
{
    if( string != NULL )
        cout << string;

    if( terminator != NULL )
        cout << terminator;
}
```

Представленная выше программа объявляет функцию `print`, принимающую два аргумента. Тем не менее, второй аргумент, *терминатор*, `"\n"`имеет значение по умолчанию, . В `main`, первые два `print` вызова, чтобы позволить второму аргументу по умолчанию предоставить новую строку для завершения печатной строки. В третьем вызове указывается явное значение второго аргумента. После выполнения этой программы выводится следующий результат:

```Output
hello,
world!
good morning, sunshine.
```

## <a name="see-also"></a>См. также раздел

[Типы выражений](../cpp/types-of-expressions.md)
