---
title: Постфиксные выражения
ms.date: 11/04/2016
helpviewer_keywords:
- operators [C++], postfix
- postfix expressions
- expressions [C++], postfix
ms.assetid: 7ac62a57-06df-422f-b012-a75b37d7cb9b
ms.openlocfilehash: 9a5c99c78623f2192b59a73f270f3ad5d2a34516
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231173"
---
# <a name="postfix-expressions"></a>Постфиксные выражения

Постфиксные выражения состоят из основных выражений или выражений, в которых постфиксные операторы следуют за основным выражением. Постфиксные операторы перечислены в следующей таблице.

### <a name="postfix-operators"></a>Постфиксные операторы

|Имя оператора|Нотация оператора|
|-------------------|-----------------------|
|[Оператор индекса](../cpp/subscript-operator.md)|**[ ]**|
|[Оператор вызова функции](../cpp/function-call-operator-parens.md)|**( )**|
|[Оператор явного преобразования типа](../cpp/explicit-type-conversion-operator-parens.md)|*Type-Name* **()**|
|[Оператор доступа к элементу](../cpp/member-access-operators-dot-and.md)|**.** ни**->**|
|[Постфиксный оператор приращения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**++**|
|[Постфиксный оператор уменьшения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**--**|

Следующий синтаксис описывает возможные постфиксные выражения:

```
primary-expression
postfix-expression[expression]postfix-expression(expression-list)simple-type-name(expression-list)postfix-expression.namepostfix-expression->namepostfix-expression++postfix-expression--cast-keyword < typename > (expression )typeid ( typename )
```

*Постфиксное выражение* выше может быть [основным выражением](primary-expressions.md) или другим постфиксным выражением. Постфиксные выражения группируются слева направо, делая возможным следующее связывание выражений.

```cpp
func(1)->GetValue()++
```

В приведенном выше выражении является первичным выражением, является постфиксным выражением `func` `func(1)` функции, `func(1)->GetValue` является постфиксным выражением, определяющим член класса, `func(1)->GetValue()` является выражением постфикса функции, а все выражением является постфиксное выражение, увеличивающее возвращаемое значение GetValue.  Значение выражения в целом имеет следующий смысл: "вызовите функцию, передающую 1 в качестве аргумента, и получите указатель на класс в качестве возвращаемого значения.  Затем вызовите `GetValue()` для этого класса, а затем увеличьте возвращаемое значение.

Перечисленные выше выражения — это выражения присваивания, что означает, что результат этих выражений должен представлять собой r-значение.

Форма постфиксного выражения

```cpp
simple-type-name ( expression-list )
```

показывает вызов конструктора.  Если simple-type-name — это фундаментальный тип, список выражений должен представлять собой отдельное выражение, и это выражение обозначает приведение значения выражения к фундаментальному типу.  Данный тип выражения приведения копирует конструктор.  Поскольку эта форма позволяет создавать фундаментальные типы и классы с использованием одного и того же синтаксиса, эта форма особенно полезна при определении шаблонных классов.

*Ключевое слово CAST* — одно из **`dynamic_cast`** , **`static_cast`** или **`reinterpret_cast`** .  Дополнительные сведения можно найти в [`dynamic_cast`](dynamic-cast-operator.md) , [`static_cast`](static-cast-operator.md) и [`reinterpet_cast`](reinterpret-cast-operator.md) .

**`typeid`** Оператор считается постфиксным выражением.  См. раздел **оператор typeid**.

## <a name="formal-and-actual-arguments"></a>Формальные и фактические аргументы

При вызове программ сведения передаются в вызываемую функцию в фактических аргументах. Вызываемые функции получают доступ к сведениям с помощью соответствующих формальных аргументов.

При вызове функции выполняются следующие задачи.

- Вычисляются все фактические аргументы (предоставляемые вызывающим объектом). Эти аргументы вычисляются в произвольном порядке, но все аргументы вычисляются и все побочные эффекты завершаются перед переходом в функцию.

- Каждый формальный аргумент инициализируется с соответствующим фактическим аргументом в списке выражений. (Формальный аргумент — это аргумент, объявленный в заголовке функции и используемый в теле функции.) Преобразования выполняются как при инициализации — как стандартные, так и пользовательские преобразования выполняются при преобразовании фактического аргумента в правильный тип. В общем виде выполненная инициализация показана в следующем коде.

    ```cpp
    void Func( int i ); // Function prototype
    ...
    Func( 7 );          // Execute function call
    ```

   Ниже представлены концептуальные инициализации до вызова.

    ```cpp
    int Temp_i = 7;
    Func( Temp_i );
    ```

   Обратите внимание, что инициализация выполняется таким образом, как если бы использовался синтаксис со знаком равенства, а не синтаксис с круглыми скобками. Копия `i` создается до передачи значения в функцию. (Дополнительные сведения см. в разделе [инициализаторы](../cpp/initializers.md) и [преобразования](../cpp/user-defined-type-conversions-cpp.md)).

   Таким образом, если прототип функции (объявление) вызывает аргумент типа **`long`** , и если вызывающая программа предоставляет фактический аргумент типа **`int`** , фактический аргумент повышается с помощью преобразования стандартного типа в тип **`long`** (см. раздел [стандартные преобразования](../cpp/standard-conversions.md)).

   Предоставление фактического аргумента при отсутствии стандартного или пользовательского преобразования в тип формального аргумента будет ошибкой.

   В случае фактических аргументов типа класса формальный аргумент инициализируется путем вызова конструктора класса. (Дополнительные сведения об этих специальных функциях-членах класса см. в разделе [конструкторы](../cpp/constructors-cpp.md) .)

- Выполняется вызов функции.

В следующем фрагменте программного кода показан вызов функции.

```cpp
// expre_Formal_and_Actual_Arguments.cpp
void func( long param1, double param2 );

int main()
{
    long i = 1;
    double j = 2;

    // Call func with actual arguments i and j.
    func( i, j );
}

// Define func with formal parameters param1 and param2.
void func( long param1, double param2 )
{
}
```

При `func` вызове из Main формальный параметр `param1` инициализируется значением `i` ( `i` преобразуется в тип в соответствии с **`long`** правильным типом, используя стандартное преобразование), а формальный параметр `param2` инициализируется значением `j` ( `j` преобразуется в тип **`double`** с помощью стандартного преобразования).

## <a name="treatment-of-argument-types"></a>Работа с типами аргументов

Формальные аргументы, объявленные как **`const`** типы, нельзя изменить в теле функции. Функции могут изменять любой аргумент, не являющийся типом **`const`** . Однако изменение является локальным для функции и не влияет на фактическое значение аргумента, если фактический аргумент не был ссылкой на объект, не являющийся типом **`const`** .

Некоторые из этих понятий показаны на примере следующих функций.

```cpp
// expre_Treatment_of_Argument_Types.cpp
int func1( const int i, int j, char *c ) {
   i = 7;   // C3892 i is const.
   j = i;   // value of j is lost at return
   *c = 'a' + j;   // changes value of c in calling function
   return i;
}

double& func2( double& d, const char *c ) {
   d = 14.387;   // changes value of d in calling function.
   *c = 'a';   // C3892 c is a pointer to a const object.
    return d;
}
```

## <a name="ellipsis-and-default-arguments"></a>Многоточие и аргументы по умолчанию

Чтобы функции принимали меньше аргументов, чем указано в определении функции, их можно определять, используя многоточие (`...`) или аргументы по умолчанию.

Многоточие означает, что аргументы могут быть обязательными, но число и типы не указаны в объявлении. Это обычно плохой стиль программирования на языке C++, поскольку он сводит на нет одно из преимуществ этого языка: безопасность типа. Различные преобразования применяются к функциям, объявленным с многоточием, а не к функциям, для которых известны формальный и фактический типы аргументов:

- Если фактический аргумент имеет тип **`float`** , **`double`** перед вызовом функции он повышается до типа.

- Любой **`signed char`** **`unsigned char`** **`signed short`** перечисляемый тип или, или, или **`unsigned short`** битовое поле преобразуются в **`signed int`** или **`unsigned int`** с помощью целочисленного повышения.

- Любой аргумент типа класса передается по значению в виде структуры данных; копия создается путем двоичного копирования, а не путем вызова конструктора копии класса (если он имеется).

Многоточие, если используется, должен быть объявлен последним в списке аргументов. Дополнительные сведения о передаче переменного числа аргументов см. в обсуждении [va_arg, va_start и va_list](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) в *справочнике по библиотеке времени выполнения*.

Дополнительные сведения о аргументах по умолчанию в программировании CLR см. в разделе [списки аргументов переменных (...) (C++/CLI)](../extensions/variable-argument-lists-dot-dot-dot-cpp-cli.md).

Аргументы по умолчанию позволяют задать значение, которое должен принять аргумент, если в вызове функции значение не передано. В следующем фрагменте кода показано, как работают аргументы по умолчанию. Дополнительные сведения об ограничениях на указание аргументов по умолчанию см. в разделе [аргументы по умолчанию](../cpp/default-arguments.md).

```cpp
// expre_Ellipsis_and_Default_Arguments.cpp
// compile with: /EHsc
#include <iostream>

// Declare the function print that prints a string,
// then a terminator.
void print( const char *string,
            const char *terminator = "\n" );

int main()
{
    print( "hello," );
    print( "world!" );

    print( "good morning", ", " );
    print( "sunshine." );
}

using namespace std;
// Define print.
void print( const char *string, const char *terminator )
{
    if( string != NULL )
        cout << string;

    if( terminator != NULL )
        cout << terminator;
}
```

Представленная выше программа объявляет функцию `print`, принимающую два аргумента. Однако второй аргумент, *признак конца*, имеет значение по умолчанию, `"\n"` . В `main` первые два вызова `print` позволяют использовать второй аргумент по умолчанию для предоставления новой строки для завершения выводимой строки. В третьем вызове указывается явное значение второго аргумента. После выполнения этой программы выводится следующий результат:

```Output
hello,
world!
good morning, sunshine.
```

## <a name="see-also"></a>См. также статью

[Типы выражений](../cpp/types-of-expressions.md)
