---
title: Постфиксные выражения
ms.date: 11/04/2016
helpviewer_keywords:
- operators [C++], postfix
- postfix expressions
- expressions [C++], postfix
ms.assetid: 7ac62a57-06df-422f-b012-a75b37d7cb9b
ms.openlocfilehash: eb6e6e8914cf260df09581232066caf3f873c04e
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62245067"
---
# <a name="postfix-expressions"></a>Постфиксные выражения

Постфиксные выражения состоят из основных выражений или выражений, в которых постфиксные операторы следуют за основным выражением. Постфиксные операторы перечислены в следующей таблице.

### <a name="postfix-operators"></a>Постфиксные операторы

|Имя оператора|Нотация оператора|
|-------------------|-----------------------|
|[Оператор индекса](../cpp/subscript-operator.md)|**[ ]**|
|[Оператор вызова функции](../cpp/function-call-operator-parens.md)|**( )**|
|[Оператор явного преобразования типа](../cpp/explicit-type-conversion-operator-parens.md)|*Имя типа* **)**|
|[Оператор доступа к членам](../cpp/member-access-operators-dot-and.md)|**.** Или **->**|
|[Постфиксный оператор приращения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**++**|
|[Постфиксный оператор уменьшения](../cpp/postfix-increment-and-decrement-operators-increment-and-decrement.md)|**--**|

Следующий синтаксис описывает возможные постфиксные выражения:

```
primary-expression
postfix-expression[expression]postfix-expression(expression-list)simple-type-name(expression-list)postfix-expression.namepostfix-expression->namepostfix-expression++postfix-expression--cast-keyword < typename > (expression )typeid ( typename )
```

*Постфиксное выражение* выше может быть основным выражением или другим постфиксным выражением.  См. в разделе **основные выражения**.  Постфиксные выражения группируются слева направо, делая возможным следующее связывание выражений.

```cpp
func(1)->GetValue()++
```

В предыдущем выражении `func` — это основное выражение `func(1)` представляет собой Постфиксное выражение функции, `func(1)->GetValue` представляет собой Постфиксное выражение, задающее член класса, `func(1)->GetValue()` — это другое Постфиксное выражение функции и весь выражение — Постфиксное выражение, увеличивающее возвращаемое значение метода GetValue.  Значение выражения в целом имеет следующий смысл: "вызовите функцию, передающую 1 в качестве аргумента, и получите указатель на класс в качестве возвращаемого значения.  Затем вызовите `GetValue()` для этого класса, затем увеличение возвращаемого значения.

Перечисленные выше выражения — это выражения присваивания, что означает, что результат этих выражений должен представлять собой r-значение.

Форма постфиксного выражения

```cpp
simple-type-name ( expression-list )
```

показывает вызов конструктора.  Если simple-type-name — это фундаментальный тип, список выражений должен представлять собой отдельное выражение, и это выражение обозначает приведение значения выражения к фундаментальному типу.  Данный тип выражения приведения копирует конструктор.  Поскольку эта форма позволяет создавать фундаментальные типы и классы с использованием одного и того же синтаксиса, эта форма особенно полезна при определении шаблонных классов.

*Слово cast* является одним из **dynamic_cast**, **static_cast** или **reinterpret_cast**.  Дополнительные сведения можно найти в **dynamic_cast**, **static_cast** и **reinterpet_cast**.

**Typeid** оператор считается Постфиксное выражение.  См. в разделе **оператор typeid**.

## <a name="formal-and-actual-arguments"></a>Формальные и фактические аргументы

При вызове программ сведения передаются в вызываемую функцию в фактических аргументах. Вызываемые функции получают доступ к сведениям с помощью соответствующих формальных аргументов.

При вызове функции выполняются следующие задачи.

- Вычисляются все фактические аргументы (предоставляемые вызывающим объектом). Эти аргументы вычисляются в произвольном порядке, но все аргументы вычисляются и все побочные эффекты завершаются перед переходом в функцию.

- Каждый формальный аргумент инициализируется с соответствующим фактическим аргументом в списке выражений. (Формальный аргумент — это аргумент, объявленный в заголовке функции и используемый в теле функции.) Преобразования выполняются таким же образом как при инициализации: стандартные и пользовательские преобразования выполняются при преобразовании фактического аргумента в требуемый тип. В общем виде выполненная инициализация показана в следующем коде.

    ```cpp
    void Func( int i ); // Function prototype
    ...
    Func( 7 );          // Execute function call
    ```

   Ниже представлены концептуальные инициализации до вызова.

    ```cpp
    int Temp_i = 7;
    Func( Temp_i );
    ```

   Обратите внимание, что инициализация выполняется таким образом, как если бы использовался синтаксис со знаком равенства, а не синтаксис с круглыми скобками. Копия `i` создается до передачи значения в функцию. (Дополнительные сведения см. в разделе [инициализаторы](../cpp/initializers.md) и [преобразования](../cpp/user-defined-type-conversions-cpp.md)).

   Таким образом Если прототип функции (объявление) вызывает аргумент типа **long**, и если вызывающая программа предоставляет фактический аргумент типа **int**, фактический аргумент повышается с помощью Преобразование стандартного типа в тип **long** (см. в разделе [стандартные преобразования](../cpp/standard-conversions.md)).

   Предоставление фактического аргумента при отсутствии стандартного или пользовательского преобразования в тип формального аргумента будет ошибкой.

   В случае фактических аргументов типа класса формальный аргумент инициализируется путем вызова конструктора класса. (См. в разделе [конструкторы](../cpp/constructors-cpp.md) Дополнительные сведения об этих специальных классов функций-членов.)

- Выполняется вызов функции.

В следующем фрагменте программного кода показан вызов функции.

```cpp
// expre_Formal_and_Actual_Arguments.cpp
void func( long param1, double param2 );

int main()
{
    long i = 1;
    double j = 2;

    // Call func with actual arguments i and j.
    func( i, j );
}

// Define func with formal parameters param1 and param2.
void func( long param1, double param2 )
{
}
```

Когда `func` вызывается из метода main, формальный параметр `param1` инициализируется со значением `i` (`i` преобразуется в тип **long** в соответствии с правильного типа, используя стандартный преобразование) и этот формальный параметр `param2` инициализируется со значением `j` (`j` преобразуется в тип **двойные** с помощью стандартного преобразования).

## <a name="treatment-of-argument-types"></a>Работа с типами аргументов

Формальные аргументы, объявленные как типы const, невозможно изменить в теле функции. Функции можно изменить любой аргумент, который не относится к типу **const**. Однако изменение является локальным для функции и не влияет на значение фактического аргумента, если фактический аргумент не является ссылкой на объект типа, отличного от **const**.

Некоторые из этих понятий показаны на примере следующих функций.

```cpp
// expre_Treatment_of_Argument_Types.cpp
int func1( const int i, int j, char *c ) {
   i = 7;   // C3892 i is const.
   j = i;   // value of j is lost at return
   *c = 'a' + j;   // changes value of c in calling function
   return i;
}

double& func2( double& d, const char *c ) {
   d = 14.387;   // changes value of d in calling function.
   *c = 'a';   // C3892 c is a pointer to a const object.
    return d;
}
```

## <a name="ellipses-and-default-arguments"></a>Многоточия и аргументы по умолчанию

Чтобы функции принимали меньше аргументов, чем указано в определении функции, их можно определять, используя многоточие (`...`) или аргументы по умолчанию.

Многоточие означает, что аргументы могут требоваться, но их число и типы не определены в объявлении. Это обычно плохой стиль программирования на языке C++, поскольку он сводит на нет одно из преимуществ этого языка: безопасность типа. Для функций, объявленных с многоточием, применяются иные преобразования, нежели для функций, для которых известны типы формальных и фактических аргументов.

- Если фактический аргумент имеет тип **float**, повышается до типа **двойные** перед вызовом функции.

- Любой знаковый или беззнаковый **char**, **короткие**, перечислимый тип или битовое поле преобразуется в знаковый или неподписанный **int** с помощью восходящее приведение целого типа.

- Любой аргумент типа класса передается по значению в виде структуры данных; копия создается путем двоичного копирования, а не путем вызова конструктора копии класса (если он имеется).

Многоточие (если оно используется) необходимо объявлять последним в списке аргументов. Дополнительные сведения о передаче переменное число аргументов см. в обсуждении [va_arg, va_start и va_list](../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md) в *Справочник по библиотеке времени выполнения*.

Сведения об аргументах по умолчанию программировании в среде CLR см. в разделе [списками аргументов переменных (...) (C++Выполняет) ](../extensions/variable-argument-lists-dot-dot-dot-cpp-cli.md).

Аргументы по умолчанию позволяют задать значение, которое должен принять аргумент, если в вызове функции значение не передано. В следующем фрагменте кода показано, как работают аргументы по умолчанию. Дополнительные сведения об ограничениях на задание аргументов по умолчанию, см. в разделе [аргументы по умолчанию](../cpp/default-arguments.md).

```cpp
// expre_Ellipses_and_Default_Arguments.cpp
// compile with: /EHsc
#include <iostream>

// Declare the function print that prints a string,
// then a terminator.
void print( const char *string,
            const char *terminator = "\n" );

int main()
{
    print( "hello," );
    print( "world!" );

    print( "good morning", ", " );
    print( "sunshine." );
}

using namespace std;
// Define print.
void print( const char *string, const char *terminator )
{
    if( string != NULL )
        cout << string;

    if( terminator != NULL )
        cout << terminator;
}
```

Представленная выше программа объявляет функцию `print`, принимающую два аргумента. Однако второй аргумент, *признак конца*, имеет значение по умолчанию `"\n"`. В `main`, первые два вызова `print` позволяют второму аргументу по умолчанию и предоставить новую строку для завершения печатаемой строки. В третьем вызове указывается явное значение второго аргумента. После выполнения этой программы выводится следующий результат:

```Output
hello,
world!
good morning, sunshine.
```

## <a name="see-also"></a>См. также

[Типы выражений](../cpp/types-of-expressions.md)