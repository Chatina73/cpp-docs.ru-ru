---
title: thread
ms.date: 05/07/2019
f1_keywords:
- thread_cpp
helpviewer_keywords:
- thread local storage (TLS)
- thread __declspec keyword
- TLS (thread local storage), compiler implementation
- __declspec keyword [C++], thread
ms.assetid: 667f2a77-6d1f-4b41-bee8-05e67324fab8
ms.openlocfilehash: cc21602764a9a3c2584bdd7da62c75974ffdd5fb
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75301292"
---
# <a name="thread"></a>thread

**Блок, относящийся только к системам Майкрософт**

Для объявления локальной переменной потока используется модификатор класса расширенной памяти **потока** . Для переносимого эквивалента в C++ 11 и более поздних версиях используйте описатель класса хранения [thread_local](../cpp/storage-classes-cpp.md#thread_local) для переносимого кода. В Windows **thread_local** реализован с **__declspec (thread)** .

## <a name="syntax"></a>Синтаксис

*декларатор* **__declspec (thread)**

## <a name="remarks"></a>Заметки

Локальное хранилище потока (TLS) — это механизм, с помощью которого в каждом потоке многопоточного процесса выделяется хранилище для хранения данных определенного потока. В стандартных многопоточных программах данные совместно используются всеми потоками заданного процесса, в то время как локальное хранилище потоков является механизмом предоставления данных для конкретного потока. Полное описание потоков см. в разделе [многопоточность](../parallel/multithreading-support-for-older-code-visual-cpp.md).

Объявления локальных переменных потока должны использовать [синтаксис расширенных атрибутов](../cpp/declspec.md) и ключевое слово **__declspec** с ключевым словом **Thread** . В следующем примере кода показано, как объявлять целочисленную локальную переменную потока и инициализировать её некоторым значением:

```cpp
__declspec( thread ) int tls_i = 1;
```

При использовании локальных переменных потока в динамически загружаемых библиотеках необходимо иметь в виду факторы, которые могут привести к неправильной инициализации локальной переменной потока:

1. Если переменная инициализируется вызовом функции (включая конструкторы), эта функция будет вызываться только для потока, который вызвал загрузку в процесс двоичного файла или библиотеки DLL, а также для потоков, запущенных после загрузки двоичного файла или библиотеки DLL. Функции инициализации не вызываются для других потоков, которые уже выполнялись при загрузке библиотеки DLL. Динамическая инициализация происходит при вызове DllMain для DLL_THREAD_ATTACH, но библиотека DLL никогда не получает это сообщение, если библиотека DLL не находится в процессе запуска потока.

1. Локальные переменные потока, инициализированные статически с постоянными значениями, обычно инициализируются должным образом на всех потоках. Однако по состоянию на декабрь 2017 существует известная ошибка соответствия в компиляторе Майкрософт C++ , в результате чего переменные **constexpr** получают динамическую, а не статическую инициализацию.

   Примечание. обе эти проблемы должны быть исправлены в будущих обновлениях компилятора.

Кроме того, при объявлении локальных объектов и переменных потока необходимо следовать приведенным ниже рекомендациям.

- Атрибут **Thread** можно применить только к объявлениям и определениям классов и данных. невозможно использовать **поток** в объявлениях или определениях функций.

- Атрибут **Thread** можно указать только для элементов данных со статической длительностью хранения. Сюда входят глобальные объекты данных (как **статические** , так и **Внешние**), локальные статические объекты и статические элементы данных классов. Нельзя объявлять автоматические объекты данных с помощью атрибута **Thread** .

- Необходимо использовать атрибут **Thread** для объявления и определение локального объекта потока, будь то объявление и определение происходят в одном и том же файле или в отдельных файлах.

- Нельзя использовать атрибут **Thread** в качестве модификатора типа.

- Так как объявление объектов, использующих атрибут **Thread** , разрешено, эти два примера семантически эквивалентны:

    ```cpp
    // declspec_thread_2.cpp
    // compile with: /LD
    __declspec( thread ) class B {
    public:
       int data;
    } BObject;   // BObject declared thread local.

    class B2 {
    public:
       int data;
    };
    __declspec( thread ) B2 BObject2;   // BObject2 declared thread local.
    ```

- Стандартный C разрешает инициализацию объекта или переменной с помощью выражения, включающего ссылку на себя, но только для нестатических объектов. Несмотря C++ на то, что обычно разрешает такую динамическую инициализацию объекта с помощью выражения, включающего ссылку на себя, этот тип инициализации не разрешен с локальными объектами потока. Например:

   ```cpp
   // declspec_thread_3.cpp
   // compile with: /LD
   #define Thread __declspec( thread )
   int j = j;   // Okay in C++; C error
   Thread int tls_i = sizeof( tls_i );   // Okay in C and C++
   ```

   Выражение **sizeof** , включающее инициализируемый объект, не является ссылкой на себя и разрешается в C и C++.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также:

[__declspec](../cpp/declspec.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Локальное хранилище потока (TLS)](../parallel/thread-local-storage-tls.md)