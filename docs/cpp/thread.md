---
title: thread
ms.date: 05/07/2019
f1_keywords:
- thread_cpp
helpviewer_keywords:
- thread local storage (TLS)
- thread __declspec keyword
- TLS (thread local storage), compiler implementation
- __declspec keyword [C++], thread
ms.assetid: 667f2a77-6d1f-4b41-bee8-05e67324fab8
ms.openlocfilehash: 59a1af8a7eb73207f84ddf2194d5fe9e77d7d46a
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2019
ms.locfileid: "65221959"
---
# <a name="thread"></a>thread

**Блок, относящийся только к системам Microsoft**

**Поток** модификатор расширенного класса хранения используется для объявления локальной переменной потока. Переносимая эквивалент в C ++ 11 и более поздних версий, используйте [thread_local](../cpp/storage-classes-cpp.md#thread_local) спецификатор класса хранения для переносимого кода. В Windows `thread_local` реализуется с помощью **__declspec(thread)**.

## <a name="syntax"></a>Синтаксис

> **__declspec (thread)** *декларатор*

## <a name="remarks"></a>Примечания

Локальное хранилище потока (TLS) — это механизм, с помощью которого в каждом потоке многопоточного процесса выделяется хранилище для хранения данных определенного потока. В стандартных многопоточных программах данные совместно используются всеми потоками заданного процесса, в то время как локальное хранилище потоков является механизмом предоставления данных для конкретного потока. Полное описание потоков, см. в разделе [многопоточность](../parallel/multithreading-support-for-older-code-visual-cpp.md).

Объявления локальных переменных потока необходимо использовать [расширенный синтаксис атрибутов](../cpp/declspec.md) и **__declspec** ключевого слова with **поток** ключевое слово. В следующем примере кода показано, как объявлять целочисленную локальную переменную потока и инициализировать её некоторым значением:

```cpp
__declspec( thread ) int tls_i = 1;
```

При использовании локальные переменные потока в библиотеках динамической загрузке, необходимо учитывать факторы, которые могут вызвать локальную переменную потока не инициализировать правильно:

1. Если переменная инициализируется с помощью вызова функции (включая конструкторы), эта функция будет вызываться только для потока, который вызвал двоичный файл или DLL для загрузки в процесс, а также для этих потоков, которые запущены после загрузки двоичный файл или DLL. Функции инициализации не вызываются для любого другого потока, в котором уже выполняется при загрузке библиотеки DLL. Динамическая инициализация происходит вызов DllMain DLL_THREAD_ATTACH, но она никогда не получает сообщение, если библиотека DLL не в процессе, при запуске потока.

1. Локальные переменные потока, которые инициализируются с постоянными значениями статически обычно инициализируются должным образом во всех потоках. Тем не менее, начиная с декабря 2017 г. существует проблема известных соответствия в Microsoft C++ компилятора, при котором переменные constexpr получать динамические вместо статической инициализации.

   Примечание. Обе эти проблемы должны быть исправлены в будущем обновления компилятора.

Кроме того необходимо соблюдать эти правила при объявлении локальных объектов потока и переменных:

- Можно применить **поток** атрибут только для класса и объявлениям и определениям данных; **поток** не может использоваться в объявлениях или определениях функций.

- Можно указать **поток** атрибут только для элементов данных со статической длительностью хранения. Сюда входят глобальные объекты данных (оба **статический** и **extern**), локальные статические объекты и статические данные-члены классов. Нельзя объявлять автоматические объекты данных с помощью **поток** атрибута.

- Необходимо использовать **поток** атрибута для объявления и определения локального объекта потока, в объявлении и определении выполняются ли в одном файле или в отдельных файлах.

- Нельзя использовать **поток** атрибут в качестве модификатора типа.

- Так как объявление объектов, которые используют **поток** атрибут разрешен, эти два примера семантически эквивалентны:

    ```cpp
    // declspec_thread_2.cpp
    // compile with: /LD
    __declspec( thread ) class B {
    public:
       int data;
    } BObject;   // BObject declared thread local.

    class B2 {
    public:
       int data;
    };
    __declspec( thread ) B2 BObject2;   // BObject2 declared thread local.
    ```

- В стандартном языке C разрешена инициализация объекта или переменной с помощью выражения, предусматривающего ссылку на себя, но только для объектов нестатической области памяти. Хотя в C++ обычно разрешена такая динамическая инициализация объекта выражениями с ссылкой на себя, такой тип инициализации не допускается в отношении локальных объектов потока. Пример:

   ```cpp
   // declspec_thread_3.cpp
   // compile with: /LD
   #define Thread __declspec( thread )
   int j = j;   // Okay in C++; C error
   Thread int tls_i = sizeof( tls_i );   // Okay in C and C++
   ```

   Обратите внимание, что **sizeof** выражение, включающее инициализируемый объект не является ссылкой на себя и разрешается в C и C++.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[__declspec](../cpp/declspec.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Локальное хранилище потока (TLS)](../parallel/thread-local-storage-tls.md)