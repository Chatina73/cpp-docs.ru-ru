---
title: __thiscall
ms.date: 05/22/2020
f1_keywords:
- __thiscall
- __thiscall_cpp
helpviewer_keywords:
- __thiscall keyword [C++]
ms.assetid: a6a22dd2-0101-4885-b33b-22f6057965df
ms.openlocfilehash: b9edc2cd8caa5fd5458f6a53c5fdb1f8a5e69914
ms.sourcegitcommit: 5bb421fdf61d290cac93a03e16a6a80959accf6d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/26/2020
ms.locfileid: "83854818"
---
# `__thiscall`

Соглашение о вызовах, **характерное для Майкрософт** , **`__thiscall`** используется в функциях-членах классов C++ в архитектуре x86. Это соглашение о вызовах по умолчанию, используемое функциями-членами, которые не используют переменные аргументы ( `vararg` функции).

В разделе **`__thiscall`** вызываемый очищает стек, что невозможно для `vararg` функций. Аргументы помещаются в стек справа налево. **`this`** Указатель передается через Register ECX, а не в стек.

На компьютерах ARM, ARM64 и x64 **`__thiscall`** принимается и игнорируется компилятором. Это обусловлено тем, что в них по умолчанию используется соглашение о вызовах на основе регистров.

Одна из причин использования **`__thiscall`** — в классах, функции-члены которых используют по **`__clrcall`** умолчанию. В этом случае можно использовать, **`__thiscall`** чтобы сделать отдельные функции для членов, вызываемые из машинного кода.

При компиляции с параметром [**`/clr:pure`**](../build/reference/clr-common-language-runtime-compilation.md) все функции и указатели функций задаются, **`__clrcall`** если не указано иное. **`/clr:pure`** **`/clr:safe`** Параметры компилятора и являются устаревшими в visual Studio 2015 и не поддерживаются в visual Studio 2017.

`vararg`функции элементов используют **`__cdecl`** соглашение о вызовах. Все аргументы функции помещаются в стек, и **`this`** указатель помещается в стек последним.

Так как это соглашение о вызове применяется только к C++, оно не имеет схемы декорирования имен C.

При определении нестатический функции-члена класса, которая не является статической, укажите модификатор соглашения о вызове только в объявлении. Его не нужно указывать повторно в определении вне строки. Компилятор использует соглашение о вызовах, указанное во время объявления в точке определения.

## <a name="see-also"></a>Дополнительно

[Передача аргументов и соглашения об именовании](../cpp/argument-passing-and-naming-conventions.md)
