---
title: __thiscall
description: Сведения о соглашении о вызовах __thiscall, специфичных для Майкрософт, для функций-членов классов x86 в Microsoft C++.
ms.date: 05/22/2020
f1_keywords:
- __thiscall
- __thiscall_cpp
helpviewer_keywords:
- __thiscall keyword [C++]
ms.assetid: a6a22dd2-0101-4885-b33b-22f6057965df
ms.openlocfilehash: 9b11dcf8dee928b687f942639ed72ead3659614b
ms.sourcegitcommit: 25f6d52eb9e5d84bd0218c46372db85572af81da
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94448455"
---
# `__thiscall`

Соглашение о вызовах, **характерное для Майкрософт** , **`__thiscall`** используется в функциях-членах классов C++ в архитектуре x86. Это соглашение о вызовах по умолчанию, используемое функциями-членами, которые не используют переменные аргументы ( `vararg` функции).

В разделе **`__thiscall`** вызываемый очищает стек, что невозможно для `vararg` функций. Аргументы помещаются в стек справа налево. **`this`** Указатель передается через Register ECX, а не в стек.

На компьютерах ARM, ARM64 и x64 **`__thiscall`** принимается и игнорируется компилятором. Это обусловлено тем, что в них по умолчанию используется соглашение о вызовах на основе регистров.

Одна из причин использования **`__thiscall`** — в классах, функции-члены которых используют по **`__clrcall`** умолчанию. В этом случае можно использовать, **`__thiscall`** чтобы сделать отдельные функции для членов, вызываемые из машинного кода.

При компиляции с параметром [`/clr:pure`](../build/reference/clr-common-language-runtime-compilation.md) все функции и указатели функций задаются, **`__clrcall`** если не указано иное. **`/clr:pure`** **`/clr:safe`** Параметры компилятора и являются устаревшими в visual Studio 2015 и не поддерживаются в visual Studio 2017.

`vararg` функции элементов используют **`__cdecl`** соглашение о вызовах. Все аргументы функции помещаются в стек, и **`this`** указатель помещается в стек последним.

Так как это соглашение о вызове применяется только к C++, оно не имеет схемы декорирования имен C.

При определении нестатический функции-члена класса, которая не является статической, укажите модификатор соглашения о вызове только в объявлении. Его не нужно указывать повторно в определении вне строки. Компилятор использует соглашение о вызовах, указанное во время объявления в точке определения.

## <a name="see-also"></a>См. также раздел

[Передача аргументов и соглашения об именовании](../cpp/argument-passing-and-naming-conventions.md)
