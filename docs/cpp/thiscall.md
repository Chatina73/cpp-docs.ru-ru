---
title: __thiscall
ms.date: 11/04/2016
f1_keywords:
- __thiscall
- __thiscall_cpp
helpviewer_keywords:
- __thiscall keyword [C++]
ms.assetid: a6a22dd2-0101-4885-b33b-22f6057965df
ms.openlocfilehash: fc5a32fedf52377889b61103856e2125733cd696
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62266793"
---
# <a name="thiscall"></a>__thiscall

**Блок, относящийся только к системам Microsoft**

**__Thiscall** соглашения о вызове используется для функций-членов и соглашение о вызовах по умолчанию C++ функции-члены, которые не используют переменные аргументы. В разделе **__thiscall**, вызываемый объект очищает стек, что невозможно для `vararg` функции. Аргументы помещаются в стек справа налево, с помощью **это** указателя передается через регистр ECX, а не на стеке, x86 архитектуры.

Одна из причин для использования **__thiscall** в классах, чьи функции-члены используйте `__clrcall` по умолчанию. В этом случае можно использовать **__thiscall** чтобы отдельных член функции можно вызывать из машинного кода.

При компиляции с параметром [/CLR: pure](../build/reference/clr-common-language-runtime-compilation.md), все функции и указатели функций являются `__clrcall` Если не указано иное. **/CLR: pure** и **/CLR: safe** параметры компилятора признаны устаревшими в Visual Studio 2015 и не поддерживается в Visual Studio 2017.

В предыдущих выпусках Visual C++ 2005 **__thiscall** соглашение о вызовах нельзя указывать явным образом в программе, поскольку **__thiscall** не являлось ключевым словом.

`vararg` Использование функции-члены **__cdecl** соглашение о вызовах. Все аргументы функции передаются в стеке, с помощью **это** указатель, помещаемый в стек последнего

Поскольку это соглашение о вызовах применяется только к C++, схема оформления имени C отсутствует.

В ARM и x64 машин, **__thiscall** принимается и игнорируется компилятором.

Если используется внестрочное определение нестатической функции класса, то модификатор соглашения о вызовах не должен быть задан во внестрочном определении. То есть для нестатических методов-членов считается, что соглашение о вызовах, указанное во время объявления, было сделано в точке определения.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Передача аргументов и соглашения об именовании](../cpp/argument-passing-and-naming-conventions.md)