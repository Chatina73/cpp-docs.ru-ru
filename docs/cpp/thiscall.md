---
title: __thiscall
ms.date: 11/04/2016
f1_keywords:
- __thiscall
- __thiscall_cpp
helpviewer_keywords:
- __thiscall keyword [C++]
ms.assetid: a6a22dd2-0101-4885-b33b-22f6057965df
ms.openlocfilehash: 8772159dca71bb7605af5e5919425065423d503d
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80188159"
---
# <a name="__thiscall"></a>__thiscall

**Блок, относящийся только к системам Microsoft**

Соглашение о вызовах **__thiscall** используется для функций-членов и является соглашением о вызовах C++ по умолчанию, используемым функциями-членами, которые не используют переменные аргументы. В разделе **__thiscall**вызываемый очищает стек, что невозможно для функций `vararg`. Аргументы передаются в стек справа налево, при **этом** указатель передается через Register ECX, а не в стек на архитектуре x86.

Одна из причин использования **__thiscall** — в классах, функции-члены которых по умолчанию используют `__clrcall`. В этом случае можно использовать **__thiscall** , чтобы отдельные функции элементов могли вызываться из машинного кода.

При компиляции с [параметром/clr: pure](../build/reference/clr-common-language-runtime-compilation.md)все функции и указатели функций `__clrcall`, если не указано иное. Параметры компилятора **/clr: pure** и **/clr: Сейф** являются устаревшими в Visual Studio 2015 и не поддерживаются в Visual Studio 2017.

В выпусках, предшествующих Visual Studio 2005, соглашение о вызовах **__thiscall** не может быть явно указано в программе, поскольку **__thiscall** не является ключевым словом.

`vararg` функции элементов используют соглашение о вызовах **__cdecl** . Все аргументы функции помещаются в стек, и **этот** указатель помещается в стек последним

Поскольку это соглашение о вызовах применяется только к C++, схема оформления имени C отсутствует.

На компьютерах ARM и x64 **__thiscall** принимается и игнорируется компилятором.

Если используется внестрочное определение нестатической функции класса, то модификатор соглашения о вызовах не должен быть задан во внестрочном определении. То есть для нестатических методов-членов считается, что соглашение о вызовах, указанное во время объявления, было сделано в точке определения.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также раздел

[Передача аргументов и соглашения об именовании](../cpp/argument-passing-and-naming-conventions.md)
