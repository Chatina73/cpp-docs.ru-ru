---
title: Добро пожаловать C++ в современныйC++
description: Описание новых идиом программирования в современных C++ и их обоснованиях.
ms.date: 01/10/2020
ms.topic: conceptual
ms.assetid: 1cb1b849-ed9c-4721-a972-fd8f3dab42e2
ms.openlocfilehash: 9630322024e639f9e5db1888dac5a1530befc716
ms.sourcegitcommit: ba129dc55dc3ff638f3af5ac0e87ec2ca1cb2674
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/10/2020
ms.locfileid: "75869725"
---
# <a name="welcome-back-to-c---modern-c"></a>Добро пожаловать C++ в современныйC++

С момента создания C++ он стал одним из самых широко используемых языков программирования в мире. Грамотно сконструированные программы на языках C++ быстры и эффективны. Язык является более гибким по сравнению с другими языками: он может работать с самыми высокими уровнями абстракции и на уровне кристалла. C++предоставляет стандартные библиотеки с высоким уровнем оптимизации. Он обеспечивает доступ к аппаратным функциям низкого уровня, чтобы максимально увеличить скорость и сократить требования к памяти. С C++помощью можно создать широкий спектр приложений. Игры, драйверы устройств и высокопроизводительное научное программное обеспечение. Внедренные программы. Клиентские приложения Windows. Даже библиотеки и компиляторы для других языков программирования пишутся в C++.

Одно из начальных требований для C++ — обратная совместимость с языком C. В результате всегда C++ имеет разрешение на программирование в стиле C, с необработанными указателями, массивами, строками символов, завершающимися нулем, и другими функциями. Они могут обеспечить высокую производительность, но также могут порождать ошибки и сложность. Эволюция C++ имеет функции, которые значительно снижают необходимость использования идиом в стиле C. Старые средства программирования C — там, где это необходимо, но с помощью современного C++ кода они должны быть меньше и меньше. Современный C++ код проще, безопаснее, более элегантно и так же быстро, как и раньше.

В следующих разделах приводятся общие сведения о главных функциях C++современных. Если не указано иное, перечисленные здесь функции доступны в C++ 11 и более поздних версиях. В компиляторе C++ Майкрософт можно задать параметр компилятора [/std](../build/reference/std-specify-language-standard-version.md) , чтобы указать версию стандарта, используемую для проекта.

## <a name="resources-and-smart-pointers"></a>Ресурсы и смарт-указатели

Одним из основных классов ошибок в программировании в стиле C является *утечка памяти*. Утечки часто вызываются сбоем при вызове **Delete** для памяти, выделенной с помощью **New**. Современные C++ акценты на принцип *получения ресурсов — инициализация* (RAII). Идея проста. Ресурсы (память кучи, дескрипторы файлов, сокеты и т. д.) должны *принадлежать* объекту. Этот объект создает и получает новый выделенный ресурс в конструкторе и удаляет его в его деструкторе. Принцип RAII гарантирует, что все ресурсы должным образом возвращаться операционной системе, когда объект-владелец выходит за пределы области.

Для поддержки C++ простого внедрения принципов RAII Стандартная библиотека предоставляет три типа интеллектуальных указателей: [std:: unique_ptr](../standard-library/unique-ptr-class.md), [std:: shared_ptr](../standard-library/shared-ptr-class.md)и [std:: weak_ptr](../standard-library/weak-ptr-class.md). Интеллектуальный указатель обрабатывает выделение и удаление памяти, которую она владеет. В следующем примере показан класс с членом массива, который выделяется в куче в вызове `make_unique()`. Вызовы **New** и **Delete** инкапсулированы классом `unique_ptr`. Когда `widget` объект выходит из области действия, вызывается деструктор unique_ptr и освобождается память, выделенная для массива.  

```cpp
#include <memory>
class widget
{
private:
    std::unique_ptr<int> data;
public:
    widget(const int size) { data = std::make_unique<int>(size); }
    void do_something() {}
};

void functionUsingWidget() {
    widget w(1000000);   // lifetime automatically tied to enclosing scope
                // constructs w, including the w.data gadget member
    // ...
    w.do_something();
    // ...
} // automatic destruction and deallocation for w and w.data

```

По возможности при выделении памяти кучи используйте интеллектуальный указатель. Если необходимо явно использовать операторы new и DELETE, следуйте принципу RAII. Дополнительные сведения см. в разделе [время существования объектов и управление ресурсами (RAII)](object-lifetime-and-resource-management-modern-cpp.md).

## <a name="stdstring-and-stdstring_view"></a>std:: String и std:: string_view

Строки в стиле C — это еще один основной источник ошибок. Используя [std:: String и std:: wstring](../standard-library/basic-string-class.md), можно устранить практически все ошибки, связанные с строками в стиле C. Кроме того, вы получаете преимущества функций членов для поиска, добавления в конец и т. д. Оба они оптимизированы для ускорения. При передаче строки в функцию, для которой требуется только доступ только для чтения, в C++ 17 можно использовать [std:: string_view](../standard-library/basic-string-view-class.md) для еще большего выигрыша в производительности.

## <a name="stdvector-and-other-standard-library-containers"></a>std:: Vector и другие контейнеры стандартной библиотеки

Все контейнеры стандартной библиотеки следуют принципу RAII. Они предоставляют итераторы для безопасного обхода элементов. И они высоко оптимизированы для повышения производительности и тщательно протестированы на правильность. Используя эти контейнеры, можно исключить потенциальные ошибки или неэффективные возможности, которые могут быть представлены в пользовательских структурах данных. Вместо необработанных массивов используйте [vector](../standard-library/vector-class.md) в качестве последовательного контейнера в C++.

```cpp
vector<string> apples;
apples.push_back("Granny Smith");
```

Используйте [Map](../standard-library/map-class.md) (не `unordered_map`) в качестве ассоциативного контейнера по умолчанию. Используйте [Set](../standard-library/set-class.md), [multimap](../standard-library/multimap-class.md)и [мультинабор](../standard-library/multiset-class.md) для вырожденных и множественных вариантов.

```cpp
map<string, string> apple_color;
// ...
apple_color["Granny Smith"] = "Green";
```

При необходимости оптимизации производительности рассмотрите возможность использования следующих средств:

- Тип [массива](../standard-library/array-class-stl.md) при внедрении важен, например, как член класса.

- Неупорядоченные ассоциативные контейнеры, такие как [unordered_map](../standard-library/unordered-map-class.md). Они имеют меньшие издержки на элементы и уточняющие запросы во время поиска, но могут быть труднее и эффективно использовать их.

- Сортировка `vector`. Дополнительные сведения см. в разделе [Алгоритмы](../cpp/algorithms-modern-cpp.md).

Не используйте массивы в стиле языка C. Для более старых API, которым требуется прямой доступ к данным, используйте методы доступа, такие как `f(vec.data(), vec.size());`. Дополнительные сведения о контейнерах см. в разделе [ C++ стандартные библиотечные контейнеры](../standard-library/stl-containers.md).

## <a name="standard-library-algorithms"></a>Стандартные алгоритмы библиотеки

Прежде чем предположить, что необходимо написать собственный алгоритм для программы, сначала проверьте C++ [алгоритмы](../standard-library/algorithm.md)стандартной библиотеки. Стандартная библиотека содержит постоянно увеличивающийся ассортимент алгоритмов для многих распространенных операций, таких как поиск, сортировка, фильтрация и случайное использование. Математическая библиотека обширна. Начиная с C++ 17 предоставляются параллельные версии многих алгоритмов.

Ниже приведены некоторые важные примеры.

- **for_each**, алгоритм обхода по умолчанию (наряду с циклами for на основе диапазона).

- **Преобразование**для неразмещенного изменения элементов контейнера

- **find_if**, алгоритм поиска по умолчанию.

- **Сортировка**, **lower_bound**и другие алгоритмы сортировки и поиска по умолчанию.

Чтобы написать оператор сравнения, используйте строгие **<** и используйте *именованные лямбда-выражения* , если это возможно.

```cpp
auto comp = [](const widget& w1, const widget& w2)
     { return w1.weight() < w2.weight(); }

sort( v.begin(), v.end(), comp );

auto i = lower_bound( v.begin(), v.end(), comp );
```

## <a name="auto-instead-of-explicit-type-names"></a>Auto вместо явных имен типов

В c++ 11 введено ключевое слово [Auto](auto-cpp.md) для использования в объявлениях переменных, функций и шаблонов. **Auto** указывает компилятору вывести тип объекта, чтобы не вводить его явным образом. **функция Auto** особенно полезна, если выведенный тип является вложенным шаблоном:

```cpp
map<int,list<string>>::iterator i = m.begin(); // C-style
auto i = m.begin(); // modern C++
```

## <a name="range-based-for-loops"></a>Циклы for на основе диапазона

Итерация в стиле C для массивов и контейнеров может потребовать ошибок индексирования, а также утомительной для ввода. Чтобы устранить эти ошибки и сделать код более удобочитаемым, используйте циклы for на основе диапазона с контейнерами стандартной библиотеки и необработанными массивами. Дополнительные сведения см. в разделе [оператор на основе диапазона for](../cpp/range-based-for-statement-cpp.md).

```cpp
#include <iostream>
#include <vector>

int main()
{
    std::vector<int> v {1,2,3};

    // C-style
    for(int i = 0; i < v.size(); ++i)
    {
        std::cout << v[i];
    }

    // Modern C++:
    for(auto& num : v)
    {
        std::cout << num;
    }
}
```

## <a name="constexpr-expressions-instead-of-macros"></a>выражения constexpr вместо макросов

Макросы в языке C++ C и являются токенами, которые обрабатываются препроцессором перед компиляцией. Перед компиляцией файла каждый экземпляр токена макроса заменяется определенным значением или выражением. Макросы обычно используются в программировании в стиле C для определения значений констант времени компиляции. Однако макросы подвержены ошибкам и сложно отлаживать. В современных C++случаях переменные [constexpr](constexpr-cpp.md) следует предпочитать для констант времени компиляции:

```cpp
#define SIZE 10 / C-style
constexpr int size = 10; // modern C++
```

### <a name="uniform-initialization"></a>Однородная инициализация

В современном C++случае можно использовать инициализацию фигурных скобок для любого типа. Такая форма инициализации особенно удобна при инициализации массивов, векторов или других контейнеров. В следующем примере `v2` инициализируется тремя экземплярами `S`. `v3` инициализируется тремя экземплярами `S`, которые сами по себе инициализируются с помощью фигурных скобок. Компилятор выводит тип каждого элемента на основе объявленного типа `v3`.

```cpp
#include <vector>

struct S
{
    std::string name;
    float num;
    S(std::string s, float f) : name(s), num(f) {}
};

int main()
{
    // C-style initialization
    std::vector<S> v;
    S s1("Norah", 2.7);
    S s2("Frank", 3.5);
    S s3("Jeri", 85.9);

    v.push_back(s1);
    v.push_back(s2);
    v.push_back(s3);

    // Modern C++:
    std::vector<S> v2 {s1, s2, s3};

    // or...
    std::vector<S> v3{ {"Norah", 2.7}, {"Frank", 3.5}, {"Jeri", 85.9} };

}
```

Дополнительные сведения см. в разделе [Инициализация фигурных скобок](initializing-classes-and-structs-without-constructors-cpp.md).

## <a name="move-semantics"></a>Семантика перемещения

Современный C++ обеспечивает *семантику перемещения*, что позволяет устранять ненужные копии памяти. В более ранних версиях языка копирование в определенных ситуациях было не так. Операция *перемещения* передает владение ресурсу из одного объекта в другой без создания копии. При реализации класса, владеющего ресурсом (например, памятью кучи, дескрипторами файлов и т. д.), можно определить *конструктор перемещения* и *оператор присваивания перемещения* для него. Компилятор выберет эти специальные элементы во время разрешения перегрузки в ситуациях, когда копирование не требуется. Типы контейнеров стандартной библиотеки вызывают конструктор перемещения для объектов, если он определен. Дополнительные сведения см. в разделе [конструкторы перемещения и операторы присваиванияC++перемещения ()](move-constructors-and-move-assignment-operators-cpp.md).

## <a name="lambda-expressions"></a>Лямбда-выражения

В программировании в стиле C функцию можно передать в другую функцию с помощью *указателя функции*. Указатели функций неудобно поддерживать и понимать. Функция, на которую они ссылаются, может быть определена в любом месте исходного кода, далеко от точки, в которой он вызывается. Кроме того, они не являются строго типизированными. Современный C++ класс предоставляет *объекты функций*, классы, переопределяющие оператор [()](function-call-operator-parens.md) , который позволяет вызывать их как функцию. Наиболее удобный способ создания объектов функций — встроенные [лямбда-выражения](../cpp/lambda-expressions-in-cpp.md). В следующем примере показано, как использовать лямбда-выражение для передачи объекта функции, что функция `for_each` будет вызываться для каждого элемента в векторе:

```cpp
    std::vector<int> v {1,2,3,4,5};
    int x = 2;
    int y = 4;
    auto result = find_if(begin(v), end(v), [=](int i) { return i > x && i < y; });
```

Лямбда-выражение `[=](int i) { return i > x && i < y; }` можно считать функцией, которая принимает один аргумент типа `int` и возвращает логическое значение, указывающее, больше ли аргумент, чем `x` и меньше `y`». Обратите внимание, что переменные `x` и `y` из окружающего контекста можно использовать в лямбда-выражении. `[=]` указывает, что эти переменные *фиксируются* по значению; Иными словами, лямбда-выражение имеет собственные копии этих значений.

## <a name="exceptions"></a>Исключения

Современные C++ акценты на исключениях, а не на кодах ошибок, как лучший способ сообщить об ошибке и обменять их. Дополнительные сведения см. в [статье C++ современные рекомендации по исключениям и обработке ошибок](errors-and-exception-handling-modern-cpp.md).

## <a name="stdatomic"></a>std:: Atomic

Используйте C++ стандартную библиотеку [std:: Atomic](../standard-library/atomic-structure.md) и связанные типы для механизмов взаимодействия между потоками.

## <a name="stdvariant-c17"></a>std:: Variant (C++ 17)

Объединения обычно используются в программировании в стиле C для экономии памяти, позволяя членам разных типов занимать одно и то же расположение в памяти. Однако объединения не являются строго типизированными и могут быть подвержены ошибкам программирования. В c++ 17 появился класс [std:: Variant](../standard-library/variant-class.md) в качестве более надежной и надежной альтернативы объединениям. Функцию [std:: Visit](../standard-library/variant-functions.md#visit) можно использовать для доступа к членам типа `variant` строго типизированным способом.

## <a name="see-also"></a>См. также:

[Справочник по языку C++](../cpp/cpp-language-reference.md)\
[Лямбда-выражения](../cpp/lambda-expressions-in-cpp.md)\
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)\
[Таблица соответствия Microsoft Visual C++ стандартам языка](../overview/visual-cpp-language-conformance.md)
