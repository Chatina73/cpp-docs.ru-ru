---
title: Добро пожаловать обратно в СЗ - Современный СЗ
description: Описывает новые идиомы программирования в современном СЗ и их обоснование.
ms.date: 01/10/2020
ms.topic: conceptual
ms.assetid: 1cb1b849-ed9c-4721-a972-fd8f3dab42e2
ms.openlocfilehash: 7d0fcb623162713b845107bbf00669af7ae5ca98
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81369494"
---
# <a name="welcome-back-to-c---modern-c"></a>Добро пожаловать обратно в СЗ - Современный СЗ

С момента своего создания, СЗ стал одним из наиболее широко используемых языков программирования в мире. Грамотно сконструированные программы на языках C++ быстры и эффективны. Язык более гибок, чем другие языки: он может работать на самом высоком уровне абстракции, и вниз на уровне кремния. СЗ поставляет высоко оптимизированные стандартные библиотеки. Это позволяет получить доступ к низкоуровневым аппаратным функциям, чтобы максимизировать скорость и свести к минимуму требования к памяти. С помощью СЗ можно создавать широкий спектр приложений. Игры, драйверы устройств и высокопроизводительное научное программное обеспечение. Встроенные программы. Клиентские приложения Windows. Даже библиотеки и компиляторы для других языков программирования пишутся на си-з.

Одно из начальных требований для C++ — обратная совместимость с языком C. В результате, СЗ всегда разрешал программирование c-стиля с необработанными указателями, массивами, нулевыми строками символов и другими функциями. Они могут обеспечить большую производительность, но также могут породить ошибки и сложность. Эволюция СЗ подчеркнулособенности, которые значительно уменьшают необходимость использования идиом С-стиль. Старые C-программирования объектов есть, когда вы в них нуждается, но с современным кодом СЗ вы должны нуждаться в них все меньше и меньше. Современный код СЗ проще, безопаснее, элегантнее и по-прежнему так же быстро, как никогда.

Следующие разделы дают обзор основных особенностей современного СЗ. Если не указано иное, функции, перечисленные здесь, доступны в C-11 и позже. В компиляторе Microsoft C's можно настроить опцию компилятора [/std,](../build/reference/std-specify-language-standard-version.md) чтобы указать, какую версию стандарта использовать для вашего проекта.

## <a name="resources-and-smart-pointers"></a>Ресурсы и интеллектуальные указатели

Одним из основных классов ошибок в C-стиле программирования является *утечка памяти.* Утечки часто вызваны неспособностью вызвать **удаление** для памяти, которая была выделена с **новым**. Современный СЗЗ подчеркивает принцип *приобретения ресурсов является инициализация* (RAII). Идея проста. Ресурсы (кучи памяти, ручки файлов, розетки и так далее) должны *принадлежать* объекту. Этот объект создает или получает вновь выделенный ресурс в своем конструкторе и удаляет его в своем деструктора. Принцип RAII гарантирует, что все ресурсы должным образом возвращаются в операционную систему, когда объект-владелец выходит за рамки.

Для поддержки простого принятия принципов RAII, Стандартная библиотека СЗ предоставляет три интеллектуальных типа указателей: [std:::unique_ptr,](../standard-library/unique-ptr-class.md) [std::shared_ptr](../standard-library/shared-ptr-class.md), и [std::weak_ptr](../standard-library/weak-ptr-class.md). Интеллектуальная указка обрабатывает распределение и удаление памяти, которой она владеет. В следующем примере показан класс с элементом массива, который `make_unique()`выделяется на куче в вызове. Вызовы к **новым** и **удаленным** `unique_ptr` инкапсулируются классом. Когда `widget` объект выходит за рамки, unique_ptr деструктор будет вызываться и он выпустит память, которая была выделена для массива.  

```cpp
#include <memory>
class widget
{
private:
    std::unique_ptr<int> data;
public:
    widget(const int size) { data = std::make_unique<int>(size); }
    void do_something() {}
};

void functionUsingWidget() {
    widget w(1000000);   // lifetime automatically tied to enclosing scope
                // constructs w, including the w.data gadget member
    // ...
    w.do_something();
    // ...
} // automatic destruction and deallocation for w and w.data

```

Когда это возможно, используйте смарт-указатель при распределении кучи памяти. Если вы должны использовать новые и удалить операторов явно, следуйте принципу RAII. Для получения дополнительной [Object lifetime and resource management (RAII)](object-lifetime-and-resource-management-modern-cpp.md)информации см.

## <a name="stdstring-and-stdstring_view"></a>std::строка и std::string_view

Строки C-стиля являются еще одним основным источником ошибок. С помощью [std::string и std::wstring,](../standard-library/basic-string-class.md)вы можете устранить практически все ошибки, связанные со строками C-стиля. Вы также получаете преимущества функций членов для поиска, добавления, предпосылки и так далее. Оба они сильно оптимизированы для скорости. При передаче строки к функции, которая требует только для чтения доступа, в C-17 вы можете использовать [std::string_view](../standard-library/basic-string-view-class.md) для еще большей производительности выгоды.

## <a name="stdvector-and-other-standard-library-containers"></a>std:вектора и других контейнеров Стандартной библиотеки

Контейнеры Стандартной Библиотеки все следуют принципу RAII. Они обеспечивают итераторы для безопасного обхода элементов. И, они сильно оптимизированы для производительности и были тщательно протестированы на правильность. Используя эти контейнеры, вы устраняете возможность ошибок или неэффективности, которые могут быть введены в пользовательские структуры данных. Вместо необработанных массивов используйте [вектор](../standard-library/vector-class.md) в качестве последовательного контейнера в СЗ.

```cpp
vector<string> apples;
apples.push_back("Granny Smith");
```

Используйте [карту](../standard-library/map-class.md) (не) `unordered_map`в качестве ассоциативного контейнера по умолчанию. Используйте [набор,](../standard-library/set-class.md) [мультикарта](../standard-library/multimap-class.md)и [мультисет](../standard-library/multiset-class.md) для дегенеративных и нескольких случаев.

```cpp
map<string, string> apple_color;
// ...
apple_color["Granny Smith"] = "Green";
```

При необходимости оптимизации производительности следует использовать:

- Тип [массива](../standard-library/array-class-stl.md) при встраивании важен, например, как член класса.

- Неупорядоченные ассоциативные контейнеры, такие как [unordered_map](../standard-library/unordered-map-class.md). Они имеют более низкие накладные расходы за элемент и постоянный поиск времени, но они могут быть более трудными в использовании правильно и эффективно.

- Сортировка `vector`. Дополнительные сведения см. в разделе [Алгоритмы](../cpp/algorithms-modern-cpp.md).

Не используйте массивы C-стиля. Для старых AAP, которые нуждаются в прямом доступе `f(vec.data(), vec.size());` к данным, используйте методы доступа, такие как вместо этого. Для получения более подробной [C++ Standard Library Containers](../standard-library/stl-containers.md)информации о контейнерах, см.

## <a name="standard-library-algorithms"></a>Алгоритмы стандартной библиотеки

Прежде чем предположить, что вам нужно написать пользовательский алгоритм для вашей программы, сначала просмотрите алгоритмы Стандартной [библиотеки](../standard-library/algorithm.md)СЗ. Стандартная библиотека содержит постоянно растущий ассортимент алгоритмов для многих распространенных операций, таких как поиск, сортировка, фильтрация и рандомизация. Библиотека математики обширна. Начиная с C-17, предоставляются параллельные версии многих алгоритмов.

Вот несколько важных примеров:

- **for_each**алгоритм обхода по умолчанию (наряду с диапазоном для циклов).

- **преобразование,** для не-на-место модификации контейнерных элементов

- **find_if**, алгоритм поиска по умолчанию.

- **сортировать,** **lower_bound,** и другие алгоритмы сортировки и поиска по умолчанию.

Чтобы написать компаратор, **<** используйте строгий и использовать *имени lambdas,* когда вы можете.

```cpp
auto comp = [](const widget& w1, const widget& w2)
     { return w1.weight() < w2.weight(); }

sort( v.begin(), v.end(), comp );

auto i = lower_bound( v.begin(), v.end(), comp );
```

## <a name="auto-instead-of-explicit-type-names"></a>авто вместо явных имен типов

С-11 ввел [автоматическое](auto-cpp.md) ключевое слово для использования в переменных, функциональных и шаблонных декларациях. **auto** говорит компилятору вывести тип объекта так, чтобы вам не пришлось вводить его явно. **авто** особенно полезно, когда выведенный тип является вложенным шаблоном:

```cpp
map<int,list<string>>::iterator i = m.begin(); // C-style
auto i = m.begin(); // modern C++
```

## <a name="range-based-for-loops"></a>Диапазон на основе циклов

Итерация C-стиля над массивами и контейнерами подвержена ошибкам индексирования, а также утомительна для ввода. Чтобы устранить эти ошибки и сделать код более читаемым, используйте диапазон для циклов как с контейнерами Standard Library, так и с необработанными массивами. Для получения дополнительной информации, [см.](../cpp/range-based-for-statement-cpp.md)

```cpp
#include <iostream>
#include <vector>

int main()
{
    std::vector<int> v {1,2,3};

    // C-style
    for(int i = 0; i < v.size(); ++i)
    {
        std::cout << v[i];
    }

    // Modern C++:
    for(auto& num : v)
    {
        std::cout << num;
    }
}
```

## <a name="constexpr-expressions-instead-of-macros"></a>выражения constexpr вместо макросов

Макросы в C и СЗ являются токенами, которые обрабатываются препроцессором перед компиляцией. Каждый экземпляр маркера макроса заменяется его определенным значением или выражением перед компиляцией файла. Макрос обычно используется в C-стиле программирования для определения компиляции времени постоянных значений. Тем не менее, макросы подвержены ошибкам и трудно отладить. В современных [консилиумах](constexpr-cpp.md) следует предпочесть переменные constexpr для констант-времени компиляции:

```cpp
#define SIZE 10 // C-style
constexpr int size = 10; // modern C++
```

### <a name="uniform-initialization"></a>Единая инициализация

В современном СЗ можно использовать инициализацию скобки для любого типа. Эта форма инициализации особенно удобна при инициализации массивов, векторов или других контейнеров. В следующем примере `v2` инициализированы `S`с тремя экземплярами . `v3`инициализирована с `S` тремя экземплярами, которые сами инициализированы с помощью скобки. Компилятор выносит вывод о типе каждого `v3`элемента на основе заявленного типа .

```cpp
#include <vector>

struct S
{
    std::string name;
    float num;
    S(std::string s, float f) : name(s), num(f) {}
};

int main()
{
    // C-style initialization
    std::vector<S> v;
    S s1("Norah", 2.7);
    S s2("Frank", 3.5);
    S s3("Jeri", 85.9);

    v.push_back(s1);
    v.push_back(s2);
    v.push_back(s3);

    // Modern C++:
    std::vector<S> v2 {s1, s2, s3};

    // or...
    std::vector<S> v3{ {"Norah", 2.7}, {"Frank", 3.5}, {"Jeri", 85.9} };

}
```

Для получения дополнительной [Brace initialization](initializing-classes-and-structs-without-constructors-cpp.md)информации см.

## <a name="move-semantics"></a>Перемещение семантики

Современная СЗ обеспечивает *семантику перемещения,* которая позволяет устранить ненужные копии памяти. В более ранних версиях языка копии неизбежны в определенных ситуациях. Операция *перемещения* передает право собственности на ресурс с одного объекта на другой без создания копии. При реализации класса, владеющего ресурсом (например, кучей памяти, обработки файлов и т.д.), можно определить *конструктор атакжем и* *переместить оператора назначения* для него. Компилятор выберет эти специальные члены во время разрешения перегрузок в ситуациях, когда копия не нужна. Типы контейнеров Стандартной библиотеки ссылаются на конструктор движения на объекты, если он определен. Для получения дополнительной информации [см.](move-constructors-and-move-assignment-operators-cpp.md)

## <a name="lambda-expressions"></a>Лямбда-выражения

В Программировании c-стиля функция может быть передана другой функции с помощью *указателя функции.* Функционные указатели неудобны для поддержания и понимания. Функция, на которую они ссылаются, может быть определена в другом месте исходного кода, далеко от точки, в которой он вызывается. Кроме того, они не безопасны для типов. Современный СЗ обеспечивает *функциональные объекты,* классы, которые переопределяют [()](function-call-operator-parens.md) оператора, что позволяет называть их как функцию. Самый удобный способ создания функциональных объектов – это внеочередные [выражения лямбды.](../cpp/lambda-expressions-in-cpp.md) В следующем примере показано, как использовать выражение лямбда `for_each` для передачи объекта функции, что функция будет вызывать на каждый элемент в векторе:

```cpp
    std::vector<int> v {1,2,3,4,5};
    int x = 2;
    int y = 4;
    auto result = find_if(begin(v), end(v), [=](int i) { return i > x && i < y; });
```

Выражение `[=](int i) { return i > x && i < y; }` лямбда может быть прочитана как "функция, которая принимает один аргумент типа `int` и `x` возвращает `y`boolean, который указывает, является ли аргумент больше, чем и меньше, чем ." Обратите внимание, `x` что `y` переменные и из окружающего контекста могут быть использованы в lambda. Указывается, `[=]` что эти переменные *фиксируются* значением; другими словами, выражение лямбда имеет свои собственные копии этих ценностей.

## <a name="exceptions"></a>Исключения

Современная СЗ подчеркивает исключения, а не коды ошибок, как лучший способ отчета и обработки условий ошибки. Для получения дополнительной информации [см.](errors-and-exception-handling-modern-cpp.md)

## <a name="stdatomic"></a>std:атомная

Используйте std Стандартной библиотеки C's [Standard Library::atomic](../standard-library/atomic-structure.md) struct и связанные с ними типы для межпоточной коммуникационной связи.

## <a name="stdvariant-c17"></a>std::вариант (СЗ17)

Соединения обычно используются в C-стиле программирования для сохранения памяти, позволяя членам различных типов занимать одно и то же место памяти. Однако профсоюзы не защищены от типов и подвержены ошибкам программирования. В качестве более надежной и безопасной альтернативы профсоюзам класс [Std::variant](../standard-library/variant-class.md) представляет собой более надежную и безопасную альтернативу. [Функция std::visit](../standard-library/variant-functions.md#visit) может использоваться для доступа `variant` к членам типа безопасным способом.

## <a name="see-also"></a>См. также раздел

[Языковая справка к СЗ](../cpp/cpp-language-reference.md)\
[Ламбда Выражения](../cpp/lambda-expressions-in-cpp.md)\
[Стандартная библиотека СЗ](../standard-library/cpp-standard-library-reference.md)\
[Таблица соответствия Microsoft Visual C++ стандартам языка](../overview/visual-cpp-language-conformance.md)
