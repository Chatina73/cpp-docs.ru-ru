---
title: Добро пожаловать в C++ — современный C++
description: Описание новых идиом программирования в современных C++ и их обоснования.
ms.date: 05/17/2020
ms.topic: conceptual
ms.assetid: 1cb1b849-ed9c-4721-a972-fd8f3dab42e2
ms.openlocfilehash: 76ac17e71368cdeee669b98505778838ef0dfee7
ms.sourcegitcommit: d4da3693f83a24f840e320e35c24a4a07cae68e2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/18/2020
ms.locfileid: "83550801"
---
# <a name="welcome-back-to-c---modern-c"></a>Добро пожаловать в C++ — современный C++

С момента его создания C++ стал одним из самых широко используемых языков программирования в мире. Грамотно сконструированные программы на языках C++ быстры и эффективны. Язык является более гибким по сравнению с другими языками: он может работать с самыми высокими уровнями абстракции и на уровне кристалла. C++ предоставляет высокооптимизированные стандартные библиотеки. Он обеспечивает доступ к аппаратным функциям низкого уровня, чтобы максимально увеличить скорость и сократить требования к памяти. С помощью C++ можно создать широкий спектр приложений. Игры, драйверы устройств и высокопроизводительное научное программное обеспечение. Внедренные программы. Клиентские приложения Windows. Даже библиотеки и компиляторы для других языков программирования пишутся на C++.

Одно из начальных требований для C++ — обратная совместимость с языком C. В результате в C++ всегда было разрешено программирование в стиле C с необработанными указателями, массивами, строками символов, завершающимися нулем, и другими функциями. Они могут обеспечить высокую производительность, но также могут порождать ошибки и сложность. Эволюция C++ имеет выделеные функции, которые значительно снижают необходимость использования идиом в стиле C. Старые средства программирования C — там, где это необходимо, но с помощью современного кода C++ они должны быть меньше и меньше. Современный код C++ проще, безопаснее, более элегантно и так же быстро, как и раньше.

В следующих разделах приводятся общие сведения о главных функциях современного C++. Если не указано иное, перечисленные здесь функции доступны в C++ 11 и более поздних версиях. В компиляторе Microsoft C++ можно задать [`/std`](../build/reference/std-specify-language-standard-version.md) параметр компилятора, чтобы указать версию стандарта, используемую для проекта.

## <a name="resources-and-smart-pointers"></a>Ресурсы и смарт-указатели

Одним из основных классов ошибок в программировании в стиле C является *утечка памяти*. Утечки часто вызываются сбоем при вызове **`delete`** памяти, выделенной с помощью **`new`** . Современный C++ подчеркивает принцип *получения ресурсов — инициализация* (RAII). Идея проста. Ресурсы (память кучи, дескрипторы файлов, сокеты и т. д.) должны *принадлежать* объекту. Этот объект создает и получает новый выделенный ресурс в конструкторе и удаляет его в его деструкторе. Принцип RAII гарантирует, что все ресурсы должным образом возвращаться операционной системе, когда объект-владелец выходит за пределы области.

Для поддержки простого внедрения принципов RAII Стандартная библиотека C++ предоставляет три типа интеллектуальных указателей: [`std::unique_ptr`](../standard-library/unique-ptr-class.md) , [`std::shared_ptr`](../standard-library/shared-ptr-class.md) и [`std::weak_ptr`](../standard-library/weak-ptr-class.md) . Интеллектуальный указатель обрабатывает выделение и удаление памяти, которую она владеет. В следующем примере показан класс с членом массива, который выделяется в куче в вызове `make_unique()` . Вызовы функций **`new`** и **`delete`** инкапсулированы `unique_ptr` классом. Когда `widget` объект выходит из области действия, будет вызван деструктор unique_ptr и освобождена память, выделенная для массива.  

```cpp
#include <memory>
class widget
{
private:
    std::unique_ptr<int> data;
public:
    widget(const int size) { data = std::make_unique<int>(size); }
    void do_something() {}
};

void functionUsingWidget() {
    widget w(1000000);   // lifetime automatically tied to enclosing scope
                // constructs w, including the w.data gadget member
    // ...
    w.do_something();
    // ...
} // automatic destruction and deallocation for w and w.data

```

По возможности при выделении памяти кучи используйте интеллектуальный указатель. Если необходимо явно использовать операторы new и DELETE, следуйте принципу RAII. Дополнительные сведения см. в разделе [время существования объектов и управление ресурсами (RAII)](object-lifetime-and-resource-management-modern-cpp.md).

## <a name="stdstring-and-stdstring_view"></a>`std::string` и `std::string_view`

Строки в стиле C — это еще один основной источник ошибок. С помощью [ `std::string` и `std::wstring` ](../standard-library/basic-string-class.md)можно устранить практически все ошибки, связанные со строками в стиле C. Кроме того, вы получаете преимущества функций членов для поиска, добавления в конец и т. д. Оба они оптимизированы для ускорения. При передаче строки в функцию, для которой требуется только доступ только для чтения, в C++ 17 можно использовать [`std::string_view`](../standard-library/basic-string-view-class.md) для еще большего выигрыша в производительности.

## <a name="stdvector-and-other-standard-library-containers"></a>`std::vector`и другие контейнеры стандартной библиотеки

Все контейнеры стандартной библиотеки следуют принципу RAII. Они предоставляют итераторы для безопасного обхода элементов. И они высоко оптимизированы для повышения производительности и тщательно протестированы на правильность. Используя эти контейнеры, можно исключить потенциальные ошибки или неэффективные возможности, которые могут быть представлены в пользовательских структурах данных. Вместо необработанных массивов используйте в [`vector`](../standard-library/vector-class.md) C++ как последовательный контейнер.

```cpp
vector<string> apples;
apples.push_back("Granny Smith");
```

Используйте [`map`](../standard-library/map-class.md) (Not `unordered_map` ) в качестве ассоциативного контейнера по умолчанию. Используйте [`set`](../standard-library/set-class.md) , [`multimap`](../standard-library/multimap-class.md) и [`multiset`](../standard-library/multiset-class.md) для создания и нескольких вариантов.

```cpp
map<string, string> apple_color;
// ...
apple_color["Granny Smith"] = "Green";
```

При необходимости оптимизации производительности рассмотрите возможность использования следующих средств:

- [`array`](../standard-library/array-class-stl.md)Тип при внедрении важен, например, как член класса.

- Неупорядоченные ассоциативные контейнеры, такие как [`unordered_map`](../standard-library/unordered-map-class.md) . Они имеют меньшие издержки на элементы и уточняющие запросы во время поиска, но могут быть труднее и эффективно использовать их.

- Отсортировано `vector` . Дополнительные сведения см. в разделе [Алгоритмы](../cpp/algorithms-modern-cpp.md).

Не используйте массивы в стиле языка C. Для более старых API, которым требуется прямой доступ к данным, используйте методы доступа, такие как `f(vec.data(), vec.size());` . Дополнительные сведения о контейнерах см. в разделе [контейнеры стандартной библиотеки C++](../standard-library/stl-containers.md).

## <a name="standard-library-algorithms"></a>Стандартные алгоритмы библиотеки

Прежде чем предположить, что необходимо написать собственный алгоритм для программы, сначала проверьте [алгоритмы](../standard-library/algorithm.md)стандартной библиотеки C++. Стандартная библиотека содержит постоянно увеличивающийся ассортимент алгоритмов для многих распространенных операций, таких как поиск, сортировка, фильтрация и случайное использование. Математическая библиотека обширна. Начиная с C++ 17 предоставляются параллельные версии многих алгоритмов.

Ниже приведены некоторые важные примеры.

- `for_each`, алгоритм обхода по умолчанию (вместе с циклами на основе диапазона `for` ).

- `transform`, для изменения элементов контейнера "не на месте"

- `find_if`, алгоритм поиска по умолчанию.

- `sort`, `lower_bound` и других алгоритмов сортировки и поиска по умолчанию.

Чтобы написать оператор сравнения, используйте строгие **`<`** и используйте *именованные лямбда-выражения* , если это возможно.

```cpp
auto comp = [](const widget& w1, const widget& w2)
     { return w1.weight() < w2.weight(); }

sort( v.begin(), v.end(), comp );

auto i = lower_bound( v.begin(), v.end(), comp );
```

## <a name="auto-instead-of-explicit-type-names"></a>`auto`вместо явных имен типов

В c++ 11 введено [`auto`](auto-cpp.md) ключевое слово для использования в объявлениях переменных, функций и шаблонов. **`auto`** Указывает компилятору вывести тип объекта, чтобы не вводить его явным образом. **`auto`** особенно полезен, если выведенный тип является вложенным шаблоном:

```cpp
map<int,list<string>>::iterator i = m.begin(); // C-style
auto i = m.begin(); // modern C++
```

## <a name="range-based-for-loops"></a>Циклы на основе диапазона `for`

Итерация в стиле C для массивов и контейнеров может потребовать ошибок индексирования, а также утомительной для ввода. Чтобы устранить эти ошибки и сделать код более удобочитаемым, используйте циклы на основе диапазона `for` с контейнерами стандартной библиотеки и необработанными массивами. Дополнительные сведения см. в разделе [ `for` инструкция на основе диапазона](../cpp/range-based-for-statement-cpp.md).

```cpp
#include <iostream>
#include <vector>

int main()
{
    std::vector<int> v {1,2,3};

    // C-style
    for(int i = 0; i < v.size(); ++i)
    {
        std::cout << v[i];
    }

    // Modern C++:
    for(auto& num : v)
    {
        std::cout << num;
    }
}
```

## <a name="constexpr-expressions-instead-of-macros"></a>`constexpr`выражения вместо макросов

Макросы в C и C++ — это токены, которые обрабатываются препроцессором перед компиляцией. Перед компиляцией файла каждый экземпляр токена макроса заменяется определенным значением или выражением. Макросы обычно используются в программировании в стиле C для определения значений констант времени компиляции. Однако макросы подвержены ошибкам и сложно отлаживать. В современных C++ предпочтительно использовать [`constexpr`](constexpr-cpp.md) переменные для констант времени компиляции:

```cpp
#define SIZE 10 // C-style
constexpr int size = 10; // modern C++
```

### <a name="uniform-initialization"></a>Однородная инициализация

В современных C++ можно использовать инициализацию фигурных скобок для любого типа. Такая форма инициализации особенно удобна при инициализации массивов, векторов или других контейнеров. В следующем примере `v2` инициализируется тремя экземплярами `S` . `v3`инициализируется тремя экземплярами `S` , которые сами по себе инициализируются с помощью фигурных скобок. Компилятор выводит тип каждого элемента на основе объявленного типа `v3` .

```cpp
#include <vector>

struct S
{
    std::string name;
    float num;
    S(std::string s, float f) : name(s), num(f) {}
};

int main()
{
    // C-style initialization
    std::vector<S> v;
    S s1("Norah", 2.7);
    S s2("Frank", 3.5);
    S s3("Jeri", 85.9);

    v.push_back(s1);
    v.push_back(s2);
    v.push_back(s3);

    // Modern C++:
    std::vector<S> v2 {s1, s2, s3};

    // or...
    std::vector<S> v3{ {"Norah", 2.7}, {"Frank", 3.5}, {"Jeri", 85.9} };

}
```

Дополнительные сведения см. в разделе [Инициализация фигурных скобок](initializing-classes-and-structs-without-constructors-cpp.md).

## <a name="move-semantics"></a>Семантика перемещения

Современный C++ обеспечивает *семантику перемещения*, что позволяет устранять ненужные копии памяти. В более ранних версиях языка копирование в определенных ситуациях было не так. Операция *перемещения* передает владение ресурсу из одного объекта в другой без создания копии. Некоторые классы являются собственными ресурсами, такими как память кучи, дескрипторы файлов и т. д. При реализации класса, владеющего ресурсами, можно определить *конструктор перемещения* и *оператор присваивания перемещения* для него. Компилятор выбирает эти специальные элементы при разрешении перегрузки в ситуациях, когда копирование не требуется. Типы контейнеров стандартной библиотеки вызывают конструктор перемещения для объектов, если он определен. Дополнительные сведения см. в разделе [конструкторы перемещения и операторы присваивания перемещения (C++)](move-constructors-and-move-assignment-operators-cpp.md).

## <a name="lambda-expressions"></a>Лямбда-выражения

В программировании в стиле C функцию можно передать в другую функцию с помощью *указателя функции*. Указатели функций неудобно поддерживать и понимать. Функция, на которую они ссылаются, может быть определена в любом месте исходного кода, далеко от точки, в которой он вызывается. Кроме того, они не являются строго типизированными. Современный C++ предоставляет *объекты функций*, классы, переопределяющие [`operator()`](function-call-operator-parens.md) оператор, который позволяет вызывать их как функцию. Наиболее удобный способ создания объектов функций — встроенные [лямбда-выражения](../cpp/lambda-expressions-in-cpp.md). В следующем примере показано, как использовать лямбда-выражение для передачи объекта функции, которое `for_each` будет вызываться функцией для каждого элемента в векторе:

```cpp
    std::vector<int> v {1,2,3,4,5};
    int x = 2;
    int y = 4;
    auto result = find_if(begin(v), end(v), [=](int i) { return i > x && i < y; });
```

Лямбда-выражение `[=](int i) { return i > x && i < y; }` можно считать функцией, которая принимает один аргумент типа `int` и возвращает логическое значение, указывающее, является ли аргумент больше `x` и меньше `y` . Обратите внимание, что переменные `x` и `y` из окружающего контекста можно использовать в лямбда-выражении. `[=]`Указывает, что эти переменные *фиксируются* по значению; иными словами, лямбда-выражение имеет собственные копии этих значений.

## <a name="exceptions"></a>Исключения

Современный C++ подчеркивает исключения, а не коды ошибок, как лучший способ сообщить об ошибке и обработать их. Дополнительные сведения см. в статье [современные рекомендации по C++ для исключений и обработки ошибок](errors-and-exception-handling-modern-cpp.md).

## `std::atomic`

Используйте структуру стандартной библиотеки C++ [`std::atomic`](../standard-library/atomic-structure.md) и связанные типы для механизмов взаимодействия между потоками.

## <a name="stdvariant-c17"></a>`std::variant`(C++ 17)

Объединения обычно используются в программировании в стиле C для экономии памяти, позволяя членам разных типов занимать одно и то же расположение в памяти. Однако объединения не являются строго типизированными и могут быть подвержены ошибкам программирования. C++ 17 представляет [`std::variant`](../standard-library/variant-class.md) класс в качестве более надежной и надежной альтернативы объединениям. [`std::visit`](../standard-library/variant-functions.md#visit)Функция может использоваться для доступа к членам типа строго типизированным `variant` способом.

## <a name="see-also"></a>См. также раздел

[Справочник по языку C++](../cpp/cpp-language-reference.md)\
[Лямбда-выражения](../cpp/lambda-expressions-in-cpp.md)\
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)\
[Таблица соответствия Microsoft Visual C++ стандартам языка](../overview/visual-cpp-language-conformance.md)
