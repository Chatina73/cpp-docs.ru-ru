---
title: Тривиальный, стандартная раскладка POD и типы литералов
ms.date: 04/05/2018
ms.assetid: 2b23a7be-9bad-49fc-8298-31a9a7c556b0
ms.openlocfilehash: c742f4c84a1b2ba558b790d7eea7760902da7818
ms.sourcegitcommit: afd6fac7c519dbc47a4befaece14a919d4e0a8a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2018
ms.locfileid: "51521709"
---
# <a name="trivial-standard-layout-pod-and-literal-types"></a>Тривиальный, стандартная раскладка POD и типы литералов

Термин *макета* ссылается на расположение членам объекта класса, структуры или тип объединения в памяти. В некоторых случаях макет четко определенных в спецификации языка. Но если класс или структура содержит определенные функции языка C++, такие как виртуальные базовые классы, виртуальные функции, члены с элементом управления доступом, то компилятор может выбрать макет. Этот макет может отличаться в зависимости от того, какие оптимизации выполняются и во многих случаях объекта могут быть не даже заняты непрерывный блок памяти. Например если класс имеет виртуальные функции, все экземпляры этого класса могут иметь общие таблицу одной виртуальной функции. Такие типы очень полезны, само собой, но они также имеют ограничения. Поскольку макет не определено они не могут быть переданы программ, написанных на других языках, таких как C, и поскольку они могут ввести несмежных их нельзя скопировать надежно с fast низкоуровневые функции например `memcopy` или сериализации по сети.

Чтобы включить компиляторов и программ на языке C++ и metaprograms делать выводы о пригодности любого заданного типа для операций, зависящих от макета конкретного памяти, C ++ 14 представила три категории простых классов и структур: *тривиальные*, *стандартная раскладка*, и *POD* или обычные старые данные. Стандартная библиотека содержит шаблоны функций `is_trivial<T>`, `is_standard_layout<T>` и `is_pod<T>` , определить, принадлежит ли заданный тип данной категории.

## <a name="trivial-types"></a>Тривиальные типы

Если класс или структура в C++ имеет предоставляемые компилятором или явно установленные по умолчанию специальные функции-члены, то он является тривиальным. В области непрерывной памяти, занимаемой им. Он может иметь члены с описателями различные права доступа. В C++ компилятор может выбрать способ упорядочить элементы в этой ситуации. Таким образом вы можете memcopy таких объектов, но не может надежно использовать их из программы на языке C. Тривиальные типа T можно скопировать в массив char или char без знака и безопасно копируется обратно в переменную T. Обратите внимание на то, что из-за требований к выравниванию, может существовать байтов заполнения между членов типа.

Тривиальные типы имеют тривиальный конструктор по умолчанию, тривиальный конструктор копии, тривиальный оператор присваивания копии и тривиальный деструктор. В каждом случае *тривиальные* означает, что конструктор или оператор/деструктор не является пользовательским и принадлежит к классу, который имеет

- Нет виртуальных функций или виртуальных базовых классов

- отсутствие базовых классов с помощью соответствующего нетривиальный конструктор или оператор/деструктор

- Нет данных-членов типа класса с помощью соответствующего нетривиальный конструктор или оператор/деструктор

Ниже приведены примеры тривиальным типам. В Trivial2, наличие `Trivial2(int a, int b)` конструктора необходимо указать конструктор по умолчанию. Для типа, чтобы считаться тривиальным необходимо явным образом по умолчанию этот конструктор.

```cpp
struct Trivial
{
      int i;
private:
   int j;
   };

struct Trivial2
{
   int i;
   Trivial2(int a, int b) : i(a), j(b) {}
   Trivial2() = default;
   private:
   int j;   // Different access control
};
```

## <a name="standard-layout-types"></a>Типы стандартных макета

Если класс или структура не содержит определенные функции языка C++, такие как виртуальные функции, которые не находятся на языке C, а все члены имеют один и тот же элемент управления доступом, это стандартная раскладка тип. Он может memcopy и макета достаточно определен, он может использоваться в программ на языке C. Стандартная раскладка типы могут иметь определяемые пользователем специальные функции-члены. Кроме того стандартный макет типы имеют следующие характеристики:

- Нет виртуальных функций или виртуальных базовых классов

- все нестатические данные-члены имеют один и тот же элемент управления доступом

- стандартная раскладка все нестатические члены типа класса

- стандартная раскладка базовых классов

- имеет того же типа как первый элемент нестатических данных без базовых классов.

- соответствует одно из следующих условий:

  - нет нестатических данных члена в классе самого дальнего и не более чем одного базового класса, с нестатическими данными-членами, или

  - имеет без базовых классов с нестатическими данными-членами

Ниже показан пример типа стандартная раскладка:

```cpp
struct SL
{
   // All members have same access:
   int i;
   int j;
   SL(int a, int b) : i(a), j(b) {} // User-defined constructor OK
};
```

Последние два требования можно возможно лучше проиллюстрировать на примере кода. В следующем примере, даже если Base стандартная раскладка `Derived` не является стандартным макетом, так как она (наиболее производный класс) и `Base` имеют нестатические данные-члены:

```cpp
struct Base
{
   int i;
   int j;
};

// std::is_standard_layout<<Derived> == false!
struct Derived : public Base
{
   int x;
   int y;
};
```

В этом примере `Derived` — стандартная раскладка поскольку `Base` нет нестатических данных-членов:

```cpp
struct Base
{
   void Foo() {}
};

// std::is_standard_layout<<Derived> == true
struct Derived : public Base
{
   int x;
   int y;
};
```

Производным также будет стандартная раскладка Если `Base` бы элементы данных и `Derived` имели только функции-члены.

## <a name="pod-types"></a>Типы POD

Если класс или структура является тривиальным и стандартная раскладка, это тип POD (обычные старые данные). Распределение памяти для типы POD упорядочено таким образом, и каждый элемент имеет старших адресов, чем элемент, который был объявлен до нее, таким образом, чтобы байтовое копирует и двоичного ввода-вывода могут выполняться с этими типами.  Скалярные типы, такие как int также являются типами POD. Типы POD, которые являются классами может содержать только типы POD нестатических данных.

## <a name="example"></a>Пример

В следующем примере показано различия между тривиальный, стандартная раскладка и типы POD:

```cpp
#include <type_traits>
#include <iostream>

using namespace std;

struct B
{
protected:
   virtual void Foo() {}
};

// Neither trivial nor standard-layout
struct A : B
{
      int a;
   int b;
   void Foo() override {} // Virtual function
};

// Trivial but not standard-layout
struct C
   {
      int a;
private:
   int b;   // Different access control
};

// Standard-layout but not trivial
struct D
{
   int a;
   int b;
   D() {} //User-defined constructor
};

struct POD
{
   int a;
   int b;
};

int main()
{
   cout << boolalpha;
   cout << "A is trivial is " << is_trivial<A>() << endl; // false
   cout << "A is standard-layout is " << is_standard_layout<A>() << endl;  // false

   cout << "C is trivial is " << is_trivial<C>() << endl; // true
   cout << "C is standard-layout is " << is_standard_layout<C>() << endl;  // false

   cout << "D is trivial is " << is_trivial<D>() << endl;  // false
   cout << "D is standard-layout is " << is_standard_layout<D>() << endl; // true

   cout << "POD is trivial is " << is_trivial<POD>() << endl; // true
   cout << "POD is standard-layout is " << is_standard_layout<POD>() << endl; // true

   return 0;
}
```

## <a name="literal_types"></a> Типы литералов

Тип литерала — это такой тип, макет которого может быть определен во время компиляции. Ниже указаны типы литералов.

- void
- скалярные типы
- ссылки
- Массивы void, скалярных типов или ссылок
- Класс, имеющий тривиальный деструктор, а также один или несколько конструкторов constexpr, которые не являются конструкторами перемещений или копий. Кроме того, все его нестатические данные-члены и базовые классы должны быть типами литералов и не должны изменяться.

## <a name="see-also"></a>См. также

[Основные понятия](../cpp/basic-concepts-cpp.md)