---
title: volatile (C++)
ms.date: 05/07/2019
f1_keywords:
- volatile_cpp
helpviewer_keywords:
- interrupt handlers and volatile keyword [C++]
- volatile keyword [C++]
- volatile objects
- objects [C++], volatile
ms.assetid: 81db4a85-ed5a-4a2c-9a53-5d07a771d2de
ms.openlocfilehash: 2396b5afaed09a28fd83f22fccde0be04e3d7790
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2019
ms.locfileid: "65221873"
---
# <a name="volatile-c"></a>volatile (C++)

Квалификатор типа, который используется для объявления о том, что объект может быть изменен в программе аппаратным обеспечением.

## <a name="syntax"></a>Синтаксис

```
volatile declarator ;
```

## <a name="remarks"></a>Примечания

Можно использовать параметр компилятора [/volatile](../build/reference/volatile-volatile-keyword-interpretation.md) для изменения интерпретации этого ключевого слова компилятором.

Visual Studio интерпретирует ключевое слово **volatile** по-разному в зависимости от целевой архитектуры. Для ARM, если параметр компилятора **/volatile** не указан, компилятор действует так, как будто был указан **/volatile:iso**. Для архитектур, отличных от ARM, если параметр компилятора **/volatile** не указан, компилятор действует так, как будто был указан **/volatile:ms**; таким образом, для архитектур, отличных от ARM, мы настоятельно рекомендуем указать **/volatile:iso** и использовать явные примитивы синхронизации и встроенные функции компилятора при работе с памятью, разделяемой между потоками.

Можно использовать квалификатор **volatile** для предоставления доступа к областям памяти, которые используются асинхронными процессами, например обработчиками прерываний.

Когда **volatile** используется с переменной, которая также имеет ключевое слово [__restrict](../cpp/extension-restrict.md), **volatile** имеет более высокий приоритет.

Если член **struct** помечен как **volatile**, то **volatile** распространяется на всю структуру. Если длина структура такова, что она не может быть скопирована в текущей архитектуре с помощью одной инструкции, **volatile** может быть полностью утерян для этой структуры.

Ключевое слово **volatile** может не оказывать воздействия на поле, если выполняется одно из следующих условий:

- Длина поля с ключевым словом volatile превышает максимальный размер, который в текущей архитектуре может быть скопирован с помощью одной инструкции.

- Длина самой внешней **struct** (или, возможно, структуры в составе вложенной **struct**) превышает максимальный размер, который может быть скопирован в текущей архитектуре с помощью одной инструкции.

Несмотря на то, что процессор не меняет порядок некэшируемых обращений к памяти, некэшируемые переменные должны быть помечены как **volatile**, чтобы гарантировать, что компилятор не изменит порядок обращений к памяти.

Объекты, объявленные как **volatile**, не используются в некоторых способах оптимизации, поскольку их значения можно изменить в любое время.  При запросе объекта с ключевым словом volatile система всегда считывает его текущее значение, даже если оно запрашивалось в предшествовавшей инструкции.  Кроме того, значение объекта записывается непосредственно при присваивании.

## <a name="iso-compliant"></a>Блок, относящийся к стандарту ISO

Если вы знакомы с C# volatile-ключевое слово, или знакомы с поведением **volatile** в более ранних версиях Microsoft C++ компилятор (MSVC), имейте в виду, C ++ 11 стандарте ISO **volatile** ключевое слово отличается и поддерживается в MSVC при [/volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md) указан параметр компилятора. (Для архитектуры ARM он установлен по умолчанию). **Volatile** ключевого слова в C ++ 11 стандарта ISO кода будет использоваться только для аппаратного доступа; не используйте его для взаимодействия между потоками. Для взаимодействия между потоками, используют механизмы, например [std::atomic\<T >](../standard-library/atomic.md) из [стандартной библиотеки C++](../standard-library/cpp-standard-library-reference.md).

## <a name="end-of-iso-compliant"></a>Конец блока, относящегося к стандарту ISO

## <a name="microsoft-specific"></a>Блок, относящийся только к системам Microsoft

Когда используется параметр компилятора **/volatile:ms** (по умолчанию для целевых архитектур, отличных от ARM), компилятор создает дополнительный код для сохранения порядка между ссылками к объектам volatile наряду с сохранением порядка ссылок на другие глобальные объекты. В частности:

- Запись в объект с ключевым словом volatile (т. н. "запись в изменяемый объект") имеет семантику освобождения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций перед записью в объект с ключевым словом volatile, в скомпилированном двоичном файле будет находиться до записи в изменяемый объект.

- Считывание из объекта с ключевым словом volatile (т. н. "считывание из изменяемого объекта") имеет семантику получения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций после считывания из объекта с ключевым словом volatile, в скомпилированном двоичном файле будет находиться после считывания из изменяемого объекта.

Благодаря этому объекты с ключевым словом volatile могут использоваться для блокировки и освобождения памяти в многопоточных приложениях.

> [!NOTE]
>  Код, который зависит от повышенных гарантий, предоставляемых при использовании параметра компилятора **/volatile:ms**, является непереносимым.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[const](../cpp/const-cpp.md)<br/>
[Указатели с ключевыми словами const и volatile](../cpp/const-and-volatile-pointers.md)