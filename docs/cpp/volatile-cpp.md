---
title: volatile (C++)
ms.date: 05/07/2019
f1_keywords:
- volatile_cpp
helpviewer_keywords:
- interrupt handlers and volatile keyword [C++]
- volatile keyword [C++]
- volatile objects
- objects [C++], volatile
ms.assetid: 81db4a85-ed5a-4a2c-9a53-5d07a771d2de
ms.openlocfilehash: 841b2e1e4ffbec87a170c45be8ad0cd0f831a0ef
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81371898"
---
# <a name="volatile-c"></a>volatile (C++)

Квалификатор типа, который используется для объявления о том, что объект может быть изменен в программе аппаратным обеспечением.

## <a name="syntax"></a>Синтаксис

```
volatile declarator ;
```

## <a name="remarks"></a>Remarks

Вы можете использовать комбинец компилятор [/volatile,](../build/reference/volatile-volatile-keyword-interpretation.md) чтобы изменить способ интерпретации этого ключевого слова компилятора.

Visual Studio интерпретирует **нестабильное** ключевое слово по-разному в зависимости от целевой архитектуры. Для ARM, если нет **/летучих** компилятор вариант указан, компилятор выполняет, как если бы **/летучие:iso** были указаны. Для архитектур, кроме ARM, если не указан опция **компилятора,летучая,** компилятор выполняет так, как если **бы /volatile:ms** были указаны; Поэтому для архитектур, кроме ARM, мы настоятельно рекомендуем указать **/volatile:iso**и использовать явные примитивы синхронизации и внутреннозависимости компилятора, когда вы имеете дело с памятью, которая передается между потоками.

Можно использовать **летучий** квалификатор для обеспечения доступа к местоположению памяти, которые используются асинхронными процессами, такими как обработчики прерываний.

Когда **летучие** используется на переменной, которая также имеет [__restrict](../cpp/extension-restrict.md) ключевое слово, **летучие** имеет приоритет.

Если участник **структуры** помечен как **летучий,** то **летучие** распространяется на всю структуру. Если структура не имеет длины, которую можно скопировать на текущую архитектуру с помощью одной инструкции, **летучая** может быть полностью потеряна на этой структуре.

**Нестабильное** ключевое слово может не повлиять на поле, если одно из следующих условий верно:

- Длина поля с ключевым словом volatile превышает максимальный размер, который в текущей архитектуре может быть скопирован с помощью одной инструкции.

- Длина внешней, содержащей **структуру,** или если она является членом возможно вложенного **структуры,** превышает максимальный размер, который можно скопировать на текущую архитектуру с помощью одной инструкции.

Хотя процессор не переназначит некэшируемые доступы к памяти, некэшируемые переменные должны быть помечены как **летучие,** чтобы гарантировать, что компилятор не переупорядокирует доступ к памяти.

Объекты, объявленные **летучими,** не используются в определенных оптимизациях, поскольку их значения могут меняться в любое время.  При запросе объекта с ключевым словом volatile система всегда считывает его текущее значение, даже если оно запрашивалось в предшествовавшей инструкции.  Кроме того, значение объекта записывается непосредственно при присваивании.


## <a name="iso-compliant"></a>Блок, относящийся к стандарту ISO

Если вы знакомы с нестабильным ключевым словом c, или знакомы с поведением **летучих** в более ранних версиях компилятора Microsoft C »(MSVC), имейте в виду, что **нестабильное** ключевое слово Стандарта СЗ11 ISO отличается и поддерживается в MSVC, когда указан опция компилятора [/volatile:iso.](../build/reference/volatile-volatile-keyword-interpretation.md) (Для архитектуры ARM он установлен по умолчанию). **Нестабильное** ключевое слово в стандартном коде СЗ11 ISO должно использоваться только для доступа к аппаратному обеспечению; не используйте его для межпоточной связи. Для межпоточной коммуникации используйте такие механизмы, как [std::atomic\<T>](../standard-library/atomic.md) из [Стандартной библиотеки СЗ.](../standard-library/cpp-standard-library-reference.md)

## <a name="end-of-iso-compliant"></a>Конец блока, относящегося к стандарту ISO

**Microsoft Специфический**

Когда используется опция компилятора **/volatile:ms** по умолчанию, когда области, не относящиеся к ARM, нацелены на компилятор, компилятор генерирует дополнительный код для поддержания заказа среди ссылок на нестабильные объекты в дополнение к поддержанию заказа на ссылки на другие глобальные объекты. В частности:

- Запись в объект с ключевым словом volatile (т. н. "запись в изменяемый объект") имеет семантику освобождения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций перед записью в объект с ключевым словом volatile, в скомпилированном двоичном файле будет находиться до записи в изменяемый объект.

- Считывание из объекта с ключевым словом volatile (т. н. "считывание из изменяемого объекта") имеет семантику получения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций после считывания из объекта с ключевым словом volatile, в скомпилированном двоичном файле будет находиться после считывания из изменяемого объекта.

Благодаря этому объекты с ключевым словом volatile могут использоваться для блокировки и освобождения памяти в многопоточных приложениях.

> [!NOTE]
> Когда он полагается на расширенную гарантию, которая предоставляется при использовании опции компилятора **/volatile:ms,** код не является портативным.

**END Microsoft Специфический**

## <a name="see-also"></a>См. также раздел

[Keywords](../cpp/keywords-cpp.md)<br/>
[const](../cpp/const-cpp.md)<br/>
[конст и летучих указателей](../cpp/const-and-volatile-pointers.md)
