---
title: Единицы преобразования и компоновкаC++()
ms.date: 12/11/2019
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
ms.openlocfilehash: dcd66b454da3758996fe827581fe4a73a641407f
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75301357"
---
# <a name="translation-units-and-linkage"></a>Единицы и компоновка преобразований

В C++ программе *символ*, например имя переменной или функции, может быть объявлен как любое количество раз в области, но его можно определить только один раз. Это правило является "одним правилом определения" (С операционными данными). *Объявление* вводит (или повторно вводит) имя в программу. *Определение* вводит имя. Если имя представляет переменную, определение явно инициализирует его. *Определение функции* состоит из сигнатуры и тела функции. Определение класса состоит из имени класса, за которым следует блок, в котором перечислены все члены класса. (При необходимости можно отдельно определить тела функций-членов в другом файле.)

В следующем примере показаны некоторые объявления:

```cpp
int i;
int f(int x);
class C;
```

В следующем примере показаны некоторые определения:

```cpp
int i{42};
int f(int x){ return x * i; }
class C {
public:
   void DoSomething();
};
```

Программа состоит из одного или нескольких *единиц трансляции*. Блок преобразования состоит из файла реализации и всех заголовков, которые он включает прямо или косвенно. Файлы реализации обычно имеют расширение *cpp* или *CXX*. Файлы заголовков обычно имеют расширение *h* или *HPP*. Каждая единица преобразования компилируется независимо компилятором. После завершения компиляции компоновщик объединяет скомпилированные блоки преобразования в одну *программу*. Нарушения правила С операционными данными обычно отображаются как ошибки компоновщика. Ошибки компоновщика возникают, когда одно и то же имя имеет два разных определения в разных единицах преобразования.

Как правило, лучшим способом сделать переменную видимой в нескольких файлах является помещение ее в файл заголовка. Затем добавьте директиву #include в каждый файл *cpp* , для которого требуется объявление. *Добавляя* к содержимому заголовка, вы гарантируете, что объявляемые имена определяются только один раз.

В C++ 20 [модули](modules-cpp.md) представлены в качестве улучшенной альтернативы файлам заголовков.

В некоторых случаях может потребоваться объявить глобальную переменную или класс в *cpp* -файле. В таких случаях необходим способ сообщить компилятору и компоновщику, какой тип *компоновки* имеет имя. Тип компоновки определяет, применяется ли имя объекта только к одному файлу или ко всем файлам. Понятие компоновки применяется только к глобальным именам. Понятие компоновки не применяется к именам, объявленным в области. Область определяется набором заключенных фигурных скобок, например в определениях функций или классов.

## <a name="external-vs-internal-linkage"></a>Внешняя и внутренняя компоновка

*Бесплатная функция* — это функция, определенная в глобальной области видимости или область пространства имен. Неконстантные глобальные переменные и свободные функции по умолчанию имеют *внешнюю компоновку*; они видимы из любой записи преобразования в программе. Поэтому ни один из других глобальных объектов не может иметь это имя. Символ с *внутренней компоновкой* или *без компоновки* отображается только в пределах блока преобразования, в котором он объявлен. Если имя имеет внутреннюю компоновку, то такое же имя может существовать в другой записи преобразования. Переменные, объявленные с определениями классов или тела функций, не имеют компоновки.

Можно принудительно включить внутреннюю компоновку в глобальное имя, явно объявляя ее как **статическую**. Это ограничивает видимость той же блока преобразования, в котором он объявлен. В этом контексте **статическое** значение означает, что что-то отличается от применения к локальным переменным.

По умолчанию для следующих объектов используется внутренняя компоновка.
- константные объекты
- объекты constexpr
- определения типов
- статические объекты в области видимости пространства имен

Чтобы присвоить объекту Const объект External компоновки, объявите его как **внешний** и присвойте ему значение:

```cpp
extern const int value = 42;
```

Дополнительные сведения см. в разделе [extern](extern-cpp.md) .

## <a name="see-also"></a>См. также:

[Основные понятия](../cpp/basic-concepts-cpp.md)