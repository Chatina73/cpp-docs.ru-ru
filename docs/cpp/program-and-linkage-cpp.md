---
title: Единицы перевода и связующее звено (КЗ)
ms.date: 12/11/2019
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
ms.openlocfilehash: 791ec53d4df863b218db463f2b9b9401bf6f466d
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81374318"
---
# <a name="translation-units-and-linkage"></a>Единицы трансляции и компоновка

В программе СЗ *символ,* например переменная или имя функции, может быть объявлен любым количеством раз в пределах своей области, но он может быть определен только один раз. Это правило является "Правилом единого определения" (ODR). *Декларация* вводит (или повторно вводит) имя в программу. *Определение* вводит имя. Если имя представляет собой переменную, определение явно инициализирует его. *Определение функции* состоит из подписи плюс тело функции. Определение класса состоит из имени класса, за которым следует блок, в который перечислены все члены класса. (Органы функций членов могут дополнительно определяться отдельно в другом файле.)

Следующий пример показывает некоторые заявления:

```cpp
int i;
int f(int x);
class C;
```

Следующий пример показывает некоторые определения:

```cpp
int i{42};
int f(int x){ return x * i; }
class C {
public:
   void DoSomething();
};
```

Программа состоит из одного или нескольких *единиц перевода.* Подразделение перевода состоит из файла реализации и всех заголовков, которые она включает прямо или косвенно. Файлы реализации обычно имеют расширение файла *cpp* или *cxx.* Файлы заголовка обычно имеют расширение *h* или *hpp.* Каждая единица перевода составляется независимо компилятором. После завершения компиляции связующее звено объединяет собранные единицы перевода в единую *программу.* Нарушения правила ODR обычно отображаются как ошибки связующим звеном. Ошибки linker возникают, когда одно и то же имя имеет два разных определения в разных единицах перевода.

Как правило, лучший способ сделать переменную видимой в нескольких файлах — поместить ее в файл заголовка. Затем добавьте директиву #include в каждый файл *cpp,* который требует декларации. Добавляя *охранники* вокруг содержимого заголовка, вы гарантируете, что имена, которые он объявляет, определяются только один раз.

В C-20 [модули](modules-cpp.md) вводятся в качестве улучшенной альтернативы файлам заголовков.

В некоторых случаях может потребоваться объявить глобальную переменную или класс в файле *cpp.* В этих случаях вам нужен способ сообщить компилятору и связующим, какая *связь* имеет имя. Тип увязки определяет, применяется ли имя объекта только к одному файлу или ко всем файлам. Концепция увязки применяется только к глобальным названиям. Понятие увязки не распространяется на имена, которые декларируются в рамках определенной сферы. Область определяется набором прилагающих фигурных скобки, например, в определениях функции или класса.

## <a name="external-vs-internal-linkage"></a>Внешняя и внутренняя связь

*Свободная функция* — это функция, которая определяется в глобальном пространстве или области имен. Нестандартные глобальные переменные и свободные функции по умолчанию имеют *внешнюю связь;* они видны из любой единицы перевода в программе. Таким образом, ни один другой глобальный объект не может иметь это имя. Символ с *внутренней связью* или *отсутствием связи* виден только в блоке перевода, в котором он заявлен. Когда имя имеет внутреннюю связь, то же имя может существовать в другой единице перевода. Переменные, объявленные с определением классов или функциональными органами, не имеют связи.

Вы можете заставить глобальное имя иметь внутреннюю связь, явно объявив его **статическим.** Это ограничивает его видимость той же единицей перевода, в которой она объявлена. В этом контексте **статика означает** нечто иное, чем при применении к локальным переменным.

Следующие объекты имеют внутреннюю связь по умолчанию:

- конст объектов
- объекты constexpr
- определения типов
- статических объектов в области пространства имен

Чтобы придать объекту внешней связи, объявите его в качестве **экстерна** и присвоите ему значение:

```cpp
extern const int value = 42;
```

Дополнительную информацию можно узнать на примере [extern.](extern-cpp.md)

## <a name="see-also"></a>См. также раздел

[Основные концепции](../cpp/basic-concepts-cpp.md)
