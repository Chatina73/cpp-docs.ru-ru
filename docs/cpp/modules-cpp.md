---
title: Обзор модулей в C++
ms.date: 12/13/2019
helpviewer_keywords:
- modules [C++]
- modules [C++], overview
description: Модули в C-20 обеспечивают современную альтернативу файлам заголовков.
ms.openlocfilehash: cd45be1dee888c8caeb65b7ff002ac8fee1ecbe1
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81370761"
---
# <a name="overview-of-modules-in-c"></a>Обзор модулей в C++

СЗ20 представляет *модули*, современное решение для компонентизации библиотек и программ СЗ. Модуль представляет собой набор файлов исходного кода, которые компилируются независимо от [единиц перевода,](https://wikipedia.org/wiki/Translation_unit_(programming)) которые их импортируют. Модули устраняют или значительно уменьшают многие проблемы, связанные с использованием файлов заголовков, а также потенциально сокращают время компиляции. Макросы, предпроцессорные директивы и неэкспортируемые имена, заявленные в модуле, не видны и поэтому не влияют на компиляцию единицы перевода, импортируемой модулем. Вы можете импортировать модули в любом порядке, не заботясь о макроопределениях. Объявления в импортирующем переводическом подразделении не участвуют в разрешении перегрузок или поиске имен в импортируемом модуле. После того, как модуль компилируется один раз, результаты хранятся в двоичном файле, который описывает все экспортированные типы, функции и шаблоны. Этот файл может обрабатываться гораздо быстрее, чем файл заголовка, и может быть повторно использован компилятором в каждом месте, где модуль импортируется в проекте.

Модули могут использоваться бок о бок с файлами заголовка. Исходный файл СЗ может импортировать модули, а также #include файлы заголовка. В некоторых случаях файл заголовка может быть импортирован в качестве модуля, а не текстуально #included препроцессором. Мы рекомендуем, чтобы новые проекты использовали модули, а не файлы заголовков как можно больше. Для более крупных существующих проектов, находящихся в стадии активной разработки, мы предлагаем поэкспериментировать с преобразованием устаревших заголовков в модули, чтобы увидеть, получите ли вы существенное сокращение времени компиляции.

## <a name="enable-modules-in-the-microsoft-c-compiler"></a>Включить модули в компиляторе Microsoft C

По состоянию на Visual Studio 2019 версии 16.2, модули не полностью реализованы в компиляторе Microsoft C . Функцию модулей можно использовать для создания модулей с одной разделами и импорта модулей Стандартной библиотеки, предоставляемых корпорацией Майкрософт. Для обеспечения поддержки модулей, компилировать с [/экспериментальным:модулем](../build/reference/experimental-module.md) и [/std: c](../build/reference/std-specify-language-standard-version.md) В проекте Visual Studio нажмите правой кнопкой мыши на узло проекта в **Solution Explorer** и выберите **Свойства.** Установите падение **конфигурации** на **все конфигурации,** а затем выберите **Настройка Свойства** > **C / СЗ** > **Язык** > **Включить C - Модули (экспериментальный)**.

Модуль и используемый код должны быть компилированы с теми же вариантами компилятора.

## <a name="consume-the-c-standard-library-as-modules"></a>Потребляйте Стандартную библиотеку СЗ в качестве модулей

Несмотря на то, что стандарт СЗ20 не указан, корпорация Майкрософт позволяет импортировать в качестве модулей стандартную библиотеку СЗ. Импортируя стандартную библиотеку СЗ в качестве модулей, а не #including ее через файлы заголовков, вы можете потенциально ускорить время компиляции в зависимости от размера проекта. Библиотека компонентизирована в следующих модулях:

- std.regex предоставляет содержание \<заголовка regex>
- std.filesystem предоставляет содержимое \<файловой системы заголовка>
- std.memory обеспечивает содержание памяти заголовка \<>
- std.threading предоставляет содержимое \<атомных \<> заголовков, condition_variable>, \<будущих>, \<> mutex, \<shared_mutex> и \<> потоков
- std.core предоставляет все остальное в Стандартной библиотеке СЗ

Чтобы использовать эти модули, просто добавьте объявление об импорте в верхнюю часть файла исходного кода. Пример:

```cpp
import std.core;
import std.regex;
```

Чтобы использовать модуль Microsoft Standard Library, составить программу с [помощью /EHsc](../build/reference/eh-exception-handling-model.md) и [/MD-опций.](../build/reference/md-mt-ld-use-run-time-library.md)

## <a name="basic-example"></a>Простой пример

В следующем примере показано простое определение модуля в исходном файле под названием **Foo.ixx**. Расширение **.ixx** требуется для файлов интерфейса модуля в Visual Studio. В этом примере файл интерфейса содержит определение функции, а также декларацию. Тем не менее, определения могут быть также помещены в один или несколько отдельных файлов (как показано в более позднем примере). **Заявление экспортного модуля Foo** указывает, что этот `Foo`файл является основным интерфейсом для модуля под названием . **Экспортный** модификатор указывает, `f()` что `Foo` эта функция будет видна при импорте другой программой или модулем. Обратите внимание, что модуль `Bar`ссылается на пространство имен.

```cpp
export module Foo;

#define ANSWER 42

namespace Bar
{
   int f_internal() {
        return ANSWER;
      }

   export int f() {
      return f_internal();
   }
}
```

Файл **MyProgram.cpp** использует **импортную** декларацию для доступа `Foo`к имени, экспортируемому . Обратите внимание, `Bar` что имя видно здесь, но не все его члены. Также обратите внимание, что макрос `ANSWER` не виден.

```cpp

import Foo;
import std.core;

using namespace std;

int main()
{
   cout << "The result of f() is " << Bar::f() << endl; // 42
   // int i = Bar::f_internal(); // C2039
   // int j = ANSWER; //C2065
}

```

Декларация импорта может отображаться только в глобальном масштабе.

## <a name="implementing-modules"></a>Внедрение модулей

Можно создать модуль с единым файлом интерфейса (.ixx), который экспортирует имена и включает в себя реализации всех функций и типов. Можно также поместить реализации в один или несколько отдельных файлов реализации, подобно тому, как используются файлы .h и .cpp. Ключевое слово **экспорта** используется только в файле интерфейса. Файл реализации может **импортировать** другой модуль, но не может **экспортировать** имена. Файлы реализации могут быть названы с любым расширением. Файл интерфейса и набор файлов реализации, которые его обратно рассматриваются как специальный вид блока перевода называется *модуль единицы*. Имя, заявленное в любом файле реализации, автоматически отображается во всех других файлах в одном и том же блоке модуля.

Для больших модулей можно разделить модуль на несколько модульных блоков, называемых *разделами.* Каждая разделная часть состоит из файла интерфейса, поддерживаемого одним или более файлами реализации. (По состоянию на Visual Studio 2019 версия 16.2, разделы еще не полностью реализованы.)

## <a name="modules-namespaces-and-argument-dependent-lookup"></a>Модули, пространства имен и аргументозависимый поиск

Правила для именных пространств в модулях такие же, как и в любом другом коде. Если декларация в пространстве имен экспортируется, прилагаемое пространство имен (за исключением неэкспортированных членов) также неявно экспортируется. Если пространство имен явно экспортируется, все декларации в определении этого пространства имен экспортируются.

При выполнении аргументозависимого поиска разрешений перегрузки в единице перевода импорта компилятор рассматривает функции, заявленные в той же единице перевода (включая интерфейсы модулей), как место, где определяется тип аргументов функции.

### <a name="module-partitions"></a>Модульные перегородки

> [!NOTE]
> Этот раздел предусмотрен для полноты. Разделы еще не реализованы в компиляторе Microsoft C.

Модуль может быть компонентирован в *разделы,* каждый из которых состоит из файла интерфейса и нулевой или более файлов реализации. Раздел модуля аналогичен модулю, за исключением того, что он разделяет право собственности на все декларации во всем модуле. Все имена, экспортируемые файлами интерфейса раздела, импортируются и реэкспортируются основным файлом интерфейса. Название раздела должно начинаться с имени модуля, за которым следует толстая кишка. Объявления в любом из разделов видны во всем модуле. Никаких специальных мер предосторожности не требуется, чтобы избежать ошибок одного определения правила (ODR). Имя (функция, класс и т.д.) можно объявить в одном разделе и определить его в другом. Файл реализации раздела начинается следующим образом:

```cpp
module Foo:part1
```

и файл интерфейса раздела начинается следующим образом:

```cpp
export module Foo:part1
```

Чтобы получить доступ к декларациям в другой части, раздел должен импортировать его, но он может использовать только имя раздела, а не имя модуля:

```cpp
module Foo:part2;
import :part1;
```

Основной блок интерфейса должен импортировать и реэкспортировать все файлы раздела интерфейса модуля следующим образом:

```cpp
export import :part1
export import :part2
...
```

Основной блок интерфейса может импортировать файлы реализации разделов, но не может экспортировать их, поскольку эти файлы не могут экспортировать какие-либо имена. Это позволяет модулю держать детали реализации внутри модуля.

## <a name="modules-and-header-files"></a>Модули и файлы заголовков

Файлы заголовка можно включить в исходный `#include` файл модуля, поставив директиву перед декларацией модуля. Эти файлы считаются в *глобальном фрагменте модуля.* Модуль может видеть только имена в *глобальном фрагменте модуля,* которые находятся в заголовках, которые он явно включает. Фрагмент глобального модуля содержит только фактически используемые символы.

```cpp
// MyModuleA.cpp

#include "customlib.h"
#include "anotherlib.h"

import std.core;
import MyModuleB;

//... rest of file
```

Можно использовать традиционный файл заголовка для управления импортируемыми модулями:

```cpp
// MyProgram.h
import std.core;
#ifdef DEBUG_LOGGING
import std.filesystem;
#endif
```

### <a name="imported-header-files"></a>Импортированные файлы заголовка

> [!NOTE]
> Этот раздел является только информационным. Наследие импорта еще не реализованы в компиляторе Microsoft C.

Некоторые заголовки являются достаточно автономными, чтобы они могли быть привлечены с помощью ключевого слова **импорта.** Основное различие между импортируемым заголовком и импортируемым модулем состоит в том, что любые определения предварительного процессора в заголовке видны в программе импорта сразу после выписки об импорте. (Предварительные определения в любых файлах, включенных в этот заголовок, *не* видны.)

```cpp
import <vector>
import "myheader.h"
```

## <a name="see-also"></a>См. также раздел

[модуль, импорт, экспорт](import-export-module.md)
