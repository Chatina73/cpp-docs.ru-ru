---
title: Обзор модулей в C++
ms.date: 12/13/2019
helpviewer_keywords:
- modules [C++]
- modules [C++], overview
description: Модули в C++ 20 предоставляют современное альтернативу файлам заголовков.
ms.openlocfilehash: 286d2ec8a26dbd0a85e8f8721ad6fd7f12f45a31
ms.sourcegitcommit: 8e285a766523e653aeeb34d412dc6f615ef7b17b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2020
ms.locfileid: "80078044"
---
# <a name="overview-of-modules-in-c"></a>Обзор модулей в C++

В c++ 20 представлены *модули*, современное решение для компонентов C++ библиотек и программ. Модуль — это набор файлов исходного кода, которые компилируются независимо от [единиц трансляции](https://wikipedia.org/wiki/Translation_unit_(programming)) , которые их импортируют. Модули устраняют или значительно снижают многие проблемы, связанные с использованием файлов заголовков, а также могут сократить время компиляции. Макросы, директивы препроцессора и неэкспортированные имена, объявленные в модуле, не видны и поэтому не влияют на компиляцию записи преобразования, которая импортирует модуль. Модули можно импортировать в любом порядке, не заботясь о переопределениях макросов. Объявления в импортируемой записи не участвуют в разрешении перегрузки или поиске имен в импортированном модуле. После компиляции модуля результаты сохраняются в двоичном файле, который описывает все экспортированные типы, функции и шаблоны. Этот файл может обрабатываться гораздо быстрее, чем файл заголовка, и может использоваться компилятором каждый раз, когда модуль импортируется в проект.

Модули можно использовать параллельно с файлами заголовков. C++ Исходный файл может импортировать модули, а также #include файлы заголовков. В некоторых случаях файл заголовка можно импортировать как модуль, а не в текстовом #included препроцессором. Рекомендуется, чтобы новые проекты использовали модули, а не файлы заголовков, насколько это возможно. Для больших существующих проектов в рамках активной разработки мы рекомендуем поэкспериментировать с преобразованием устаревших заголовков в модули, чтобы определить, будет ли получено осмысленное сокращение времени компиляции.

## <a name="enable-modules-in-the-microsoft-c-compiler"></a>Включение модулей в компиляторе C++ Microsoft

В Visual Studio 2019 версии 16,2 модули не полностью реализованы в компиляторе Майкрософт C++ . С помощью функции "модули" можно создавать модули с одной секцией и импортировать модули стандартной библиотеки, предоставляемые корпорацией Майкрософт. Чтобы включить поддержку модулей, Скомпилируйте с помощью [/експериментал: module](../build/reference/experimental-module.md) и [/std: c + + Latest](../build/reference/std-specify-language-standard-version.md). В проекте Visual Studio щелкните правой кнопкой мыши узел проекта в **Обозреватель решений** и выберите пункт **свойства**. Задайте в раскрывающемся списке **Конфигурация** значение **все конфигурации**, а затем выберите **Свойства конфигурации** > **язык** **C/C++**  >  > **включить C++ модули (экспериментальные)** .

Модуль и код, который его использует, должны быть скомпилированы с теми же параметрами компилятора.

## <a name="consume-the-c-standard-library-as-modules"></a>Использовать C++ стандартную библиотеку в качестве модулей

Корпорация Майкрософт позволяет импортировать C++ стандартную библиотеку в качестве модулей, хотя это не указано в стандарте c++ 20. Импортировав C++ стандартную библиотеку как модули, а не #including их через заголовочные файлы, вы можете ускорить компиляцию в зависимости от размера проекта. Библиотека является компонентом следующих модулей:

- STD. Regex предоставляет содержимое заголовка \<Regex >
- STD. FileSystem предоставляет содержимое заголовков \<FileSystem >
- STD. Memory предоставляет содержимое заголовка \<памяти >
- STD. Threading предоставляет содержимое заголовков \<атомарные >, \<condition_variable >, \<будущих >, \<мьютекс >, \<shared_mutex > и \<Thread >
- STD. Core предоставляет все остальное в C++ стандартной библиотеке

Чтобы использовать эти модули, просто добавьте объявление импорта в начало файла исходного кода. Например:

```cpp
import std.core;
import std.regex;
```

Чтобы использовать модуль стандартной библиотеки Майкрософт, скомпилируйте программу с параметрами [/EHsc](../build/reference/eh-exception-handling-model.md) и [/MD](../build/reference/md-mt-ld-use-run-time-library.md) .

## <a name="basic-example"></a>Простой пример

В следующем примере показано простое определение модуля в исходном файле с именем **foo. икскс**. Расширение **. икскс** требуется для файлов интерфейса модуля в Visual Studio. В этом примере файл интерфейса содержит определение функции, а также объявление. Однако определения можно также поместить в один или несколько отдельных файлов (как показано в следующем примере). Инструкция **Export Module foo** указывает, что этот файл является основным интерфейсом для модуля с именем `Foo`. Модификатор **экспорта** в `f()` указывает, что эта функция будет отображаться при импорте `Foo` другой программой или модулем. Обратите внимание, что модуль ссылается на `Bar`пространства имен.

```cpp
export module Foo;

#define ANSWER 42

namespace Bar
{
   int f_internal() {
        return ANSWER;
      }

   export int f() {
      return f_internal();
   }
}
```

Файл **MyProgram. cpp** использует объявление **импорта** для доступа к имени, экспортируемому с помощью `Foo`. Обратите внимание, что имя `Bar` отображается здесь, но не все его члены. Также обратите внимание, что макрос `ANSWER` невидим.

```cpp

import Foo;
import std.core;

using namespace std;

int main()
{
   cout << "The result of f() is " << Bar::f() << endl; // 42
   // int i = Bar::f_internal(); // C2039
   // int j = ANSWER; //C2065
}

```

Объявление импорта может использоваться только в глобальной области видимости.

## <a name="implementing-modules"></a>Реализация модулей

Можно создать модуль с одним файлом интерфейса (. икскс), который экспортирует имена и включает реализации всех функций и типов. Можно также разместить реализации в одном или нескольких отдельных файлах реализации, аналогично использованию h и CPP Files. Ключевое слово **Export** используется только в файле интерфейса. Файл реализации может **импортировать** другой модуль, но не может **экспортировать** никаких имен. Файлы реализации могут называться любым расширением. Файл интерфейса и набор файлов реализации, которые его поддерживают, обрабатываются как особый тип записи преобразования, называемой *единицей модуля*. Имя, объявленное в любом файле реализации, автоматически отображается во всех остальных файлах в той же единице модуля.

Для больших модулей модуль можно разделить на несколько единиц модуля, называемых *секциями*. Каждая секция состоит из файла интерфейса, поддерживаемого одним или несколькими файлами реализации. (Начиная с Visual Studio 2019 версии 16,2, секции еще не полностью реализованы.)

## <a name="modules-namespaces-and-argument-dependent-lookup"></a>Модули, пространства имен и поиск с зависимостью от аргументов

Правила для пространств имен в модулях такие же, как и в любом другом коде. Если экспортируется объявление в пространстве имен, то включающее пространство имен (за исключением неэкспортированных элементов) также будет неявно экспортировано. Если пространство имен экспортируется явным образом, экспортируются все объявления в этом определении пространства имен.

При выполнении уточняющего запроса, зависящего от аргумента, для разрешения перегрузки в импортируемой записи преобразования компилятор учитывает функции, объявленные в той же записи преобразования (включая интерфейсы модуля), как и тип аргументов функции. определены.

### <a name="module-partitions"></a>Секции модулей

> [!NOTE]
> Этот раздел предназначен для полноты. Секции еще не реализованы в компиляторе C++ Майкрософт.

Модуль может быть разбит на *Секции*, каждый из которых состоит из файла интерфейса, а также от нуля или нескольких файлов реализации. Раздел модуля аналогичен модулю, за исключением того, что он разделяет владение всеми объявлениями во всем модуле. Все имена, экспортированные с помощью файлов интерфейса секционирования, импортируются и экспортируются повторно с помощью первичного файла интерфейса. Имя секции должно начинаться с имени модуля, за которым следует двоеточие. Объявления в любой из секций видны во всем модуле. Специальные меры предосторожности не требуются, чтобы избежать ошибок с одним определением (С операционными данными). Можно объявить имя (функцию, класс и т. д.) в одной секции и определить их в другой. Файл реализации секции начинается следующим образом:

```cpp
module Foo:part1
```

и файл интерфейса секционирования начинается следующим образом:

```cpp
export module Foo:part1
```

Чтобы получить доступ к объявлениям в другой секции, необходимо импортировать ее секцию, но она может использовать только имя секции, а не имя модуля:

```cpp
module Foo:part2;
import :part1;
```

Основная единица интерфейса должна импортировать и повторно экспортировать все файлы разделов интерфейса модуля следующим образом:

```cpp
export import :part1
export import :part2
...
```

Основная единица интерфейса может импортировать файлы реализации секций, но не может экспортировать их, так как эти файлы не могут экспортировать какие-либо имена. Это позволяет модулю удержать внутренние сведения о реализации модуля.

## <a name="modules-and-header-files"></a>Модули и файлы заголовков

Файлы заголовков можно включить в исходный файл модуля, поместив директиву `#include` перед объявлением модуля. Эти файлы считаются частью *глобального фрагмента модуля*. Модуль может видеть только имена в *фрагменте глобального модуля* , который содержит явно заголовков. Фрагмент глобального модуля содержит только символы, которые фактически используются.

```cpp
// MyModuleA.cpp

#include "customlib.h"
#include "anotherlib.h"

import std.core;
import MyModuleB;

//... rest of file
```

Для управления импортируемыми модулями можно использовать традиционный заголовочный файл.

```cpp
// MyProgram.h
import std.core;
#ifdef DEBUG_LOGGING
import std.filesystem;
#endif
```

### <a name="imported-header-files"></a>Импортированные файлы заголовков

> [!NOTE]
> Этот раздел является только информационным. Устаревшие импорты еще не реализованы в C++ компиляторе Майкрософт.

Некоторые заголовки достаточно самодостаточны, что их можно использовать с помощью ключевого слова **Import** . Основное различие между импортированным заголовком и импортированным модулем заключается в том, что все определения препроцессора в заголовке видимы в программе импорта сразу после оператора import. (Определения препроцессора в файлах, содержащихся в этом заголовке, *не* видны.)

```cpp
import <vector>
import "myheader.h"
```

## <a name="see-also"></a>См. также:

[Модуль, импорт, экспорт](import-export-module.md)
