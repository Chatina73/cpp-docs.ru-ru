---
title: Перегрузка операторов
ms.date: 11/04/2016
f1_keywords:
- operator_cpp
- operator
helpviewer_keywords:
- redefinable operators [C++]
- non-redefinable operators [C++]
- operator keyword [C++]
- operators [C++], overloading
- operator overloading
ms.assetid: 56ad4c4f-dd0c-45e0-adaa-08fe98cb1f8e
ms.openlocfilehash: a16f68088ffffd6c3cf38f5ae3adda5f2d59fb57
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80188575"
---
# <a name="operator-overloading"></a>Перегрузка операторов

Ключевое слово **operator** объявляет функцию, указывающую, какой *оператор-символ* означает при применении к экземплярам класса. Это дает оператору более одного значения — "перегружает" его. Компилятор различает разные значения оператора, проверяя типы его операндов.

## <a name="syntax"></a>Синтаксис

> Оператор *типа* **оператор** *-symbol* **(** *parameter-list* **)**

## <a name="remarks"></a>Remarks

Функцию большинства встроенных операторов можно переопределить глобально или для отдельных классов. Перегруженные операторы реализуются в виде функции.

Имя перегруженного оператора — **operator** *x*, где *x* — это оператор, как показано в следующей таблице. Например, для перегрузки оператора сложения необходимо определить функцию с именем **operator +** . Аналогично, чтобы перегрузить оператор сложения и присваивания, **+=** , определите функцию с именем **operator + =** .

### <a name="redefinable-operators"></a>Переопределяемые операторы

|Оператор|Имя|Тип|
|--------------|----------|----------|
|**,**|Запятая|Двоичные данные|
|**!**|Логическое НЕ|Унарный|
|**!=**|Неравенство|Двоичные данные|
|**%**|Modulus|Двоичные данные|
|**%=**|Назначение модуля|Двоичные данные|
|**&**|Побитовое И|Двоичные данные|
|**&**|Взятие адреса|Унарный|
|**&&**|Логическое И|Двоичные данные|
|**&=**|Назначение побитового И|Двоичные данные|
|**( )**|Вызов функции|—|
|**( )**|Оператор приведения|Унарный|
|**&#42;**|Умножение|Двоичные данные|
|**&#42;**|Разыменование указателя|Унарный|
|**&#42;=**|Присваивание умножения|Двоичные данные|
|**+**|Сложение|Двоичные данные|
|**+**|Унарный плюс|Унарный|
|**++**|Шаг <sup>1</sup>|Унарный|
|**+=**|Присваивание сложения|Двоичные данные|
|**-**|Вычитание|Двоичные данные|
|**-**|Унарное отрицание|Унарный|
|**--**|Уменьшить <sup>1</sup>|Унарный|
|**-=**|Присваивание вычитания|Двоичные данные|
|**->**|Выбор члена|Двоичные данные|
|**— >&#42;**|Выбор указателя на член|Двоичные данные|
|**/**|Деление|Двоичные данные|
|**/=**|Присваивание деления|Двоичные данные|
|**\<**|Меньше чем|Двоичные данные|
|**<<**|Сдвиг влево|Двоичные данные|
|**<<=**|Сдвиг влево и присваивание|Двоичные данные|
|**<=**|Меньше или равно|Двоичные данные|
|**=**|Назначение|Двоичные данные|
|**==**|Равенство|Двоичные данные|
|**>**|Больше|Двоичные данные|
|**>=**|Больше или равно|Двоичные данные|
|**>>**|Сдвиг вправо|Двоичные данные|
|**>>=**|Сдвиг вправо и присваивание|Двоичные данные|
|**[ ]**|Индекс массива|—|
|**^**|Исключающее ИЛИ|Двоичные данные|
|**^=**|Исключающее ИЛИ/присваивание|Двоичные данные|
|**&#124;**|Побитовое ИЛИ|Двоичные данные|
|**&#124;=**|Назначение побитового включающего ИЛИ|Двоичные данные|
|**&#124;&#124;**|Логическое ИЛИ|Двоичные данные|
|**~**|Дополнение до единицы|Унарный|
|**delete**|DELETE|—|
|**новую**|Создать|—|
|операторы преобразования|операторы преобразования|Унарный|

Существует <sup>1</sup> две версии унарных операторов инкремента и декремента: добавочное и инкрементное.

Дополнительные сведения см. в разделе [Общие правила перегрузки операторов](../cpp/general-rules-for-operator-overloading.md) . Ограничения для разных категорий перегруженных операторов описываются в следующих разделах.

- [Унарные операторы](../cpp/overloading-unary-operators.md)

- [Бинарные операторы](../cpp/binary-operators.md)

- [Присваивание](../cpp/assignment.md)

- [Вызов функции](../cpp/function-call-cpp.md)

- [Индексация](../cpp/subscripting.md)

- [Доступ к членам класса](../cpp/member-access.md)

- [Инкремент и декремента](../cpp/increment-and-decrement-operator-overloading-cpp.md).

- [Пользовательские преобразования типов](../cpp/user-defined-type-conversions-cpp.md)

Операторы, перечисленные в следующей таблице, не могут быть перегружены. Таблица содержит символы препроцессора **#** и **##** .

### <a name="nonredefinable-operators"></a>Непереопределяемые операторы

|Оператор|Имя|
|-|-|
|**.**|Выбор члена|
|**.&#42;**|Выбор указателя на член|
|**::**|Разрешение области|
|**? :**|Условная логика|
|**#**|Препроцессор: преобразование в строку|
|**##**|Препроцессор: конкатенация|

Хотя перегруженные операторы обычно называются компилятором неявным образом при их появлении в коде, их можно вызывать и явным образом — точно так же, как и любую функцию-член или функцию, не являющуюся членом.

```cpp
Point pt;
pt.operator+( 3 );  // Call addition operator to add 3 to pt.
```

## <a name="example"></a>Пример

В следующем примере оператор **+** перегружается для добавления двух комплексных чисел и возвращает результат.

```cpp
// operator_overloading.cpp
// compile with: /EHsc
#include <iostream>
using namespace std;

struct Complex {
   Complex( double r, double i ) : re(r), im(i) {}
   Complex operator+( Complex &other );
   void Display( ) {   cout << re << ", " << im << endl; }
private:
   double re, im;
};

// Operator overloaded using a member function
Complex Complex::operator+( Complex &other ) {
   return Complex( re + other.re, im + other.im );
}

int main() {
   Complex a = Complex( 1.2, 3.4 );
   Complex b = Complex( 5.6, 7.8 );
   Complex c = Complex( 0.0, 0.0 );

   c = a + b;
   c.Display();
}
```

```Output
6.8, 11.2
```

## <a name="in-this-section"></a>В этом разделе

- [Общие правила перегрузки операторов](../cpp/general-rules-for-operator-overloading.md)

- [Перегрузка унарных операторов](../cpp/overloading-unary-operators.md)

- [Бинарные операторы](../cpp/binary-operators.md)

- [Присваивание](../cpp/assignment.md)

- [Вызов функции](../cpp/function-call-cpp.md)

- [Индексация](../cpp/subscripting.md)

- [Доступ к членам](../cpp/member-access.md)

## <a name="see-also"></a>См. также раздел

[Встроенные операторы C++, приоритет и ассоциативность](../cpp/cpp-built-in-operators-precedence-and-associativity.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)
