---
title: Заданные пользователем преобразования типов (C++)
ms.date: 11/04/2016
f1_keywords:
- explicit_cpp
helpviewer_keywords:
- constructors [C++], and constants
- conversion functions [C++]
- explicit keyword [C++]
- type conversion
- constructors [C++], drawbacks
- conversion constructors
- type conversion [C++], explicit conversion
- coercion [C++]
- conversions [C++], explicit
- objects [C++], converting
- conversion functions [C++], rules for declaring
- declaring functions [C++], conversion functions
- functions [C++], conversion
- converting objects
- constructors [C++], conversion
- conversions [C++], by constructors
- data type conversion [C++], explicit
ms.assetid: d40e4310-a190-4e95-a34c-22c5c20aa0b9
ms.openlocfilehash: e74d5b3a748a9aab22a6a9d83c4d6c4bd3379df4
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81374684"
---
# <a name="user-defined-type-conversions-c"></a>Заданные пользователем преобразования типов (C++)

*Преобразование* создает новое значение определенного типа из значения другого типа. *Стандартные преобразования* встроены в язык СЗ и поддерживают его встроенные типы, и вы можете создавать *пользовательские конверсии* для выполнения конверсий в, от или между типами, определяемыми пользователем.

Стандартные преобразования выполняют преобразование между встроенными типами, между указателями или ссылками на типы, связанные наследованием, в и из указателей void и в пустой указатель. Для получения дополнительной [информации см.](../cpp/standard-conversions.md) Пользовательские преобразования выполняют преобразование между пользовательскими типами или между пользовательскими и встроенными типами. Вы можете реализовать их как [конструкторы преобразования](#ConvCTOR) или как [функции преобразования.](#ConvFunc)

Преобразования могут быть явными, когда программист вызывает преобразование одного типа в другой (как в приведении или прямой инициализации) или неявными, когда язык или программа вызывают типы, которые отличаются от заданных программистом.

Попытка неявного преобразования выполняется, когда

- тип аргумента, предоставленного для функции, не совпадает с соответствующим параметром;

- тип значения, возвращаемого функцией, не совпадает с типом возвращаемого значения функции;

- тип выражения инициализатора не совпадает с типом инициализируемого объекта;

- тип результата выражения, которое управляет условным оператором, циклической конструкцией или параметром, не совпадает с тем, который требуется для управления;

- тип операнда, предоставленного для оператора, не совпадает с соответствующим параметром операнда. Для встроенных операторов тип обоих операндов должен совпадать; он преобразуется в общий тип, который может представлять оба операнда. Для получения дополнительной [информации см.](standard-conversions.md) Для пользовательских операторов тип каждого операнда должен совпадать с соответствующим параметром операнда.

Если не удается выполнить неявное преобразование с помощью стандартного преобразования, компилятор может использовать пользовательское преобразование, за которым (при необходимости) будет следовать дополнительное стандартное преобразование.

Если на сайте преобразования есть два и более пользовательских преобразования, выполняющих одно преобразование, преобразование называется неоднозначным. Неоднозначность подразумевает ошибку, так как компилятор не может определить, какое из доступных преобразований выбрать. Тем не менее, не будет ошибкой определить несколько способов выполнения одного преобразования, так как набор доступных преобразований может отличаться в разных участках исходного кода, например в зависимости от того, какие файлы заголовков входят в исходный файл. Пока на сайте преобразования доступно только одно преобразование, о неоднозначности речь не идет. Существует несколько путей возникновения неоднозначных преобразований, однако самые распространенные перечислены ниже.

- Множественное наследование. Преобразование определено в нескольких базовых классах.

- Вызов неоднозначной функции. Преобразование определено как конструктор преобразования типа целевого объекта и как функция преобразования типа источника. Для получения дополнительной информации [см.](#ConvFunc)

Неоднозначность, как правило, можно устранить, просто более полно указав имя соответствующего типа или выполнив явное приведение для пояснения намерения.

Конструкторы преобразования и функции преобразования подчиняются правилам управления доступом членов, однако доступность преобразований учитывается, только если можно определить неоднозначное преобразование. Это означает, что преобразование может быть неоднозначным, даже если уровень доступа конкурирующего преобразования будет блокировать его использование. Для получения дополнительной информации [Member Access Control](../cpp/member-access-control-cpp.md)о доступности участников см.

## <a name="the-explicit-keyword-and-problems-with-implicit-conversion"></a>Ключевое слово explicit и проблемы с неявным преобразованием

По умолчанию при создании пользовательского преобразования компилятор может использовать его для выполнения неявных преобразований. Иногда это совпадает с вашими намерениями, но в других случаях простые правила, которые определяют выполнение неявных преобразований компилятором, могут привести к тому, что он примет нежелательный код.

Одним из хорошо известных примеров неявного преобразования, которое может вызвать проблемы, является преобразование в **bool.** Существует множество причин, по которым можно создать тип класса, который может быть использован в контексте Boolean, например, чтобы он мог использоваться для управления оператора **if** или loop, но когда компилятор выполняет конверсию, определяемую пользователем, ввстроенному типу, компилятору разрешается применять дополнительное стандартное преобразование впоследствии. Цель этого дополнительного стандартного преобразования заключается в том, чтобы позволить вещи, как продвижение от **короткого** до **Int**, но он также открывает дверь для менее очевидных преобразований, например, от **bool** к **int**, что позволяет тип вашего класса, который будет использоваться в рядовых контекстах вы никогда не предполагалось. Эта конкретная проблема известна как *проблема безопасного bool*. Такого рода проблема, где **явное** ключевое слово может помочь.

**Явное** ключевое слово говорит компилятору, что указанное преобразование не может быть использовано для выполнения неявных преобразований. Если вы хотели синтаксическомудобстве неявных преобразований до введения **явного** ключевого слова, вам пришлось либо принять непредвиденные последствия, которые иногда создавалось неявное преобразование, либо использовать менее удобные, названные функции преобразования в качестве обходного пути. Теперь, используя **явное** ключевое слово, можно создать удобные преобразования, которые могут быть использованы только для выполнения явных слепков или прямой инициализации, и это не приведет к таким проблемам, о чем свидетельствует проблема Safe Bool.

**Явное** ключевое слово может быть применено к конструкторам преобразования с c-98, а также к функциям преобразования, начиная с C-11. Следующие разделы содержат больше информации о том, как использовать **явное** ключевое слово.

## <a name="conversion-constructors"></a><a name="ConvCTOR"></a>Конструкторы преобразования

Конструкторы преобразования определяют преобразование из пользовательских или встроенных типов в пользовательские типы. Ниже приводится пример, демонстрируемый конструктор преобразования, который преобразуется из `Money`встроенного **ввода double** в пользовательский тип.

```cpp
#include <iostream>

class Money
{
public:
    Money() : amount{ 0.0 } {};
    Money(double _amount) : amount{ _amount } {};

    double amount;
};

void display_balance(const Money balance)
{
    std::cout << "The balance is: " << balance.amount << std::endl;
}

int main(int argc, char* argv[])
{
    Money payable{ 79.99 };

    display_balance(payable);
    display_balance(49.95);
    display_balance(9.99f);

    return 0;
}
```

Обратите внимание, что первый вызов функции `display_balance`, которая принимает аргументы типа `Money`, не требует преобразования, так как аргумент принадлежит к правильному типу. Тем не менее, `display_balance`на втором вызове к , преобразование необходимо, `49.95`потому что тип аргумента, **двойной** со значением , не то, что функция ожидает. Функция не может использовать это значение напрямую, а потому, что есть преобразование из типа`Money`аргумента - `Money` **двойной**- к типу параметра соответствия - временное значение типа построено из аргумента и используется для завершения вызова функции. В третьем вызове, `display_balance`обратите внимание, что аргумент не является **двойным,** а вместо этого **поплавок** со значением - и все же вызов функции все еще может быть завершен, потому что компилятор может выполнить стандартное преобразование- в этом случае, от **плавания** до **двойного**- а затем выполнить пользовательский преобразование от **двойного** к `Money` завершению необходимого `9.99`преобразования.

### <a name="declaring-conversion-constructors"></a>Объявление конструкторов преобразования

Следующие правила применяются к объявлению конструктора преобразования.

- Целевым типом преобразования является сконструированный пользовательский тип.

- Конструкторы преобразований, как правило, принимают только один аргумент типа источника. Однако конструктор преобразования может указывать дополнительные параметры, если у каждого из них есть значение по умолчанию. Тип источника остается типом первого параметра.

- Конструкторы преобразований, как и все конструкторы, не указывают тип возвращаемого значения. Указание типа возвращаемого значения в объявлении является ошибкой.

- Конструкторы преобразования могут быть явными.

### <a name="explicit-conversion-constructors"></a>Явные конструкторы преобразования

Объявляя конструктор преобразования **явным,** он может использоваться только для выполнения прямой инициализации объекта или для выполнения явного броска. Это не дает функциям, которые принимают аргумент типа класса, также неявно принимать аргументы типа источника конструктора преобразования, а также блокирует инициализацию копирования типа класса из значения типа источника. В следующем примере демонстрируется определение явного конструктора преобразования и влияние на правильный синтаксис кода.

```cpp
#include <iostream>

class Money
{
public:
    Money() : amount{ 0.0 } {};
    explicit Money(double _amount) : amount{ _amount } {};

    double amount;
};

void display_balance(const Money balance)
{
    std::cout << "The balance is: " << balance.amount << std::endl;
}

int main(int argc, char* argv[])
{
    Money payable{ 79.99 };        // Legal: direct initialization is explicit.

    display_balance(payable);      // Legal: no conversion required
    display_balance(49.95);        // Error: no suitable conversion exists to convert from double to Money.
    display_balance((Money)9.99f); // Legal: explicit cast to Money

    return 0;
}
```

В этом примере обратите внимание, что явный конструктор преобразования можно использовать для выполнения прямой инициализации типа `payable`. Если же вы попытаетесь выполнить инициализацию копирования `Money payable = 79.99;`, это приведет к ошибке. Первый вызов `display_balance` не включает преобразование, так как указан аргумент правильного типа. Второй вызов `display_balance` является ошибкой, так как конструктор преобразования нельзя использовать для выполнения неявного преобразования. Третий вызов `display_balance` является законным из-за `Money`явного литья, но обратите внимание, что компилятор по-прежнему помогли завершить литье, вставив неявный литые от **поплавка** до **двойного**.

Несмотря на то, что использование неявных преобразований кажется удобным, в результате могут возникать трудновыявляемые ошибки. Как показывает опыт, лучше всего объявлять все конструкторы преобразований явными за исключением тех случаев, когда необходимо, чтобы определенное преобразование выполнялось неявно.

## <a name="conversion-functions"></a><a name="ConvFunc"></a>Функции преобразования

Функции преобразования определяют преобразования из пользовательского в другие типы. Эти функции иногда называют "операторами приведения", так как они, наряду с конструкторами преобразования, вызываются, когда значение приводится к другому типу. Следующий пример демонстрирует функцию преобразования, которая преобразуется `Money`из пользовательского типа, в встроенный тип, **двойной:**

```cpp
#include <iostream>

class Money
{
public:
    Money() : amount{ 0.0 } {};
    Money(double _amount) : amount{ _amount } {};

    operator double() const { return amount; }
private:
    double amount;
};

void display_balance(const Money balance)
{
    std::cout << "The balance is: " << balance << std::endl;
}
```

Обратите внимание, `amount` что переменная члена становится частной и что функция публичного `amount`преобразования для ввода **двойного** вводится только для того, чтобы вернуть значение . В функции `display_balance` неявное преобразование возникает, когда значение `balance` направляется в стандартный вывод с помощью оператора вставки в поток `<<`. Поскольку оператор потоковой вставки не определен `Money`для пользовательского типа, но есть один для встроенного типа `Money` **double,** компилятор может использовать функцию преобразования от **удвоенного** для удовлетворения оператора потока-вставки.

Функции преобразования наследуются производными классами. Функции преобразования в производном классе переопределяют наследуемую функцию преобразования, только когда выполняют преобразование в точно такой же тип. Например, функция преобразования, определяемая пользователем, **оператора-оператора** производных классов не переопределяет или даже влияет - функция преобразования оператора базового **класса,** определяемая пользователем, даже если стандартные преобразования определяют связь преобразования между **Int** и **short.**

### <a name="declaring-conversion-functions"></a>Объявление функций преобразования

Следующие правила применяются к объявлению функции преобразования.

- Целевой тип преобразования должен быть объявлен до объявления функции преобразования. Классы, структуры, перечисления и определения типа нельзя объявлять в объявлении функции преобразования.

    ```cpp
    operator struct String { char string_storage; }() // illegal
    ```

- Функции преобразования не принимают аргументов. Указание любых параметров в объявлении является ошибкой.

- Функции преобразования имеют тип возвращаемого значения, задаваемый именем функции преобразования, которое также является именем типа целевого объекта преобразования. Указание типа возвращаемого значения в объявлении является ошибкой.

- Функции преобразования могут быть виртуальными.

- Функции преобразования могут быть явными.

### <a name="explicit-conversion-functions"></a>Явные функции преобразования

Если функция преобразования объявлена как явная, ее можно использовать только для выполнения явного приведения. Это не дает функциям, которые принимают аргумент типа целевого объекта функции преобразования, также неявно принимать аргументы типа класса, а также блокирует инициализацию копирования экземпляров типа целевого объекта из значения типа класса. В следующем примере демонстрируется определение явной функции преобразования и влияние на правильный синтаксис кода.

```cpp
#include <iostream>

class Money
{
public:
    Money() : amount{ 0.0 } {};
    Money(double _amount) : amount{ _amount } {};

    explicit operator double() const { return amount; }
private:
    double amount;
};

void display_balance(const Money balance)
{
    std::cout << "The balance is: " << (double)balance << std::endl;
}
```

Здесь функция преобразования **оператора двойной** был сделан явным, и явный литые для ввода **двойной** был введен в функции `display_balance` для выполнения преобразования. Если пропустить это преобразование, компилятор не сможет найти подходящий оператор вставки в поток `<<` для типа `Money` и может возникнуть ошибка.
