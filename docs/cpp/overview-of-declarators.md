---
title: Общие сведения о деклараторах
ms.date: 11/04/2016
helpviewer_keywords:
- declarators, about declarators
ms.assetid: 0f2e2312-80bd-4154-8345-718bd9ed2173
ms.openlocfilehash: 8279dcb7f3cbc137320e46dded48d140d1429f8a
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50583359"
---
# <a name="overview-of-declarators"></a>Общие сведения о деклараторах

Деклараторы — это компоненты объявления, которые определяют имена объектов или функций. Деклараторы также указывают, является ли именованный объект массивом, объектом, указателем или ссылкой.  Хотя деклараторы и не задают базовый тип, однако они изменяют хранящуюся в нем информацию о типе, что позволяет определять производные типы, например указатели, ссылки и массивы.  Применительно к функциям декларатор действует на спецификатор типа. Это дает возможность полностью определить тип возвращаемого функцией значения: объект, указатель или ссылка. (Спецификаторы, рассматриваемые в [объявления и определения](declarations-and-definitions-cpp.md), обеспечивающие возможность быстрого определения свойства, такие как тип и класс хранения. Модификаторы, которые рассматриваются в этом разделе и в [модификаторы, используемые Microsoft](../cpp/microsoft-specific-modifiers.md), изменяют деклараторы.) На следующем рисунке представлено полное объявление функции `MyFunction` и указаны входящие в него компоненты.

![Модификаторы, спецификаторы и деклараторы](../cpp/media/vc38qy1.gif "vc38QY1") спецификаторы, модификаторы и деклараторы

**Блок, относящийся только к системам Microsoft**

Большинство ключевых слов расширений Microsoft можно использовать в качестве модификаторов для создания производных типов; они не являются ни спецификаторами, ни деклараторами. (См. в разделе [модификаторы, используемые Microsoft](../cpp/microsoft-specific-modifiers.md).)

**Завершение блока, относящегося только к системам Майкрософт**

В синтаксисе объявления деклараторы указываются после необязательного списка спецификаторов. Спецификаторы рассматриваются в [объявления.](declarations-and-definitions-cpp.md) Объявление может содержать несколько деклараторов, но каждый из них объявляет только одно имя.

В следующем примере видно, как сочетаются спецификаторы и деклараторы, из которых состоит полное объявление:

```cpp
const char *pch, ch;
```

В приведенном выше объявлении ключевые слова **const** и **char** составляют список спецификаторов. Помимо них перечислены два декларатора: `*pch` и `ch`.  Объявление, в котором объявлено несколько сущностей, состоит из спецификатора типа, за которым следует список деклараторов, разделенных запятыми. Объявление завершается точкой с запятой.

**Деклараторы для простых объектов**

Декларатор простого объекта, например int или double, содержит только имя. К нему могут добавляться необязательные круглые скобки.

`int i; // declarator is i`

`int (i); // declarator is (i)`

**Деклараторы для указателей, ссылок и массивов**

Если перед именем находится оператор указателя, то объект создается как указатель или ссылка.  <strong>\*</strong> Оператор объявляет имя в качестве указателя, а **&** оператор объявляет его как ссылку.

```cpp
int *i; // declarator is *i
int **i; // declarator is **i;
int &i = x; // declaratory is &i
```

Добавление **const** или **volatile** эти особые свойства к указателю.  Использование этих спецификаторов в деклараторе (в отличие от спецификатора типа) позволяет изменить свойства самого указателя, а не его объекта.

```cpp
char *const cpc; // const pointer to char
const char *pcc; // pointer to const char
const char *const cpcc; // const pointer to const char
```

Дополнительные сведения можно найти в [указатели const и volatile](../cpp/const-and-volatile-pointers.md).

Указатель на член класса или структуры объявляется с соответствующим спецификатором вложенного имени:

```cpp
int X::* pIntMember;
int ::X::* pIntMember; // the initial :: specifies X is in global scope
char Outer::Inner::* pIntMember; // pointer to char in a nested class
```

Если после имени стоят квадратные скобки, в которые заключено необязательное константное выражение, то объект создается как массив.  Несколько пар квадратных скобок подряд объявляют дополнительные размерности массива.

```cpp
int i[5]; // array with five elements of type int numbered from 0 to 4
int i[]; // array of unknown size
char *s[4]; // array of pointers to char
int i[2][2]; // two dimensional array
```

**Деклараторы для функций**

Круглые скобки, расположенные после имени и окружающие список аргументов, позволяют объявить функцию.  Ниже следует объявление типа возвращаемого значения функции **int** и тремя аргументами типа **int**.

```cpp
int f(int a, int b, int c);
```

Чтобы объявить указатель или ссылку на функцию, необходимо добавить перед ее именем оператор указателя или ссылки, как показано ниже.  Скобки, которые обычно являются необязательными, необходимы для того, чтобы указатель на функцию можно было отличить от функции, которая возвращает указатель:

```cpp
int (*pf)(int); // pointer to function returning int
int *f(int i); // function returning pointer to int
int (&pf)(int); // reference to function
```

Указатели на функции-члены можно отличить по вложенным спецификаторам имен:

```cpp
int (X::* pmf)(); // pointer to member function of X returning int
int* (X::* pmf)(); // pointer to member function returning pointer to int
```

См. также [указатели на члены](../cpp/pointers-to-members.md).

**Функции и объекты в одном объявлении**

Объявлять функции и объекты можно в одном и том же объявлении. Это делается следующим образом:

```cpp
int i, *j, f(int k);  // int, pointer to int, function returning int
```

В некоторых случаях синтаксис может вводить в заблуждение.  Рассмотрим следующее объявление:

```cpp
int* i, f(int k);  // pointer to int, function returning int (not int*)
```

может выглядеть как объявление **int** указатель и функции, возвращающей `int*`, но это не так.  Это потому, что \* входит в декларатор `i`, не являющийся частью декларатор `f`.

**Упрощение синтаксиса декларатора при помощи оператора typedef**

Тем не менее, лучше всего, является использование **typedef** или круглые скобки и **typedef** ключевое слово. Рассмотрим следующее объявление массива указателей на функции:

```cpp
//  Function returning type int that takes one
//   argument of type char *.
typedef int (*PIFN)( char * );
//  Declare an array of 7 pointers to functions
//   returning int and taking one argument of type
//   char *.
PIFN pifnDispatchArray[7];
```

Аналогичное объявление можно записать и без **typedef** объявления, но это весьма сложным, так что вероятность появления ошибки нивелирует все преимущества:

```cpp
int ( *pifnDispatchArray[7] )( char * );
```

Дополнительные сведения о ключевом слове typedef см. в разделе [псевдонимы и определения типов](aliases-and-typedefs-cpp.md).

Указатели, ссылки, массивы одного базового типа можно объединить в одном объявлении (разделив их запятыми), как в следующем примере:

```cpp
int a, *b, c[5], **d, &e=a;
```

**Более сложный синтаксис декларатора**

- Деклараторы указателей, ссылок, массивов и функций можно объединять. Это позволит объявлять такие объекты, как массивы указателей на функции, указатели на массивы и т. д.

- Приведенная ниже рекурсивная грамматика полностью описывает синтаксис декларатора указателя.

- Декларатор (`declarator`) определяется одним из следующих правил:

  - идентификатор 
  - Полное имя 
  - декларатор (список аргументов) [cv-qualfiers] [исключение spec]
  - декларатор [[константное выражение]]
  - декларатор указателя оператор 
  - (объявление)

- и *оператора указателя* является одним из:

  - \* [cv квалификаторы]
  - & [cv квалификаторы]:: вложенные name-specifier \* [cv квалификаторы]

Поскольку любой декларатор может содержать другие деклараторы, то при помощи приведенных выше правил можно создавать более сложные производные типы, например массивы указателей или функции, возвращающие массивы указателей на функции.  Чтобы сформировать каждую часть этой конструкции, сначала укажите идентификатор, представляющий базовый тип данных, а затем примените правило синтаксиса с приведенным выше выражением в качестве декларатора (`declarator`).  Порядок, в котором применяются правила синтаксиса, должен быть обратным тому, в каком выражения формулируются в английском языке.  Если применение *оператора указателя* правило синтаксиса к выражению массива или функции, используйте скобки, если требуется, чтобы указатель на массив или функцию, как в последней строке в таблице ниже.

В следующем примере показано создание указателя на массив из десяти указателей на целочисленное значение.

|Словесное выражение|Декларатор|Применяемое правило синтаксиса|
|-----------------------|----------------|-------------------------|
||`i`|1|
|указателей на|`*i`|5|
|массив из 10|`(*i)[10]`|4|
|указатель на|`*((*i)[10])`|6, а затем 5|

Если используется несколько модификаторов указателя, ссылки, массива или функции, то деклараторы могут становиться довольно сложными.  Раздел [Интерпретация более сложных деклараторов](../c-language/interpreting-more-complex-declarators.md) описывается, как читать более сложный синтаксис деклараторов.  Этот раздел относится к C и C++, хотя в C++, в любом \* используется для обозначения указателя, полное имя, например MyClass::\* может использоваться для указания указатель на член класса.