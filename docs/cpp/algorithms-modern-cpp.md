---
title: Алгоритмы (современный C++)
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 6f758d3c-a7c7-4a50-92bb-97b2f6d4ab27
ms.openlocfilehash: b972e575c982ae2523ec560a6237eac76ceaf834
ms.sourcegitcommit: c6f8e6c2daec40ff4effd8ca99a7014a3b41ef33
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/24/2019
ms.locfileid: "64345178"
---
# <a name="algorithms-modern-c"></a>Алгоритмы (современный C++)

Для современных особенностях программирования на C++, мы рекомендуем использовать алгоритмы в [стандартной библиотеки C++](../standard-library/cpp-standard-library-reference.md). Вот несколько важных примеров:

- **for_each**, который представляет собой алгоритм обхода по умолчанию. (Также **преобразования** для семантики не на месте.)

- **find_if**, который представляет собой алгоритм поиска по умолчанию.

- **Сортировка**, **lower_bound**и другие сортировки по умолчанию и алгоритмы поиска.

Чтобы написать оператор сравнения, используйте строгое **<** и использовать *именованные лямбда-выражения* следует.

```cpp
auto comp = [](const widget& w1, const widget& w2)
     { return w1.weight() < w2.weight(); }

sort( v.begin(), v.end(), comp );

auto i = lower_bound( v.begin(), v.end(), comp );
```

## <a name="loops"></a>Циклы

По возможности используйте по диапазону **для** циклов или вызовы алгоритма или оба параметра, а не написанные вручную циклы. **Копировать**, **преобразования**, **count_if**, **remove_if**, и другие подобные им намного лучше, чем рукописные циклы, так как их целью является очевидным и они упростить написание кода без ошибок. Кроме того многие алгоритмы стандартной библиотеки C++ имеют оптимизации реализации, которые делают их более эффективными.

Вместо старого C++ следующим образом:

```cpp
for ( auto i = strings.begin(); i != strings.end(); ++i ) {
    /* ... */
}

auto i = v.begin();

for ( ; i != v.end(); ++i ) {
    if (*i > x && *i < y) break;
}
```

Используйте современный язык C++ следующим образом:

```cpp
for_each( begin(strings), end(strings), [](string& s) {
  // ...
} );

auto i = find_if( begin(v), end(v),  [=](int i) { return i > x && i < y; } );
```

### <a name="range-based-for-loops"></a>На диапазоне циклы for

На основе диапазона **для** цикла является функцией C ++ 11 языка, не алгоритм стандартной библиотеки C++. Но он заслуживает упоминания в этой дискуссии о циклах. На основе диапазона **для** циклы являются расширением **для** ключевое слово и предоставить удобным и эффективным способом записи циклов, выполняющих итерацию с диапазоном значений. Контейнеры стандартной библиотеки C++, строки и массивы готовы для основанных на диапазоне **для** циклы. Чтобы включить этот новый синтаксис итераций для определяемого пользователем типа, добавьте следующую поддержку:

- Объект `begin` метод, который возвращает итератор, указывающий на начало структуры и `end` метод, который возвращает итератор, указывающий конец структуры.

- Поддержка в итераторе этих методов: **оператор**<strong>\*</strong>, **оператор! =**, и **operator ++** (версия префикса).

Эти методы могут быть члены или отдельные функции.

## <a name="random-numbers"></a>Случайные числа

Не секрет, старый CRT `rand()` функция имеет много изъянов, которые были подробно обсуждаются в сообществе с ++. В современном C++ нет необходимости иметь дело с этим недостатками, равно, и нет необходимости изобретать собственный равномерно распределенных генератора случайных чисел, так как средства для быстрого и простого создания доступны в стандартной библиотеке C++, как показано в [ \<случайных >](../standard-library/random.md).

## <a name="see-also"></a>См. также

[Возвращение к C++ (современный C++)](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)<br/>
