---
title: Встраиваемые функции (C++)
ms.date: 10/09/2018
f1_keywords:
- __forceinline_cpp
- __inline_cpp
- inline_cpp
- __inline
- _inline
- __forceinline
- _forceinline
helpviewer_keywords:
- inline functions [C++], class members
ms.assetid: 355f120c-2847-4608-ac04-8dda18ffe10c
ms.openlocfilehash: 55cf598877c2447e0f80e783b53b290699042b8b
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50607822"
---
# <a name="inline-functions-c"></a>Встраиваемые функции (C++)

Функция, определенная в теле объявления класса, является встраиваемой.

## <a name="example"></a>Пример

В показанном ниже объявлении класса конструктор `Account` является встраиваемой функцией. Функции-члены `GetBalance`, `Deposit`, и `Withdraw` не указаны как **встроенного** , но могут быть реализованы как встраиваемые функции.

```cpp
// Inline_Member_Functions.cpp
class Account
{
public:
    Account(double initial_balance) { balance = initial_balance; }
    double GetBalance();
    double Deposit( double Amount );
    double Withdraw( double Amount );
private:
    double balance;
};

inline double Account::GetBalance()
{
    return balance;
}

inline double Account::Deposit( double Amount )
{
    return ( balance += Amount );
}

inline double Account::Withdraw( double Amount )
{
    return ( balance -= Amount );
}
int main()
{
}
```

> [!NOTE]
>  В объявлении класса функции объявлены без **встроенного** ключевое слово. **Встроенного** ключевое слово можно указать в объявлении класса; результат одинаков.

Заданная встроенная функция-член должна быть объявлена одинаково в каждом блоке компиляции. Из-за этого ограничения встроенные функции работают так же, как если бы они были созданными экземплярами функций. Кроме того, должно существовать только одно определение встраиваемой функции.

Функции-члена класса по умолчанию имеют внешнюю компоновку, если определение этой функции не содержит **встроенного** спецификатор. В предыдущем примере показано, что эти функции должны не следует объявлять явно с **встроенного** описатель; с помощью **встроенного** в функции определения приводит к становится встраиваемой. Тем не менее, не допускается для повторного объявления функции, как **встроенного** после вызова этой функции.

## <a name="inline-inline-and-forceinline"></a>Встроенные, __inline, и \__forceinline

**Встроенного** и **__inline** спецификаторы указать компилятору вставить копию тела функции в каждое место, в вызове функции.

Такая вставка (она называется подстановкой или встраиванием) выполняется только в том случае, если проведенный компилятором анализ затрат и выгод показывает, что это может дать выигрыш. Подстановка снимает нагрузку на вызов функции, иногда ценой увеличения размера кода.

**__Forceinline** ключевое слово переопределяет анализ затрат и результатов и основывается на человека программиста, вместо этого. Соблюдайте осторожность при использовании **__forceinline**. Беспорядочное использование **__forceinline** может привести к увеличению кода с производительности или, в некоторых случаях даже снижение производительности (из-за повышенной разбиение на страницы большой исполняемый файл, например).

Применение встраиваемых функций может ускорить выполнение программ, поскольку устраняет нагрузку на вызов функций. Для подставляемых функций выполняются оптимизации кода, которые недоступны для обычных функций.

Параметры и ключевые слова подстановки компилятор обрабатывает как рекомендации. Подстановка функции не гарантируется. Нельзя принудить компилятор выполнить подстановку определенной функции, даже с **__forceinline** ключевое слово. При компиляции с параметром **/CLR**, компилятор не будет подставлять функцию при наличии атрибутов безопасности, применяемых в функцию.

**Встроенного** ключевое слово доступно только в C++. **__Inline** и **__forceinline** доступны ключевые слова в C и C++. Для совместимости с предыдущими версиями **_inline** и **_forceinline** являются синонимами для **__inline**, и **__forceinline** Если параметр компилятора [/Za \(отключить расширения языка)](../build/reference/za-ze-disable-language-extensions.md) указан.

**Встроенного** ключевое слово указывает компилятору, что подстановка является предпочтительной. Однако компилятор может создать отдельный экземпляр функции и вместо подстановки кода создать стандартную компоновку вызова. Существует две ситуации, в которых это может происходить.

- Рекурсивные функции.

- Функции, на которые создаются ссылки посредством указателя в любом месте блока трансляции.

Эти причины могут конфликтовать с встраивания, соотношения *как некоторыми другими*, по своему усмотрению компилятора; не следует полагаться на **встроенного** вызовет функцию для встраивания.

Как при использовании обычных функций, для встраиваемых функций нет заданного порядка вычисления аргументов. Фактически он может отличаться от порядка, в котором аргументы вычисляются при передаче с использованием обычного протокола вызова функций.

[/Ob](../build/reference/ob-inline-function-expansion.md) параметр оптимизации компилятора помогает определить, происходит ли фактически подставляемых функций.

[/ Параметр LTCG](../build/reference/ltcg-link-time-code-generation.md) выполняет межмодульную независимо от того, была ли она запрошена в исходном коде.

### <a name="example-1"></a>Пример 1

```cpp
// inline_keyword1.cpp
// compile with: /c
inline int max( int a , int b ) {
   if( a > b )
      return a;
   return b;
}
```

Функции-члены класса могут объявляться как подставляемые либо при помощи **встроенного** ключевое слово или путем вставки определения функции внутри определения класса.

### <a name="example-2"></a>Пример 2

```cpp
// inline_keyword2.cpp
// compile with: /EHsc /c
#include <iostream>
using namespace std;

class MyClass {
public:
   void print() { cout << i << ' '; }   // Implicitly inline
private:
   int i;
};
```

### <a name="microsoft-specific"></a>Блок, относящийся только к системам Microsoft

**__Inline** ключевое слово эквивалентно **встроенного**.

Даже с **__forceinline**, компилятор не может выполнять подстановку кода во всех случаях. Компилятор не выполняет подстановку, если:

- Функция или вызывающий ее объект скомпилированы с параметром /Ob0 (параметр по умолчанию для отладочной сборки).

- В функции и вызывающем объекте используются разные типы (в одном — обработка исключений C++, а в другом — структурированная).

- Функция имеет переменное число аргументов.

- В функции используется встроенный код ассемблера (кроме случаев компиляции с параметром /Og, /Ox, /O1 или /O2).

- Функция является рекурсивной и не сопровождается директивой **#pragma inline_recursion(on)**. С помощью этой директивы выполняется подстановка рекурсивных функций с глубиной по умолчанию, 16 вызовам. Чтобы уменьшить глубину подстановки, используйте [inline_depth](../preprocessor/inline-depth.md) директивы pragma.

- Функция является виртуальной, и для нее используется виртуальный вызов. Прямые вызовы виртуальных функций могут подставляться.

- Программа принимает адрес функции, и вызов совершается через указатель на функцию. Прямые вызовы функций, чей адрес был принят, могут подставляться.

- Функция также помечена [с атрибутом naked](../cpp/naked-cpp.md) [__declspec](../cpp/declspec.md) модификатор.

Если компилятор не может выполнить подстановку функции, объявленные с **__forceinline**, он создает предупреждение уровня 1, за исключением случаев:

- Функция компилируется с помощью /Od или параметром/Ob0. Не встраивания в этих случаях ожидается.

- Функция извне, определенную в библиотеке или другой записи преобразования, или целевой объект виртуального вызова или целевой объект косвенного вызова. Компилятор не может определить неподставляемый код, который его не удается найти в текущей записи преобразования.

Рекурсивные функции можно подставляться до глубины, определяемое [inline_depth](../preprocessor/inline-depth.md) pragma, но не более 16 вызовов. Начиная с этой глубины рекурсивные функции обрабатываются как вызовы на экземпляр функции.  Глубина, до которой эвристический поиск для подстановки функций проверяет рекурсивные функции, не может превышать 16 вызовов. [Inline_recursion](../preprocessor/inline-recursion.md) pragma управляет подстановкой подставляемых функций функции в настоящее время в разделе расширения. См. в разделе [расширение встраиваемых функций](../build/reference/ob-inline-function-expansion.md) (/ Ob) параметр компилятора связанные сведения.

**Завершение блока, относящегося только к системам Майкрософт**

Дополнительные сведения об использовании **встроенного** описатель, см. в разделе:

- [Подставляемые функции-члены класса](../cpp/inline-functions-cpp.md)

- [Определение встроенных функций C++ с помощью dllexport и dllimport](../cpp/defining-inline-cpp-functions-with-dllexport-and-dllimport.md)

## <a name="when-to-use-inline-functions"></a>Когда использовать встраиваемые функции

Встроенные функции лучше использовать для небольших функций, например функций доступа к закрытым элементам данных. Основное назначение таких одно- и двухстрочных функций доступа — возвращение сведений о состоянии объектов; короткие функции чувствительны к рабочей нагрузке вызовов функций. Более длинные функции тратят пропорционально меньше времени на выполнение последовательности вызова и возврата. Встраивание дает им меньше преимуществ.

Объект `Point` класс можно определить следующим образом:

```cpp
// when_to_use_inline_functions.cpp
class Point
{
public:
    // Define "accessor" functions as
    //  reference types.
    unsigned& x();
    unsigned& y();
private:
    unsigned _x;
    unsigned _y;
};

inline unsigned& Point::x()
{
    return _x;
}
inline unsigned& Point::y()
{
    return _y;
}
int main()
{
}
```

При условии, что манипуляция координатами — относительно распространенная операция в клиенте, такого класса, указав две функции доступа (`x` и `y` в предыдущем примере) как **встроенного** обычно обеспечивает экономию издержки на:

- вызовы функций (включая передачу параметров и размещение адреса объекта в стеке);

- сохранение кадра стека вызывающего объекта;

- настройку нового кадра стека;

- передачу возвращаемого значения;

- восстановление старого кадра стека;

- Назад

## <a name="inline-functions-vs-macros"></a>Встроенные функции и макросы

Хотя встраиваемые функции похожи на макросы (поскольку код функции разворачивается в точке вызова во время компиляции), встраиваемые функции анализируются компилятором, тогда как макросы разворачиваются препроцессором. В результате, имеется несколько важных различий.

- Встраиваемые функции выполняют все протоколы безопасности типов, обязательные для обычных функций.

- Встраиваемые функции определяются с помощью того же синтаксиса как любой другой функции, за исключением того, чтобы они включали **встроенного** ключевое слово в объявлении функции.

- Выражения, передаваемые во встраиваемые функции в качестве аргументов, вычисляются один раз. В некоторых случаях выражения, передаваемые в макросы в качестве аргументов, можно вычислить несколько раз.

В следующем примере показан макрос, преобразующий строчные буквы в прописные.

```cpp
// inline_functions_macro.c
#include <stdio.h>
#include <conio.h>

#define toupper(a) ((a) >= 'a' && ((a) <= 'z') ? ((a)-('a'-'A')):(a))

int main() {
   char ch;
   printf_s("Enter a character: ");
   ch = toupper( getc(stdin) );
   printf_s( "%c", ch );
}
//  Sample Input:  xyz
// Sample Output:  Z
```

Цель выражения `toupper(getc(stdin))` является, что символ должен считываться с консольного устройства (`stdin`) и, при необходимости, переведенную в верхний регистр.

В результате реализации макроса `getc` выполняется один раз для определения того, больше или равен "a" символ, и один раз для определения того, меньше он или равен "z". Если символ находится в этом диапазоне, `getc` выполняется еще раз для преобразования символа в прописную букву. Это означает, что программа ожидает два или три символа, когда в идеальном случае она должна ожидать только один.

Встраиваемые функции позволяют устранить описанную выше проблему.

```cpp
// inline_functions_inline.cpp
#include <stdio.h>
#include <conio.h>

inline char toupper( char a ) {
   return ((a >= 'a' && a <= 'z') ? a-('a'-'A') : a );
}

int main() {
   printf_s("Enter a character: ");
   char ch = toupper( getc(stdin) );
   printf_s( "%c", ch );
}
```

```Output
Sample Input: a
Sample Output: A
```

## <a name="see-also"></a>См. также

[noinline](../cpp/noinline.md)<br/>
[auto_inline](../preprocessor/auto-inline.md)