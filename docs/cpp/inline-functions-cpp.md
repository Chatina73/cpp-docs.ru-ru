---
title: Встраиваемые функции (C++)
description: Ключевое слово C++ inline можно использовать для предложения встроенных функций компилятору.
ms.date: 10/09/2018
f1_keywords:
- __forceinline_cpp
- __inline_cpp
- inline_cpp
- __inline
- _inline
- __forceinline
- _forceinline
helpviewer_keywords:
- inline functions [C++], class members
ms.assetid: 355f120c-2847-4608-ac04-8dda18ffe10c
ms.openlocfilehash: 454a727f0c002dc476e5fdab217efc3dea716e14
ms.sourcegitcommit: 80c8a512b361bd84e38958beb1a1bf6db7434021
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2020
ms.locfileid: "86180713"
---
# <a name="inline-functions-c"></a>Встраиваемые функции (C++)

Функция, определенная в теле объявления класса, является встроенной.

## <a name="example"></a>Пример

В показанном ниже объявлении класса конструктор `Account` является встраиваемой функцией. Функции члена `GetBalance` , `Deposit` и `Withdraw` не указаны как, **`inline`** но могут быть реализованы как встроенные функции.

```cpp
// Inline_Member_Functions.cpp
class Account
{
public:
    Account(double initial_balance) { balance = initial_balance; }
    double GetBalance();
    double Deposit( double Amount );
    double Withdraw( double Amount );
private:
    double balance;
};

inline double Account::GetBalance()
{
    return balance;
}

inline double Account::Deposit( double Amount )
{
    return ( balance += Amount );
}

inline double Account::Withdraw( double Amount )
{
    return ( balance -= Amount );
}
int main()
{
}
```

> [!NOTE]
> В объявлении класса функции были объявлены без **`inline`** ключевого слова. **`inline`** Ключевое слово может быть указано в объявлении класса; результат будет таким же.

Заданная встроенная функция-член должна быть объявлена одинаково в каждом блоке компиляции. Из-за этого ограничения встраиваемые функции работают так же, как если бы они были созданными экземплярами функций. Кроме того, должно существовать только одно определение встраиваемой функции.

Функция-член класса по умолчанию имеет внешнюю компоновку, если только определение этой функции не содержит **`inline`** спецификатор. В предыдущем примере показано, что вам не нужно явно объявлять эти функции с помощью **`inline`** описателя. Использование **`inline`** в определении функции приводит к тому, что оно будет встроенной функцией. Однако не допускается повторное объявление функции **`inline`** после вызова этой функции.

## <a name="inline-__inline-and-__forceinline"></a>`inline`, `__inline` и `__forceinline`.

**`inline`** Описатели и **`__inline`** указывают компилятору вставить копию тела функции в каждое место вызова функции.

Вставка, называемая *встроенным развертыванием* или *встраиванием*, выполняется только в том случае, если анализ стоимости компилятора показывает, что это целесообразно. Встроенное расширение минимизирует затраты на вызов функций за счет потенциальных затрат на больший размер кода.

**`__forceinline`** Ключевое слово переопределяет анализ затратных преимуществ и полагается на ненужное программиста. Соблюдайте осторожность при использовании **`__forceinline`** . Использование беспорядочного использования **`__forceinline`** может привести к увеличению объема кода с незначительным выигрышем в производительности или, в некоторых случаях, даже к снижению производительности (из-за увеличения объема подкачки для большого исполняемого файла).

Применение встраиваемых функций может ускорить выполнение программ, поскольку устраняет нагрузку на вызов функций. Для подставляемых функций выполняются оптимизации кода, которые недоступны для обычных функций.

Параметры и ключевые слова подстановки компилятор обрабатывает как рекомендации. Нет никакой гарантии, что функции будут встроены. Нельзя заставить компилятор подставляемь определенную функцию даже с помощью **`__forceinline`** ключевого слова. При компиляции с **`/clr`** компилятор не будет встроен в функцию, если к функции применены атрибуты безопасности.

**`inline`** Ключевое слово доступно только в C++. **`__inline`** **`__forceinline`** Ключевые слова и доступны как в C, так и в C++. Для совместимости с предыдущими версиями **`_inline`** и **`_forceinline`** являются синонимами для **`__inline`** , и **`__forceinline`** если не указан параметр компилятора, не следует [ `/Za` \( отключать расширения языка)](../build/reference/za-ze-disable-language-extensions.md) .

**`inline`** Ключевое слово указывает компилятору, что предпочтительнее встроенное расширение. Однако компилятор может создать отдельный экземпляр функции и вместо подстановки кода создать стандартную компоновку вызова. В двух случаях может возникнуть такая ситуация:

- Рекурсивные функции.

- Функции, на которые создаются ссылки посредством указателя в любом месте блока трансляции.

Эти причины могут повлиять на встраивание, *как и другие*, на усмотрение компилятора. не следует зависеть от **`inline`** спецификатора, чтобы сделать функцию встроенной.

Как и в случае с обычными функциями, в встроенной функции не определен порядок вычисления аргументов. На самом деле он может отличаться от порядка вычисления аргументов при передаче с использованием обычного протокола вызова функций.

[`/Ob`](../build/reference/ob-inline-function-expansion.md)Параметр оптимизации компилятора позволяет определить, выполняется ли фактическое расширение функции.

[`/LTCG`](../build/reference/ltcg-link-time-code-generation.md)выполняет Межмодульное встраивание независимо от того, запрошены ли они в исходном коде.

### <a name="example-1"></a>Пример 1

```cpp
// inline_keyword1.cpp
// compile with: /c
inline int max( int a , int b ) {
   if( a > b )
      return a;
   return b;
}
```

Функции-члены класса могут быть объявлены встроенными либо с помощью **`inline`** ключевого слова, либо путем помещения определения функции в определение класса.

### <a name="example-2"></a>Пример 2

```cpp
// inline_keyword2.cpp
// compile with: /EHsc /c
#include <iostream>
using namespace std;

class MyClass {
public:
   void print() { cout << i << ' '; }   // Implicitly inline
private:
   int i;
};
```

**Специально для систем Майкрософт**

**`__inline`** Ключевое слово эквивалентно значению **`inline`** .

Даже при использовании **`__forceinline`** компилятор не может встроен код во всех обстоятельствах. Компилятор не может выполнить встраивание функции, если:

- Функция или ее вызывающий объект компилируются вместе с **`/Ob0`** (параметром по умолчанию для отладочных сборок).

- В функции и вызывающем объекте используются разные типы (в одном — обработка исключений C++, а в другом — структурированная).

- Функция имеет переменное число аргументов.

- Функция использует встроенную сборку, если она не скомпилирована с помощью **`/Ox`** , **`/O1`** или **`/O2`** .

- Функция является рекурсивной и не имеет **`#pragma inline_recursion(on)`** набора. С помощью этой директивы выполняется подстановка рекурсивных функций с глубиной по умолчанию, 16 вызовам. Чтобы уменьшить глубину встраивания, используйте [`inline_depth`](../preprocessor/inline-depth.md) директиву pragma.

- Функция является виртуальной, и для нее используется виртуальный вызов. Прямые вызовы виртуальных функций могут подставляться.

- Программа принимает адрес функции, и вызов совершается через указатель на функцию. Прямые вызовы функций, чей адрес был принят, могут подставляться.

- Функция также помечается [`naked`](../cpp/naked-cpp.md) [`__declspec`](../cpp/declspec.md) модификатором.

Если компилятор не может выполнить встраивание функции, объявленной с помощью **`__forceinline`** , создается предупреждение уровня 1, за исключением случаев, когда:

- Функция компилируется с помощью/OD или/Ob0. В таких случаях встраивание не ожидается.

- Функция определена извне, в включенной библиотеке или другой записи преобразования либо является виртуальным целевым объектом вызова или адресатом косвенного вызова. Компилятор не может определить невстроенный код, который не удается найти в текущей записи преобразования.

Рекурсивные функции могут быть заменены встроенным кодом на глубину, заданную [`inline_depth`](../preprocessor/inline-depth.md) директивой pragma, до максимум 16 вызовов. Начиная с этой глубины рекурсивные функции обрабатываются как вызовы на экземпляр функции.  Глубина, для которой рекурсивные функции проверяются встроенным эвристическим методом, не может превышать 16. [`inline_recursion`](../preprocessor/inline-recursion.md)Директива pragma управляет встроенным расширением функции, находящегося в данный момент в расширении. Дополнительные сведения см. в описании параметра компилятора для [расширения встроенной функции](../build/reference/ob-inline-function-expansion.md) (/OB).

**Завершение блока, относящегося только к системам Майкрософт**

Дополнительные сведения об использовании **встроенного** описателя см. в следующих статьях:

- [Подставляемые функции-члены класса](../cpp/inline-functions-cpp.md)

- [Определение встроенных функций C++ с помощью dllexport и dllimport](../cpp/defining-inline-cpp-functions-with-dllexport-and-dllimport.md)

## <a name="when-to-use-inline-functions"></a>Когда использовать встраиваемые функции

Встроенные функции лучше использовать для небольших функций, например функций доступа к закрытым элементам данных. Основной целью таких функций метода доступа является возврат сведений о состоянии объектов. Короткие функции чувствительны к издержек вызовов функций. Более длинные функции тратят пропорционально меньше времени в вызове и возвращают последовательность и выделяют меньше от встраивания.

`Point`Класс можно определить следующим образом:

```cpp
// when_to_use_inline_functions.cpp
class Point
{
public:
    // Define "accessor" functions as
    //  reference types.
    unsigned& x();
    unsigned& y();
private:
    unsigned _x;
    unsigned _y;
};

inline unsigned& Point::x()
{
    return _x;
}
inline unsigned& Point::y()
{
    return _y;
}
int main()
{
}
```

Предполагается, что обработка координат является относительно распространенной операцией в клиенте такого класса, указывая две функции доступа ( `x` и `y` в предыдущем примере), как **`inline`** правило, позволяет экономить издержки:

- вызовы функций (включая передачу параметров и размещение адреса объекта в стеке);

- сохранение кадра стека вызывающего объекта;

- Настройка нового кадра стека

- передачу возвращаемого значения;

- Восстановление старого кадра стека

- Возвращает

## <a name="inline-functions-vs-macros"></a>Встроенные функции и макросы

Встроенные функции похожи на макросы, так как код функции разворачивается в точке вызова во время компиляции. Однако встроенные функции анализируются компилятором, а макросы развертываются препроцессором. В результате, имеется несколько важных различий.

- Встраиваемые функции выполняют все протоколы безопасности типов, обязательные для обычных функций.

- Встроенные функции указываются с использованием того же синтаксиса, что и любая другая функция, за исключением того, что они содержат **`inline`** ключевое слово в объявлении функции.

- Выражения, передаваемые во встраиваемые функции в качестве аргументов, вычисляются один раз. В некоторых случаях выражения, передаваемые в макросы в качестве аргументов, можно вычислить несколько раз.

В следующем примере показан макрос, преобразующий строчные буквы в прописные.

```cpp
// inline_functions_macro.c
#include <stdio.h>
#include <conio.h>

#define toupper(a) ((a) >= 'a' && ((a) <= 'z') ? ((a)-('a'-'A')):(a))

int main() {
   char ch;
   printf_s("Enter a character: ");
   ch = toupper( getc(stdin) );
   printf_s( "%c", ch );
}
//  Sample Input:  xyz
// Sample Output:  Z
```

Цель выражения заключается в том `toupper(getc(stdin))` , что символ должен быть считан с консольного устройства ( `stdin` ) и, при необходимости, преобразован в верхний регистр.

Из-за реализации макроса `getc` выполняется один раз для определения того, что символ больше или равен "a", и один раз, чтобы определить, меньше ли он или равен z. Если символ находится в этом диапазоне, `getc` выполняется еще раз для преобразования символа в прописную букву. Это означает, что программа ожидает два или три символа, когда, в идеале, будет ожидать только один.

Подставляемые функции позволяют устранить описанную выше проблему.

```cpp
// inline_functions_inline.cpp
#include <stdio.h>
#include <conio.h>

inline char toupper( char a ) {
   return ((a >= 'a' && a <= 'z') ? a-('a'-'A') : a );
}

int main() {
   printf_s("Enter a character: ");
   char ch = toupper( getc(stdin) );
   printf_s( "%c", ch );
}
```

```Output
Sample Input: a
Sample Output: A
```

## <a name="see-also"></a>См. также раздел

[`noinline`](../cpp/noinline.md)<br/>
[`auto_inline`](../preprocessor/auto-inline.md)
