---
title: Встраиваемые функции (C++)
ms.date: 10/09/2018
f1_keywords:
- __forceinline_cpp
- __inline_cpp
- inline_cpp
- __inline
- _inline
- __forceinline
- _forceinline
helpviewer_keywords:
- inline functions [C++], class members
ms.assetid: 355f120c-2847-4608-ac04-8dda18ffe10c
ms.openlocfilehash: efaaacc46f63ac1a702ab2110d35fe80727ead1d
ms.sourcegitcommit: a6d63c07ab9ec251c48bc003ab2933cf01263f19
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74857519"
---
# <a name="inline-functions-c"></a>Встраиваемые функции (C++)

Функция, определенная в теле объявления класса, является встроенной.

## <a name="example"></a>Пример

В показанном ниже объявлении класса конструктор `Account` является встраиваемой функцией. Функции элементов `GetBalance`, `Deposit`и `Withdraw` не указаны как **встроенные** , но могут быть реализованы как встроенные функции.

```cpp
// Inline_Member_Functions.cpp
class Account
{
public:
    Account(double initial_balance) { balance = initial_balance; }
    double GetBalance();
    double Deposit( double Amount );
    double Withdraw( double Amount );
private:
    double balance;
};

inline double Account::GetBalance()
{
    return balance;
}

inline double Account::Deposit( double Amount )
{
    return ( balance += Amount );
}

inline double Account::Withdraw( double Amount )
{
    return ( balance -= Amount );
}
int main()
{
}
```

> [!NOTE]
>  В объявлении класса функции были объявлены без ключевого слова **inline** . Ключевое слово **inline** можно указать в объявлении класса. Результат такой же.

Заданная встроенная функция-член должна быть объявлена одинаково в каждом блоке компиляции. Из-за этого ограничения встраиваемые функции работают так же, как если бы они были созданными экземплярами функций. Кроме того, должно существовать только одно определение встраиваемой функции.

Функция-член класса по умолчанию имеет внешнюю компоновку, если только определение этой функции не содержит **встроенный** спецификатор. В предыдущем примере показано, что эти функции не нужно объявлять явным образом с помощью **встроенного** описателя. использование **встроенных** функций в определении функции приводит к тому, что оно будет встроенной функцией. Однако повторное объявление функции как **встроенного** после вызова этой функции недопустимо.

## <a name="inline-__inline-and-__forceinline"></a>Встроенные, __inline и \__forceinline

**Встроенные** описатели и **__inline** предписывает компилятору вставлять копию тела функции в каждое место вызова функции.

Такая вставка (она называется подстановкой или встраиванием) выполняется только в том случае, если проведенный компилятором анализ затрат и выгод показывает, что это может дать выигрыш. Подстановка снимает нагрузку на вызов функции, иногда ценой увеличения размера кода.

Ключевое слово **__forceinline** переопределяет анализ затрат и преимуществ и полагается на ненужное программиста. Соблюдайте осторожность при использовании **__forceinline**. Использование **__forceinline** может привести к увеличению объема кода с незначительным выигрышем в производительности или, в некоторых случаях, даже к снижению производительности (из-за увеличения подкачки более крупного исполняемого файла).

Применение встраиваемых функций может ускорить выполнение программ, поскольку устраняет нагрузку на вызов функций. Для подставляемых функций выполняются оптимизации кода, которые недоступны для обычных функций.

Параметры и ключевые слова подстановки компилятор обрабатывает как рекомендации. Подстановка функции не гарантируется. Нельзя заставить компилятор подставляемь определенную функцию даже с ключевым словом **__forceinline** . При компиляции с **параметром/CLR**компилятор не будет встроен в функцию, если к ней применены атрибуты безопасности.

Ключевое слово **inline** доступно только в C++. Ключевые слова **__inline** и **__forceinline** доступны как в C, так C++и в. Для совместимости с предыдущими версиями **_inline** и **_forceinline** являются синонимами для **__inline**и **__forceinline** , если не задан параметр компилятора [/Za \(отключить расширения языка)](../build/reference/za-ze-disable-language-extensions.md) .

Ключевое слово **inline** сообщает компилятору, что предпочтительнее встроенное расширение. Однако компилятор может создать отдельный экземпляр функции и вместо подстановки кода создать стандартную компоновку вызова. Существует две ситуации, в которых это может происходить.

- Рекурсивные функции.

- Функции, на которые создаются ссылки посредством указателя в любом месте блока трансляции.

Эти причины могут повлиять на встраивание, *как и другие*, на усмотрение компилятора. не следует зависеть от **встроенного** описателя, чтобы сделать функцию встроенной.

Как при использовании обычных функций, для встраиваемых функций нет заданного порядка вычисления аргументов. Фактически он может отличаться от порядка, в котором аргументы вычисляются при передаче с использованием обычного протокола вызова функций.

Параметр оптимизации компилятора [/Ob](../build/reference/ob-inline-function-expansion.md) помогает определить, выполняется ли фактическое расширение функции.

[/LTCG](../build/reference/ltcg-link-time-code-generation.md) выполняет Межмодульное встраивание независимо от того, был ли он запрошен в исходном коде.

### <a name="example-1"></a>Пример 1

```cpp
// inline_keyword1.cpp
// compile with: /c
inline int max( int a , int b ) {
   if( a > b )
      return a;
   return b;
}
```

Функции-члены класса могут быть объявлены как встроенные с помощью **встроенного** ключевого слова или путем помещения определения функции в определение класса.

### <a name="example-2"></a>Пример 2

```cpp
// inline_keyword2.cpp
// compile with: /EHsc /c
#include <iostream>
using namespace std;

class MyClass {
public:
   void print() { cout << i << ' '; }   // Implicitly inline
private:
   int i;
};
```

**Блок, относящийся только к системам Майкрософт**

Ключевое слово **__inline** эквивалентно **встроенному**.

Даже при использовании **__forceinline**компилятор не может выполнить встроенный код во всех обстоятельствах. Компилятор не выполняет подстановку, если:

- Функция или вызывающий ее объект скомпилированы с параметром /Ob0 (параметр по умолчанию для отладочной сборки).

- В функции и вызывающем объекте используются разные типы (в одном — обработка исключений C++, а в другом — структурированная).

- Функция имеет переменное число аргументов.

- В функции используется встроенный код ассемблера (кроме случаев компиляции с параметром /Og, /Ox, /O1 или /O2).

- Функция является рекурсивной и не сопровождается **#pragma inline_recursion (on)** . С помощью этой директивы выполняется подстановка рекурсивных функций с глубиной по умолчанию, 16 вызовам. Чтобы уменьшить глубину встраивания, используйте директиву pragma [inline_depth](../preprocessor/inline-depth.md) .

- Функция является виртуальной, и для нее используется виртуальный вызов. Прямые вызовы виртуальных функций могут подставляться.

- Программа принимает адрес функции, и вызов совершается через указатель на функцию. Прямые вызовы функций, чей адрес был принят, могут подставляться.

- Функция также помечается модификатором [naked](../cpp/naked-cpp.md) [__declspec](../cpp/declspec.md) .

Если компилятор не может выполнить встраивание функции, объявленной с **__forceinline**, создается предупреждение уровня 1, за исключением случаев, когда:

- Функция компилируется с помощью/OD или/Ob0. В таких случаях встраивание не ожидается.

- Функция определена извне, в включенной библиотеке или другой записи преобразования либо является виртуальным целевым объектом вызова или адресатом косвенного вызова. Компилятор не может определить невстроенный код, который не удается найти в текущей записи преобразования.

Рекурсивные функции можно заменить на глубину, указанную директивой pragma [inline_depth](../preprocessor/inline-depth.md) , до 16 вызовов. Начиная с этой глубины рекурсивные функции обрабатываются как вызовы на экземпляр функции.  Глубина, до которой эвристический поиск для подстановки функций проверяет рекурсивные функции, не может превышать 16 вызовов. Директива pragma [inline_recursion](../preprocessor/inline-recursion.md) управляет встроенным расширением функции, находящегося в данный момент в процессе расширения. Дополнительные сведения см. в описании параметра компилятора для [расширения встроенной функции](../build/reference/ob-inline-function-expansion.md) (/OB).

**Завершение блока, относящегося только к системам Майкрософт**

Дополнительные сведения об использовании **встроенного** описателя см. в следующих статьях:

- [Встроенные функции элементов класса](../cpp/inline-functions-cpp.md)

- [Определение встроенных функций C++ с помощью dllexport и dllimport](../cpp/defining-inline-cpp-functions-with-dllexport-and-dllimport.md)

## <a name="when-to-use-inline-functions"></a>Когда использовать встраиваемые функции

Встроенные функции лучше использовать для небольших функций, например функций доступа к закрытым элементам данных. Основное назначение таких одно- и двухстрочных функций метода доступа — возвращение сведений о состоянии объектов; короткие функции чувствительны к рабочей нагрузке вызовов функций. Более длинные функции тратят пропорционально меньше времени на выполнение последовательности вызова и возврата. Встраивание дает им меньше преимуществ.

Класс `Point` можно определить следующим образом:

```cpp
// when_to_use_inline_functions.cpp
class Point
{
public:
    // Define "accessor" functions as
    //  reference types.
    unsigned& x();
    unsigned& y();
private:
    unsigned _x;
    unsigned _y;
};

inline unsigned& Point::x()
{
    return _x;
}
inline unsigned& Point::y()
{
    return _y;
}
int main()
{
}
```

При условии, что управление координатами является относительно распространенной операцией в клиенте такого класса, при указании двух функций доступа (`x` и `y` в предыдущем примере) в качестве **встроенных** обычно сохраняются такие затраты:

- вызовы функций (включая передачу параметров и размещение адреса объекта в стеке);

- сохранение кадра стека вызывающего объекта;

- настройку нового кадра стека;

- передачу возвращаемого значения;

- восстановление старого кадра стека;

- Назад

## <a name="inline-functions-vs-macros"></a>Встроенные функции и макросы

Хотя встраиваемые функции похожи на макросы (поскольку код функции разворачивается в точке вызова во время компиляции), встраиваемые функции анализируются компилятором, тогда как макросы разворачиваются препроцессором. В результате, имеется несколько важных различий.

- Встраиваемые функции выполняют все протоколы безопасности типов, обязательные для обычных функций.

- Встроенные функции указываются с использованием того же синтаксиса, что и любая другая функция, за исключением того, что они содержат ключевое слово **inline** в объявлении функции.

- Выражения, передаваемые во встраиваемые функции в качестве аргументов, вычисляются один раз. В некоторых случаях выражения, передаваемые в макросы в качестве аргументов, можно вычислить несколько раз.

В следующем примере показан макрос, преобразующий строчные буквы в прописные.

```cpp
// inline_functions_macro.c
#include <stdio.h>
#include <conio.h>

#define toupper(a) ((a) >= 'a' && ((a) <= 'z') ? ((a)-('a'-'A')):(a))

int main() {
   char ch;
   printf_s("Enter a character: ");
   ch = toupper( getc(stdin) );
   printf_s( "%c", ch );
}
//  Sample Input:  xyz
// Sample Output:  Z
```

Цель выражения `toupper(getc(stdin))` заключается в том, что символ должен быть считан с консольного устройства (`stdin`) и при необходимости преобразуется в верхний регистр.

В результате реализации макроса `getc` выполняется один раз для определения того, больше или равен "a" символ, и один раз для определения того, меньше он или равен "z". Если символ находится в этом диапазоне, `getc` выполняется еще раз для преобразования символа в прописную букву. Это означает, что программа ожидает два или три символа, когда в идеальном случае она должна ожидать только один.

Подставляемые функции позволяют устранить описанную выше проблему.

```cpp
// inline_functions_inline.cpp
#include <stdio.h>
#include <conio.h>

inline char toupper( char a ) {
   return ((a >= 'a' && a <= 'z') ? a-('a'-'A') : a );
}

int main() {
   printf_s("Enter a character: ");
   char ch = toupper( getc(stdin) );
   printf_s( "%c", ch );
}
```

```Output
Sample Input: a
Sample Output: A
```

## <a name="see-also"></a>См. также:

[noinline](../cpp/noinline.md)<br/>
[auto_inline](../preprocessor/auto-inline.md)