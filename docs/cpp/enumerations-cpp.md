---
title: Перечисления (C++)
ms.date: 06/01/2018
f1_keywords:
- enum_cpp
helpviewer_keywords:
- declarations, enumerations
- enumerators, declaring
- enum keyword [C++]
- named constants, enumeration declarations
- declaring enumerations
ms.assetid: 081829db-5dca-411e-a53c-bffef315bcb3
ms.openlocfilehash: 67b03256390d5447ae5accc28dd450a7f60f485c
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80180190"
---
# <a name="enumerations-c"></a>Перечисления (C++)

Перечисление — это пользовательский тип, состоящий из набора целочисленных констант, называемых перечислителями.

> [!NOTE]
>  В этой статье рассматривается тип C++ **перечисления** языка ISO Standard и тип **класса Enum** с областью действия (или строго типизированный), представленный в c++ 11. Сведения об **открытых классах enum** или **закрытых типах классов enum** в C++/CLI и C++/CX см. в разделе [Класс Enum](../extensions/enum-class-cpp-component-extensions.md).

## <a name="syntax"></a>Синтаксис

```
// unscoped enum:
enum [identifier] [: type]
{enum-list};

// scoped enum:
enum [class|struct]
[identifier] [: type]
{enum-list};
```

```cpp
// Forward declaration of enumerations  (C++11):
enum A : int; // non-scoped enum must have type specified
enum class B; // scoped enum defaults to int but ...
enum class C : short;  // ... may have any integral underlying type
```

## <a name="parameters"></a>Параметры

*identifier*<br/>
Имя типа, присваиваемое перечислению.

*type*<br/>
Базовый тип перечислителей; все перечислители имеют один базовый тип. Может быть любым целочисленным типом.

*Перечисление-список*<br/>
Разделенный запятыми список перечислителей в перечислении. Каждый перечислитель или имя переменной в области должны быть уникальными. Однако значения могут повторяться. В неограниченном перечислении область является окружающей областью. в перечислении с заданной областью областью является сам *список перечисления* .  В перечислении с заданной областью список может быть пустым, что фактически определяет новый целочисленный тип.

*class*<br/>
С помощью этого ключевого слова в объявлении указывается перечисление с областью видимости, и необходимо указать *идентификатор* . Можно также использовать ключевое слово **struct** вместо **Class**, так как они семантически эквивалентны в данном контексте.

## <a name="enumerator-scope"></a>Область перечислителя

Перечисление предоставляет контекст для описания диапазона значений, которые представлены в виде именованных констант и также называются перечислителями. В первоначальных типах перечислений C и C++ перечислители с неполным имеем являются видимыми внутри области видимости, в которой объявлено перечисление. В ограниченных перечислениях имя перечислителя должно уточняться именем типа перечисления. В следующем примере демонстрируется основное различие между двумя видами перечислений.

```cpp
namespace CardGame_Scoped
{
    enum class Suit { Diamonds, Hearts, Clubs, Spades };

    void PlayCard(Suit suit)
    {
        if (suit == Suit::Clubs) // Enumerator must be qualified by enum type
        { /*...*/}
    }
}

namespace CardGame_NonScoped
{
    enum Suit { Diamonds, Hearts, Clubs, Spades };

    void PlayCard(Suit suit)
    {
        if (suit == Clubs) // Enumerator is visible without qualification
        { /*...*/
        }
    }
}
```

Каждому имени в перечислении присваивается целочисленное значение, которое соответствует определенному месту в порядке значений в перечислении. По умолчанию первому значению присваивается 0, следующему — 1 и т. д., но можно задать значение перечислителя явным образом, как показано ниже:

```cpp
enum Suit { Diamonds = 1, Hearts, Clubs, Spades };
```

Перечислителю `Diamonds` присваивается значение `1`. Если последующим перечислителям не присваиваются явные значения, они получают значение предыдущего перечислителя плюс один. В предыдущем примере `Hearts` имел бы значение 2, `Clubs` — значение 3 и т.д.

Каждый перечислитель обрабатывается как константа и должен иметь уникальное имя в пределах области, где определено **перечисление** (для перечислений с неограниченным диапазоном) или в самом **перечислении** (для перечислений с областью видимости). Значения, задаваемые имена, могут быть неуникальными. Например, для следующего объявления неограниченного перечисления `Suit`:

```cpp
enum Suit { Diamonds = 5, Hearts, Clubs = 4, Spades };
```

значения `Diamonds`, `Hearts`, `Clubs` и `Spades` равны 5, 6, 4 и 5 соответственно. Обратите внимание, что значение 5 используется несколько раз; это допускается, независимо от намерений разработчика. Такие же правила распространяются на ограниченные перечисления.

## <a name="casting-rules"></a>Приведение правил

Неограниченные константы перечисления могут быть неявно преобразованы в **тип int**, но **тип int** никогда не может быть неявно преобразован в значение enum. В следующем примере показано, что пройдет при попытке присвоить переменной `hand` значение, не относящееся к типу `Suit`:

```cpp
int account_num = 135692;
Suit hand;
hand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'
```

Приведение требуется для преобразования **типа int** в перечислитель с областью или вне области действия. Однако неограниченный перечислитель можно преобразовать в целочисленное значение без приведения.

```cpp
int account_num = Hearts; //OK if Hearts is in a unscoped enum
```

Использование подобных неявных преобразований может приводить к непредвиденным побочным эффектам. Чтобы избежать ошибок программирования, связанных с неограниченными перечислениями, значения ограниченных перечислений являются строго типизированными. Ограниченные перечислители должны уточняться именем типа перечисления (идентификатором); они не могут быть неявно преобразованы, как показано в следующем примере:

```cpp
namespace ScopedEnumConversions
{
    enum class Suit { Diamonds, Hearts, Clubs, Spades };

    void AttemptConversions()
    {
        Suit hand;
        hand = Clubs; // error C2065: 'Clubs' : undeclared identifier
        hand = Suit::Clubs; //Correct.
        int account_num = 135692;
        hand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'
        hand = static_cast<Suit>(account_num); // OK, but probably a bug!!!

        account_num = Suit::Hearts; // error C2440: '=' : cannot convert from 'Suit' to 'int'
        account_num = static_cast<int>(Suit::Hearts); // OK
    }
}
```

Обратите внимание, что в строке `hand = account_num;` по-прежнему содержится ошибка, которая происходит при использовании неограниченных перечислений, как показано выше. Эта ошибка устраняется с помощью явного приведения. Однако при использовании ограниченных перечислений попытка преобразования в следующем операторе — `account_num = Suit::Hearts;` — больше не будет разрешена без явного приведения.

## <a name="enums-with-no-enumerators"></a><a name="no_enumerators"></a>Перечисления без перечислителей

**Visual Studio 2017 версии 15,3 и более поздних версий** (доступно с помощью [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)): путем определения перечисления (Regular или с областью видимости) с явным базовым типом и без перечислителей, вы можете использовать новый целочисленный тип, который не имеет неявного преобразования в любой другой тип. Используя этот тип вместо встроенного базового типа, можно исключить потенциальные ошибки для незначительных ошибок, вызванных случайными неявными преобразованиями.

```cpp
enum class byte : unsigned char { };
```

Новый тип является точной копией базового типа и, таким образом, имеет то же соглашение о вызовах, что означает, что его можно использовать в ABI без снижения производительности. Если переменные типа инициализируются с помощью инициализации прямого списка, приведение не требуется. В следующем примере показано, как инициализировать перечисления без перечислителей в различных контекстах:

```cpp
enum class byte : unsigned char { };

enum class E : int { };
E e1{ 0 };
E e2 = E{ 0 };

struct X
{
    E e{ 0 };
    X() : e{ 0 } { }
};

E* p = new E{ 0 };

void f(E e) {};

int main()
{
    f(E{ 0 });
    byte i{ 42 };
    byte j = byte{ 42 };

    // unsigned char c = j; // C2440: 'initializing': cannot convert from 'byte' to 'unsigned char'
    return 0;
}
```

## <a name="see-also"></a>См. также раздел

[Объявления перечислений C](../c-language/c-enumeration-declarations.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)
