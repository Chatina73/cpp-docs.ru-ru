---
title: Перечисления (C++)
ms.date: 06/01/2018
f1_keywords:
- enum_cpp
helpviewer_keywords:
- declarations, enumerations
- enumerators, declaring
- enum keyword [C++]
- named constants, enumeration declarations
- declaring enumerations
ms.assetid: 081829db-5dca-411e-a53c-bffef315bcb3
ms.openlocfilehash: 2a1b3d33534887568c6a55e320e77e0a018cafff
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81366322"
---
# <a name="enumerations-c"></a>Перечисления (C++)

Перечисление — это пользовательский тип, состоящий из набора целочисленных констант, называемых перечислителями.

> [!NOTE]
> В этой статье рассматриваются **типовый enum-enum** Стандартного языка ИСО и типовой (или сильно набранный) тип **класса,** который вводится в СЗ11. Для получения информации об **общедоступных** классах или частных типах **классов enum** в си/CLI и C-CX [см.](../extensions/enum-class-cpp-component-extensions.md)

## <a name="syntax"></a>Синтаксис

```
// unscoped enum:
enum [identifier] [: type]
{enum-list};

// scoped enum:
enum [class|struct]
[identifier] [: type]
{enum-list};
```

```cpp
// Forward declaration of enumerations  (C++11):
enum A : int; // non-scoped enum must have type specified
enum class B; // scoped enum defaults to int but ...
enum class C : short;  // ... may have any integral underlying type
```

## <a name="parameters"></a>Параметры

*Идентификатор*<br/>
Имя типа, присваиваемое перечислению.

*тип*<br/>
Базовый тип перечислителей; все перечислители имеют один базовый тип. Может быть любым целочисленным типом.

*список*<br/>
Разделенный запятыми список перечислителей в перечислении. Каждый перечислитель или имя переменной в области должны быть уникальными. Однако значения могут повторяться. В unscoped enum область представляет собой окружающую область; в масштабе enum область представляет собой *сам список.*  В объеме enum список может быть пустым, что фактически определяет новый интегральный тип.

*class*<br/>
Используя это ключевое слово в декларации, вы указываете, что enum является областью охвата, и *идентификатор* должен быть предоставлен. Вы также можете использовать **ключевое** слово структуры вместо **класса,** так как они семантически эквивалентны в этом контексте.

## <a name="enumerator-scope"></a>Область enumerator

Перечисление предоставляет контекст для описания диапазона значений, которые представлены в виде именованных констант и также называются перечислителями. В первоначальных типах перечислений C и C++ перечислители с неполным имеем являются видимыми внутри области видимости, в которой объявлено перечисление. В ограниченных перечислениях имя перечислителя должно уточняться именем типа перечисления. В следующем примере демонстрируется основное различие между двумя видами перечислений.

```cpp
namespace CardGame_Scoped
{
    enum class Suit { Diamonds, Hearts, Clubs, Spades };

    void PlayCard(Suit suit)
    {
        if (suit == Suit::Clubs) // Enumerator must be qualified by enum type
        { /*...*/}
    }
}

namespace CardGame_NonScoped
{
    enum Suit { Diamonds, Hearts, Clubs, Spades };

    void PlayCard(Suit suit)
    {
        if (suit == Clubs) // Enumerator is visible without qualification
        { /*...*/
        }
    }
}
```

Каждому имени в перечислении присваивается целочисленное значение, которое соответствует определенному месту в порядке значений в перечислении. По умолчанию первому значению присваивается 0, следующему — 1 и т. д., но можно задать значение перечислителя явным образом, как показано ниже:

```cpp
enum Suit { Diamonds = 1, Hearts, Clubs, Spades };
```

Перечислителю `Diamonds` присваивается значение `1`. Если последующим перечислителям не присваиваются явные значения, они получают значение предыдущего перечислителя плюс один. В предыдущем примере `Hearts` имел бы значение 2, `Clubs` — значение 3 и т.д.

Каждый регистратор рассматривается как константа и должен иметь уникальное имя в рамках, где **enum** определяется (для unscoped enums) или в пределах самого **перечисления** (для прицеловых перечислений). Значения, задаваемые имена, могут быть неуникальными. Например, для следующего объявления неограниченного перечисления `Suit`:

```cpp
enum Suit { Diamonds = 5, Hearts, Clubs = 4, Spades };
```

значения `Diamonds`, `Hearts`, `Clubs` и `Spades` равны 5, 6, 4 и 5 соответственно. Обратите внимание, что значение 5 используется несколько раз; это допускается, независимо от намерений разработчика. Такие же правила распространяются на ограниченные перечисления.

## <a name="casting-rules"></a>Приведение правил

Нескопированные константы enum могут быть неявно преобразованы в **Int,** но **int** никогда неявно конвертируется в значение enum. В следующем примере показано, что пройдет при попытке присвоить переменной `hand` значение, не относящееся к типу `Suit`:

```cpp
int account_num = 135692;
Suit hand;
hand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'
```

Бросок необходим для преобразования **int** в объем или нескопированный регистратор. Однако неограниченный перечислитель можно преобразовать в целочисленное значение без приведения.

```cpp
int account_num = Hearts; //OK if Hearts is in a unscoped enum
```

Использование подобных неявных преобразований может приводить к непредвиденным побочным эффектам. Чтобы избежать ошибок программирования, связанных с неограниченными перечислениями, значения ограниченных перечислений являются строго типизированными. Ограниченные перечислители должны уточняться именем типа перечисления (идентификатором); они не могут быть неявно преобразованы, как показано в следующем примере:

```cpp
namespace ScopedEnumConversions
{
    enum class Suit { Diamonds, Hearts, Clubs, Spades };

    void AttemptConversions()
    {
        Suit hand;
        hand = Clubs; // error C2065: 'Clubs' : undeclared identifier
        hand = Suit::Clubs; //Correct.
        int account_num = 135692;
        hand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'
        hand = static_cast<Suit>(account_num); // OK, but probably a bug!!!

        account_num = Suit::Hearts; // error C2440: '=' : cannot convert from 'Suit' to 'int'
        account_num = static_cast<int>(Suit::Hearts); // OK
    }
}
```

Обратите внимание, что в строке `hand = account_num;` по-прежнему содержится ошибка, которая происходит при использовании неограниченных перечислений, как показано выше. Эта ошибка устраняется с помощью явного приведения. Однако при использовании ограниченных перечислений попытка преобразования в следующем операторе — `account_num = Suit::Hearts;` — больше не будет разрешена без явного приведения.

## <a name="enums-with-no-enumerators"></a><a name="no_enumerators"></a>Цифры без регистраторов

**Visual Studio 2017 версия 15.3 и позже** (доступно с [/std:c'17](../build/reference/std-specify-language-standard-version.md)): Определив enum (обычный или объем) с явным базовым типом и без регистраторов, вы можете в действительности ввести новый интегральный тип, который не имеет неявного преобразования в любой другой тип. Используя этот тип вместо встроенного базового типа, можно исключить возможность тонких ошибок, вызванных непреднамеренными неявными преобразованиями.

```cpp
enum class byte : unsigned char { };
```

Новый тип является точной копией базового типа, и поэтому имеет ту же конвенцию вызова, что означает, что он может быть использован в ABI без каких-либо штрафов за производительность. Нет литья не требуется, когда переменные типа инициализированы с помощью прямого списка инициализации. Следующий пример показывает, как инициализировать enums без регистраторов в различных контекстах:

```cpp
enum class byte : unsigned char { };

enum class E : int { };
E e1{ 0 };
E e2 = E{ 0 };

struct X
{
    E e{ 0 };
    X() : e{ 0 } { }
};

E* p = new E{ 0 };

void f(E e) {};

int main()
{
    f(E{ 0 });
    byte i{ 42 };
    byte j = byte{ 42 };

    // unsigned char c = j; // C2440: 'initializing': cannot convert from 'byte' to 'unsigned char'
    return 0;
}
```

## <a name="see-also"></a>См. также раздел

[Объявления перечислений C](../c-language/c-enumeration-declarations.md)<br/>
[Keywords](../cpp/keywords-cpp.md)
