---
title: Перечисления (C++)
ms.date: 06/01/2018
f1_keywords:
- enum_cpp
helpviewer_keywords:
- declarations, enumerations
- enumerators, declaring
- enum keyword [C++]
- named constants, enumeration declarations
- declaring enumerations
ms.assetid: 081829db-5dca-411e-a53c-bffef315bcb3
ms.openlocfilehash: caec9ea7ac5482ff23b73676a3fd7b3d25ad293f
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62398944"
---
# <a name="enumerations-c"></a>Перечисления (C++)

Перечисление — это пользовательский тип, состоящий из набора целочисленных констант, называемых перечислителями.

> [!NOTE]
>  В этой статье рассматриваются языка C++ стандарта ISO **перечисления** типа и области (или со строгой типизацией) **класс перечисления** тип, который впервые введен в C ++ 11. Сведения о **открытый класс перечисления** или **класс закрытого перечисления** типы в C++выполняет и C++/CX, см. в разделе [класс перечисления](../extensions/enum-class-cpp-component-extensions.md).

## <a name="syntax"></a>Синтаксис

```
// unscoped enum:
enum [identifier] [: type]
{enum-list};

// scoped enum:
enum [class|struct]
[identifier] [: type]
{enum-list};
```

```cpp
// Forward declaration of enumerations  (C++11):
enum A : int; // non-scoped enum must have type specified
enum class B; // scoped enum defaults to int but ...
enum class C : short;  // ... may have any integral underlying type
```

## <a name="parameters"></a>Параметры

*identifier*<br/>
Имя типа, присваиваемое перечислению.

*type*<br/>
Базовый тип перечислителей; все перечислители имеют один базовый тип. Может быть любым целочисленным типом.

*Enum-list*<br/>
Разделенный запятыми список перечислителей в перечислении. Каждый перечислитель или имя переменной в области должны быть уникальными. Однако значения могут повторяться. В неограниченном перечислении видимости является окружающая область; в ограниченном перечислении областью видимости является *перечисления списка* сам.  В ограниченном перечислении областью, список может быть пустым в силе, который определяет новый целочисленный тип.

*class*<br/>
Используя это ключевое слово в объявлении, указать, что перечисление ограничено и *идентификатор* должно быть указано. Можно также использовать **структуры** ключевое слово вместо **класс**, как они семантически эквивалентны, в этом контексте.

## <a name="enumerator-scope"></a>Область перечислителя

Перечисление предоставляет контекст для описания диапазона значений, которые представлены в виде именованных констант и также называются перечислителями. В первоначальных типах перечислений C и C++ перечислители с неполным имеем являются видимыми внутри области видимости, в которой объявлено перечисление. В ограниченных перечислениях имя перечислителя должно уточняться именем типа перечисления. В следующем примере демонстрируется основное различие между двумя видами перечислений.

```cpp
namespace CardGame_Scoped
{
    enum class Suit { Diamonds, Hearts, Clubs, Spades };

    void PlayCard(Suit suit)
    {
        if (suit == Suit::Clubs) // Enumerator must be qualified by enum type
        { /*...*/}
    }
}

namespace CardGame_NonScoped
{
    enum Suit { Diamonds, Hearts, Clubs, Spades };

    void PlayCard(Suit suit)
    {
        if (suit == Clubs) // Enumerator is visible without qualification
        { /*...*/
        }
    }
}
```

Каждому имени в перечислении присваивается целочисленное значение, которое соответствует определенному месту в порядке значений в перечислении. По умолчанию первому значению присваивается 0, следующему — 1 и т. д., но можно задать значение перечислителя явным образом, как показано ниже:

```cpp
enum Suit { Diamonds = 1, Hearts, Clubs, Spades };
```

Перечислителю `Diamonds` присваивается значение `1`. Если последующим перечислителям не присваиваются явные значения, они получают значение предыдущего перечислителя плюс один. В предыдущем примере `Hearts` имел бы значение 2, `Clubs` — значение 3 и т.д.

Каждый перечислитель обрабатывается как константа и должен иметь уникальное имя в области где **перечисления** определяется (для неограниченных перечислений) или в **перечисления** сам (для ограниченных перечислений). Значения, задаваемые имена, могут быть неуникальными. Например, для следующего объявления неограниченного перечисления `Suit`:

```cpp
enum Suit { Diamonds = 5, Hearts, Clubs = 4, Spades };
```

значения `Diamonds`, `Hearts`, `Clubs` и `Spades` равны 5, 6, 4 и 5 соответственно. Обратите внимание, что значение 5 используется несколько раз; это допускается, независимо от намерений разработчика. Такие же правила распространяются на ограниченные перечисления.

## <a name="casting-rules"></a>Приведение правил

Неограниченные перечисления-константы могут неявно преобразовываться к **int**, но **int** не может быть неявно преобразован в значение перечисления. В следующем примере показано, что пройдет при попытке присвоить переменной `hand` значение, не относящееся к типу `Suit`:

```cpp
int account_num = 135692;
Suit hand;
hand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'
```

Необходимо приведение для преобразования **int** на ограниченный или неограниченный перечислитель. Однако неограниченный перечислитель можно преобразовать в целочисленное значение без приведения.

```cpp
int account_num = Hearts; //OK if Hearts is in a unscoped enum
```

Использование подобных неявных преобразований может приводить к непредвиденным побочным эффектам. Чтобы избежать ошибок программирования, связанных с неограниченными перечислениями, значения ограниченных перечислений являются строго типизированными. Ограниченные перечислители должны уточняться именем типа перечисления (идентификатором); они не могут быть неявно преобразованы, как показано в следующем примере:

```cpp
namespace ScopedEnumConversions
{
    enum class Suit { Diamonds, Hearts, Clubs, Spades };

    void AttemptConversions()
    {
        Suit hand;
        hand = Clubs; // error C2065: 'Clubs' : undeclared identifier
        hand = Suit::Clubs; //Correct.
        int account_num = 135692;
        hand = account_num; // error C2440: '=' : cannot convert from 'int' to 'Suit'
        hand = static_cast<Suit>(account_num); // OK, but probably a bug!!!

        account_num = Suit::Hearts; // error C2440: '=' : cannot convert from 'Suit' to 'int'
        account_num = static_cast<int>(Suit::Hearts); // OK
    }
}
```

Обратите внимание, что в строке `hand = account_num;` по-прежнему содержится ошибка, которая происходит при использовании неограниченных перечислений, как показано выше. Эта ошибка устраняется с помощью явного приведения. Однако при использовании ограниченных перечислений попытка преобразования в следующем операторе — `account_num = Suit::Hearts;` — больше не будет разрешена без явного приведения.

## <a name="no_enumerators"></a> Перечисления атрибутом не перечислителей

**Visual Studio 2017 версии 15.3 и более поздние версии** (состав [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)): Определив перечисления (обычный или областью действия) с помощью явного базового типа и не перечислители, фактически можно ввести новый целочисленный тип, который не имеет неявного преобразования к любому другому типу. С помощью этого типа вместо встроенных базового типа, можно исключить вероятность ошибкам из-за случайных неявные преобразования.

```cpp
enum class byte : unsigned char { };
```

Новый тип является точную копию базового типа и, следовательно, соглашение о вызове, это означает, что он может использоваться через ABI без снижения производительности. Преобразование не требуется, когда переменные типа инициализируются с помощью инициализации прямого списка. В следующем примере показано, как для инициализации перечисления атрибутом не перечислители в различных контекстах:

```cpp
enum class byte : unsigned char { };

enum class E : int { };
E e1{ 0 };
E e2 = E{ 0 };

struct X
{
    E e{ 0 };
    X() : e{ 0 } { }
};

E* p = new E{ 0 };

void f(E e) {};

int main()
{
    f(E{ 0 });
    byte i{ 42 };
    byte j = byte{ 42 };

    // unsigned char c = j; // C2440: 'initializing': cannot convert from 'byte' to 'unsigned char'
    return 0;
}
```

## <a name="see-also"></a>См. также

[Объявления перечислений C](../c-language/c-enumeration-declarations.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)