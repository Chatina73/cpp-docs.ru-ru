---
description: 'Дополнительные сведения: абстрактные классы (C++)'
title: Абстрактные классы (C++)
ms.date: 02/18/2021
helpviewer_keywords:
- classes [C++], abstract
- base classes [C++], abstract classes [C++]
- abstract classes [C++]
- derived classes [C++], abstract classes [C++]
ms.openlocfilehash: 375dd40c41a9de2b5b66a295cfccaae04d4ccbb8
ms.sourcegitcommit: 10baf2761694a7d9f478e5609f24158ed8258a44
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2021
ms.locfileid: "107282626"
---
# <a name="abstract-classes-c"></a>Абстрактные классы (C++)

Абстрактные классы используются в качестве обобщенных концепций, на основе которых можно создавать более конкретные производные классы. Нельзя создать объект типа абстрактного класса. Однако можно использовать указатели и ссылки на абстрактные типы классов.

Абстрактный класс создается путем объявления по крайней мере одной чистой виртуальной функции члена. Это виртуальная функция, объявленная с помощью синтаксиса *чистого* описателя ( `= 0` ). Классы, производные от абстрактного класса, должны реализовывать чисто виртуальную функцию; в противном случае они также будут абстрактными.

Рассмотрим пример, представленный в [виртуальных функциях](../cpp/virtual-functions.md). Класс `Account` создан для того, чтобы предоставлять общие функции, но объекты типа `Account` имеют слишком общий характер для практического применения. Это означает `Account` хороший кандидат для абстрактного класса:

```cpp
// deriv_AbstractClasses.cpp
// compile with: /LD
class Account {
public:
   Account( double d );   // Constructor.
   virtual double GetBalance();   // Obtain balance.
   virtual void PrintBalance() = 0;   // Pure virtual function.
private:
    double _balance;
};
```

Единственное различие между этим и предыдущим объявлениями состоит в том, что функция `PrintBalance` объявлена со спецификатором чисто виртуальной функции pure (`= 0`).

## <a name="restrictions-on-abstract-classes"></a>Ограничения на использование абстрактных классов

Абстрактные классы нельзя использовать для:

- переменных и данных членов;

- типов аргументов;

- типов возвращаемых функциями значений;

- типов явных преобразований.

Если конструктор абстрактного класса вызывает чисто виртуальную функцию, прямо или косвенно, результат не определен. Однако конструкторы и деструкторы абстрактных классов могут вызывать другие функции-члены.

## <a name="defined-pure-virtual-functions"></a>Определенные чистые виртуальные функции

Чистые виртуальные функции в абстрактных классах могут быть *определены* или иметь реализацию. Вызывать эти функции можно только с помощью полного синтаксиса:

*abstract — имя класса*::*Function-Name*()

Определенные чистые виртуальные функции полезны при проектировании иерархий классов, базовые классы которых содержат чистые виртуальные деструкторы. Это обусловлено тем, что деструкторы базового класса всегда вызываются во время уничтожения объекта. Рассмотрим следующий пример.

```cpp
// deriv_RestrictionsOnUsingAbstractClasses.cpp
// Declare an abstract base class with a pure virtual destructor.
// It's the simplest possible abstract class.
class base
{
public:
    base() {}
    // To define the virtual destructor outside the class:
    virtual ~base() = 0;
    // Microsoft-specific extension to define it inline:
//  virtual ~base() = 0 {};
};

base::~base() {} // required if not using Microsoft extension

class derived : public base
{
public:
    derived() {}
    ~derived() {}
};

int main()
{
    derived aDerived; // destructor called when it goes out of scope
}
```

В примере показано, как расширение компилятора Майкрософт позволяет добавить встроенное определение в чистый виртуальный `~base()` . Его также можно определить за пределами класса с помощью `base::~base() {}` .

Когда объект `aDerived` выходит из области действия, `derived` вызывается деструктор класса. Компилятор создает код для неявного вызова деструктора класса `base` после `derived` деструктора. Пустая реализация чисто виртуальной функции `~base` гарантирует, что для функции существует хотя бы определенная реализация. Без него компоновщик создает неразрешенную ошибку внешнего символа для неявного вызова.

> [!NOTE]
> В предыдущем примере чистая виртуальная функция `base::~base` вызывается неявно из `derived::~derived`. Кроме того, можно явно вызывать чистые виртуальные функции, используя полное имя функции-члена. Такие функции должны иметь реализацию, или вызов приводит к ошибке во время компоновки.

## <a name="see-also"></a>См. также раздел

[Наследование](../cpp/inheritance-cpp.md)
