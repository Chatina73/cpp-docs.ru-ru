---
title: Лямбда-выражения в C++
ms.date: 05/07/2019
helpviewer_keywords:
- lambda expressions [C++]
- lambda expressions [C++], overview
- lambda expressions [C++], vs. function objects
ms.assetid: 713c7638-92be-4ade-ab22-fa33417073bf
ms.openlocfilehash: e206ea8d67bb333065bf43f7f9c2dc373a5a5258
ms.sourcegitcommit: a6d63c07ab9ec251c48bc003ab2933cf01263f19
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74857493"
---
# <a name="lambda-expressions-in-c"></a>Лямбда-выражения в C++

В C++ 11 и более поздних версиях лямбда-выражение, часто называемое *лямбда*– — это удобный способ определения объекта анонимной функции ( *замыкания*) непосредственно в расположении, где оно вызывается или передается в качестве аргумента функции. Обычно лямбда-выражения используются для инкапсуляции нескольких строк кода, передаваемых алгоритмам или асинхронным методам. В этой статье приводится определение лямбда-выражений, их сравнение с другими методами программирования, описание их преимуществ и простой пример.

## <a name="related-topics"></a>См. также

- [Лямбда-выражения и объекты функций](lambda-expression-syntax.md)
- [Работа с лямбда-выражениями](examples-of-lambda-expressions.md)
- [лямбда-выражения constexpr](lambda-expressions-constexpr.md)

## <a name="parts-of-a-lambda-expression"></a>Структура лямбда-выражения

В стандарте ISO C++ демонстрируется простое лямбда-выражение, передаваемое функции `std::sort()` в качестве третьего аргумента:

```cpp
#include <algorithm>
#include <cmath>

void abssort(float* x, unsigned n) {
    std::sort(x, x + n,
        // Lambda expression begins
        [](float a, float b) {
            return (std::abs(a) < std::abs(b));
        } // end of lambda expression
    );
}
```

На следующем рисунке показана структура лямбда-выражения:

![Структурные элементы лямбда-выражения](../cpp/media/lambdaexpsyntax.png "Структурные элементы лямбда-выражения")

1. *предложение Capture* (также известное как элемент *объявления лямбда-выражения* в C++ спецификации).

1. *список параметров* Используемых. (Также называется *лямбда-объявлением*)

1. *изменяемая спецификация* Используемых.

1. *Спецификация Exception* Используемых.

1. *замыкающий-возвращаемый тип* Используемых.

1. *тело лямбда-выражения*.

### <a name="capture-clause"></a>Предложение фиксации

Лямбда-выражение может добавлять новые переменные в тексте (в **C++ 14**), а также получать доступ к переменным из окружающей области или *записывать*их. Лямбда-выражение начинается с предложения Capture (*лямбда-* знаком в стандартном синтаксисе), который указывает, какие переменные захватываются и является ли захват значением или ссылкой. Доступ к переменным с префиксом с амперсандом (`&`) осуществляется по ссылке, а к переменным без префикса — по значению.

Пустое предложение фиксации (`[ ]`) показывает, что тело лямбда-выражения не осуществляет доступ к переменным во внешней области видимости.

Режим записи по умолчанию (*захват-по умолчанию* в стандартном синтаксисе) можно использовать для указания способа записи всех внешних переменных, на которые имеются ссылки в лямбда-выражении: `[&]` означает, что все переменные, на которые вы ссылаетесь, записываются по ссылке, и `[=]` означает, что они записываются по значению. Можно сначала использовать режим фиксации по умолчанию, а затем применить для определенных переменных другой режим. Например, если тело лямбда-выражения осуществляет доступ к внешней переменной `total` по ссылке, а к внешней переменной `factor` по значению, следующие предложения фиксации эквивалентны:

```cpp
[&total, factor]
[factor, &total]
[&, factor]
[factor, &]
[=, &total]
[&total, =]
```

При использовании записи по умолчанию фиксируются только переменные, указанные в лямбда-выражении.

Если предложение Capture включает `&`отслеживания по умолчанию, то `identifier` в `capture` этого предложения записи не может иметь `& identifier`формы. Аналогично, если предложение Capture включает `=`захвата по умолчанию, то ни `capture` этого предложения записи не могут иметь `= identifier`формы. Идентификатор или **это** значение не может использоваться в предложении Capture более одного раза. В следующем фрагменте кода приводится несколько примеров.

```cpp
struct S { void f(int i); };

void S::f(int i) {
    [&, i]{};      // OK
    [&, &i]{};     // ERROR: i preceded by & when & is the default
    [=, this]{};   // ERROR: this when = is the default
    [=, *this]{ }; // OK: captures this by value. See below.
    [i, i]{};      // ERROR: i repeated
}
```

Захват, за которым следует многоточие, — это расширение пакета, как показано в следующем примере [шаблона Variadic](../cpp/ellipses-and-variadic-templates.md) :

```cpp
template<class... Args>
void f(Args... args) {
    auto x = [args...] { return g(args...); };
    x();
}
```

Чтобы использовать лямбда-выражения в теле метода класса, передайте **этот** указатель в предложение Capture, чтобы предоставить доступ к методам и членам данных включающего класса.

**Visual Studio 2017 версии 15,3 и более поздних версий** (доступно с [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)): **этот** указатель может быть записан по значению путем указания `*this` в предложении Capture. Захват по значению означает, что весь *замыкание*, которое является объектом анонимной функции, енкапулатес лямбда-выражение, копируется в каждый сайт вызова, где вызывается лямбда. Захват по значению полезен, когда лямбда-выражение будет выполняться в параллельных или асинхронных операциях, особенно на определенных аппаратных архитектурах, таких как NUMA.

Пример, демонстрирующий использование лямбда-выражений с методами класса, см. в разделе "пример: использование лямбда-выражения в методе" в [примерах лямбда-выражений](../cpp/examples-of-lambda-expressions.md).

При использовании предложения фиксации рекомендуется помнить об этих важных аспектах, особенно при использовании лямбда-выражений с многопоточностью:

- Фиксацию ссылок можно использовать для изменения переменных снаружи, тогда как фиксацию значений нельзя. (**изменяемое** позволяет изменять копии, но не оригиналы.)

- Фиксация ссылок отражает изменение переменных снаружи, тогда как фиксация значений — нет.

- Фиксация ссылки вводит зависимость от времени существования, тогда как фиксация значения не обладает зависимостями от времени существования. Это особенно важно в случае асинхронного использования лямбда-выражений. Если в асинхронном лямбда-выражении по ссылке фиксируется локальная переменная, вполне вероятно, что к моменту его вызова она станет недоступной, что вызовет исключение нарушения прав доступа во время выполнения.

### <a name="generalized-capture-c-14"></a>Обобщенная фиксация (C++14)

В C++14 вы можете объявлять и инициализировать новые переменные в предложении фиксации. Для этого не требуется, чтобы эти переменные существовали во внешней области видимости лямбда-функции. Инициализация может быть выражена в качестве любого произвольного выражения. Тип новой переменной определяется типом, который создается выражением. Одно из преимуществ этой возможности заключается в том, что в C++14 таким образом можно фиксировать переменные из окружающей области видимости, доступные только для перемещения (например std::unique_ptr), и использовать их в лямбда-выражении.

```cpp
pNums = make_unique<vector<int>>(nums);
//...
      auto a = [ptr = move(pNums)]()
        {
           // use ptr
        };
```

### <a name="parameter-list"></a>Список параметров

В дополнение к возможности фиксации переменных, лямбда-выражения могут принимать входные параметры. Список параметров (*лямбда-декларатор* в стандартном синтаксисе) является необязательным и в большинстве аспектов напоминает список параметров для функции.

```cpp
auto y = [] (int first, int second)
{
    return first + second;
};
```

В  **C++ 14**, если тип параметра является универсальным, можно использовать ключевое слово auto в качестве спецификатора типа. Это отдает компилятору команду создать оператор вызова функции в качестве шаблона. Каждый экземпляр ключевого слова auto в списке параметров эквивалентен параметру отдельного типа.

```cpp
auto y = [] (auto first, auto second)
{
    return first + second;
};
```

Лямбда-выражение может принимать другое лямбда-выражение в качестве своего аргумента. Дополнительные сведения см. в разделе "лямбда-выражения более высокого порядка" статьи [Примеры лямбда-выражений](../cpp/examples-of-lambda-expressions.md).

Поскольку список параметров является необязательным, можно опустить пустые скобки, если аргументы не передаются в лямбда-выражение, а лямбда-декларатор не содержит *спецификацию Exception*, *замыкающего-возвращаемого типа*или **изменяемого**.

### <a name="mutable-specification"></a>Отключаемая спецификация

Как правило, оператор вызова функции лямбда-выражения является константой по значению, но использование ключевого слова **mutable** отменяет это. Он не создает изменяемые элементы данных. Отключаемая спецификация позволяет телу лямбда-выражения изменять переменные, захваченные по значению. В некоторых примерах, приведенных далее в этой статье, показано, как использовать **Изменяемые**.

### <a name="exception-specification"></a>Спецификация исключений

Можно использовать спецификацию исключений `noexcept`, чтобы указать, что лямбда-выражение не создает исключений. Как и в случае с обычными C++ функциями, компилятор Майкрософт создает предупреждение [C4297](../error-messages/compiler-warnings/compiler-warning-level-1-c4297.md) , если лямбда-выражение объявляет спецификацию исключения `noexcept` и тело лямбда-выражения создает исключение, как показано ниже:

```cpp
// throw_lambda_expression.cpp
// compile with: /W4 /EHsc
int main() // C4297 expected
{
   []() noexcept { throw 5; }();
}
```

Дополнительные сведения см. в разделе [спецификации исключений (throw)](../cpp/exception-specifications-throw-cpp.md).

### <a name="return-type"></a>Тип возвращаемого значения

Возвращаемый тип лямбда-выражения выводится автоматически. Не обязательно использовать ключевое слово [Auto](../cpp/auto-cpp.md) , если не указан *завершающий возвращаемый тип*. *Замыкающий возвращаемый тип* напоминает часть возвращаемого типа в обычном методе или функции. Однако тип возвращаемого значения следует списку параметров, и необходимо включить ключевое слово `->` элемента trailing-return-type перед типом возвращаемого значения.

Можно опустить часть возвращаемого типа лямбда-выражения, если тело лямбда-выражения содержит только один оператор return или лямбда-выражение не возвращает значение. Если тело лямбда-выражения содержит один оператор return, компилятор выводит тип возвращаемого значения из типа возвращаемого выражения. В противном случае компилятор выводит возвращаемый тип в **значение void**. Рассмотрим следующие примеры кода, иллюстрирующие этот принцип.

```cpp
auto x1 = [](int i){ return i; }; // OK: return type is int
auto x2 = []{ return{ 1, 2 }; };  // ERROR: return type is void, deducing
                                  // return type from braced-init-list is not valid
```

Лямбда-выражение может создавать другое лямбда-выражение в качестве своего возвращаемого значения. Дополнительные сведения см. в разделе "лямбда-выражения более высокого порядка" в [примерах лямбда-выражений](../cpp/examples-of-lambda-expressions.md).

### <a name="lambda-body"></a>Тело лямбда-выражения

Тело лямбда-выражения (*составной оператор* в стандартном синтаксисе) в лямбда-выражении может содержать все, что может содержать тело обычного метода или функции. Тело обычной функции и лямбда-выражения может осуществлять доступ к следующим типам переменных:

- Фиксированные переменные из внешней области видимости (см. выше).

- Параметры

- Локально объявленные переменные

- Члены данных класса, объявленные внутри **класса и** захваченные

- Любая переменная, которая имеет статическую длительность хранения (например, глобальная переменная)

В следующем примере содержится лямбда-выражение, которое явно фиксирует переменную `n` по значению и неявно фиксирует переменную `m` по ссылке.

```cpp
// captures_lambda_expression.cpp
// compile with: /W4 /EHsc
#include <iostream>
using namespace std;

int main()
{
   int m = 0;
   int n = 0;
   [&, n] (int a) mutable { m = ++n + a; }(4);
   cout << m << endl << n << endl;
}
```

```Output
5
0
```

Поскольку переменная `n` фиксируется по значению, ее значение после вызова лямбда-выражения остается равным `0`. **Изменяемая** спецификация позволяет изменять `n` в лямбда-выражении.

Несмотря на то что лямбда-выражение может фиксировать только переменные с автоматической длительностью хранения, в теле лямбда-выражения можно использовать переменные, которые имеют статическую длительность хранения. В следующем примере функция `generate` и лямбда-выражение используются для присвоения значения каждому элементу объекта `vector`. Лямбда-выражение изменяет статическую переменную для получения значения следующего элемента.

```cpp
void fillVector(vector<int>& v)
{
    // A local static variable.
    static int nextValue = 1;

    // The lambda expression that appears in the following call to
    // the generate function modifies and uses the local static
    // variable nextValue.
    generate(v.begin(), v.end(), [] { return nextValue++; });
    //WARNING: this is not thread-safe and is shown for illustration only
}
```

Дополнительные сведения см. в разделе [Generate](../standard-library/algorithm-functions.md#generate).

В следующем примере кода используется функция из предыдущего примера, и добавляется пример лямбда-выражения, использующего алгоритм C++ стандартной библиотеки `generate_n`. Это лямбда-выражение назначает элемент объекта `vector` сумме предыдущих двух элементов. Ключевое слово **mutable** используется для того, чтобы тело лямбда-выражения могла изменять свои копии внешних переменных `x` и `y`, которые захватывают лямбда-выражение по значению. Поскольку лямбда-выражение захватывает исходные переменные `x` и `y` по значению, их значения остаются равными `1` после выполнения лямбда-выражения.

```cpp
// compile with: /W4 /EHsc
#include <algorithm>
#include <iostream>
#include <vector>
#include <string>

using namespace std;

template <typename C> void print(const string& s, const C& c) {
    cout << s;

    for (const auto& e : c) {
        cout << e << " ";
    }

    cout << endl;
}

void fillVector(vector<int>& v)
{
    // A local static variable.
    static int nextValue = 1;

    // The lambda expression that appears in the following call to
    // the generate function modifies and uses the local static
    // variable nextValue.
    generate(v.begin(), v.end(), [] { return nextValue++; });
    //WARNING: this is not thread-safe and is shown for illustration only
}

int main()
{
    // The number of elements in the vector.
    const int elementCount = 9;

    // Create a vector object with each element set to 1.
    vector<int> v(elementCount, 1);

    // These variables hold the previous two elements of the vector.
    int x = 1;
    int y = 1;

    // Sets each element in the vector to the sum of the
    // previous two elements.
    generate_n(v.begin() + 2,
        elementCount - 2,
        [=]() mutable throw() -> int { // lambda is the 3rd parameter
        // Generate current value.
        int n = x + y;
        // Update previous two values.
        x = y;
        y = n;
        return n;
    });
    print("vector v after call to generate_n() with lambda: ", v);

    // Print the local variables x and y.
    // The values of x and y hold their initial values because
    // they are captured by value.
    cout << "x: " << x << " y: " << y << endl;

    // Fill the vector with a sequence of numbers
    fillVector(v);
    print("vector v after 1st call to fillVector(): ", v);
    // Fill the vector with the next sequence of numbers
    fillVector(v);
    print("vector v after 2nd call to fillVector(): ", v);
}
```

```Output
vector v after call to generate_n() with lambda: 1 1 2 3 5 8 13 21 34
x: 1 y: 1
vector v after 1st call to fillVector(): 1 2 3 4 5 6 7 8 9
vector v after 2nd call to fillVector(): 10 11 12 13 14 15 16 17 18
```

Дополнительные сведения см. в разделе [generate_n](../standard-library/algorithm-functions.md#generate_n).

## <a name="constexpr-lambda-expressions"></a>Лямбда-выражения constexpr

**Visual Studio 2017 версии 15,3 и более поздних версий** (доступно с [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)): лямбда-выражение может быть объявлено как `constexpr` или использоваться в константном выражении, если инициализация каждого элемента данных, который он захватывает или вводит, разрешена в константном выражении.

```cpp
    int y = 32;
    auto answer = [y]() constexpr
    {
        int x = 10;
        return y + x;
    };

    constexpr int Increment(int n)
    {
        return [n] { return n + 1; }();
    }
```

Лямбда-выражение неявным образом `constexpr`, если его результат удовлетворяет требованиям функции `constexpr`:

```cpp
    auto answer = [](int n)
    {
        return 32 + n;
    };

    constexpr int response = answer(10);
```

Если лямбда-выражение явно или явно `constexpr`, то преобразование в указатель функции создает функцию `constexpr`:

```cpp
    auto Increment = [](int n)
    {
        return n + 1;
    };

    constexpr int(*inc)(int) = Increment;
```

## <a name="microsoft-specific"></a>Специально для систем Майкрософт

Лямбда-выражения не поддерживаются в следующих управляемых сущностях среды CLR: **ссылочный класс**, **структура ссылки**, **класс значения**или **Структура значения**.

Если используется модификатор, зависящий от Microsoft, например [__declspec](../cpp/declspec.md), его можно вставить в лямбда-выражение сразу после `parameter-declaration-clause`, например:

```cpp
auto Sqr = [](int t) __declspec(code_seg("PagedMem")) -> int { return t*t; };
```

Чтобы определить, поддерживается ли модификатор лямбда-выражениями, см. статью о нем в разделе " [модификаторы Microsoft](../cpp/microsoft-specific-modifiers.md) " документации.

В дополнение к стандартным функциям лямбда-выражения C++ 11 Visual Studio поддерживает лямбда-выражения без отслеживания состояния, которые можно преобразовать в указатели функций, использующие произвольные соглашения о вызовах.

## <a name="see-also"></a>См. также:

[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Объекты функции в стандартной библиотеке C++](../standard-library/function-objects-in-the-stl.md)<br/>
[Вызов функции](../cpp/function-call-cpp.md)<br/>
[for_each](../standard-library/algorithm-functions.md#for_each)
