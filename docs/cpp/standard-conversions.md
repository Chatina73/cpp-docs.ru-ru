---
title: Стандартные преобразования
ms.date: 10/02/2019
helpviewer_keywords:
- standard conversions, categories of
- L-values [C++]
- conversions, standard
ms.assetid: ce7ac8d3-5c99-4674-8229-0672de05528d
ms.openlocfilehash: c51a5ea5aaabb27babb9e4cd355721742088d31e
ms.sourcegitcommit: c51b2c665849479fa995bc3323a22ebe79d9d7ce
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/07/2019
ms.locfileid: "71998896"
---
# <a name="standard-conversions"></a>Стандартные преобразования

В языке C++ определены преобразования между его основными типами. Также определяются преобразования для указателей, ссылочных типов и типов указателей на члены. Эти преобразования называются *стандартными преобразованиями*.

В этом разделе рассматриваются следующие стандартные преобразования:

- Восходящие приведения целочисленных типов

- Преобразования целочисленных типов

- Преобразования типов с плавающей запятой

- Преобразования типов с плавающей запятой и целочисленных типов

- Арифметические преобразования

- Преобразования указателей

- Преобразования ссылок

- Преобразования указателей на члены

  > [!NOTE]
  > Пользовательские типы могут определять собственные преобразования. Преобразование определяемых пользователем типов рассматривается в [конструкторах](../cpp/constructors-cpp.md) и [преобразованиях](../cpp/user-defined-type-conversions-cpp.md).

Следующий код вызывает преобразования (в данном примере это восходящее приведение целочисленных типов).

```cpp
long  long_num1, long_num2;
int   int_num;

// int_num promoted to type long prior to assignment.
long_num1 = int_num;

// int_num promoted to type long prior to multiplication.
long_num2 = int_num * long_num2;
```

Результат преобразования является L-значением только в том случае, если получается ссылочный тип. Например, определяемое пользователем преобразование, объявленное как `operator int&()`, возвращает ссылку и является l-значением. Однако преобразование, объявленное как `operator int()`, возвращает объект и не является l-значением.

## <a name="integral-promotions"></a>Восходящие приведения целочисленных типов

Объекты целочисленного типа можно преобразовать в другой более широкий целочисленный тип, то есть тип, который может представлять больший набор значений. Этот расширяющий тип преобразования называется *целочисленным повышением*. С помощью целочисленного повышения можно использовать следующие типы в выражении, где можно использовать другой целочисленный тип:

- Объекты, литералы и константы типа **char** и **short int**

- Типы перечисления.

- битовые поля **int**

- Перечислители.

C++рекламные акции — это «сохранение значения», так как значение после продвижения гарантированно совпадает со значением до повышения уровня. В случае с сохранением данных об акциях объекты более коротких целочисленных типов (например, битовые поля или объекты типа **char**) помещаются в тип **int** , если **int** может представлять полный диапазон исходного типа. Если **int** не может представлять полный диапазон значений, объект помещается в тип **без знака int**.  Хотя эта стратегия аналогична той, которая используется в стандартном языке C, преобразования с сохранением значений не сохраняют "подпись" объекта.

Обычно при повышениях с сохранением значения и повышениях с сохранением наличия знака выдаются одинаковые результаты. Однако они могут дать разные результаты, если объект повышенного уровня выглядит следующим образом:

- Операнд `/`, `%`, `/=`, `%=`, `<`, `<=`, `>` или `>=`

   Эти операторы зависят от знака для определения результата. При применении к этим операндам предложения с сохранением и обслуживанием, сохраняя при этом подписи, получают разные результаты.

- Левый операнд `>>` или `>>=`

   Эти операторы обрабатывают количества со знаком и без знака по-разному в операции сдвига. Для количества со знаком операция сдвига вправо распространяет бит знака на освобожденные позиции битов, а освобожденные разряды заполняются нулем в неподписанных количествах.

- Аргумент для перегруженной функции или операнд перегруженного оператора, который зависит от подписи типа операнда для соответствующего аргумента. Дополнительные сведения об определении перегруженных операторов см. в разделе [перегруженные операторы](../cpp/operator-overloading.md).

## <a name="integral-conversions"></a>Преобразования целочисленных типов

*Целочисленные преобразования* — это преобразования между целочисленными типами. Целочисленные типы — **char**, **Short** (или **short int**), **int**, **Long**и **long long**. Эти типы могут быть дополнены со **знаком** или без **знака**, а в качестве краткости для **неподписанного целого** **числа можно использовать** .

### <a name="signed-to-unsigned"></a>Преобразование чисел со знаком в числа без знака

Объекты целочисленных типов со знаком можно преобразовывать в соответствующие типы без знака. При возникновении этих преобразований фактический битовый шаблон не изменяется. Однако интерпретация изменений данных. Рассмотрим этот код:

```cpp
#include <iostream>

using namespace std;
int main()
{
    short  i = -3;
    unsigned short u;

    cout << (u = i) << "\n";
}
// Output: 65533
```

В предыдущем примере определено и инициализировано **короткое значение со знаком**`i`, которое инициализируется с отрицательным числом. Выражение `(u = i)` приводит к тому, что `i` преобразуется в **Неподписанное короткое** значение перед присваиванием `u`.

### <a name="unsigned-to-signed"></a>Преобразование чисел без знака в числа со знаком

Объекты целочисленных типов без знака можно преобразовывать в соответствующие типы со знаком. Однако если значение без знака находится за пределами представимого диапазона типа со знаком, результат не будет иметь правильное значение, как показано в следующем примере:

```cpp
#include <iostream>

using namespace std;
int main()
{
short  i;
unsigned short u = 65533;

cout << (i = u) << "\n";
}
//Output: -3
```

В предыдущем примере `u` является **неподписанным коротким** целым объектом, который должен быть преобразован в значение со знаком, чтобы вычислить выражение `(i = u)`. Поскольку его значение не может быть правильно представлено **коротким знаком**, данные будут неправильно интерпретированы, как показано ниже.

## <a name="floating-point-conversions"></a>Преобразование чисел с плавающей запятой

Объект типа с плавающей запятой можно безопасно преобразовать в более точный тип с плавающей запятой, то есть без потери значимости. Например, при преобразовании с **плавающей запятой** в **Double или из** **двойного** в **длинное двойное** значение может быть безизменным.

Объект плавающего типа также можно преобразовать в менее точный тип, если он находится в диапазоне, представленном этим типом. (См. раздел [плавающие ограничения](../cpp/floating-limits.md) для диапазонов плавающих типов.) Если исходное значение не может быть представлено точно, его можно преобразовать в следующее большее или следующее более низкое значение. Если такого значения не существует, результат будет неопределенным. Рассмотрим следующий пример.

```cpp
cout << (float)1E300 << endl;
```

Максимальное значение, которое может быть представлено типом **float** , — это 3.402823466 E38 — намного меньшее число, чем 1E300. Таким образом, число преобразуется в бесконечное значение, а результатом является "INF".

## <a name="conversions-between-integral-and-floating-point-types"></a>Преобразования между целочисленным типом и типом с плавающей запятой

Определенные выражения могут вызывать преобразование объектов плавающего типа в целочисленные типы, и наоборот. Если объект целочисленного типа преобразуется в тип с плавающей запятой, а исходное значение не может быть представлено точно, результатом является либо следующее выше, либо следующее меньшее представимое значение.

При преобразовании объекта с плавающего типа в целочисленный тип дробная часть *усекается*или округляется в сторону нуля. Число, например 1,3, преобразуется в 1, а-1,3 преобразуется в-1. Если усеченное значение выше наибольшего допустимого значения или меньше наименьшего представимого значения, результат будет неопределенным.

## <a name="arithmetic-conversions"></a>Арифметические преобразования

Многие бинарные операторы (обсуждаемые в [выражениях с бинарными операторами](../cpp/expressions-with-binary-operators.md)) приводят к преобразованию операндов и выдают результаты одинаковым образом. Преобразования эти операторы вызываются *обычными арифметическими преобразованиями*. Арифметические преобразования операндов, которые имеют различные собственные типы, выполняются, как показано в следующей таблице. Типы typedef ведут себя в соответствии со своими базовыми собственными типами.

### <a name="conditions-for-type-conversion"></a>Условия для преобразования типов

|Выполненные условия|Преобразование|
|--------------------|----------------|
|Любой из операндов имеет тип **long double**.|Другой операнд преобразуется в тип **long double**.|
|Предыдущее условие не выполнено, или операнд имеет тип **Double**.|Другой операнд преобразуется в тип **Double**.|
|Предыдущие условия не выполнены, и любой из операндов имеет тип **float**.|Другой операнд преобразуется в тип **float**.|
|Предыдущие условия не выполнены (ни один из операндов не является операндом с плавающей запятой).|Операнды получают целочисленные продвижения следующим образом:<br /><br />— Если любой из операндов имеет тип **без знака Long**, то другой операнд преобразуется в тип **без знака Long**.<br />— Если предыдущее условие не выполнено, и если любой из операндов имеет тип **Long** , а другой тип **без знака int**, то оба операнда преобразуются в тип **без знака Long**.<br />— Если предыдущие два условия не выполняются, и если любой из операндов имеет тип **Long**, то другой операнд преобразуется в тип **Long**.<br />— Если предыдущие три условия не выполняются, и если любой из операндов имеет тип **без знака int**, то другой операнд преобразуется в тип **без знака int**.<br />— Если ни одно из вышеперечисленных условий не выполняется, оба операнда преобразуются в тип **int**.|

В следующем коде демонстрируются правила преобразования, описанные в таблице.

```cpp
double dVal;
float fVal;
int iVal;
unsigned long ulVal;

int main() {
   // iVal converted to unsigned long
   // result of multiplication converted to double
   dVal = iVal * ulVal;

   // ulVal converted to float
   // result of addition converted to double
   dVal = ulVal + fVal;
}
```

Первый оператор в приведенном выше примере представляет умножение двух целочисленных типов, `iVal` и `ulVal`. Условие соблюдается, что ни один операнд не имеет плавающего типа, а операнд имеет тип **без знака int**. Таким образом, другой операнд, `iVal`, преобразуется в тип **без знака int**. Затем результат присваивается `dVal`. Условие здесь соответствует тому, что один операнд имеет тип **Double**, поэтому результат умножения **без знака** преобразуется в тип **double**.

Второй оператор в предыдущем примере показывает добавление типа **float** и целого числа: `fVal` и `ulVal`. Переменная `ulVal` преобразуется в тип **float** (третье условие в таблице). Результат сложения преобразуется в тип **Double** (второе условие в таблице) и назначается `dVal`.

## <a name="pointer-conversions"></a>Преобразования указателей

Указатели можно преобразовывать в ходе присваивания, инициализации, сравнения и выполнения других выражений.

### <a name="pointer-to-classes"></a>Указатель на классы

Указатель на класс можно преобразовать в указатель на базовый класс в двух случаях.

Во-первых, когда указанный базовый класс доступен и преобразование однозначно. Дополнительные сведения об неоднозначных ссылках на базовые классы см. в разделе [несколько базовых классов](../cpp/multiple-base-classes.md).

Доступность базового класса зависит от используемого типа наследования. Рассмотрим пример наследования на следующем рисунке.

![Граф наследования,&#45;демонстрирующий]доступность базового класса(../cpp/media/vc38xa1.gif "граф&#45;наследования доступности базового класса") <br/>
Граф наследования, демонстрирующий доступность базового класса

В следующей таблице показана доступность базового класса для ситуации, представленной на рисунке.

|Тип функции|Наследование|Допустимо ли преобразование из<br /><br /> Б * в @ no__t-0 Legal?|
|----------------------|----------------|-------------------------------------------|
|Внешняя функция (без области видимости класса)|Private|Нет|
||Защищенный|Нет|
||Public|Да|
|Функция-член B (в области B)|Private|Да|
||Защищенный|Да|
||Public|Да|
|Функция-член C (в области C)|Private|Нет|
||Защищенный|Да|
||Public|Да|

Во-вторых, указатель на класс можно преобразовать в указатель на базовый класс при использовании явного преобразования типов. Дополнительные сведения о явных преобразованиях типов см. в разделе [оператор явного преобразования типа](explicit-type-conversion-operator-parens.md).

Результатом такого преобразования является указатель на *подобъект*, часть объекта, полностью описываемого базовым классом.

В следующем примере кода определяется два класса: `A` и `B`, где `B` является производным от класса `A`. (Дополнительные сведения о наследовании см. в разделе [производные классы](../cpp/inheritance-cpp.md).) Затем он определяет `bObject`, объект типа `B` и два указателя (`pA` и `pB`), которые указывают на объект.

```cpp
// C2039 expected
class A
{
public:
    int AComponent;
    int AMemberFunc();
};

class B : public A
{
public:
    int BComponent;
    int BMemberFunc();
};
int main()
{
   B bObject;
   A *pA = &bObject;
   B *pB = &bObject;

   pA->AMemberFunc();   // OK in class A
   pB->AMemberFunc();   // OK: inherited from class A
   pA->BMemberFunc();   // Error: not in class A
}
```

Указатель `pA` принадлежит типу `A *`, и это можно интерпретировать следующим образом: "указатель на объект типа `A`". Члены `bObject` (например, `BComponent` и `BMemberFunc`) являются уникальными для типа `B` и поэтому недоступны через `pA`. Указатель `pA` предоставляет доступ только к тем характеристикам (функциям-членам и данным) объекта, которые определены в классе `A`.

### <a name="pointer-to-function"></a>Указатель на функцию

Указатель на функцию можно преобразовать в тип `void *`, если тип `void *` достаточно велик, чтобы вместить этот указатель.

### <a name="pointer-to-void"></a>Указатель на void

Указатели на тип **void** можно преобразовать в указатели на любой другой тип, но только с явно приведенным типом (в отличие от C). Указатель на любой тип можно преобразовать неявно в указатель на тип **void**. Указатель на неполный объект типа может быть преобразован в указатель на **void** (неявно) и обратно (явно). Результат такого преобразования равен значению исходного указателя. Объект считается неполным, если он объявлен, но недостаточно информации для определения его размера или базового класса.

Указатель на любой объект, который не является **константой** или **volatile** , может быть неявно преобразован в указатель типа `void *`.

### <a name="const-and-volatile-pointers"></a>Указатели с ключевыми словами const и volatile

C++не предоставляет стандартное преобразование из типа **const** или **volatile** в тип, который не является **константой** или **volatile**. Однако можно указать любое преобразование с помощью явного приведения типов (включая небезопасные преобразования).

> [!NOTE]
> C++указатели на члены, за исключением указателей на статические члены, отличаются от обычных указателей и не имеют одинаковых стандартных преобразований. Указатели на статические члены являются обычными, и для них имеются такие же преобразования, как и для обычных указателей.

### <a name="null-pointer-conversions"></a>Преобразование пустых (null) указателей

Целочисленное константное выражение, результатом которого является ноль, или такое выражение, приведенное к типу указателя, преобразуется в указатель, называемый *пустым указателем*. Этот указатель всегда сравнивает неравный с указателем на любой допустимый объект или функцию. Исключение — это указатели на основанные объекты, которые могут иметь одинаковое смещение и по-прежнему указывать на разные объекты.

В C++ 11 тип [nullptr](../cpp/nullptr.md) должен быть предпочтительным для пустого указателя в стиле C.

### <a name="pointer-expression-conversions"></a>Преобразование выражений указателей

Любое выражение с типом массива можно преобразовать в указатель того же типа. Результатом преобразования будет указатель на первый элемент массива. В следующем примере показано такое преобразование.

```cpp
char szPath[_MAX_PATH]; // Array of type char.
char *pszPath = szPath; // Equals &szPath[0].
```

Выражение, которое приводит к функции, возвращающей определенный тип, преобразуется в указатель на функцию, возвращающую этот тип, за исключением случая, когда:

- Выражение используется в качестве операнда оператора взятия адреса ( **&** ).

- выражение используется в качестве операнда для оператора вызова функции.

## <a name="reference-conversions"></a>Преобразования ссылок

В таких случаях ссылка на класс может быть преобразована в ссылку на базовый класс:

- Указанный базовый класс доступен.

- Преобразование является однозначным. (Дополнительные сведения об неоднозначных ссылках на базовый класс см. в разделе [несколько базовых классов](../cpp/multiple-base-classes.md).)

Результат преобразования — это указатель на вложенный объект, представляющий базовый класс.

## <a name="pointer-to-member"></a>Указатель на член

Указатели на члены класса можно преобразовать в ходе присвоения, инициализации, сравнения и выполнения других выражений. В этом разделе описаны следующие преобразования указателей в члены.

### <a name="pointer-to-base-class-member"></a>Указатель на член базового класса

Указатель на член базового класса можно преобразовать в указатель на член производного от него класса при выполнении следующих условий:

- доступно обратное преобразование из указателя на производный класс в указатель базового класса;

- производный класс не наследуется виртуально от базового класса.

Если левый операнд является указателем на член, правый операнд должен иметь тип указателя на член или являться константным выражением со значением 0. Такое присваивание допустимо только в следующих случаях:

- правый операнд является указателем на член того же класса, что и левый операнд;

- левый операнд является указателем на член класса, открыто и однозначно производного от класса правого операнда.

### <a name="null-pointer-to-member-conversions"></a>преобразование указателя NULL на члены

Целочисленное константное выражение, результатом вычисления которого является ноль, преобразуется в указатель null. Этот указатель всегда сравнивает неравный с указателем на любой допустимый объект или функцию. Исключение — это указатели на основанные объекты, которые могут иметь одинаковое смещение и по-прежнему указывать на разные объекты.

В следующем примере кода демонстрируется определение указателя на член `i` в классе `A`. Указатель `pai` инициализируется со значением 0 и становится пустым указателем.

```cpp
class A
{
public:
int i;
};

int A::*pai = 0;

int main()
{
}
```

## <a name="see-also"></a>См. также

[C++Справочник по языку](../cpp/cpp-language-reference.md)