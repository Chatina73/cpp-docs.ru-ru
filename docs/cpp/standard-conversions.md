---
title: Стандартные преобразования
ms.date: 10/02/2019
helpviewer_keywords:
- standard conversions, categories of
- L-values [C++]
- conversions, standard
ms.assetid: ce7ac8d3-5c99-4674-8229-0672de05528d
ms.openlocfilehash: cb4960c2f981b99fbc798098357a0ac65e8ddaa6
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87232226"
---
# <a name="standard-conversions"></a>Стандартные преобразования

В языке C++ определены преобразования между его основными типами. Также определяются преобразования для указателей, ссылочных типов и типов указателей на члены. Эти преобразования называются *стандартными преобразованиями*.

В этом разделе рассматриваются следующие стандартные преобразования:

- Восходящие приведения целочисленных типов

- Преобразования целочисленных типов

- Преобразования типов с плавающей запятой

- Преобразования типов с плавающей запятой и целочисленных типов

- Арифметические преобразования

- Преобразования указателей

- Преобразования ссылок

- Преобразования указателей на члены

  > [!NOTE]
  > Пользовательские типы могут определять собственные преобразования. Преобразование определяемых пользователем типов рассматривается в [конструкторах](../cpp/constructors-cpp.md) и [преобразованиях](../cpp/user-defined-type-conversions-cpp.md).

Следующий код вызывает преобразования (в данном примере это восходящее приведение целочисленных типов).

```cpp
long  long_num1, long_num2;
int   int_num;

// int_num promoted to type long prior to assignment.
long_num1 = int_num;

// int_num promoted to type long prior to multiplication.
long_num2 = int_num * long_num2;
```

Результат преобразования является L-значением только в том случае, если получается ссылочный тип. Например, определяемое пользователем преобразование, объявленное как, `operator int&()` возвращает ссылку и является l-значением. Однако преобразование, объявленное как, `operator int()` возвращает объект и не является l-значением.

## <a name="integral-promotions"></a>Восходящие приведения целочисленных типов

Объекты целочисленного типа можно преобразовать в другой более широкий целочисленный тип, то есть тип, который может представлять больший набор значений. Этот расширяющий тип преобразования называется *целочисленным повышением*. С помощью целочисленного повышения можно использовать следующие типы в выражении, где можно использовать другой целочисленный тип:

- Объекты, литералы и константы типа **`char`** и**`short int`**

- Типы перечисления.

- **`int`** битовые поля

- Enumerators

Специальные акции C++ — это «сохранение значения», так как значение после продвижения гарантированно совпадает со значением до повышения уровня. В случае с сохранением данных об акциях объекты более коротких целочисленных типов (например, битовые поля или объекты типа **`char`** ) переносятся в тип, **`int`** Если **`int`** могут представлять полный диапазон исходного типа. Если **`int`** не может представлять полный диапазон значений, объект повышается до типа **`unsigned int`** .  Хотя эта стратегия аналогична той, которая используется в стандартном языке C, преобразования с сохранением значений не сохраняют "подпись" объекта.

Обычно при повышениях с сохранением значения и повышениях с сохранением наличия знака выдаются одинаковые результаты. Однако они могут дать разные результаты, если объект повышенного уровня выглядит следующим образом:

- Операнд `/` , `%` , `/=` , `%=` , `<` , `<=` , `>` или`>=`

   Эти операторы зависят от знака для определения результата. При применении к этим операндам предложения с сохранением и обслуживанием, сохраняя при этом подписи, получают разные результаты.

- Левый операнд `>>` или`>>=`

   Эти операторы обрабатывают количества со знаком и без знака по-разному в операции сдвига. Для количества со знаком операция сдвига вправо распространяет бит знака на освобожденные позиции битов, а освобожденные разряды заполняются нулем в неподписанных количествах.

- Аргумент для перегруженной функции или операнд перегруженного оператора, который зависит от подписи типа операнда для соответствующего аргумента. Дополнительные сведения об определении перегруженных операторов см. в разделе [перегруженные операторы](../cpp/operator-overloading.md).

## <a name="integral-conversions"></a>Преобразования целочисленных типов

*Целочисленные преобразования* — это преобразования между целочисленными типами. Целочисленные типы: **`char`** , **`short`** (или **`short int`** ), **`int`** , **`long`** и **`long long`** . Эти типы могут уточняться с помощью **`signed`** или **`unsigned`** , а также **`unsigned`** могут использоваться в качестве краткости для **`unsigned int`** .

### <a name="signed-to-unsigned"></a>Преобразование чисел со знаком в числа без знака

Объекты целочисленных типов со знаком можно преобразовывать в соответствующие типы без знака. При возникновении этих преобразований фактический битовый шаблон не изменяется. Однако интерпретация изменений данных. Рассмотрим этот код:

```cpp
#include <iostream>

using namespace std;
int main()
{
    short  i = -3;
    unsigned short u;

    cout << (u = i) << "\n";
}
// Output: 65533
```

В предыдущем примере **`signed short`** `i` определено и инициализировано отрицательное число. Выражение `(u = i)` приводит к `i` преобразованию в **`unsigned short`** перед присваиванием `u` .

### <a name="unsigned-to-signed"></a>Преобразование чисел без знака в числа со знаком

Объекты целочисленных типов без знака можно преобразовывать в соответствующие типы со знаком. Однако если значение без знака находится за пределами представимого диапазона типа со знаком, результат не будет иметь правильное значение, как показано в следующем примере:

```cpp
#include <iostream>

using namespace std;
int main()
{
short  i;
unsigned short u = 65533;

cout << (i = u) << "\n";
}
//Output: -3
```

В предыдущем примере `u` — это **`unsigned short`** целочисленный объект, который необходимо преобразовать в число со знаком для вычисления выражения `(i = u)` . Поскольку его значение не может быть правильно представлено в **`signed short`** , данные будут неправильно интерпретированы, как показано ниже.

## <a name="floating-point-conversions"></a>Преобразование чисел с плавающей запятой

Объект типа с плавающей запятой можно безопасно преобразовать в более точный тип с плавающей запятой, то есть без потери значимости. Например, преобразования из **`float`** в **`double`** **`double`** в **`long double`** являются безнадежными, а значение не изменяется.

Объект плавающего типа также можно преобразовать в менее точный тип, если он находится в диапазоне, представленном этим типом. (См. раздел [плавающие ограничения](../cpp/floating-limits.md) для диапазонов плавающих типов.) Если исходное значение не может быть представлено точно, его можно преобразовать в следующее большее или следующее более низкое значение. Если такого значения не существует, результат будет неопределенным. Рассмотрим следующий пример:

```cpp
cout << (float)1E300 << endl;
```

Максимальное значение, которое может быть представлено типом, **`float`** — это 3.402823466 E38 — намного меньшее число, чем 1E300. Таким образом, число преобразуется в бесконечное значение, а результатом является "INF".

## <a name="conversions-between-integral-and-floating-point-types"></a>Преобразования между целочисленным типом и типом с плавающей запятой

Определенные выражения могут вызывать преобразование объектов плавающего типа в целочисленные типы, и наоборот. Если объект целочисленного типа преобразуется в тип с плавающей запятой, а исходное значение не может быть представлено точно, результатом является либо следующее выше, либо следующее меньшее представимое значение.

При преобразовании объекта с плавающего типа в целочисленный тип дробная часть *усекается*или округляется в сторону нуля. Число, например 1,3, преобразуется в 1, а-1,3 преобразуется в-1. Если усеченное значение выше наибольшего допустимого значения или меньше наименьшего представимого значения, результат будет неопределенным.

## <a name="arithmetic-conversions"></a>Арифметические преобразования

Многие бинарные операторы (обсуждаемые в [выражениях с бинарными операторами](../cpp/expressions-with-binary-operators.md)) приводят к преобразованию операндов и выдают результаты одинаковым образом. Преобразования эти операторы вызываются *обычными арифметическими преобразованиями*. Арифметические преобразования операндов, которые имеют различные собственные типы, выполняются, как показано в следующей таблице. Типы typedef ведут себя в соответствии со своими базовыми собственными типами.

### <a name="conditions-for-type-conversion"></a>Условия для преобразования типов

|Выполненные условия|Преобразование|
|--------------------|----------------|
|Любой операнд имеет тип **`long double`** .|Другой операнд преобразуется в тип **`long double`** .|
|Предыдущее условие не выполнено, и любой из операндов имеет тип **`double`** .|Другой операнд преобразуется в тип **`double`** .|
|Предыдущие условия не выполнены, и любой из операндов имеет тип **`float`** .|Другой операнд преобразуется в тип **`float`** .|
|Предыдущие условия не выполнены (ни один из операндов не является операндом с плавающей запятой).|Операнды получают целочисленные продвижения следующим образом:<br /><br />— Если любой из операндов имеет тип **`unsigned long`** , то другой операнд преобразуется в тип **`unsigned long`** .<br />— Если предыдущее условие не выполнено, и если любой из операндов имеет тип **`long`** , а другой тип **`unsigned int`** , оба операнда преобразуются в тип **`unsigned long`** .<br />— Если предыдущие два условия не выполняются, и если любой из операндов имеет тип **`long`** , то другой операнд преобразуется в тип **`long`** .<br />— Если предыдущие три условия не выполняются, и если любой из операндов имеет тип **`unsigned int`** , то другой операнд преобразуется в тип **`unsigned int`** .<br />— Если ни одно из вышеперечисленных условий не выполняется, оба операнда преобразуются в тип **`int`** .|

В следующем коде демонстрируются правила преобразования, описанные в таблице.

```cpp
double dVal;
float fVal;
int iVal;
unsigned long ulVal;

int main() {
   // iVal converted to unsigned long
   // result of multiplication converted to double
   dVal = iVal * ulVal;

   // ulVal converted to float
   // result of addition converted to double
   dVal = ulVal + fVal;
}
```

Первый оператор в приведенном выше примере представляет умножение двух целочисленных типов, `iVal` и `ulVal`. Условие выполнено, так как операнд не имеет плавающего типа, а один операнд имеет тип **`unsigned int`** . Таким образом, другой операнд, `iVal` преобразуется в тип **`unsigned int`** . Затем результат присваивается `dVal` . Условие здесь соответствует тому, что один операнд имеет тип **`double`** , поэтому **`unsigned int`** результат умножения преобразуется в тип **`double`** .

Второй оператор в предыдущем примере показывает добавление **`float`** и целочисленный тип: `fVal` и `ulVal` . `ulVal`Переменная преобразуется в тип **`float`** (третье условие в таблице). Результат сложения преобразуется в тип **`double`** (второе условие в таблице) и присваивается `dVal` .

## <a name="pointer-conversions"></a>Преобразования указателей

Указатели можно преобразовывать в ходе присваивания, инициализации, сравнения и выполнения других выражений.

### <a name="pointer-to-classes"></a>Указатель на классы

Указатель на класс можно преобразовать в указатель на базовый класс в двух случаях.

Во-первых, когда указанный базовый класс доступен и преобразование однозначно. Дополнительные сведения об неоднозначных ссылках на базовые классы см. в разделе [несколько базовых классов](../cpp/multiple-base-classes.md).

Доступность базового класса зависит от используемого типа наследования. Рассмотрим пример наследования на следующем рисунке.

![Граф наследования, демонстрирующий доступность базовых&#45;классов](../cpp/media/vc38xa1.gif "Граф наследования, демонстрирующий доступность базовых&#45;классов") <br/>
Граф наследования, демонстрирующий доступность базового класса

В следующей таблице показана доступность базового класса для ситуации, представленной на рисунке.

|Тип функции|Наследование|Допустимо ли преобразование из<br /><br /> Б * к \* юридическим?|
|----------------------|----------------|-------------------------------------------|
|Внешняя функция (без области видимости класса)|Private|Нет|
||Защищенный|Нет|
||Общедоступные|Да|
|Функция-член B (в области B)|Private|Да|
||Защищенный|Да|
||Общедоступные|Да|
|Функция-член C (в области C)|Private|Нет|
||Защищенный|Да|
||Общедоступные|Да|

Во-вторых, указатель на класс можно преобразовать в указатель на базовый класс при использовании явного преобразования типов. Дополнительные сведения о явных преобразованиях типов см. в разделе [оператор явного преобразования типа](explicit-type-conversion-operator-parens.md).

Результатом такого преобразования является указатель на *подобъект*, часть объекта, полностью описываемого базовым классом.

В следующем примере кода определяется два класса: `A` и `B`, где `B` является производным от класса `A`. (Дополнительные сведения о наследовании см. в разделе [производные классы](../cpp/inheritance-cpp.md).) Затем он определяет `bObject` , объект типа `B` и два указателя ( `pA` и `pB` ), которые указывают на объект.

```cpp
// C2039 expected
class A
{
public:
    int AComponent;
    int AMemberFunc();
};

class B : public A
{
public:
    int BComponent;
    int BMemberFunc();
};
int main()
{
   B bObject;
   A *pA = &bObject;
   B *pB = &bObject;

   pA->AMemberFunc();   // OK in class A
   pB->AMemberFunc();   // OK: inherited from class A
   pA->BMemberFunc();   // Error: not in class A
}
```

Указатель `pA` принадлежит типу `A *`, и это можно интерпретировать следующим образом: "указатель на объект типа `A`". Члены `bObject` (такие как `BComponent` и `BMemberFunc` ) являются уникальными для типа `B` и поэтому недоступны через `pA` . Указатель `pA` предоставляет доступ только к тем характеристикам (функциям-членам и данным) объекта, которые определены в классе `A`.

### <a name="pointer-to-function"></a>Указатель на функцию

Указатель на функцию можно преобразовать в тип `void *` , если тип `void *` достаточно большой для хранения указателя.

### <a name="pointer-to-void"></a>Указатель на void

Указатели на тип **`void`** можно преобразовать в указатели на любой другой тип, но только с явно приведенным типом (в отличие от C). Указатель на любой тип можно преобразовать неявно в указатель на тип **`void`** . Указатель на неполный объект типа можно преобразовать в указатель на **`void`** (неявно) и обратно (явно). Результат такого преобразования равен значению исходного указателя. Объект считается неполным, если он объявлен, но недостаточно информации для определения его размера или базового класса.

Указатель на любой объект, который не **`const`** или **`volatile`** может быть неявно преобразован в указатель типа `void *` .

### <a name="const-and-volatile-pointers"></a>Указатели с ключевыми словами const и volatile

C++ не передает стандартное преобразование из **`const`** **`volatile`** типа или в тип, который не является **`const`** или **`volatile`** . Однако можно указать любое преобразование с помощью явного приведения типов (включая небезопасные преобразования).

> [!NOTE]
> Указатели C++ на члены, за исключением указателей на статические члены, отличаются от обычных указателей и не имеют одинаковых стандартных преобразований. Указатели на статические члены являются обычными, и для них имеются такие же преобразования, как и для обычных указателей.

### <a name="null-pointer-conversions"></a>Преобразование пустых (null) указателей

Целочисленное константное выражение, результатом которого является ноль, или такое выражение, приведенное к типу указателя, преобразуется в указатель, называемый *пустым указателем*. Этот указатель всегда сравнивает неравный с указателем на любой допустимый объект или функцию. Исключение — это указатели на основанные объекты, которые могут иметь одинаковое смещение и по-прежнему указывать на разные объекты.

В C++ 11 тип [nullptr](../cpp/nullptr.md) должен быть предпочтительным для пустого указателя в стиле C.

### <a name="pointer-expression-conversions"></a>Преобразование выражений указателей

Любое выражение с типом массива можно преобразовать в указатель того же типа. Результатом преобразования будет указатель на первый элемент массива. В следующем примере показано такое преобразование.

```cpp
char szPath[_MAX_PATH]; // Array of type char.
char *pszPath = szPath; // Equals &szPath[0].
```

Выражение, которое приводит к функции, возвращающей определенный тип, преобразуется в указатель на функцию, возвращающую этот тип, за исключением случая, когда:

- Выражение используется в качестве операнда оператора взятия адреса ( **&** ).

- выражение используется в качестве операнда для оператора вызова функции.

## <a name="reference-conversions"></a>Преобразования ссылок

В таких случаях ссылка на класс может быть преобразована в ссылку на базовый класс:

- Указанный базовый класс доступен.

- Преобразование является однозначным. (Дополнительные сведения об неоднозначных ссылках на базовый класс см. в разделе [несколько базовых классов](../cpp/multiple-base-classes.md).)

Результат преобразования — это указатель на вложенный объект, представляющий базовый класс.

## <a name="pointer-to-member"></a>Указатель на член

Указатели на члены класса можно преобразовать в ходе присвоения, инициализации, сравнения и выполнения других выражений. В этом разделе описаны следующие преобразования указателей в члены.

### <a name="pointer-to-base-class-member"></a>Указатель на член базового класса

Указатель на член базового класса можно преобразовать в указатель на член производного от него класса при выполнении следующих условий:

- доступно обратное преобразование из указателя на производный класс в указатель базового класса;

- производный класс не наследуется виртуально от базового класса.

Если левый операнд является указателем на член, правый операнд должен иметь тип указателя на член или являться константным выражением со значением 0. Такое присваивание допустимо только в следующих случаях:

- правый операнд является указателем на член того же класса, что и левый операнд;

- левый операнд является указателем на член класса, открыто и однозначно производного от класса правого операнда.

### <a name="null-pointer-to-member-conversions"></a>преобразование указателя NULL на члены

Целочисленное константное выражение, результатом вычисления которого является ноль, преобразуется в указатель null. Этот указатель всегда сравнивает неравный с указателем на любой допустимый объект или функцию. Исключение — это указатели на основанные объекты, которые могут иметь одинаковое смещение и по-прежнему указывать на разные объекты.

В следующем примере кода демонстрируется определение указателя на член `i` в классе `A`. Указатель `pai` инициализируется со значением 0 и становится пустым указателем.

```cpp
class A
{
public:
int i;
};

int A::*pai = 0;

int main()
{
}
```

## <a name="see-also"></a>См. также раздел

[Справочник по языку C++](../cpp/cpp-language-reference.md)
