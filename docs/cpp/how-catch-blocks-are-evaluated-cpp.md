---
title: Проверка блоков Catch (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- try-catch keyword [C++], catchable types
- catch keyword [C++], types of catch handlers
- C++ exception handling, catch handlers
- exception handling, catching and deleting exceptions
- types [C++], exception handling
ms.assetid: 202dbf07-8ace-4b3b-b3ae-4b45c275e0b4
ms.openlocfilehash: 21d68b25fa3695a9b5637dcace081424f99911d8
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87188106"
---
# <a name="how-catch-blocks-are-evaluated-c"></a>Проверка блоков Catch (C++)

C++ позволяет создавать исключения любого типа, хотя обычно рекомендуется создавать типы, производные от std::exception. Исключение C++ может быть перехвачено **`catch`** обработчиком, который указывает тот же тип, что и выданное исключение, или обработчиком, который может перехватить любой тип исключения.

Если созданное исключение имеет тип класса, у которого имеется один или несколько базовых классов, то его могут перехватывать обработчики, которые принимают базовые классы (и ссылки на базовые классы) этого типа исключения. Обратите внимание, что если исключение перехватывается по ссылке, то оно привязывается к самому объекту исключения; в противном случае обрабатывается его копия (как и в случае с аргументами функции).

При возникновении исключения оно может быть перехвачено следующими типами **`catch`** обработчиков:

- Обработчик, который может принимать любой тип данных (синтаксис с многоточием).

- Обработчик, принимающий тот же тип, что и объект исключения; так как это копия, **`const`** **`volatile`** модификаторы не учитываются.

- Обработчик, который принимает ссылку на тот же тип, что и у объекта исключения.

- Обработчик, принимающий ссылку на **`const`** форму или того **`volatile`** же типа, что и объект исключения.

- Обработчик, принимающий базовый класс того же типа, что и объект исключения; так как это копия, **`const`** **`volatile`** модификаторы не учитываются. **`catch`** Обработчик для базового класса не должен предшествовать **`catch`** обработчику для производного класса.

- Обработчик, который принимает ссылку на базовый класс того же типа, что и у объекта исключения.

- Обработчик, принимающий ссылку на **`const`** **`volatile`** форму или базового класса того же типа, что и объект исключения.

- Обработчик, который принимает указатель, в который можно преобразовать созданный объект указателя при помощи стандартных правил преобразования указателей.

Порядок, в котором **`catch`** отображаются обработчики, важен, так как обработчики для данного **`try`** блока анализируются в порядке их внешнего вида. Например, ошибкой будет поместить обработчик для базового класса перед обработчиком для производного класса. После обнаружения соответствующего **`catch`** обработчика последующие обработчики не проверяются. В результате обработчик многоточия **`catch`** должен быть последним обработчиком для своего **`try`** блока. Пример:

```cpp
// ...
try
{
    // ...
}
catch( ... )
{
    // Handle exception here.
}
// Error: the next two handlers are never examined.
catch( const char * str )
{
    cout << "Caught exception: " << str << endl;
}
catch( CExcptClass E )
{
    // Handle CExcptClass exception here.
}
```

В этом примере обработчик многоточия **`catch`** является единственным проверенным обработчиком.

## <a name="see-also"></a>См. также раздел

[Современные рекомендации по C++ для исключений и обработки ошибок](../cpp/errors-and-exception-handling-modern-cpp.md)
