---
title: Оператор try-finally
ms.date: 11/19/2018
f1_keywords:
- __try
- _try
- __leave_cpp
- __leave
- __finally_cpp
- __try_cpp
- __finally
- _finally
helpviewer_keywords:
- __try keyword [C++]
- __finally keyword [C++]
- __leave keyword [C++]
- try-catch keyword [C++], try-finally keyword
- try-finally keyword [C++]
- __finally keyword [C++], try-finally statement syntax
- __leave keyword [C++], try-finally statement
- structured exception handling [C++], try-finally
ms.assetid: 826e0347-ddfe-4f6e-a7bc-0398e0edc7c2
ms.openlocfilehash: d2a1c63f686b46aad4e174c86895f6f9fc00d260
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "58778342"
---
# <a name="try-finally-statement"></a>Оператор try-finally

**Блок, относящийся только к системам Microsoft**

Следующий синтаксис описывает **try-finally** инструкции:

> **\_\_Попробуйте**<br/>
> {<br/>
> &nbsp;&nbsp;&nbsp;&nbsp;защищенный код<br/>
> }<br/>
> **\_\_Наконец**<br/>
> {<br/>
> &nbsp;&nbsp;&nbsp;&nbsp;код завершения<br/>
> }<br/>

## <a name="grammar"></a>Грамматика

*try-finally-statement*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**\_\_try** *compound-statement* **\_\_finally** *compound-statement*

**Try-finally** инструкция является расширением Microsoft для языков C и C++, которое позволяет целевым приложениям гарантировать выполнение кода очистки при прерывании выполнения блока кода. Очистка включает такие задачи, как отмена распределения памяти, закрытие файлов и освобождение их дескрипторов. **Try-finally** инструкции особенно полезен для подпрограмм, в которых в нескольких местах, где проверяется для ошибок, которые может вызвать преждевременное возвращение из подпрограммы.

Связанные сведения и пример кода, см. в разделе [try-except Statement](../cpp/try-except-statement.md). Дополнительные сведения о структурированной обработке исключений в общем, см. в разделе [структурированную обработку исключений](../cpp/structured-exception-handling-c-cpp.md). Дополнительные сведения об обработке исключений в управляемых приложениях с C++выполняет, см. в разделе [обработка исключений в/CLR](../extensions/exception-handling-cpp-component-extensions.md).

> [!NOTE]
> Структурированная обработка исключений поддерживается в Win32 для исходных файлов как на C, так и на C++. Однако она не предназначена специально для C++. Для того чтобы ваш код лучше переносился, лучше использовать механизм обработки исключений языка C++. Кроме того, этот механизм отличается большей гибкостью, поскольку может обрабатывать исключения любого типа. Для программ на языке C++ рекомендуется использовать механизм обработки исключений C++ ([try, catch и throw](../cpp/try-throw-and-catch-statements-cpp.md) инструкций).

Составной оператор после **__try** предложение находится защищенный раздел. Составной оператор после **__finally** предложение является обработчиком завершения. Такой обработчик определяет набор действий, выполняемых при выходе из защищенного раздела независимо от того, происходит ли выход в результате исключения (ненормальное завершение) или в результате стандартной передачи управления дальше (нормальное завершение).

Управление достигает **__try** инструкции с обычного последовательного выполнения (вниз). Если элемент управления входит **__try**, становится активным соответствующий обработчик. Если поток элементов управления достигает конца блока try, выполнение продолжается следующим образом.

1. Вызывается обработчик завершения.

1. По завершении работы обработчика завершения выполнение продолжается после **__finally** инструкции. Независимо от того как завершается защищенный раздел (например, с помощью **goto** из защищенного тела или **возвращают** инструкции), выполняется обработчик завершения *перед* поток управления перемещается из защищенного раздела.

   Объект **__finally** инструкции не блокирует поиск соответствующего обработчика исключений.

При возникновении исключения в **__try** блока, операционная система должна найти обработчик для исключения или программа завершится ошибкой. Если обработчик найден, все **__finally** блоки выполняются и выполнение продолжается в обработчике.

Например, предположим, ряд вызовов функций связывает функцию А с функцией D, как показано на следующем рисунке. Каждая функция имеет один обработчик завершения. Если исключение возникает в функции D и обрабатывается в объект, обработчики завершения вызываются в следующем порядке, в котором система освобождает стек: D, C, B.

![Порядок прекращения&#45;выполнения обработчика](../cpp/media/vc38cx1.gif "порядок прекращения&#45;выполнения обработчика") <br/>
Порядок выполнения обработчиков завершения

> [!NOTE]
> Поведение оператора try-finally отличается от некоторых других языков, которые поддерживают использование **наконец**, например C#.  Один **__try** , возможно, но не оба объекта **__finally** и **__except**.  Если оба следует использовать одновременно, оператор try-except должен включать внутренней оператор try-finally.  Правила,задающие время выполнения каждого блока, также различаются.

Для совместимости с предыдущими версиями **_try**, **_finally**, и **_leave** являются синонимами для **__try**, **__ Наконец**, и **__leave** Если параметр компилятора [/Za \(отключить расширения языка)](../build/reference/za-ze-disable-language-extensions.md) указан.

## <a name="the-leave-keyword"></a>Ключевое слово __leave

**__Leave** ключевое слово может использоваться только в пределах защищенного раздела оператора **try-finally** инструкции и его влияние — переход в конец защищенного раздела. Выполнение продолжается с первого оператора в обработчике завершения.

Объект **goto** оператор также может переходить из защищенного раздела, но он снижает производительность, так как он вызывает очистки стека. **__Leave** инструкции более эффективна, так как он не вызывает освобождение стека.

## <a name="abnormal-termination"></a>Аварийное завершение

Выход из **try-finally** инструкции, использующей [longjmp](../c-runtime-library/reference/longjmp.md) функции времени выполнения считается ненормальным завершением. Не допускается для перехода в **__try** инструкции, но допустим для выход из него. Все **__finally** инструкций, которые активны между отправным пунктом точкой (нормальном завершении **__try** блок) и назначение ( **__except** блокировать, обрабатывает исключение) должна выполняться. Это называется "локальной раскруткой".

Если **попробуйте** блок завершается преждевременно по любой причине, включая выход из блока, система выполняет связанный **наконец** блока как часть процесса очистки стека. В таких случаях [AbnormalTermination](/windows/desktop/Debug/abnormaltermination) возвращает **true** Если вызывается из **наконец** block; в противном случае возвращается **false**.

Обработчик завершения не вызывается, если процесс удален во время выполнения **try-finally** инструкции.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Написание обработчика завершения](../cpp/writing-a-termination-handler.md)<br/>
[Структурированная обработка исключений (C/C++)](../cpp/structured-exception-handling-c-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Синтаксис обработчика завершения](/windows/desktop/Debug/termination-handler-syntax)