---
title: Оператор try-finally
ms.date: 11/19/2018
f1_keywords:
- __try
- _try
- __leave_cpp
- __leave
- __finally_cpp
- __try_cpp
- __finally
- _finally
helpviewer_keywords:
- __try keyword [C++]
- __finally keyword [C++]
- __leave keyword [C++]
- try-catch keyword [C++], try-finally keyword
- try-finally keyword [C++]
- __finally keyword [C++], try-finally statement syntax
- __leave keyword [C++], try-finally statement
- structured exception handling [C++], try-finally
ms.assetid: 826e0347-ddfe-4f6e-a7bc-0398e0edc7c2
ms.openlocfilehash: c26b72f7c675a4130f38c515cf71ecc290328ccc
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69498605"
---
# <a name="try-finally-statement"></a>Оператор try-finally

**Блок, относящийся только к системам Microsoft**

Следующий синтаксис описывает оператор **try-finally** :

> **\_\_Повторите**<br/>
> {<br/>
> &nbsp;&nbsp;&nbsp;&nbsp;Защищенный код<br/>
> }<br/>
> **\_\_счете**<br/>
> {<br/>
> &nbsp;&nbsp;&nbsp;&nbsp;код завершения<br/>
> }

## <a name="grammar"></a>Грамматика

*try-finally-statement*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Try составной *оператор* **finally \_ \_**  **\_ \_**

Оператор **try-finally** — это расширение Майкрософт для C и C++ языков, которое позволяет целевым приложениям гарантировать выполнение кода очистки при прерывании выполнения блока кода. Очистка включает такие задачи, как отмена распределения памяти, закрытие файлов и освобождение их дескрипторов. Оператор **try-finally** особенно полезен для подпрограмм, в которых есть несколько мест, где выполняется проверка на наличие ошибки, которая может привести к преждевременному возврату из подпрограммы.

Связанные сведения и пример кода см. в разделе [оператор try-except](../cpp/try-except-statement.md). Дополнительные сведения об структурированной обработке исключений в целом см. в разделе [структурированная обработка исключений](../cpp/structured-exception-handling-c-cpp.md). Дополнительные сведения об обработке исключений в управляемых приложениях с помощью C++/CLI см. [в разделе Обработка исключений в разделе/CLR](../extensions/exception-handling-cpp-component-extensions.md).

> [!NOTE]
> Структурированная обработка исключений поддерживается в Win32 для исходных файлов как на C, так и на C++. Однако она не предназначена специально для C++. Для того чтобы ваш код лучше переносился, лучше использовать механизм обработки исключений языка C++. Кроме того, этот механизм отличается большей гибкостью, поскольку может обрабатывать исключения любого типа. Для C++ программ рекомендуется использовать механизм обработки C++ исключений (операторы[try, catch и Throw](../cpp/try-throw-and-catch-statements-cpp.md) ).

Составной оператор после предложения **__try** является защищенным разделом. Составной оператор после предложения **__finally** является обработчиком завершения. Такой обработчик определяет набор действий, выполняемых при выходе из защищенного раздела независимо от того, происходит ли выход в результате исключения (ненормальное завершение) или в результате стандартной передачи управления дальше (нормальное завершение).

Элемент управления достигает оператора **__try** с помощью простого последовательного выполнения (с переходом). Когда элемент управления входит в **__try**, связанный с ним обработчик становится активным. Если поток элементов управления достигает конца блока try, выполнение продолжается следующим образом.

1. Вызывается обработчик завершения.

1. После завершения обработчика завершения выполнение продолжится после оператора **__finally** . Независимо от того, как заканчивается защищенный раздел (например, с помощью инструкции **goto** из защищенного текста или оператора **return** ), обработчик завершения выполняется *до* того, как поток управления перемещается из защищенного раздела.

   Оператор **__finally** не блокирует поиск соответствующего обработчика исключений.

Если в блоке **__try** возникает исключение, операционная система должна найти обработчик для исключения, иначе программа завершится ошибкой. Если обработчик найден, выполняются все и все блоки **__finally** , а выполнение возобновляется в обработчике.

Например, предположим, ряд вызовов функций связывает функцию А с функцией D, как показано на следующем рисунке. Каждая функция имеет один обработчик завершения. Если исключение возникает в функции D и обрабатывается в, обработчики завершения вызываются в таком порядке, когда система очищает стек: D, C, B.

![Порядок выполнения обработчика&#45;завершения]для(../cpp/media/vc38cx1.gif "выполнения обработчика завершения&#45;") <br/>
Порядок выполнения обработчиков завершения

> [!NOTE]
> Поведение try-finally отличается от некоторых других языков, которые поддерживают использование **и**, например, C#.  Один элемент **__try** может иметь либо, но не оба, для **__finally** и **__except**.  Если оба следует использовать одновременно, оператор try-except должен включать внутренней оператор try-finally.  Правила,задающие время выполнения каждого блока, также различаются.

Для совместимости с предыдущими версиями **_try**, **_finally**и **_leave** являются синонимами для **__try**, **__finally**и **__leave** , если только параметр компилятора [/Za \(не отключил расширения языка) ](../build/reference/za-ze-disable-language-extensions.md)указан.

## <a name="the-__leave-keyword"></a>Ключевое слово __leave

Ключевое слово **__leave** допустимо только в защищенном разделе оператора **try-finally** , и его результат заключается в переходе к концу защищенного раздела. Выполнение продолжается с первого оператора в обработчике завершения.

Оператор **goto** также может перейти из защищенного раздела, но снижает производительность, так как вызывает очистку стека. Инструкция **__leave** более эффективна, так как она не приводит к очистке стека.

## <a name="abnormal-termination"></a>Аварийное завершение

Выход из оператора **try-finally** с помощью функции времени выполнения [longjmp](../c-runtime-library/reference/longjmp.md) считается аномальным завершением. Переход к оператору **__try** недопустимым, но допустим, чтобы перейти из него. Необходимо запустить все операторы **__finally** , активные между точкой отправления (нормальное завершение блока **__try** ) и назначением (блок **__except** , обрабатывающий исключение). Это называется "локальной раскруткой".

Если блок **try** преждевременно завершается по какой-либо причине, включая переход за пределы блока, система выполняет связанный блок **finally** как часть процесса очистки стека. В таких случаях функция [абнормалтерминатион](/windows/win32/Debug/abnormaltermination) возвращает **значение true** , если вызывается из блока **finally** ; в противном случае возвращается **значение false**.

Обработчик завершения не вызывается, если процесс завершается в процессе выполнения инструкции **try-finally** .

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Написание обработчика завершения](../cpp/writing-a-termination-handler.md)<br/>
[Структурированная обработка исключений (C/C++)](../cpp/structured-exception-handling-c-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Синтаксис обработчика завершения](/windows/win32/Debug/termination-handler-syntax)