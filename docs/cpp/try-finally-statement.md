---
title: Оператор try-finally
description: Справочник по Microsoft C++ к __try и __finally структурированным операторам обработки исключений.
ms.date: 08/25/2020
f1_keywords:
- __try
- _try
- __leave_cpp
- __leave
- __finally_cpp
- __try_cpp
- __finally
- _finally
helpviewer_keywords:
- __try keyword [C++]
- __finally keyword [C++]
- __leave keyword [C++]
- try-catch keyword [C++], try-finally keyword
- try-finally keyword [C++]
- __finally keyword [C++], try-finally statement syntax
- __leave keyword [C++], try-finally statement
- structured exception handling [C++], try-finally
ms.assetid: 826e0347-ddfe-4f6e-a7bc-0398e0edc7c2
ms.openlocfilehash: edabbbe35c86f0305e31f36584c4dfe01f2f88cd
ms.sourcegitcommit: efc8c32205c9d610f40597556273a64306dec15d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/26/2020
ms.locfileid: "88898643"
---
# <a name="try-finally-statement"></a>инструкция `try-finally`

`try-finally`Оператор — это расширение для **Microsoft** , которое поддерживает структурированную обработку исключений в языках C и C++.

## <a name="syntax"></a>Синтаксис

Следующий синтаксис описывает `try-finally` инструкцию:

```cpp
    // . . .
    __try {
        // guarded code
    }
    __finally {
        // termination code
    }
    // . . .
```

## <a name="grammar"></a>Грамматика

> *`try-finally-statement`*:\
> &emsp;**`__try`** *`compound-statement`* **`__finally`** *`compound-statement`*

`try-finally`Инструкция является расширением Microsoft для языков C и C++, которые позволяют целевым приложениям гарантировать выполнение кода очистки при прерывании выполнения блока кода. Очистка включает такие задачи, как отмена распределения памяти, закрытие файлов и освобождение их дескрипторов. Оператор `try-finally` особенно полезен для подпрограмм, в которых в нескольких местах выполняется проверка на наличие ошибок, способных вызвать преждевременное возвращение из подпрограммы.

Связанные сведения и пример кода см. в разделе [ `try-except` инструкция](../cpp/try-except-statement.md). Дополнительные сведения об структурированной обработке исключений в целом см. в разделе [структурированная обработка исключений](../cpp/structured-exception-handling-c-cpp.md). Дополнительные сведения об обработке исключений в управляемых приложениях с помощью C++/CLI см. [в разделе Обработка `/clr` исключений в ](../extensions/exception-handling-cpp-component-extensions.md).

> [!NOTE]
> Структурированная обработка исключений поддерживается в Win32 для исходных файлов как на C, так и на C++. Однако она не предназначена специально для C++. Для того чтобы ваш код лучше переносился, лучше использовать механизм обработки исключений языка C++. Кроме того, этот механизм отличается большей гибкостью, поскольку может обрабатывать исключения любого типа. Для программ на c++ рекомендуется использовать механизм обработки исключений c++ (операторы[ `try` , `catch` и `throw` ](../cpp/try-throw-and-catch-statements-cpp.md) ).

Составной оператор после **`__try`** предложения является защищенным разделом. Составной оператор после предложения **`__finally`** является обработчиком завершения. Обработчик задает набор действий, которые выполняются при выходе из защищенного раздела, вне зависимости от того, выходит ли он из защищенного раздела на исключение (аномальное завершение) или по стандартному переходу (нормальное завершение).

Управление достигает **`__try`** оператора с помощью простого последовательного выполнения (с переходом). Когда элемент управления вводит **`__try`** , связанный с ним обработчик становится активным. Если поток элементов управления достигает конца блока try, выполнение продолжается следующим образом.

1. Вызывается обработчик завершения.

1. По окончании работы обработчика завершения выполнение продолжается после оператора **`__finally`** . Однако защищенный раздел заканчивается (например, с помощью из **`goto`** защищенного тела или **`return`** оператора) обработчик завершения выполняется *до того, как* поток управления перемещается из защищенного раздела.

   **`__finally`** Инструкция не блокирует поиск соответствующего обработчика исключений.

Если в блоке возникает исключение **`__try`** , операционная система должна найти обработчик для исключения, иначе программа завершится ошибкой. Если обработчик найден, **`__finally`** выполняются все блоки и выполнение возобновляется в обработчике.

Например, предположим, ряд вызовов функций связывает функцию А с функцией D, как показано на следующем рисунке. Каждая функция имеет один обработчик завершения. Если исключение создается в функции D и обрабатывается в функции А, обработчики завершения вызываются в том порядке, в котором система освобождает стек: D, C и B.

![Порядок выполнения обработчика&#45;завершения](../cpp/media/vc38cx1.gif "Порядок выполнения обработчика&#45;завершения") <br/>
Порядок выполнения обработчиков завершения

> [!NOTE]
> Поведение try-finally отличается от других языков, поддерживающих использование **`finally`** , например C#.  Один **`__try`** может иметь либо, но не оба, **`__finally`** и **`__except`** .  Если оба следует использовать одновременно, оператор try-except должен включать внутренней оператор try-finally.  Правила,задающие время выполнения каждого блока, также различаются.

Для совместимости с предыдущими версиями,, **`_try`** **`_finally`** и **`_leave`** являются синонимами для **`__try`** , **`__finally`** и, **`__leave`** если не задан параметр компилятора [ `/Za` (отключить расширения языка)](../build/reference/za-ze-disable-language-extensions.md) .

## <a name="the-__leave-keyword"></a>Ключевое слово __leave

**`__leave`** Ключевое слово допустимо только в защищенном разделе `try-finally` оператора, и его результат — переход к концу защищенного раздела. Выполнение продолжается с первого оператора в обработчике завершения.

**`goto`** Инструкция также может выйти из защищенного раздела, но снижает производительность, так как она вызывает раскрутку стека. Эта **`__leave`** инструкция более эффективна, так как она не приводит к очистке стека.

## <a name="abnormal-termination"></a>Аварийное завершение

Выход из `try-finally` инструкции с помощью функции времени выполнения [longjmp](../c-runtime-library/reference/longjmp.md) считается аномальным завершением. Незаконно переходить к **`__try`** оператору, но его можно переключать с одного на другой. **`__finally`** Должны быть выполнены все инструкции, активные между точкой отправления (нормальное завершение **`__try`** блока) и назначением ( **`__except`** блок, обрабатывающий исключение). Он называется *локальным выкруткой*.

Если **`__try`** блок преждевременно завершается по какой-либо причине, включая переход за пределы блока, система выполняет связанный **`__finally`** блок как часть процесса очистки стека. В таких случаях [`AbnormalTermination`](/windows/win32/Debug/abnormaltermination) функция возвращает значение, **`true`** Если вызывается из **`__finally`** блока. в противном случае возвращается значение **`false`** .

Обработчик завершения не вызывается, если процесс завершается в процессе выполнения `try-finally` инструкции.

**Завершение для конкретной корпорации Майкрософт**

## <a name="see-also"></a>См. также

[Написание обработчика завершения](../cpp/writing-a-termination-handler.md)<br/>
[Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Синтаксис обработчика завершения](/windows/win32/Debug/termination-handler-syntax)
