---
title: Оператор try-finally
ms.date: 11/19/2018
f1_keywords:
- __try
- _try
- __leave_cpp
- __leave
- __finally_cpp
- __try_cpp
- __finally
- _finally
helpviewer_keywords:
- __try keyword [C++]
- __finally keyword [C++]
- __leave keyword [C++]
- try-catch keyword [C++], try-finally keyword
- try-finally keyword [C++]
- __finally keyword [C++], try-finally statement syntax
- __leave keyword [C++], try-finally statement
- structured exception handling [C++], try-finally
ms.assetid: 826e0347-ddfe-4f6e-a7bc-0398e0edc7c2
ms.openlocfilehash: 6234e8a2d2c18177a1e66475fff850c76f7ef73e
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227079"
---
# <a name="try-finally-statement"></a>Оператор try-finally

**Блок, относящийся только к системам Microsoft**

Следующий синтаксис описывает оператор **try-finally** :

> **\_\_try**<br/>
> {\
> &nbsp;&nbsp;&nbsp;&nbsp;Защищенный код \
> }\
> **\_\_счете**\
> {\
> &nbsp;&nbsp;&nbsp;&nbsp;код завершения \
> }

## <a name="grammar"></a>Грамматика

*try-finally-statement*:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;** \_ \_ try** *составной* *оператор* ** \_ \_ finally**

Оператор **try-finally** — это расширение Майкрософт для языков C и C++, которое позволяет целевым приложениям гарантировать выполнение кода очистки при прерывании выполнения блока кода. Очистка включает такие задачи, как отмена распределения памяти, закрытие файлов и освобождение их дескрипторов. Оператор **try-finally** особенно полезен для подпрограмм, в которых есть несколько мест, где выполняется проверка на наличие ошибки, которая может привести к преждевременному возврату из подпрограммы.

Связанные сведения и пример кода см. в разделе [оператор try-except](../cpp/try-except-statement.md). Дополнительные сведения об структурированной обработке исключений в целом см. в разделе [структурированная обработка исключений](../cpp/structured-exception-handling-c-cpp.md). Дополнительные сведения об обработке исключений в управляемых приложениях с помощью C++/CLI см. [в разделе Обработка исключений в разделе/CLR](../extensions/exception-handling-cpp-component-extensions.md).

> [!NOTE]
> Структурированная обработка исключений поддерживается в Win32 для исходных файлов как на C, так и на C++. Однако она не предназначена специально для C++. Для того чтобы ваш код лучше переносился, лучше использовать механизм обработки исключений языка C++. Кроме того, этот механизм отличается большей гибкостью, поскольку может обрабатывать исключения любого типа. Для программ на C++ рекомендуется использовать механизм обработки исключений C++ (операторы[try, catch и Throw](../cpp/try-throw-and-catch-statements-cpp.md) ).

Составной оператор после предложения **__try** является защищенным разделом. Составной оператор после **`__finally`** предложения является обработчиком завершения. Такой обработчик определяет набор действий, выполняемых при выходе из защищенного раздела независимо от того, происходит ли выход в результате исключения (ненормальное завершение) или в результате стандартной передачи управления дальше (нормальное завершение).

Элемент управления достигает **__try** оператора с помощью простого последовательного выполнения (с переходом). Когда элемент управления входит в **__try**, связанный с ним обработчик становится активным. Если поток элементов управления достигает конца блока try, выполнение продолжается следующим образом.

1. Вызывается обработчик завершения.

1. После завершения обработчика завершения выполнение продолжится после **`__finally`** инструкции. Независимо от того, как заканчивается защищенный раздел (например, через **`goto`** защищенный текст или **`return`** инструкцию), обработчик завершения выполняется *до* того, как поток управления перемещается из защищенного раздела.

   **`__finally`** Оператор не блокирует поиск соответствующего обработчика исключений.

Если в блоке **__try** возникает исключение, операционная система должна найти обработчик для исключения, иначе программа завершится ошибкой. Если обработчик найден, **`__finally`** выполняются все блоки и выполнение возобновляется в обработчике.

Например, предположим, ряд вызовов функций связывает функцию А с функцией D, как показано на следующем рисунке. Каждая функция имеет один обработчик завершения. Если исключение создается в функции D и обрабатывается в функции А, обработчики завершения вызываются в том порядке, в котором система освобождает стек: D, C и B.

![Порядок выполнения обработчика&#45;завершения](../cpp/media/vc38cx1.gif "Порядок выполнения обработчика&#45;завершения") <br/>
Порядок выполнения обработчиков завершения

> [!NOTE]
> Поведение try-finally отличается от некоторых других языков, которые поддерживают использование, **например, C#**.  Один **__try** может иметь либо, но не оба, **`__finally`** и **`__except`** .  Если оба следует использовать одновременно, оператор try-except должен включать внутренней оператор try-finally.  Правила,задающие время выполнения каждого блока, также различаются.

Для совместимости с предыдущими версиями **_try**, **_finally**и **_leave** являются синонимами для **__try**, **`__finally`** и, если не **`__leave`** задан параметр компилятора [/Za \( Отключить расширения языка)](../build/reference/za-ze-disable-language-extensions.md) .

## <a name="the-__leave-keyword"></a>Ключевое слово __leave

**`__leave`** Ключевое слово допустимо только в защищенном разделе оператора **try-finally** , и его результат заключается в переходе к концу защищенного раздела. Выполнение продолжается с первого оператора в обработчике завершения.

**`goto`** Инструкция также может выйти из защищенного раздела, но снижает производительность, так как она вызывает раскрутку стека. **`__leave`** Инструкция более эффективна, так как она не приводит к очистке стека.

## <a name="abnormal-termination"></a>Аварийное завершение

Выход из оператора **try-finally** с помощью функции времени выполнения [longjmp](../c-runtime-library/reference/longjmp.md) считается аномальным завершением. Переход к оператору **__try** недопустимым, но допустим, чтобы выйти из него. **`__finally`** Должны быть выполнены все инструкции, активные между точкой отправления (нормальное завершение блока **__try** ) и назначением ( **`__except`** блок, обрабатывающий исключение). Это называется "локальной раскруткой".

Если **`try`** блок преждевременно завершается по какой-либо причине, включая переход за пределы блока, система выполняет связанный блок **finally** как часть процесса очистки стека. В таких случаях функция [абнормалтерминатион](/windows/win32/Debug/abnormaltermination) возвращает значение, **`true`** Если вызывается из блока **finally** ; в противном случае возвращается значение **`false`** .

Обработчик завершения не вызывается, если процесс завершается в процессе выполнения инструкции **try-finally** .

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Написание обработчика завершения](../cpp/writing-a-termination-handler.md)<br/>
[Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[Синтаксис обработчика завершения](/windows/win32/Debug/termination-handler-syntax)
