---
title: Время существования объектов и управление ресурсами (RAII)
description: Следуйте принципу RAII в современном C++ , чтобы избежать утечки ресурсов.
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: 8aa0e1a1-e04d-46b1-acca-1d548490700f
ms.openlocfilehash: 01867ec0a71ba54bb6534da1b408cb0610d652a7
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303375"
---
# <a name="object-lifetime-and-resource-management-raii"></a>Время существования объектов и управление ресурсами (RAII)

В отличие от управляемых языков C++ , не имеет автоматической сборки *мусора*. Это внутренний процесс, который освобождает память кучи и другие ресурсы при выполнении программы. C++ Программа отвечает за возврат всех приобретенных ресурсов в операционную систему. Сбой освобождения неиспользуемого ресурса называется *утечкой*. Потерянные ресурсы недоступны для других программ до завершения процесса. Утечки памяти в частности являются распространенной причиной ошибок в программировании в стиле C.

Современные C++ методы позволяют не использовать память кучи насколько это возможно путем объявления объектов в стеке. Если ресурс слишком велик для стека, он должен *принадлежать* объекту. При инициализации объекта он получает ресурс, который он владеет. Затем объект отвечает за освобождение ресурса в его деструкторе. Сам объект-владелец объявляется в стеке. Принцип, в котором *объекты владеют ресурсами* , также называется "получением ресурсов является инициализацией" или RAII.

Если объект стека, владеющий ресурсами, выходит за пределы области видимости, его деструктор вызывается автоматически. Таким образом, сборка мусора в C++ тесно связана с временем существования объекта и является детерминированной. Ресурс всегда освобождается в известной точке программы, которой можно управлять. Только детерминированные деструкторы, такие как C++ , могут одновременно обрабатывали ресурсы памяти и не памяти.

В следующем примере показан простой объект `w`. Он объявлен в стеке в области видимости функции и уничтожается в конце блока функции. Объект `w` не владеет *ресурсами* (например, памятью, выделенной в куче). Его единственный член `g` сам объявлен в стеке и просто выходит за пределы области действия вместе с `w`. В деструкторе `widget` Специальный код не требуется.

```cpp
class widget {
private:
    gadget g;   // lifetime automatically tied to enclosing object
public:
    void draw();
};

void functionUsingWidget () {
    widget w;   // lifetime automatically tied to enclosing scope
                // constructs w, including the w.g gadget member
    // ...
    w.draw();
    // ...
} // automatic destruction and deallocation for w and w.g
  // automatic exception safety,
  // as if "finally { w.dispose(); w.g.dispose(); }"
```

В следующем примере `w` владеет ресурсом памяти и поэтому должен иметь код в его деструкторе, чтобы удалить память.
 
```cpp
class widget
{
private:
    int* data;
public:
    widget(const int size) { data = new int[size]; } // acquire
    ~widget() { delete[] data; } // release
    void do_something() {}
};

void functionUsingWidget() {
    widget w(1000000);   // lifetime automatically tied to enclosing scope
                        // constructs w, including the w.data member
    w.do_something();

} // automatic destruction and deallocation for w and w.data

```

Начиная с C++ 11, существует лучший способ написать предыдущий пример: с помощью смарт-указателя из стандартной библиотеки. Интеллектуальный указатель обрабатывает выделение и удаление памяти, которую она владеет. Использование смарт-указателя устраняет необходимость в явном деструкторе в классе `widget`.

```cpp
#include <memory>
class widget
{
private:
    std::unique_ptr<int> data;
public:
    widget(const int size) { data = std::make_unique<int>(size); }
    void do_something() {}
};

void functionUsingWidget() {
    widget w(1000000);   // lifetime automatically tied to enclosing scope
                // constructs w, including the w.data gadget member
    // ...
    w.do_something();
    // ...
} // automatic destruction and deallocation for w and w.data

```

При использовании смарт-указателей для выделения памяти можно устранить потенциальные утечки памяти. Эта модель подходит для других ресурсов, таких как дескрипторы файлов или сокеты. Вы можете управлять своими ресурсами аналогичным образом в своих классах. Дополнительные сведения см. в разделе [интеллектуальные указатели](smart-pointers-modern-cpp.md).

Структура C++ гарантирует, что объекты уничтожаются, когда выходят за пределы области. То есть они уничтожаются как блоки, завершаются в обратную последовательность конструкции. При уничтожении объекта его базовые объекты и члены уничтожаются в определенном порядке. Объекты, объявленные вне любого блока в глобальной области, могут привести к проблемам. Отладка может быть сложной, если конструктор глобального объекта вызывает исключение.

## <a name="see-also"></a>См. также

[Добро пожаловать обратно вC++](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
