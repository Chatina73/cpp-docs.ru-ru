---
title: Управление временем жизни и ресурсами объекта (современный C++)
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 8aa0e1a1-e04d-46b1-acca-1d548490700f
ms.openlocfilehash: 5964078960a5b241cb5af369aeddba45a06e48ad
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62245027"
---
# <a name="object-lifetime-and-resource-management-modern-c"></a>Управление временем жизни и ресурсами объекта (современный C++)

В отличие от управляемых языков C++ нет сборщик мусора (GC), который автоматически освобождает ресурсы, нет больше — используемая память по мере выполнения программы. В C++ управление ресурсами непосредственно связано с временем жизни объекта. В этом документе описываются факторы, которые влияют на время жизни объекта в C++ и управлении ими.

C++ не GC, главным образом потому, что он не обрабатывает ресурсы неоптимизированными для памяти. Только детерминированные деструкторы, как в C++ может обрабатывать столь же ресурсы памяти и неоптимизированными для памяти. Сборщик Мусора также имеет другие проблемы, как нагрузка в памяти и ЦП и Населенный пункт. Но universality фундаментальной проблемой, не удается исправить с помощью clever оптимизации.

## <a name="concepts"></a>Основные понятия

Важно помнить в управление временем существования объекта является инкапсуляция, использующий объект не используются ресурсы, которые объект, ответственный за, или как избавиться от них или даже ли ему принадлежат все ресурсы вообще. Он содержит только уничтожаемый объект. Язык C++ core позволяет убедиться, что уничтожение объектов правильность времени, то есть блоки выход в обратном порядке конструкции. При уничтожении объекта, его базовых классов и членов, удаляются в определенном порядке.  Язык автоматически уничтожает объекты, пока вы не выполните особые программные решения как выделение кучи или размещаемые операторы new.  Например [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md) как `unique_ptr` и `shared_ptr`, и контейнеров стандартной библиотеки C++, такие как `vector`, инкапсулировать **новый** /  **Удалить** и `new[]` / `delete[]` в объектах, которые имеют деструкторы. Вот почему так важно использовать интеллектуальные указатели и контейнеры стандартной библиотеки C++.

Другим важным принципом в управление жизненным циклом: деструкторы. Деструкторы инкапсулировать освобождения ресурса.  (Часто используемые является RRID, уничтожение — выпуск ресурсов.)  Ресурс — то, что вы получаете из «система» и придется вернуться позже.  Это наиболее распространенных ресурс, но существуют также файлы, сокеты, текстуры и другие ресурсы неоптимизированными для памяти. Ресурс «владеет» означает, что его можно использовать, когда он нужен, но также необходимо освободить после завершения работы с ним.  При уничтожении объекта, его деструктор освобождает ресурсы, он принадлежит.

Последний является DAG (направленный ациклический граф).  Структура владения в программе forms DAG. Объект не может быть владельцем самого — это не только невозможно, но также по своей природе бессмысленным. Но два объекта могут совместно использовать владение объектом третий.  Несколько типов ссылок возможны в DAG следующим образом: Объект является членом группы B (B владеет объект), хранилищ C `vector<D>` (C принадлежат каждому элементу D), E хранилищ `shared_ptr<F>` (E использует владение F, возможно совместно с другими объектами), и т. д.  Пока существует не было циклов и каждого канала в группе DAG, представленного объектом, имеет деструктор (вместо необработанный указатель, дескриптор или другого механизма), а затем утечки ресурсов невозможно, так как язык не позволяет их. Ресурсы освобождаются сразу после они больше не требуются, без запуска сборщика мусора. Время существования отслеживания издержки – бесплатно для области стека, базовых классов, членов и связанных вариантах и недорогим для `shared_ptr`.

### <a name="heap-based-lifetime"></a>Время жизни на основе кучи

Для времени существования объектов кучи, используйте [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md). Используйте `shared_ptr` и `make_shared` как указатель по умолчанию и распределителя. Используйте `weak_ptr` чтобы прервать циклов, кэширование и наблюдать объекты без влияния на или при условии, что никаких сведений о времени их существования.

```cpp
void func() {

auto p = make_shared<widget>(); // no leak, and exception safe
...
p->draw();

} // no delete required, out-of-scope triggers smart pointer destructor
```

Используйте `unique_ptr` для уникальное владение, например, в *pimpl* идиом. (См. в разделе [Pimpl для инкапсуляции времени компиляции](../cpp/pimpl-for-compile-time-encapsulation-modern-cpp.md).) Сделать `unique_ptr` основной целью все явные **новый** выражения.

```cpp
unique_ptr<widget> p(new widget());
```

Можно использовать необработанные указатели для и отсутствием прав владения и наблюдения. Указатель-владелец может помеха, но он не может вызвать утечку.

```cpp
class node {
  ...
  vector<unique_ptr<node>> children; // node owns children
  node* parent; // node observes parent, which is not a concern
  ...
};
node::node() : parent(...) { children.emplace_back(new node(...) ); }
```

Если необходима оптимизация производительности, может потребоваться использовать *хорошо инкапсулированный* -владелец указатели и явные вызовы для удаления. Например, при реализации структуры данных низкого уровня.

### <a name="stack-based-lifetime"></a>Время жизни на основе стека

В современном C++ *стековую область* — это эффективное средство для написания надежного кода, так как она объединяет автоматического *время существования стека* и *время жизни член данных* с высокой эффективностью — Отслеживание времени существования по существу, даром издержек. Время жизни объекта в куче требует тщательного подхода ручной режим управления и может быть источник утечки ресурсов и повысить эффективность работы, особенно в том случае, если вы работаете с необработанными указателями. Рассмотрим следующий код, который показывает область стека.

```cpp
class widget {
private:
    gadget g;   // lifetime automatically tied to enclosing object
public:
    void draw();
};

void functionUsingWidget () {
    widget w;   // lifetime automatically tied to enclosing scope
                // constructs w, including the w.g gadget member
    // ...
    w.draw();
    // ...
} // automatic destruction and deallocation for w and w.g
  // automatic exception safety,
  // as if "finally { w.dispose(); w.g.dispose(); }"
```

Как можно реже используйте статическое время жизни (глобальные статические, локальную статическую функцию), так как могут возникнуть проблемы. Что происходит, когда конструктор глобального объекта создает исключение? Как правило приложение ошибкам способом, который может быть трудно отладить. Порядок построения создает проблемы для статическое время жизни объектов и не параллельно безопасно. Проблема, не только является создание объектов порядок уничтожения могут быть сложными, особенно в том случае, если задействован полиморфизм. Даже в том случае, если объект или переменная не полиморфных, не имеет сложных или уничтожение упорядочение, по-прежнему проблемы параллелизма поточно ориентированными. Многопоточного приложения не могут безопасно изменять данные в статических объектов без необходимости локальной памяти потока, блокировки ресурсов и другие специальные меры предосторожности.

## <a name="see-also"></a>См. также

[Возвращение к C++ (современный C++)](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
