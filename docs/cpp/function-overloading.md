---
title: Перегрузка функций
ms.date: 03/27/2019
helpviewer_keywords:
- function overloading [C++], about function overloading
- function overloading
- declaring functions [C++], overloading
ms.assetid: 3c9884cb-1d5e-42e8-9a49-6f46141f929e
ms.openlocfilehash: a59c0e27a4500cb20ef42e9a55b4eb0004e07f65
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81368912"
---
# <a name="function-overloading"></a>Перегрузка функций

C++ позволяет определять несколько функций с одинаковым именем в одной области. Эти функции называются *перегруженными* функциями. Перегруженные функции позволяют поставлять различные семантики для функции, в зависимости от типов и количества аргументов.

Например, `print` функция, которая `std::string` принимает аргумент может выполнять очень разные задачи, чем тот, который принимает аргумент **типа двойной.** Перегрузка избавила вас `print_string` от `print_double`необходимости использовать такие имена, как или . Во время компилята компилятор выбирает, какую перегрузку использовать, основываясь на типе аргументов, передаемых абонентом.  Если вы `print(42.0)`позвоните, то `void print(double d)` функция будет вызываться. Если вы `print("hello world")`позвоните, то `void print(std::string)` перегрузка будет вызываться.

Можно перегружать как функции членов, так и функции, не являемые членами. В следующей таблице указаны компоненты объявления функций, используемые языком C++ для различения групп функций с одинаковым именем в одной области.

### <a name="overloading-considerations"></a>Заметки по перегрузке

|Элемент объявления функции|Использование для перегрузки|
|----------------------------------|---------------------------|
|Тип возвращаемого функцией значения|нет|
|Число аргументов|Да|
|Тип аргументов|Да|
|Наличие или отсутствие многоточия|Да|
|Использование имен **typedef**|нет|
|Незаданные границы массива|нет|
|**конст** или **летучих**|Да, при применении ко всей функции|
|[Реф-квалификаторы](#ref-qualifiers)|Да|

## <a name="example"></a>Пример

В следующем примере показано использование перегрузки.

```cpp
// function_overloading.cpp
// compile with: /EHsc
#include <iostream>
#include <math.h>
#include <string>

// Prototype three print functions.
int print(std::string s);             // Print a string.
int print(double dvalue);            // Print a double.
int print(double dvalue, int prec);  // Print a double with a
                                     //  given precision.
using namespace std;
int main(int argc, char *argv[])
{
    const double d = 893094.2987;
    if (argc < 2)
    {
        // These calls to print invoke print( char *s ).
        print("This program requires one argument.");
        print("The argument specifies the number of");
        print("digits precision for the second number");
        print("printed.");
        exit(0);
    }

    // Invoke print( double dvalue ).
    print(d);

    // Invoke print( double dvalue, int prec ).
    print(d, atoi(argv[1]));
}

// Print a string.
int print(string s)
{
    cout << s << endl;
    return cout.good();
}

// Print a double in default precision.
int print(double dvalue)
{
    cout << dvalue << endl;
    return cout.good();
}

//  Print a double in specified precision.
//  Positive numbers for precision indicate how many digits
//  precision after the decimal point to show. Negative
//  numbers for precision indicate where to round the number
//  to the left of the decimal point.
int print(double dvalue, int prec)
{
    // Use table-lookup for rounding/truncation.
    static const double rgPow10[] = {
        10E-7, 10E-6, 10E-5, 10E-4, 10E-3, 10E-2, 10E-1,
        10E0, 10E1,  10E2,  10E3,  10E4, 10E5,  10E6 };
    const int iPowZero = 6;

    // If precision out of range, just print the number.
    if (prec < -6 || prec > 7)
    {
        return print(dvalue);
    }
    // Scale, truncate, then rescale.
    dvalue = floor(dvalue / rgPow10[iPowZero - prec]) *
        rgPow10[iPowZero - prec];
    cout << dvalue << endl;
    return cout.good();
}
```

В приведенном выше коде отображается перегрузка функции `print` в области видимости файла.

Аргумент по умолчанию не считается частью типа функции. Таким образом, он не используется при выборе перегруженных функций. Две функции, которые различаются только в своих аргументах, считаются множественными определениями, а не перегруженными функциями.

Аргументы по умолчанию не могут быть предоставлены для перегруженных операторов.

## <a name="argument-matching"></a>Сопоставление аргументов

Перегруженные функции выбираются для оптимального соответствия объявлений функций в текущей области аргументам, предоставленным в вызове функции. Если подходящая функция найдена, эта функция вызывается. "Подходящий" в этом контексте означает либо:

- Точное соответствие найдено.

- Тривиальное преобразование выполнено.

- Восходящее приведение целого типа выполнено.

- Стандартное преобразование в требуемый тип аргумента существует.

- Пользовательское преобразование (оператор преобразования или конструктор) в требуемый тип аргумента существует.

- Аргументы, представленные многоточием, найдены.

Компилятор создает набор функций-кандидатов для каждого аргумента. Функции-кандидаты — это функции, в которых фактический аргумент в данной позиции можно преобразовать в тип формального аргумента.

Для каждого аргумента создается набор наиболее подходящих функций, и выбранная функция представляет собой пересечение всех наборов. Если на пересечении находится несколько функций, перегрузка является неоднозначной и выдает ошибку. Функция, которая выбирается в конечном итоге, всегда является самой подходящей по сравнению с остальными функциями в группе по крайней мере для одного аргумента. Если нет явного победителя, вызов функции генерирует ошибку.

Рассмотрим следующие объявления (функции отмечены как `Variant 1`, `Variant 2` и `Variant 3` для ссылки в последующем обсуждении).

```cpp
Fraction &Add( Fraction &f, long l );       // Variant 1
Fraction &Add( long l, Fraction &f );       // Variant 2
Fraction &Add( Fraction &f, Fraction &f );  // Variant 3

Fraction F1, F2;
```

Рассмотрим следующий оператор.

```cpp
F1 = Add( F2, 23 );
```

Представленный выше оператор создает два набора.

|Набор 1. Функции-кандидаты, имеющие первый аргумент дробного типа|Набор 2: Кандидат функции, чей второй аргумент может быть преобразован в тип **Int**|
|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Variant 1|Вариант 1 **(Int** может быть преобразован в **длительный** с использованием стандартного преобразования)|
|Variant 3||

Функции в комплекте 2 являются функциями, для которых есть неявные преобразования от фактического типа параметра к формальному типу параметра, и среди таких функций есть функция, для которой "стоимость" преобразования фактического типа параметра в его формальный тип параметра является наименьшей.

Пересечением этих двух наборов является функция Variant 1. Ниже представлен пример неоднозначного вызова функции.

```cpp
F1 = Add( 3, 6 );
```

В предыдущем вызове функции создаются следующие наборы.

|Установить 1: Кандидат функции, которые имеют первый аргумент типа **Int**|Установить 2: Кандидат функции, которые имеют второй аргумент типа **Int**|
|---------------------------------------------------------------------|----------------------------------------------------------------------|
|Вариант 2 **(Int** может быть преобразован в **длительный** с использованием стандартного преобразования)|Вариант 1 **(Int** может быть преобразован в **длительный** с использованием стандартного преобразования)|

Поскольку пересечение этих двух наборов пусто, компилятор генерирует сообщение об ошибке.

Для сопоставления аргументов функция с *аргументами n* по умолчанию рассматривается как *n*no 1 отдельные функции, каждая из которых имеет различное количество аргументов.

Многоточие (...) выступает в качестве подстановочного знака; оно соответствует любому фактическому аргументу. Это может привести к много неоднозначных наборов, если вы не проектируете ваши перегруженные наборы функций с крайней осторожностью.

> [!NOTE]
> Неопределенность перегруженных функций не может быть определена до тех пор, пока не возникнет вызов функции. На этом этапе наборы создаются для каждого аргумента в вызове функции, и можно определить, существует ли неоднозначная перегрузка. Это означает, что неоднозначности могут оставаться в коде до тех пор, пока они не будут вызваны конкретным вызовом функции.

## <a name="argument-type-differences"></a>Различия типов аргументов

Перегруженные функции различают типы аргументов, имеющие разные инициализаторы. Следовательно, аргумент заданного типа и ссылка на этот тип считаются одинаковыми для перегрузки, поскольку имеют одни и те же инициализаторы. Например, `max( double, double )` — то же самое, что и `max( double &, double & )`. Объявление двух таких функций приводит к ошибке.

По той же причине функциональные аргументы типа, измененные **const** или **летучими,** не рассматриваются иначе, чем базовый тип для целей перегрузки.

Однако механизм перегрузки функций может различать ссылки, которые консораются по **конст** и **летучим,** и ссылками на базовый тип. Это делает код, такой как следующий возможный:

```cpp
// argument_type_differences.cpp
// compile with: /EHsc /W3
// C4521 expected
#include <iostream>

using namespace std;
class Over {
public:
   Over() { cout << "Over default constructor\n"; }
   Over( Over &o ) { cout << "Over&\n"; }
   Over( const Over &co ) { cout << "const Over&\n"; }
   Over( volatile Over &vo ) { cout << "volatile Over&\n"; }
};

int main() {
   Over o1;            // Calls default constructor.
   Over o2( o1 );      // Calls Over( Over& ).
   const Over o3;      // Calls default constructor.
   Over o4( o3 );      // Calls Over( const Over& ).
   volatile Over o5;   // Calls default constructor.
   Over o6( o5 );      // Calls Over( volatile Over& ).
}
```

### <a name="output"></a>Выходные данные

```Output
Over default constructor
Over&
Over default constructor
const Over&
Over default constructor
volatile Over&
```

Указатели на **конст** и **летучие** объекты также считаются различными от указателей к базовому типу для целей перегрузки.

## <a name="argument-matching-and-conversions"></a>Сопоставление аргументов и преобразования

Когда компилятор пытается сопоставить фактические аргументы с аргументами в объявлениях функций и точное соответствие найти не удается, для получения правильного типа он может выполнять стандартные или пользовательские преобразования. Для преобразований действуют следующие правила:

- последовательности преобразований, содержащие несколько пользовательских преобразований, не учитываются;

- последовательности преобразований, которые могут быть сокращены путем удаления промежуточных преобразований, не учитываются.

Получающаяся последовательность преобразований (если таковые имеются), называется наилучшей последовательностью сопоставления. Существует несколько способов преобразования объекта типа **Int** в тип **неподписанных длинных** с помощью стандартных конверсий (описанных в [стандартных преобразованиях):](../cpp/standard-conversions.md)

- Преобразование из **Int** в **длинный,** а затем из **долгого** в **неподписанный долго**.

- Преобразование из **Int** в **неподписанный длинный**.

Первая последовательность, хотя она достигает желаемой цели, не является лучшим соответствия последовательности - более короткая последовательность существует.

В представленной ниже таблице показана группа преобразований, называемых тривиальными. Они оказывают ограниченное влияние на определение наилучшей последовательности сопоставления. В списке, приведенном после таблицы, рассматриваются экземпляры, в которых тривиальные преобразования влияют на выбор последовательности.

### <a name="trivial-conversions"></a>Тривиальные преобразования

|Тип, из которого выполняется преобразование|Тип, в который выполняется преобразование|
|-----------------------|---------------------|
|*имя типа*|*имя типа***&**|
|*имя типа***&**|*имя типа*|
|*имя типа* **[ ]**|*имя типа*__\*__|
|имя **(** *(аргумент-лист)* **)** *type-name*|**(** __\*__ *(тип-имя)* **(** *аргумент-список)* **)**|
|*имя типа*|**конст-имя** *типа*|
|*имя типа*|**летучие** *типа-имя*|
|*имя типа*__\*__|**конст-имя** *типа*__\*__|
|*имя типа*__\*__|**летучие** *типа-имя*__\*__|

Ниже приведена последовательность, в которой делаются попытки выполнения преобразований.

1. Точное соответствие. Точное соответствие между типами, с которыми функция вызывается, и типами, объявленными в прототипе функции, всегда является наилучшим соответствием. Последовательности тривиальных преобразований классифицируются как точные соответствия. Тем не менее, последовательности, которые не делают любой из этих преобразований считаются лучше, чем последовательности, которые преобразуют:

   - От указателя, чтобы указатель`type` <strong>\*</strong> **к const** (к **const** `type` <strong>\*</strong>).

   - От указателя, к указателю`type` <strong>\*</strong> на **летучие** `type` <strong>\*</strong> **(летучие** ).

   - От ссылки, на ссылку на **const** (к`type` **&** **const** `type` **&**).

   - От ссылки, на`type` **&** ссылку на **летучие** (к **летучим** `type` **&**).

1. Сопоставление с использованием повышений. Любая последовательность, не классифицируемая как точный совпадение, содержащая только интегральные акции, переходы из **поплавка** в **двойные,** и тривиальные преобразования классифицируются как матч с использованием промо-акций. Хотя сопоставление с использованием повышений не такое хорошее, как точное, оно лучше сопоставления с использованием стандартных преобразований.

1. Сопоставление с использованием стандартных преобразований. Любая последовательность, не классифицированная как точное соответствие или сопоставление с использованием повышений и содержащая только стандартные и тривиальные преобразования, классифицируется как сопоставление с использованием стандартных преобразований. В этой категории применяются следующие правила:

   - Преобразование из указателя в производный класс, в указатель на прямой или `void *` `const void *`косвенный базовый класс предпочтительнее преобразования в или .

   - преобразование из указателя на производный класс в указатель на базовый класс создает тем более хорошее соответствие, чем ближе базовый класс к прямому базовому классу. Предположим, что иерархия классов имеет вид, показанный на следующем рисунке.

![График предпочтительных конверсий](../cpp/media/vc391t1.gif "График предпочтительных конверсий") <br/>
График, показывающий предпочтительные преобразования

Преобразование из типа `D*` в тип `C*` предпочтительнее преобразования из типа `D*` в тип `B*`. Аналогично, преобразование из типа `D*` в тип `B*` предпочтительнее преобразования из типа `D*` в тип `A*`.

Это же правило применяется для преобразований ссылок. Преобразование из типа `D&` в тип `C&` предпочтительнее преобразования из типа `D&` в тип `B&` и т. д.

Это же правило применяется для преобразований указателей на член. Преобразование из типа `T D::*` в тип `T C::*` предпочтительнее преобразования из типа `T D::*` в тип `T B::*` и т. д. (`T` — тип члена.)

Предыдущее правило применяется только в определенном пути наследования. Рассмотрим граф, показанный на следующем рисунке.

![Несколько&#45;наследования, отображение предпочтительных конверсий](../cpp/media/vc391t2.gif "Несколько&#45;наследования, отображение предпочтительных конверсий") <br/>
График с несколькими наследования, показывающий предпочтительные преобразования

Преобразование из типа `C*` в тип `B*` предпочтительнее преобразования из типа `C*` в тип `A*`. Причина заключается в том, что эти преобразования находятся на одном пути и узел `B*` ближе. Однако преобразование из типа `C*` в тип `D*` не `A*`является предпочтительным для преобразования в тип; нет никаких предпочтений, потому что преобразования следуют разными путями.

1. Сопоставление с пользовательскими преобразованиями. Эта последовательность не может быть классифицирована как точное соответствие, совпадение с использованием рекламных акций или совпадение с использованием стандартных конверсий. Чтобы последовательность можно было классифицировать как сопоставление с пользовательскими преобразованиями, она должна содержать только пользовательские, стандартные или тривиальные преобразования. Сопоставление с пользовательскими преобразованиями лучше сопоставления с многоточием, но хуже сопоставления со стандартными преобразованиями.

1. Сопоставление с многоточием. Любая последовательность, соответствующая многоточию в объявлении, классифицируется как сопоставление с многоточием. Это считается самым слабым матчем.

Пользовательские преобразования применяются при отсутствии встроенного повышения или преобразования. Эти преобразования выбираются на основе типа сопоставляемого аргумента. Рассмотрим следующий код.

```cpp
// argument_matching1.cpp
class UDC
{
public:
   operator int()
   {
      return 0;
   }
   operator long();
};

void Print( int i )
{
};

UDC udc;

int main()
{
   Print( udc );
}
```

Доступные пользовательские конверсии для класса `UDC` от типа **Int** и типа **длиной.** Поэтому компилятор проверяет преобразования для типа сопоставляемого объекта: `UDC`. Преобразование в **int** существует, и оно выбрано.

В процессе сопоставления аргументов стандартные преобразования можно применять как к аргументу, так и к результату пользовательского преобразования. Поэтому следующий код работает.

```cpp
void LogToFile( long l );
...
UDC udc;
LogToFile( udc );
```

В предыдущем примере, пользователь-определенный преобразование, оператор `udc` **длинный**, вызывается для преобразования в тип **долго.** Если бы не было определено преобразование, определяемое пользователем в **тип,** преобразование продолжалось бы следующим образом: Тип `UDC` был бы преобразован в тип **Int** с помощью конверсии, определяемой пользователем. Тогда стандартное преобразование от типа **int** к типу **долго** было бы применено в соответствии с аргументом в декларации.

Если для соответствия аргумента требуется какие-либо конверсии, определяемые пользователем, стандартные преобразования не используются при оценке наилучшего соответствия. Даже если более чем одной функции кандидата требует конверсии, определяемой пользователем, функции считаются равными. Пример:

```cpp
// argument_matching2.cpp
// C2668 expected
class UDC1
{
public:
   UDC1( int );  // User-defined conversion from int.
};

class UDC2
{
public:
   UDC2( long ); // User-defined conversion from long.
};

void Func( UDC1 );
void Func( UDC2 );

int main()
{
   Func( 1 );
}
```

Обе версии `Func` требуют преобразования, определяемого пользователем, для преобразования типа **Int** в аргумент типа класса. Возможные преобразования:

- Преобразование из типа `UDC1` **int** в тип (пользователь-определенный конверсии).

- Преобразование из типа **Int** в тип **долго;** затем конвертировать `UDC2` в тип (двухступенчатое преобразование).

Несмотря на то, что второй требует как стандартного преобразования, так и конверсии, определяемой пользователем, эти два преобразования по-прежнему считаются равными.

> [!NOTE]
> Пользовательские преобразования считаются преобразованиями посредством создания или инициализации (функции преобразования). При рассмотрении наилучшего соответствия оба метода считаются одинаковыми.

## <a name="argument-matching-and-the-this-pointer"></a>Сопоставление аргументов и указатель this

Функции членов класса рассматриваются по-разному, в зависимости от того, объявлены ли они **статичными.** Поскольку нестатические функции имеют неявный аргумент, который поставляет **этот** указатель, нестатические функции считаются одним аргументом больше, чем статические функции; в противном случае они объявляются одинаково.

Эти нестатические функции члена требуют, чтобы подразумеваемый **указатель** соответствовал типу объекта, через который вызывается функция, или, для перегруженных операторов, они требовали, чтобы первый аргумент соответствовал объекту, на котором применяется оператор. (Для получения дополнительной информации о перегруженных операторов, [см. Перегруженные операторы](../cpp/operator-overloading.md).)

В отличие от других аргументов в перегруженных функциях, временные объекты не вводятся и не пытаются конверсии при попытке сопоставить **этот** аргумент указателя.

Когда `->` оператор выбора участника используется для доступа к `class_name`функции участника класса, **этот** аргумент указателя имеет тип `class_name * const`. Если члены объявлены **const** или **летучих,** типы `const class_name * const` и `volatile class_name * const`, соответственно.

Оператор выбора члена `.` работает точно так же, за исключением того, что в качестве префикса к имени объекта подставляется неявный оператор взятия адреса `&`. В следующем примере показано, как это делается:

```cpp
// Expression encountered in code
obj.name

// How the compiler treats it
(&obj)->name
```

С точки зрения сопоставления аргументов, левый операнд операторов `->*` и `.*` (указатель на член) обрабатывается так же, как и для операторов `.` и `->` (выбор члена).

## <a name="ref-qualifiers-on-member-functions"></a><a name="ref-qualifiers"></a>Реф-квалификаторы по функциям членов

Квалификаторы Ref позволяют перегружать функцию члена на основе того, является ли объект, на который указывает **это,** rvalue или lvalue.  Эта функция может быть использована, чтобы избежать ненужных операций копирования в сценариях, где вы решили не предоставлять указатель доступ к данным. Например, предположим, что класс `C` инициализирует некоторые данные в `get_data()`своем конструкторе и возвращает копию этих данных в функцию члена. Если объект типа `C` представляет собой rvalue, который вот-вот будет уничтожен, то компилятор выберет `get_data() &&` перегрузку, которая перемещает данные, а не копирует их.

```cpp
#include <iostream>
#include <vector>

using namespace std;

class C
{

public:
    C() {/*expensive initialization*/}
    vector<unsigned> get_data() &
    {
        cout << "lvalue\n";
        return _data;
    }
    vector<unsigned> get_data() &&
    {
        cout << "rvalue\n";
        return std::move(_data);
    }

private:
    vector<unsigned> _data;
};

int main()
{
    C c;
    auto v = c.get_data(); // get a copy. prints "lvalue".
    auto v2 = C().get_data(); // get the original. prints "rvalue"
    return 0;
}
```

## <a name="restrictions-on-overloading"></a>Ограничения на перегрузку

К допустимому набору перегруженных функций применяется несколько ограничений.

- Любые две функции в наборе перегруженных функций должны иметь разные списки аргументов.

- Перегрузка функций со списками аргументов одного типа лишь на основании возвращаемого типа недопустима.

     **Microsoft Специфический**

Вы можете перегружать **оператора новым** исключительно на основе типа возврата - в частности, на основе указанного модификатора памяти модели.

**END Microsoft Специфический**

- Функции участника не могут быть перегружены только на основе одной из них, статичной, а другой нестатичной.

- **декларации типа** не определяют новые типы; они вводят синонимы для существующих типов. Они не влияют на механизм перегрузки. Рассмотрим следующий код.

    ```cpp
    typedef char * PSTR;

    void Print( char *szToPrint );
    void Print( PSTR szToPrint );
    ```

   Две указанные выше функции имеют идентичные списки аргументов. `PSTR`является синонимом типа `char *`. В области члена этот код возвращает ошибку.

- Перечисляемые типы являются отдельными типами и могут использоваться для различения перегруженных функций.

- Типы "array of" и "pointer to" считаются идентичными для целей различения перегруженных функций, но только для познавательных измеренных массивов. Вот почему эти перегруженные функции конфликтуют и генерируют сообщение об ошибке:

    ```cpp
    void Print( char *szToPrint );
    void Print( char szToPrint[] );
    ```

   В случае многомерных массивов второе и все последующие измерения являются частью типа. Поэтому они используются для различения перегруженных функций.

    ```cpp
    void Print( char szToPrint[] );
    void Print( char szToPrint[][7] );
    void Print( char szToPrint[][9][42] );
    ```

## <a name="overloading-overriding-and-hiding"></a>Перегрузка, переопределение и сокрытие

Любые два объявления функции с одинаковым именем в одной области видимости могут ссылаться на одну функцию или на две разные перегруженные функции. Если списки аргументов в объявлениях содержат аргументы эквивалентных типов (как описано в предыдущем разделе), эти объявления относятся к одной и той же функции. В противном случае они ссылаются на две различные функции, которые выбираются с использованием перегрузки.

Сфера применения класса строго соблюдается; таким образом, функция, заявленная в базовом классе, не в той же области, что и функция, заявленная в производном классе. Если функция в производном классе объявляется с тем же именем, что и виртуальная функция в базовом классе, функция производного класса *перекрывает* функцию базового класса. Для получения дополнительной информации [см.](../cpp/virtual-functions.md)

Если функция базового класса не объявлена «виртуальной», то функция производного класса, как говорят, *скрывает* ее. И переопределение, и сокрытие отличаются от перегрузки.

Область блокировки строго соблюдается; таким образом, функция, заявленная в области файла, не в той же области, что и функция, объявленная локально. Если локально объявленная функция имеет то же имя, что и функция, объявленная в области файла, локально объявленная функция скрывает функцию области файла, не вызывая перегрузки. Пример:

```cpp
// declaration_matching1.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
void func( int i )
{
    cout << "Called file-scoped func : " << i << endl;
}

void func( char *sz )
{
   cout << "Called locally declared func : " << sz << endl;
}

int main()
{
   // Declare func local to main.
   extern void func( char *sz );

   func( 3 );   // C2664 Error. func( int ) is hidden.
   func( "s" );
}
```

В предыдущем коде показаны два определения функции `func`. Определение, которое принимает `char *` аргумент типа `main` является локальным из-за **оператора extern.** Таким образом, определение, которое принимает аргумент типа **Int** `func` скрыта, и первый вызов по ошибке.

В случае перегруженных функций-членов различным версиям функции могут предоставляться разные права доступа. Они по-прежнему считаются находящимися в области видимости включающего класса и, таким образом, являются перегруженными функциями. Рассмотрим следующий код, в котором функция-член `Deposit` перегружена; одна версия является открытой, вторая — закрытой.

Целью кода в примере является предоставление класса `Account`, в котором для внесения средств требуется правильный пароль. Это делается с помощью перегрузки.

Вызов `Deposit` в `Account::Deposit` вызовы функции частного члена. Этот вызов является `Account::Deposit` правильным, поскольку функция члена является и имеет доступ к частным членам класса.

```cpp
// declaration_matching2.cpp
class Account
{
public:
   Account()
   {
   }
   double Deposit( double dAmount, char *szPassword );

private:
   double Deposit( double dAmount )
   {
      return 0.0;
   }
   int Validate( char *szPassword )
   {
      return 0;
   }

};

int main()
{
    // Allocate a new object of type Account.
    Account *pAcct = new Account;

    // Deposit $57.22. Error: calls a private function.
    // pAcct->Deposit( 57.22 );

    // Deposit $57.22 and supply a password. OK: calls a
    //  public function.
    pAcct->Deposit( 52.77, "pswd" );
}

double Account::Deposit( double dAmount, char *szPassword )
{
   if ( Validate( szPassword ) )
      return Deposit( dAmount );
   else
      return 0.0;
}
```

## <a name="see-also"></a>См. также раздел

[Функции (C++)](../cpp/functions-cpp.md)
