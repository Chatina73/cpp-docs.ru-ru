---
title: Перегрузка функций
ms.date: 03/27/2019
helpviewer_keywords:
- function overloading [C++], about function overloading
- function overloading
- declaring functions [C++], overloading
ms.assetid: 3c9884cb-1d5e-42e8-9a49-6f46141f929e
ms.openlocfilehash: fe390ae190f422f7951f7101a7c08808b1c6a526
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80179787"
---
# <a name="function-overloading"></a>Перегрузка функций

C++ позволяет определять несколько функций с одинаковым именем в одной области. Эти функции называются *перегруженными* функциями. Перегруженные функции позволяют указать другую семантику для функции в зависимости от типов и числа аргументов.

Например, функция `print`, которая принимает аргумент `std::string`, может выполнять задачи, отличные от тех, которые принимают аргумент типа **Double**. Перегрузка позволяет избежать использования таких имен, как `print_string` или `print_double`. Во время компиляции компилятор выбирает, какую перегрузку следует использовать в зависимости от типа аргументов, передаваемых вызывающим объектом.  При вызове `print(42.0)`будет вызвана функция `void print(double d)`. При вызове `print("hello world")`будет вызвана перегрузка `void print(std::string)`.

Можно перегружать как функции-члены, так и функции, не являющиеся членами. В следующей таблице указаны компоненты объявления функций, используемые языком C++ для различения групп функций с одинаковым именем в одной области.

### <a name="overloading-considerations"></a>Заметки по перегрузке

|Элемент объявления функции|Использование для перегрузки|
|----------------------------------|---------------------------|
|Тип возвращаемого функцией значения|нет|
|Число аргументов|Да|
|Тип аргументов|Да|
|Наличие или отсутствие многоточия|Да|
|Использование **typedef** Names|нет|
|Незаданные границы массива|нет|
|**const** или **volatile**|Да, при применении ко всей функции|
|[Квалификаторы ref](#ref-qualifiers)|Да|

## <a name="example"></a>Пример

В следующем примере показано использование перегрузки.

```cpp
// function_overloading.cpp
// compile with: /EHsc
#include <iostream>
#include <math.h>
#include <string>

// Prototype three print functions.
int print(std::string s);             // Print a string.
int print(double dvalue);            // Print a double.
int print(double dvalue, int prec);  // Print a double with a
                                     //  given precision.
using namespace std;
int main(int argc, char *argv[])
{
    const double d = 893094.2987;
    if (argc < 2)
    {
        // These calls to print invoke print( char *s ).
        print("This program requires one argument.");
        print("The argument specifies the number of");
        print("digits precision for the second number");
        print("printed.");
        exit(0);
    }

    // Invoke print( double dvalue ).
    print(d);

    // Invoke print( double dvalue, int prec ).
    print(d, atoi(argv[1]));
}

// Print a string.
int print(string s)
{
    cout << s << endl;
    return cout.good();
}

// Print a double in default precision.
int print(double dvalue)
{
    cout << dvalue << endl;
    return cout.good();
}

//  Print a double in specified precision.
//  Positive numbers for precision indicate how many digits
//  precision after the decimal point to show. Negative
//  numbers for precision indicate where to round the number
//  to the left of the decimal point.
int print(double dvalue, int prec)
{
    // Use table-lookup for rounding/truncation.
    static const double rgPow10[] = {
        10E-7, 10E-6, 10E-5, 10E-4, 10E-3, 10E-2, 10E-1,
        10E0, 10E1,  10E2,  10E3,  10E4, 10E5,  10E6 };
    const int iPowZero = 6;

    // If precision out of range, just print the number.
    if (prec < -6 || prec > 7)
    {
        return print(dvalue);
    }
    // Scale, truncate, then rescale.
    dvalue = floor(dvalue / rgPow10[iPowZero - prec]) *
        rgPow10[iPowZero - prec];
    cout << dvalue << endl;
    return cout.good();
}
```

В приведенном выше коде отображается перегрузка функции `print` в области видимости файла.

Аргумент по умолчанию не считается частью типа функции. Поэтому он не используется при выборе перегруженных функций. Две функции, которые различаются только в своих аргументах, считаются множественными определениями, а не перегруженными функциями.

Аргументы по умолчанию не могут быть указаны для перегруженных операторов.

## <a name="argument-matching"></a>Сопоставление аргументов

Перегруженные функции выбираются для оптимального соответствия объявлений функций в текущей области аргументам, предоставленным в вызове функции. Если подходящая функция найдена, эта функция вызывается. Подходящее значение в этом контексте означает:

- Точное соответствие найдено.

- Тривиальное преобразование выполнено.

- Восходящее приведение целого типа выполнено.

- Стандартное преобразование в требуемый тип аргумента существует.

- Пользовательское преобразование (оператор преобразования или конструктор) в требуемый тип аргумента существует.

- Аргументы, представленные многоточием, найдены.

Компилятор создает набор функций-кандидатов для каждого аргумента. Функции-кандидаты — это функции, в которых фактический аргумент в данной позиции можно преобразовать в тип формального аргумента.

Для каждого аргумента создается набор наиболее подходящих функций, и выбранная функция представляет собой пересечение всех наборов. Если на пересечении находится несколько функций, перегрузка является неоднозначной и выдает ошибку. Функция, которая выбирается в конечном итоге, всегда является самой подходящей по сравнению с остальными функциями в группе по крайней мере для одного аргумента. Если нет ничего ясного, вызов функции приведет к ошибке.

Рассмотрим следующие объявления (функции отмечены как `Variant 1`, `Variant 2` и `Variant 3` для ссылки в последующем обсуждении).

```cpp
Fraction &Add( Fraction &f, long l );       // Variant 1
Fraction &Add( long l, Fraction &f );       // Variant 2
Fraction &Add( Fraction &f, Fraction &f );  // Variant 3

Fraction F1, F2;
```

Рассмотрим следующий оператор.

```cpp
F1 = Add( F2, 23 );
```

Представленный выше оператор создает два набора.

|Набор 1. Функции-кандидаты, имеющие первый аргумент дробного типа|Set 2: функции-кандидаты, второй аргумент которого можно преобразовать в тип **int**|
|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Variant 1|Вариант 1 (**int** можно преобразовать в **Long** с помощью стандартного преобразования)|
|Variant 3||

Функции в наборе 2 — это функции, для которых существуют неявные преобразования фактического типа параметра в формальный тип параметра, а в таких функциях есть функция, для которой «Cost» преобразования фактического типа параметра в формальный тип параметра — минимальные.

Пересечением этих двух наборов является функция Variant 1. Ниже представлен пример неоднозначного вызова функции.

```cpp
F1 = Add( 3, 6 );
```

В предыдущем вызове функции создаются следующие наборы.

|Set 1: потенциальные функции, имеющие первый аргумент типа **int**|Set 2: потенциальные функции с вторым аргументом типа **int**|
|---------------------------------------------------------------------|----------------------------------------------------------------------|
|Вариант 2 (**int** можно преобразовать в **Long** с помощью стандартного преобразования)|Вариант 1 (**int** можно преобразовать в **Long** с помощью стандартного преобразования)|

Поскольку пересечение этих двух наборов пусто, компилятор выдает сообщение об ошибке.

Для сопоставления аргументов функция с *n* аргументами по умолчанию обрабатывается как *n*+ 1 отдельных функций, каждая из которых имеет разное число аргументов.

Многоточие (...) выступает в качестве подстановочного знака; оно соответствует любому фактическому аргументу. Это может привести к созданию множества неоднозначных наборов, если вы не разрабатываете перегруженные наборы функций с крайней осторожностью.

> [!NOTE]
>  Неоднозначность перегруженных функций не может быть определена до тех пор, пока не будет обнаружен вызов функции. На этом этапе наборы создаются для каждого аргумента в вызове функции, и можно определить, существует ли неоднозначная перегрузка. Это означает, что неоднозначности могут оставаться в коде до тех пор, пока они не будут вызваны конкретным вызовом функции.

## <a name="argument-type-differences"></a>Различия типов аргументов

Перегруженные функции различают типы аргументов, имеющие разные инициализаторы. Следовательно, аргумент заданного типа и ссылка на этот тип считаются одинаковыми для перегрузки, поскольку имеют одни и те же инициализаторы. Например, `max( double, double )` — то же самое, что и `max( double &, double & )`. Объявление двух таких функций приводит к ошибке.

По той же причине аргументы функции типа, измененные **const** или **volatile** , не обрабатываются иначе, чем базовый тип в целях перегрузки.

Однако механизм перегрузки функций может отличать ссылки, уточняющие их на **const** и **volatile** , и на базовый тип. Он делает код следующим:

```cpp
// argument_type_differences.cpp
// compile with: /EHsc /W3
// C4521 expected
#include <iostream>

using namespace std;
class Over {
public:
   Over() { cout << "Over default constructor\n"; }
   Over( Over &o ) { cout << "Over&\n"; }
   Over( const Over &co ) { cout << "const Over&\n"; }
   Over( volatile Over &vo ) { cout << "volatile Over&\n"; }
};

int main() {
   Over o1;            // Calls default constructor.
   Over o2( o1 );      // Calls Over( Over& ).
   const Over o3;      // Calls default constructor.
   Over o4( o3 );      // Calls Over( const Over& ).
   volatile Over o5;   // Calls default constructor.
   Over o6( o5 );      // Calls Over( volatile Over& ).
}
```

### <a name="output"></a>Выходные данные

```Output
Over default constructor
Over&
Over default constructor
const Over&
Over default constructor
volatile Over&
```

Указатели на **константные** и **временные** объекты также считаются различными указателями на базовый тип в целях перегрузки.

## <a name="argument-matching-and-conversions"></a>Сопоставление аргументов и преобразования

Когда компилятор пытается сопоставить фактические аргументы с аргументами в объявлениях функций и точное соответствие найти не удается, для получения правильного типа он может выполнять стандартные или пользовательские преобразования. Для преобразований действуют следующие правила:

- последовательности преобразований, содержащие несколько пользовательских преобразований, не учитываются;

- последовательности преобразований, которые могут быть сокращены путем удаления промежуточных преобразований, не учитываются.

Получающаяся последовательность преобразований (если таковые имеются), называется наилучшей последовательностью сопоставления. Существует несколько способов преобразования объекта типа **int** в тип **без знака Long** с помощью стандартных преобразований (см. описание в разделе [стандартные преобразования](../cpp/standard-conversions.md)):

- Преобразование **типа int** в **Long** , а затем от **Long** к Long **без знака**.

- Преобразование **типа int в тип** **Long без знака**.

Первая последовательность, хотя она достигает требуемой цели, не является наилучшей совпадающей последовательностью — существует более короткая последовательность.

В представленной ниже таблице показана группа преобразований, называемых тривиальными. Они оказывают ограниченное влияние на определение наилучшей последовательности сопоставления. В списке, приведенном после таблицы, рассматриваются экземпляры, в которых тривиальные преобразования влияют на выбор последовательности.

### <a name="trivial-conversions"></a>Тривиальные преобразования

|Тип, из которого выполняется преобразование|Тип, в который выполняется преобразование|
|-----------------------|---------------------|
|*имя типа*|*имя типа* **&**|
|*имя типа* **&**|*имя типа*|
|*Type-Name* **[]**|*имя типа* __\*__|
|*Type-Name* **(** *Argument-List* **)**|**(** __\*__ *Type-Name* **) (** *Argument-List* **)**|
|*имя типа*|**const** *-имя типа*|
|*имя типа*|**изменяемое** *имя типа*|
|*имя типа* __\*__|Тип **const** *— имя* __\*__|
|*имя типа* __\*__|**изменяемое** *имя типа* __\*__|

Ниже приведена последовательность, в которой делаются попытки выполнения преобразований.

1. Точное соответствие. Точное соответствие между типами, с которыми функция вызывается, и типами, объявленными в прототипе функции, всегда является наилучшим соответствием. Последовательности тривиальных преобразований классифицируются как точные соответствия. Однако последовательности, которые не делают ни одно из этих преобразований, рассматриваются лучше, чем последовательности, которые преобразуют:

   - Указатель с указателя на **const** (`type` <strong>\*</strong> в **константу** `type` <strong>\*</strong>).

   - От указателя к указателю на **volatile** (`type` <strong>\*</strong> к **volatile** `type` <strong>\*</strong>).

   - Ссылка на ссылку на **const** (`type` **&** в **const** `type` **&** ).

   - Из ссылки, чтобы ссылаться на **volatile** (`type` **&** в **volatile** `type` **&** ).

1. Сопоставление с использованием повышений. Любая последовательность, не классифицированная как точное совпадение, которая содержит только целочисленные акции, преобразования от **float** к **Double**, а тривиальные преобразования классифицируются как соответствие с помощью специальных предложений. Хотя сопоставление с использованием повышений не такое хорошее, как точное, оно лучше сопоставления с использованием стандартных преобразований.

1. Сопоставление с использованием стандартных преобразований. Любая последовательность, не классифицированная как точное соответствие или сопоставление с использованием повышений и содержащая только стандартные и тривиальные преобразования, классифицируется как сопоставление с использованием стандартных преобразований. В этой категории применяются следующие правила:

   - Преобразование указателя на производный класс в указатель на прямой или косвенный базовый класс является предпочтительным для преобразования в `void *` или `const void *`.

   - преобразование из указателя на производный класс в указатель на базовый класс создает тем более хорошее соответствие, чем ближе базовый класс к прямому базовому классу. Предположим, что иерархия классов имеет вид, показанный на следующем рисунке.

![Граф предпочтительных преобразований](../cpp/media/vc391t1.gif "Граф предпочтительных преобразований") <br/>
Граф, демонстрирующий предпочтительные преобразования

Преобразование из типа `D*` в тип `C*` предпочтительнее преобразования из типа `D*` в тип `B*`. Аналогично, преобразование из типа `D*` в тип `B*` предпочтительнее преобразования из типа `D*` в тип `A*`.

Это же правило применяется для преобразований ссылок. Преобразование из типа `D&` в тип `C&` предпочтительнее преобразования из типа `D&` в тип `B&` и т. д.

Это же правило применяется для преобразований указателей на член. Преобразование из типа `T D::*` в тип `T C::*` предпочтительнее преобразования из типа `T D::*` в тип `T B::*` и т. д. (`T` — тип члена.)

Предыдущее правило применяется только в определенном пути наследования. Рассмотрим граф, показанный на следующем рисунке.

![Множественное&#45;наследование, показывающее предпочтительные преобразования](../cpp/media/vc391t2.gif "Множественное&#45;наследование, показывающее предпочтительные преобразования") <br/>
Граф множественного наследования, демонстрирующий предпочтительные преобразования

Преобразование из типа `C*` в тип `B*` предпочтительнее преобразования из типа `C*` в тип `A*`. Причина заключается в том, что эти преобразования находятся на одном пути и узел `B*` ближе. Однако преобразование из типа `C*` в тип `D*` не является предпочтительным для преобразования в тип `A*`; предпочтений нет, так как преобразования следуют по разным путям.

1. Сопоставление с пользовательскими преобразованиями. Эта последовательность не может классифицироваться как точное совпадение, сопоставление с помощью рекламных акций или соответствие с помощью стандартных преобразований. Чтобы последовательность можно было классифицировать как сопоставление с пользовательскими преобразованиями, она должна содержать только пользовательские, стандартные или тривиальные преобразования. Сопоставление с пользовательскими преобразованиями лучше сопоставления с многоточием, но хуже сопоставления со стандартными преобразованиями.

1. Сопоставление с многоточием. Любая последовательность, соответствующая многоточию в объявлении, классифицируется как сопоставление с многоточием. Это считается самым слабым совпадением.

Пользовательские преобразования применяются при отсутствии встроенного повышения или преобразования. Эти преобразования выбираются на основе типа сопоставляемого аргумента. Рассмотрим следующий код.

```cpp
// argument_matching1.cpp
class UDC
{
public:
   operator int()
   {
      return 0;
   }
   operator long();
};

void Print( int i )
{
};

UDC udc;

int main()
{
   Print( udc );
}
```

Доступные пользовательские преобразования для класса `UDC` относятся к типу **int** и типу **Long**. Поэтому компилятор проверяет преобразования для типа сопоставляемого объекта: `UDC`. Существует преобразование в **тип int** и оно выбрано.

В процессе сопоставления аргументов стандартные преобразования можно применять как к аргументу, так и к результату пользовательского преобразования. Поэтому следующий код работает.

```cpp
void LogToFile( long l );
...
UDC udc;
LogToFile( udc );
```

В предыдущем примере для преобразования `udc` в тип **Long**вызывается определяемое пользователем преобразование **operator of Long**. Если не было определено пользовательское преобразование в тип **Long** , преобразование было бы выполнено следующим образом: тип `UDC` был преобразован в тип **int** с помощью пользовательского преобразования. Затем было применено стандартное преобразование типа **int** к типу **Long** , чтобы соответствовать аргументу в объявлении.

Если какие-либо определенные пользователем преобразования должны соответствовать аргументу, стандартные преобразования не используются при вычислении наилучшего соответствия. Даже если для нескольких потенциальных функций требуется определенное пользователем преобразование, эти функции считаются равными. Пример:

```cpp
// argument_matching2.cpp
// C2668 expected
class UDC1
{
public:
   UDC1( int );  // User-defined conversion from int.
};

class UDC2
{
public:
   UDC2( long ); // User-defined conversion from long.
};

void Func( UDC1 );
void Func( UDC2 );

int main()
{
   Func( 1 );
}
```

Обеим версиям `Func` требуется определенное пользователем преобразование для преобразования типа **int** в аргумент типа класса. Возможные преобразования:

- Преобразование типа **int** в тип `UDC1` (определяемое пользователем преобразование).

- Преобразование типа **int** в тип **Long**; Затем преобразуйте в тип `UDC2` (преобразование из двух шагов).

Несмотря на то, что второй требуется как стандартное преобразование, так и определяемое пользователем преобразование, два преобразования по-прежнему считаются равными.

> [!NOTE]
>  Пользовательские преобразования считаются преобразованиями посредством создания или инициализации (функции преобразования). При рассмотрении наилучшего соответствия оба метода считаются одинаковыми.

## <a name="argument-matching-and-the-this-pointer"></a>Сопоставление аргументов и указатель this

Функции-члены класса обрабатываются по-разному, в зависимости от того, объявлены ли они как **статические**. Поскольку нестатические функции имеют неявный аргумент, который предоставляет **этот** указатель, нестатические функции считаются еще одним аргументом, чем статические функции. в противном случае они объявляются одинаково.

Для этих нестатических функций-членов требуется, чтобы подразумеваемый **этот** указатель совпадал с типом объекта, через который вызывается функция, или для перегруженных операторов требуется, чтобы первый аргумент соответствовал объекту, к которому применяется оператор. (Дополнительные сведения о перегруженных операторах см. в разделе [перегруженные операторы](../cpp/operator-overloading.md).)

В отличие от других аргументов перегруженных функций, временные объекты не вводятся, и при попытке сопоставления **этого** аргумента указателя попытки преобразования не выполняются.

Если оператор выбора члена `->` используется для доступа к функции-члену класса `class_name`, **этот** аргумент-указатель имеет тип `class_name * const`. Если члены объявляются как **const** или **volatile**, то типы `const class_name * const` и `volatile class_name * const`соответственно.

Оператор выбора члена `.` работает точно так же, за исключением того, что в качестве префикса к имени объекта подставляется неявный оператор взятия адреса `&`. В следующем примере показано, как это делается:

```cpp
// Expression encountered in code
obj.name

// How the compiler treats it
(&obj)->name
```

С точки зрения сопоставления аргументов, левый операнд операторов `->*` и `.*` (указатель на член) обрабатывается так же, как и для операторов `.` и `->` (выбор члена).

## <a name="ref-qualifiers-on-member-functions"></a><a name="ref-qualifiers"></a>Квалификаторы ref для функций-членов

Квалификаторы ref позволяют перегружать функцию-член на основе того **, является ли** объект, на который указывает, значением rvalue или lvalue.  Эту функцию можно использовать, чтобы избежать ненужных операций копирования в сценариях, где вы решили не предоставлять доступ к данным с помощью указателя. Например, предположим, что класс `C` инициализирует некоторые данные в своем конструкторе и возвращает копию этих данных в функции-члене `get_data()`. Если объект типа `C` является rvalue, который будет уничтожен, компилятор выберет перегрузку `get_data() &&`, которая перемещает данные, а не копирует их.

```cpp
#include <iostream>
#include <vector>

using namespace std;

class C
{

public:
    C() {/*expensive initialization*/}
    vector<unsigned> get_data() &
    {
        cout << "lvalue\n";
        return _data;
    }
    vector<unsigned> get_data() &&
    {
        cout << "rvalue\n";
        return std::move(_data);
    }

private:
    vector<unsigned> _data;
};

int main()
{
    C c;
    auto v = c.get_data(); // get a copy. prints "lvalue".
    auto v2 = C().get_data(); // get the original. prints "rvalue"
    return 0;
}
```

## <a name="restrictions-on-overloading"></a>Ограничения на перегрузку

К допустимому набору перегруженных функций применяется несколько ограничений.

- Любые две функции в наборе перегруженных функций должны иметь разные списки аргументов.

- Перегрузка функций со списками аргументов одного типа лишь на основании возвращаемого типа недопустима.

     **Блок, относящийся только к системам Microsoft**

**Оператор New** можно перегружать только на основе возвращаемого типа, а именно на основе указанного модификатора модели памяти.

**Завершение блока, относящегося только к системам Майкрософт**

- Функции элементов не могут быть перегружены только на основе одного статического, а другого нестатического.

- объявления **typedef** не определяют новые типы. они представляют синонимы для существующих типов. Они не влияют на механизм перегрузки. Рассмотрим следующий код.

    ```cpp
    typedef char * PSTR;

    void Print( char *szToPrint );
    void Print( PSTR szToPrint );
    ```

   Две указанные выше функции имеют идентичные списки аргументов. `PSTR` является синонимом для типа `char *`. В области члена этот код возвращает ошибку.

- Перечисляемые типы являются отдельными типами и могут использоваться для различения перегруженных функций.

- Типы "массив" и "указатель на" считаются идентичными в целях различения перегруженных функций, но только для одноэлементных измерений массивов. Вот почему эти перегруженные функции конфликтуют и создают сообщение об ошибке:

    ```cpp
    void Print( char *szToPrint );
    void Print( char szToPrint[] );
    ```

   В случае многомерных массивов второе и все последующие измерения являются частью типа. Поэтому они используются для различения перегруженных функций.

    ```cpp
    void Print( char szToPrint[] );
    void Print( char szToPrint[][7] );
    void Print( char szToPrint[][9][42] );
    ```

## <a name="overloading-overriding-and-hiding"></a>Перегрузка, переопределение и скрытие

Любые два объявления функции с одинаковым именем в одной области видимости могут ссылаться на одну функцию или на две разные перегруженные функции. Если списки аргументов в объявлениях содержат аргументы эквивалентных типов (как описано в предыдущем разделе), эти объявления относятся к одной и той же функции. В противном случае они ссылаются на две различные функции, которые выбираются с использованием перегрузки.

Область класса строго наблюдалась; Поэтому функция, объявленная в базовом классе, находится не в той же области, что и функция, объявленная в производном классе. Если функция в производном классе объявлена с тем же именем, что и виртуальная функция в базовом классе, функция производного класса *переопределяет* функцию базового класса. Дополнительные сведения см. в разделе [виртуальные функции](../cpp/virtual-functions.md).

Если функция базового класса не объявлена как Virtual, то говорят, что функция производного класса *скрывает* ее. Переопределение и скрытие отличаются от перегрузки.

Область видимости блока строго наблюдалась; Поэтому функция, объявленная в области файла, не находится в той же области, что и функция, объявленная локально. Если локально объявленная функция имеет то же имя, что и функция, объявленная в области файла, локально объявленная функция скрывает функцию области файла, не вызывая перегрузки. Пример:

```cpp
// declaration_matching1.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
void func( int i )
{
    cout << "Called file-scoped func : " << i << endl;
}

void func( char *sz )
{
   cout << "Called locally declared func : " << sz << endl;
}

int main()
{
   // Declare func local to main.
   extern void func( char *sz );

   func( 3 );   // C2664 Error. func( int ) is hidden.
   func( "s" );
}
```

В предыдущем коде показаны два определения функции `func`. Определение, принимающее аргумент типа `char *`, является локальным для `main` из-за оператора **extern** . Поэтому определение, принимающее аргумент типа **int** , скрыто, а первый вызов `func` имеет значение Error.

В случае перегруженных функций-членов различным версиям функции могут предоставляться разные права доступа. Они по-прежнему считаются находящимися в области видимости включающего класса и, таким образом, являются перегруженными функциями. Рассмотрим следующий код, в котором функция-член `Deposit` перегружена; одна версия является открытой, вторая — закрытой.

Целью кода в примере является предоставление класса `Account`, в котором для внесения средств требуется правильный пароль. Для этого используется перегрузка.

Вызов `Deposit` в `Account::Deposit` вызывает закрытую функцию члена. Этот вызов является правильным, так как `Account::Deposit` является функцией-членом и имеет доступ к закрытым членам класса.

```cpp
// declaration_matching2.cpp
class Account
{
public:
   Account()
   {
   }
   double Deposit( double dAmount, char *szPassword );

private:
   double Deposit( double dAmount )
   {
      return 0.0;
   }
   int Validate( char *szPassword )
   {
      return 0;
   }

};

int main()
{
    // Allocate a new object of type Account.
    Account *pAcct = new Account;

    // Deposit $57.22. Error: calls a private function.
    // pAcct->Deposit( 57.22 );

    // Deposit $57.22 and supply a password. OK: calls a
    //  public function.
    pAcct->Deposit( 52.77, "pswd" );
}

double Account::Deposit( double dAmount, char *szPassword )
{
   if ( Validate( szPassword ) )
      return Deposit( dAmount );
   else
      return 0.0;
}
```

## <a name="see-also"></a>См. также раздел

[Функции (C++)](../cpp/functions-cpp.md)
