---
title: Перегрузка функций
ms.date: 03/27/2019
helpviewer_keywords:
- function overloading [C++], about function overloading
- function overloading
- declaring functions [C++], overloading
ms.assetid: 3c9884cb-1d5e-42e8-9a49-6f46141f929e
ms.openlocfilehash: 6cc432e404a7a66de63cf87f0fe87f0ccdcb5d70
ms.sourcegitcommit: 309dc532f13242854b47759cef846de59bb807f1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/28/2019
ms.locfileid: "58565978"
---
# <a name="function-overloading"></a>Перегрузка функций

C++ позволяет определять несколько функций с одинаковым именем в одной области. При вызове этих функций *перегружены* функции. Перегруженные функции позволяют указать различную семантику для функции, в зависимости от типов и числа аргументов.

Например `print` функцию, которая принимает `std::string` аргумент может выполнять совершенно разные задачи, чем та, которая принимает аргумент типа **двойные**. Перегрузка избавляет от необходимости использовать имена, такие как `print_string` или `print_double`. Во время компиляции компилятор выбирает перегрузку, которую нужно использовать в зависимости от типа аргументов, передаваемых в вызывающим объектом.  При вызове метода `print(42.0)`, а затем `void print(double d)` функция будет вызываться. При вызове метода `print("hello world")`, а затем `void print(std::string)` перегрузки будет вызываться.

Можно перегрузить функции-члены и функции, не являющихся членами. В следующей таблице указаны компоненты объявления функций, используемые языком C++ для различения групп функций с одинаковым именем в одной области.

### <a name="overloading-considerations"></a>Заметки по перегрузке

|Элемент объявления функции|Использование для перегрузки|
|----------------------------------|---------------------------|
|Тип возвращаемого функцией значения|Нет|
|Число аргументов|Да|
|Тип аргументов|Да|
|Наличие или отсутствие многоточия|Да|
|Использование **typedef** имена|Нет|
|Незаданные границы массива|Нет|
|**const** или **volatile**|Да, при применении к всей функции|
|[Ref квалификаторы](#ref-qualifiers)|Да|

## <a name="example"></a>Пример

В следующем примере показано использование перегрузки.

```cpp
// function_overloading.cpp
// compile with: /EHsc
#include <iostream>
#include <math.h>
#include <string>

// Prototype three print functions.
int print(std::string s);             // Print a string.
int print(double dvalue);            // Print a double.
int print(double dvalue, int prec);  // Print a double with a
                                     //  given precision.
using namespace std;
int main(int argc, char *argv[])
{
    const double d = 893094.2987;
    if (argc < 2)
    {
        // These calls to print invoke print( char *s ).
        print("This program requires one argument.");
        print("The argument specifies the number of");
        print("digits precision for the second number");
        print("printed.");
        exit(0);
    }

    // Invoke print( double dvalue ).
    print(d);

    // Invoke print( double dvalue, int prec ).
    print(d, atoi(argv[1]));
}

// Print a string.
int print(string s)
{
    cout << s << endl;
    return cout.good();
}

// Print a double in default precision.
int print(double dvalue)
{
    cout << dvalue << endl;
    return cout.good();
}

//  Print a double in specified precision.
//  Positive numbers for precision indicate how many digits
//  precision after the decimal point to show. Negative
//  numbers for precision indicate where to round the number
//  to the left of the decimal point.
int print(double dvalue, int prec)
{
    // Use table-lookup for rounding/truncation.
    static const double rgPow10[] = {
        10E-7, 10E-6, 10E-5, 10E-4, 10E-3, 10E-2, 10E-1,
        10E0, 10E1,  10E2,  10E3,  10E4, 10E5,  10E6 };
    const int iPowZero = 6;

    // If precision out of range, just print the number.
    if (prec < -6 || prec > 7)
    {
        return print(dvalue);
    }
    // Scale, truncate, then rescale.
    dvalue = floor(dvalue / rgPow10[iPowZero - prec]) *
        rgPow10[iPowZero - prec];
    cout << dvalue << endl;
    return cout.good();
}
```

В приведенном выше коде отображается перегрузка функции `print` в области видимости файла.

Аргумент по умолчанию не считается частью типа функции. Таким образом он не используется при выборке перегруженных функций. Две функции, которые различаются только в своих аргументах, считаются множественными определениями, а не перегруженными функциями.

Аргументы по умолчанию не могут задаваться для перегруженных операторов.

## <a name="argument-matching"></a>Сопоставление аргументов

Перегруженные функции выбираются для оптимального соответствия объявлений функций в текущей области аргументам, предоставленным в вызове функции. Если подходящая функция найдена, эта функция вызывается. «Подходящая» в данном контексте означает либо.

- Точное соответствие найдено.

- Тривиальное преобразование выполнено.

- Восходящее приведение целого типа выполнено.

- Стандартное преобразование в требуемый тип аргумента существует.

- Пользовательское преобразование (оператор преобразования или конструктор) в требуемый тип аргумента существует.

- Аргументы, представленные многоточием, найдены.

Компилятор создает набор функций-кандидатов для каждого аргумента. Функции-кандидаты — это функции, в которых фактический аргумент в данной позиции можно преобразовать в тип формального аргумента.

Для каждого аргумента создается набор наиболее подходящих функций, и выбранная функция представляет собой пересечение всех наборов. Если на пересечении находится несколько функций, перегрузка является неоднозначной и выдает ошибку. Функция, которая выбирается в конечном итоге, всегда является самой подходящей по сравнению с остальными функциями в группе по крайней мере для одного аргумента. Если не выявляет победителя, вызов функции приводит к ошибке.

Рассмотрим следующие объявления (функции отмечены как `Variant 1`, `Variant 2` и `Variant 3` для ссылки в последующем обсуждении).

```cpp
Fraction &Add( Fraction &f, long l );       // Variant 1
Fraction &Add( long l, Fraction &f );       // Variant 2
Fraction &Add( Fraction &f, Fraction &f );  // Variant 3

Fraction F1, F2;
```

Рассмотрим следующий оператор.

```cpp
F1 = Add( F2, 23 );
```

Представленный выше оператор создает два набора.

|Набор 1: Функции-кандидаты, имеющие первый аргумент дробного типа|Набор 2: Кандидат функции которых второй аргумент можно преобразовать к типу **int**|
|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
|Variant 1|Вариант 1 (**int** может быть преобразован в **long** с помощью стандартного преобразования)|
|Variant 3||

Функции в наборе 2 являются функции существует, для которых являются неявные преобразования из типа фактического параметра в тип формального параметра, и среди таких функций имеется функция, для которой является «стоимость» преобразование типа фактического параметра в тип формального параметра наименьшее.

Пересечением этих двух наборов является функция Variant 1. Ниже представлен пример неоднозначного вызова функции.

```cpp
F1 = Add( 3, 6 );
```

В предыдущем вызове функции создаются следующие наборы.

|Набор 1: Кандидат функции, имеющие первый аргумент типа **int**|Набор 2: Кандидат функции, имеющие второй аргумент типа **int**|
|---------------------------------------------------------------------|----------------------------------------------------------------------|
|Variant 2 (**int** может быть преобразован в **long** с помощью стандартного преобразования)|Вариант 1 (**int** может быть преобразован в **long** с помощью стандартного преобразования)|

Поскольку пересечение этих двух наборов является пустым, компилятор выдает сообщение об ошибке.

Для сопоставления функции с помощью аргументов *n* аргументы по умолчанию рассматривается как *n*+ 1 отдельные функции, каждая из которых Разное количество аргументов.

Многоточие (...) выступает в качестве подстановочного знака; оно соответствует любому фактическому аргументу. Он может привести к множества неоднозначных наборов, если вы не разрабатываете наборов перегруженных функций с особой осторожностью.

> [!NOTE]
>  Неоднозначность перегруженных функций невозможно определить, пока не будет обнаружен вызов функции. На этом этапе наборы создаются для каждого аргумента в вызове функции, и можно определить, существует ли неоднозначная перегрузка. Это означает, что неоднозначности могут оставаться в коде до тех пор, пока они не будут вызваны конкретным вызовом функции.

## <a name="argument-type-differences"></a>Различия типов аргументов

Перегруженные функции различают типы аргументов, имеющие разные инициализаторы. Следовательно, аргумент заданного типа и ссылка на этот тип считаются одинаковыми для перегрузки, поскольку имеют одни и те же инициализаторы. Например, `max( double, double )` — то же самое, что и `max( double &, double & )`. Объявление двух таких функций приводит к ошибке.

По этой же причине аргументы функций, тип которых изменен с **const** или **volatile** не обрабатываются иначе, чем базовый тип для перегрузки.

Однако механизм перегрузки функций может различать ссылки, которые определяются **const** и **volatile** и ссылки на базовый тип. Это повышает кода приведенному ниже:

```cpp
// argument_type_differences.cpp
// compile with: /EHsc /W3
// C4521 expected
#include <iostream>

using namespace std;
class Over {
public:
   Over() { cout << "Over default constructor\n"; }
   Over( Over &o ) { cout << "Over&\n"; }
   Over( const Over &co ) { cout << "const Over&\n"; }
   Over( volatile Over &vo ) { cout << "volatile Over&\n"; }
};

int main() {
   Over o1;            // Calls default constructor.
   Over o2( o1 );      // Calls Over( Over& ).
   const Over o3;      // Calls default constructor.
   Over o4( o3 );      // Calls Over( const Over& ).
   volatile Over o5;   // Calls default constructor.
   Over o6( o5 );      // Calls Over( volatile Over& ).
}
```

### <a name="output"></a>Вывод

```Output
Over default constructor
Over&
Over default constructor
const Over&
Over default constructor
volatile Over&
```

Указатели на **const** и **volatile** объекты также считаются отличными от указателей на базовый тип для перегрузки.

## <a name="argument-matching-and-conversions"></a>Сопоставление аргументов и преобразования

Когда компилятор пытается сопоставить фактические аргументы с аргументами в объявлениях функций и точное соответствие найти не удается, для получения правильного типа он может выполнять стандартные или пользовательские преобразования. Для преобразований действуют следующие правила:

- последовательности преобразований, содержащие несколько пользовательских преобразований, не учитываются;

- последовательности преобразований, которые могут быть сокращены путем удаления промежуточных преобразований, не учитываются.

Получающаяся последовательность преобразований (если таковые имеются), называется наилучшей последовательностью сопоставления. Существует несколько способов преобразования объекта типа **int** ввода **unsigned long** с использованием стандартных преобразований (описанных в [стандартные преобразования](../cpp/standard-conversions.md)):

- Преобразование из **int** для **long** и затем из **long** для **unsigned long**.

- Преобразование из **int** для **unsigned long**.

Первая последовательность, хотя и обеспечивает достижение требуемой цели, не наилучшей последовательностью сопоставления, существует более короткая последовательность.

В представленной ниже таблице показана группа преобразований, называемых тривиальными. Они оказывают ограниченное влияние на определение наилучшей последовательности сопоставления. В списке, приведенном после таблицы, рассматриваются экземпляры, в которых тривиальные преобразования влияют на выбор последовательности.

### <a name="trivial-conversions"></a>Тривиальные преобразования

|Тип, из которого выполняется преобразование|Тип, в который выполняется преобразование|
|-----------------------|---------------------|
|*Имя типа*|*Имя типа* **&**|
|*Имя типа* **&**|*Имя типа*|
|*Имя типа* **]**|*Имя типа* __\*__|
|*Имя типа* **(** *список аргументов* **)**|**(** __\*__ *имя типа* **) (** *список аргументов* **)**|
|*Имя типа*|**const** *имя типа*|
|*Имя типа*|**volatile** *имя типа*|
|*Имя типа* __\*__|**const** *имя типа* __\*__|
|*Имя типа* __\*__|**volatile** *имя типа* __\*__|

Ниже приведена последовательность, в которой делаются попытки выполнения преобразований.

1. Точное соответствие. Точное соответствие между типами, с которыми функция вызывается, и типами, объявленными в прототипе функции, всегда является наилучшим соответствием. Последовательности тривиальных преобразований классифицируются как точные соответствия. Тем не менее последовательностей, не делайте никакие из этих преобразований, считаются лучше, чем последовательности, которые преобразуют:

   - Из указателя в указатель на **const** (`type` <strong>\*</strong> для **const** `type` <strong>\*</strong> ).

   - Из указателя в указатель на **volatile** (`type` <strong>\*</strong> для **volatile** `type` <strong>\*</strong>).

   - Из указателя в указатель на **const** (`type` **&** для **const** `type` **&**).

   - Из указателя в указатель на **volatile** (`type` **&** для **volatile** `type` **&**).

1. Сопоставление с использованием повышений. Любая последовательность, не классифицированная как точное соответствие, содержащий только восходящие приведения целого типа, преобразования из **float** для **двойные**, и тривиальные преобразования, классифицируется как сопоставление с использованием повышений. Хотя сопоставление с использованием повышений не такое хорошее, как точное, оно лучше сопоставления с использованием стандартных преобразований.

1. Сопоставление с использованием стандартных преобразований. Любая последовательность, не классифицированная как точное соответствие или сопоставление с использованием повышений и содержащая только стандартные и тривиальные преобразования, классифицируется как сопоставление с использованием стандартных преобразований. В этой категории применяются следующие правила:

   - Преобразование из указателя на производный класс в указатель на прямой или косвенный базовый класс предпочтительнее преобразования в `void *` или `const void *`.

   - преобразование из указателя на производный класс в указатель на базовый класс создает тем более хорошее соответствие, чем ближе базовый класс к прямому базовому классу. Предположим, что иерархия классов имеет вид, показанный на следующем рисунке.

![График предпочтительные преобразования](../cpp/media/vc391t1.gif "график предпочтительные преобразования") <br/>
Диаграмма, показывающая предпочтительные преобразования

Преобразование из типа `D*` в тип `C*` предпочтительнее преобразования из типа `D*` в тип `B*`. Аналогично, преобразование из типа `D*` в тип `B*` предпочтительнее преобразования из типа `D*` в тип `A*`.

Это же правило применяется для преобразований ссылок. Преобразование из типа `D&` в тип `C&` предпочтительнее преобразования из типа `D&` в тип `B&` и т. д.

Это же правило применяется для преобразований указателей на член. Преобразование из типа `T D::*` в тип `T C::*` предпочтительнее преобразования из типа `T D::*` в тип `T B::*` и т. д. (`T` — тип члена.)

Предыдущее правило применяется только в определенном пути наследования. Рассмотрим граф, показанный на следующем рисунке.

![Несколько&#45;наследование, показывающее предпочтительные преобразования](../cpp/media/vc391t2.gif "несколько&#45;наследование, показывающее предпочтительные преобразования") <br/>
Граф множественного наследования, показывающее предпочтительные преобразования

Преобразование из типа `C*` в тип `B*` предпочтительнее преобразования из типа `C*` в тип `A*`. Причина заключается в том, что эти преобразования находятся на одном пути и узел `B*` ближе. Однако преобразование из типа `C*` ввода `D*` не предпочтительнее преобразования в тип `A*`; нет предпочтений нет, поскольку преобразования осуществляются с использованием разных путей.

1. Сопоставление с пользовательскими преобразованиями. Эта последовательность невозможно классифицировать как точное соответствие, сопоставление с использованием повышений или сопоставление с использованием стандартных преобразований. Чтобы последовательность можно было классифицировать как сопоставление с пользовательскими преобразованиями, она должна содержать только пользовательские, стандартные или тривиальные преобразования. Сопоставление с пользовательскими преобразованиями лучше сопоставления с многоточием, но хуже сопоставления со стандартными преобразованиями.

1. Сопоставление с многоточием. Любая последовательность, соответствующая многоточию в объявлении, классифицируется как сопоставление с многоточием. Он самое слабое соответствие.

Пользовательские преобразования применяются при отсутствии встроенного повышения или преобразования. Эти преобразования выбираются на основе типа сопоставляемого аргумента. Рассмотрим следующий код.

```cpp
// argument_matching1.cpp
class UDC
{
public:
   operator int()
   {
      return 0;
   }
   operator long();
};

void Print( int i )
{
};

UDC udc;

int main()
{
   Print( udc );
}
```

Доступные заданные пользователем преобразования для класса `UDC` : из типа **int** и тип **long**. Поэтому компилятор проверяет преобразования для типа сопоставляемого объекта: `UDC`. Преобразование в **int** существует, и он выбран.

В процессе сопоставления аргументов стандартные преобразования можно применять как к аргументу, так и к результату пользовательского преобразования. Поэтому следующий код работает.

```cpp
void LogToFile( long l );
...
UDC udc;
LogToFile( udc );
```

В предыдущем примере, определенное пользователем преобразование **long-оператор**, вызывается для преобразования `udc` ввода **long**. Если нет определенное пользователем преобразование в тип **long** был определен, преобразование продолжилось бы следующим образом: Тип `UDC` был бы преобразован в тип **int** с использованием определенного пользователем преобразования. Затем стандартное преобразование из типа **int** ввода **long** была реализована в соответствии с аргументом в объявлении.

Если для сопоставления аргумента необходимы все заданные пользователем преобразования, стандартные преобразования не используются при оценке наилучшего соответствия. Даже если более одного кандидата функции требуется определенное пользователем преобразование, функции считаются одинаковыми. Пример:

```cpp
// argument_matching2.cpp
// C2668 expected
class UDC1
{
public:
   UDC1( int );  // User-defined conversion from int.
};

class UDC2
{
public:
   UDC2( long ); // User-defined conversion from long.
};

void Func( UDC1 );
void Func( UDC2 );

int main()
{
   Func( 1 );
}
```

Обе версии `Func` требуют определенного пользователем преобразования для преобразования типа **int** аргументу типа класса. Возможные преобразования:

- Преобразование из типа **int** ввода `UDC1` (пользовательское преобразование).

- Преобразование из типа **int** ввода **long**; затем преобразование в тип `UDC2` (двухступенчатое преобразование).

Несмотря на то, что второй требуется стандартное преобразование и пользовательское преобразование, два преобразования все равно считаются одинаковыми.

> [!NOTE]
>  Пользовательские преобразования считаются преобразованиями посредством создания или инициализации (функции преобразования). При рассмотрении наилучшего соответствия оба метода считаются одинаковыми.

## <a name="argument-matching-and-the-this-pointer"></a>Сопоставление аргументов и указатель this

Функции-члены класса обрабатываются по-разному, в зависимости от того, они будут объявлены как **статических**. Поскольку нестатические функции имеют неявный аргумент, который предоставляет **это** указатель, считается, что нестатические функции имеют один аргумент больше, чем статические функции; в противном случае они объявляются одинаково.

Эти нестатические функции-члены требуют неявный **это** указатель соответствовал типу объекта, через который вызывается функция, или, для перегруженных операторов, они требуют, что первый аргумент совпадал с объект, для которого применяется оператор. (Дополнительные сведения о перегруженных операторах см. в разделе [перегруженные операторы](../cpp/operator-overloading.md).)

В отличие от других аргументов в перегруженных функций, представленные никакие временные объекты и преобразования не применяются при попытке сопоставить **это** аргументом указателя.

Когда `->` оператора выбора члена используется для доступа к функции-члена класса `class_name`, **это** аргумент-указатель с типом `class_name * const`. Если элементы объявлены как **const** или **volatile**, типы, `const class_name * const` и `volatile class_name * const`, соответственно.

Оператор выбора члена `.` работает точно так же, за исключением того, что в качестве префикса к имени объекта подставляется неявный оператор взятия адреса `&`. В следующем примере показано, как это делается:

```cpp
// Expression encountered in code
obj.name

// How the compiler treats it
(&obj)->name
```

С точки зрения сопоставления аргументов, левый операнд операторов `->*` и `.*` (указатель на член) обрабатывается так же, как и для операторов `.` и `->` (выбор члена).

## <a name="ref-qualifiers"></a> Ref квалификаторы для функций-членов

Квалификаторы ref делают возможным перегрузить функцию-член на основании ли объект указывает **это** rvalue или lvalue.  Эту функцию можно использовать чтобы избежать ненужных операций копирования в сценариях, где пользователь не указывает указатель доступ к данным. Предположим, например, класс `C` некоторые данные в его конструктор инициализирует и возвращает копию этих данных в функции-члене `get_data()`. Если тип объекта `C` представляет собой rvalue, уничтожить, то компилятор выберет `get_data() &&` перегрузку, которая перемещает данные, чем скопировать его.

```cpp
#include <iostream>
#include <vector>

using namespace std;

class C
{

public:
    C() {/*expensive initialization*/}
    vector<unsigned> get_data() &
    {
        cout << "lvalue\n";
        return _data;
    }
    vector<unsigned> get_data() &&
    {
        cout << "rvalue\n";
        return std::move(_data);
    }

private:
    vector<unsigned> _data;
};

int main()
{
    C c;
    auto v = c.get_data(); // get a copy. prints "lvalue".
    auto v2 = C().get_data(); // get the original. prints "rvalue"
    return 0;
}
```

## <a name="restrictions-on-overloading"></a>Ограничения по перегрузке

К допустимому набору перегруженных функций применяется несколько ограничений.

- Любые две функции в наборе перегруженных функций должны иметь разные списки аргументов.

- Перегрузка функций со списками аргументов одного типа лишь на основании возвращаемого типа недопустима.

     **Блок, относящийся только к системам Microsoft**

Можно перегрузить **оператор new** исключительно на основании возвращаемого типа, в частности, на основании указанного модификатора модели памяти.

**Завершение блока, относящегося только к системам Майкрософт**

- Функции-члены Невозможно перегружать исключительно на основе один является статической, а вторая — нестатической.

- **TypeDef** объявления не определяют новые типы; они представляют синонимы для существующих типов. Они не влияют на механизм перегрузки. Рассмотрим следующий код.

    ```cpp
    typedef char * PSTR;

    void Print( char *szToPrint );
    void Print( PSTR szToPrint );
    ```

   Две указанные выше функции имеют идентичные списки аргументов. `PSTR` является синонимом для типа `char *`. В области члена этот код возвращает ошибку.

- Перечисляемые типы являются отдельными типами и могут использоваться для различения перегруженных функций.

- Типы «массив» и «указатель» считаются идентичными в целях различения между перегруженных функций, но только для однонаправленного распределяться массивов. Вот почему эти перегруженные функции конфликтуют и появится сообщение об ошибке:

    ```cpp
    void Print( char *szToPrint );
    void Print( char szToPrint[] );
    ```

   В случае многомерных массивов второе и все последующие измерения являются частью типа. Поэтому они используются для различения перегруженных функций.

    ```cpp
    void Print( char szToPrint[] );
    void Print( char szToPrint[][7] );
    void Print( char szToPrint[][9][42] );
    ```

## <a name="overloading-overriding-and-hiding"></a>Перегрузка, переопределение и скрытие

Любые два объявления функции с одинаковым именем в одной области видимости могут ссылаться на одну функцию или на две разные перегруженные функции. Если списки аргументов в объявлениях содержат аргументы эквивалентных типов (как описано в предыдущем разделе), эти объявления относятся к одной и той же функции. В противном случае они ссылаются на две различные функции, которые выбираются с использованием перегрузки.

Область видимости класса строго соблюдается; Таким образом, функция, объявленная в базовом классе не находится в той же области, как функция объявлен в производном классе. Если функция в производном классе объявлена с тем же именем, что и виртуальная функция в базовом классе, функция производного класса *переопределяет* функцию базового класса. Дополнительные сведения см. в разделе [виртуальные функции](../cpp/virtual-functions.md).

Если функция базового класса не объявлена как «virtual», то функция производного класса говорят, что *скрыть* его. Переопределение и скрытие отличаются от перегрузки.

Область видимости блока строго соблюдается; Таким образом, функция, объявленная в области видимости файла не находится в той же области, как функция объявлен локально. Если локально объявленная функция имеет то же имя, что и функция, объявленная в области файла, локально объявленная функция скрывает функцию области файла, не вызывая перегрузки. Пример:

```cpp
// declaration_matching1.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
void func( int i )
{
    cout << "Called file-scoped func : " << i << endl;
}

void func( char *sz )
{
   cout << "Called locally declared func : " << sz << endl;
}

int main()
{
   // Declare func local to main.
   extern void func( char *sz );

   func( 3 );   // C2664 Error. func( int ) is hidden.
   func( "s" );
}
```

В предыдущем коде показаны два определения функции `func`. Определение, которое принимает аргумент типа `char *` является локальным для `main` из-за **extern** инструкции. Таким образом, определение, которое принимает аргумент типа **int** скрыта и первый вызов `func` произошла ошибка.

В случае перегруженных функций-членов различным версиям функции могут предоставляться разные права доступа. Они по-прежнему считаются находящимися в области видимости включающего класса и, таким образом, являются перегруженными функциями. Рассмотрим следующий код, в котором функция-член `Deposit` перегружена; одна версия является открытой, вторая — закрытой.

Целью кода в примере является предоставление класса `Account`, в котором для внесения средств требуется правильный пароль. Это делается с помощью перегрузки.

Вызов `Deposit` в `Account::Deposit` вызывает закрытая функция-член. Это правильный вызов поскольку `Account::Deposit` является функцией-членом, и имеет доступ к закрытым членам класса.

```cpp
// declaration_matching2.cpp
class Account
{
public:
   Account()
   {
   }
   double Deposit( double dAmount, char *szPassword );

private:
   double Deposit( double dAmount )
   {
      return 0.0;
   }
   int Validate( char *szPassword )
   {
      return 0;
   }

};

int main()
{
    // Allocate a new object of type Account.
    Account *pAcct = new Account;

    // Deposit $57.22. Error: calls a private function.
    // pAcct->Deposit( 57.22 );

    // Deposit $57.22 and supply a password. OK: calls a
    //  public function.
    pAcct->Deposit( 52.77, "pswd" );
}

double Account::Deposit( double dAmount, char *szPassword )
{
   if ( Validate( szPassword ) )
      return Deposit( dAmount );
   else
      return 0.0;
}
```

## <a name="see-also"></a>См. также

[Функции (C++)](../cpp/functions-cpp.md)