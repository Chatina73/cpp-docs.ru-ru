---
title: align (C++)
ms.date: 12/17/2018
f1_keywords:
- align_cpp
helpviewer_keywords:
- align __declspec keyword
- __declspec keyword [C++], align
ms.assetid: 9cb63f58-658b-4425-ac47-af8eabfc5878
ms.openlocfilehash: 1bfe6e7a4646be8cea622078b4d85f20f458e1c5
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62258153"
---
# <a name="align-c"></a>align (C++)

В Visual Studio 2015 и более поздних версиях используется стандарт C ++ 11 `alignas` описатель для выравнивания элементов управления. Дополнительные сведения см. в разделе [выравнивание](../cpp/alignment-cpp-declarations.md).

**Блок, относящийся только к системам Microsoft**

Используйте `__declspec(align(#))` для точного управления выравниванием пользовательских данных (например, статическими распределениями или автоматическими данными в функции).

## <a name="syntax"></a>Синтаксис

> **__declspec( align(** *#* **) )** *declarator*

## <a name="remarks"></a>Примечания

Написание приложений, использующих последние инструкции процессора, связано с некоторыми новыми ограничениями и проблемами. В частности, для множества новых инструкций требуется, чтобы данные были выровнены по 16-байтовым границам. Кроме того, выравнивание часто используемых данных в соответствии с размером строки кэш-памяти конкретного процессора повышает производительность кэша. Например, при определении структуры размером менее 32 байт может потребоваться выровнять ее до 32 байт, чтобы добиться эффективного кэширования объектов этого типа структуры.

\# значение выравнивания. Допустимые записи — целые степени двух значений от 1 до 8192 (байты), например 2, 4, 8, 16, 32 или 64. `declarator` — это данные, которые объявляются как выровненные.

Сведения о том, как возвращать значение типа `size_t` это требование к выравниванию типа, см. в разделе [__alignof](../cpp/alignof-operator.md). Сведения об объявлении невыровненных указателей при нацеливании на 64-разрядных процессоров, см. в разделе [__unaligned](../cpp/unaligned.md).

Можно использовать `__declspec(align(#))` при определении **структуры**, **объединение**, или **класс**, или при объявлении переменной.

Компилятор не гарантирует и не пытается сохранить атрибут выравнивания данных при операции копирования или преобразования данных. Например [memcpy](../c-runtime-library/reference/memcpy-wmemcpy.md) можно скопировать структуру, объявленную с `__declspec(align(#))` в любом месте. Обратите внимание, что обычные Распределители, например, [malloc](../c-runtime-library/reference/malloc.md), C++ [оператор new](new-operator-cpp.md)и Распределители Win32, возвращают память, которая является обычно недостаточно выровнена для `__declspec(align(#))` структурами и массивами структуры. Чтобы гарантировать, что назначения операции копирования или данных преобразования выравнивается правильно, используйте [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md), или напишите собственный распределитель.

Невозможно задать выравнивание параметров функции. Если данные содержат атрибут выравнивания, передаваемый с помощью значения в стек, это выравнивание контролируется соглашением о вызовах. Если в вызываемой функции важно выравнивание данных, скопируйте параметр в правильно выровненную память перед использованием.

Без `__declspec(align(#))`, компилятор обычно выравнивает данные по естественным границам на основе целевого процессора и объема данных, вплоть до 4-байтовых границ на 32-разрядных процессорах и 8-байтовых границ на 64-разрядных процессоров. Данные в классах или структурах выравниваются в классе или в структуре по наименьшему естественному выравниванию с учетом текущего параметра упаковки (на основе параметра компилятора #pragma `pack` или `/Zp`).

В этом примере демонстрируется использование `__declspec(align(#))`:

```cpp
__declspec(align(32)) struct Str1{
   int a, b, c, d, e;
};
```

Теперь этот тип содержит 32-разрядный атрибут выравнивания. Это означает, что все статические и автоматические экземпляры начинаются с 32-разрядной границы. Дополнительная структура типам, объявленным с этим типом в качестве члена сохранить атрибут выравнивания этого типа, т. е. любая структура с `Str1` как элемент имеет атрибут выравнивания, составляющий по меньшей мере 32.

Обратите внимание, что `sizeof(struct Str1)` равно 32. При этом подразумевается, что если создается массив объектов Str1, а базовый массив выровнен по 32 байтам, то каждый член массива также выровнен по 32 байтам. Для создания массива, база которого правильно выровнена в динамической памяти, используйте [_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md), или напишите собственный распределитель.

Значение `sizeof` для любой структуры является суммой смещения последнего члена и его размера, округленной до ближайшего числа, кратного большему из следующих значений: значению выравнивания наибольшего члена или значению выравнивания всей структуры.

Компилятор использует эти правила для выравнивания структуры:

- Если выравнивание не переопределяется с помощью `__declspec(align(#))`, выравнивание скалярного члена структуры — это его минимальный размер и текущая упаковка.

- Если выравнивание не переопределяется с помощью `__declspec(align(#))`, выравнивание структуры — это максимальное число отдельных выравниваний членов.

- Член структуры размещается со смещением от начала его родительской структуры. Смещение — это наименьшее число, кратное ее выравниванию, больше или равное смещению в конце предыдущего члена.

- Размер структуры — это наименьшее число, кратное ее выравниванию, больше или равное смещению в конце его последнего члена.

`__declspec(align(#))` может только увеличить ограничения выравнивания.

Дополнительные сведения:

- [Примеры использования align](#vclrfalignexamples)

- [Определение новых типов с помощью __declspec(align(#))](#vclrf_declspecaligntypedef)

- [Выравнивание данных в локальном хранилище потока](#vclrfthreadlocalstorageallocation)

- [Использование align с упаковкой данных](#vclrfhowalignworkswithdatapacking)

- [Примеры выравнивания структуры](../build/x64-software-conventions.md#examples-of-structure-alignment) (x64 конкретных)

## <a name="vclrfalignexamples"></a> Примеры использования align

В следующих примерах показано, как `__declspec(align(#))` влияет на размер и выравнивание структур данных. В примерах допускаются следующие определения.

```cpp
#define CACHE_LINE  32
#define CACHE_ALIGN __declspec(align(CACHE_LINE))
```

В этом примере структура `S1` определена с помощью `__declspec(align(32))`. Все случаи использования `S1` для определения переменных или в объявлениях других типов выравниваются по 32 байтам. `sizeof(struct S1)` возвращает значение 32, а `S1` имеет 16 байтов заполнения после 16 байтов, необходимых для удержания четырех целых чисел. Каждый **int** член требует 4-байтового выравнивания, но выравнивание самой структуры объявляется 32. Следовательно, общее выравнивание производится по 32 байтам.

```cpp
struct CACHE_ALIGN S1 { // cache align all instances of S1
   int a, b, c, d;
};
struct S1 s1;   // s1 is 32-byte cache aligned
```

В этом примере `sizeof(struct S2)` возвращает 16. Это сумма размеров членов, поскольку это число является кратным наибольшему требуемому выравниванию (кратное 8).

```cpp
__declspec(align(8)) struct S2 {
   int a, b, c, d;
};
```

В следующем примере `sizeof(struct S3)` возвращает 64.

```cpp
struct S3 {
   struct S1 s1;   // S3 inherits cache alignment requirement
                  // from S1 declaration
   int a;         // a is now cache aligned because of s1
                  // 28 bytes of trailing padding
};
```

Обратите внимание, что в этом примере `a` выравнивается по своему естественному типу, то есть, в данном случае, по 4 байтам. Однако значение `S1` должно быть выровнено по 32-байтовой границе. После `a` следует двадцать восемь байтов заполнения, чтобы значение `s1` начиналось со смещением 32. Затем `S4` наследует требование к выравниванию `S1`, поскольку это наибольшее требование к выравниванию в структуре. `sizeof(struct S4)` возвращает 64.

```cpp
struct S4 {
   int a;
   // 28 bytes padding
    struct S1 s1;      // S4 inherits cache alignment requirement of S1
};
```

Следующие три объявления переменных также используют `__declspec(align(#))`. В каждом случае переменная должна быть выровнена по 32 байтам. В случае массива базовый адрес массива, а не каждый член массива, выравнивается по 32 байтам. Значение `sizeof` для каждого члена массива не изменяется при использовании `__declspec(align(#))`.

```cpp
CACHE_ALIGN int i;
CACHE_ALIGN int array[128];
CACHE_ALIGN struct s2 s;
```

Для выравнивания каждого члена массива нужно использовать следующий код:

```cpp
typedef CACHE_ALIGN struct { int a; } S5;
S5 array[10];
```

Обратите внимание, что в этом примере выравнивание самой структуры и первого элемента работают одинаково:

```cpp
CACHE_ALIGN struct S6 {
   int a;
   int b;
};

struct S7 {
   CACHE_ALIGN int a;
               int b;
};
```

`S6` и `S7` имеют одинаковые характеристики выравнивания, выделения и размера.

В этом примере выравнивание начальных адресов a, b, c и d — соответственно 4, 1, 4, и 1.

```cpp
void fn() {
   int a;
   char b;
   long c;
   char d[10]
}
```

Выравнивание при выделении памяти в куче зависит от того, какая функция выделения вызвана.  Например, если используется `malloc`, результат зависит от размера операнда. Если *arg* > = 8, возвращаемая память выравнивается по 8 байтам. Если *arg* < 8, то память выравнивается представляет собой первую степень 2 меньше, чем *arg*. Например, если использовать malloc(7), выравнивание выполняется по 4 байтам.

## <a name="vclrf_declspecaligntypedef"></a> Определение новых типов с помощью __declspec(align(#))

Можно определить тип с характеристикой выравнивания.

Например, можно определить `struct` со значением выравнивания таким образом:

```cpp
struct aType {int a; int b;};
typedef __declspec(align(32)) struct aType bType;
```

Теперь `aType` и `bType` одинаковый размер (8 байт), но переменные типа `bType` являются 32-байтовой границе.

## <a name="vclrfthreadlocalstorageallocation"></a> Выравнивание данных в локальном хранилище потока

Статическое локальное хранилище потока (TLS), созданное с помощью атрибута `__declspec(thread)` и помещенное в раздел TLS образа, обеспечивает выравнивание так же, как стандартные статические данные. Для создания данных TLS операционная система выделяет память в размере раздела TLS и сохраняет атрибут выравнивания раздела TLS.

В этом примере показаны различные способы помещения выровненных данных в локальное хранилище потока.

```cpp
// put an aligned integer in TLS
__declspec(thread) __declspec(align(32)) int a;

// define an aligned structure and put a variable of the struct type
// into TLS
__declspec(thread) __declspec(align(32)) struct F1 { int a; int b; } a;

// create an aligned structure
struct CACHE_ALIGN S9 {
   int a;
   int b;
};
// put a variable of the structure type into TLS
__declspec(thread) struct S9 a;
```

## <a name="vclrfhowalignworkswithdatapacking"></a> Использование align с упаковкой данных

`/Zp` Параметр компилятора и `pack` pragma иметь влияние на упаковку данных для членов структуры и объединения. В этом примере показано, как `/Zp` и `__declspec(align(#))` совместной работы:

```cpp
struct S {
   char a;
   short b;
   double c;
   CACHE_ALIGN double d;
   char e;
   double f;
};
```

В следующей таблице перечислено смещение каждого члена в различных значениях `/Zp` (или #pragma `pack`), показывая их взаимодействие.

|Переменная|/Zp1|/Zp2|/Zp4|/Zp8|
|--------------|-----------|-----------|-----------|-----------|
|пример|0|0|0|0|
|b|1|2|2|2|
|c|3|4|4|8|
|d|32|32|32|32|
|й|40|40|40|40|
|f|41|42|44|48|
|sizeof(S)|64|64|64|64|

Дополнительные сведения см. в статье [/Zp (выравнивание членов структур)](../build/reference/zp-struct-member-alignment.md).

Смещение объекта зависит от смещения предыдущего объекта и от текущего параметра упаковки, если у объекта нет атрибута `__declspec(align(#))`. Если же такой атрибут есть, то выравнивание зависит от смещения предыдущего объекта и от значения `__declspec(align(#))` объекта.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[__declspec](../cpp/declspec.md)<br/>
[Обзор соглашений ABI ARM](../build/overview-of-arm-abi-conventions.md)<br/>
[Программные соглашения для 64-разрядных систем](../build/x64-software-conventions.md)