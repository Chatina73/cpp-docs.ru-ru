---
title: Строковые и символьные литералы (C++)
ms.date: 11/04/2016
f1_keywords:
- R
helpviewer_keywords:
- L constant
- escape sequences
- Null strings, null-terminated strings
- literal strings, C++
- Null strings
- string literals, syntax
- string literals
- literal strings
- strings [C++], string literals
- NULL, character constant
- wide characters, strings
ms.assetid: 61de8f6f-2714-4e7b-86b6-a3f885d3b9df
ms.openlocfilehash: d3721f3624a64a24de0a5458d88de4836b07a9c1
ms.sourcegitcommit: 1819bd2ff79fba7ec172504b9a34455c70c73f10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2018
ms.locfileid: "51329843"
---
# <a name="string-and-character-literals--c"></a>Строковые и символьные литералы (C++)

В C++ поддерживаются различные типы строк и символов, а также доступны различные способы выражения значений литералов каждого из этих типов. В исходном коде содержимое символьных и строковых литералов выражается с помощью кодировки. Универсальные имена символов и escape-символы позволяют представить любую строку, используя только основную кодировку исходного кода. Необработанные строковые литералы позволяют не использовать escape-символы и могут применяться для выражения всех типов строковых литералов. Можно также создать литералы std::string без необходимости выполнять дополнительные действия по созданию или преобразованию.

```cpp
#include <string>
using namespace std::string_literals; // enables s-suffix for std::string literals

int main()
{
    // Character literals
    auto c0 =   'A'; // char
    auto c1 = u8'A'; // char
    auto c2 =  L'A'; // wchar_t
    auto c3 =  u'A'; // char16_t
    auto c4 =  U'A'; // char32_t

    // String literals
    auto s0 =   "hello"; // const char*
    auto s1 = u8"hello"; // const char*, encoded as UTF-8
    auto s2 =  L"hello"; // const wchar_t*
    auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16
    auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32

    // Raw string literals containing unescaped \ and "
    auto R0 =   R"("Hello \ world")"; // const char*
    auto R1 = u8R"("Hello \ world")"; // const char*, encoded as UTF-8
    auto R2 =  LR"("Hello \ world")"; // const wchar_t*
    auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16
    auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32

    // Combining string literals with standard s-suffix
    auto S0 =   "hello"s; // std::string
    auto S1 = u8"hello"s; // std::string
    auto S2 =  L"hello"s; // std::wstring
    auto S3 =  u"hello"s; // std::u16string
    auto S4 =  U"hello"s; // std::u32string

    // Combining raw string literals with standard s-suffix
    auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char*
    auto S6 = u8R"("Hello \ world")"s; // std::string from a raw const char*, encoded as UTF-8
    auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t*
    auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16
    auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32
}
```

Строковые литералы могут не иметь префикса или включать префиксы `u8`, `L`, `u`и  `U` для обозначения кодировок обычных символов (однобайтовых или многобайтовых), UTF-8, расширенных символов (UCS-2 или UTF-16), UTF-16 и UTF-32, соответственно. Необработанные строковые литералы могут включать префиксы `R`, `u8R`, `LR`, `uR` и `UR` для эквивалентов необработанных версий кодировок.  Чтобы создать временные или статические значения std::string, можно использовать строковые литералы или необработанные строковые литералы с суффиксом `s` . Дополнительные сведения см. в разделе "Строковые литералы" ниже. Дополнительные сведения об основной кодировке исходного кода, универсальных именах символов и использовании символов из расширенных кодовых страниц в исходном коде см. в разделе [Character Sets](../cpp/character-sets.md).

## <a name="character-literals"></a>Символьные литералы

*Символьный литерал* состоит из символьной константы. Она представлена символом, заключенным в одинарные кавычки. Существует пять типов символьных литералов:

- Обычные символьные литералы типа **char**, например `'a'`

- UTF-8 символьные литералы типа **char**, например `u8'a'`

- Расширенные символьные литералы типа `wchar_t`, например `L'a'`.

- UTF-16 символьные литералы типа `char16_t`, например `u'a'`

- UTF-32 символьные литералы типа `char32_t`, например `U'a'`

Символ, используемый для символьных литералов могут быть любые символы, за исключением зарезервированных символов обратной косой черты ("\\"), знак кавычки (') или новой строки. Зарезервированные символы можно указывать с помощью escape-последовательности. Символы можно указывать с помощью универсальных имен символов, при условии что тип является достаточно крупным для размещения символа.

### <a name="encoding"></a>кодировка

Символьные литералы кодируются по-разному на основе их префикс.

- Символьного литерала без префикса является обычный символ литерала. Значение литерала обычный символ, содержащей один символ, escape-последовательности, или универсальное имя символа, может быть представлено в кодировке выполнения имеет значение, равное его кодирование в набор символов исполнения числовое значение. Обычный символ литерала, содержащий более одного символа, универсальное имя символа или escape-последовательность — это *многозначные константы литерала*. Многосимвольные литералом или литерал обычный символ, не могут быть представлены в кодировке выполнения условно поддерживаемых, имеет тип int, и его значение определяется реализацией.

- Символьный литерал, который начинается с префикса L — это литерал расширенных символов. Значение литерала расширенных символов, содержащая один символ, escape-последовательность или универсальное имя символа имеет значение, равное кодировки в расширенных символов выполнения настроенные символьный литерал не имеет представления числовое значение набор расширенных символов выполнения, в противном случае значение определяется реализацией. Значение литерала расширенных символов, содержащий несколько символов, escape-последовательности и универсальные имена символов определяется реализацией.

- Символьный литерал, который начинается с префикса u8 является UTF-8 символьного литерала. Значение UTF-8 символьный литерал, содержащий один символ, escape-последовательности, или универсальное имя символа имеет значение, равное значению точки кода ISO 10646, если она может быть представлена единый блок кода UTF-8 (соответствующие элементы управления C0 и основной латиницы Блок Юникода). Если значение не может быть представлено одной единицы кода UTF-8, программа является некорректным. Символ UTF-8, литерал, содержащий более одного символа, escape-последовательность или универсальное имя символа является некорректным.

- Символьный литерал, который начинается с префикса u является UTF-16 символьного литерала. Значение литерала символ UTF-16, содержащей один символ, escape-последовательности, или универсальное имя символа имеет значение, равное значению точки кода ISO 10646, если она может быть представлена единый блок кода UTF-16 (соответствующий базовый многоязыковой плоскости ). Если значение не может быть представлено одной единицы кода UTF-16, программа является некорректным. Символ UTF-16, литерал, содержащий более одного символа, escape-последовательность или универсальное имя символа является некорректным.

- Символьный литерал, который начинается с префикса U является UTF-32 символьного литерала. Значение литерала символ UTF-32, содержащей один символ, escape-последовательности, или универсальное имя символа имеет значение, равное значению точки кода ISO 10646. Символ UTF-8, литерал, содержащий более одного символа, escape-последовательность или универсальное имя символа является некорректным.

###  <a name="bkmk_Escape"></a> Escape-последовательность

Существует три вида escape-последовательностей: простая, восьмеричная и шестнадцатеричная. Возможны следующие типы escape-последовательностей:

|Значение|Escape-последовательность|
|-----------|---------------------|
| новая строка | \\n |
| обратная косая черта | \\\\ |
| горизонтальная табуляция | \\t |
| вопросительный знак | ? или \\? |
| вертикальная табуляция | \\v |
| одинарная кавычка | \\' |
| стирание назад | \\b |
| двойная кавычка | \\" |
| возврат каретки | \\R |
| нуль-символ | \\0 |
| перевод страницы | \\F |
| восьмеричный | \\ooo |
| оповещение (колокольчик) | \\a |
| шестнадцатеричный | \\xhhh |

Приведенный ниже показаны некоторые примеры escape-символов, с помощью литералов обычный символ. Тот же самый синтаксис escape-последовательности является допустимым для других типов литерала символ.

```cpp
#include <iostream>
using namespace std;

int main() {
    char newline = '\n';
    char tab = '\t';
    char backspace = '\b';
    char backslash = '\\';
    char nullChar = '\0';

    cout << "Newline character: " << newline << "ending" << endl; // Newline character:
                                                                  //  ending
    cout << "Tab character: " << tab << "ending" << endl; // Tab character : ending
    cout << "Backspace character: " << backspace << "ending" << endl; // Backspace character : ending
    cout << "Backslash character: " << backslash << "ending" << endl; // Backslash character : \ending
    cout << "Null character: " << nullChar << "ending" << endl; //Null character:  ending
}
```

**Блок, относящийся только к системам Microsoft**

Чтобы создать значение из обычный символ литерала (которые без префикса), компилятор преобразует символ или последовательность символов между одинарными кавычками в 8-разрядные значения в 32-разрядное целое число. Несколько символов в литерале заполняют соответствующие байты по мере необходимости от высокого до низкого порядка. Чтобы создать **char** значение, компилятор принимает младший байт. Чтобы создать **wchar_t** или `char16_t` значение, компилятор принимает младшее слово. Компилятор выдает предупреждение о том, что результат усекается, если какие-либо биты заданы выше назначенного байта или слова.

```cpp
char c0    = 'abcd';    // C4305, C4309, truncates to 'd'
wchar_t w0 = 'abcd';    // C4305, C4309, truncates to '\x6364'
```

Восьмеричная escape-последовательность — это обратная косая черта, за которой следует последовательность восьмеричных цифр (не более трех). Восьмеричная escape-последовательность, которая содержит более трех цифр, обрабатывается как восьмеричная последовательность из трех цифр, за которой следуют цифры, обозначающие символы. Это может приводить к неожиданным результатам. Пример:

```cpp
char c1 = '\100';   // '@'
char c2 = '\1000';  // C4305, C4309, truncates to '0'
```

Escape-последовательности, которые содержат невосьмеричные символы, вычисляются как восьмеричные последовательности до последнего восьмеричного символа, за которым следуют остальные символы. Пример:

```cpp
char c3 = '\009';   // '9'
char c4 = '\089';   // C4305, C4309, truncates to '9'
char c5 = '\qrs';   // C4129, C4305, C4309, truncates to 's'
```

Шестнадцатеричная escape-последовательность — это обратная косая черта, за которой следует символ `x`и последовательность шестнадцатеричных цифр. Escape-последовательности, которые не содержат шестнадцатеричные цифры, вызывают ошибку компилятора C2153. Эта ошибка сообщает, что шестнадцатеричные литералы должны содержать по крайней мере одну шестнадцатеричную цифру. Начальные нули пропускаются. Escape-последовательность, которая содержит шестнадцатеричные и другие символы, вычисляется как шестнадцатеричная escape-последовательность до последнего шестнадцатеричного символа, за которым следуют другие символы.   В обычных с префиксом u8 символ или литерал максимальное шестнадцатеричное значение — 0xFF. В расширенном символьном литерале с префиксом L или u максимальное шестнадцатеричное значение — 0xFFFF. В расширенном символьном литерале с префиксом U максимальное шестнадцатеричное значение — 0xFFFFFFFF.

```cpp
char c6 = '\x0050'; // 'P'
char c7 = '\x0pqr'; // C4305, C4309, truncates to 'r'
```

Если расширенный символьный литерал с префиксом `L` содержит более одного символа, значение берется из первого символа. Последующие символы игнорируются, в отличие от эквивалентных обычный символ литерала.

```cpp
wchar_t w1 = L'\100';   // L'@'
wchar_t w2 = L'\1000';  // C4066 L'@', 0 ignored
wchar_t w3 = L'\009';   // C4066 L'\0', 9 ignored
wchar_t w4 = L'\089';   // C4066 L'\0', 89 ignored
wchar_t w5 = L'\qrs';   // C4129, C4066 L'q' escape, rs ignored
wchar_t w6 = L'\x0050'; // L'P'
wchar_t w7 = L'\x0pqr'; // C4066 L'\0', pqr ignored
```

**Завершение блока, относящегося только к системам Майкрософт**

Символ обратной косой черты (\\) является символом продолжения строки, если он находится в конце строки. Если символ обратной косой черты требуется использовать как символьный литерал, необходимо ввести две косые черты подряд (`\\`). Дополнительные сведения о символе продолжения строки см. в разделе [Phases of Translation](../preprocessor/phases-of-translation.md).

###  <a name="bkmk_UCN"></a> Универсальные имена символов

В символьных литералах и машинных (не являющихся необработанными) строковых литералах любой символ может быть представлен универсальным именем символа.  Универсальные имена символов образуются префиксом \U, за которым следует восьмизначная кодовая точка Юникода, или префиксом \u, за которым следует четырехзначная кодовая точка Юникода. Все восемь или четыре знака, соответственно, должны присутствовать для создания корректного универсального имени символа.

```cpp
char u1 = 'A';          // 'A'
char u2 = '\101';       // octal, 'A'
char u3 = '\x41';       // hexadecimal, 'A'
char u4 = '\u0041';     // \u UCN 'A'
char u5 = '\U00000041'; // \U UCN 'A'
```

#### <a name="surrogate-pairs"></a>Суррогатные пары

С помощью универсальных имен символов нельзя закодировать значения в диапазоне суррогатных кодовых точек D800–DFFF. Для суррогатных пар Юникода укажите универсальное имя символа, используя `\UNNNNNNNN`, где NNNNNNNN — восьмизначная кодовая точка для символа. При необходимости компилятор создаст суррогатную пару.

В C++03 языком допускалось, чтобы универсальными именами символов представлялось лишь определенное подмножество символов. Также могли существовать универсальные имена символов, не представляющие никаких допустимых символов Юникода. В стандарте C++11 этот недочет был исправлен. В C++11 в символьных и строковых литералах и идентификаторах можно использовать универсальные имена символов.  Дополнительные сведения об универсальных именах символов см. в разделе [Character Sets](../cpp/character-sets.md). Дополнительные сведения о Юникоде см. в статье [Unicode](https://msdn.microsoft.com/library/dd374081). Дополнительные сведения о суррогатных парах см. в статье [Surrogate Pairs and Supplementary Characters](/windows/desktop/Intl/surrogates-and-supplementary-characters)(Суррогатные пары и дополнительные символы).

## <a name="string-literals"></a>Строковые литералы

Строковый литерал представляет последовательность символов, которые вместе образуют строку с завершающим нулем. Символы должны быть заключены в двойные кавычки. Существуют следующие типы строковых литералов.

### <a name="narrow-string-literals"></a>Узкие строковые литералы

Узкий строковый литерал является без префикса, двойной кавычки с разделителями, завершающийся нулевым массивом типа `const char[n]`, где n — длина массива в байтах. Обычный строковый литерал может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Обычный строковый литерал также может содержать перечисленные выше escape-последовательности и универсальные имена символов, которые помещаются в байте.

```cpp
const char *narrow = "abcd";

// represents the string: yes\no
const char *escaped = "yes\\no";
```

#### <a name="utf-8-encoded-strings"></a>Строки в кодировке UTF-8

Строка в кодировке UTF-8 представляет собой с префиксом u8, двойной кавычки с разделителями, с завершающим нулем массив типа `const char[n]`, где n — длина закодированного массива в байтах. Строковый литерал с префиксом u8 может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Строковый литерал с префиксом u8 может также содержать перечисленные выше escape-последовательности и любые универсальные имена символов.

```cpp
const char* str1 = u8"Hello World";
const char* str2 = u8"\U0001F607 is O:-)";
```

### <a name="wide-string-literals"></a>Расширенные строковые литералы

Расширенный строковый литерал является нулем массив констант **wchar_t** , начинающийся с "`L`" и содержать любые графические символы, за исключением двойных кавычек ("«), обратной косой черты (\\), или символ новой строки. Расширенный строковый литерал может содержать перечисленные выше escape-последовательности и любые универсальные имена символов.

```cpp
const wchar_t* wide = L"zyxw";
const wchar_t* newline = L"hello\ngoodbye";
```

#### <a name="char16t-and-char32t-c11"></a>char16_t и char32_t (C++11)

В C++11 доступны символьные типы `char16_t` (портативный, 16-разрядный Юникод) и `char32_t` (32-разрядный Юникод):

```cpp
auto s3 = u"hello"; // const char16_t*
auto s4 = U"hello"; // const char32_t*
```

### <a name="raw-string-literals-c11"></a>Необработанные строковые литералы (C++11)

Необработанный строковый литерал является массивом нулем — любого символьного типа —, содержащий любые графические символы, включая двойные кавычки ("«), обратной косой черты (\\), или символ новой строки. Необработанные строковые литералы часто применяются в регулярных выражениях, которые используют классы символов, а также в строках HTML и XML. Примеры см. в следующей статье: [Bjarne Stroustrup's FAQ on C++11](http://www.stroustrup.com/C++11FAQ.html)(Вопросы и ответы о C++11 от Бьерна Страуструпа).

```cpp
// represents the string: An unescaped \ character
const char* raw_narrow = R"(An unescaped \ character)";
const wchar_t* raw_wide = LR"(An unescaped \ character)";
const char*       raw_utf8  = u8R"(An unescaped \ character)";
const char16_t* raw_utf16 = uR"(An unescaped \ character)";
const char32_t* raw_utf32 = UR"(An unescaped \ character)";
```

Разделитель — это содержащая до 16 символов пользовательская последовательность, которая стоит непосредственно перед открывающей круглой скобкой и сразу после закрывающей круглой скобки необработанного строкового литерала.  Например, в `R"abc(Hello"\()abc"` последовательность разделителей — `abc` , а содержимое строки — `Hello"\(`. Разделители можно использовать для различения необработанных строк, содержащих двойные кавычки и круглые скобки. Следующая строка приводит к ошибке компилятора:

```cpp
// meant to represent the string: )"
const char* bad_parens = R"()")";  // error C2059
```

Однако ошибку можно устранить с помощью разделителя:

```cpp
const char* good_parens = R"xyz()")xyz";
```

Можно создать необработанный строковый литерал, содержащий символ новой строки (не escape-символ) в исходном коде:

```cpp
// represents the string: hello
//goodbye
const wchar_t* newline = LR"(hello
goodbye)";
```

### <a name="stdstring-literals-c14"></a>Литералы std::string (C++14)

Литералы std::string представляют собой реализацию пользовательских литералов на основе стандартной библиотеки (см. ниже) и получаются путем добавления префикса "xyx"s (вместе с суффиксом `s` ). Этот тип строковых литералов создает временные объекты типа std::string, std::wstring, std::u32string или std::u16string, в зависимости от указанного префикса. Если префикс не используется, как показано выше, создается объект типа std::string. Если используется префикс L"xyz"s, создается объект типа std::wstring. При использовании префикса u"xyz"s создается объект типа [std::u16string](../standard-library/string-typedefs.md#u16string), а префикса U"xyz"s — объект типа [std::u32string](../standard-library/string-typedefs.md#u32string).

```cpp
//#include <string>
//using namespace std::string_literals;
string str{ "hello"s };
string str2{ u8"Hello World" };
wstring str3{ L"hello"s };
u16string str4{ u"hello"s };
u32string str5{ U"hello"s };
```

Суффикс "s" также может использоваться для необработанных строковых литералов:

```cpp
u32string str6{ UR"(She said "hello.")"s };
```

литералы std::String определены в пространстве имен `std::literals::string_literals` в \<строка > файла заголовка. Поскольку `std::literals::string_literals`и `std::literals` объявляются как [встроенные пространства имен](../cpp/namespaces-cpp.md), `std::literals::string_literals` автоматически считается напрямую принадлежащим пространству имен `std`.

### <a name="size-of-string-literals"></a>Размер строковых литералов

Для ANSI char\* строки и других однобайтовых кодировках (не UTF-8) размер строкового литерала (в байтах) — количество символов плюс 1 для завершающего нуль-символа. Для строк остальных типов размер напрямую не связан с количеством символов. В кодировке UTF-8 для кодирования некоторых *единиц кода*используется до четырех символьных элементов, а для типов char16_t и wchar_t в кодировке UTF-16 — два элемента (всего четыре байта) для кодирования одной *единицы кода*.   В примере ниже показан размер расширенного строкового литерала в байтах.

```cpp
const wchar_t* str = L"Hello!";
const size_t byteSize = (wcslen(str) + 1) * sizeof(wchar_t);
```

Обратите внимание, что `strlen()` и `wcslen()` не включают размер завершающего нуль-символа, размер которого равен размеру элемента строкового типа: один байт на символ\* string, два байта для wchar_t\* или char16_t\*строки и четыре байта для char32_t\* строк.

Максимальная длина строкового литерала — 65535 байт. Это ограничение применимо как к узким, так и к расширенным строковым литералам.

### <a name="modifying-string-literals"></a>Изменение строковых литералов

Поскольку строковые литералы (не включая литералов std: String) — это константы, попытка изменить их, например, `str[2] = 'A'`— вызывает ошибку компилятора.

**Блок, относящийся только к системам Microsoft**

В Visual C++ можно использовать строковый литерал для инициализации указателя не являющимся константным **char** или **wchar_t**. Это разрешено в коде C99, но не рекомендуется в С++98 и удалено из С++11. Попытка изменить строку вызовет нарушение прав доступа, как показано в следующем примере:

```cpp
wchar_t* str = L"hello";
str[2] = L'a'; // run-time error: access violation
```

Может привести к компилятору выдавать ошибку при преобразовании строкового литерала в символ указателя non_const при установке [/Zc: strictstrings (отключение преобразования типов строковых литералов)](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) параметр компилятора. Рекомендуется использовать его для создания переносимого кода, соответствующего стандартам. Также рекомендуется использовать **автоматически** ключевого слова для объявления строки указатели, инициализированные литерала, так как он разрешается в правильный тип (const). В следующем примере кода перехватывается во время компиляции попытка записать в строковый литерал:

```cpp
auto str = L"hello";
str[2] = L'a'; // C3892: you cannot assign to a variable that is const.
```

В некоторых случаях идентичные строковые литералы могут быть объединены в пул для экономии места в исполняемом файле. При объединении строковых литералов в пулы компилятор делает так, что все ссылки на определенный строковый литерал указывают на одну и ту же область в памяти, вместо того чтобы каждая ссылка указывала на отдельный экземпляр строкового литерала. Для включения объединения строковых литералов в пулы используется параметр компилятора [/GF](../build/reference/gf-eliminate-duplicate-strings.md) .

**End Microsoft Specific**

### <a name="concatenating-adjacent-string-literals"></a>Сцепление смежных строковых литералов

Все смежные расширенные и узкие строковые литералы соединяются. Данное объявление:

```cpp
char str[] = "12" "34";
```

идентично следующему объявлению:

```cpp
char atr[] = "1234";
```

и следующему объявлению:

```cpp
char atr[] =  "12\
34";
```

Использование внедренных шестнадцатеричных escape-кодов для задания строковых литералов может привести к непредвиденным результатам. В следующем примере выполняется попытка создать строковый литерал, содержащий символ ASCII 5, за которым следуют символы f, i, v и e:

```cpp
"\x05five"
```

Фактический результат (шестнадцатеричное значение 5F) является кодом ASCII для символа подчеркивания, за которым следуют символы i, v и e. Чтобы получить правильный результат, можно воспользоваться одним из следующих способов:

```cpp
"\005five"     // Use octal literal.
"\x05" "five"  // Use string splicing.
```

Поскольку литералы std::string представляют собой типы std::string, их можно соединить с оператором "+", определенном для типов [basic_string](../standard-library/basic-string-class.md) . Эти литералы также можно соединить аналогично смежным строковым литералам. В обоих случаях кодировка строки и суффикс должны совпадать:

```cpp
auto x1 = "hello" " " " world"; // OK
auto x2 = U"hello" " " L"world"; // C2308: disagree on prefix
auto x3 = u8"hello" " "s u8"world"s; // OK, agree on prefixes and suffixes
auto x4 = u8"hello" " "s u8"world"z; // C3688, disagree on suffixes
```

### <a name="string-literals-with-universal-character-names"></a>Строковые литералы с универсальными именами символов

Машинные (не являющиеся необработанными) строковые литералы могут использовать универсальные имена символов для представления любого символа, при условии что универсальные имена можно кодировать как один или несколько символов в строковом типе.  Например, универсальное имя символа, представляющее символ национального алфавита, не может быть закодировано в строку обычных символов с помощью кодовой страницы ANSI. Тем не менее его можно закодировать в строку обычных символов в некоторых многобайтовых кодовых страницах, в строках UTF-8 или в двухбайтовой строке. В C ++ 11 поддержка Юникода расширена, char16_t\* и char32_t\* строковые типы:

```cpp
// ASCII smiling face
const char*     s1 = ":-)";

// UTF-16 (on Windows) encoded WINKING FACE (U+1F609)
const wchar_t*  s2 = L"😉 = \U0001F609 is ;-)";

// UTF-8  encoded SMILING FACE WITH HALO (U+1F607)
const char*     s3 = u8"😇 = \U0001F607 is O:-)";

// UTF-16 encoded SMILING FACE WITH OPEN MOUTH (U+1F603)
const char16_t* s4 = u"😃 = \U0001F603 is :-D";

// UTF-32 encoded SMILING FACE WITH SUNGLASSES (U+1F60E)
const char32_t* s5 = U"😎 = \U0001F60E is B-)";
```

## <a name="see-also"></a>См. также

[Кодировки](../cpp/character-sets.md)<br/>
[Числовые, логические литералы и литералы-указатели](../cpp/numeric-boolean-and-pointer-literals-cpp.md)<br/>
[Определенные пользователем литералы](../cpp/user-defined-literals-cpp.md)
