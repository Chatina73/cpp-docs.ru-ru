---
title: Строковые и символьные литералы (C++)
description: Как объявить и определить строковые и символьные литералы в C++.
ms.date: 08/06/2019
f1_keywords:
- R
- L
- u
- u8
- LR
- uR
- u8R
helpviewer_keywords:
- literal strings [C++]
- string literals [C++]
ms.assetid: 61de8f6f-2714-4e7b-86b6-a3f885d3b9df
ms.openlocfilehash: df690bea81b9799b30ae91313ce7157400ef8413
ms.sourcegitcommit: bd7ddc044f9083246614b602ef6a758775313214
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/09/2019
ms.locfileid: "68866097"
---
# <a name="string-and-character-literals-c"></a>Строковые и символьные литералы (C++)

В C++ поддерживаются различные типы строк и символов, а также доступны различные способы выражения значений литералов каждого из этих типов. В исходном коде содержимое символьных и строковых литералов выражается с помощью кодировки. Универсальные имена символов и escape-символы позволяют представить любую строку, используя только основную кодировку исходного кода. Необработанные строковые литералы позволяют не использовать escape-символы и могут применяться для выражения всех типов строковых литералов. Можно также создавать литералы без необходимости выполнения дополнительных действий по созданию `std::string` или преобразованию.

```cpp
#include <string>
using namespace std::string_literals; // enables s-suffix for std::string literals

int main()
{
    // Character literals
    auto c0 =   'A'; // char
    auto c1 = u8'A'; // char
    auto c2 =  L'A'; // wchar_t
    auto c3 =  u'A'; // char16_t
    auto c4 =  U'A'; // char32_t

    // Multicharacter literals
    auto m0 = 'abcd'; // int, value 0x61626364

    // String literals
    auto s0 =   "hello"; // const char*
    auto s1 = u8"hello"; // const char*, encoded as UTF-8
    auto s2 =  L"hello"; // const wchar_t*
    auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16
    auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32

    // Raw string literals containing unescaped \ and "
    auto R0 =   R"("Hello \ world")"; // const char*
    auto R1 = u8R"("Hello \ world")"; // const char*, encoded as UTF-8
    auto R2 =  LR"("Hello \ world")"; // const wchar_t*
    auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16
    auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32

    // Combining string literals with standard s-suffix
    auto S0 =   "hello"s; // std::string
    auto S1 = u8"hello"s; // std::string
    auto S2 =  L"hello"s; // std::wstring
    auto S3 =  u"hello"s; // std::u16string
    auto S4 =  U"hello"s; // std::u32string

    // Combining raw string literals with standard s-suffix
    auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char*
    auto S6 = u8R"("Hello \ world")"s; // std::string from a raw const char*, encoded as UTF-8
    auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t*
    auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16
    auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32
}
```

Строковые литералы могут не иметь префикса или включать префиксы `u8`, `L`, `u`и  `U` для обозначения кодировок обычных символов (однобайтовых или многобайтовых), UTF-8, расширенных символов (UCS-2 или UTF-16), UTF-16 и UTF-32, соответственно. Необработанный строковый литерал `R`может `u8R`иметь `LR`префиксы, `UR` ,, `uR`и для необработанных эквивалентов этих кодировок.  Чтобы создать временные или статические `std::string` значения, можно использовать строковые литералы или необработанные строковые литералы `s` с суффиксом. Дополнительные сведения см. в разделе [строковые литералы](#string-literals) ниже. Дополнительные сведения о базовой кодировке исходного кода, универсальных именах символов и использовании символов из расширенных кодовых страниц в исходном коде см. в разделе [наборы символов](../cpp/character-sets.md).

## <a name="character-literals"></a>Символьные литералы

*Символьный литерал* состоит из символьной константы. Она представлена символом, заключенным в одинарные кавычки. Существует пять типов символьных литералов:

- Обычные символьные литералы типа **char**, например`'a'`

- Символьные литералы UTF-8 типа **char** (**char8_t** в c++ 20), например`u8'a'`

- Расширенные символьные литералы типа `wchar_t`, например `L'a'`.

- Символьные литералы UTF-16 типа `char16_t`, например`u'a'`

- UTF-32 символьные литералы типа `char32_t`, например`U'a'`

Символом, используемым для символьного литерала, может быть любой символ, за исключением символов\\обратной косой черты (""), одинарной кавычки (') или новой строки. Зарезервированные символы можно указывать с помощью escape-последовательности. Символы можно указывать с помощью универсальных имен символов, при условии что тип является достаточно крупным для размещения символа.

### <a name="encoding"></a>кодировка

Символьные литералы кодируются по-разному в соответствии с их префиксом.

- Символьный литерал без префикса является обычным символьным литералом. Значение обычного символьного литерала, содержащего один символ, escape-последовательность или универсальное имя символа, которое может быть представлено в наборе символов выполнения, имеет значение, равное числовому значению его кодировки в наборе символов выполнения. Обычный символьный литерал, содержащий более одного символа, escape-последовательности или универсального имени символа, являетсямногосимвольным литералом. Многосимвольный литерал или обычный символьный литерал, который не может быть представлен в наборе символов выполнения, имеет тип **int**, а его значение определяется реализацией. Сведения о КОМПИЛЯТОРОМ MSVC см. в разделе, относящемся к **корпорации Майкрософт** ниже.

- Символьный литерал, начинающийся с `L` префикса, является литералом расширенных символов. Значение литерала расширенных символов, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное числовому значению его кодировки в наборе расширенных символов выполнения, если только символьный литерал не имеет представления в набор расширенных символов выполнения. в этом случае значение определяется реализацией. Значение литерала расширенных символов, содержащего несколько символов, escape-последовательностями или универсальных имен символов, определяется реализацией. Сведения о КОМПИЛЯТОРОМ MSVC см. в разделе, относящемся к **корпорации Майкрософт** ниже.

- Символьный литерал, начинающийся с `u8` префикса, является символьным литералом UTF-8. Значение символьного литерала UTF-8, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное значению его кодовой точки ISO 10646, если оно может быть представлено в одной единице кода UTF-8 (соответствующем элементам управления C0 и Basic Latin Блок Юникода). Если значение не может быть представлено одной единицей кода UTF-8, программа неправильно сформирована. Символьный литерал в кодировке UTF-8, содержащий более одного символа, escape-последовательности или универсального имени символа, имеет неправильный формат.

- Символьный литерал, начинающийся с `u` префикса, является символьным литералом UTF-16. Значение символьного литерала UTF-16, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное значению его кодовой точки ISO 10646, если оно может быть представлено в одной единице кода UTF-16 (соответствующее базовой многоязыковой плоскости). ). Если значение не может быть представлено одной единицей кода UTF-16, программа неправильно сформирована. Символьный литерал UTF-16, содержащий более одного символа, escape-последовательности или универсального имени символа, имеет неправильный формат.

- Символьный литерал, начинающийся с `U` префикса, является символьным литералом UTF-32. Значение символьного литерала UTF-32, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное значению кодовой точки ISO 10646. Символьный литерал в кодировке UTF-32, содержащий более одного символа, escape-последовательности или универсального имени символа, имеет неправильный формат.

###  <a name="bkmk_Escape"></a>Escape-последовательности

Существует три вида escape-последовательностей: простая, восьмеричная и шестнадцатеричная. Возможны следующие типы escape-последовательностей:

|Значение|Escape-последовательность|
|-----------|---------------------|
| новая строка | \\\n |
| обратная косая черта | \\\\ |
| горизонтальная табуляция | \\t |
| вопросительный знак | ? или \\? |
| вертикальная табуляция | \\3,3 |
| одинарная кавычка | \\' |
| стирание назад | \\& |
| двойная кавычка | \\" |
| возврат каретки | \\Cерверный |
| нуль-символ | \\0 |
| перевод страницы | \\ж |
| восьмеричный | \\OOO |
| оповещение (колокольчик) | \\конкретного |
| шестнадцатеричный | \\ксххх |

Восьмеричная escape-последовательность — это обратная косая черта, за которой следует последовательность из одной до трех восьмеричных цифр. Восьмеричная escape-последовательность завершается на первом символе, который не является восьмеричной цифрой, если он встречается раньше, чем третья цифра. Наибольшее возможное восьмеричное значение `\377`—.

Шестнадцатеричная escape-последовательность — это обратная косая `x`черта, за которой следует символ, за которым следует последовательность из одной или нескольких шестнадцатеричных цифр. Начальные нули пропускаются. В обычном или U8 символьном литерале самое высокое шестнадцатеричное значение — 0xFF. В расширенном символьном литерале с префиксом L или u максимальное шестнадцатеричное значение — 0xFFFF. В расширенном символьном литерале с префиксом U максимальное шестнадцатеричное значение — 0xFFFFFFFF.

В этом примере кода показаны некоторые примеры экранированных символов с помощью обычных символьных литералов. Один и тот же синтаксис escape-последовательности допустим для других типов символьных литералов.

```cpp
#include <iostream>
using namespace std;

int main() {
    char newline = '\n';
    char tab = '\t';
    char backspace = '\b';
    char backslash = '\\';
    char nullChar = '\0';

    cout << "Newline character: " << newline << "ending" << endl; // Newline character:
                                                                  //  ending
    cout << "Tab character: " << tab << "ending" << endl; // Tab character : ending
    cout << "Backspace character: " << backspace << "ending" << endl; // Backspace character : ending
    cout << "Backslash character: " << backslash << "ending" << endl; // Backslash character : \ending
    cout << "Null character: " << nullChar << "ending" << endl; //Null character:  ending
}
```

Обратная косая\\черта () — это символ продолжения строки, когда он помещается в конец строки. Если символ обратной косой черты требуется использовать как символьный литерал, необходимо ввести две косые черты подряд (`\\`). Дополнительные сведения о символе продолжения строки см. в разделе [Phases of Translation](../preprocessor/phases-of-translation.md).

**Специально для Майкрософт**

Чтобы создать значение из короткого многосимвольного литерала, компилятор преобразует символ или последовательность символов между одинарными кавычками в 8-битные значения в пределах 32-разрядного целого числа. Несколько символов в литерале заполняют соответствующие байты по мере необходимости от высокого до низкого порядка. Затем компилятор преобразует целое число в целевой тип после обычных правил. Например, чтобы создать значение **char** , компилятор принимает младший байт. Чтобы создать значение **wchar_t** или `char16_t` , компилятор принимает слово низкого порядка. Компилятор выдает предупреждение о том, что результат усекается, если какие-либо биты заданы выше назначенного байта или слова.

```cpp
char c0    = 'abcd';    // C4305, C4309, truncates to 'd'
wchar_t w0 = 'abcd';    // C4305, C4309, truncates to '\x6364'
int i0     = 'abcd';    // 0x61626364
```

Восьмеричная escape-последовательность, которая содержит более трех цифр, рассматривается как восьмеричная последовательность из 3 цифр, за которой следуют последующие цифры как символы в многосимвольном литерале, что может привести к неудивительному результату. Например:

```cpp
char c1 = '\100';   // '@'
char c2 = '\1000';  // C4305, C4309, truncates to '0'
```

Escape-последовательности, которые содержат невосьмеричные символы, вычисляются в виде восьмеричной последовательности вплоть до последнего восьмеричного символа, за которыми следуют оставшиеся символы в виде последующих символов в многосимвольном литерале. Предупреждение C4125 создается, если первый невосьмеричный символ является десятичной цифрой. Например:

```cpp
char c3 = '\009';   // '9'
char c4 = '\089';   // C4305, C4309, truncates to '9'
char c5 = '\qrs';   // C4129, C4305, C4309, truncates to 's'
```

Восьмеричная escape-последовательность, которая имеет большее значение `\377` , чем ошибка C2022: "*значение-in-Decimal*": слишком большое для символа.

Escape-последовательность, которая содержит шестнадцатеричные и нешестнадцатеричные символы, вычисляется как многосимвольный литерал, содержащий шестнадцатеричную escape-последовательность вплоть до последнего шестнадцатеричного символа, за которыми следуют нешестнадцатеричные символы. Шестнадцатеричная escape-последовательность, которая не содержит шестнадцатеричных цифр, приводит к ошибке компилятора C2153: "шестнадцатеричные литералы должны содержать по крайней мере одну шестнадцатеричную цифру".

```cpp
char c6 = '\x0050'; // 'P'
char c7 = '\x0pqr'; // C4305, C4309, truncates to 'r'
```

Если в расширенном символьном литерале `L` с префиксом содержится последовательность из множества символов, значение берется из первого символа, а компилятор выдает предупреждение C4066. Последующие символы игнорируются, в отличие от поведения эквивалентного обычного многосимвольного литерала.

```cpp
wchar_t w1 = L'\100';   // L'@'
wchar_t w2 = L'\1000';  // C4066 L'@', 0 ignored
wchar_t w3 = L'\009';   // C4066 L'\0', 9 ignored
wchar_t w4 = L'\089';   // C4066 L'\0', 89 ignored
wchar_t w5 = L'\qrs';   // C4129, C4066 L'q' escape, rs ignored
wchar_t w6 = L'\x0050'; // L'P'
wchar_t w7 = L'\x0pqr'; // C4066 L'\0', pqr ignored
```

**Завершение Microsoft для конкретных**

###  <a name="bkmk_UCN"></a> Универсальные имена символов

В символьных литералах и машинных (не являющихся необработанными) строковых литералах любой символ может быть представлен универсальным именем символа.  Универсальные имена символов формируются с помощью префикса `\U` , за которым следует 8-значная кодовая точка Юникода или префикс `\u` , за которым следует 4-значная кодовая точка Юникода. Все восемь или четыре знака, соответственно, должны присутствовать для создания корректного универсального имени символа.

```cpp
char u1 = 'A';          // 'A'
char u2 = '\101';       // octal, 'A'
char u3 = '\x41';       // hexadecimal, 'A'
char u4 = '\u0041';     // \u UCN 'A'
char u5 = '\U00000041'; // \U UCN 'A'
```

#### <a name="surrogate-pairs"></a>Суррогатные пары

Универсальные имена символов не могут кодировать значения в суррогатном диапазоне кодовых точек D800-DFFF. Для суррогатных пар Юникода укажите универсальное имя символа, используя `\UNNNNNNNN`, где NNNNNNNN — восьмизначная кодовая точка для символа. При необходимости компилятор создает суррогатную пару.

В C++03 языком допускалось, чтобы универсальными именами символов представлялось лишь определенное подмножество символов. Также могли существовать универсальные имена символов, не представляющие никаких допустимых символов Юникода. Эта ошибка была исправлена в стандарте C++ 11. В C++11 в символьных и строковых литералах и идентификаторах можно использовать универсальные имена символов.  Дополнительные сведения об универсальных именах символов см. в разделе [Character Sets](../cpp/character-sets.md). Дополнительные сведения о Юникоде см. в статье [Unicode](https://msdn.microsoft.com/library/dd374081). Дополнительные сведения о суррогатных парах см. в статье [Surrogate Pairs and Supplementary Characters](/windows/desktop/Intl/surrogates-and-supplementary-characters)(Суррогатные пары и дополнительные символы).

## <a name="string-literals"></a>Строковые литералы

Строковый литерал представляет последовательность символов, которые вместе образуют строку с завершающим нулем. Символы должны быть заключены в двойные кавычки. Существуют следующие типы строковых литералов.

### <a name="narrow-string-literals"></a>Узкие строковые литералы

Узким строковым литералом является нефиксированный, разделенный символами двойной кавычки массив типа `const char[n]`, где n — это длина массива в байтах. Обычный строковый литерал может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Обычный строковый литерал также может содержать перечисленные выше escape-последовательности и универсальные имена символов, которые помещаются в байте.

```cpp
const char *narrow = "abcd";

// represents the string: yes\no
const char *escaped = "yes\\no";
```

#### <a name="utf-8-encoded-strings"></a>Строки в кодировке UTF-8

Строка в кодировке UTF-8 — это U8 с двойной кавычкой, разделенный нулем массив типа `const char[n]`, где *n* — это длина закодированного массива в байтах. Строковый литерал с префиксом u8 может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Строковый литерал с префиксом u8 может также содержать перечисленные выше escape-последовательности и любые универсальные имена символов.

```cpp
const char* str1 = u8"Hello World";
const char* str2 = u8"\U0001F607 is O:-)";
```

### <a name="wide-string-literals"></a>Широкие строковые литералы

Широкий строковый литерал — это массив констант **wchar_t** , заканчивающийся нулем, который имеет префикс "`L`" и содержит любой графический символ, кроме двойных кавычек ("), обратной косой черты (\\) или символа новой строки. Расширенный строковый литерал может содержать перечисленные выше escape-последовательности и любые универсальные имена символов.

```cpp
const wchar_t* wide = L"zyxw";
const wchar_t* newline = L"hello\ngoodbye";
```

#### <a name="char16_t-and-char32_t-c11"></a>char16_t и char32_t (C++11)

В C++11 доступны символьные типы `char16_t` (портативный, 16-разрядный Юникод) и `char32_t` (32-разрядный Юникод):

```cpp
auto s3 = u"hello"; // const char16_t*
auto s4 = U"hello"; // const char32_t*
```

### <a name="raw-string-literals-c11"></a>Необработанные строковые литералы (C++ 11)

Необработанный строковый литерал — это массив из любого символьного типа, заканчивающийся нулем, который содержит любой графический символ, включая двойные кавычки ("),\\обратную косую черту () или символ новой строки. Необработанные строковые литералы часто применяются в регулярных выражениях, которые используют классы символов, а также в строках HTML и XML. Примеры см. в следующей статье: [Вопросы и ответы по Бьерном Страуструп на c++ 11](http://www.stroustrup.com/C++11FAQ.html).

```cpp
// represents the string: An unescaped \ character
const char* raw_narrow = R"(An unescaped \ character)";
const wchar_t* raw_wide = LR"(An unescaped \ character)";
const char*       raw_utf8  = u8R"(An unescaped \ character)";
const char16_t* raw_utf16 = uR"(An unescaped \ character)";
const char32_t* raw_utf32 = UR"(An unescaped \ character)";
```

Разделитель — это определяемая пользователем последовательность длиной до 16 символов, которая непосредственно предшествует открывающей скобке необработанного строкового литерала и сразу после закрывающей скобки.  Например, в `R"abc(Hello"\()abc"` последовательность разделителей — `abc` , а содержимое строки — `Hello"\(`. Разделители можно использовать для различения необработанных строк, содержащих двойные кавычки и круглые скобки. Этот строковый литерал вызывает ошибку компилятора:

```cpp
// meant to represent the string: )"
const char* bad_parens = R"()")";  // error C2059
```

Однако ошибку можно устранить с помощью разделителя:

```cpp
const char* good_parens = R"xyz()")xyz";
```

Можно создать необработанный строковый литерал, содержащий символ новой строки (не экранированный символ) в источнике:

```cpp
// represents the string: hello
//goodbye
const wchar_t* newline = LR"(hello
goodbye)";
```

### <a name="stdstring-literals-c14"></a>литералы std:: String (C++ 14)

`std::string`литералы являются реализациями определяемых пользователем литералов в стандартной библиотеке (см. ниже), которые представлены `"xyz"s` как ( `s` с суффиксом). Этот тип строкового литерала создает временный объект типа `std::string` `std::u32string`, `std::wstring`, или `std::u16string`, в зависимости от указанного префикса. Если префикс не используется, `std::string` то создается. `L"xyz"s``std::wstring`создает. `u"xyz"s`создает [std:: u16string](../standard-library/string-typedefs.md#u16string)и `U"xyz"s` создает [std:: u32string](../standard-library/string-typedefs.md#u32string).

```cpp
//#include <string>
//using namespace std::string_literals;
string str{ "hello"s };
string str2{ u8"Hello World" };
wstring str3{ L"hello"s };
u16string str4{ u"hello"s };
u32string str5{ U"hello"s };
```

`s` Суффикс можно также использовать для необработанных строковых литералов:

```cpp
u32string str6{ UR"(She said "hello.")"s };
```

`std::string`литералы определяются в пространстве имен `std::literals::string_literals` \<в строке > файле заголовка. Поскольку `std::literals::string_literals`и `std::literals` объявляются как [встроенные пространства имен](../cpp/namespaces-cpp.md), `std::literals::string_literals` автоматически считается напрямую принадлежащим пространству имен `std`.

### <a name="size-of-string-literals"></a>Размер строковых литералов

Для строк `char*` ANSI и других однобайтовых кодировок (но не UTF-8) размер строкового литерала (в байтах) — это число символов плюс 1 для завершающего нуль-символа. Для строк остальных типов размер напрямую не связан с количеством символов. UTF-8 использует до четырех элементов **char** для кодирования некоторых *единиц кода*, а `char16_t` или `wchar_t` кодирования UTF-16 может использовать два элемента (всего четыре байта) для кодирования одной *единицы кода*. В примере ниже показан размер расширенного строкового литерала в байтах.

```cpp
const wchar_t* str = L"Hello!";
const size_t byteSize = (wcslen(str) + 1) * sizeof(wchar_t);
```

Обратите `strlen()` внимание `wcslen()` , что и не включайте размер завершающего нуль-символа, размер которого равен размеру элемента строкового типа `char*` : один байт в строке, два байта `wchar_t*` или `char16_t*` строки и четыре байт в `char32_t*` строках.

Максимальная длина строкового литерала составляет 65 535 байт. Это ограничение применимо как к узким, так и к расширенным строковым литералам.

### <a name="modifying-string-literals"></a>Изменение строковых литералов

Поскольку строковые литералы (не `std::string` включая литералы) являются константами, попытка их изменить, например `str[2] = 'A'`, приводит к ошибке компилятора.

**Специально для Майкрософт**

В Microsoft C++можно использовать строковый литерал для инициализации указателя на неконстантный **тип char** или **wchar_t**. Эта неконстантная инициализация разрешена в коде C99, но не рекомендуется в C++ 98 и удалена в C++ 11. Попытка изменить строку вызовет нарушение прав доступа, как показано в следующем примере:

```cpp
wchar_t* str = L"hello";
str[2] = L'a'; // run-time error: access violation
```

Если задать параметр компилятора [/Zc: strictStrings (отключить преобразование типа строкового литерала)](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) , то при преобразовании строкового литерала в указатель неконстантного символа компилятор может выдать ошибку. Рекомендуется использовать его для создания переносимого кода, соответствующего стандартам. Также рекомендуется использовать ключевое слово **Auto** для объявления инициализированных указателей строкового литерала, так как он разрешается в правильный (const) тип. В следующем примере кода перехватывается во время компиляции попытка записать в строковый литерал:

```cpp
auto str = L"hello";
str[2] = L'a'; // C3892: you cannot assign to a variable that is const.
```

В некоторых случаях идентичные строковые литералы могут быть объединены в пул для экономии места в исполняемом файле. При объединении строковых литералов в пулы компилятор делает так, что все ссылки на определенный строковый литерал указывают на одну и ту же область в памяти, вместо того чтобы каждая ссылка указывала на отдельный экземпляр строкового литерала. Для включения объединения строковых литералов в пулы используется параметр компилятора [/GF](../build/reference/gf-eliminate-duplicate-strings.md) .

**Завершение Microsoft для конкретных**

### <a name="concatenating-adjacent-string-literals"></a>Сцепление смежных строковых литералов

Все смежные расширенные и узкие строковые литералы соединяются. Данное объявление:

```cpp
char str[] = "12" "34";
```

идентично следующему объявлению:

```cpp
char atr[] = "1234";
```

и следующему объявлению:

```cpp
char atr[] =  "12\
34";
```

Использование внедренных шестнадцатеричных escape-кодов для задания строковых литералов может привести к непредвиденным результатам. В следующем примере выполняется попытка создать строковый литерал, содержащий символ ASCII 5, за которым следуют символы f, i, v и e:

```cpp
"\x05five"
```

Фактический результат (шестнадцатеричное значение 5F) является кодом ASCII для символа подчеркивания, за которым следуют символы i, v и e. Чтобы получить правильный результат, можно воспользоваться одним из следующих способов:

```cpp
"\005five"     // Use octal literal.
"\x05" "five"  // Use string splicing.
```

`std::string`литералы, так как они `std::string` являются типами, могут быть объединены `+` с оператором, который определен для типов [basic_string](../standard-library/basic-string-class.md) . Эти литералы также можно соединить аналогично смежным строковым литералам. В обоих случаях кодировка строки и суффикс должны совпадать:

```cpp
auto x1 = "hello" " " " world"; // OK
auto x2 = U"hello" " " L"world"; // C2308: disagree on prefix
auto x3 = u8"hello" " "s u8"world"s; // OK, agree on prefixes and suffixes
auto x4 = u8"hello" " "s u8"world"z; // C3688, disagree on suffixes
```

### <a name="string-literals-with-universal-character-names"></a>Строковые литералы с универсальными именами символов

Машинные (не являющиеся необработанными) строковые литералы могут использовать универсальные имена символов для представления любого символа, при условии что универсальные имена можно кодировать как один или несколько символов в строковом типе.  Например, универсальное имя символа, представляющее символ национального алфавита, не может быть закодировано в строку обычных символов с помощью кодовой страницы ANSI. Тем не менее его можно закодировать в строку обычных символов в некоторых многобайтовых кодовых страницах, в строках UTF-8 или в двухбайтовой строке. В c++ 11 Поддержка Юникода расширена с помощью `char16_t*` строковых типов и. `char32_t*`

```cpp
// ASCII smiling face
const char*     s1 = ":-)";

// UTF-16 (on Windows) encoded WINKING FACE (U+1F609)
const wchar_t*  s2 = L"😉 = \U0001F609 is ;-)";

// UTF-8  encoded SMILING FACE WITH HALO (U+1F607)
const char*     s3 = u8"😇 = \U0001F607 is O:-)";

// UTF-16 encoded SMILING FACE WITH OPEN MOUTH (U+1F603)
const char16_t* s4 = u"😃 = \U0001F603 is :-D";

// UTF-32 encoded SMILING FACE WITH SUNGLASSES (U+1F60E)
const char32_t* s5 = U"😎 = \U0001F60E is B-)";
```

## <a name="see-also"></a>См. также

[Character Sets](../cpp/character-sets.md)\
[Числовые, логические литералы и константы указателей](../cpp/numeric-boolean-and-pointer-literals-cpp.md)\
[Определенные пользователем литералы](../cpp/user-defined-literals-cpp.md)
