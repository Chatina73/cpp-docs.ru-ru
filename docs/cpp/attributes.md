---
description: Дополнительные сведения о атрибутах в C++
title: Атрибуты в C++
ms.date: 04/18/2021
ms.openlocfilehash: ebf35b7c80a815bd4da605c0a5f8343fe991d5b4
ms.sourcegitcommit: 6d2a4ab362b657d17ce1cb336b22b5454dc2bc7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/19/2021
ms.locfileid: "107721125"
---
# <a name="attributes-in-c"></a>Атрибуты в C++

Стандарт C++ определяет общий набор атрибутов. Он также позволяет поставщикам компиляторов определять собственные атрибуты в пространстве имен, характерном для конкретного поставщика. Однако компиляторы необходимы только для распознавания атрибутов, определенных в стандарте.

В некоторых случаях стандартные атрибуты перекрываются с параметрами, зависящими от компилятора `__declspec` . В Microsoft C++ `[[deprecated]]` вместо использования можно использовать атрибут `__declspec(deprecated)` . `[[deprecated]]`Атрибут распознается любым согласованным компилятором. Для всех остальных `__declspec` параметров, таких как `dllimport` и, пока нет `dllexport` эквивалента атрибута, поэтому необходимо продолжать использовать `__declspec` синтаксис. Атрибуты не влияют на систему типов и не изменяют значение программы. Компиляторы не учитывают значения атрибутов, которые они не распознают.

**Visual Studio 2017 версии 15,3 и более поздних версий** (доступно с [`/std:c++17`](../build/reference/std-specify-language-standard-version.md) ): в области списка атрибутов можно указать пространство имен для всех имен одним знаком **`using`** :

```cpp
void g() {
    [[using rpr: kernel, target(cpu,gpu)]] // equivalent to [[ rpr::kernel, rpr::target(cpu,gpu) ]]
    do task();
}
```

## <a name="c-standard-attributes"></a>Стандартные атрибуты C++

В C++ 11 атрибуты предоставляют стандартизированный способ комментирования конструкций C++ (включая классы, функции, переменные и блоки) с дополнительными сведениями. Атрибуты могут быть или не зависят от поставщика. Компилятор может использовать эти сведения для создания информационных сообщений или для применения специальной логики при компиляции кода с атрибутом. Компилятор игнорирует все нераспознаваемые атрибуты, что означает, что вы не можете определить собственные настраиваемые атрибуты с помощью этого синтаксиса. Атрибуты заключены в двойные квадратные скобки:

```cpp
[[deprecated]]
void Foo(int);
```

Атрибуты представляют стандартизированную альтернативу модулям, зависящим от поставщика `#pragma` , например директивам, `__declspec()` (Visual C++) или `__attribute__` (GNU). Однако для большинства целей вам по-прежнему потребуется использовать конструкции для конкретного поставщика. В настоящее время стандартный указывает следующие атрибуты, которые должен распознать компилятор:

- `[[noreturn]]` Указывает, что функция никогда не возвращает значение; Иными словами, всегда возникает исключение. Компилятор может настроить правила компиляции для `[[noreturn]]` сущностей.

- `[[carries_dependency]]` Указывает, что функция распространяет упорядочение зависимостей данных для синхронизации потоков. Атрибут можно применить к одному или нескольким параметрам, чтобы указать, что переданный аргумент несет зависимость в тело функции. Атрибут может применяться к самой функции, чтобы указать, что возвращаемое значение несет зависимость от функции. Компилятор может использовать эти сведения для создания более эффективного кода.

- `[[deprecated]]`**Visual Studio 2015 и более поздние версии:** Указывает, что функция не предназначена для использования. Кроме того, он может не существовать в будущих версиях интерфейса библиотеки. Компилятор может использовать этот атрибут для создания информационного сообщения, когда клиентский код пытается вызвать функцию. `[[deprecated]]` может применяться к объявлению класса, typedef-Name, переменной, нестатическому элементу данных, функции, пространству имен, перечислению, перечислителю или специализации шаблона.

- `[[fallthrough]]`**Visual Studio 2017 и более поздние версии:** (доступно с [`/std:c++17`](../build/reference/std-specify-language-standard-version.md) ) `[[fallthrough]]` атрибут может использоваться в контексте [`switch`](switch-statement-cpp.md) инструкций в качестве подсказки для компилятора (или любого читателя кода, считывающего код), который предназначен для fallthrough поведения. Компилятор Microsoft C++ в настоящее время не предупреждает о поведении fallthrough, поэтому этот атрибут не влияет на поведение компилятора.

- `[[nodiscard]]`**Visual Studio 2017 версии 15,3 и более поздних версий:** (доступно с [`/std:c++17`](../build/reference/std-specify-language-standard-version.md) ) указывает, что возвращаемое значение функции не предназначено для отмены. Вызывает предупреждение [порог предупреждения c4834](../error-messages/compiler-warnings/c4834.md), как показано в следующем примере:

    ```cpp
    [[nodiscard]]
    int foo(int i) { return i * i; }

    int main()
    {
        foo(42); //warning C4834: discarding return value of function with 'nodiscard' attribute
        return 0;
    }
    ```

- `[[maybe_unused]]`**Visual Studio 2017 версии 15,3 и более поздних версий:** (доступно с [`/std:c++17`](../build/reference/std-specify-language-standard-version.md) ) указывает, что переменные, функции, классы, typedef, нестатические элементы данных, перечисления или специализацию шаблона можно намеренно не использовать. Компилятор не выдает предупреждение, если помеченная сущностью `[[maybe_unused]]` не используется. Сущность, объявленная без атрибута, может быть впоследствии повторно объявлена с атрибутом и наоборот. Сущность считается *помеченной* после первого объявления, помеченного как " `[[maybe_unused]]` проанализировано", и для оставшейся части текущего блока преобразования.

## <a name="microsoft-specific-attributes"></a>Атрибуты, относящиеся к Microsoft

- `[[gsl::suppress(rules)]]` Этот атрибут, предназначенный для Microsoft, используется для подавления предупреждений от тех, которые применяют правила [библиотеки (GSL)](https://github.com/Microsoft/GSL) в коде. Например, рассмотрим следующий фрагмент кода:

    ```cpp
    int main()
    {
        int arr[10]; // GSL warning C26494 will be fired
        int* p = arr; // GSL warning C26485 will be fired
        [[gsl::suppress(bounds.1)]] // This attribute suppresses Bounds rule #1
        {
            int* q = p + 1; // GSL warning C26481 suppressed
            p = q--; // GSL warning C26481 suppressed
        }
    }
    ```

  В этом примере возникают следующие предупреждения:

  - 26494 (тип правило 5: всегда инициализировать объект.)

  - 26485 (ограничивающее правило 3: нет массива для Decay указателя.)

  - 26481 (правило границы 1: не используйте арифметические действия с указателями. Вместо этого используйте Span.)

  Первые два предупреждения срабатывают при компиляции этого кода с установленным и активируемым средством анализа кода CppCoreCheck. Но третье предупреждение не срабатывает из-за атрибута. Вы можете подавить весь профиль границ, записав его `[[gsl::suppress(bounds)]]` без включения определенного номера правила. C++ Core Guidelines предназначены для помощи в написании лучшего и безопасного кода. Атрибут подавлять упрощает отключение предупреждений, когда они не нужны.
