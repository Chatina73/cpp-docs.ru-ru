---
title: Атрибуты в C++
ms.date: 06/01/2018
ms.assetid: 748340d9-8abf-4940-b0a0-91b6156a3ff8
ms.openlocfilehash: a4d24324165f3cce60d259adf6e3d21638296cf8
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50471829"
---
# <a name="attributes-in-c"></a>Атрибуты в C++

Стандарт C++ определяет набор атрибутов, а также позволяет поставщиками компиляторов для определения собственных атрибутов (в пространстве имен поставщика), но компиляторы должны распознает только те атрибуты, которые определены в стандарте.

В некоторых случаях стандартные атрибуты перекрываться с параметрами declspec специфичные для компилятора. В Visual C++, можно использовать `[[deprecated]]` атрибута, а не с помощью `declspec(deprecated)` и атрибут будет распознаваться компилятором любой совместимый. Для всех остальных параметров declspec например dllimport и dllexport есть еще атрибут эквивалента, необходимо продолжить использовать синтаксис declspec. Атрибуты не влияют на системе типов, и они не изменяют смысл программы. Компиляторы пропускать значения атрибутов, которые не удается распознать.

**Visual Studio 2017 версии 15.3 и более поздние версии** (состав [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)): В рамках список атрибутов, можно указать пространство имен для всех имен с одним **с помощью** introducer:

```cpp
void g() {
    [[using rpr: kernel, target(cpu,gpu)]] // equivalent to [[ rpr::kernel, rpr::target(cpu,gpu) ]]
    do task();
}
```

## <a name="c-standard-attributes"></a>Стандарт C++ атрибуты

В C ++ 11 атрибуты внедрить стандартную процедуру для добавления заметок к конструкций C++ (включая, но не ограничиваясь классы, функции, переменные и блоки), с дополнительными сведениями, которые могут поддерживаться или не может быть от конкретных поставщиков. Компилятор может использовать эти сведения для создания информационных сообщений или для применения специальной логики при компиляции кода с атрибутами. Компилятор игнорирует все атрибуты, которые он не распознает, что означает, что невозможно определить собственные настраиваемые атрибуты, используя следующий синтаксис. Атрибуты заключаются в двойные квадратные скобки:

```cpp
[[deprecated]]
void Foo(int);
```

Атрибуты представляют стандартизированный альтернативой расширения поставщика, например директивы #pragma, __declspec() (Visual C++), или &#95; &#95;атрибут&#95; &#95; (GNU). Тем не менее по-прежнему необходимо будет использовать конструкции поставщика для большинства целей. В настоящее время стандарте задает следующие атрибуты, которые следует иметь в виду соответствующим компилятором:

- `[[noreturn]]` Указывает, что функция никогда не возвращается; Другими словами всегда выдает исключение. Компилятор можно настроить правила его компиляции `[[noreturn]]` сущностей.

- `[[carries_dependency]]` Указывает, что функция распространяет данные зависимостей, упорядочение по отношению к синхронизации потоков. Атрибут может применяться для одного или нескольких параметров, чтобы указать, что переданный аргумент содержит зависимость в теле функции. Атрибут может быть применен к саму функцию, чтобы указать, что возвращаемое значение содержит зависимость выходом из функции. Компилятор может использовать эти сведения для создания более эффективный код.

- `[[deprecated]]` **Visual Studio 2015 и более поздних версий:** указывает, что функция не предназначена для использования и может отсутствовать в будущих версиях интерфейса библиотеки. Компилятор может использовать это для создания информационное сообщение, когда клиентский код пытается вызвать функцию. Могут применяться к объявлению класса, имя typedef, переменной, нестатические данные-член, функции, пространство имен, перечисления, перечислителя или специализацию шаблона.

- `[[fallthrough]]` **Visual Studio 2017 и более поздних версий:** (состав [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)) `[[fallthrough]]` атрибут может использоваться в контексте [переключения](switch-statement-cpp.md) инструкции, как подсказку для компилятора (или если вы читаете код), поведение fallthrough предназначено. Компилятор Visual C++ в настоящее время не предупреждать о fallthrough поведение, поэтому этот атрибут не имеет эффекта компилятора поведения.

- `[[nodiscard]]` **Visual Studio 2017 версии 15.3 и более поздние версии:** (состав [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)) указывает, что возвращаемое значение функции не должен быть отброшены. Вызывает предупреждение C4834, как показано в следующем примере:

   ```cpp
   [[nodiscard]]
   int foo(int i) { return i * i; }

   int main()
   {
       foo(42); //warning C4834: discarding return value of function with 'nodiscard' attribute
       return 0;
   }
   ```

- `[[maybe_unused]]` **Visual Studio 2017 версии 15.3 и более поздние версии:** (состав [/std: c ++ 17](../build/reference/std-specify-language-standard-version.md)) указывает, что переменной, функции, класса, typedef, нестатические данные-член, enum или специализации шаблона может намеренно не используется. Компилятор не предупреждать, когда сущность помечена как `[[maybe_unused]]` не используется. Повторное объявление сущности, которая объявлена без атрибута можно позже с атрибутом и наоборот. Сущность считается помечено после первого объявления, помеченный анализируется и конца перевод текущей записи преобразования.

## <a name="microsoft-specific-attributes"></a>Атрибуты, характерные для Майкрософт

- `[[gsl::suppress(rules)]]` Этот атрибут характерные для Майкрософт используется для подавления предупреждений в данный момент применения [библиотеки поддержки рекомендации (GSL)](https://github.com/Microsoft/GSL) правила в коде. Например рассмотрим этот фрагмент кода:

    ```cpp
    void main()
    {
        int arr[10]; // GSL warning 26494 will be fired
        int* p = arr; // GSL warning 26485 will be fired
        [[gsl::suppress(bounds.1)]] // This attribute suppresses Bounds rule #1
        {
            int* q = p + 1; // GSL warning 26481 suppressed
            p = q--; // GSL warning 26481 suppressed
        }
    }
    ```

   Приведенный пример кода вызывает следующие предупреждения:

   - 26494 (тип правила 5: всегда Инициализируйте объект.)

   - 26485 (границы правило 3: массива в указатель decay.)

   - 26481 (границы правила 1: не используйте арифметику указателей. Используйте диапазон.)

   Первые два предупреждения срабатывать при компиляции кода с помощью средства анализа кода CppCoreCheck установлен и активирован. Но третье предупреждение не срабатывает из-за атрибута. Весь профиль границ можно отключить, писать [[gsl::suppress(bounds)]], не включая номер конкретного правила. C++ Core Guidelines призваны помочь в создании более и более безопасный код. Атрибут подавлять позволяет легко отключить предупреждения, если они не нужны.