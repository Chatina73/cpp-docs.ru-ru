---
title: Атрибуты в C++
ms.date: 05/06/2019
ms.assetid: 748340d9-8abf-4940-b0a0-91b6156a3ff8
ms.openlocfilehash: efdc62e2343135aee483520f633bac99519455b4
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87229211"
---
# <a name="attributes-in-c"></a>Атрибуты в C++

Стандарт C++ определяет набор атрибутов, а также позволяет поставщикам компиляторов определять собственные атрибуты (в рамках пространства имен, зависящего от поставщика), но компиляторы должны распознать только те атрибуты, которые определены в стандарте.

В некоторых случаях стандартные атрибуты перекрываются с параметрами declspec, зависящими от компилятора. В Visual C++ можно использовать атрибут, а `[[deprecated]]` не использовать `declspec(deprecated)` , и атрибут будет распознан любым компилятором. Для всех остальных параметров declspec, таких как dllimport и dllexport, существует хотя бы один эквивалент атрибута, поэтому необходимо продолжить использовать синтаксис declspec. Атрибуты не влияют на систему типов и не изменяют значение программы. Компиляторы не учитывают значения атрибутов, которые они не распознают.

**Visual Studio 2017 версии 15,3 и более поздних версий** (доступно в [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)): в области списка атрибутов можно указать пространство имен для всех имен одним знаком **`using`** :

```cpp
void g() {
    [[using rpr: kernel, target(cpu,gpu)]] // equivalent to [[ rpr::kernel, rpr::target(cpu,gpu) ]]
    do task();
}
```

## <a name="c-standard-attributes"></a>Стандартные атрибуты C++

В C++ 11 атрибуты предоставляют стандартизированный способ добавления комментариев к конструкциям C++ (включая классы, функции, переменные и блоки) с дополнительными сведениями, которые могут быть не зависящими от поставщика. Компилятор может использовать эти сведения для создания информационных сообщений или для применения специальной логики при компиляции кода с атрибутом. Компилятор игнорирует все нераспознаваемые атрибуты, что означает, что вы не можете определить собственные настраиваемые атрибуты с помощью этого синтаксиса. Атрибуты заключены в двойные квадратные скобки:

```cpp
[[deprecated]]
void Foo(int);
```

Атрибуты представляют стандартизированную альтернативу модулям, зависящим от поставщика, например директивы #pragma, __declspec () (Visual C++) или &#95;&#95;атрибут&#95;&#95;  (GNU). Тем не менее для большинства целей вам по-прежнему потребуется использовать конструкции, характерные для поставщика. В настоящее время стандартный указывает следующие атрибуты, которые должен распознать компилятор:

- `[[noreturn]]`Указывает, что функция никогда не возвращает значение; Иными словами, всегда возникает исключение. Компилятор может настроить правила компиляции для `[[noreturn]]` сущностей.

- `[[carries_dependency]]`Указывает, что функция распространяет упорядочение зависимостей данных относительно синхронизации потоков. Атрибут можно применить к одному или нескольким параметрам, чтобы указать, что переданный аргумент несет зависимость в тело функции. Атрибут может применяться к самой функции, чтобы указать, что возвращаемое значение несет зависимость от функции. Компилятор может использовать эти сведения для создания более эффективного кода.

- `[[deprecated]]`**Visual Studio 2015 и более поздние версии:** Указывает, что функция не предназначена для использования и может не существовать в будущих версиях интерфейса библиотеки. Компилятор может использовать его для создания информационного сообщения, когда клиентский код пытается вызвать функцию. Может применяться к объявлению класса, typedef-Name, переменной, нестатическому элементу данных, функции, пространству имен, перечислению, перечислителю или специализации шаблона.

- `[[fallthrough]]`**Visual Studio 2017 и более поздние версии:** (доступно с [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)) `[[fallthrough]]` атрибут может использоваться в контексте операторов [switch](switch-statement-cpp.md) в качестве подсказки для компилятора (или любого читателя кода, считывающего код), предназначенного для поведения fallthrough. Компилятор Microsoft C++ в настоящее время не предупреждает о поведении fallthrough, поэтому этот атрибут не влияет на поведение компилятора.

- `[[nodiscard]]`**Visual Studio 2017 версии 15,3 и более поздних версий:** (доступно с [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)) указывает, что возвращаемое значение функции не предназначено для отмены. Вызывает предупреждение порог предупреждения c4834, как показано в следующем примере:

    ```cpp
    [[nodiscard]]
    int foo(int i) { return i * i; }

    int main()
    {
        foo(42); //warning C4834: discarding return value of function with 'nodiscard' attribute
        return 0;
    }
    ```

- `[[maybe_unused]]`**Visual Studio 2017 версии 15,3 и более поздних версий:** (доступно с [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)) указывает, что переменные, функции, классы, typedef, нестатические элементы данных, перечисления или специализацию шаблона могут быть намеренно не использованы. Компилятор не выдает предупреждение, если помеченная сущность `[[maybe_unused]]` не используется. Сущность, объявленная без атрибута, может быть впоследствии повторно объявлена с атрибутом и наоборот. Сущность считается помеченной после того, как будет проанализировано ее первое объявление, и для оставшейся части перевода текущей записи преобразования.

## <a name="microsoft-specific-attributes"></a>Атрибуты, относящиеся к Microsoft

- `[[gsl::suppress(rules)]]`Этот атрибут, предназначенный для Microsoft, используется для подавления предупреждений от тех, которые применяют правила [библиотеки (GSL)](https://github.com/Microsoft/GSL) в коде. Например, рассмотрим следующий фрагмент кода:

    ```cpp
    int main()
    {
        int arr[10]; // GSL warning C26494 will be fired
        int* p = arr; // GSL warning C26485 will be fired
        [[gsl::suppress(bounds.1)]] // This attribute suppresses Bounds rule #1
        {
            int* q = p + 1; // GSL warning C26481 suppressed
            p = q--; // GSL warning C26481 suppressed
        }
    }
    ```

  В этом примере возникают следующие предупреждения:

  - 26494 (тип правило 5: всегда инициализировать объект.)

  - 26485 (ограничивающее правило 3: нет массива для Decay указателя.)

  - 26481 (правило границы 1: не используйте арифметические действия с указателями. Вместо этого используйте Span.)

  Первые два предупреждения срабатывают при компиляции этого кода с установленным и активируемым средством анализа кода CppCoreCheck. Но третье предупреждение не срабатывает из-за атрибута. Вы можете подавить весь профиль границ, записав [[GSL:: подавлять (Bounds)]] без включения определенного номера правила. C++ Core Guidelines предназначены для помощи в написании лучшего и безопасного кода. Атрибут подавлять упрощает отключение предупреждений, если они не нужны.
  