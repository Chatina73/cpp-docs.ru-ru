---
title: Атрибуты вC++
ms.date: 05/06/2019
ms.assetid: 748340d9-8abf-4940-b0a0-91b6156a3ff8
ms.openlocfilehash: 5967974d419299778e4aadaa235ee21c62e16d34
ms.sourcegitcommit: a930a9b47bd95599265d6ba83bb87e46ae748949
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/22/2020
ms.locfileid: "76518300"
---
# <a name="attributes-in-c"></a>Атрибуты вC++

C++ Стандарт определяет набор атрибутов, а также позволяет поставщикам компиляторов определять собственные атрибуты (в пространстве имен, зависящем от поставщика), но компиляторы должны распознать только те атрибуты, которые определены в стандарте.

В некоторых случаях стандартные атрибуты перекрываются с параметрами declspec, зависящими от компилятора. В визуальном C++элементе вместо `declspec(deprecated)` можно использовать атрибут `[[deprecated]]`, и атрибут будет распознан любым согласованным компилятором. Для всех остальных параметров declspec, таких как dllimport и dllexport, существует хотя бы один эквивалент атрибута, поэтому необходимо продолжить использовать синтаксис declspec. Атрибуты не влияют на систему типов и не изменяют значение программы. Компиляторы не учитывают значения атрибутов, которые они не распознают.

**Visual Studio 2017 версии 15,3 и более поздних версий** (доступно в [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)): в области списка атрибутов можно указать пространство имен для всех имен с **помощью одного средства** .

```cpp
void g() {
    [[using rpr: kernel, target(cpu,gpu)]] // equivalent to [[ rpr::kernel, rpr::target(cpu,gpu) ]]
    do task();
}
```

## <a name="c-standard-attributes"></a>C++Стандартные атрибуты

В C++ 11 атрибуты предоставляют стандартизированный способ создания аннотаций C++ к конструкциям (включая классы, функции, переменные и блоки) с дополнительными сведениями, которые могут быть не зависящими от поставщика. Компилятор может использовать эти сведения для создания информационных сообщений или для применения специальной логики при компиляции кода с атрибутом. Компилятор игнорирует все нераспознаваемые атрибуты, что означает, что вы не можете определить собственные настраиваемые атрибуты с помощью этого синтаксиса. Атрибуты заключены в двойные квадратные скобки:

```cpp
[[deprecated]]
void Foo(int);
```

Атрибуты представляют стандартизированную альтернативу модулям, зависящим от поставщика, например директивы #pragma, __declspec () C++(Visual) &#95; &#95;или&#95; &#95; Attribute (GNU). Тем не менее для большинства целей вам по-прежнему потребуется использовать конструкции, характерные для поставщика. В настоящее время стандартный указывает следующие атрибуты, которые должен распознать компилятор:

- `[[noreturn]]` указывает, что функция никогда не возвращает значение; Иными словами, всегда возникает исключение. Компилятор может настроить правила компиляции для сущностей `[[noreturn]]`.

- `[[carries_dependency]]` указывает, что функция распространяет упорядочение зависимостей данных относительно синхронизации потоков. Атрибут можно применить к одному или нескольким параметрам, чтобы указать, что переданный аргумент несет зависимость в тело функции. Атрибут может применяться к самой функции, чтобы указать, что возвращаемое значение несет зависимость от функции. Компилятор может использовать эти сведения для создания более эффективного кода.

- `[[deprecated]]` **Visual Studio 2015 и более поздних версий:** указывает, что функция не предназначена для использования и может не существовать в будущих версиях интерфейса библиотеки. Компилятор может использовать его для создания информационного сообщения, когда клиентский код пытается вызвать функцию. Может применяться к объявлению класса, typedef-Name, переменной, нестатическому элементу данных, функции, пространству имен, перечислению, перечислителю или специализации шаблона.

- `[[fallthrough]]` **Visual Studio 2017 и более поздних версий:** (доступно с помощью [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)) атрибут `[[fallthrough]]` можно использовать в контексте операторов [switch](switch-statement-cpp.md) в качестве подсказки для компилятора (или любого читателя кода, считывающего код), предназначенного для поведения fallthrough. Компилятор Майкрософт C++ в настоящее время не предупреждает о поведении fallthrough, поэтому этот атрибут не влияет на поведение компилятора.

- `[[nodiscard]]` **Visual Studio 2017 версии 15,3 и более поздних версий:** (доступно с [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)) указывает, что возвращаемое значение функции не предназначено для отмены. Вызывает предупреждение порог предупреждения c4834, как показано в следующем примере:

    ```cpp
    [[nodiscard]]
    int foo(int i) { return i * i; }

    int main()
    {
        foo(42); //warning C4834: discarding return value of function with 'nodiscard' attribute
        return 0;
    }
    ```

- `[[maybe_unused]]` **Visual Studio 2017 версии 15,3 и более поздних версий:** (доступно с [/std: c++ 17](../build/reference/std-specify-language-standard-version.md)) указывает, что переменные, функции, классы, typedef, нестатические элементы данных, перечисление или специализацию шаблона можно намеренно не использовать. Компилятор не предупреждает о том, что сущность, помеченная `[[maybe_unused]]`, не используется. Сущность, объявленная без атрибута, может быть впоследствии повторно объявлена с атрибутом и наоборот. Сущность считается помеченной после того, как будет проанализировано ее первое объявление, и для оставшейся части перевода текущей записи преобразования.

## <a name="microsoft-specific-attributes"></a>Атрибуты, относящиеся к Microsoft

- `[[gsl::suppress(rules)]]` этот атрибут, предназначенный для Microsoft, используется для подавления предупреждений от тех, которые применяют правила [библиотеки (GSL)](https://github.com/Microsoft/GSL) в коде. Например, рассмотрим следующий фрагмент кода:

    ```cpp
    int main()
    {
        int arr[10]; // GSL warning 26494 will be fired
        int* p = arr; // GSL warning 26485 will be fired
        [[gsl::suppress(bounds.1)]] // This attribute suppresses Bounds rule #1
        {
            int* q = p + 1; // GSL warning 26481 suppressed
            p = q--; // GSL warning 26481 suppressed
        }
    }
    ```

  В этом примере возникают следующие предупреждения:

  - 26494 (тип правило 5: всегда инициализировать объект.)

  - 26485 (ограничивающее правило 3: нет массива для Decay указателя.)

  - 26481 (правило границы 1: не используйте арифметические действия с указателями. Вместо этого используйте Span.)

  Первые два предупреждения срабатывают при компиляции этого кода с установленным и активируемым средством анализа кода CppCoreCheck. Но третье предупреждение не срабатывает из-за атрибута. Вы можете подавить весь профиль границ, записав [[GSL:: подавлять (Bounds)]] без включения определенного номера правила. C++ Основные рекомендации призваны помочь в написании лучшего и безопасного кода. Атрибут подавлять упрощает отключение предупреждений, если они не нужны.
  