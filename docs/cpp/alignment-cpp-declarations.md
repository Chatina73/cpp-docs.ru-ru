---
title: Выравнивание (объявления C++)
description: Определение выравнивания данных в современных C++.
ms.date: 09/19/2019
ms.assetid: a986d510-ccb8-41f8-b905-433df9183485
ms.openlocfilehash: 67debc00343b8bee4184e020c9269011e2fcebc9
ms.sourcegitcommit: f907b15f50a6b945d0b87c03af0050946157d701
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/20/2019
ms.locfileid: "71158753"
---
# <a name="alignment-c-declarations"></a>Выравнивание (объявления C++)

Одной из низкоуровневых особенностей C++ является возможность указать точное выравнивание объектов в памяти, чтобы максимально использовать конкретную аппаратную архитектуру. По умолчанию компилятор выстраивает элементы класса и структуры по значению размера: и `bool` `char` по 1 байтам, `short` в 2-байтовых `int` `long`границах,, и `float` в 4-байтовых границах. `long long`, идля`long double` 8-байтовых границ. `double` В большинстве случаев не нужно беспокоиться о выравнивании, так как выравнивание по умолчанию уже оптимально. Однако в некоторых случаях можно добиться значительного улучшения производительности или экономии памяти, указав пользовательское выравнивание для структур данных. До Visual Studio 2015 можно использовать ключевые слова `__alignof` Майкрософт и `declspec(alignas)` задать выравнивание, превышающее значение по умолчанию. Начиная с Visual Studio 2015 следует использовать стандартные ключевые слова C++ 11 [alignof и alignas](../cpp/alignof-and-alignas-cpp.md) для максимального переноса кода. Новые ключевые слова ведут себя так же, как и расширения, специфичные для Майкрософт. Документация для этих расширений также применима к новым ключевым словам. Дополнительные сведения см. в разделе [оператор __alignof](../cpp/alignof-operator.md) и [выровняйте](../cpp/align-cpp.md). В C++ стандарте не задано поведение упаковки для выравнивания по границам, меньшим, чем значение по умолчанию компилятора для целевой платформы, поэтому в этом случае необходимо использовать пакет Microsoft #pragma [Pack](../preprocessor/pack.md) .

Используйте [класс aligned_storage](../standard-library/aligned-storage-class.md) для выделения памяти структур данных с пользовательскими выравниваниями. [Класс aligned_union](../standard-library/aligned-union-class.md) предназначен для указания выравнивания для объединений с нетривиальными конструкторами или деструкторами.

## <a name="about-alignment"></a>О выравнивании

Выравнивание представляет собой свойство адреса памяти, выражаемое как числовой адрес по модулю степени 2. Например, адрес 0x0001103F остаток от деления 4 равен 3. Этот адрес считается согласованным с 4n + 3, где 4 обозначает выбранную степень 2. Выравнивание адреса зависит от выбранной степени 2. Тот же адрес по модулю 8 равен 7. Говорят, что адрес выровнен по X, если его выравнивание — Xn+0.

Процессоры выполняют инструкции, которые работают с данными, хранящимися в памяти. Данные идентифицируются по их адресам в памяти. У одной из них также есть размер. Мы вызываем объект «база» *естественным* образом, если его адрес выровнен по размеру. В противном случае он называется *неправильно* . Например, 8-байтная база с плавающей запятой имеет естественное выравнивание, если адрес, используемый для его распознавания, имеет 8-байтовое выравнивание.

## <a name="compiler-handling-of-data-alignment"></a>Обработка выравнивания данных компилятором

Компиляторы пытаются сделать выделение данных способом, который предотвращает неправильное выравнивание данных.

Для простых типов данных компилятор назначает адреса, которые кратны размеру в байтах для типа данных. Например, компилятор назначает адреса переменным типа `long` , кратным 4, устанавливая младшие 2 бита адреса равными нулю.

Компилятор также дополняет структуры тем способом, который естественным образом соответствует каждому элементу структуры. Рассмотрим структуру `struct x_` в следующем примере кода:

```cpp
struct x_
{
   char a;     // 1 byte
   int b;      // 4 bytes
   short c;    // 2 bytes
   char d;     // 1 byte
} bar[3];
```

Компилятор дополняет эту структуру для принудительного выравнивания естественным образом.

В следующем примере кода показано, как компилятор помещает заполненную структуру в память:

```cpp
// Shows the actual memory layout
struct x_
{
   char a;            // 1 byte
   char _pad0[3];     // padding to put 'b' on 4-byte boundary
   int b;            // 4 bytes
   short c;          // 2 bytes
   char d;           // 1 byte
   char _pad1[1];    // padding to make sizeof(x_) multiple of 4
} bar[3];
```

Оба объявления возвращают `sizeof(struct x_)` 12 байт.

Второе объявление включает два дополняющих элемента:

1. `char _pad0[3]`для выровняйте `int b` элемент на 4-байтовой границе.

1. `char _pad1[1]`для выровняйте элементы массива структуры `struct _x bar[3];` по 4-байтовой границе.

Заполнение выровнено между элементами `bar[3]` таким образом, что обеспечивает естественный доступ.

В следующем примере кода показан `bar[3]` макет массива:

```Output
adr offset   element
------   -------
0x0000   char a;         // bar[0]
0x0001   char pad0[3];
0x0004   int b;
0x0008   short c;
0x000a   char d;
0x000b   char _pad1[1];

0x000c   char a;         // bar[1]
0x000d   char _pad0[3];
0x0010   int b;
0x0014   short c;
0x0016   char d;
0x0017   char _pad1[1];

0x0018   char a;         // bar[2]
0x0019   char _pad0[3];
0x001c   int b;
0x0020   short c;
0x0022   char d;
0x0023   char _pad1[1];
```

## <a name="see-also"></a>См. также

[Выравнивание структуры данных](https://en.wikipedia.org/wiki/Data_structure_alignment)
