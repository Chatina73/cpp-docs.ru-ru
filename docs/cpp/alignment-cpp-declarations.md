---
title: Выравнивание (объявления C++)
ms.date: 11/04/2016
ms.assetid: a986d510-ccb8-41f8-b905-433df9183485
ms.openlocfilehash: 644a1f5d476fc35093c99b26e2d0685ad041b0af
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50563115"
---
# <a name="alignment-c-declarations"></a>Выравнивание (объявления C++)

Одной из низкоуровневых особенностей C++ является возможность указать точное выравнивание объектов в памяти, чтобы максимально использовать конкретную аппаратную архитектуру. По умолчанию компилятор выравнивает члены класса и структуры по значению их размера: bool и char выравниваются по однобайтовым границам, короткие по двум байтам, int по четырем байтам, long long, double и long double на восемь байт. В большинстве случаев беспокоиться о выравнивании не нужно, так как выравнивание по умолчанию уже является оптимальным. Однако в некоторых случаях можно добиться значительного выигрыша в производительности или обеспечить экономное расходование памяти путем указания настраиваемого выравнивания для структур данных. До появления Visual Studio 2015 для указания выравнивания, превышающего значение по умолчанию, применяли ключевые слова для систем Microsoft, такие как __alignof и declspec(alignas). Начиная с Visual Studio 2015 следует использовать C ++ 11 стандартные ключевые слова [alignof и alignas](../cpp/alignof-and-alignas-cpp.md) для обеспечения максимальной переносимости кода. Новые ключевые слова ведут себя таким же скрытым образом, как и специальные расширения для систем Microsoft, а документация для таких расширений также применяется к новым ключевым словам. См. в разделе [оператор __alignof](../cpp/alignof-operator.md) и [выровнять](../cpp/align-cpp.md) Дополнительные сведения. Стандарт C++ не определяет поведение упаковки для выравнивания по границам, меньшим, чем компилятора по умолчанию для целевой платформы, поэтому необходимо по-прежнему использовать Microsoft #pragma [пакет](../preprocessor/pack.md) в этом случае.

Стандартная библиотека C++ предоставляет [класс aligned_storage](../standard-library/aligned-storage-class.md) для выделения памяти для структур данных с помощью настраиваемых выравниваний и [класс aligned_union](../standard-library/aligned-union-class.md) для указания выравнивания для объединения с нетривиальные конструкторы или деструкторы.

## <a name="about-alignment"></a>О выравнивании

Выравнивание представляет собой свойство адреса памяти, выражаемое как числовой адрес по модулю степени 2. Например, адрес 0x0001103F по модулю 4 равен 3. При этом говорят, что данный адрес выровнен как 4n + 3, где 4 указывает выбранную степень 2. Выравнивание адреса зависит от выбранной степени 2. Тот же адрес по модулю 8 равен 7. Говорят, что адрес выровнен по X, если его выравнивание — Xn+0.

ЦП выполняют инструкции, работающие с данными, которые хранятся в памяти, а данные идентифицируются своими адресами в памяти. В дополнение к своему адресу одиночный элемент данных также имеет размер. Обычно элемент данных называется выровненным естественным образом, если его адрес выровнен по своему размеру. Если нет, он будет невыровненным. Например, 8-байтовый элемент данных с плавающей запятой выровнен естественным образом, если адрес, используемый для его идентификации, выровнен по 8.

Выравнивание компилятором данных. Компиляторы устройств пытаются выделить данные таким образом, чтобы не допустить рассогласование данных.

Для простых типов данных компилятор назначает адреса, которые кратны размеру в байтах для типа данных. Поэтому компилятор назначает адреса переменным типа long, кратные четырем, устанавливая два младших бита адреса на нуль.

Кроме того, компилятор дополняет структуры так, что он естественным образом выравнивает каждый элемент структуры. Рассмотрим структуру struct x_ в следующем примере кода:

```cpp
struct x_
{
   char a;     // 1 byte
   int b;      // 4 bytes
   short c;    // 2 bytes
   char d;     // 1 byte
} MyStruct;

```

Компилятор дополняет эту структуру для принудительного выравнивания естественным образом.

В следующем примере кода показано, как компилятор размещает дополненную структуру в memory:Copy

```cpp
// Shows the actual memory layout
struct x_
{
   char a;            // 1 byte
   char _pad0[3];     // padding to put 'b' on 4-byte boundary
   int b;            // 4 bytes
   short c;          // 2 bytes
   char d;           // 1 byte
   char _pad1[1];    // padding to make sizeof(x_) multiple of 4
}
```

1. Оба объявления возвращают sizeof(struct x_), равный 12 байтам.

1. Второе объявление включает два дополняющих элемента:

1. char _pad0[3] для выравнивания члена int b по 4-байтовой границе

1. char _pad1[1] для выравнивания элементов массива структуры struct _x bar[3];

1. Дополнение выравнивает элементы bar[3] таким образом, что разрешается естественный доступ.

В следующем примере кода показано использование макета массива bar[3].

```
adr offset   element
------   -------
0x0000   char a;         // bar[0]
0x0001   char pad0[3];
0x0004   int b;
0x0008   short c;
0x000a   char d;
0x000b   char _pad1[1];

0x000c   char a;         // bar[1]
0x000d   char _pad0[3];
0x0010   int b;
0x0014   short c;
0x0016   char d;
0x0017   char _pad1[1];

0x0018   char a;         // bar[2]
0x0019   char _pad0[3];
0x001c   int b;
0x0020   short c;
0x0022   char d;
0x0023   char _pad1[1];
```

## <a name="see-also"></a>См. также

[Выравнивание структуры данных](http://en.wikipedia.org/wiki/Data_structure_alignment)