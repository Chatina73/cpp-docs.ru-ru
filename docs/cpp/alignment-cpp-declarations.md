---
title: Выравнивание
description: Определение выравнивания данных в современных C++.
ms.date: 12/11/2019
ms.assetid: a986d510-ccb8-41f8-b905-433df9183485
ms.openlocfilehash: 45b22742394a0b1c159e8b8102a26802a2441929
ms.sourcegitcommit: 8e285a766523e653aeeb34d412dc6f615ef7b17b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2020
ms.locfileid: "80076112"
---
# <a name="alignment"></a>Выравнивание

Одной из низкоуровневых особенностей C++ является возможность указать точное выравнивание объектов в памяти, чтобы максимально использовать конкретную аппаратную архитектуру. По умолчанию компилятор выровняйте элементы класса и структуры по значению размера: `bool` и `char` в однобайтовых границах, `short` на 2-байтовых границах, `int`, `long`и `float` в пределах 4-байтового диапазона, `long long`, `double`и `long double` в пределах 8-байтовых границ.

В большинстве случаев не нужно беспокоиться о выравнивании, так как выравнивание по умолчанию уже оптимально. Однако в некоторых случаях можно добиться значительного улучшения производительности или экономии памяти, указав пользовательское выравнивание для структур данных. До Visual Studio 2015 можно использовать ключевые слова Майкрософт `__alignof` и `declspec(alignas)`, чтобы указать выравнивание, превышающее значение по умолчанию. Начиная с Visual Studio 2015 следует использовать стандартные ключевые слова C++ 11 **alignof** и **alignas** для максимального переноса кода. Новые ключевые слова ведут себя так же, как и расширения, специфичные для Майкрософт. Документация для этих расширений также применима к новым ключевым словам. Дополнительные сведения см. в разделе [оператор __alignof](../cpp/alignof-operator.md) и [выровняйте](../cpp/align-cpp.md). В C++ стандарте не задано поведение упаковки для выравнивания по границам, меньшим, чем значение по умолчанию компилятора для целевой платформы, поэтому в этом случае необходимо использовать пакет Microsoft #pragma [Pack](../preprocessor/pack.md) .

Используйте [класс aligned_storage](../standard-library/aligned-storage-class.md) для выделения памяти структур данных с пользовательскими выравниваниями. [Класс aligned_union](../standard-library/aligned-union-class.md) предназначен для указания выравнивания для объединений с нетривиальными конструкторами или деструкторами.

## <a name="alignment-and-memory-addresses"></a>Выравнивание и адреса памяти

Выравнивание представляет собой свойство адреса памяти, выражаемое как числовой адрес по модулю степени 2. Например, адрес 0x0001103F остаток от деления 4 равен 3. Этот адрес считается согласованным с 4n + 3, где 4 обозначает выбранную степень 2. Выравнивание адреса зависит от выбранной степени 2. Тот же адрес по модулю 8 равен 7. Говорят, что адрес выровнен по X, если его выравнивание — Xn+0.

Процессоры выполняют инструкции, которые работают с данными, хранящимися в памяти. Данные идентифицируются по их адресам в памяти. У одной из них также есть размер. Мы вызываем объект «база» *естественным* образом, если его адрес выровнен по размеру. В противном случае он называется *неправильно* . Например, 8-байтная база с плавающей запятой имеет естественное выравнивание, если адрес, используемый для его распознавания, имеет 8-байтовое выравнивание.

## <a name="compiler-handling-of-data-alignment"></a>Обработка выравнивания данных компилятором

Компиляторы пытаются сделать выделение данных способом, который предотвращает неправильное выравнивание данных.

Для простых типов данных компилятор назначает адреса, которые кратны размеру в байтах для типа данных. Например, компилятор назначает адреса переменным типа `long`, которые являются кратными 4, устанавливая младшие 2 бита адреса равными нулю.

Компилятор также дополняет структуры тем способом, который естественным образом соответствует каждому элементу структуры. Рассмотрим структуру `struct x_` в следующем примере кода:

```cpp
struct x_
{
   char a;     // 1 byte
   int b;      // 4 bytes
   short c;    // 2 bytes
   char d;     // 1 byte
} bar[3];
```

Компилятор дополняет эту структуру для принудительного выравнивания естественным образом.

В следующем примере кода показано, как компилятор помещает заполненную структуру в память:

```cpp
// Shows the actual memory layout
struct x_
{
   char a;            // 1 byte
   char _pad0[3];     // padding to put 'b' on 4-byte boundary
   int b;            // 4 bytes
   short c;          // 2 bytes
   char d;           // 1 byte
   char _pad1[1];    // padding to make sizeof(x_) multiple of 4
} bar[3];
```

Оба объявления возвращают `sizeof(struct x_)` как 12 байт.

Второе объявление включает два дополняющих элемента:

1. `char _pad0[3]` выровняйте элемент `int b` на границе 4 байта.

1. `char _pad1[1]` для выровняйте элементы массива структуры `struct _x bar[3];` с границей, сопоставленной с четырьмя байтами.

Заполнение выровнено по элементам `bar[3]` таким образом, что обеспечивает естественный доступ.

В следующем примере кода показан макет массива `bar[3]`.

```Output
adr offset   element
------   -------
0x0000   char a;         // bar[0]
0x0001   char pad0[3];
0x0004   int b;
0x0008   short c;
0x000a   char d;
0x000b   char _pad1[1];

0x000c   char a;         // bar[1]
0x000d   char _pad0[3];
0x0010   int b;
0x0014   short c;
0x0016   char d;
0x0017   char _pad1[1];

0x0018   char a;         // bar[2]
0x0019   char _pad0[3];
0x001c   int b;
0x0020   short c;
0x0022   char d;
0x0023   char _pad1[1];
```

## <a name="alignof-and-alignas"></a>alignof и alignas

Описатель типа **alignas** — это переносимый, C++ стандартный способ указания пользовательского выравнивания переменных и определяемых пользователем типов. Оператор **alignof** аналогичен стандартному переносимому способу получения выравнивания указанного типа или переменной.

## <a name="example"></a>Пример

**Alignas** можно использовать для класса, структуры или объединения или для отдельных членов. При обнаружении нескольких описателей **alignas** компилятор выберет наиболее однозначное значение (то есть с наибольшим значением).

```cpp
// alignas_alignof.cpp
// compile with: cl /EHsc alignas_alignof.cpp
#include <iostream>

struct alignas(16) Bar
{
    int i;       // 4 bytes
    int n;      // 4 bytes
    alignas(4) char arr[3];
    short s;          // 2 bytes
};

int main()
{
    std::cout << alignof(Bar) << std::endl; // output: 16
}
```

## <a name="see-also"></a>См. также:

[Выравнивание структуры данных](https://en.wikipedia.org/wiki/Data_structure_alignment)
