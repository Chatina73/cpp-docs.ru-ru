---
title: Выравнивание
description: Как в современных C++ указывается выравнивание данных.
ms.date: 12/11/2019
ms.assetid: a986d510-ccb8-41f8-b905-433df9183485
ms.openlocfilehash: 7f6bef061fee41389bad644d9ac5244f5644da76
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227651"
---
# <a name="alignment"></a>Выравнивание

Одной из низкоуровневых особенностей C++ является возможность указать точное выравнивание объектов в памяти, чтобы максимально использовать конкретную аппаратную архитектуру. По умолчанию компилятор выстраивает члены класса и структуры по значению размера: **`bool`** и **`char`** по 1 байтам, **`short`** по 2 байтам,,, и к 4-байтным границам, и **`int`** , и **`long`** **`float`** **`long long`** **`double`** **`long double`** по 8-байтным границам.

В большинстве случаев не нужно беспокоиться о выравнивании, так как выравнивание по умолчанию уже оптимально. Однако в некоторых случаях можно добиться значительного улучшения производительности или экономии памяти, указав пользовательское выравнивание для структур данных. До Visual Studio 2015 можно использовать ключевые слова Майкрософт **`__alignof`** и **`__declspec(align)`** задать выравнивание, превышающее значение по умолчанию. Начиная с Visual Studio 2015 следует использовать стандартные ключевые слова C++ 11 **`alignof`** и **`alignas`** максимальную переносимость кода. Новые ключевые слова ведут себя так же, как и расширения, специфичные для Майкрософт. Документация для этих расширений также применима к новым ключевым словам. Дополнительные сведения см. в разделе [ `alignof` operator](../cpp/alignof-operator.md) and [aligned](../cpp/align-cpp.md). Стандарт C++ не задает поведение упаковки для выравнивания на границах меньше, чем значение по умолчанию компилятора для целевой платформы, поэтому в этом случае необходимо использовать корпорацию Майкрософт [`#pragma pack`](../preprocessor/pack.md) .

Используйте [класс aligned_storage](../standard-library/aligned-storage-class.md) для выделения памяти структур данных с пользовательскими выравниваниями. [Класс aligned_union](../standard-library/aligned-union-class.md) предназначен для указания выравнивания для объединений с нетривиальными конструкторами или деструкторами.

## <a name="alignment-and-memory-addresses"></a>Выравнивание и адреса памяти

Выравнивание представляет собой свойство адреса памяти, выражаемое как числовой адрес по модулю степени 2. Например, адрес 0x0001103F остаток от деления 4 равен 3. Этот адрес считается согласованным с 4n + 3, где 4 обозначает выбранную степень 2. Выравнивание адреса зависит от выбранной степени 2. Тот же адрес по модулю 8 равен 7. Говорят, что адрес выровнен по X, если его выравнивание — Xn+0.

Процессоры выполняют инструкции, которые работают с данными, хранящимися в памяти. Данные идентифицируются по их адресам в памяти. У одной из них также есть размер. Мы вызываем объект «база» *естественным* образом, если его адрес выровнен по размеру. В противном случае он называется *неправильно* . Например, 8-байтная база с плавающей запятой имеет естественное выравнивание, если адрес, используемый для его распознавания, имеет 8-байтовое выравнивание.

## <a name="compiler-handling-of-data-alignment"></a>Обработка выравнивания данных компилятором

Компиляторы пытаются сделать выделение данных способом, который предотвращает неправильное выравнивание данных.

Для простых типов данных компилятор назначает адреса, которые кратны размеру в байтах для типа данных. Например, компилятор назначает адреса переменным типа **`long`** , кратным 4, устанавливая младшие 2 бита адреса равными нулю.

Компилятор также дополняет структуры тем способом, который естественным образом соответствует каждому элементу структуры. Рассмотрим структуру `struct x_` в следующем примере кода:

```cpp
struct x_
{
   char a;     // 1 byte
   int b;      // 4 bytes
   short c;    // 2 bytes
   char d;     // 1 byte
} bar[3];
```

Компилятор дополняет эту структуру для принудительного выравнивания естественным образом.

В следующем примере кода показано, как компилятор помещает заполненную структуру в память:

```cpp
// Shows the actual memory layout
struct x_
{
   char a;            // 1 byte
   char _pad0[3];     // padding to put 'b' on 4-byte boundary
   int b;            // 4 bytes
   short c;          // 2 bytes
   char d;           // 1 byte
   char _pad1[1];    // padding to make sizeof(x_) multiple of 4
} bar[3];
```

Оба объявления возвращают `sizeof(struct x_)` 12 байт.

Второе объявление включает два дополняющих элемента:

1. `char _pad0[3]`для выровняйте `int b` элемент на 4-байтовой границе.

1. `char _pad1[1]`для выровняйте элементы массива структуры `struct _x bar[3];` по 4-байтовой границе.

Заполнение выровнено между элементами таким `bar[3]` образом, что обеспечивает естественный доступ.

В следующем примере кода показан `bar[3]` Макет массива:

```Output
adr offset   element
------   -------
0x0000   char a;         // bar[0]
0x0001   char pad0[3];
0x0004   int b;
0x0008   short c;
0x000a   char d;
0x000b   char _pad1[1];

0x000c   char a;         // bar[1]
0x000d   char _pad0[3];
0x0010   int b;
0x0014   short c;
0x0016   char d;
0x0017   char _pad1[1];

0x0018   char a;         // bar[2]
0x0019   char _pad0[3];
0x001c   int b;
0x0020   short c;
0x0022   char d;
0x0023   char _pad1[1];
```

## <a name="alignof-and-alignas"></a>`alignof` и `alignas`

**`alignas`** Спецификатор типа является переносимым стандартным способом C++ для указания пользовательского выравнивания переменных и определяемых пользователем типов. Этот **`alignof`** оператор аналогичен стандартному переносимому способу получения выравнивания указанного типа или переменной.

## <a name="example"></a>Пример

Можно использовать **`alignas`** для класса, структуры или объединения или для отдельных элементов. При **`alignas`** обнаружении нескольких описателей компилятор выберет наиболее однозначное значение (то есть с наибольшим значением).

```cpp
// alignas_alignof.cpp
// compile with: cl /EHsc alignas_alignof.cpp
#include <iostream>

struct alignas(16) Bar
{
    int i;       // 4 bytes
    int n;      // 4 bytes
    alignas(4) char arr[3];
    short s;          // 2 bytes
};

int main()
{
    std::cout << alignof(Bar) << std::endl; // output: 16
}
```

## <a name="see-also"></a>См. также статью

[Выравнивание структуры данных](https://en.wikipedia.org/wiki/Data_structure_alignment)
