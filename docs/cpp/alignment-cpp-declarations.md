---
title: Выравнивание (объявления C++)
description: Как выравнивание данных указывается в modern C++.
ms.date: 05/30/2019
ms.assetid: a986d510-ccb8-41f8-b905-433df9183485
ms.openlocfilehash: b6e03ac2b89624a0eb6602183d4ff4bf8b518f8d
ms.sourcegitcommit: 28eae422049ac3381c6b1206664455dbb56cbfb6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/31/2019
ms.locfileid: "66450772"
---
# <a name="alignment-c-declarations"></a>Выравнивание (объявления C++)

Одной из низкоуровневых особенностей C++ является возможность указать точное выравнивание объектов в памяти, чтобы максимально использовать конкретную аппаратную архитектуру. По умолчанию компилятор выравнивает члены класса и структуры по значению их размера: `bool` и `char` по 1-байтовым границам, `short` на 2-байтовые границы `int`, `long`, и `float` на 4-байтовым границам, а `long long`, `double`, и `long double` по 8-байтовым границам. В большинстве случаев вы не должно заботить выравнивание, так как выравнивание по умолчанию уже является оптимальным. В некоторых случаях тем не менее, можно добиться значительное повышение производительности или обеспечить экономное расходование памяти путем указания настраиваемого выравнивания для структур данных. Прежде чем Visual Studio 2015 можно использовать ключевые слова систем Microsoft `__alignof` и `declspec(alignas)` для указания выравнивания, превышающего значение по умолчанию. Начиная с Visual Studio 2015 следует использовать C ++ 11 стандартные ключевые слова [alignof и alignas](../cpp/alignof-and-alignas-cpp.md) для обеспечения максимальной переносимости кода. Новые ключевые слова ведут себя так же, за кулисами как Майкрософт расширений. Документация для таких расширений также применяется к новые ключевые слова. Дополнительные сведения см. в разделе [оператор __alignof](../cpp/alignof-operator.md) и [выровнять](../cpp/align-cpp.md). C++ Standard не определяет поведение упаковки для выравнивания по границам, меньшим, чем компилятора по умолчанию для целевой платформы, поэтому вам по-прежнему нужно использовать Microsoft #pragma [пакет](../preprocessor/pack.md) в этом случае.

Используйте [класс aligned_storage](../standard-library/aligned-storage-class.md) для выделения памяти структур данных с помощью настраиваемых выравниваний. [Класс aligned_union](../standard-library/aligned-union-class.md) предназначен для указания выравнивания для объединения с нетривиальные конструкторы или деструкторы.

## <a name="about-alignment"></a>О выравнивании

Выравнивание представляет собой свойство адреса памяти, выражаемое как числовой адрес по модулю степени 2. Например адрес 0x0001103F по модулю 4 равен 3. Что говорят, что адрес выровнен как 4n + 3, где 4 указывает выбранную степень 2. Выравнивание адреса зависит от выбранной степени 2. Тот же адрес по модулю 8 равен 7. Говорят, что адрес выровнен по X, если его выравнивание — Xn+0.

ЦП выполняют инструкции, которые работают с данными, хранимыми в памяти. Данные идентифицируются своими адресами в памяти. Одиночный элемент данных также имеет размер. Мы называем datum *выровнены естественным образом* если его адрес выровнен до размера. Он называется *невыровненных* в противном случае. Например datum с плавающей запятой размером 8 байт, выровнен естественным образом в том случае, если адрес, используемый для его идентификации 8-байтового выравнивания.

## <a name="compiler-handling-of-data-alignment"></a>Обработка компилятора выравнивание данных

Компиляторы попытаться сделать распределений данных способом, который предотвращает выравнивание данных.

Для простых типов данных компилятор назначает адреса, которые кратны размеру в байтах для типа данных. Например, компилятор назначает адреса переменным типа `long` , кратные 4 задание 2 бита адреса нижней до нуля.

Кроме того, компилятор дополняет структуры так, естественным образом выравнивает каждый элемент структуры. Рассмотрим структуру `struct x_` в следующем примере кода:

```cpp
struct x_
{
   char a;     // 1 byte
   int b;      // 4 bytes
   short c;    // 2 bytes
   char d;     // 1 byte
} MyStruct;
```

Компилятор дополняет эту структуру для принудительного выравнивания естественным образом.

В следующем примере кода показано, как компилятор размещает дополненную структуру в памяти:

```cpp
// Shows the actual memory layout
struct x_
{
   char a;            // 1 byte
   char _pad0[3];     // padding to put 'b' on 4-byte boundary
   int b;            // 4 bytes
   short c;          // 2 bytes
   char d;           // 1 byte
   char _pad1[1];    // padding to make sizeof(x_) multiple of 4
}
```

1. Оба объявления возвращают `sizeof(struct x_)` 12 байтам.

1. Второе объявление включает два дополняющих элемента:

1. `char _pad0[3]` Чтобы выровнять `int b` член по 4-байтовой границе

1. `char _pad1[1]` для выравнивания элементов массива структуры `struct _x bar[3];`

1. Дополнение выравнивает элементы `bar[3]` способом, который разрешается естественный доступ.

В следующем коде показано в примере `bar[3]` макета массива:

```Output
adr offset   element
------   -------
0x0000   char a;         // bar[0]
0x0001   char pad0[3];
0x0004   int b;
0x0008   short c;
0x000a   char d;
0x000b   char _pad1[1];

0x000c   char a;         // bar[1]
0x000d   char _pad0[3];
0x0010   int b;
0x0014   short c;
0x0016   char d;
0x0017   char _pad1[1];

0x0018   char a;         // bar[2]
0x0019   char _pad0[3];
0x001c   int b;
0x0020   short c;
0x0022   char d;
0x0023   char _pad1[1];
```

## <a name="see-also"></a>См. также

[Выравнивание структуры данных](https://en.wikipedia.org/wiki/Data_structure_alignment)
