---
title: Ссылки (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- objects [C++], referencing
- references [C++]
- references, to pointers
- declarations, references
- references, declaring
- referencing objects, declarator syntax
ms.assetid: 68156f7f-97a0-4b66-b26d-b25ade5e3bd8
ms.openlocfilehash: 2353f0861f0f249416d0bb84a7a951b1cb6d64bc
ms.sourcegitcommit: a6d63c07ab9ec251c48bc003ab2933cf01263f19
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/05/2019
ms.locfileid: "74857337"
---
# <a name="references-c"></a>Ссылки (C++)

В ссылке, как и в указателе, хранится адрес объекта, расположенного в другой области памяти. В отличие от указателя, после инициализации ссылку нельзя перенаправить на другой объект или присвоить ей нулевое значение. Существует два вида ссылок: ссылки lvalue, которые ссылаются на именованную переменную и ссылки rvalue, которые ссылаются на [временный объект](../cpp/temporary-objects.md). Оператор & указывает на ссылку lvalue, а & оператор & указывает на ссылку rvalue или универсальную ссылку (rvalue или lvalue) в зависимости от контекста.

Ссылки могут объявляться с помощью следующего синтаксиса.

> \[*storage-class-specifiers*] \[*cv-qualifiers*] *type-specifiers* \[*ms-modifier*] *declarator* \[ **=** *expression*] **;**

Можно использовать любой допустимый декларатор, задающий ссылку. Следующий упрощенный синтаксис применяется всегда, кроме случаев, когда ссылка является ссылкой на функцию или тип массива.

> \[*описатели класса хранения*] \[*ОПС-квалификаторы*] *описатели типа* \[ **&** или **&&** ] \[" *ОПС-квалификаторы*"] *identifier* \[ **=** *выражение*] **;**

Ссылки объявляются с использованием следующей последовательности.

1. Спецификаторы объявления:

   - Необязательный спецификатор класса хранения.

   - Необязательные квалификаторы **const** и/или **volatile** .

   - Спецификатор типа: имя типа.

1. Декларатор:

   - Необязательный модификатор, используемый в системах Microsoft. Дополнительные сведения см. в разделе [модификаторы, зависящие от Майкрософт](../cpp/microsoft-specific-modifiers.md).

   - Оператор **&** или **&&** .

   - Необязательные **константы const** и (или) **volatile** квалификаторов.

   - Идентификатор.

1. Необязательный инициализатор.

Более сложные формы декларатора для указателей на массивы и функции также применяются к ссылкам на массивы и функции. Дополнительные сведения см. в разделе [указатели](../cpp/pointers-cpp.md).

Несколько деклараторов и инициализаторов могут отображаться в разделенном запятыми списке после отдельного спецификатора объявления. Например:

```cpp
int &i;
int &i, &j;
```

Ссылки, указатели и объекты могут быть объявлены вместе.

```cpp
int &ref, *ptr, k;
```

Ссылка содержит адрес объекта, однако с синтаксической точки зрения ведет себя как объект.

В следующей программе обратите внимание, что имя объекта, `s` и ссылка на объект, `SRef`, могут использоваться идентично в следующих программах.

## <a name="example"></a>Пример

```cpp
// references.cpp
#include <stdio.h>
struct S {
   short i;
};

int main() {
   S  s;   // Declare the object.
   S& SRef = s;   // Declare the reference.
   s.i = 3;

   printf_s("%d\n", s.i);
   printf_s("%d\n", SRef.i);

   SRef.i = 4;
   printf_s("%d\n", s.i);
   printf_s("%d\n", SRef.i);
}
```

```Output
3
3
4
4
```

## <a name="see-also"></a>См. также:

[Аргументы функции ссылочного типа](../cpp/reference-type-function-arguments.md)<br/>
[Возвращаемые значения функции ссылочного типа](../cpp/reference-type-function-returns.md)<br/>
[Ссылки на указатели](../cpp/references-to-pointers.md)
