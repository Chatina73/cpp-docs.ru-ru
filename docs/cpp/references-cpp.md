---
description: 'Дополнительные сведения: ссылки (C++)'
title: Ссылки (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- objects [C++], referencing
- references [C++]
- references, to pointers
- declarations, references
- references, declaring
- referencing objects, declarator syntax
ms.assetid: 68156f7f-97a0-4b66-b26d-b25ade5e3bd8
ms.openlocfilehash: 1f49e089d8992a32f30e1a384d5f0c36fa327c0f
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97250053"
---
# <a name="references-c"></a>Ссылки (C++)

В ссылке, как и в указателе, хранится адрес объекта, расположенного в другой области памяти. В отличие от указателя, после инициализации ссылку нельзя перенаправить на другой объект или присвоить ей нулевое значение. Существует два вида ссылок: ссылки lvalue, которые ссылаются на именованную переменную и ссылки rvalue, которые ссылаются на [временный объект](../cpp/temporary-objects.md). Оператор & указывает на ссылку lvalue, а оператор && указывает либо на ссылку rvalue, либо на универсальную ссылку (rvalue или lvalue) в зависимости от контекста.

Ссылки могут объявляться с помощью следующего синтаксиса.

> \[*спецификаторы класса хранения*] \[ *ОПС-квалификаторы*] выражения *-описатели типа* \[ *MS-Modifiers*] выражение *декларатора* \[ **=** ]**;**

Можно использовать любой допустимый декларатор, задающий ссылку. Следующий упрощенный синтаксис применяется всегда, кроме случаев, когда ссылка является ссылкой на функцию или тип массива.

> \[*спецификаторы класса хранения*] \[ *ОПС-квалификаторы*] *описатели типа* \[ **&** или **&&** ] \[ *ОПС-квалификаторы*]  \[ **=** *выражение* идентификатора]**;**

Ссылки объявляются с использованием следующей последовательности.

1. Спецификаторы объявления:

   - Необязательный спецификатор класса хранения.

   - Необязательные **`const`** и/или **`volatile`** квалификаторы.

   - Спецификатор типа: имя типа.

1. Декларатор:

   - Необязательный модификатор, используемый в системах Microsoft. Дополнительные сведения см. в разделе [модификаторы, зависящие от Майкрософт](../cpp/microsoft-specific-modifiers.md).

   - **&** Оператор или **&&** оператор.

   - Необязательный **`const`** и/или **`volatile`** квалификаторов.

   - Идентификатор.

1. Необязательный инициализатор.

Более сложные формы декларатора для указателей на массивы и функции также применяются к ссылкам на массивы и функции. Дополнительные сведения см. в разделе [указатели](../cpp/pointers-cpp.md).

Несколько деклараторов и инициализаторов могут отображаться в разделенном запятыми списке после отдельного спецификатора объявления. Пример:

```cpp
int &i;
int &i, &j;
```

Ссылки, указатели и объекты могут быть объявлены вместе.

```cpp
int &ref, *ptr, k;
```

Ссылка содержит адрес объекта, однако с синтаксической точки зрения ведет себя как объект.

В следующей программе обратите внимание, что имя объекта, `s` и ссылка на объект, `SRef`, могут использоваться идентично в следующих программах.

## <a name="example"></a>Пример

```cpp
// references.cpp
#include <stdio.h>
struct S {
   short i;
};

int main() {
   S  s;   // Declare the object.
   S& SRef = s;   // Declare the reference.
   s.i = 3;

   printf_s("%d\n", s.i);
   printf_s("%d\n", SRef.i);

   SRef.i = 4;
   printf_s("%d\n", s.i);
   printf_s("%d\n", SRef.i);
}
```

```Output
3
3
4
4
```

## <a name="see-also"></a>См. также раздел

[Аргументы функции ссылочного типа](../cpp/reference-type-function-arguments.md)<br/>
[Функции ссылочного типа возвращают](../cpp/reference-type-function-returns.md)<br/>
[Ссылки на указатели](../cpp/references-to-pointers.md)
