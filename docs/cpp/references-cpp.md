---
title: Ссылки (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- objects [C++], referencing
- references [C++]
- references, to pointers
- declarations, references
- references, declaring
- referencing objects, declarator syntax
ms.assetid: 68156f7f-97a0-4b66-b26d-b25ade5e3bd8
ms.openlocfilehash: 8a771b8bfc067966c3c054700538ebf180a5eb23
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87233617"
---
# <a name="references-c"></a>Ссылки (C++)

В ссылке, как и в указателе, хранится адрес объекта, расположенного в другой области памяти. В отличие от указателя, после инициализации ссылку нельзя перенаправить на другой объект или присвоить ей нулевое значение. Существует два вида ссылок: ссылки lvalue, которые ссылаются на именованную переменную и ссылки rvalue, которые ссылаются на [временный объект](../cpp/temporary-objects.md). Оператор & указывает на ссылку lvalue, а оператор && указывает либо на ссылку rvalue, либо на универсальную ссылку (rvalue или lvalue) в зависимости от контекста.

Ссылки могут объявляться с помощью следующего синтаксиса.

> \[*спецификаторы класса хранения*] \[ *ОПС-квалификаторы*] выражения *-описатели типа* \[ *MS-Modifiers*] выражение *декларатора* \[ **=** *expression*]**;**

Можно использовать любой допустимый декларатор, задающий ссылку. Следующий упрощенный синтаксис применяется всегда, кроме случаев, когда ссылка является ссылкой на функцию или тип массива.

> \[*спецификаторы класса хранения*] \[ *ОПС-квалификаторы*] *описатели типа* \[ **&** или **&&** ] \[ *ОПС-квалификаторы*] *identifier* \[ **=** *выражение*идентификатора]**;**

Ссылки объявляются с использованием следующей последовательности.

1. Спецификаторы объявления:

   - Необязательный спецификатор класса хранения.

   - Необязательные **`const`** и/или **`volatile`** квалификаторы.

   - Спецификатор типа: имя типа.

1. Декларатор:

   - Необязательный модификатор, используемый в системах Microsoft. Дополнительные сведения см. в разделе [модификаторы, зависящие от Майкрософт](../cpp/microsoft-specific-modifiers.md).

   - **&** Оператор или **&&** оператор.

   - Необязательный **`const`** и/или **`volatile`** квалификаторов.

   - Идентификатор.

1. Необязательный инициализатор.

Более сложные формы декларатора для указателей на массивы и функции также применяются к ссылкам на массивы и функции. Дополнительные сведения см. в разделе [указатели](../cpp/pointers-cpp.md).

Несколько деклараторов и инициализаторов могут отображаться в разделенном запятыми списке после отдельного спецификатора объявления. Например:

```cpp
int &i;
int &i, &j;
```

Ссылки, указатели и объекты могут быть объявлены вместе.

```cpp
int &ref, *ptr, k;
```

Ссылка содержит адрес объекта, однако с синтаксической точки зрения ведет себя как объект.

В следующей программе обратите внимание, что имя объекта, `s` и ссылка на объект, `SRef`, могут использоваться идентично в следующих программах.

## <a name="example"></a>Пример

```cpp
// references.cpp
#include <stdio.h>
struct S {
   short i;
};

int main() {
   S  s;   // Declare the object.
   S& SRef = s;   // Declare the reference.
   s.i = 3;

   printf_s("%d\n", s.i);
   printf_s("%d\n", SRef.i);

   SRef.i = 4;
   printf_s("%d\n", s.i);
   printf_s("%d\n", SRef.i);
}
```

```Output
3
3
4
4
```

## <a name="see-also"></a>См. также раздел

[Аргументы функции ссылочного типа](../cpp/reference-type-function-arguments.md)<br/>
[Функции ссылочного типа возвращают](../cpp/reference-type-function-returns.md)<br/>
[Ссылки на указатели](../cpp/references-to-pointers.md)
