---
title: 'Условный &quest; оператор: :'
ms.date: 11/04/2016
f1_keywords:
- '?:'
- '?'
helpviewer_keywords:
- conditional operators [C++]
- '? : operator'
ms.assetid: 88643ee8-7100-4f86-880a-705ec22b6271
ms.openlocfilehash: 4ba4c80d40450fd5975b047a1a4fca63146c5773
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81337264"
---
# <a name="conditional-operator-quest-"></a>Условный &quest; оператор: :

## <a name="syntax"></a>Синтаксис

```
expression ? expression : expression
```

## <a name="remarks"></a>Remarks

Условный оператор **(. . .)** является ternary оператора (он принимает три operands). Условный оператор работает следующим образом.

- Первая операнд неявно преобразуется в **bool.** Он вычисляется, и все побочные эффекты завершаются перед продолжением.

- Если первая операнд оценивается как **истинная** (1), то оценивается вторая операнд.

- Если первая операнд оценивается как **ложная** (0), то оценивается третья операнд.

Результатом условного оператора является оцененного операнда — второго или третьего. В условном выражении оценивается только один из последних двух операндов.

Условные выражения имеют ассоциативность справа налево. Первый операнд должен иметь целочисленный тип или тип указателя. Следующие правила применяются ко второму и третьему операндам.

- Если оба операнда имеют один и тот же тип, результат имеет тот же тип.

- Если оба оперы имеют арифметические или перечисленные типы, обычные арифметические преобразования (покрытые [Стандартными Преобразованиями)](standard-conversions.md)выполняются для преобразования их в общий тип.

- Если оба операнда имеют тип указателя или один операнд относится к типу указателя, а другой является выражением константы со значением 0, преобразования указателя выполняются с целью преобразования их к общему типу.

- Если оба операнда имеют ссылочные типы, для преобразования их в общий тип используются ссылочные преобразования.

- Если оба операнда имеют тип void, общий тип также имеет тип void.

- Если оба операнда относятся к одному определяемому пользователем типу, общий тип также относится к этому типу.

- Если операнды относятся к разным типам и по крайней мере один из операндов относится к определяемому пользователем типу, для определения общего типа используются правила языка (см. предупреждение ниже).

Какие-либо сочетания второго и третьего операндов, отсутствующие в предыдущем списке, недопустимы. Тип результата — это общий тип и l-значение, если и второй, и третий операнды имеют один и тот же тип и представляют собой l-значения.

> [!WARNING]
> Если типы второго и третьего операндов не идентичны, вызываются правила преобразования сложных типов в соответствии со стандартом C++. Эти преобразования могут привести к непредвиденному поведению, включая создание и удаление временных объектов. По этой причине мы настоятельно рекомендуем вам (1) либо избегать использования определяемых пользователем типов в качестве операндов в условных операторах, (2) либо, если определяемые пользователем типы все же используются, явно приводить каждый операнд к общему типу.

## <a name="example"></a>Пример

```cpp
// expre_Expressions_with_the_Conditional_Operator.cpp
// compile with: /EHsc
// Demonstrate conditional operator
#include <iostream>
using namespace std;
int main() {
   int i = 1, j = 2;
   cout << ( i > j ? i : j ) << " is greater." << endl;
}
```

## <a name="see-also"></a>См. также раздел

[Операторы C++, приоритет и ассоциативность](../cpp/cpp-built-in-operators-precedence-and-associativity.md)<br/>
[Оператор условного выражения](../c-language/conditional-expression-operator.md)
