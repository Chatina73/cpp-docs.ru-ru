---
title: Использование dllimport и dllexport в классах C++
ms.date: 11/04/2016
helpviewer_keywords:
- exporting classes [C++]
- declarations [C++], class
- exportable classes [C++]
- classes [C++], declaring
- classes [C++], exportable and inheritance
- inheritance [C++], exportable classes [C++]
- dllimport attribute [C++], classes
- declaring classes [C++]
- dllexport attribute [C++]
- dllexport attribute [C++], classes [C++]
ms.assetid: 8d7d1303-b9e9-47ca-96cc-67bf444a08a9
ms.openlocfilehash: c0a2c96a37f58c956976980beafd5ecbed4d1318
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365116"
---
# <a name="using-dllimport-and-dllexport-in-c-classes"></a>Использование dllimport и dllexport в классах C++

**Microsoft Специфический**

Вы можете объявить классы СЗ с атрибутом **dllimport** или **dllexport.** Эти формы подразумевают, что импортирован или экспортирован весь класс. Классы, которые можно экспортировать таким образом, называются экспортируемыми классами.

В следующем примере определяется экспортируемый класс. Экспортируются все его функции-члены и статические данные.

```cpp
#define DllExport   __declspec( dllexport )

class DllExport C {
   int i;
   virtual int func( void ) { return 1; }
};
```

Обратите внимание, что явное использование атрибутов **dllimport** и **dllexport** на членах экспортируемого класса запрещено.

## <a name="dllexport-classes"></a><a name="_pluslang_using_dllimport_and_dllexport_in_c2b2bdllexportclasses"></a>классы dllexport

Когда вы объявляете класс **dllexport,** все его функции члена и статические члены данных экспортируются. Необходимо предоставить определения всех таких членов в одной программе. В противном случае возникает ошибка компоновщика. Единственным исключением из этого правила являются чистые виртуальные функции, для которых не требуется предоставлять явные определения. Однако, поскольку деструктор абстрактного класса всегда вызывается деструктором базового класса, чистые виртуальные деструкторы должны всегда предоставлять определение. Обратите внимание, что те же правила применяются и к неэкспортируемым классам.

При экспорте данных типа класса или функций, которые возвращают классы, не забудьте экспортировать класс.

## <a name="dllimport-classes"></a><a name="_pluslang_dllexport_classesdllexportclasses"></a>dllimport Классы

Когда вы объявляете класс **dllimport,** все его функции члена и статические члены данных импортируются. В отличие от поведения **dllimport** и **dllexport** по типам некласса, члены статических данных не могут указать определение в той же программе, в которой определяется класс **dllimport.**

## <a name="inheritance-and-exportable-classes"></a><a name="_pluslang_using_dllimport_and_dllexport_in_c2b2binheritanceandexportableclasses"></a>Наследственные и экспортируемые классы

Все базовые классы экспортируемого класса должны быть экспортируемыми. В противном случае создается предупреждение компилятора. Кроме того, все доступные члены, которые также являются классами, должны быть доступными для экспорта. Это правило позволяет классу **dllexport** наследовать от класса **dllimport,** а класс **dllimport** наследовать от класса **dllexport** (хотя последний не рекомендуется). Как правило, все, что доступно клиенту библиотеки DLL (в соответствии с правилами доступа C++), должно быть частью экспортируемого интерфейса. Сюда входят закрытые данные-члены, на которые ссылаются встраиваемые функции.

## <a name="selective-member-importexport"></a><a name="_pluslang_using_dllimport_and_dllexport_in_c2b2bselectivememberimportexport"></a>Выборочный импорт/экспорт членов

Поскольку функции членов и статические данные в классе неявно имеют внешнюю связь, их можно объявить атрибутом **dllimport** или **dllexport,** если только весь класс не экспортируется. Если весь класс импортируется или экспортируется, явное декларирование функций членов и данных как **dllimport** или **dllexport** запрещено. Если вы объявляете статического участника данных в определении класса **dllexport,** определение должно происходить где-то в рамках той же программы (как при внешней связи некласса).

Аналогичным образом, вы можете объявить функции участника с атрибутами **dllimport** или **dllexport.** В этом случае вы должны предоставить определение **dllexport** где-то в рамках той же программы.

Обратите внимание на несколько важных аспектов выборочного импорта и экспорта членов.

- Выборочный импорт и экспорт членов рекомендуется использовать для предоставления версии экспортированного интерфейса класса, который является более ограничивающим, то есть для которого можно разработать библиотеку DLL, предоставляющую меньше открытых и закрытых компонентов, чем разрешил бы язык. Кроме того, это может пригодиться для точной настройки экспортируемого интерфейса: если известно, что клиент по определению не может получить доступ к некоторым закрытым данным, не требуется экспортировать целый класс.

- При экспорте одной виртуальной функции в классе необходимо экспортировать все функции или хотя бы предоставить версии, которые клиент может использовать напрямую.

- Если имеется класс, в котором используется выборочный импорт и экспорт членов с виртуальными функциями, функции должны быть расположены в экспортируемом интерфейсе или определены встроенным образом (видимым клиенту).

- Если вы определяете участника как **dllexport,** но не включаете его в определение класса, создается ошибка компилятора. Необходимо определить член в заголовке класса.

- Хотя определение членов класса как **dllimport** или **dllexport** разрешено, вы не можете переопределить интерфейс, указанный в определении класса.

- Если вы определяете функцию участника в месте, не являющееся телом определения класса, в котором вы ее декларировали, создается предупреждение, если функция определяется как **dllexport** или **dllimport** (если это определение отличается от указанного в декларации класса).

**END Microsoft Специфический**

## <a name="see-also"></a>См. также раздел

[dllexport, dllimport](../cpp/dllexport-dllimport.md)
