---
title: Интеллектуальные указатели (современный C++)
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: 909ef870-904c-49b6-b8cd-e9d0b7dc9435
ms.openlocfilehash: 0e93ce033649f5654595ae23a5f10da347879718
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365540"
---
# <a name="smart-pointers-modern-c"></a>Интеллектуальные указатели (современный C++)

В современном программировании СЗ Стандартная библиотека включает в себя *интеллектуальные указатели,* которые используются для обеспечения того, чтобы программы были свободны от памяти и утечки ресурсов и были безопасными для исключения.

## <a name="uses-for-smart-pointers"></a>Использование интеллектуальных указателей

Интеллектуальные указатели определяются в пространстве `std` имен в файле [ \<заголовка памяти>.](../standard-library/memory.md) Они имеют решающее значение для [RAII](objects-own-resources-raii.md) или *приобретение ресурсов является идиома программирования инициализации.* Главная задача этой идиомы — обеспечить, чтобы одновременно с получением ресурса производилась инициализация объекта, чтобы все ресурсы для объекта создавались и подготавливались в одной строке кода. На практике основным принципом RAII является предоставление владения любым ресурсом в куче (например, динамически выделенной памятью или дескрипторами системных объектов) объекту, выделенному стеком, деструктор которого содержит код для удаления или освобождения ресурса, а также весь связанный код очистки.

В большинстве случаев при инициализации необработанного указателя или дескриптора ресурса для указания на фактический ресурс следует сразу же передать указатель в интеллектуальный указатель. В современном C++ необработанные указатели используются только в небольших блоках кода с ограниченной областью, циклах или вспомогательных функциях, когда важна производительность и вероятность проблем с владением низкая.

В следующем примере сравниваются объявления необработанного и интеллектуального указателей.

[!code-cpp[smart_pointers_intro#1](codesnippet/CPP/smart-pointers-modern-cpp_1.cpp)]

Как показано в примере, интеллектуальный указатель — это шаблон класса, который объявляется в стеке и инициализируется с помощью необработанного указателя, указывающего на размещенный в куче объект. После инициализации интеллектуальный указатель становится владельцем необработанного указателя. Это означает, что интеллектуальный указатель отвечает за удаление памяти, заданной необработанным указателем. Деструктор интеллектуального указателя содержит вызов для удаления, и поскольку интеллектуальный указатель объявлен в стеке, его деструктор вызывается, как только интеллектуальный указатель оказывается вне области, даже если исключение создается где-либо в другой части стека.

Доступ к инкапсулированному указателю осуществляется с помощью знакомых операторов указателя `->` и `*`, которые класс интеллектуального указателя перегружает для возврата инкапсулированного необработанного указателя.

Этот интеллектуальный указатель C++ напоминает создание объектов в таких языках, как C#: вы создаете объект, а система удаляет его в правильный момент. Отличие заключается в том, что отсутствует отдельный сборщик мусора, работающий в фоновом режиме; память управляется через стандартные правила области C++, чтобы среда выполнения функционировала быстрее и эффективнее.

> [!IMPORTANT]
> Всегда создавайте интеллектуальные указатели в отдельной строке кода; ни в коем случае не делайте это в списке параметров, чтобы не произошла небольшая утечка ресурсов, связанная с определенными правилами выделения памяти спискам параметров.

Ниже приведен пример, `unique_ptr` как интеллектуальный тип указателя из Стандартной библиотеки СЗ может быть использован для инкапсулировать указатель на большой объект.

[!code-cpp[smart_pointers_intro#2](codesnippet/CPP/smart-pointers-modern-cpp_2.cpp)]

В этом примере показаны следующие важные шаги, необходимые для использования интеллектуальных указателей.

1. Объявите интеллектуальный указатель как автоматическую (локальную) переменную. (Не используйте **new** новое `malloc` или выражение на смарт-указатель себя.)

1. В параметре типа укажите тип, на который указывает инкапсулированный указатель.

1. Передайте необработанный указатель **на новый**объект-ed в смарт-конструктор указателя. (Некоторые служебные функции или конструкторы интеллектуальных указателей делают это автоматически.)

1. Используйте перегруженные операторы `->` и `*` для доступа к объекту.

1. Интеллектуальный указатель удаляет объект автоматически.

Интеллектуальные указатели разработаны для обеспечения максимальной эффективности в отношении памяти и производительности. Например, единственный элемент данных в `unique_ptr` — это инкапсулированный указатель. Это означает, что размер `unique_ptr` точно такой же, как и у указателя — 4 или 8 байтов. Доступ к инкапсулированному указателю с помощью смарт-указателя перегруженных и -> операторы не значительно медленнее, чем доступ к необработанным указателям напрямую.

Умные указатели имеют свои собственные функции членов, которые доступны с помощью "точка" обозначения. Например, некоторые интеллектуальные указатели Стандартной библиотеки сот-кватерами смс-системы сотовой установки имеют функцию сбросить, которая выпускает право собственности на указатель. Это полезно, когда нужно освободить память, принадлежащую интеллектуальному указателю, не дожидаясь, пока интеллектуальный указатель окажется вне области, как показано в следующем примере.

[!code-cpp[smart_pointers_intro#3](codesnippet/CPP/smart-pointers-modern-cpp_3.cpp)]

Интеллектуальные указатели обычно предоставляют способ прямого доступа к необработанному указателю. Смарт-указатели Стандартной `get` библиотеки сум-библиотеки имеют функцию члена для этой цели и `CComPtr` имеют члена общедоступного `p` класса. Предоставляя прямой доступ к базовому указателю, можно использовать интеллектуальный указатель для управления памятью в своем коде и по-прежнему передавать необработанный указатель коду, который не поддерживает интеллектуальные указатели.

[!code-cpp[smart_pointers_intro#4](codesnippet/CPP/smart-pointers-modern-cpp_4.cpp)]

## <a name="kinds-of-smart-pointers"></a>Виды интеллектуальных указателей

В следующем разделе приведены различные виды интеллектуальных указателей, доступные в среде программирования Windows, и приводится описание их использования.

### <a name="c-standard-library-smart-pointers"></a>Смарт-указатели Стандартной библиотеки СЗ

Используйте эти интеллектуальные указатели как основной вариант для инкапсуляции указателей на простые старые объекты C++ (POCO).

- `unique_ptr`<br/>
   Обеспечивает, чтобы у базового указателя был только один владелец. Используйте как вариант по умолчанию для POCO, кроме случая, когда вы точно знаете, что требуется `shared_ptr`. Может быть передан новому владельцу, но не может быть скопирован или сделан общим. Заменяет `auto_ptr`, использовать который не рекомендуется. Сравните с `boost::scoped_ptr`. `unique_ptr`мала и эффективна; размер один указатель и поддерживает ссылки на rvalue для быстрой вставки и поиска из коллекций стандартной библиотеки. Файл заголовка: `<memory>`. Для получения дополнительной информации [см. Как: Создать и использовать unique_ptr инстанций](how-to-create-and-use-unique-ptr-instances.md) и [unique_ptr класса](../standard-library/unique-ptr-class.md).

- `shared_ptr`<br/>
   Интеллектуальный указатель с подсчитанными ссылками. Используйте, когда необходимо присвоить один необработанный указатель нескольким владельцам, например, когда копия указателя возвращается из контейнера, но требуется сохранить оригинал. Необработанный указатель не будет удален до тех пор, пока все владельцы `shared_ptr` не выйдут из области или не откажутся от владения. Размер — 2 указателя; один — для объекта и второй — для блока общего элемента управления, который содержит счетчик ссылок. Файл заголовка: `<memory>`. Для получения дополнительной информации см [shared_ptr](../standard-library/shared-ptr-class.md) [shared_ptr.](how-to-create-and-use-shared-ptr-instances.md)

- `weak_ptr`<br/>
    Интеллектуальный указатель для особых случаев использования с `shared_ptr`. `weak_ptr` предоставляет доступ к объекту, который принадлежит одному или нескольким экземплярам `shared_ptr`, но не участвует в подсчете ссылок. Используйте, когда требуется отслеживать объект, но не требуется, чтобы он оставался в активном состоянии. Требуется в некоторых случаях для разрыва циклических ссылок между экземплярами `shared_ptr`. Файл заголовка: `<memory>`. Для получения дополнительной информации [см. Как: Создать и использовать weak_ptr инстанций](how-to-create-and-use-weak-ptr-instances.md) и [weak_ptr класса](../standard-library/weak-ptr-class.md).

### <a name="smart-pointers-for-com-objects-classic-windows-programming"></a>Интеллектуальные указатели для объектов COM (классическое программирование Windows)

При работе с COM-объектами создайте оболочку для указателей интерфейса в соответствующем типе интеллектуальных указателей. Библиотека шаблонных классов (ATL) определяет несколько интеллектуальных указателей для различных целей. Можно также использовать тип интеллектуального указателя `_com_ptr_t`, который компилятор использует при создании классов оболочки из файлов с расширением TLB. Это лучший вариант, если вы не хотите включать файлы заголовков ATL.

[Класс CComPtr](../atl/reference/ccomptr-class.md)<br/>
Используйте, если невозможно использовать ATL. Выполняет подсчет ссылок с помощью методов `AddRef` и `Release`. Для получения дополнительной [информации, см.](how-to-create-and-use-ccomptr-and-ccomqiptr-instances.md)

[Класс CCom-IPtr](../atl/reference/ccomqiptr-class.md)<br/>
Похож на `CComPtr`, но также предоставляет упрощенный синтаксис для вызова `QueryInterface` COM-объекта. Для получения дополнительной [информации, см.](how-to-create-and-use-ccomptr-and-ccomqiptr-instances.md)

[Класс CComHeapPtr](../atl/reference/ccomheapptr-class.md)<br/>
Интеллектуальный указатель на объекты, которые используют `CoTaskMemFree` для освобождения памяти.

[Класс CComGITPtr](../atl/reference/ccomgitptr-class.md)<br/>
Интеллектуальный указатель для интерфейсов, получаемых из глобальной таблицы интерфейсов (GIT).

[класс _com_ptr_t](com-ptr-t-class.md)<br/>
По функциональности аналогичен `CComQIPtr`, но не зависит от заголовков ATL.

### <a name="atl-smart-pointers-for-poco-objects"></a>Смарт-указатели ATL для объектов POCO

В дополнение к интеллектуальным указателям для объектов COM, ATL также определяет интеллектуальные указатели и коллекции интеллектуальных указателей для простых старых объектов СЗ (POCO). В классическом программировании Windows эти типы являются полезными альтернативами коллекциям Стандартных библиотек, особенно когда портативность кода не требуется или когда вы не хотите смешивать модели программирования Стандартной библиотеки и ATL.

[Класс CAutoPtr](../atl/reference/cautoptr-class.md)<br/>
Интеллектуальный указатель, принудительно реализующий уникальное владение путем переноса владения на копию. Сравним с нерекомендуемым классом `std::auto_ptr`.

[Класс CHeapPtr](../atl/reference/cheapptr-class.md)<br/>
Интеллектуальная указка для объектов, которые выделяются с помощью функции C [malloc.](../c-runtime-library/reference/malloc.md)

[Класс CAutoVectorPtr](../atl/reference/cautovectorptr-class.md)<br/>
Интеллектуальный указатель для массивов, память для которых выделяется с помощью `new[]`.

[Класс CAutoPtrArray](../atl/reference/cautoptrarray-class.md)<br/>
Класс, инкапсулирующий массив элементов `CAutoPtr`.

[Класс CAutoPtrList](../atl/reference/cautoptrlist-class.md)<br/>
Класс, инкапсулирующий методы для управления списком узлов `CAutoPtr`.

## <a name="see-also"></a>См. также раздел

[Указатели](pointers-cpp.md)<br/>
[Языковая справка к СЗ](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека СЗ](../standard-library/cpp-standard-library-reference.md)
