---
title: friend (C++)
ms.date: 07/15/2019
f1_keywords:
- friend_cpp
helpviewer_keywords:
- member access, from friend functions
- friend classes [C++]
- friend keyword [C++]
ms.assetid: 8fe9ee55-d56f-40cd-9075-d9fb1375aff4
ms.openlocfilehash: 20116674feffaa5b4bbddf707dd3a4d0c1d9ad98
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81364446"
---
# <a name="friend-c"></a>friend (C++)

В некоторых случаях удобнее предоставить члену уровня доступ к функциям, которые не являются членами класса или всем членам в отдельном классе. Только реализатор класса может объявить, что является для него дружественным элементом. Функция или класс не могут объявить себя дружественным элементом для любого класса. В определении класса используйте ключевое слово **друга** и имя функции, не являющейся членом, или другого класса, чтобы предоставить ему доступ к частным и защищенным членам вашего класса. В определении шаблона параметр типа может быть объявлен в качестве друга.

## <a name="syntax"></a>Синтаксис

```
class friend F
friend F;
```

## <a name="friend-declarations"></a>Объявления дружественных элементов

При объявлении дружественной функции, которая не была объявлена ранее, эта функция экспортируется во включающую область вне класса.

Функции, заявленные в заявлении друга, рассматриваются так, как если бы они были объявлены с помощью ключевого слова **extern.** Для получения дополнительной информации, [см.](extern-cpp.md)

Хотя функции с глобальной областью действия могут быть объявлены как дружественные до объявления своих прототипов, функции-члены не могут быть объявлены как дружественные функции до полного объявления их класса. В следующем коде показано, почему при этом возникает ошибка.

```cpp
class ForwardDeclared;   // Class name is known.
class HasFriends
{
    friend int ForwardDeclared::IsAFriend();   // C2039 error expected
};
```

В предыдущем примере в области действия вводится имя класса `ForwardDeclared`, но полное объявление — в частности, часть, в которой объявляется функция `IsAFriend`, — отсутствует. Таким образом, объявление `HasFriends` **друга** в классе генерирует ошибку.

Начиная с C-11, существуют две формы заявлений о друзьях для класса:

```cpp
friend class F;
friend F;
```

Первая форма вводит новый класс F, если ни один существующий класс под этим именем не был найден во внутреннем пространстве имен. **СЗ11**: Вторая форма не вводит новый класс; он может использоваться, когда класс уже объявлен, и он должен использоваться при объявлении параметра типа шаблона или typedef как друг.

Используйте, `class friend F` когда упомянутый тип еще не объявлен:

```cpp
namespace NS
{
    class M
    {
        class friend F;  // Introduces F but doesn't define it
    };
}
```

```cpp
namespace NS
{
    class M
    {
        friend F; // error C2433: 'NS::F': 'friend' not permitted on data declarations
    };
}
```

В следующем примере относится к классу, `friend F` `F` который объявлен вне сферы ДЕЙСТВИЯ NS.

```cpp
class F {};
namespace NS
{
    class M
    {
        friend F;  // OK
    };
}
```

Используйте `friend F` для объявления параметра шаблона в качестве друга:

```cpp
template <typename T>
class my_class
{
    friend T;
    //...
};
```

Используйте `friend F` для объявления typedef в качестве друга:

```cpp
class Foo {};
typedef Foo F;

class G
{
    friend F; // OK
    friend class F // Error C2371 -- redefinition
};
```

Чтобы объявить два класса как дружественные друг другу, весь второй класс должен быть указан как дружественный для первого класса. Причина такого ограничения заключается в том, что компилятор получает достаточные сведения для объявления отдельных дружественных функций только в момент объявления второго класса.

> [!NOTE]
> Хотя весь второй класс должен быть дружественным для первого класса, можно выбрать, какие функции первого класса будут дружественными для второго класса.

## <a name="friend-functions"></a>дружественные функции

Функция **друга** — это функция, которая не является членом класса, но имеет доступ к частным и защищенным членам класса. Дружественные функции не считаются членами класса; это обычные внешние функции с особыми правами доступа. Друзья не находятся в области класса, и они не называются с помощью операторов по отбору участников (**.** и**>**- ) если они не являются членами другого класса. Функция **друга** объявляется классом, предоставляющим доступ. Декларация **друга** может быть размещена в любом месте в декларации класса. На него не влияют ключевые слова управления доступом.

В следующем примере показан класс `Point` и дружественная функция `ChangePrivate`. Функция **"Друг"** имеет доступ к `Point` частному члену данных объекта, который он получает в качестве параметра.

```cpp
// friend_functions.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
class Point
{
    friend void ChangePrivate( Point & );
public:
    Point( void ) : m_i(0) {}
    void PrintPrivate( void ){cout << m_i << endl; }

private:
    int m_i;
};

void ChangePrivate ( Point &i ) { i.m_i++; }

int main()
{
   Point sPoint;
   sPoint.PrintPrivate();
   ChangePrivate(sPoint);
   sPoint.PrintPrivate();
// Output: 0
           1
}
```

## <a name="class-members-as-friends"></a>Члены класса как дружественные элементы

Функции-члены класса могут быть объявлены в других классах как дружественные. Рассмотрим следующий пример:

```cpp
// classes_as_friends1.cpp
// compile with: /c
class B;

class A {
public:
   int Func1( B& b );

private:
   int Func2( B& b );
};

class B {
private:
   int _b;

   // A::Func1 is a friend function to class B
   // so A::Func1 has access to all members of B
   friend int A::Func1( B& );
};

int A::Func1( B& b ) { return b._b; }   // OK
int A::Func2( B& b ) { return b._b; }   // C2248
```

В предыдущем примере дружественный доступ к классу `A::Func1( B& )` предоставляется только функции `B`. Таким образом, доступ `_b` к частному `A` члену `Func2`является правильным в `Func1` классе, но не в .

Класс `friend` — это класс, все функций-члены которого являются дружественными функциями класса, то есть функции-члены которого имеют доступ к закрытым и защищенным членам другого класса. Предположим, что в классе `friend` было следующее объявление `B`:

```cpp
friend class A;
```

В этом случае все функции-члены из класса `A` имели бы дружественный доступ к классу `B`. В следующем коде приведен пример дружественного класса.

```cpp
// classes_as_friends2.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
class YourClass {
friend class YourOtherClass;  // Declare a friend class
public:
   YourClass() : topSecret(0){}
   void printMember() { cout << topSecret << endl; }
private:
   int topSecret;
};

class YourOtherClass {
public:
   void change( YourClass& yc, int x ){yc.topSecret = x;}
};

int main() {
   YourClass yc1;
   YourOtherClass yoc1;
   yc1.printMember();
   yoc1.change( yc1, 5 );
   yc1.printMember();
}
```

Дружественные отношения не являются взаимными, если это не указано явным образом. В предыдущем примере функции-члены класса `YourClass` не имеют доступа к закрытым членам класса `YourOtherClass`.

Управляемый тип (в C/CLI) не может иметь никаких функций друга, классов друзей или интерфейсов друзей.

Дружественные отношения не наследуются; это означает, что классы, производные от `YourOtherClass`, не могут обращаться к закрытым членам класса `YourClass`. Дружественные отношения не являются переходящими, поэтому классы, дружественные классу `YourOtherClass`, не могут обращаться к закрытым членам класса `YourClass`.

На следующем рисунке показаны объявления 4 классов: `Base`, `Derived`, `aFriend` и `anotherFriend`. Только класс `aFriend` имеет прямой доступ к закрытым членам класса `Base` (и к любым возможным унаследованным членам класса `Base`).

![Последствия дружественных отношений](../cpp/media/vc38v41.gif "Последствия дружественных отношений") <br/>
Последствия дружественных отношений

## <a name="inline-friend-definitions"></a>Встроенные определения дружественных элементов

Функции друга могут быть определены (с учетом тела функции) внутри классовых деклараций. Эти функции являются встраиваемыми, и как встраиваемые функции членов они ведут себя так, как если бы они были определены сразу после просмотра всех членов класса, но до закрытия области класса (конец объявления класса). Функции друзей, определяемые внутри деклараций класса, находятся в сфере прилагаемого класса.

## <a name="see-also"></a>См. также раздел

[Keywords](../cpp/keywords-cpp.md)
