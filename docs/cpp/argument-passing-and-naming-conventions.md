---
title: Передача аргументов и соглашения именования
ms.date: 12/17/2018
helpviewer_keywords:
- argument passing [C++], conventions
- arguments [C++], widening
- coding conventions, arguments
- arguments [C++], passing
- registers, return values
- thiscall keyword [C++]
- naming conventions [C++], arguments
- arguments [C++], naming
- passing arguments [C++], conventions
- conventions [C++], argument names
ms.assetid: de468979-eab8-4158-90c5-c198932f93b9
ms.openlocfilehash: e621db339102f1f40030bc7826d383d306a39be8
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80190772"
---
# <a name="argument-passing-and-naming-conventions"></a>Передача аргументов и соглашения именования

**Блок, относящийся только к системам Microsoft**

Компиляторы C++ Майкрософт позволяют задавать соглашения для передачи аргументов и возвращаемых значений между функциями и вызывающими объектами. Некоторые соглашения доступны не на всех поддерживаемых платформах, и в некоторых соглашениях используются реализации, зависящие от платформы. В большинстве случаев ключевые слова или параметры компилятора, которые задают неподдерживаемое на определенной платформе соглашение, игнорируются, и используется соглашение по умолчанию для данной платформы.

На платформах x86 все аргументы при передаче расширяются до 32 бит. Возвращаемые значения также расширяются до 32 бит и возвращаются в регистре EAX, за исключением 8-байтовых структур, которые возвращаются в паре регистров EDX:EAX. Более крупные структуры возвращаются в регистре EAX в виде указателей на скрытые возвращаемые структуры. Параметры помещаются в стек справа налево. Структуры, не являющиеся данными POD (обычные старые данные), не возвращаются в регистрах.

Компилятор создает код пролога и эпилога для сохранения и восстановления регистров ESI, EDI, EBX и EBP, если они используются в функции.

> [!NOTE]
> Если функция возвращает структуру, объединение или класс по значению, все определения типа должны быть одинаковыми, в противном случае программа завершается сбоем в среде выполнения.

Сведения о том, как определить собственный Пролог и код эпилога, см. в разделе [вызовы функций с атрибутом naked](../cpp/naked-function-calls.md).

Сведения о соглашениях о вызовах по умолчанию в коде, предназначенном для платформ x64, см. в разделе [соглашение о вызовах x64](../build/x64-calling-convention.md). Сведения о проблемах с соглашениями о вызовах в коде, предназначенном для платформ ARM, см. в разделе [распространенные проблемы перехода на C++ Visual ARM](../build/common-visual-cpp-arm-migration-issues.md).

Компилятор Visual C/C++ поддерживает следующие соглашения о вызовах.

|Ключевое слово|Очистка стека|Передача параметров|
|-------------|-------------------|-----------------------|
|[__cdecl](../cpp/cdecl.md)|Caller|Параметры помещаются в стек в обратном порядке (справа налево)|
|[__clrcall](../cpp/clrcall.md)|Недоступно|Параметры загружаются в стек выражений CLR по-порядку (слева направо).|
|[__stdcall](../cpp/stdcall.md)|Вызываемая функция|Параметры помещаются в стек в обратном порядке (справа налево)|
|[__fastcall](../cpp/fastcall.md)|Вызываемая функция|Хранятся в регистрах, затем помещаются в стек|
|[__thiscall](../cpp/thiscall.md)|Вызываемая функция|Помещается в стек; **этот** указатель ХРАНИТСЯ в ECX|
|[__vectorcall](../cpp/vectorcall.md)|Вызываемая функция|Хранятся в регистрах, затем помещаются в стек в обратном порядке (справа налево)|

Связанные сведения см. в разделе [устаревшие соглашения о вызовах](../cpp/obsolete-calling-conventions.md).

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также раздел

[Соглашения о вызовах](../cpp/calling-conventions.md)
