---
title: Операторы new и delete
ms.date: 11/19/2019
helpviewer_keywords:
- new keyword [C++]
- delete keyword [C++]
ms.assetid: fa721b9e-0374-4f04-bb87-032ea775bcc8
ms.openlocfilehash: fd170c1500e2d80879fdd89f7d825930189ae942
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81367889"
---
# <a name="new-and-delete-operators"></a>Операторы new и delete

СЗ поддерживает динамическое распределение и размещение объектов с помощью [новых](new-operator-cpp.md) и [удаляющих](delete-operator-cpp.md) операторов. Эти операторы выделяют память для объектов из пула, называемого свободным хранилищем. **Новый** оператор называет оператора специальной функции [новой,](new-operator-cpp.md)а оператор **удаления** вызывает оператора специальной функции [удалить.](delete-operator-cpp.md)

**Новая** функция в Стандартной библиотеке СЗ поддерживает поведение, указанное в стандарте СЗ, которое заключается в том, чтобы бросить std::bad_alloc исключение, если выделение памяти не удается. Если вы все еще хотите не бросая версию **новой,** свяжите свою программу с nothrownew.obj. Однако при связях с nothrownew.obj **новый оператор** по умолчанию в стандартной библиотеке СЗ больше не функционирует.

Для получения списка библиотечных файлов, включающие библиотеку C [CRT Library Features](../c-runtime-library/crt-library-features.md)Runtime и Стандартную библиотеку СЗ, см.

## <a name="the-new-operator"></a><a id="new_operator"> </a> Новый оператор

Когда оператор, например следующее, встречается в программе, это переводится как вызов **оператору функции:**

```cpp
char *pch = new char[BUFFER_SIZE];
```

Если запрос предназначен для нулевых байтов хранилища, **новый оператор** возвращает указатель на отдельный объект (т.е. повторные вызовы **оператору новых** указателей возврата различных указателей). Если не хватает памяти для запроса на `std::bad_alloc` распределение, **оператор новый** бросает исключение, или возвращает **nullptr,** если вы связали в не бросая **оператора новой** поддержки.

Вы можете написать рутину, которая пытается освободить память и повторить распределение; [Дополнительную](../c-runtime-library/reference/set-new-handler.md) информацию _set_new_handler. Для получения более подробной информации о схеме восстановления см.

В следующей таблице описаны две области новых функций **оператора.**

### <a name="scope-for-operator-new-functions"></a>Область для новых функций оператора

|Оператор|Область|
|--------------|-----------|
|**::оператор новый**|Global|
|*название класса* **::оператор новый**|Class|

Первый аргумент для **оператора новый** должен быть `size_t` типа (тип, определенный в \<stddef.h>), и тип возврата всегда **недействителен.** <strong>\*</strong>

Новая функция глобального **оператора** называется, когда **новый** оператор используется для распределения объектов встроенных типов, объектов типа класса, которые не содержат новых функций **оператора,** определяемых пользователем, и массивов любого типа. Когда **новый** оператор используется для распределения объектов типа класса, где определяется **новый оператор,** оператор **нового** класса вызывается.

Новая функция **оператора,** определяемая для класса, является функцией статического члена (которая, следовательно, не может быть виртуальной), которая скрывает **глобальному оператору новую** функцию для объектов этого типа. Рассмотрим случай, когда **новая** используется для выделения и установки памяти на заданное значение:

```cpp
#include <malloc.h>
#include <memory.h>

class Blanks
{
public:
    Blanks(){}
    void *operator new( size_t stAllocateBlock, char chInit );
};
void *Blanks::operator new( size_t stAllocateBlock, char chInit )
{
    void *pvTemp = malloc( stAllocateBlock );
    if( pvTemp != 0 )
        memset( pvTemp, chInit, stAllocateBlock );
    return pvTemp;
}
// For discrete objects of type Blanks, the global operator new function
// is hidden. Therefore, the following code allocates an object of type
// Blanks and initializes it to 0xa5
int main()
{
   Blanks *a5 = new(0xa5) Blanks;
   return a5 != 0;
}
```

Аргумент, представленный в скобках к `Blanks::operator new` новым `chInit` передается в качестве аргумента. **new** Тем не менее, **глобальная функция оператора** скрыта, в результате чего код, например следующий для создания ошибки:

```cpp
Blanks *SomeBlanks = new Blanks;
```

Компилятор поддерживает **новые** функции участников и **удаляет** операторов в декларации класса. Пример:

```cpp
class MyClass
{
public:
   void * operator new[] (size_t)
   {
      return 0;
   }
   void   operator delete[] (void*)
   {
   }
};

int main()
{
   MyClass *pMyClass = new MyClass[5];
   delete [] pMyClass;
}
```

### <a name="handling-insufficient-memory"></a>Обработка нехватки памяти

Тестирование для неудавшегося распределения памяти может быть сделано, как показано здесь:

```cpp
#include <iostream>
using namespace std;
#define BIG_NUMBER 100000000
int main() {
   int *pI = new int[BIG_NUMBER];
   if( pI == 0x0 ) {
      cout << "Insufficient memory" << endl;
      return -1;
   }
}
```

Существует еще один способ обработки неудавшихся запросов распределения памяти. Напишите пользовательскую процедуру восстановления для обработки такого сбоя, а затем зарегистрируйте свою функцию, позвонив [_set_new_handler](../c-runtime-library/reference/set-new-handler.md) функцию выполнения.

## <a name="the-delete-operator"></a><a id="delete_operator"> </a> Оператор удаления

Память, динамически распределенная с помощью **нового** оператора, может быть освобождена с помощью оператора **удаления.** Оператор удаления вызывает функцию **удаления оператора,** которая высвобожает память обратно в доступный пул. Использование оператора **удаления** также приводит к вызову деструктора класса (если он есть).

Существуют глобальные и классовые функции **удаления оператора.** Для данного класса можно определить только одну функцию **удаления оператора;** если определяется, он скрывает функцию удаления глобального **оператора.** Функция **удаления** глобального оператора всегда требуется для массивов любого типа.

Функция удаления глобального **оператора.** Существуют две формы для **глобального оператора удаления** и **класса-член оператора удалить** функции:

```cpp
void operator delete( void * );
void operator delete( void *, size_t );
```

Только одна из двух предыдущих форм может присутствовать для данного класса. Первая форма принимает один `void *`аргумент типа, который содержит указатель на объект для дераспределения. Вторая форма — размер сделки — берет два аргумента, первый из которых является указателем на блок памяти для делокации, а вторая — количество байтов для делокации. Тип возврата обеих форм **недействителен** **(оператор удаляет** не может вернуть значение).

Цель второй формы состоит в том, чтобы ускорить поиск правильной категории размера объекта, которая будет удалена, которая часто не хранится рядом с самим распределением и, вероятно, не затягивается. Вторая форма полезна, когда функция **удаления оператора** из базового класса используется для удаления объекта производного класса.

Функция **удаления оператора** статична; поэтому она не может быть виртуальной. Функция **удаления оператора** подчиняется элементу управления доступом, как описано в [элементе управления доступом.](member-access-control-cpp.md)

В следующем примере показаны новые функции **оператора,** определяемого пользователем, и **функции удаления оператора,** предназначенные для распределения журналов и дислокаций памяти:

```cpp
#include <iostream>
using namespace std;

int fLogMemory = 0;      // Perform logging (0=no; nonzero=yes)?
int cBlocksAllocated = 0;  // Count of blocks allocated.

// User-defined operator new.
void *operator new( size_t stAllocateBlock ) {
   static int fInOpNew = 0;   // Guard flag.

   if ( fLogMemory && !fInOpNew ) {
      fInOpNew = 1;
      clog << "Memory block " << ++cBlocksAllocated
          << " allocated for " << stAllocateBlock
          << " bytes\n";
      fInOpNew = 0;
   }
   return malloc( stAllocateBlock );
}

// User-defined operator delete.
void operator delete( void *pvMem ) {
   static int fInOpDelete = 0;   // Guard flag.
   if ( fLogMemory && !fInOpDelete ) {
      fInOpDelete = 1;
      clog << "Memory block " << cBlocksAllocated--
          << " deallocated\n";
      fInOpDelete = 0;
   }

   free( pvMem );
}

int main( int argc, char *argv[] ) {
   fLogMemory = 1;   // Turn logging on
   if( argc > 1 )
      for( int i = 0; i < atoi( argv[1] ); ++i ) {
         char *pMem = new char[10];
         delete[] pMem;
      }
   fLogMemory = 0;  // Turn logging off.
   return cBlocksAllocated;
}
```

Представленный выше код можно использовать для обнаружения "утечек памяти", т. е. памяти, которая выделяется в свободном хранилище, но никогда не освобождается. Для выполнения этого обнаружения **глобальные новые** и **удаленные** операторы переопределяются для подсчета распределения и распределения памяти.

Компилятор поддерживает **новые** функции участников и **удаляет** операторов в декларации класса. Пример:

```cpp
// spec1_the_operator_delete_function2.cpp
// compile with: /c
class X  {
public:
   void * operator new[] (size_t) {
      return 0;
   }
   void operator delete[] (void*) {}
};

void f() {
   X *pX = new X[5];
   delete [] pX;
}
```
