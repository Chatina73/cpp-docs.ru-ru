---
title: Деструкторы (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- objects [C++], destroying
- Visual C++, destructors
- destroying objects, destructors
- ~ operator [C++], specifying destructors
- destructors, about destructors
- destructors, C++
ms.assetid: afa859b0-f3bc-4c4d-b250-c68b335b6004
ms.openlocfilehash: 5c56a6ffc43f8fa00ffd540a5922d8ac279475ed
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50586021"
---
# <a name="destructors-c"></a>Деструкторы (C++)

Деструктор является функцией-членом, который вызывается автоматически, когда объект выходит за пределы области или уничтожается явным образом с помощью вызова **удалить**. Деструктор имеет имя, совпадающее с именем класса, предшествует знак тильды (`~`). Например, деструктор для класса `String` объявляется следующим образом: `~String()`.

Если не определить деструктор, компилятор предоставит по умолчанию; для многих классов этого достаточно. Необходимо только определить пользовательский деструктор, когда класс хранит указатели на ресурсы системы, которые должны быть сняты или указатели, которыми владеют память они указывают.

Рассмотрим следующее объявление класса `String`:

```cpp
// spec1_destructors.cpp
#include <string.h>

class String {
public:
   String( char *ch );  // Declare constructor
   ~String();           //  and destructor.
private:
   char    *_text;
   size_t  sizeOfText;
};

// Define the constructor.
String::String( char *ch ) {
   sizeOfText = strlen( ch ) + 1;

   // Dynamically allocate the correct amount of memory.
   _text = new char[ sizeOfText ];

   // If the allocation succeeds, copy the initialization string.
   if( _text )
      strcpy_s( _text, sizeOfText, ch );
}

// Define the destructor.
String::~String() {
   // Deallocate the memory that was previously reserved
   //  for this string.
   if (_text)
      delete[] _text;
}

int main() {
   String str("The piper in the glen...");
}
```

В предыдущем примере деструктор `String::~String` использует **удалить** оператор для освобождения пространства, динамически выделенного для хранения текста.

## <a name="declaring-destructors"></a>Объявление деструкторов

Деструкторы — это функции с тем же именем, что и класс, но с добавленным в начало знаком тильды (`~`).

При объявлении деструкторов действуют несколько правил. Деструкторы:

- Не могут иметь аргументов.

- Возвращает значение (или **void**).

- Не могут объявляться как **const**, **volatile**, или **статических**. Тем не менее, их можно вызывать для уничтожения объектов, объявленных как **const**, **volatile**, или **статических**.

- Могут быть объявлены как **виртуального**. Используя виртуальные деструкторы, можно уничтожать объекты, не зная их тип — правильный деструктор для объекта вызывается с помощью механизма виртуальных функций. Обратите внимание, что для абстрактных классов деструкторы также могут объявляться как чисто виртуальные функции.

## <a name="using-destructors"></a>Использование деструкторов

Деструкторы вызываются, когда происходит одно из следующих событий:

- Локальный (автоматический) объект с областью видимости блока выходит за пределы области видимости.

- Объект, выделенный с помощью **новый** оператор можно явно освободить с помощью **удалить**.

- Время существования временного объекта заканчивается.

- Программа заканчивается, глобальные или статические объекты продолжают существовать.

- Деструктор явно вызываться с использованием полного имени функции деструктора.

Деструкторы могут свободно вызывать функции-члена класса и осуществлять доступ к данным членов класса.

Существует два ограничения на использование деструкторов.

- Не удается получить его адрес.

- Производные классы не наследуют деструктор базового класса.

## <a name="order-of-destruction"></a>Порядок уничтожения

Когда объект выходит за пределы области или удаляется, последовательность событий при его полном уничтожении выглядит следующим образом:

1. Вызывается деструктор класса, и выполняется тело функции деструктора.

1. Деструкторы для объектов нестатических членов вызываются в порядке, обратном порядку их появления в объявлении класса. Необязательный список инициализации членов используется в создании этих членов не влияет на порядок конструктора или деструктора.

1. Деструкторы для невиртуальных базовых классов вызываются в порядке, обратном порядку объявления.

1. Деструкторы для виртуальных базовых классов вызываются в порядке, обратном порядку их объявления.

```cpp
// order_of_destruction.cpp
#include <stdio.h>

struct A1      { virtual ~A1() { printf("A1 dtor\n"); } };
struct A2 : A1 { virtual ~A2() { printf("A2 dtor\n"); } };
struct A3 : A2 { virtual ~A3() { printf("A3 dtor\n"); } };

struct B1      { ~B1() { printf("B1 dtor\n"); } };
struct B2 : B1 { ~B2() { printf("B2 dtor\n"); } };
struct B3 : B2 { ~B3() { printf("B3 dtor\n"); } };

int main() {
   A1 * a = new A3;
   delete a;
   printf("\n");

   B1 * b = new B3;
   delete b;
   printf("\n");

   B3 * b2 = new B3;
   delete b2;
}

Output: A3 dtor
A2 dtor
A1 dtor

B1 dtor

B3 dtor
B2 dtor
B1 dtor
```

### <a name="virtual-base-classes"></a>Виртуальные базовые классы

Деструкторы для виртуальных базовых классов вызываются в порядке, обратном их указанию в направленном ациклическом графе (в глубину, слева направо, обход в обратном порядке). На следующем рисунке представлен граф наследования.

![Граф наследования, показывающий виртуальные базовые классы](../cpp/media/vc392j1.gif "vc392J1")

Граф наследования, представляющий виртуальные базовые классы

Ниже перечислены заголовки классов, представленных на рисунке.

```cpp
class A
class B
class C : virtual public A, virtual public B
class D : virtual public A, virtual public B
class E : public C, public D, virtual public B
```

Чтобы определить порядок удаления виртуальных базовых классов объекта типа `E`, компилятор выполняет сборку списка, применяя следующий алгоритм.

1. Просмотрите левую часть графа, начиная с самой глубокой точки графа (в данном случае `E`).

1. Просматривайте граф справа налево, пока не будут пройдены все узлы. Запомните имя текущего узла.

1. Пересмотрите предыдущий узел (вниз и вправо), чтобы определить, является ли рассматриваемый узел виртуальным базовым классом.

1. Если рассматриваемый узел является виртуальным базовым классом, просмотрите список, чтобы проверить, был ли он введен ранее. Если он не является виртуальным базовым классом, игнорируйте его.

1. Если рассматриваемого узла еще нет в списке, добавьте его вниз списка.

1. Просмотрите граф вверх и вдоль следующего пути вправо.

1. Перейдите к шагу 2.

1. Если путь последний путь вверх исчерпан, запомните имя текущего узла.

1. Перейдите к шагу 3.

1. Выполняйте этот процесс, пока нижний узел снова не станет текущим узлом.

Таким образом, для класса `E` порядок удаления будет следующим.

1. Невиртуальный базовый класс `E`.

1. Невиртуальный базовый класс `D`.

1. Невиртуальный базовый класс `C`.

1. Виртуальный базовый класс `B`.

1. Виртуальный базовый класс `A`.

В ходе этого процесса создается упорядоченный список уникальных записей. Имя класса никогда не отображается дважды. После создания список просматривается в обратном порядке, и вызывается деструктор для каждого класса в списке от последнего к первому.

Порядок построения или удаления очень важен, когда конструкторы и деструкторы в одном классе полагаются на другой компонент, который создается первым или сохраняется дольше, например если деструктор `A` (на рисунке выше) полагается на то, что `B` будет по-прежнему присутствовать после выполнения кода, или наоборот.

Такие взаимозависимости между классами в графе наследования опасны, поскольку классы, наследуемые впоследствии, могут изменить крайний левый путь, тем самым изменив порядок построения и удаления.

### <a name="non-virtual-base-classes"></a>Невиртуальная базовые классы

Деструкторы для невиртуальных базовых классов вызываются в обратном порядке, в котором объявлены имен базовых классов. Рассмотрим следующее объявление класса.

```cpp
class MultInherit : public Base1, public Base2
...
```

В предыдущем примере деструктор `Base2` вызывается перед деструктором `Base1`.

## <a name="explicit-destructor-calls"></a>Явные вызовы деструктора

Редко возникает необходимость в явном вызове деструктора. Однако может быть полезно выполнить удаление объектов, размещенных по абсолютным адресам. Эти объекты часто предоставляются с использованием пользовательского **новый** оператор, который принимает аргумент размещения. **Удалить** оператор не может освободить эту память, так как она не предоставляется из свободного хранилища (Дополнительные сведения см. в разделе [новых и удаленных операторах](../cpp/new-and-delete-operators.md)). Вызов деструктора, однако, может выполнить соответствующую очистку. Для явного вызова деструктора для объекта (`s`) класса `String` воспользуйтесь одним из следующих операторов.

```cpp
s.String::~String();     // non-virtual call
ps->String::~String();   // non-virtual call

s.~String();       // Virtual call
ps->~String();     // Virtual call
```

Нотация для явных вызовов деструкторов, показанная в предыдущем примере, может использоваться независимо от того, определяет ли тип деструктор. Это позволяет выполнять такие явные вызовы, не зная, определен ли деструктор для типа. Явный вызов деструктора, если ни один из них не определен, не имеет никакого эффекта.