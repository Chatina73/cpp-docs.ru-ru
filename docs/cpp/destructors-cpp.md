---
description: 'Дополнительные сведения о: деструкторы (C++)'
title: Деструкторы (C++)
ms.date: 07/20/2019
helpviewer_keywords:
- objects [C++], destroying
- destructors, C++
ms.assetid: afa859b0-f3bc-4c4d-b250-c68b335b6004
ms.openlocfilehash: 121df368fc79f7dbabe4ccac6fe93c36788c5e51
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97195571"
---
# <a name="destructors-c"></a>Деструкторы (C++)

Деструктор — это функция-член, которая вызывается автоматически, когда объект выходит из области действия или явно уничтожается вызовом метода **`delete`** . Деструктор имеет то же имя, что и класс, перед которым стоит тильда ( `~` ). Например, деструктор для класса `String` объявляется следующим образом: `~String()`.

Если деструктор не определен, компилятор будет предоставлять его по умолчанию. для многих классов это достаточно. Необходимо определить пользовательский деструктор, если класс хранит дескрипторы для системных ресурсов, которые необходимо освободить, или указатели, владеющие памятью, на которую они указывают.

Рассмотрим следующее объявление класса `String`:

```cpp
// spec1_destructors.cpp
#include <string>

class String {
public:
   String( char *ch );  // Declare constructor
   ~String();           //  and destructor.
private:
   char    *_text;
   size_t  sizeOfText;
};

// Define the constructor.
String::String( char *ch ) {
   sizeOfText = strlen( ch ) + 1;

   // Dynamically allocate the correct amount of memory.
   _text = new char[ sizeOfText ];

   // If the allocation succeeds, copy the initialization string.
   if( _text )
      strcpy_s( _text, sizeOfText, ch );
}

// Define the destructor.
String::~String() {
   // Deallocate the memory that was previously reserved
   //  for this string.
   delete[] _text;
}

int main() {
   String str("The piper in the glen...");
}
```

В предыдущем примере деструктор `String::~String` использует **`delete`** оператор для освобождения пространства, динамически выделяемого для хранения текста.

## <a name="declaring-destructors"></a>Объявление деструкторов

Деструкторы — это функции с тем же именем, что и класс, но с добавленным в начало знаком тильды (`~`).

При объявлении деструкторов действуют несколько правил. Деструкторы:

- Не могут иметь аргументов.

- Не возвращают значение (или **`void`** ).

- Не может быть объявлен как **`const`** , **`volatile`** или **`static`** . Однако они могут вызываться для уничтожения объектов, объявленных как **`const`** , **`volatile`** или **`static`** .

- Может быть объявлен как **`virtual`** . Используя виртуальные деструкторы, можно уничтожать объекты, не зная их тип — правильный деструктор для объекта вызывается с помощью механизма виртуальных функций. Обратите внимание, что для абстрактных классов деструкторы также могут объявляться как чисто виртуальные функции.

## <a name="using-destructors"></a>Использование деструкторов

Деструкторы вызываются, когда происходит одно из следующих событий:

- Локальный (автоматический) объект с областью видимости блока выходит за пределы области видимости.

- Объект, выделенный с помощью **`new`** оператора, явным образом освобождается с помощью **`delete`** .

- Время существования временного объекта заканчивается.

- Программа заканчивается, глобальные или статические объекты продолжают существовать.

- Деструктор явно вызываться с использованием полного имени функции деструктора.

Деструкторы могут свободно вызывать функции-члена класса и осуществлять доступ к данным членов класса.

Существуют два ограничения на использование деструкторов.

- Вы не можете получить его адрес.

- Производные классы не наследуют деструктор своего базового класса.

## <a name="order-of-destruction"></a>Порядок уничтожения

Когда объект выходит за пределы области или удаляется, последовательность событий при его полном уничтожении выглядит следующим образом:

1. Вызывается деструктор класса, и выполняется тело функции деструктора.

1. Деструкторы для объектов нестатических членов вызываются в порядке, обратном порядку их появления в объявлении класса. Необязательный список инициализации элементов, используемый при создании этих элементов, не влияет на порядок создания или уничтожения.

1. Деструкторы для невиртуальных базовых классов вызываются в обратную последовательность объявления.

1. Деструкторы для виртуальных базовых классов вызываются в порядке, обратном порядку их объявления.

```cpp
// order_of_destruction.cpp
#include <cstdio>

struct A1      { virtual ~A1() { printf("A1 dtor\n"); } };
struct A2 : A1 { virtual ~A2() { printf("A2 dtor\n"); } };
struct A3 : A2 { virtual ~A3() { printf("A3 dtor\n"); } };

struct B1      { ~B1() { printf("B1 dtor\n"); } };
struct B2 : B1 { ~B2() { printf("B2 dtor\n"); } };
struct B3 : B2 { ~B3() { printf("B3 dtor\n"); } };

int main() {
   A1 * a = new A3;
   delete a;
   printf("\n");

   B1 * b = new B3;
   delete b;
   printf("\n");

   B3 * b2 = new B3;
   delete b2;
}

Output: A3 dtor
A2 dtor
A1 dtor

B1 dtor

B3 dtor
B2 dtor
B1 dtor
```

### <a name="virtual-base-classes"></a>Виртуальные базовые классы

Деструкторы для виртуальных базовых классов вызываются в порядке, обратном их указанию в направленном ациклическом графе (в глубину, слева направо, обход в обратном порядке). На следующем рисунке представлен граф наследования.

![Граф наследования, показывающий виртуальные базовые классы](../cpp/media/vc392j1.gif "Граф наследования, показывающий виртуальные базовые классы") <br/>
Граф наследования, показывающий виртуальные базовые классы

Ниже перечислены заголовки классов, представленных на рисунке.

```cpp
class A
class B
class C : virtual public A, virtual public B
class D : virtual public A, virtual public B
class E : public C, public D, virtual public B
```

Чтобы определить порядок удаления виртуальных базовых классов объекта типа `E`, компилятор выполняет сборку списка, применяя следующий алгоритм.

1. Просмотрите левую часть графа, начиная с самой глубокой точки графа (в данном случае `E`).

1. Просматривайте граф справа налево, пока не будут пройдены все узлы. Запомните имя текущего узла.

1. Пересмотрите предыдущий узел (вниз и вправо), чтобы определить, является ли рассматриваемый узел виртуальным базовым классом.

1. Если рассматриваемый узел является виртуальным базовым классом, просмотрите список, чтобы проверить, был ли он введен ранее. Если он не является виртуальным базовым классом, игнорируйте его.

1. Если рассматриваемого узла еще нет в списке, добавьте его вниз списка.

1. Просмотрите граф вверх и вдоль следующего пути вправо.

1. Перейдите к шагу 2.

1. Если путь последний путь вверх исчерпан, запомните имя текущего узла.

1. Перейдите к шагу 3.

1. Выполняйте этот процесс, пока нижний узел снова не станет текущим узлом.

Таким образом, для класса `E` порядок удаления будет следующим.

1. Невиртуальный базовый класс `E` .

1. Невиртуальный базовый класс `D` .

1. Невиртуальный базовый класс `C` .

1. Виртуальный базовый класс `B`.

1. Виртуальный базовый класс `A`.

В ходе этого процесса создается упорядоченный список уникальных записей. Имя класса никогда не отображается дважды. После создания список просматривается в обратном порядке, и вызывается деструктор для каждого класса в списке от последнего к первому.

Порядок построения или удаления очень важен, когда конструкторы и деструкторы в одном классе полагаются на другой компонент, который создается первым или сохраняется дольше, например если деструктор `A` (на рисунке выше) полагается на то, что `B` будет по-прежнему присутствовать после выполнения кода, или наоборот.

Такие взаимозависимости между классами в графе наследования опасны, поскольку классы, наследуемые впоследствии, могут изменить крайний левый путь, тем самым изменив порядок построения и удаления.

### <a name="non-virtual-base-classes"></a>Не являющиеся виртуальными базовыми классами

Деструкторы для невиртуальных базовых классов вызываются в порядке, в котором объявляются имена базовых классов. Рассмотрим следующее объявление класса.

```cpp
class MultInherit : public Base1, public Base2
...
```

В предыдущем примере деструктор `Base2` вызывается перед деструктором `Base1`.

## <a name="explicit-destructor-calls"></a>Явные вызовы деструктора

Редко возникает необходимость в явном вызове деструктора. Однако может быть полезно выполнить удаление объектов, размещенных по абсолютным адресам. Обычно эти объекты выделяются с помощью определяемого пользователем **`new`** оператора, принимающего аргумент размещения. **`delete`** Оператор не может освободить эту память, так как она не выделена из бесплатного хранилища (Дополнительные сведения см. [в разделе операторы new и DELETE](../cpp/new-and-delete-operators.md)). Вызов деструктора, однако, может выполнить соответствующую очистку. Для явного вызова деструктора для объекта (`s`) класса `String` воспользуйтесь одним из следующих операторов.

```cpp
s.String::~String();     // non-virtual call
ps->String::~String();   // non-virtual call

s.~String();       // Virtual call
ps->~String();     // Virtual call
```

Нотация для явных вызовов деструкторов, показанная в предыдущем примере, может использоваться независимо от того, определяет ли тип деструктор. Это позволяет выполнять такие явные вызовы, не зная, определен ли деструктор для типа. Явный вызов деструктора, если ни один из них не определен, не имеет никакого эффекта.

## <a name="robust-programming"></a>Отказоустойчивость

Классу требуется деструктор, если он получает ресурс, и для безопасного управления ресурсом, вероятно, потребуется реализовать конструктор копии и назначение копирования.

Если эти специальные функции не определены пользователем, они неявно определяются компилятором. Неявно созданные конструкторы и операторы присваивания выполняют поверхностную почленном копию, которая почти наверняка неверно, если объект управляет ресурсом.

В следующем примере неявно созданный конструктор копии сделает указатели `str1.text` и `str2.text` ссылался на одну и ту же память, и, когда мы вернемся из `copy_strings()` , эта память будет удалена дважды, что является неопределенным поведением:

```cpp
void copy_strings()
{
   String str1("I have a sense of impending disaster...");
   String str2 = str1; // str1.text and str2.text now refer to the same object
} // delete[] _text; deallocates the same memory twice
  // undefined behavior
```

Явное определение деструктора, конструктора копирования или оператора присваивания копирования предотвращает неявное определение конструктора перемещения и оператора присваивания перемещения. В этом случае не удастся предоставить операции перемещения, если копирование занимает много ресурсов, но пропущенная возможность оптимизации.

## <a name="see-also"></a>См. также раздел

[Конструкторы копий и операторы присваивания копирования](../cpp/copy-constructors-and-copy-assignment-operators-cpp.md)</br>
[Конструкторы перемещения и операторы присваивания перемещения](../cpp/move-constructors-and-move-assignment-operators-cpp.md)
