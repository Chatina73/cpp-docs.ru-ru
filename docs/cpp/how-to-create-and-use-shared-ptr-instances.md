---
title: Практическое руководство. Создание и использование экземпляров shared_ptr
ms.custom: how-to
ms.date: 11/19/2018
ms.topic: conceptual
ms.assetid: 7d6ebb73-fa0d-4b0b-a528-bf05de96518e
ms.openlocfilehash: 8363139efddb2fa64057fdb995ab7bd5dfbcfd9b
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62153752"
---
# <a name="how-to-create-and-use-sharedptr-instances"></a>Практическое руководство. Создание и использование экземпляров shared_ptr

`shared_ptr` Тип — смарт-указатель в стандартной библиотеке C++, который предназначен для сценариев, в которых возможно больше одного владельца, для управления временем существования объекта в памяти. После инициализации `shared_ptr` скопируйте его, передать его по значению в аргументы функций и назначьте его в другом `shared_ptr` экземпляров. Все экземпляры указывать на тот же объект, а общий доступ к один «управляющий блок», который увеличивает и уменьшает счетчик ссылок каждый раз, когда новый `shared_ptr` добавляется, выходит за пределы области или сбрасывается. Когда число ссылок достигает нуля, блок управления удаляет ресурсов памяти и самого себя.

На следующем рисунке показаны несколько `shared_ptr` экземпляров, которые указывают в одном расположении.

![Общий указатель схеме](../cpp/media/shared_ptr.png "схема общий указатель")

## <a name="example-1"></a>Пример 1

По возможности используйте [make_shared](../standard-library/memory-functions.md#make_shared) функцию для создания `shared_ptr` при создании ресурсов памяти в первый раз. `make_shared` — безопасный в отношении исключений. Он использует тот же вызов, чтобы выделить память для блок управления и ресурс и тем самым сократить издержки конструкции. Если вы не используете `make_shared`, вам необходимо будет использовать для создания объекта, прежде чем передать его в новый явное выражение `shared_ptr` конструктор. В следующем примере показаны различные способы объявления и инициализации `shared_ptr` вместе с нового объекта.

[!code-cpp[stl_smart_pointers#1](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_1.cpp)]

## <a name="example-2"></a>Пример 2

В следующем примере показано, как объявить и инициализировать `shared_ptr` экземпляров, которые принимают на общее владение объект, который уже выделен другой `shared_ptr`. Предполагается, что `sp2` является инициализированный `shared_ptr`.

[!code-cpp[stl_smart_pointers#2](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_2.cpp)]

## <a name="example-3"></a>Пример 3

`shared_ptr` можно использовать в контейнеры стандартной библиотеки C++ при использовании алгоритмов, которые копируются элементы. Можно создать оболочку элементов в `shared_ptr`, а затем скопируйте их в другие контейнеры, с учетом того, что основная память является допустимым до тех пор, пока он вам нужен и больше не. В следующем примере показано, как использовать `replace_copy_if` алгоритм на `shared_ptr` экземпляров в векторе.

[!code-cpp[stl_smart_pointers#4](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_3.cpp)]

## <a name="example-4"></a>Пример 4

Можно использовать `dynamic_pointer_cast`, `static_pointer_cast`, и `const_pointer_cast` для приведения `shared_ptr`. Эти функции похожи `dynamic_cast`, `static_cast`, и `const_cast` операторы. Приведенный ниже показано, как протестировать производный тип каждого элемента в вектор `shared_ptr` из базовых классов, а затем копируются элементы и отображения сведений о них.

[!code-cpp[stl_smart_pointers#5](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_4.cpp)]

## <a name="example-5"></a>Пример 5

Вы можете передать `shared_ptr` в другую функцию следующим образом:

- Передайте `shared_ptr` по значению. Это вызывает конструктор копирования, увеличивает счетчик ссылок и вызываемый объект владельца. Имеется небольшое количество издержек в данной операции, который может быть значительным в зависимости от количества `shared_ptr` объектов при передаче. Используйте этот параметр, если контракт кода (подразумеваемые или явные) между вызывающий и вызываемый объекты требует, что вызываемый объект быть владельцем.

- Передайте `shared_ptr` по ссылке или константная ссылка. В этом случае счетчик ссылок не увеличивается и вызываемый объект можно получить доступ к указатель до тех пор, пока вызывающий объект не выходят из области видимости. Или можете создать вызываемый объект `shared_ptr` на основе ссылки и тем самым становятся общего владельца. Используйте этот параметр, когда вызывающий объект не имеет сведений о вызываемый объект, или когда необходимо передать `shared_ptr` и хотите избежать копирования для повышения производительности.

- Передайте базовый указатель или ссылку на базовый объект. Это позволяет вызываемому объекту для использования объекта, но не поддерживает его, чтобы владеть или увеличения времени существования. Если вызываемый объект создает `shared_ptr` из необработанным указателем, новый `shared_ptr` не зависит от исходного и не влияет на основной ресурс. Используйте этот параметр, если контракт между вызывающий и вызываемый объекты четко указывает, что вызывающий объект сохраняет владение `shared_ptr` времени существования.

- При выборе способ передачи `shared_ptr`, определить, имеет ли вызываемый объект владеть основной ресурс. «Владелец» — это объект или функцию, которая может поддерживать основной ресурс для до тех пор, пока она нужна. Если вызывающая сторона должна гарантировать, что вызываемый объект можно продлить срок службы указатель за его времени существования (функции), используйте первый параметр. Вы не заботитесь расширяет ли вызываемый объект времени существования, передавать по ссылке и позволить вызываемому объекту скопировать его или нет.

- Если вам нужно предоставить доступ к вспомогательные функции для указателя базового и вы знаете, вспомогательная функция будет просто использовать указатель и возвращения до возврата вызывающей функции, а затем эта функция не имеет владеть указателя базового. Он просто имеет доступ к указатель за время существования вызывающего `shared_ptr`. В этом случае это безопасно передать `shared_ptr` по ссылке, или передайте необработанный указатель или ссылку на базовый объект. Таким образом передавая обеспечит выигрыш в производительности и также могут помочь вам express программирования намерения.

- В некоторых случаях для примера в `std:vector<shared_ptr<T>>`, может потребоваться передать каждый `shared_ptr` тело лямбда-выражения или объекта функции по имени. Если лямбда-выражения или функции не хранит указатель, то передайте `shared_ptr` по ссылке, чтобы избежать вызова конструктора копии для каждого элемента.

## <a name="example-6"></a>Пример 6

В следующем примере показан как `shared_ptr` перегружает различные операторы сравнения, чтобы включить Сравнение указателей в памяти, который принадлежит `shared_ptr` экземпляров.

[!code-cpp[stl_smart_pointers#3](../cpp/codesnippet/CPP/how-to-create-and-use-shared-ptr-instances_6.cpp)]

## <a name="see-also"></a>См. также

[Интеллектуальные указатели (современный C++)](../cpp/smart-pointers-modern-cpp.md)
