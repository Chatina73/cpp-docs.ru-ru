---
title: Конструкторы копий и операторы присваивания копий (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- = operator [C++], copying objects
- assignment statements [C++], copying objects
- assignment operators [C++], for copying objects
- objects [C++], copying
- initializing objects, by copying objects
- copying objects
- assigning values to copy objects
ms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d
ms.openlocfilehash: 59f463d103e233a1d9b25da3243a16f67263c815
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62392301"
---
# <a name="copy-constructors-and-copy-assignment-operators-c"></a>Конструкторы копий и операторы присваивания копий (C++)

> [!NOTE]
> Начиная с версии C ++ 11, в языке поддерживаются два вида присваивания: *Копировать назначение* и *присваивание перемещением*. В этой статье "присваивание" означает "присваивание копированием", если явно не указано другое. Сведения о присваивании перемещением см. в разделе [конструкторы перемещения и операторы присваивания перемещения (C++)](move-constructors-and-move-assignment-operators-cpp.md).
>
> Как при операции назначения, так и при операции инициализации выполняется копирование объектов.

- **Назначение**: Когда значение одного объекта присваивается другому объекту, первый объект копируется второй объект. Поэтому

    ```cpp
    Point a, b;
    ...
    a = b;
    ```

   приводит к тому, что значение `b` копируется в значение `a`.

- **Инициализация**: Инициализация происходит, если объект был объявлен, если аргументы функции передаются по значению или значения возвращаются из функции по значению.

Можно определить семантику копии объектов типа класса. Например, рассмотрим следующий код.

```cpp
TextFile a, b;
a.Open( "FILE1.DAT" );
b.Open( "FILE2.DAT" );
b = a;
```

Предыдущий код может означать "копировать содержимое FILE1.DAT в FILE2.DAT" или "игнорировать FILE2.DAT и сделать `b` вторым дескриптором FILE1.DAT". Необходимо вложить соответствующую семантику копирования в каждый класс следующим образом.

- С помощью оператора присваивания **оператор =** вместе со ссылкой на тип класса, как тип возвращаемого значения, а также параметр, который передается по **const** ссылки, например `ClassName& operator=(const ClassName& x);`.

- С помощью конструктора копии.

Если конструктор копии не объявлен, компилятор создает конструктор копии для каждого члена.  Если оператор присваивания копированием не объявлен, компилятор создает оператор присваивания копированием для каждого члена. Объявление конструктора копии не подавляет созданный компилятором оператор присваивания копий, и наоборот. При реализации любого из этих способов рекомендуется также реализовать другой способ, чтобы значение кода было четким.

Конструктор копии принимает аргумент типа <em>имя_класса</em><strong>&</strong>, где *имя_класса* — это имя класса, для которого определен конструктор. Пример:

```cpp
// spec1_copying_class_objects.cpp
class Window
{
public:
    Window( const Window& ); // Declare copy constructor.
    // ...
};

int main()
{
}
```

> [!NOTE]
> Сделайте тип аргумента конструктора копии **const** <em>имя_класса</em> <strong>&</strong> по возможности. Это поможет избежать случайного изменения копируемого объекта конструктором копии. Он также позволит выполнять копирование из **const** объектов.

## <a name="compiler-generated-copy-constructors"></a>Конструкторы копии, создаваемые компилятором

Конструкторы копии, созданный компилятором, например конструкторы копии, определяемые пользователем, имеют один аргумент типа «ссылка на *имя_класса*.» Исключение — когда все базовые классы и классов-членов объявлены конструкторы копии, принимающие один аргумент типа **const** <em>имя_класса</em><strong>&</strong>. В этом случае аргумент конструктора копии, создаваемые компилятором является также **const**.

Если тип аргумента для конструктора копии не **const**, инициализация путем копирования **const** возвращает ошибку. Обратное утверждение не верно: Если аргумент является **const**, выполнить инициализацию путем копирования объекта, не **const**.

Операторы присваивания, созданный компилятором следуют той же схеме, относится к **const.** Они принимают один аргумент типа <em>имя_класса</em> <strong>&</strong> Если операторы присваивания во всех базовых и дочерних классах принимают аргументы типа **const** <em>имя_класса</em><strong>&</strong>. Таким образом, созданный классом, принимает оператор присваивания **const** аргумент.

> [!NOTE]
> Если виртуальные базовые классы инициализируются конструкторами копии, создаются компиляторами или определяются пользователем, они инициализируются только один раз, во время создания.

Последствия аналогичны тем, которые имеет конструктор копии. Если аргумент имеет тип не **const**, назначение из **const** возвращает ошибку. Обратное утверждение не верно: Если **const** значение присваивается значение, которое не является **const**, присваивание завершается успешно.

Дополнительные сведения о перегруженных операторах присваивания см. в разделе [назначения](../cpp/assignment.md).