---
title: Конструкторы копий и операторы присваивания копий (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- = operator [C++], copying objects
- assignment statements [C++], copying objects
- assignment operators [C++], for copying objects
- objects [C++], copying
- initializing objects, by copying objects
- copying objects
- assigning values to copy objects
ms.assetid: a94fe1f9-0289-4fb9-8633-77c654002c0d
ms.openlocfilehash: beabe4c6219975d33c7af98a94498188c9abfa55
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80189537"
---
# <a name="copy-constructors-and-copy-assignment-operators-c"></a>Конструкторы копий и операторы присваивания копий (C++)

> [!NOTE]
> Начиная с C++ 11, в языке поддерживаются два вида присваивания: *копирование назначения* и *Перемещение*. В этой статье "присваивание" означает "присваивание копированием", если явно не указано другое. Сведения о назначении Move см. в разделе [конструкторы Move и операторы присваивания перемещения (C++)](move-constructors-and-move-assignment-operators-cpp.md).
>
> Как при операции назначения, так и при операции инициализации выполняется копирование объектов.

- **Назначение**: когда значение одного объекта присваивается другому объекту, первый объект копируется во второй объект. Таким образом:

    ```cpp
    Point a, b;
    ...
    a = b;
    ```

   приводит к тому, что значение `b` копируется в значение `a`.

- **Инициализация**: инициализация происходит при объявлении нового объекта, когда аргументы передаются в функции по значению или когда значения возвращаются из функций по значению.

Можно определить семантику копии объектов типа класса. Рассмотрим для примера такой код:

```cpp
TextFile a, b;
a.Open( "FILE1.DAT" );
b.Open( "FILE2.DAT" );
b = a;
```

Предыдущий код может означать "копировать содержимое FILE1.DAT в FILE2.DAT" или "игнорировать FILE2.DAT и сделать `b` вторым дескриптором FILE1.DAT". Необходимо вложить соответствующую семантику копирования в каждый класс следующим образом.

- С помощью оператора присваивания **operator =** вместе со ссылкой на тип класса в качестве возвращаемого типа и параметра, передаваемого ссылкой **const** , например `ClassName& operator=(const ClassName& x);`.

- С помощью конструктора копии.

Если конструктор копии не объявлен, компилятор создает конструктор копии для каждого члена.  Если оператор присваивания копированием не объявлен, компилятор создает оператор присваивания копированием для каждого члена. Объявление конструктора копии не подавляет созданный компилятором оператор присваивания копий, и наоборот. При реализации любого из этих способов рекомендуется также реализовать другой способ, чтобы значение кода было четким.

Конструктор копий принимает аргумент типа <em>class-name</em> <strong>&</strong>, где *Class-Name* — это имя класса, для которого определен конструктор. Пример:

```cpp
// spec1_copying_class_objects.cpp
class Window
{
public:
    Window( const Window& ); // Declare copy constructor.
    // ...
};

int main()
{
}
```

> [!NOTE]
> Если это возможно, сделайте тип аргумента <em>-класса</em> **const** конструктора копии<strong>&</strong> . Это поможет избежать случайного изменения копируемого объекта конструктором копии. Он также позволяет копировать из **постоянных** объектов.

## <a name="compiler-generated-copy-constructors"></a>Конструкторы копии, создаваемые компилятором

Созданные компилятором конструкторы копий, такие как пользовательские конструкторы копий, имеют один аргумент типа "ссылка на *имя-класса*". Исключением является то, что все базовые классы и классы элементов имеют конструкторы копий, объявленные как принимающие один аргумент типа **const** <em>class-name</em> <strong>&</strong>. В этом случае аргумент конструктора копии, созданный компилятором, также является **константой**.

Если тип аргумента для конструктора копии не является **константой**, инициализация путем копирования объекта **const** приводит к ошибке. Обратная неверно: Если аргумент является **константой**, инициализацию можно выполнить путем копирования объекта, который не является **константой**.

Созданные компилятором операторы присваивания следуют тому же шаблону, что и для **const.** Они принимают один аргумент типа <em>class-name</em> <strong>&</strong> , если операторы присваивания во всех базовых классах и классов членов не принимают аргументы типа **const** <em>Class-Name</em> <strong>&</strong>. В этом случае созданный классом оператор присваивания принимает аргумент **const** .

> [!NOTE]
> Если виртуальные базовые классы инициализируются конструкторами копии, создаются компиляторами или определяются пользователем, они инициализируются только один раз, во время создания.

Последствия аналогичны тем, которые имеет конструктор копии. Если тип аргумента не является **константой**, присваивание из **константного** объекта приводит к ошибке. Обратная неверно: Если **константе** присваивается значение, которое не является **константой**, то назначение выполняется.

Дополнительные сведения о перегруженных операторах присваивания см. в разделе [назначение](../cpp/assignment.md).
