---
title: Исключения и освобождение стека в C++
ms.date: 11/04/2016
ms.assetid: a1a57eae-5fc5-4c49-824f-3ce2eb8129ed
ms.openlocfilehash: 5e094101557469a189311ce2c5344bb895696649
ms.sourcegitcommit: 1819bd2ff79fba7ec172504b9a34455c70c73f10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2018
ms.locfileid: "51330958"
---
# <a name="exceptions-and-stack-unwinding-in-c"></a>Исключения и освобождение стека в C++

В механизме исключений C++ элемент управления перемещается из оператора throw в первый оператор catch, который может обработать выданный тип. При достижении оператора catch все автоматические переменные, находящиеся в области между throw и операторов catch, удаляются в процессе, называемом *стека*. При очистке стека выполнение продолжается следующим образом.

1. Управление достигает **попробуйте** инструкции в процессе обычного последовательного выполнения. Выполняется защищенный раздел в **попробуйте** выполняется блок.

1. Если исключение не создается во время выполнения защищенного раздела, **catch** предложения, выполните **попробуйте** блок не выполняются. Выполнение продолжается с оператора после последнего **catch** предложение, следующего за связанным **попробуйте** блока.

1. Если исключение во время выполнения защищенного раздела или в любой процедуре, вызываемой прямо или косвенно, объект исключения создается из объекта, который создается путем **throw** операнд. (Это означает, что может быть задействован конструктор копии.) На этом этапе компилятор выполняет поиск **catch** предложение в высоком уровне контекста выполнения, который может обработать исключение типа, возникает исключение, или для **catch** обработчик, который может обрабатывать любой тип исключения. **Catch** обработчики проверяются в порядке их отображения после **попробуйте** блока. Если соответствующий обработчик не найден, следующий динамический внешний **попробуйте** проверке блока. Этот процесс продолжается до внешний **попробуйте** проверке блока.

1. Если соответствующий обработчик по-прежнему не найден или исключение возникает во время процесса очистки до получения элемента управления обработчиком, вызывается предопределенная функция времени выполнения `terminate`. Если исключение возникает после создания исключения, но до начала процесса очистки, вызывается функция `terminate`.

1. Если соответствующий **catch** обработчик найден и он выполняет перехват по значению, его формальный параметр инициализируется путем копирования объекта исключения. Если обработчик выполняет перехват по ссылке, параметр инициализируется для ссылки на объект исключения. После инициализации формального параметра начинается процесс очистки стека. Это включает в себя все деструкция автоматически создаваемых объектов, которые были полностью созданы — но еще не уничтожается — между началом **попробуйте** блок, который связан с **catch** обработчика и исключение возникновения исключения. Удаление происходит в порядке, обратном созданию. **Catch** выполняется обработчик и выполнение программы продолжается после последнего обработчика — то есть с первого оператора или конструкции, не **catch** обработчика. Элемент управления можно ввести только **catch** обработчик с использованием созданного исключения, никогда не через **goto** инструкции или **случай** метки в **переключения** инструкция.

## <a name="stack-unwinding-example"></a>Пример очистки стека

В следующем примере показано, как очистить стек при создании исключения. Выполнение потока переходит от оператора throw в `C` к оператору catch в `main`, и при этом удаляются все функции. Обратите внимание, что порядок создания и удаления объектов `Dummy` соответствует порядку их выхода из области видимости. Также обратите внимание, что завершается выполнение только функции `main`, содержащей оператор catch. Функция `A` никогда не возвращается после вызова `B()`, и `B` никогда не возвращается после вызова `C()`. Обратите внимание, что если раскомментировать определение указателя `Dummy` и соответствующую инструкцию DELETE, а затем запустить программу, указатель не удаляется. Это показывает, что может произойти, если функции не предоставляют гарантию исключения. Дополнительные сведения см. в разделе "Практическое руководство. Разработка исключений". Если закомментировать оператор catch, можно наблюдать за тем, что происходит при завершении выполнения программы в результате необработанного исключения.

```cpp
#include <string>
#include <iostream>
using namespace std;

class MyException{};
class Dummy
{
    public:
    Dummy(string s) : MyName(s) { PrintMsg("Created Dummy:"); }
    Dummy(const Dummy& other) : MyName(other.MyName){ PrintMsg("Copy created Dummy:"); }
    ~Dummy(){ PrintMsg("Destroyed Dummy:"); }
    void PrintMsg(string s) { cout << s  << MyName <<  endl; }
    string MyName;
    int level;
};

void C(Dummy d, int i)
{
    cout << "Entering FunctionC" << endl;
    d.MyName = " C";
    throw MyException();

    cout << "Exiting FunctionC" << endl;
}

void B(Dummy d, int i)
{
    cout << "Entering FunctionB" << endl;
    d.MyName = "B";
    C(d, i + 1);
    cout << "Exiting FunctionB" << endl;
}

void A(Dummy d, int i)
{
    cout << "Entering FunctionA" << endl;
    d.MyName = " A" ;
  //  Dummy* pd = new Dummy("new Dummy"); //Not exception safe!!!
    B(d, i + 1);
 //   delete pd;
    cout << "Exiting FunctionA" << endl;
}

int main()
{
    cout << "Entering main" << endl;
    try
    {
        Dummy d(" M");
        A(d,1);
    }
    catch (MyException& e)
    {
        cout << "Caught an exception of type: " << typeid(e).name() << endl;
    }

    cout << "Exiting main." << endl;
    char c;
    cin >> c;
}

/* Output:
    Entering main
    Created Dummy: M
    Copy created Dummy: M
    Entering FunctionA
    Copy created Dummy: A
    Entering FunctionB
    Copy created Dummy: B
    Entering FunctionC
    Destroyed Dummy: C
    Destroyed Dummy: B
    Destroyed Dummy: A
    Destroyed Dummy: M
    Caught an exception of type: class MyException
    Exiting main.

*/
```