---
title: Несколько базовых классов
ms.date: 11/19/2018
helpviewer_keywords:
- base classes [C++], multiple
- derived classes [C++], multiple bases
- multiple inheritance, class declaration
- multiple base classes [C++]
ms.assetid: a30c69fe-401c-4a87-96a0-e0da70c7c740
ms.openlocfilehash: 7cac70da5dd7093ce3e9c1cf3d2350d780c6b391
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81353732"
---
# <a name="multiple-base-classes"></a>Несколько базовых классов

Класс может быть получен из нескольких базовых классов. В модели с несколькими наследственными (где классы происходят из более чем одного базового класса) базовые классы определяются с помощью элемента грамматики *базового списка.* Например, объявление класса для `CollectionOfBook`, производного от `Collection` и `Book`, можно указать следующим образом.

```cpp
// deriv_MultipleBaseClasses.cpp
// compile with: /LD
class Collection {
};
class Book {};
class CollectionOfBook : public Book, public Collection {
    // New members
};
```

Порядок, в котором указываются базовые классы, не имеет значения, кроме некоторых случаев, когда вызываются конструкторы и деструкторы. В таких случаях порядок, в котором указываются базовые классы, влияет на следующее.

- Порядок, в котором конструктор выполняет инициализацию. Если код основан на том, что инициализация части `Book``CollectionOfBook` должна выполняться перед частью `Collection`, порядок указания важен. Инициализация происходит в порядке, указанном классами в *базовом списке.*

- Порядок, в котором вызываются деструкторы для очистки. Опять же, если определенная часть класса должна присутствовать, а другая часть должна быть удалена, порядок имеет значение. Деструкторов вызываются в обратном порядке классов, указанных в *базовом списке.*

    > [!NOTE]
    >  Порядок указания базовых классов может повлиять на структуру памяти класса. Не принимайте никаких программных решений на основе порядка базовых членов в памяти.

При указании *базового списка*не указано одно и то же имя класса более одного раза. Однако класс может стать косвенным базовым классом производного класса несколько раз.

## <a name="virtual-base-classes"></a>Виртуальные базовые классы

Поскольку класс может несколько раз выступать как косвенный базовый класс к производному классу, в C++ имеется способ оптимизировать функционирование таких базовых классов. Виртуальные базовые классы позволяют экономить пространство и исключать неоднозначности в иерархиях классов, в которых используется множественное наследование.

Каждый невиртуальный объект содержит копию элементов данных, определенных в базовом классе. Такой повтор данных приводит к ненужному увеличению их объема. Кроме того, при каждой попытке обращения к элементам базового класса приходится указывать, какая именно их копия требуется.

Если базовый класс определен как виртуальный базовый класс, то он может несколько раз выступать как косвенный базовый класс без дублирования элементов данных. Единственная копия его элементов данных совместно используется всеми базовыми классами, которые используют его как виртуальный базовый класс.

При объявлении виртуального базового класса **виртуальное** ключевое слово отображается в базовых списках выведенных классов.

Рассмотрим иерархию классов, представленную на следующем рисунке, на котором показана имитация графа Lunch-Line.

![Граф имитации очереди](../cpp/media/vc38xp1.gif "Граф имитации очереди") <br/>
Имитированный график линии обеда

Как видно на рисунке, класс `Queue` является базовым для двух других классов: `CashierQueue` и `LunchQueue`. Однако когда эти два класса объединяются и образуют класс `LunchCashierQueue`, возникает следующая проблема: новый класс содержит два подчиненных объекта типа `Queue` — один из `CashierQueue`, а другой из `LunchQueue`. На следующем рисунке показана концептуальная структура памяти (фактическая структура памяти может быть оптимизирована).

![Имитированный объект линии&#45;обед](../cpp/media/vc38xp2.gif "Имитированный объект линии&#45;обед") <br/>
Имитируемый объект очереди

Обратите внимание, что в объекте `Queue` имеется два подчиненных объекта `LunchCashierQueue`. В следующем коде содержится объявление `Queue` как виртуального базового класса:

```cpp
// deriv_VirtualBaseClasses.cpp
// compile with: /LD
class Queue {};
class CashierQueue : virtual public Queue {};
class LunchQueue : virtual public Queue {};
class LunchCashierQueue : public LunchQueue, public CashierQueue {};
```

**Виртуальное** ключевое слово гарантирует, что в `Queue` него включена только одна копия субобъекта (см. следующую цифру).

![Имитация обеденного&#45;объекта линии, виртуальных базовых классов](../cpp/media/vc38xp3.gif "Имитация обеденного&#45;объекта линии, виртуальных базовых классов") <br/>
Имитированный объект ланч-линии с виртуальными базовыми классами

Класс может иметь как виртуальный, так и невиртуальный компонент заданного типа. Это происходит при условиях, которые иллюстрирует следующий рисунок.

![Виртуальные и не&#45;виртуальные компоненты класса](../cpp/media/vc38xp4.gif "Виртуальные и не&#45;виртуальные компоненты класса") <br/>
Виртуальные и невиртуальные компоненты одного класса

На этом рисунке показано, что классы `CashierQueue` и `LunchQueue` используют `Queue` как виртуальный базовый класс. Однако `TakeoutQueue` определяет `Queue` в качестве базового класса, а не виртуального базового класса. Поэтому в `LunchTakeoutCashierQueue` имеется два подчиненных объекта типа `Queue`: один из пути наследования, включающего `LunchCashierQueue`, а второй из пути, включающего `TakeoutQueue`. Это показано на следующем рисунке.

![Виртуальный & не&#45;виртуальное наследование в макете объектов](../cpp/media/vc38xp5.gif "Виртуальный & не&#45;виртуальное наследование в макете объектов") <br/>
Макет объекта с виртуальным и невиртуальным наследованием

> [!NOTE]
> Наследование от виртуальных базовых классов позволяет существенно сократить объем данных по сравнению с наследованием от невиртуальных классов. Однако оно может породить дополнительные затраты на обработку.

Если производный класс переопределяет виртуальную функцию, которую он наследует от виртуального базового класса, и если конструктор или деструктор производного базового класса вызывает эту функцию при помощи указателя на виртуальный базовый класс, то компилятор может вставить дополнительные скрытые поля vtordisp в классы с виртуальными базовыми классами. Вариант `/vd0` компилятора подавляет добавление скрытого конструктора vtordisp/члена смещения destructor. Опция `/vd1` компилятора, по умолчанию, позволяет им там, где они необходимы. Добавление полей vtordisps следует отключать только в том случае, если точно известно, что все конструкторы и деструкторы классов вызывают виртуальные функции виртуально.

Опция `/vd` компилятора влияет на весь модуль компиляции. Используйте `vtordisp` прагму для подавления, а затем позывных `vtordisp` полей на основе класса к классу:

```cpp
#pragma vtordisp( off )
class GetReal : virtual public { ... };
\#pragma vtordisp( on )
```

## <a name="name-ambiguities"></a>Неоднозначность имен

Множественное наследование предоставляет возможность наследования имен по нескольким путям. Имена членов класса в этих путях не обязательно должны быть уникальными. Эти конфликты имен называются неоднозначностями.

Любое выражение, которое ссылается на член класса, должно иметь однозначную ссылку. В следующем примере показано, как появляются неоднозначности.

```cpp
// deriv_NameAmbiguities.cpp
// compile with: /LD
// Declare two base classes, A and B.
class A {
public:
    unsigned a;
    unsigned b();
};

class B {
public:
    unsigned a();  // Note that class A also has a member "a"
    int b();       //  and a member "b".
    char c;
};

// Define class C as derived from A and B.
class C : public A, public B {};
```

При наличии указанных выше объявлений класса код, такой как указано ниже, является неоднозначным, поскольку не ясно, ссылается ли `b` на `b` в `A` или в `B`.

```cpp
C *pc = new C;

pc->b();
```

Рассмотрим предыдущий пример. Поскольку имя `a` является членом обоих классов `A` и `B`, компилятор не может определить, какая переменная `a` обозначает функцию, которую необходимо вызвать. Доступ к члену неоднозначен, если он может ссылаться на несколько функций, объектов, типов или перечислителей.

Компилятор определяет неоднозначности, выполняя тесты в указанном порядке.

1. Если доступ к имени неоднозначен (как описано выше), создается сообщение об ошибке.

1. Если перегруженные функции однозначны, они разрешаются.

1. Если доступ к имени нарушает разрешение доступа к членам, создается сообщение об ошибке. (Для получения дополнительной [Member-Access Control](../cpp/member-access-control-cpp.md)информации см.

Если выражение приводит к неоднозначности в результате наследования, его можно разрешить вручную, указав вместо данного имени имя класса. Чтобы выполнить компиляцию в предыдущем примере без неоднозначностей, можно использовать следующий код.

```cpp
C *pc = new C;

pc->B::a();
```

> [!NOTE]
> Если объявлен `C`, могут возникнуть ошибки, если сослаться на `B` в области `C`. Однако ошибка не выдается, если не внести неквалифицированную ссылку на `B` в области `C`.

### <a name="dominance"></a>Доминирование

Через граф наследования можно достичь несколько имен (функции, объекта или перечислителя). С невиртуальными базовыми классами такие случаи неоднозначны. Они также неоднозначны с виртуальными базовыми классами, если одно из имен не доминирует над другими.

То или иное имя доминирует над другим, если оно определено в обоих классах и один класс является производным от другого. Доминирующее имя — это имя в производном классе; оно используется тогда, когда в противном случае возникла бы неоднозначность, как показано в следующем примере.

```cpp
// deriv_Dominance.cpp
// compile with: /LD
class A {
public:
    int a;
};

class B : public virtual A {
public:
    int a();
};

class C : public virtual A {};

class D : public B, public C {
public:
    D() { a(); } // Not ambiguous. B::a() dominates A::a.
};
```

### <a name="ambiguous-conversions"></a>Неоднозначные преобразования

Явные и неявные преобразования указателей и ссылок в типы класса могут приводить к неоднозначности. На следующем рисунке "Неоднозначное преобразование указателей в базовые классы" показано следующее:

- Объявление объекта типа `D`.

- Эффект применения адреса оператора ()**&** к этому объекту. Обратите внимание, что оператор взятия адреса всегда возвращает базовый адрес объекта.

- Результат явного преобразования указателя, полученного с помощью оператора взятия адреса, в тип базового класса `A`. Обратите внимание, что приведение адреса объекта к типу `A*` не всегда предоставляет компилятору достаточно информации о том, какой из типов подобъектов типа `A` следует выбрать; в данном случае существуют два подобъекта.

![Неоднозначное преобразование указателей в базовые классы](../cpp/media/vc38xt1.gif "Неоднозначное преобразование указателей в базовые классы") <br/>
Неоднозначное преобразование указателей в базовые классы

Преобразование в тип `A*` (указатель на `A`) является неоднозначным, поскольку нет способа определить, какой подобъект типа `A` является правильным. Обратите внимание, что неоднозначности можно избежать, явно указав используемый подобъект, как показано ниже:

```cpp
(A *)(B *)&d       // Use B subobject.
(A *)(C *)&d       // Use C subobject.
```

### <a name="ambiguities-and-virtual-base-classes"></a>Неоднозначности и виртуальные базовые классы

Если используются виртуальные базовые классы, доступ к функциям, объектам, типам и перечислениям можно получить по путям множественного наследования. Поскольку существует только один экземпляр базового класса, неоднозначность при доступе к этим именам отсутствует.

На следующем рисунке показано составление объектов с использованием виртуального и невиртуального наследования.

![Виртуальные производные и не&#45;виртуальные производные](../cpp/media/vc38xr1.gif "Виртуальные производные и не&#45;виртуальные производные") <br/>
Виртуальный против невиртуального произввода

На этом рисунке доступ к любому члену класса `A` через невиртуальная базовые классы вызывает неоднозначность; у компилятора нет сведений, поясняющих, нужно ли использовать вложенный объект, связанный с `B`, или вложенный объект, связанный с `C`. Однако если `A` задано как виртуальный базовый класс, вопросов о том, к какому из вложенных объектов осуществляется доступ, не возникает.

## <a name="see-also"></a>См. также раздел

[Наследование](../cpp/inheritance-cpp.md)
