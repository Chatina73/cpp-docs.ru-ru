---
title: Structured Exception Handling (C/C++)
ms.date: 08/14/2018
helpviewer_keywords:
- termination handlers [C++], handling exceptions in C++
- structured exception handling [C++]
- try-catch keyword [C++], exception handlers
- C++ exception handling, termination handlers
- try-catch keyword [C++], termination handlers
- C++ exception handling, exception handlers
ms.assetid: dd3b647d-c269-43a8-aab9-ad1458712976
ms.openlocfilehash: 01eaeaa57ee4d09452f37a7241f89e75fdca843e
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231108"
---
# <a name="structured-exception-handling-cc"></a>Structured Exception Handling (C/C++)

Структурированная обработка исключений (SEH) — это расширение Майкрософт для языка C для обработки определенных исключительных ситуаций кода, таких как ошибки оборудования, корректно. Хотя Windows и Microsoft C++ поддерживают SEH, мы рекомендуем использовать обработку исключений C++ в стандарте ISO, поскольку это делает код более переносимым и гибким. Тем не менее, для поддержки существующего кода или определенных типов программ все равно может потребоваться использовать SEH.

**Зависит от корпорации Майкрософт:**

## <a name="grammar"></a>Грамматика

*try-except-оператор* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**__try** *compound-statement* **`__except`** *составной оператор* __try составной инструкции **(** *Expression* **)**

*try-finally-оператор* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**__try** *compound-statement* **`__finally`** *составной* оператор составного оператора

## <a name="remarks"></a>Remarks

С помощью SEH можно убедиться, что ресурсы, такие как блоки памяти и файлы, освобождаются правильно, если выполнение неожиданно завершается. Можно также решить определенные проблемы (например, недостаток памяти) с помощью кратко структурированного кода, не зависящего от **`goto`** инструкций или тщательного тестирования кодов возврата.

Операторы try-except и try-finally, которые упоминаются в этом разделе, являются расширениями языка C для систем Microsoft. Они поддерживают SEH, позволяя приложениям получать контроль над программой после событий, которые в иных ситуациях привели бы к завершению выполнения. Хотя обработка ошибок SEH работает с исходными файлами C++, она не была создана специально для этого языка. При использовании SEH в программе C++, компилируемой с помощью параметра [/EHa или/EHsc](../build/reference/eh-exception-handling-model.md) , деструкторы для локальных объектов вызываются, но другое поведение выполнения может отличаться от ожидаемого. Иллюстрации см. в примере далее в этой статье. В большинстве случаев вместо SEH рекомендуется использовать [обработку исключений C++](../cpp/try-throw-and-catch-statements-cpp.md)в стандарте ISO, которую также поддерживает компилятор Microsoft C++. С помощью обработки исключений C++ можно повысить переносимость кода и обрабатывать исключения любого типа.

При наличии кода C, использующего SEH, можно смешивать его с кодом C++, использующим обработку исключений C++. Дополнительные сведения см. [в разделе Handle Structured Exceptions in C++](../cpp/exception-handling-differences.md).

Существует два механизма SEH.

- [Обработчики исключений](../cpp/writing-an-exception-handler.md)или **`__except`** блоки, которые могут реагировать на исключение или закрыть его.

- [Обработчики завершения](../cpp/writing-a-termination-handler.md)или **`__finally`** блоки, которые вызываются всегда, если исключение вызывает завершение или нет.

Эти два типа обработчиков различаются, однако тесно взаимодействию в процессе, который называется "развертыванием стека". При возникновении структурированного исключения Windows ищет недавно установленный обработчик исключений, который сейчас является активным. Обработчик может выполнить одно из трех действий:

- не распознать исключение и передать управление другим обработчикам;

- распознать исключение, но отбросить его;

- распознать исключение и обработать его.

Обработчик исключений, распознавший исключение, может находиться за пределами функции, которая выполнялась, когда возникло исключение. В некоторых случаях он может находиться в функции, хранящейся гораздо выше по стеку. Выполняемая в настоящее время функция и все прочие функции в кадре стека завершаются. В ходе этого процесса стек будет "развернут;", т. е. локальные нестатические переменные завершенных функций удаляются из стека.

По мере развертывания стека операционная система вызывает все обработчики завершения, которые были написаны для каждой функции. При помощи обработчиков завершения можно освободить ресурсы, которые в противном случае оставались бы открытыми ненормального завершения. Если вы ввели критическую секцию, вы можете выйти из него в обработчике завершения. Если ожидается завершение программы, можно выполнить другие задачи обслуживания, например закрыть и удалить временные файлы.

## <a name="next-steps"></a>Дальнейшие шаги

- [Написание обработчика исключений](../cpp/writing-an-exception-handler.md)

- [Написание обработчика завершения](../cpp/writing-a-termination-handler.md)

- [Обработка структурированных исключений в C++](../cpp/exception-handling-differences.md)

## <a name="example"></a>Пример

Как упоминалось ранее, деструкторы для локальных объектов вызываются, если вы используете SEH в программе C++ и компилируете его с помощью параметра **/EHa** или **/EHsc** . Однако если при этом используются исключения C++, то поведение во время выполнения может отличаться от ожидаемого. В этом примере демонстрируются эти различия в поведении.

```cpp
#include <stdio.h>
#include <Windows.h>
#include <exception>

class TestClass
{
public:
    ~TestClass()
    {
        printf("Destroying TestClass!\r\n");
    }
};

__declspec(noinline) void TestCPPEX()
{
#ifdef CPPEX
    printf("Throwing C++ exception\r\n");
    throw std::exception("");
#else
    printf("Triggering SEH exception\r\n");
    volatile int *pInt = 0x00000000;
    *pInt = 20;
#endif
}

__declspec(noinline) void TestExceptions()
{
    TestClass d;
    TestCPPEX();
}

int main()
{
    __try
    {
        TestExceptions();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("Executing SEH __except block\r\n");
    }

    return 0;
}
```

Если для компиляции этого кода используется параметр **/EHsc** , но локальный макрос элемента управления теста `CPPEX` не определен, то выполнение деструктора не выполняется, `TestClass` и выходные данные выглядят следующим образом:

```Output
Triggering SEH exception
Executing SEH __except block
```

Если для компиляции кода используется параметр **/EHsc** и `CPPEX` он определен с помощью `/DCPPEX` (так что создается исключение C++), `TestClass` деструктор выполняется, а выходные данные выглядят следующим образом:

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Если для компиляции кода используется параметр **/EHa** , `TestClass` деструктор выполняется вне зависимости от того, было ли создано исключение с помощью или с `std::throw` помощью SEH для активации исключения, то есть независимо от того, определен ли параметр `CPPEX` или нет. Выходные данные выглядят следующим образом:

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Дополнительные сведения см. в статье [/EH (модель обработки исключений)](../build/reference/eh-exception-handling-model.md).

**Завершение для конкретной корпорации Майкрософт**

## <a name="see-also"></a>См. также статью

[Обработка исключений](../cpp/exception-handling-in-visual-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[\<exception>](../standard-library/exception.md)<br/>
[Обработка ошибок и исключений](../cpp/errors-and-exception-handling-modern-cpp.md)<br/>
[Структурированная обработка исключений (Windows)](/windows/win32/debug/structured-exception-handling)
