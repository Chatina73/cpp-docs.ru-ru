---
title: Structured Exception Handling (C/C++)
ms.date: 08/14/2018
helpviewer_keywords:
- termination handlers [C++], handling exceptions in C++
- structured exception handling [C++]
- try-catch keyword [C++], exception handlers
- C++ exception handling, termination handlers
- try-catch keyword [C++], termination handlers
- C++ exception handling, exception handlers
ms.assetid: dd3b647d-c269-43a8-aab9-ad1458712976
ms.openlocfilehash: b77a218340399578e3c9428100476787e2e60b25
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62330574"
---
# <a name="structured-exception-handling-cc"></a>Structured Exception Handling (C/C++)

Структурированная обработка исключений (SEH) является расширением Microsoft для C для корректной обработки определенных ситуациях код поддержки исключений, например, сбоев оборудования. Несмотря на то, что Windows и Visual C++ поддерживают SEH, мы рекомендуем использовать обработка исключений C++ в соответствии со стандартом ISO, так как он делает код более переносимость и гибкость. Тем не менее чтобы сохранить существующий код или для программ определенных видов, вы по-прежнему может потребоваться использовать SEH.

**Системам Майкрософт:**

## <a name="grammar"></a>Грамматика

*try-except-statement* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**__try** *compound-statement* **__except** **(** *expression* **)** *compound-statement*

*try-finally-statement* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;**__try** *compound-statement* **__finally** *compound-statement*

## <a name="remarks"></a>Примечания

С SEH можно гарантировать, что правильно ресурсы, такие как блоки памяти и файлы будут освобождены, если непредвиденного завершения программы. Можно также обрабатывать конкретные проблемы, например, нехватки памяти — с помощью краткого структурированного кода, который не зависит от **goto** инструкций или длительного тестирования кодов возврата.

Операторы try-except и try-finally, которые упоминаются в этом разделе, являются расширениями языка C для систем Microsoft. Они поддерживают SEH, позволяя приложениям получать контроль над программой после событий, которые в иных ситуациях привели бы к завершению выполнения. Хотя обработка ошибок SEH работает с исходными файлами C++, она не была создана специально для этого языка. Если SEH используется в программе C++, компиляция выполняется с помощью [/EHa или/EHsc](../build/reference/eh-exception-handling-model.md) параметр, деструкторы для локальных объектов вызываются, однако прочие аспекты выполнения могут не соответствовать ожиданиям. Иллюстрация см. пример далее в этой статье. В большинстве случаев вместо SHE рекомендуется использовать со стандартом ISO [обработки исключений C++](../cpp/try-throw-and-catch-statements-cpp.md), который также поддерживается Visual C++. С помощью обработки исключений C++ можно повысить переносимость кода и обрабатывать исключения любого типа.

Если у вас есть код C, который использует SEH, вы можете объединять с кодом C++, использующего обработку исключений C++. Сведения см. в разделе [обрабатывать структурированные исключения в C++](../cpp/exception-handling-differences.md).

Существует два механизма SEH.

- [Обработчики исключений](../cpp/writing-an-exception-handler.md), или **__except** блоками, которые можно реагировать на исключение или отбрасывать его.

- [Обработчики завершения](../cpp/writing-a-termination-handler.md), или **__finally** блоками, которые всегда вызываются, ли исключение вызывает завершение или нет.

Эти два типа обработчиков различаются, однако тесно взаимодействию в процессе, который называется "развертыванием стека". При возникновении структурированное исключение, Windows выполняет поиск последнего установленного обработчик исключений, который в данный момент активна. Обработчик может выполнить одно из трех действий:

- не распознать исключение и передать управление другим обработчикам;

- распознать исключение, но отбросить его;

- распознать исключение и обработать его.

Обработчик исключений, распознавший исключение, может находиться за пределами функции, которая выполнялась, когда возникло исключение. В некоторых случаях он может находиться в функции, хранящейся гораздо выше по стеку. Выполняемая в настоящее время функция и все прочие функции в кадре стека завершаются. В ходе этого процесса стек освобождается «;» то есть локальные переменные нестатических завершенные функции будут удалены из стека.

По мере развертывания стека операционная система вызывает все обработчики завершения, которые были написаны для каждой функции. При помощи обработчиков завершения можно освободить ресурсы, которые в противном случае оставались бы открытыми ненормального завершения. Если вы ввели критической секции, вы можете выйти из в обработчик завершения. Если ожидается завершение программы, можно выполнить другие задачи обслуживания, например закрыть и удалить временные файлы.

## <a name="next-steps"></a>Следующие шаги

- [Написание обработчика исключений](../cpp/writing-an-exception-handler.md)

- [Написание обработчика завершения](../cpp/writing-a-termination-handler.md)

- [Обработка структурированных исключений в C++](../cpp/exception-handling-differences.md)

## <a name="example"></a>Пример

Как упоминалось выше, деструкторы для локальных объектов вызываются в том случае, если вы используете SEH в программе на языке C++ и скомпилируйте его с помощью **/EHa** или **/EHsc** параметр. Однако если при этом используются исключения C++, то поведение во время выполнения может отличаться от ожидаемого. В этом примере демонстрируется это различие в поведении.

```cpp
#include <stdio.h>
#include <Windows.h>
#include <exception>

class TestClass
{
public:
    ~TestClass()
    {
        printf("Destroying TestClass!\r\n");
    }
};

__declspec(noinline) void TestCPPEX()
{
#ifdef CPPEX
    printf("Throwing C++ exception\r\n");
    throw std::exception("");
#else
    printf("Triggering SEH exception\r\n");
    volatile int *pInt = 0x00000000;
    *pInt = 20;
#endif
}

__declspec(noinline) void TestExceptions()
{
    TestClass d;
    TestCPPEX();
}

int main()
{
    __try
    {
        TestExceptions();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("Executing SEH __except block\r\n");
    }

    return 0;
}
```

При использовании **/EHsc** Чтобы скомпилировать этот код, но макрос локального тестирования управления `CPPEX` — не указано, есть без выполнения `TestClass` деструктор и вывод выглядит следующим образом:

```Output
Triggering SEH exception
Executing SEH __except block
```

Если вы используете **/EHsc** для компиляции кода и `CPPEX` определяется с помощью `/DCPPEX` (таким образом, создается исключение C++), `TestClass` деструктора и вывод выглядит следующим образом:

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Если вы используете **/EHa** для компиляции кода, `TestClass` деструктора независимо от того, возникло ли исключение с помощью `std::throw` или с помощью SEH исключений, то есть ли `CPPEX` определенные или нет. Вывод выглядит следующим образом.

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Дополнительные сведения см. в статье [/EH (модель обработки исключений)](../build/reference/eh-exception-handling-model.md).

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Обработка исключений](../cpp/exception-handling-in-visual-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[\<exception>](../standard-library/exception.md)<br/>
[Обработка ошибок и исключений](../cpp/errors-and-exception-handling-modern-cpp.md)<br/>
[Структурированные исключения, обработка (Windows)](https://msdn.microsoft.com/library/windows/desktop/ms680657.aspx)
