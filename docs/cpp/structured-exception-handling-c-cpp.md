---
title: Structured Exception Handling (C/C++)
ms.date: 08/14/2018
helpviewer_keywords:
- termination handlers [C++], handling exceptions in C++
- structured exception handling [C++]
- try-catch keyword [C++], exception handlers
- C++ exception handling, termination handlers
- try-catch keyword [C++], termination handlers
- C++ exception handling, exception handlers
ms.assetid: dd3b647d-c269-43a8-aab9-ad1458712976
ms.openlocfilehash: 4555690476bc149687c680fc2baae53b96658a4e
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69498485"
---
# <a name="structured-exception-handling-cc"></a>Structured Exception Handling (C/C++)

Структурированная обработка исключений (SEH) — это расширение Майкрософт для языка C для обработки определенных исключительных ситуаций кода, таких как ошибки оборудования, корректно. Несмотря на то что C++ Windows и Microsoft поддерживают SEH, рекомендуется использовать стандартную C++ обработку исключений ISO, так как это делает код более переносимым и гибким. Тем не менее, для поддержки существующего кода или определенных типов программ все равно может потребоваться использовать SEH.

**Специально для Майкрософт:**

## <a name="grammar"></a>Грамматика

*try-except-statement* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp; **__try** *compound-statement* **__except** **(** *expression* **)** *compound-statement*

*try-finally-оператор* :<br/>
&nbsp;&nbsp;&nbsp;&nbsp; **__try** *составной оператор* **__finally** *составной оператор*

## <a name="remarks"></a>Примечания

С помощью SEH можно убедиться, что ресурсы, такие как блоки памяти и файлы, освобождаются правильно, если выполнение неожиданно завершается. Можно также решить определенные проблемы (например, недостаток памяти) с помощью кратко структурированного кода, не зависящего от инструкций **goto** или тщательного тестирования кодов возврата.

Операторы try-except и try-finally, которые упоминаются в этом разделе, являются расширениями языка C для систем Microsoft. Они поддерживают SEH, позволяя приложениям получать контроль над программой после событий, которые в иных ситуациях привели бы к завершению выполнения. Хотя обработка ошибок SEH работает с исходными файлами C++, она не была создана специально для этого языка. Если SEH используется в C++ программе, компилируемой с параметром [/EHa или/EHsc](../build/reference/eh-exception-handling-model.md) , то деструкторы для локальных объектов вызываются, но другое поведение выполнения может отличаться от ожидаемого. Иллюстрации см. в примере далее в этой статье. В большинстве случаев вместо SEH рекомендуется использовать стандартную [ C++ обработку исключений](../cpp/try-throw-and-catch-statements-cpp.md)ISO, которую также поддерживает компилятор Майкрософт C++ . С помощью обработки исключений C++ можно повысить переносимость кода и обрабатывать исключения любого типа.

При наличии кода C, использующего SEH, можно смешивать его с C++ кодом, использующим C++ обработку исключений. Дополнительные сведения см. [в разделе Handle Structured C++Exceptions in ](../cpp/exception-handling-differences.md).

Существует два механизма SEH.

- [Обработчики исключений](../cpp/writing-an-exception-handler.md)или блокировки **__except** , которые могут реагировать на исключение или закрыть его.

- [Обработчики завершения](../cpp/writing-a-termination-handler.md)или блоки **__finally** , которые вызываются всегда, являются ли исключение причиной завершения или нет.

Эти два типа обработчиков различаются, однако тесно взаимодействию в процессе, который называется "развертыванием стека". При возникновении структурированного исключения Windows ищет недавно установленный обработчик исключений, который сейчас является активным. Обработчик может выполнить одно из трех действий:

- не распознать исключение и передать управление другим обработчикам;

- распознать исключение, но отбросить его;

- распознать исключение и обработать его.

Обработчик исключений, распознавший исключение, может находиться за пределами функции, которая выполнялась, когда возникло исключение. В некоторых случаях он может находиться в функции, хранящейся гораздо выше по стеку. Выполняемая в настоящее время функция и все прочие функции в кадре стека завершаются. В ходе этого процесса стек будет "развернут;", т. е. локальные нестатические переменные завершенных функций удаляются из стека.

По мере развертывания стека операционная система вызывает все обработчики завершения, которые были написаны для каждой функции. При помощи обработчиков завершения можно освободить ресурсы, которые в противном случае оставались бы открытыми ненормального завершения. Если вы ввели критическую секцию, вы можете выйти из него в обработчике завершения. Если ожидается завершение программы, можно выполнить другие задачи обслуживания, например закрыть и удалить временные файлы.

## <a name="next-steps"></a>Следующие шаги

- [Написание обработчика исключений](../cpp/writing-an-exception-handler.md)

- [Написание обработчика завершения](../cpp/writing-a-termination-handler.md)

- [Обработка структурированных исключений в C++](../cpp/exception-handling-differences.md)

## <a name="example"></a>Пример

Как упоминалось ранее, деструкторы для локальных объектов вызываются при использовании SEH в C++ программе и его компиляции с помощью параметра **/EHa** или **/EHsc** . Однако если при этом используются исключения C++, то поведение во время выполнения может отличаться от ожидаемого. В этом примере демонстрируются эти различия в поведении.

```cpp
#include <stdio.h>
#include <Windows.h>
#include <exception>

class TestClass
{
public:
    ~TestClass()
    {
        printf("Destroying TestClass!\r\n");
    }
};

__declspec(noinline) void TestCPPEX()
{
#ifdef CPPEX
    printf("Throwing C++ exception\r\n");
    throw std::exception("");
#else
    printf("Triggering SEH exception\r\n");
    volatile int *pInt = 0x00000000;
    *pInt = 20;
#endif
}

__declspec(noinline) void TestExceptions()
{
    TestClass d;
    TestCPPEX();
}

int main()
{
    __try
    {
        TestExceptions();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("Executing SEH __except block\r\n");
    }

    return 0;
}
```

Если для компиляции этого кода используется параметр **/EHsc** , но локальный макрос `CPPEX` элемента управления теста не определен, то выполнение `TestClass` деструктора не выполняется, и выходные данные выглядят следующим образом:

```Output
Triggering SEH exception
Executing SEH __except block
```

Если для компиляции кода используется параметр **/EHsc** и `CPPEX` он определен с помощью `/DCPPEX` (так что создается C++ исключение), `TestClass` деструктор выполняется и выходные данные выглядят следующим образом:

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Если для компиляции кода используется параметр **/EHa** `TestClass` , деструктор выполняется вне зависимости от того, было ли создано исключение с помощью `std::throw` или с помощью SEH для активации исключения, то есть независимо от того, определен `CPPEX` ли параметр или нет. Вывод выглядит следующим образом.

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Дополнительные сведения см. в статье [/EH (модель обработки исключений)](../build/reference/eh-exception-handling-model.md).

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Обработка исключений](../cpp/exception-handling-in-visual-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[\<exception>](../standard-library/exception.md)<br/>
[Ошибки и обработка исключений](../cpp/errors-and-exception-handling-modern-cpp.md)<br/>
[Структурированная обработка исключений (Windows)](/windows/win32/debug/structured-exception-handling)
