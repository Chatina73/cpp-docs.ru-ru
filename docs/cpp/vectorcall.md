---
title: __vectorcall
ms.date: 12/17/2018
f1_keywords:
- __vectorcall_cpp
- __vectorcall
- _vectorcall
helpviewer_keywords:
- __vectorcall keyword
- __vectorcall
ms.assetid: 1c95ed59-86c6-4857-b4ed-10519193f851
ms.openlocfilehash: c933f995c57094b28e477e439c7b9ff5a13c2063
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80187522"
---
# <a name="__vectorcall"></a>__vectorcall

**Блок, относящийся только к системам Microsoft**

Соглашение о вызовах **__vectorcall** указывает, что аргументы функции должны передаваться в регистры, если это возможно. **__vectorcall** использует больше регистров для аргументов, чем [__fastcall](../cpp/fastcall.md) или используемое по умолчанию [соглашение о вызовах x64](../build/x64-calling-convention.md) . Соглашение о вызовах **__vectorcall** поддерживается только в машинном коде на процессорах x86 и x64, включающих Streaming SIMD Extensions 2 (SSE2) и более поздних версий. Используйте **__vectorcall** для ускорения функций, которые передают несколько аргументов вектора с плавающей запятой или SIMD, и выполняют операции, которые используют преимущества аргументов, загруженных в регистры. В следующем списке перечислены функции, общие для реализаций **__vectorcall**x86 и x64. Различия объясняются ниже в этом разделе.

|Элемент|Реализация|
|-------------|--------------------|
|Соглашение об оформлении имен C|Имена функций добавляются в суффикс с двумя знаками "at" (\@\@), за которыми следует число байтов (в десятичной системе) в списке параметров.|
|Соглашение о преобразовании регистра|Преобразование регистра не выполняется.|

Использование параметра компилятора [/GV](../build/reference/gd-gr-gv-gz-calling-convention.md) приводит к тому, что каждая функция в модуле компилируется как **__vectorcall** , если только функция не является функцией-членом, объявляется с конфликтующим атрибутом соглашения о вызове, использует список аргументов `vararg` переменной или имеет имя `main`.

Можно передать три типа аргументов путем регистрации в функциях **__vectorcall** : *целочисленные значения типа* , значения *векторного типа* и *однородные векторные* значения (Хва).

Целочисленный тип удовлетворяет двум требованиям: он соответствует размеру собственного регистра процессора (например, 4 байта на компьютере с архитектурой x86 или 8 байт на компьютере с архитектурой x64) и его можно преобразовывать в целое число с длиной, соответствующей длине регистра, и обратно без изменения его битового представления. Например, любой тип, который может быть повышен до **int** на платформе x86 (**Long** в x64), например **char** или **Short**, или который может быть приведен к типу **int** (**Long** в x64), а исходный тип без изменений — целочисленный тип. Целочисленные типы включают указатель, ссылку, типы **структуры** или **объединения** 4 байта (8 байт в x64) или меньше. На платформах x64 более крупные типы **структуры** и **объединения** передаются по ссылке на память, выделенную вызывающей стороной; на платформах x86 они передаются по значению в стеке.

Тип Vector — это либо тип с плавающей запятой, например **float** или **Double**, либо тип вектора SIMD, например **__m128** или **__m256**.

Тип HVA — это составной тип, в котором может содержаться до 4 элементов данных, имеющих идентичные векторные типы. Тип HVA предъявляет то же требование к выравниванию, что и векторный тип его членов. Это пример определения **структуры** Хва, которая содержит три одинаковых векторных типа и имеет 32-байтное выравнивание:

```cpp
typedef struct {
   __m256 x;
   __m256 y;
   __m256 z;
} hva3;    // 3 element HVA type on __m256
```

Объявите функции явным образом с помощью ключевого слова **__vectorcall** в файлах заголовков, чтобы разрешать компоновку независимо скомпилированного кода без ошибок. Функции должны создавать прототипы для использования **__vectorcall**и не могут использовать `vararg` список аргументов переменной длины.

Функцию-член можно объявить с помощью описателя **__vectorcall** . Скрытый **этот** указатель передается функцией Register в качестве первого аргумента целочисленного типа.

На компьютерах ARM **__vectorcall** принимается и игнорируется компилятором.

Если используется внестрочное определение нестатической функции-члена класса, то модификатор соглашения о вызовах не должен быть задан во внестрочном определении. То есть для нестатических членов класса считается, что соглашение о вызовах, указанное во время объявления, было сделано в точке определения. Рассмотрим следующее определение класса:

```cpp
struct MyClass {
   void __vectorcall mymethod();
};
```

В этом случае следующий код:

```cpp
void MyClass::mymethod() { return; }
```

эквивалентен следующему:

```cpp
void __vectorcall MyClass::mymethod() { return; }
```

При создании указателя на функцию **__vectorcall** необходимо указать модификатор соглашения о вызове **__vectorcall** . В следующем примере создается **typedef** для указателя на функцию **__vectorcall** , которая принимает четыре аргумента **double** и возвращает значение **__m256** :

```cpp
typedef __m256 (__vectorcall * vcfnptr)(double, double, double, double);
```

Для совместимости с предыдущими версиями **_vectorcall** является синонимом для **__vectorcall** , если только не указан параметр компилятора [/Za \(отключить расширения языка)](../build/reference/za-ze-disable-language-extensions.md) .

## <a name="__vectorcall-convention-on-x64"></a>Соглашение о вызовах __vectorcall для архитектуры x64

Соглашение о вызовах **__vectorcall** в x64 расширяет стандартное соглашение о вызовах x64 для использования дополнительных регистров. Аргументы как целочисленного, так и векторного типа сопоставляются с регистрами исходя из позиции в списке аргументов. Аргументы HVA назначаются неиспользуемым векторным регистрам.

Если любые из первых четырех аргументов в порядке слева направо являются целочисленными, они передаются в регистрах, соответствующих их позициям: RCX, RDX, R8 или R9. Скрытый **этот** указатель считается первым аргументом целочисленного типа. Если аргумент HVA на одной из первых четырех позиций не может быть передан в доступных регистрах, вместо него в соответствующем регистре для целочисленных значений передается ссылка на память, выделенную вызывающим объектом. Аргументы целочисленного типа, расположенные за четвертой позицией в списке параметров, передаются в стеке.

Если любые из первых шести аргументов в порядке слева направо являются аргументами векторного типа, они передаются по значению в векторных регистрах SSE 0–5, соответствующих их позициям. Типы с плавающей запятой и **__m128** передаются в регистрах XMM, а типы **__m256** передаются в регистры ИММ. В этом состоит отличие от стандартного соглашения о вызовах x64, так как векторные типы передаются по значению, а не по ссылкам; кроме того, используются дополнительные регистры. Пространство теневого стека, выделенное для аргументов векторного типа, зафиксировано в 8 байт, а параметр [/homeparams](../build/reference/homeparams-copy-register-parameters-to-stack.md) не применяется. Аргументы векторного типа начиная с седьмой позиции в списке параметров передаются в стеке по ссылке на память, выделенную вызывающим объектом.

После выделения регистров для векторных аргументов элементы данных в аргументах Хва выделяются в порядке возрастания на неиспользуемые векторные регистры XMM0 в XMM5 (или YMM0 в YMM5 для типов **__m256** ), если доступно достаточное количество регистров для всего Хва. Если регистров недостаточно, аргумент HVA передается по ссылке на память, выделенную вызывающим объектом. Пространство теневого стека, выделенное для аргументов типа HVA, имеет фиксированный размер 8 байт с неопределенным содержимым. Аргументы HVA назначаются регистрам в порядке слева направо в списке параметров и могут находиться в любой позиции. Аргументы HVA, находящиеся на одной из первых четырех позиций в списке аргументов и не назначенные векторным регистрам, передаются по ссылке в целочисленном регистре, соответствующем их позициям. Аргументы HVA, переданные по ссылке после четвертой позиции в списке параметров, помещаются в стек.

Результаты функций **__vectorcall** возвращаются по значению в регистрах, если это возможно. Результаты целочисленных типов, включая struct и union размером 8 байт и менее, возвращаются по значению в RAX. Результаты векторного типа возвращаются по значению в XMM0 или YMM0 в зависимости от их размера. В результатах HVA каждый элемент данных возвращается по значению в регистрах XMM0:XMM3 или YMM0:YMM3 в зависимости от размера элемента. Типы результатов, которые не помещаются в соответствующее регистры, возвращаются по ссылке на память, выделенную вызывающим объектом.

Стек поддерживается вызывающим объектом в реализации платформы x64 **__vectorcall**. Код пролога и эпилога вызывающего объекта выделяет и очищает стек для вызываемой функции. Аргументы помещаются в стек в порядке справа налево, а для аргументов, передаваемых в регистрах, выделяется пространство теневого стека.

Примеры:

```cpp
// crt_vc64.c
// Build for amd64 with: cl /arch:AVX /W3 /FAs crt_vc64.c
// This example creates an annotated assembly listing in
// crt_vc64.asm.

#include <intrin.h>
#include <xmmintrin.h>

typedef struct {
   __m128 array[2];
} hva2;    // 2 element HVA type on __m128

typedef struct {
   __m256 array[4];
} hva4;    // 4 element HVA type on __m256

// Example 1: All vectors
// Passes a in XMM0, b in XMM1, c in YMM2, d in XMM3, e in YMM4.
// Return value in XMM0.
__m128 __vectorcall
example1(__m128 a, __m128 b, __m256 c, __m128 d, __m256 e) {
   return d;
}

// Example 2: Mixed int, float and vector parameters
// Passes a in RCX, b in XMM1, c in R8, d in XMM3, e in YMM4,
// f in XMM5, g pushed on stack.
// Return value in YMM0.
__m256 __vectorcall
example2(int a, __m128 b, int c, __m128 d, __m256 e, float f, int g) {
   return e;
}

// Example 3: Mixed int and HVA parameters
// Passes a in RCX, c in R8, d in R9, and e pushed on stack.
// Passes b by element in [XMM0:XMM1];
// b's stack shadow area is 8-bytes of undefined value.
// Return value in XMM0.
__m128 __vectorcall example3(int a, hva2 b, int c, int d, int e) {
   return b.array[0];
}

// Example 4: Discontiguous HVA
// Passes a in RCX, b in XMM1, d in XMM3, and e is pushed on stack.
// Passes c by element in [YMM0,YMM2,YMM4,YMM5], discontiguous because
// vector arguments b and d were allocated first.
// Shadow area for c is an 8-byte undefined value.
// Return value in XMM0.
float __vectorcall example4(int a, float b, hva4 c, __m128 d, int e) {
   return b;
}

// Example 5: Multiple HVA arguments
// Passes a in RCX, c in R8, e pushed on stack.
// Passes b in [XMM0:XMM1], d in [YMM2:YMM5], each with
// stack shadow areas of an 8-byte undefined value.
// Return value in RAX.
int __vectorcall example5(int a, hva2 b, int c, hva4 d, int e) {
   return c + e;
}

// Example 6: HVA argument passed by reference, returned by register
// Passes a in [XMM0:XMM1], b passed by reference in RDX, c in YMM2,
// d in [XMM3:XMM4].
// Register space was insufficient for b, but not for d.
// Return value in [YMM0:YMM3].
hva4 __vectorcall example6(hva2 a, hva4 b, __m256 c, hva2 d) {
   return b;
}

int __cdecl main( void )
{
   hva4 h4;
   hva2 h2;
   int i;
   float f;
   __m128 a, b, d;
   __m256 c, e;

   a = b = d = _mm_set1_ps(3.0f);
   c = e = _mm256_set1_ps(5.0f);
   h2.array[0] = _mm_set1_ps(6.0f);
   h4.array[0] = _mm256_set1_ps(7.0f);

   b = example1(a, b, c, d, e);
   e = example2(1, b, 3, d, e, 6.0f, 7);
   d = example3(1, h2, 3, 4, 5);
   f = example4(1, 2.0f, h4, d, 5);
   i = example5(1, h2, 3, h4, 5);
   h4 = example6(h2, h4, c, h2);
}
```

## <a name="__vectorcall-convention-on-x86"></a>Соглашение о вызовах __vectorcall для архитектуры x86

Соглашение о вызовах **__vectorcall** соответствует соглашению **__fastcall** для аргументов целочисленного типа 32-bit и использует преимущества регистров вектора SSE для векторного типа и аргументов Хва.

Первые два целочисленных аргумента, встреченные в списке параметров в порядке слева направо, помещаются в регистры ECX и EDX соответственно. Скрытый **этот** указатель рассматривается как аргумент первого целочисленного типа и передается в ECX. Первые шесть аргументов векторного типа передаются по значению через векторные регистры SSE 0–5 в регистры XMM или YMM в зависимости от размера аргумента.

Первые шесть аргументов векторного типа в порядке слева направо передаются по значению в векторных регистрах SSE 0–5. Типы с плавающей запятой и **__m128** передаются в регистрах XMM, а типы **__m256** передаются в регистры ИММ. Для аргументов векторного типа, которые передаются через регистр, пространство теневого стека не выделяется. Аргументы векторного типа начиная с седьмой позиции в списке передаются в стек по ссылке на память, выделенную вызывающим объектом. Ограничение на ошибку компилятора [C2719](../error-messages/compiler-errors-2/compiler-error-c2719.md) не применяется к этим аргументам.

После выделения регистров для векторных аргументов элементы данных в аргументах Хва выделяются в порядке возрастания на неиспользуемые векторные регистры XMM0 в XMM5 (или YMM0 в YMM5, для типов **__m256** ), если доступно достаточное количество регистров для всего Хва. Если регистров недостаточно, аргумент HVA передается в стек по ссылке на память, выделенную вызывающим объектом. Пространство теневого стека аргументу HVA не выделяется. Аргументы HVA назначаются регистрам в порядке слева направо в списке параметров и могут находиться в любой позиции.

Результаты функций **__vectorcall** возвращаются по значению в регистрах, если это возможно. Результаты целочисленных типов, включая structs и union размером 4 байт и менее, возвращаются по значению в EAX. Структуры или объединения целочисленного типа размером 8 байт или менее возвращаются по значению в регистрах EDX:EAX. Результаты векторного типа возвращаются по значению в XMM0 или YMM0 в зависимости от их размера. В результатах HVA каждый элемент данных возвращается по значению в регистрах XMM0:XMM3 или YMM0:YMM3 в зависимости от размера элемента. Результаты других типов возвращаются по ссылке на память, выделенную вызывающим объектом.

Реализация **__vectorcall** x86 соответствует соглашению о аргументах, помещаемых в стек справа налево вызывающим объектом, а вызываемая функция очищает стек непосредственно перед возвратом. В стек передаются только те аргументы, которые не помещаются в регистры.

Примеры:

```cpp
// crt_vc86.c
// Build for x86 with: cl /arch:AVX /W3 /FAs crt_vc86.c
// This example creates an annotated assembly listing in
// crt_vc86.asm.

#include <intrin.h>
#include <xmmintrin.h>

typedef struct {
   __m128 array[2];
} hva2;    // 2 element HVA type on __m128

typedef struct {
   __m256 array[4];
} hva4;    // 4 element HVA type on __m256

// Example 1: All vectors
// Passes a in XMM0, b in XMM1, c in YMM2, d in XMM3, e in YMM4.
// Return value in XMM0.
__m128 __vectorcall
example1(__m128 a, __m128 b, __m256 c, __m128 d, __m256 e) {
   return d;
}

// Example 2: Mixed int, float and vector parameters
// Passes a in ECX, b in XMM0, c in EDX, d in XMM1, e in YMM2,
// f in XMM3, g pushed on stack.
// Return value in YMM0.
__m256 __vectorcall
example2(int a, __m128 b, int c, __m128 d, __m256 e, float f, int g) {
   return e;
}

// Example 3: Mixed int and HVA parameters
// Passes a in ECX, c in EDX, d and e pushed on stack.
// Passes b by element in [XMM0:XMM1].
// Return value in XMM0.
__m128 __vectorcall example3(int a, hva2 b, int c, int d, int e) {
   return b.array[0];
}

// Example 4: HVA assigned after vector types
// Passes a in ECX, b in XMM0, d in XMM1, and e in EDX.
// Passes c by element in [YMM2:YMM5].
// Return value in XMM0.
float __vectorcall example4(int a, float b, hva4 c, __m128 d, int e) {
   return b;
}

// Example 5: Multiple HVA arguments
// Passes a in ECX, c in EDX, e pushed on stack.
// Passes b in [XMM0:XMM1], d in [YMM2:YMM5].
// Return value in EAX.
int __vectorcall example5(int a, hva2 b, int c, hva4 d, int e) {
   return c + e;
}

// Example 6: HVA argument passed by reference, returned by register
// Passes a in [XMM1:XMM2], b passed by reference in ECX, c in YMM0,
// d in [XMM3:XMM4].
// Register space was insufficient for b, but not for d.
// Return value in [YMM0:YMM3].
hva4 __vectorcall example6(hva2 a, hva4 b, __m256 c, hva2 d) {
   return b;
}

int __cdecl main( void )
{
   hva4 h4;
   hva2 h2;
   int i;
   float f;
   __m128 a, b, d;
   __m256 c, e;

   a = b = d = _mm_set1_ps(3.0f);
   c = e = _mm256_set1_ps(5.0f);
   h2.array[0] = _mm_set1_ps(6.0f);
   h4.array[0] = _mm256_set1_ps(7.0f);

   b = example1(a, b, c, d, e);
   e = example2(1, b, 3, d, e, 6.0f, 7);
   d = example3(1, h2, 3, 4, 5);
   f = example4(1, 2.0f, h4, d, 5);
   i = example5(1, h2, 3, h4, 5);
   h4 = example6(h2, h4, c, h2);
}
```

**End Microsoft Specific**

## <a name="see-also"></a>См. также раздел

[Передача аргументов и соглашения об именовании](../cpp/argument-passing-and-naming-conventions.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)
