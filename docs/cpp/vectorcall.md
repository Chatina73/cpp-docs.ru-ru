---
description: 'Дополнительные сведения: __vectorcall'
title: __vectorcall
ms.date: 12/17/2018
f1_keywords:
- __vectorcall_cpp
- __vectorcall
- _vectorcall
helpviewer_keywords:
- __vectorcall keyword
- __vectorcall
ms.assetid: 1c95ed59-86c6-4857-b4ed-10519193f851
ms.openlocfilehash: 223576b7aec37434cb9574d744e9ebc1b9aa88f9
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97210976"
---
# <a name="__vectorcall"></a>__vectorcall

**Блок, относящийся только к системам Microsoft**

**`__vectorcall`** Соглашение о вызовах указывает, что аргументы функции должны передаваться в регистры, если это возможно. **`__vectorcall`** использует больше регистров для аргументов [`__fastcall`](../cpp/fastcall.md) , чем или используемое по умолчанию [соглашение о вызовах x64](../build/x64-calling-convention.md) . **`__vectorcall`** Соглашение о вызовах поддерживается только в машинном коде на процессорах x86 и x64, включающих Streaming SIMD Extensions 2 (SSE2) и более поздних версий. Используйте **`__vectorcall`** для ускорения функций, которые передают несколько аргументов вектора с плавающей запятой или SIMD, и выполняют операции, использующие преимущества аргументов, загруженных в регистры. В следующем списке перечислены функции, общие для реализаций x86 и x64 **`__vectorcall`** . Различия объясняются ниже в этом разделе.

|Элемент|Реализация|
|-------------|--------------------|
|Соглашение об оформлении имен C|Имена функций добавляются в суффикс с двумя знаками "at" ( \@ \@ ), за которыми следует число байтов (в десятичной системе) в списке параметров.|
|Соглашение о преобразовании регистра|Преобразование регистра не выполняется.|

Использование [`/Gv`](../build/reference/gd-gr-gv-gz-calling-convention.md) параметра компилятора приводит к тому, что каждая функция в модуле будет компилироваться так, как если бы она **`__vectorcall`** не была функцией-членом, объявлена с конфликтующим атрибутом соглашения о вызове, использует `vararg` список аргументов переменной или имеет имя `main` .

Можно передать три типа аргументов путем регистрации в **`__vectorcall`** функциях: значения *целочисленного типа* , значения *векторного типа* и *однородные векторные* значения (Хва).

Целочисленный тип удовлетворяет двум требованиям: он соответствует размеру собственного регистра процессора (например, 4 байта на компьютере с архитектурой x86 или 8 байт на компьютере с архитектурой x64) и его можно преобразовывать в целое число с длиной, соответствующей длине регистра, и обратно без изменения его битового представления. Например, любой тип, который можно повысить до версии **`int`** x86 ( **`long long`** в x64), например, или или **`char`** **`short`** , который можно привести к **`int`** ( **`long long`** в x64) и вернуть исходный тип без изменений, является целочисленным типом. Целочисленные типы включают указатель, ссылку и **`struct`** **`union`** типы 4 байт (8 байт на x64) или меньше. На платформах x64 больший размер **`struct`** и **`union`** типы передаются по ссылке на память, выделенную вызывающей стороной; на платформах x86 они передаются по значению в стеке.

Тип Vector является либо типом с плавающей запятой (например,, либо **`float`** **`double`** ), либо типом ВЕКТОРа SIMD, например, **`__m128`** или **`__m256`** .

Тип HVA — это составной тип, в котором может содержаться до 4 элементов данных, имеющих идентичные векторные типы. Тип HVA предъявляет то же требование к выравниванию, что и векторный тип его членов. Это пример **`struct`** определения Хва, которое содержит три одинаковых векторных типа и имеет 32-байтное выравнивание:

```cpp
typedef struct {
   __m256 x;
   __m256 y;
   __m256 z;
} hva3;    // 3 element HVA type on __m256
```

Объявите функции явным образом с помощью **`__vectorcall`** ключевого слова в файлах заголовков, чтобы разрешить компоновку независимо скомпилированного кода без ошибок. Функции должны иметь прототипы для использования **`__vectorcall`** и не могут использовать `vararg` список аргументов переменной длины.

Функцию-член можно объявить с помощью **`__vectorcall`** описателя. Скрытый **`this`** Указатель передается функцией Register в качестве первого аргумента целочисленного типа.

На компьютерах ARM **`__vectorcall`** принимается и игнорируется компилятором.

Если используется внестрочное определение нестатической функции-члена класса, то модификатор соглашения о вызовах не должен быть задан во внестрочном определении. То есть для нестатических членов класса считается, что соглашение о вызовах, указанное во время объявления, было сделано в точке определения. Рассмотрим следующее определение класса:

```cpp
struct MyClass {
   void __vectorcall mymethod();
};
```

В этом случае следующий код:

```cpp
void MyClass::mymethod() { return; }
```

эквивалентен следующему:

```cpp
void __vectorcall MyClass::mymethod() { return; }
```

**`__vectorcall`** При создании указателя на функцию необходимо указать модификатор соглашения о вызовах **`__vectorcall`** . В следующем примере создается **`typedef`** для указателя на **`__vectorcall`** функцию, которая принимает четыре **`double`** аргумента и возвращает **`__m256`** значение.

```cpp
typedef __m256 (__vectorcall * vcfnptr)(double, double, double, double);
```

Для совместимости с предыдущими версиями аргумент **`_vectorcall`** является синонимом, **`__vectorcall`** если только параметр компилятора не [ `/Za` \( отключает расширения языка)](../build/reference/za-ze-disable-language-extensions.md) .

## <a name="__vectorcall-convention-on-x64"></a>Соглашение о вызовах __vectorcall для архитектуры x64

**`__vectorcall`** Соглашение о вызовах в x64 расширяет стандартное соглашение о вызовах x64, чтобы воспользоваться преимуществами дополнительных регистров. Аргументы как целочисленного, так и векторного типа сопоставляются с регистрами исходя из позиции в списке аргументов. Аргументы HVA назначаются неиспользуемым векторным регистрам.

Если любые из первых четырех аргументов в порядке слева направо являются целочисленными, они передаются в регистрах, соответствующих их позициям: RCX, RDX, R8 или R9. Скрытый **`this`** указатель рассматривается как аргумент первого целочисленного типа. Если аргумент HVA на одной из первых четырех позиций не может быть передан в доступных регистрах, вместо него в соответствующем регистре для целочисленных значений передается ссылка на память, выделенную вызывающим объектом. Аргументы целочисленного типа, расположенные за четвертой позицией в списке параметров, передаются в стеке.

Если любые из первых шести аргументов в порядке слева направо являются аргументами векторного типа, они передаются по значению в векторных регистрах SSE 0–5, соответствующих их позициям. Операции с плавающей запятой и **`__m128`** типы передаются в регистрах XMM, а **`__m256`** типы передаются в регистры ИММ. В этом состоит отличие от стандартного соглашения о вызовах x64, так как векторные типы передаются по значению, а не по ссылкам; кроме того, используются дополнительные регистры. Пространство теневого стека, выделенное для аргументов векторного типа, фиксировано в 8 байт, а [`/homeparams`](../build/reference/homeparams-copy-register-parameters-to-stack.md) параметр не применяется. Аргументы векторного типа начиная с седьмой позиции в списке параметров передаются в стеке по ссылке на память, выделенную вызывающим объектом.

После выделения регистров для векторных аргументов элементы данных в аргументах Хва выделяются в порядке возрастания на неиспользуемые векторные регистры XMM0 в XMM5 (или YMM0 в YMM5, для **`__m256`** типов), если для всего Хва доступно достаточно регистров. Если регистров недостаточно, аргумент HVA передается по ссылке на память, выделенную вызывающим объектом. Пространство теневого стека, выделенное для аргументов типа HVA, имеет фиксированный размер 8 байт с неопределенным содержимым. Аргументы HVA назначаются регистрам в порядке слева направо в списке параметров и могут находиться в любой позиции. Аргументы HVA, находящиеся на одной из первых четырех позиций в списке аргументов и не назначенные векторным регистрам, передаются по ссылке в целочисленном регистре, соответствующем их позициям. Аргументы HVA, переданные по ссылке после четвертой позиции в списке параметров, помещаются в стек.

Результаты **`__vectorcall`** функций возвращаются по значению в регистрах, если это возможно. Результаты целочисленных типов, включая struct и union размером 8 байт и менее, возвращаются по значению в RAX. Результаты векторного типа возвращаются по значению в XMM0 или YMM0 в зависимости от их размера. В результатах HVA каждый элемент данных возвращается по значению в регистрах XMM0:XMM3 или YMM0:YMM3 в зависимости от размера элемента. Типы результатов, которые не помещаются в соответствующее регистры, возвращаются по ссылке на память, выделенную вызывающим объектом.

Стек поддерживается вызывающим объектом в реализации x64 **`__vectorcall`** . Код пролога и эпилога вызывающего объекта выделяет и очищает стек для вызываемой функции. Аргументы помещаются в стек в порядке справа налево, а для аргументов, передаваемых в регистрах, выделяется пространство теневого стека.

Примеры:

```cpp
// crt_vc64.c
// Build for amd64 with: cl /arch:AVX /W3 /FAs crt_vc64.c
// This example creates an annotated assembly listing in
// crt_vc64.asm.

#include <intrin.h>
#include <xmmintrin.h>

typedef struct {
   __m128 array[2];
} hva2;    // 2 element HVA type on __m128

typedef struct {
   __m256 array[4];
} hva4;    // 4 element HVA type on __m256

// Example 1: All vectors
// Passes a in XMM0, b in XMM1, c in YMM2, d in XMM3, e in YMM4.
// Return value in XMM0.
__m128 __vectorcall
example1(__m128 a, __m128 b, __m256 c, __m128 d, __m256 e) {
   return d;
}

// Example 2: Mixed int, float and vector parameters
// Passes a in RCX, b in XMM1, c in R8, d in XMM3, e in YMM4,
// f in XMM5, g pushed on stack.
// Return value in YMM0.
__m256 __vectorcall
example2(int a, __m128 b, int c, __m128 d, __m256 e, float f, int g) {
   return e;
}

// Example 3: Mixed int and HVA parameters
// Passes a in RCX, c in R8, d in R9, and e pushed on stack.
// Passes b by element in [XMM0:XMM1];
// b's stack shadow area is 8-bytes of undefined value.
// Return value in XMM0.
__m128 __vectorcall example3(int a, hva2 b, int c, int d, int e) {
   return b.array[0];
}

// Example 4: Discontiguous HVA
// Passes a in RCX, b in XMM1, d in XMM3, and e is pushed on stack.
// Passes c by element in [YMM0,YMM2,YMM4,YMM5], discontiguous because
// vector arguments b and d were allocated first.
// Shadow area for c is an 8-byte undefined value.
// Return value in XMM0.
float __vectorcall example4(int a, float b, hva4 c, __m128 d, int e) {
   return b;
}

// Example 5: Multiple HVA arguments
// Passes a in RCX, c in R8, e pushed on stack.
// Passes b in [XMM0:XMM1], d in [YMM2:YMM5], each with
// stack shadow areas of an 8-byte undefined value.
// Return value in RAX.
int __vectorcall example5(int a, hva2 b, int c, hva4 d, int e) {
   return c + e;
}

// Example 6: HVA argument passed by reference, returned by register
// Passes a in [XMM0:XMM1], b passed by reference in RDX, c in YMM2,
// d in [XMM3:XMM4].
// Register space was insufficient for b, but not for d.
// Return value in [YMM0:YMM3].
hva4 __vectorcall example6(hva2 a, hva4 b, __m256 c, hva2 d) {
   return b;
}

int __cdecl main( void )
{
   hva4 h4;
   hva2 h2;
   int i;
   float f;
   __m128 a, b, d;
   __m256 c, e;

   a = b = d = _mm_set1_ps(3.0f);
   c = e = _mm256_set1_ps(5.0f);
   h2.array[0] = _mm_set1_ps(6.0f);
   h4.array[0] = _mm256_set1_ps(7.0f);

   b = example1(a, b, c, d, e);
   e = example2(1, b, 3, d, e, 6.0f, 7);
   d = example3(1, h2, 3, 4, 5);
   f = example4(1, 2.0f, h4, d, 5);
   i = example5(1, h2, 3, h4, 5);
   h4 = example6(h2, h4, c, h2);
}
```

## <a name="__vectorcall-convention-on-x86"></a>Соглашение о вызовах __vectorcall для архитектуры x86

**`__vectorcall`** Соглашение о вызовах соответствует **`__fastcall`** соглашению для аргументов 32-разрядного целочисленного типа и использует преимущества регистров вектора SSE для векторного типа и аргументов Хва.

Первые два целочисленных аргумента, встреченные в списке параметров в порядке слева направо, помещаются в регистры ECX и EDX соответственно. Скрытый **`this`** указатель рассматривается как аргумент первого целочисленного типа и передается в ECX. Первые шесть аргументов векторного типа передаются по значению через векторные регистры SSE 0–5 в регистры XMM или YMM в зависимости от размера аргумента.

Первые шесть аргументов векторного типа в порядке слева направо передаются по значению в векторных регистрах SSE 0–5. Операции с плавающей запятой и **`__m128`** типы передаются в регистрах XMM, а **`__m256`** типы передаются в регистры ИММ. Для аргументов векторного типа, которые передаются через регистр, пространство теневого стека не выделяется. Аргументы векторного типа начиная с седьмой позиции в списке передаются в стек по ссылке на память, выделенную вызывающим объектом. Ограничение на ошибку компилятора [C2719](../error-messages/compiler-errors-2/compiler-error-c2719.md) не применяется к этим аргументам.

После выделения регистров для векторных аргументов элементы данных в аргументах Хва выделяются в порядке возрастания на неиспользуемые векторы XMM0 в XMM5 (или YMM0 в YMM5, для **`__m256`** типов), если доступно достаточное количество регистров для всего Хва. Если регистров недостаточно, аргумент HVA передается в стек по ссылке на память, выделенную вызывающим объектом. Пространство теневого стека аргументу HVA не выделяется. Аргументы HVA назначаются регистрам в порядке слева направо в списке параметров и могут находиться в любой позиции.

Результаты **`__vectorcall`** функций возвращаются по значению в регистрах, если это возможно. Результаты целочисленных типов, включая structs и union размером 4 байт и менее, возвращаются по значению в EAX. Структуры или объединения целочисленного типа размером 8 байт или менее возвращаются по значению в регистрах EDX:EAX. Результаты векторного типа возвращаются по значению в XMM0 или YMM0 в зависимости от их размера. В результатах HVA каждый элемент данных возвращается по значению в регистрах XMM0:XMM3 или YMM0:YMM3 в зависимости от размера элемента. Результаты других типов возвращаются по ссылке на память, выделенную вызывающим объектом.

Реализация x86 **`__vectorcall`** соответствует соглашению о аргументах, передаваемых в стеке справа налево вызывающим объектом, а вызываемая функция очищает стек непосредственно перед возвратом. В стек передаются только те аргументы, которые не помещаются в регистры.

Примеры:

```cpp
// crt_vc86.c
// Build for x86 with: cl /arch:AVX /W3 /FAs crt_vc86.c
// This example creates an annotated assembly listing in
// crt_vc86.asm.

#include <intrin.h>
#include <xmmintrin.h>

typedef struct {
   __m128 array[2];
} hva2;    // 2 element HVA type on __m128

typedef struct {
   __m256 array[4];
} hva4;    // 4 element HVA type on __m256

// Example 1: All vectors
// Passes a in XMM0, b in XMM1, c in YMM2, d in XMM3, e in YMM4.
// Return value in XMM0.
__m128 __vectorcall
example1(__m128 a, __m128 b, __m256 c, __m128 d, __m256 e) {
   return d;
}

// Example 2: Mixed int, float and vector parameters
// Passes a in ECX, b in XMM0, c in EDX, d in XMM1, e in YMM2,
// f in XMM3, g pushed on stack.
// Return value in YMM0.
__m256 __vectorcall
example2(int a, __m128 b, int c, __m128 d, __m256 e, float f, int g) {
   return e;
}

// Example 3: Mixed int and HVA parameters
// Passes a in ECX, c in EDX, d and e pushed on stack.
// Passes b by element in [XMM0:XMM1].
// Return value in XMM0.
__m128 __vectorcall example3(int a, hva2 b, int c, int d, int e) {
   return b.array[0];
}

// Example 4: HVA assigned after vector types
// Passes a in ECX, b in XMM0, d in XMM1, and e in EDX.
// Passes c by element in [YMM2:YMM5].
// Return value in XMM0.
float __vectorcall example4(int a, float b, hva4 c, __m128 d, int e) {
   return b;
}

// Example 5: Multiple HVA arguments
// Passes a in ECX, c in EDX, e pushed on stack.
// Passes b in [XMM0:XMM1], d in [YMM2:YMM5].
// Return value in EAX.
int __vectorcall example5(int a, hva2 b, int c, hva4 d, int e) {
   return c + e;
}

// Example 6: HVA argument passed by reference, returned by register
// Passes a in [XMM1:XMM2], b passed by reference in ECX, c in YMM0,
// d in [XMM3:XMM4].
// Register space was insufficient for b, but not for d.
// Return value in [YMM0:YMM3].
hva4 __vectorcall example6(hva2 a, hva4 b, __m256 c, hva2 d) {
   return b;
}

int __cdecl main( void )
{
   hva4 h4;
   hva2 h2;
   int i;
   float f;
   __m128 a, b, d;
   __m256 c, e;

   a = b = d = _mm_set1_ps(3.0f);
   c = e = _mm256_set1_ps(5.0f);
   h2.array[0] = _mm_set1_ps(6.0f);
   h4.array[0] = _mm256_set1_ps(7.0f);

   b = example1(a, b, c, d, e);
   e = example2(1, b, 3, d, e, 6.0f, 7);
   d = example3(1, h2, 3, 4, 5);
   f = example4(1, 2.0f, h4, d, 5);
   i = example5(1, h2, 3, h4, 5);
   h4 = example6(h2, h4, c, h2);
}
```

**Завершение Microsoft для конкретных**

## <a name="see-also"></a>См. также раздел

[Передача аргументов и соглашения именования](../cpp/argument-passing-and-naming-conventions.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)
