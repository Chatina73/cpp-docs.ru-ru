---
title: __vectorcall
ms.date: 12/17/2018
f1_keywords:
- __vectorcall_cpp
- __vectorcall
- _vectorcall
helpviewer_keywords:
- __vectorcall keyword
- __vectorcall
ms.assetid: 1c95ed59-86c6-4857-b4ed-10519193f851
ms.openlocfilehash: 55c383c4bdf83ddb5fdf1c4990d5f2e47b4d819a
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62393887"
---
# <a name="vectorcall"></a>__vectorcall

**Блок, относящийся только к системам Microsoft**

**__Vectorcall** соглашение о вызовах указывает аргументы для функции должны передаваться в регистрах, когда это возможно. **__vectorcall** использует больше регистров для аргументов, чем [__fastcall](../cpp/fastcall.md) или значение по умолчанию [x64 соглашение о вызовах](../build/x64-calling-convention.md) использовать. **__Vectorcall** соглашение о вызовах поддерживается только в машинном коде на x86 и x64 процессорах, имеющих Streaming SIMD Extensions 2 (SSE2) и более поздних версий. Используйте **__vectorcall** ускорить функций, передающих несколько с плавающей запятой или векторных аргументов SIMD и выполнять операции, использующие преимущества аргументы, загружаемым в регистрах. В следующем списке приведены возможности, которые являются общими для реализации x86 и x64 **__vectorcall**. Различия объясняются ниже в этом разделе.

|Элемент|Реализация|
|-------------|--------------------|
|Соглашение об оформлении имен C|Имена функций добавляется суффикс с «» символов (\@\@) за которым следует число байтов (в десятичном формате) в списке параметров.|
|Соглашение о преобразовании регистра|Преобразование регистра не выполняется.|

С помощью [/Gv](../build/reference/gd-gr-gv-gz-calling-convention.md) параметр компилятора приводит к каждой функции в модуле компилируется как **__vectorcall** Если функция является функцией-членом, объявлена с конфликтующим атрибутом соглашения вызывающего, использует `vararg` переменные списки аргументов, или имеет имя `main`.

Можно передавать 3 типа аргументов, зарегистрируйтесь в **__vectorcall** функции: *целочисленный тип* значения, *векторным типом* значения, и *гомогенные векторные Агрегатные* значения (HVA).

Целочисленный тип удовлетворяет двум требованиям: он соответствует размеру собственного регистра процессора (например, 4 байта на компьютере с архитектурой x86 или 8 байт на компьютере с архитектурой x64) и его можно преобразовывать в целое число с длиной, соответствующей длине регистра, и обратно без изменения его битового представления. Например, любой тип, который может быть повышена до **int** на x86 (**long long** в x64) — например, **char** или **короткие**— или, может быть приведен к **int** (**long long** в x64) и обратно к его исходному типу без изменения имеет целочисленный тип. Целочисленным типам относятся указатель, ссылка и **структуры** или **объединение** типы размером 4 байт (8 байт в x64) или меньше. В x64 платформ, большего размера **структуры** и **объединение** типы передаются по ссылке на память, выделенную вызывающим объектом; на x86 платформ, они передаются по значению в стеке.

Является векторным типом является либо типом с плавающей запятой — например, **float** или **двойные**— или векторный тип SIMD — например, **__m128** или **__m256**.

Тип HVA — это составной тип, в котором может содержаться до 4 элементов данных, имеющих идентичные векторные типы. Тип HVA предъявляет то же требование к выравниванию, что и векторный тип его членов. Это пример HVA **структуры** определения, который содержит 3 идентичных векторных типа и имеет 32-байтное выравнивание:

```cpp
typedef struct {
   __m256 x;
   __m256 y;
   __m256 z;
} hva3;    // 3 element HVA type on __m256
```

Явным образом с помощью функции необходимо объявлять **__vectorcall** ключевое слово в файлы заголовка, чтобы отдельно скомпилированный код мог компоноваться без ошибок. Функции должны быть прототипом для использования **__vectorcall**и не может использовать `vararg` список аргументов переменной длины.

Функция-член может быть объявлена с помощью **__vectorcall** спецификатор. Скрытый **это** указателя передается через регистр как первый аргумент целочисленного типа.

На компьютерах ARM **__vectorcall** принимается и игнорируется компилятором.

Если используется внестрочное определение нестатической функции-члена класса, то модификатор соглашения о вызовах не должен быть задан во внестрочном определении. То есть для нестатических членов класса считается, что соглашение о вызовах, указанное во время объявления, было сделано в точке определения. Рассмотрим следующее определение класса:

```cpp
struct MyClass {
   void __vectorcall mymethod();
};
```

В этом случае следующий код:

```cpp
void MyClass::mymethod() { return; }
```

эквивалентен следующему:

```cpp
void __vectorcall MyClass::mymethod() { return; }
```

**__Vectorcall** модификатор соглашения о вызовах должен быть указан при создании указателя на **__vectorcall** будет создана функция. В следующем примере создается **typedef** для указателя на **__vectorcall** функция, которая принимает четыре **двойные** аргументы и возвращает **__m256**значение:

```cpp
typedef __m256 (__vectorcall * vcfnptr)(double, double, double, double);
```

Для совместимости с предыдущими версиями **_vectorcall** является синонимом **__vectorcall** Если параметр компилятора [/Za \(отключить расширения языка)](../build/reference/za-ze-disable-language-extensions.md)указан.

## <a name="vectorcall-convention-on-x64"></a>Соглашение о вызовах __vectorcall для архитектуры x64

**__Vectorcall** соглашение о вызовах в x64 расширяет стандартные x64 вызовах, чтобы воспользоваться преимуществами дополнительные регистры. Аргументы как целочисленного, так и векторного типа сопоставляются с регистрами исходя из позиции в списке аргументов. Аргументы HVA назначаются неиспользуемым векторным регистрам.

Если любые из первых четырех аргументов в порядке слева направо являются целочисленными, они передаются в регистрах, соответствующих их позициям: RCX, RDX, R8 или R9. Скрытый **это** указатель рассматривается как первый аргумент целочисленного типа. Если аргумент HVA на одной из первых четырех позиций не может быть передан в доступных регистрах, вместо него в соответствующем регистре для целочисленных значений передается ссылка на память, выделенную вызывающим объектом. Аргументы целочисленного типа, расположенные за четвертой позицией в списке параметров, передаются в стеке.

Если любые из первых шести аргументов в порядке слева направо являются аргументами векторного типа, они передаются по значению в векторных регистрах SSE 0–5, соответствующих их позициям. С плавающей запятой и **__m128** типы передаются в регистрах XMM, а **__m256** типы передаются в регистрах YMM регистрирует. В этом состоит отличие от стандартного соглашения о вызовах x64, так как векторные типы передаются по значению, а не по ссылкам; кроме того, используются дополнительные регистры. Пространство теневого стека, выделенное для аргументов векторного типа имеет фиксированный размер 8 байт и [/homeparams](../build/reference/homeparams-copy-register-parameters-to-stack.md) параметр не применяется. Аргументы векторного типа начиная с седьмой позиции в списке параметров передаются в стеке по ссылке на память, выделенную вызывающим объектом.

После распределения регистры для векторных аргументов элементы данных из аргументов типа HVA выделяются по возрастанию, по неиспользуемым векторным регистрам XMM0 – XMM5 (или YMM0 – YMM5 — для **__m256** типы), при условии, что имеется достаточно регистров доступно для распределения всего значения HVA. Если регистров недостаточно, аргумент HVA передается по ссылке на память, выделенную вызывающим объектом. Пространство теневого стека, выделенное для аргументов типа HVA, имеет фиксированный размер 8 байт с неопределенным содержимым. Аргументы HVA назначаются регистрам в порядке слева направо в списке параметров и могут находиться в любой позиции. Аргументы HVA, находящиеся на одной из первых четырех позиций в списке аргументов и не назначенные векторным регистрам, передаются по ссылке в целочисленном регистре, соответствующем их позициям. Аргументы HVA, переданные по ссылке после четвертой позиции в списке параметров, помещаются в стек.

Результаты **__vectorcall** функции возвращаются по значению в регистрах. Результаты целочисленных типов, включая struct и union размером 8 байт и менее, возвращаются по значению в RAX. Результаты векторного типа возвращаются по значению в XMM0 или YMM0 в зависимости от их размера. В результатах HVA каждый элемент данных возвращается по значению в регистрах XMM0:XMM3 или YMM0:YMM3 в зависимости от размера элемента. Типы результатов, которые не помещаются в соответствующее регистры, возвращаются по ссылке на память, выделенную вызывающим объектом.

Стек поддерживается вызывающим x64 реализация **__vectorcall**. Код пролога и эпилога вызывающего объекта выделяет и очищает стек для вызываемой функции. Аргументы помещаются в стек в порядке справа налево, а для аргументов, передаваемых в регистрах, выделяется пространство теневого стека.

Примеры

```cpp
// crt_vc64.c
// Build for amd64 with: cl /arch:AVX /W3 /FAs crt_vc64.c
// This example creates an annotated assembly listing in
// crt_vc64.asm.

#include <intrin.h>
#include <xmmintrin.h>

typedef struct {
   __m128 array[2];
} hva2;    // 2 element HVA type on __m128

typedef struct {
   __m256 array[4];
} hva4;    // 4 element HVA type on __m256

// Example 1: All vectors
// Passes a in XMM0, b in XMM1, c in YMM2, d in XMM3, e in YMM4.
// Return value in XMM0.
__m128 __vectorcall
example1(__m128 a, __m128 b, __m256 c, __m128 d, __m256 e) {
   return d;
}

// Example 2: Mixed int, float and vector parameters
// Passes a in RCX, b in XMM1, c in R8, d in XMM3, e in YMM4,
// f in XMM5, g pushed on stack.
// Return value in YMM0.
__m256 __vectorcall
example2(int a, __m128 b, int c, __m128 d, __m256 e, float f, int g) {
   return e;
}

// Example 3: Mixed int and HVA parameters
// Passes a in RCX, c in R8, d in R9, and e pushed on stack.
// Passes b by element in [XMM0:XMM1];
// b's stack shadow area is 8-bytes of undefined value.
// Return value in XMM0.
__m128 __vectorcall example3(int a, hva2 b, int c, int d, int e) {
   return b.array[0];
}

// Example 4: Discontiguous HVA
// Passes a in RCX, b in XMM1, d in XMM3, and e is pushed on stack.
// Passes c by element in [YMM0,YMM2,YMM4,YMM5], discontiguous because
// vector arguments b and d were allocated first.
// Shadow area for c is an 8-byte undefined value.
// Return value in XMM0.
float __vectorcall example4(int a, float b, hva4 c, __m128 d, int e) {
   return b;
}

// Example 5: Multiple HVA arguments
// Passes a in RCX, c in R8, e pushed on stack.
// Passes b in [XMM0:XMM1], d in [YMM2:YMM5], each with
// stack shadow areas of an 8-byte undefined value.
// Return value in RAX.
int __vectorcall example5(int a, hva2 b, int c, hva4 d, int e) {
   return c + e;
}

// Example 6: HVA argument passed by reference, returned by register
// Passes a in [XMM0:XMM1], b passed by reference in RDX, c in YMM2,
// d in [XMM3:XMM4].
// Register space was insufficient for b, but not for d.
// Return value in [YMM0:YMM3].
hva4 __vectorcall example6(hva2 a, hva4 b, __m256 c, hva2 d) {
   return b;
}

int __cdecl main( void )
{
   hva4 h4;
   hva2 h2;
   int i;
   float f;
   __m128 a, b, d;
   __m256 c, e;

   a = b = d = _mm_set1_ps(3.0f);
   c = e = _mm256_set1_ps(5.0f);
   h2.array[0] = _mm_set1_ps(6.0f);
   h4.array[0] = _mm256_set1_ps(7.0f);

   b = example1(a, b, c, d, e);
   e = example2(1, b, 3, d, e, 6.0f, 7);
   d = example3(1, h2, 3, 4, 5);
   f = example4(1, 2.0f, h4, d, 5);
   i = example5(1, h2, 3, h4, 5);
   h4 = example6(h2, h4, c, h2);
}
```

## <a name="vectorcall-convention-on-x86"></a>Соглашение о вызовах __vectorcall для архитектуры x86

**__Vectorcall** следующим соглашение о вызове **__fastcall** соглашение для 32-разрядное целое число аргументов типов, а также используются преимущества Векторные регистры SSE для аргументов векторного типа и аргументов HVA.

Первые два целочисленных аргумента, встреченные в списке параметров в порядке слева направо, помещаются в регистры ECX и EDX соответственно. Скрытый **это** указатель рассматривается как первый аргумент целочисленного типа и передается в регистре ECX. Первые шесть аргументов векторного типа передаются по значению через векторные регистры SSE 0–5 в регистры XMM или YMM в зависимости от размера аргумента.

Первые шесть аргументов векторного типа в порядке слева направо передаются по значению в векторных регистрах SSE 0–5. С плавающей запятой и **__m128** типы передаются в регистрах XMM, а **__m256** типы передаются в регистрах YMM регистрирует. Для аргументов векторного типа, которые передаются через регистр, пространство теневого стека не выделяется. Аргументы векторного типа начиная с седьмой позиции в списке передаются в стек по ссылке на память, выделенную вызывающим объектом. Ограничение на ошибку компилятора [C2719](../error-messages/compiler-errors-2/compiler-error-c2719.md) не применяется к этим аргументам.

После распределения регистры для векторных аргументов данных членов из аргументов типа HVA выделяются в возрастающем порядке по неиспользуемым векторным регистрам XMM0 – XMM5 (или YMM0 – YMM5 — для **__m256** типы), при условии, что имеется достаточно регистров доступно для распределения всего значения HVA. Если регистров недостаточно, аргумент HVA передается в стек по ссылке на память, выделенную вызывающим объектом. Пространство теневого стека аргументу HVA не выделяется. Аргументы HVA назначаются регистрам в порядке слева направо в списке параметров и могут находиться в любой позиции.

Результаты **__vectorcall** функции возвращаются по значению в регистрах. Результаты целочисленных типов, включая structs и union размером 4 байт и менее, возвращаются по значению в EAX. Структуры или объединения целочисленного типа размером 8 байт или менее возвращаются по значению в регистрах EDX:EAX. Результаты векторного типа возвращаются по значению в XMM0 или YMM0 в зависимости от их размера. В результатах HVA каждый элемент данных возвращается по значению в регистрах XMM0:XMM3 или YMM0:YMM3 в зависимости от размера элемента. Результаты других типов возвращаются по ссылке на память, выделенную вызывающим объектом.

X86 реализация **__vectorcall** следующим соглашением аргументы в стек справа налево, вызывающий объект, а вызываемая функция очищает стек перед возвратом. В стек передаются только те аргументы, которые не помещаются в регистры.

Примеры

```cpp
// crt_vc86.c
// Build for x86 with: cl /arch:AVX /W3 /FAs crt_vc86.c
// This example creates an annotated assembly listing in
// crt_vc86.asm.

#include <intrin.h>
#include <xmmintrin.h>

typedef struct {
   __m128 array[2];
} hva2;    // 2 element HVA type on __m128

typedef struct {
   __m256 array[4];
} hva4;    // 4 element HVA type on __m256

// Example 1: All vectors
// Passes a in XMM0, b in XMM1, c in YMM2, d in XMM3, e in YMM4.
// Return value in XMM0.
__m128 __vectorcall
example1(__m128 a, __m128 b, __m256 c, __m128 d, __m256 e) {
   return d;
}

// Example 2: Mixed int, float and vector parameters
// Passes a in ECX, b in XMM0, c in EDX, d in XMM1, e in YMM2,
// f in XMM3, g pushed on stack.
// Return value in YMM0.
__m256 __vectorcall
example2(int a, __m128 b, int c, __m128 d, __m256 e, float f, int g) {
   return e;
}

// Example 3: Mixed int and HVA parameters
// Passes a in ECX, c in EDX, d and e pushed on stack.
// Passes b by element in [XMM0:XMM1].
// Return value in XMM0.
__m128 __vectorcall example3(int a, hva2 b, int c, int d, int e) {
   return b.array[0];
}

// Example 4: HVA assigned after vector types
// Passes a in ECX, b in XMM0, d in XMM1, and e in EDX.
// Passes c by element in [YMM2:YMM5].
// Return value in XMM0.
float __vectorcall example4(int a, float b, hva4 c, __m128 d, int e) {
   return b;
}

// Example 5: Multiple HVA arguments
// Passes a in ECX, c in EDX, e pushed on stack.
// Passes b in [XMM0:XMM1], d in [YMM2:YMM5].
// Return value in EAX.
int __vectorcall example5(int a, hva2 b, int c, hva4 d, int e) {
   return c + e;
}

// Example 6: HVA argument passed by reference, returned by register
// Passes a in [XMM1:XMM2], b passed by reference in ECX, c in YMM0,
// d in [XMM3:XMM4].
// Register space was insufficient for b, but not for d.
// Return value in [YMM0:YMM3].
hva4 __vectorcall example6(hva2 a, hva4 b, __m256 c, hva2 d) {
   return b;
}

int __cdecl main( void )
{
   hva4 h4;
   hva2 h2;
   int i;
   float f;
   __m128 a, b, d;
   __m256 c, e;

   a = b = d = _mm_set1_ps(3.0f);
   c = e = _mm256_set1_ps(5.0f);
   h2.array[0] = _mm_set1_ps(6.0f);
   h4.array[0] = _mm256_set1_ps(7.0f);

   b = example1(a, b, c, d, e);
   e = example2(1, b, 3, d, e, 6.0f, 7);
   d = example3(1, h2, 3, 4, 5);
   f = example4(1, 2.0f, h4, d, 5);
   i = example5(1, h2, 3, h4, 5);
   h4 = example6(h2, h4, c, h2);
}
```

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Передача аргументов и соглашения об именовании](../cpp/argument-passing-and-naming-conventions.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)