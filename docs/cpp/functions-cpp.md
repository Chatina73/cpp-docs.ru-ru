---
title: Функции (C++)
ms.date: 11/19/2018
helpviewer_keywords:
- defaults, arguments
- function definitions
- function definitions, about function definitions
- default arguments
- declarators, functions
ms.assetid: 33ba01d5-75b5-48d2-8eab-5483ac7d2274
ms.openlocfilehash: 1425ddebffc150158e88e44b1d2c22e3f85e5a31
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81375735"
---
# <a name="functions-c"></a>Функции (C++)

Функции — это блоки кода, выполняющие определенные операции. Если требуется, функция может определять входные параметры, позволяющие вызывающим объектам передавать ей аргументы. При необходимости функция также может возвращать значение как выходное. Функции полезны для инкапсуляции основных операций в едином блоке, который может многократно использоваться. В идеальном случае имя этого блока должно четко описывать назначение функции. Следующая функция принимает два рядовые от вызываемого и возвращает их сумму; *a* и *b* являются *параметрами* типа **Int**.

```cpp
int sum(int a, int b)
{
    return a + b;
}
```

Функция может быть вызвана, или *называется,* из любого количества мест в программе. Значения, которые передаются функции *являются аргументы,* чьи типы должны быть совместимы с типами параметров в определении функции.

```cpp
int main()
{
    int i = sum(10, 32);
    int j = sum(i, 66);
    cout << "The value of j is" << j << endl; // 108
}
```

Длина функции практически не ограничена, однако для максимальной эффективности кода целесообразно использовать функции, каждая из которых выполняет одиночную, четко определенную задачу. Сложные алгоритмы лучше разбивать на более короткие и простые для понимания функции, если это возможно.

Функции, определенные в области видимости класса, называются функциями-членами. В C++, в отличие от других языков, функции можно также определять в области видимости пространства имен (включая неявное глобальное пространство имен). Такие функции называются *свободными функциями* или *функциями, не являемыми членами;* они широко используются в Стандартной библиотеке.

Функции могут быть *перегружены,* что означает, что различные версии функции могут иметь одно и то же имя, если они отличаются от числа и/или типа формальных параметров. Для получения дополнительной информации [см.](../cpp/function-overloading.md)

## <a name="parts-of-a-function-declaration"></a>Части объявления функции

Минимальное *декларирование* функций состоит из типа возврата, имени функции и списка параметров (которые могут быть пустыми), а также дополнительных ключевых слов, которые предоставляют дополнительные инструкции компилятору. Следующим примером является декларация функций:

```cpp
int sum(int a, int b);
```

Определение функции состоит из декларации, плюс *тело*, которое весь код между фигурные скобки:

```cpp
int sum(int a, int b)
{
    return a + b;
}
```

Объявление функции, за которым следует точка с запятой, может многократно встречаться в разных местах кода программы. Оно необходимо перед любыми вызовами этой функции в каждой записи преобразования. По правилу одного определения, определение функции должно фигурировать в коде программы лишь один раз.

При объявлении функции необходимо указать:

1. Тип возврата, который определяет тип значения, которое возвращает функцию, или **недействительным,** если значение не возвращается. В СЗ11 **авто** является действительным типом возврата, который поручает компилятору сделать вывод о типе из оператора возврата. Тип decltype (auto) также используется в C++14. Дополнительные сведения см. в подразделе "Выведение возвращаемых типов" ниже.

1. Имя функции, которое должно начинаться с буквы или символа подчеркивания и не должно содержать пробелов. В стандартной библиотеке со знака подчеркивания обычно начинаются имена закрытых функций-членов или функций, не являющихся членами и не предназначенных для использования в вашем коде.

1. Список параметров, заключенный в скобки. В этом списке через запятую указывается нужное (возможно, нулевое) число параметров, задающих тип и, при необходимости, локальное имя, по которому к значениям можно получить доступ в теле функции.

Необязательные элементы объявления функции:

1. `constexpr` — указывает, что возвращаемое значение функции является константой, значение которой может быть определено во время компиляции.

    ```cpp
    constexpr float exp(float x, int n)
    {
        return n == 0 ? 1 :
            n % 2 == 0 ? exp(x * x, n / 2) :
            exp(x * x, (n - 1) / 2) * x;
    };
    ```

1. Его спецификация связи, **extern** или **статические**.

    ```cpp
    //Declare printf with C linkage.
    extern "C" int printf( const char *fmt, ... );

    ```

   Для получения дополнительной информации [см.](../cpp/program-and-linkage-cpp.md)

1. **inline**, который поручает компилятору заменить каждый вызов функции самим кодом функции. Подстановка может улучшить эффективность кода в сценариях, где функция выполняется быстро и многократно вызывается во фрагментах, являющихся критическими для производительности программы.

    ```cpp
    inline double Account::GetBalance()
    {
        return balance;
    }
    ```

   Для получения дополнительной информации [см.](../cpp/inline-functions-cpp.md)

1. Выражение, `noexcept` которое определяет, может ли функция выбросить исключение. В следующем примере функция не выбрасывает `is_pod` исключение, если выражение оценивается как **истинное.**

    ```cpp
    #include <type_traits>

    template <typename T>
    T copy_object(T& obj) noexcept(std::is_pod<T>) {...}
    ```

   Для получения дополнительной информации, [см. noexcept](../cpp/noexcept-cpp.md).

1. (Только функции членов) CV-квалификаторы, которые определяют, является ли функция **констейной** или **летучей.**

1. (Только функции членов) **виртуальные** `override`, `final`, или . **виртуальный** указывает, что функция может быть переопределена в производном классе. `override` — означает, что функция в производном классе переопределяет виртуальную функцию. `final` — означает, что функция не может быть переопределена ни в одном из последующих производных классов. Для получения дополнительной информации [см.](../cpp/virtual-functions.md)

1. (только функции члена) **статическое** применение к функции члена означает, что функция не связана с любыми экземплярами объекта класса.

1. (Только нестатические функции члена) Реф-квалификатор, который указывает на компилятор, который перегружает функцию, чтобы выбрать, когда неявный параметр объекта (это)\*является ссылкой на rvalue против ссылки lvalue. Для получения дополнительной информации [см.](function-overloading.md#ref-qualifiers)

На следующем рисунке показаны компоненты определения функции. Затененная область является телом функции.

![Части определения функции](../cpp/media/vc38ru1.gif "Части определения функции") <br/>
Части определения функции

## <a name="function-definitions"></a>Определения функций

*Определение функции* состоит из декларации и органа функции, заключенного в фигурные скобки, которые содержат переменные декларации, заявления и выражения. Следующий пример показывает полное определение функции:

```cpp
    int foo(int i, std::string s)
    {
       int value {i};
       MyClass mc;
       if(strcmp(s, "default") != 0)
       {
            value = mc.do_something(i);
       }
       return value;
    }
```

Переменные, объявленные в теле функции, называются локальными. Они исчезают из области видимости при выходе из функции, поэтому функция никогда не должна возвращать ссылку на локальную переменную.

```cpp
    MyClass& boom(int i, std::string s)
    {
       int value {i};
       MyClass mc;
       mc.Initialize(i,s);
       return mc;
    }
```

## <a name="const-and-constexpr-functions"></a>функции const и constexpr

Можно объявить функцию участника как **конст,** чтобы указать, что функция не может изменять значения любых членов данных в классе. Объявляя функцию участника в качестве **const,** вы помогаете компилятору обеспечить *const-correctness.* Если кто-то по ошибке пытается изменить объект, используя функцию, объявленную как **const,** повышается ошибка компилятора. Для получения дополнительной [информации, см.](const-cpp.md)

Объявить функцию, когда `constexpr` значение, оно производит, возможно, может быть определено во время компиляции. Функция constexpr обычно выполняется быстрее, чем обычная функция. Для получения дополнительной информации, [см.](constexpr-cpp.md)

## <a name="function-templates"></a>Шаблоны функций

Шаблоны функций подобны шаблонам классов. Их задача заключается в создании конкретных функций на основе аргументов шаблонов. Во многих случаях шаблоны могут определять типы аргументов, поэтому их не требуется явно указывать.

```cpp
template<typename Lhs, typename Rhs>
auto Add2(const Lhs& lhs, const Rhs& rhs)
{
    return lhs + rhs;
}

auto a = Add2(3.13, 2.895); // a is a double
auto b = Add2(string{ "Hello" }, string{ " World" }); // b is a std::string
```

Для получения дополнительной [информации](../cpp/function-templates.md) см.

## <a name="function-parameters-and-arguments"></a>Параметры и аргументы функций

У функции имеется список параметров, в котором через запятую перечислено необходимое (возможно, нулевое) число типов. Каждому параметру присваивается имя, по которому к нему можно получить доступ в теле функции. В шаблоне функции могут указываться дополнительные типы или значения параметров. Вызывающий объект передает аргументы, представляющие собой конкретные значения, типы которых совместимы со списком параметров.

По умолчанию аргументы передаются функции по значению, то есть функция получает копию передаваемого объекта. Копирование крупных объектов может быть ресурсозатратным и неоправданным. Чтобы привести к тому, что аргументы передаются по ссылке (в частности, ссылка на lvalue), добавьте квантификатор ссылки к параметру:

```cpp
void DoSomething(std::string& input){...}
```

Если функция изменяет аргумент, передаваемый по ссылке, изменяется исходный объект, а не его локальная копия. Чтобы предотвратить изменение функции такого аргумента, квалифицируйте параметр как const&:

```cpp
void DoSomething(const std::string& input){...}
```

**СЗ 11:**  Для явного обращения с аргументами, которые передаются по rvalue-reference или lvalue-reference, используйте двойной амперсанд по параметру, чтобы указать универсальную ссылку:

```cpp
void DoSomething(const std::string&& input){...}
```

Функция, объявленная с пустым словом с одним ключевым **словом** в списке деклараций параметра, не принимает никаких аргументов, если **пустота** ключевого слова является первым и единственным членом списка деклараций аргументов. Аргументы типа **недействительными** в других частях списка производят ошибки. Пример:

```cpp

// OK same as GetTickCount()
long GetTickCount( void );
```

Обратите внимание, что, хотя это незаконно, чтобы указать **пустоту** аргумент, за исключением, как описано здесь, типы, полученные из типа **пустоты** (например, указатели **на пустоту** и массивы **пустоты**) может отображаться в любом месте список аргумент декларации.

### <a name="default-arguments"></a>Аргументы по умолчанию

Последним параметрам в сигнатуре функции можно назначить аргумент по умолчанию, т. е. вызывающий объект сможет опустить аргумент при вызове функции, если не требуется указать какое-либо другое значение.

```cpp
int DoSomething(int num,
    string str,
    Allocator& alloc = defaultAllocator)
{ ... }

// OK both parameters are at end
int DoSomethingElse(int num,
    string str = string{ "Working" },
    Allocator& alloc = defaultAllocator)
{ ... }

// C2548: 'DoMore': missing default parameter for parameter 2
int DoMore(int num = 5, // Not a trailing parameter!
    string str,
    Allocator& = defaultAllocator)
{...}
```

Для получения дополнительной [информации см.](../cpp/default-arguments.md)

## <a name="function-return-types"></a>типов возвращаемых функциями значений;

Функция не может вернуть другую функцию или встроенный массив; однако он может вернуть указатели к этим типам, или *lambda*, который производит объект функции. За исключением этих случаев, функция может вернуть значение любого типа, которое находится в области, или оно может вернуть не значение, и в этом случае тип возврата **недействителен.**

### <a name="trailing-return-types"></a>Завершающие возвращаемые типы

"Обычные" возвращаемые типы расположены слева от сигнатуры функции. Тип *возврата трейл* расположен справа по большей части подписи и предшествует оператору ->. Завершающие возвращаемые типы особенно полезны в шаблонах функций, когда тип возвращаемого значения зависит от параметров шаблона.

```cpp
template<typename Lhs, typename Rhs>
auto Add(const Lhs& lhs, const Rhs& rhs) -> decltype(lhs + rhs)
{
    return lhs + rhs;
}
```

Когда **авто** используется в сочетании с типом возврата, он просто служит в качестве заполнителя для того, что вырабатывает выражение деклепа, и сам не выполняет вычет типа.

## <a name="function-local-variables"></a>Локальные переменные функции

Переменная, объявленная внутри тела функции, называется *локальной переменной* или просто *локальной.* Нестатические локальные переменные видны только в теле функции. Если локальные переменные объявляются в стеке, они исчезают из области видимости при выходе из функции. При построении локальной переменной и возврате по стоимости компилятор обычно может выполнять *именованные операции возврата,* чтобы избежать ненужных операций копирования. Если локальная переменная возвращается по ссылке, компилятор выдаст предупреждение, поскольку любые попытки вызывающего объекта использовать эту ссылку произойдут после уничтожения локальной переменной.

В C++ локальные переменные можно объявлять как статические. Переменная является видимой только в теле функции, однако для всех экземпляров функции существует только одна копия переменной. Локальные статические объекты удаляются во время завершения, определенного директивой `atexit`. Если статический объект не был создан из-за того, что поток кода программы обошел соответствующее объявление, попытка уничтожения этого объект не предпринимается.

## <a name="type-deduction-in-return-types-c14"></a><a name="type_deduction"></a>Тип вычета в типах возврата (C-14)

В C-14 можно использовать **авто,** чтобы поручить компилятору сделать вывод о типе возврата из тела функции без необходимости предоставления типа возврата. Обратите внимание, что **auto** всегда выводит к возврату по стоимости. Используйте `auto&&`, чтобы дать компилятору команду выведения ссылки.

В этом примере **авто** будет выведено в виде неконсальной стоимостной копии суммы lhs и rhs.

```cpp
template<typename Lhs, typename Rhs>
auto Add2(const Lhs& lhs, const Rhs& rhs)
{
    return lhs + rhs; //returns a non-const object by value
}
```

Обратите внимание, что **авто** не сохраняет конст-несс типа он выводит. Для функций пересылки, значение возврата которых должно сохранять конст-несс или реф-несс своих аргументов, можно использовать ключевое слово **decltype (auto),** которое использует правила разновидности **типа** и сохраняет всю информацию типа. **деклепом (авто)** может использоваться как обычное значение возврата на левой стороне или как задняющее значение возврата.

Следующий пример (на основе кода от [N3493),](https://wg21.link/n3493)показывает **деклип (авто),** используемый для обеспечения идеальной пересылки функциональных аргументов в типе возврата, который не известен до момента мгновенного использования шаблона.

```cpp
template<typename F, typename Tuple = tuple<T...>, int... I>
decltype(auto) apply_(F&& f, Tuple&& args, index_sequence<I...>)
{
    return std::forward<F>(f)(std::get<I>(std::forward<Tuple>(args))...);
}

template<typename F, typename Tuple = tuple<T...>,
    typename Indices = make_index_sequence<tuple_size<Tuple>::value >>
   decltype( auto)
    apply(F&& f, Tuple&& args)
{
    return apply_(std::forward<F>(f), std::forward<Tuple>(args), Indices());
}
```

## <a name="returning-multiple-values-from-a-function"></a><a name="multi_val"></a>Возвращение нескольких значений из функции

Существуют различные способы возврата более одного значения из функции:

1. Инкапсулировать значения в названном классе или объекте структуры. Требуется, чтобы определение класса или структуры было видимым для вызывающего абонента:

    ```cpp
    #include <string>
    #include <iostream>

    using namespace std;

    struct S
    {
        string name;
        int num;
    };

    S g()
    {
        string t{ "hello" };
        int u{ 42 };
        return { t, u };
    }

    int main()
    {
        S s = g();
        cout << s.name << " " << s.num << endl;
        return 0;
    }
    ```

1. Возврат std::tuple или std::pair объект:

    ```cpp
    #include <tuple>
    #include <string>
    #include <iostream>

    using namespace std;

    tuple<int, string, double> f()
    {
        int i{ 108 };
        string s{ "Some text" };
        double d{ .01 };
        return { i,s,d };
    }

    int main()
    {
        auto t = f();
        cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;

        // --or--

        int myval;
        string myname;
        double mydecimal;
        tie(myval, myname, mydecimal) = f();
        cout << myval << " " << myname << " " << mydecimal << endl;

        return 0;
    }
    ```

1. **Visual Studio 2017 версия 15.3 и позже** (доступна с [/std:c'17](../build/reference/std-specify-language-standard-version.md)): Используйте структурированные привязки. Преимущество структурированных привязок заключается в том, что переменные, хранящие значения возврата, инициализированы одновременно с их декларированными значениями, что в некоторых случаях может быть значительно более эффективным. В этом заявлении --`auto[x, y, z] = f();`скобки вводят и инициализируют имена, которые находятся в области для всего блока функций.

    ```cpp
    #include <tuple>
    #include <string>
    #include <iostream>

    using namespace std;

    tuple<int, string, double> f()
    {
        int i{ 108 };
        string s{ "Some text" };
        double d{ .01 };
        return { i,s,d };
    }
    struct S
    {
        string name;
        int num;
    };

    S g()
    {
        string t{ "hello" };
        int u{ 42 };
        return { t, u };
    }

    int main()
    {
        auto[x, y, z] = f(); // init from tuple
        cout << x << " " << y << " " << z << endl;

        auto[a, b] = g(); // init from POD struct
        cout << a << " " << b << endl;
        return 0;
    }
    ```

1. Помимо использования самого значения возврата, можно "вернуть" значения, определив любое количество параметров для использования pass-by-reference, чтобы функция сработала или инициализировала значения объектов, которые предоставляет вызываемый абонент. Для получения дополнительной информации, см [Справочник-Тип Функциональные Аргументы](reference-type-function-arguments.md).

## <a name="function-pointers"></a>Указатели функций

Как и в C, в C++ поддерживаются указатели на функции. Однако более типобезопасной альтернативой обычно служит использование объекта-функции.

Рекомендуется использовать **typedef** для объявления псевдонима для типа указателя функции при объявлении функции, которая возвращает тип указателя функции.  Например.

```cpp
typedef int (*fp)(int);
fp myFunction(char* s); // function returning function pointer
```

Если оно не используется, то правильный синтаксис объявления функции можно вывести из синтаксиса декларатора для указателя на функцию, заменив идентификатор (в приведенном выше примере — `fp`) на имя функции и список аргументов, как показано выше:

```cpp
int (*myFunction(char* s))(int);
```

Это объявление эквивалентно объявлению при помощи ключевого слова typedef, которое приводилось выше.

## <a name="see-also"></a>См. также раздел

[Перегрузка функций](../cpp/function-overloading.md)<br/>
[Функции с переменными списками аргументов](../cpp/functions-with-variable-argument-lists-cpp.md)<br/>
[Явно используемые по умолчанию и удаленные функции](../cpp/explicitly-defaulted-and-deleted-functions.md)<br/>
[Поиск имен функций с зависимостью от аргументов (поиск Koenig)](../cpp/argument-dependent-name-koenig-lookup-on-functions.md)<br/>
[Аргументы по умолчанию](../cpp/default-arguments.md)<br/>
[Встраиваемые функции](../cpp/inline-functions-cpp.md)
