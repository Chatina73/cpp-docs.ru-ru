---
title: Оператор static_cast
ms.date: 11/04/2016
f1_keywords:
- static_cast_cpp
helpviewer_keywords:
- static_cast keyword [C++]
ms.assetid: 1f7c0c1c-b288-476c-89d6-0e2ceda5c293
ms.openlocfilehash: dca6d5297379e6ddc1c70dba80f35f2f55672e49
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62267132"
---
# <a name="staticcast-operator"></a>Оператор static_cast

Преобразует *выражение* типу *идентификатор типа* только на основе типов, которые присутствуют в выражении.

## <a name="syntax"></a>Синтаксис

```
static_cast <type-id> ( expression )
```

## <a name="remarks"></a>Примечания

В стандартном языке C++, проверка типа во время выполнения не выполняется, что обеспечивает безопасность преобразования. В C ++/CX выполняются проверки во время компиляции и во время выполнения. Дополнительные сведения см. в разделе [Приведение](casting.md).

**Static_cast** оператор может использоваться для операции, такие как преобразование указателя на базовый класс в указатель на производный класс. Такие преобразования не всегда являются безопасными.

В общем использовании **static_cast** для преобразования типов числовых данных, например перечисления в целые числа или целые числа, числа с плавающей запятой, и являются определенные типы данных используются в преобразовании. **static_cast** преобразования не как **dynamic_cast** преобразования, так как **static_cast** тип времени выполнения не проверяет, тогда как **dynamic_cast** выполняет. Объект **dynamic_cast** к неоднозначному указателю завершится ошибкой, пока **static_cast** возвращает, как если бы все в порядке; это может быть опасно. Несмотря на то что **dynamic_cast** преобразования безопасны, **dynamic_cast** только works на указатели или ссылки и проверку типов во время выполнения является дополнительной нагрузкой. Дополнительные сведения см. в разделе [оператор dynamic_cast](../cpp/dynamic-cast-operator.md).

В следующем примере строка `D* pd2 = static_cast<D*>(pb);` небезопасна, поскольку `D` может иметь поля и методы, не входящие в `B`. Однако строка `B* pb2 = static_cast<B*>(pd);` является безопасным преобразованием, поскольку `D` всегда содержит все `B`.

```cpp
// static_cast_Operator.cpp
// compile with: /LD
class B {};

class D : public B {};

void f(B* pb, D* pd) {
   D* pd2 = static_cast<D*>(pb);   // Not safe, D can have fields
                                   // and methods that are not in B.

   B* pb2 = static_cast<B*>(pd);   // Safe conversion, D always
                                   // contains all of B.
}
```

В отличие от к [dynamic_cast](../cpp/dynamic-cast-operator.md), проверка во время выполнения не проводится на **static_cast** преобразование `pb`. Объект, на который указывает `pb`, может не быть объектом типа `D`, и в этом случае использование `*pd2` может привести ужасным последствиям. Например, вызов функции, являющейся членом класса `D`, но не класса `B`, может привести к нарушению прав доступа.

**Dynamic_cast** и **static_cast** операторы переместить указатель по всей иерархии классов. Тем не менее **static_cast** исключительно с помощью сведений, предоставленных в операторе приведения и поэтому может быть небезопасно. Пример:

```cpp
// static_cast_Operator_2.cpp
// compile with: /LD /GR
class B {
public:
   virtual void Test(){}
};
class D : public B {};

void f(B* pb) {
   D* pd1 = dynamic_cast<D*>(pb);
   D* pd2 = static_cast<D*>(pb);
}
```

Если `pb` действительно указывает на объект типа `D`, `pd1` и `pd2` получат одно и то же значение. Также они получат одно и то же значение, если `pb == 0`.

Если `pb` указывает на объект типа `B` , а не полный `D` класса, затем **dynamic_cast** будет достаточно возвращается ноль. Тем не менее **static_cast** основывается на утверждении программиста, `pb` указывает на объект типа `D` и просто возвращает указатель на этот предполагаемый `D` объекта.

Следовательно **static_cast** можно выполнить обратное неявные преобразования, в противном случае результаты не определены. Возлагается на программиста, чтобы убедиться, что результаты **static_cast** преобразования являются безопасными.

Это поведение также применяется к типам, отличным от типов класса. Например **static_cast** может использоваться для преобразования из int в **char**. Тем не менее полученный в результате **char** может иметь недостаточно бит для хранения всего **int** значение. Опять же, возлагается на программиста, чтобы убедиться, что результаты **static_cast** преобразования являются безопасными.

**Static_cast** оператор может также использоваться для выполнения любого неявного преобразования, включая стандартные преобразования и заданные пользователем преобразования. Пример:

```cpp
// static_cast_Operator_3.cpp
// compile with: /LD /GR
typedef unsigned char BYTE;

void f() {
   char ch;
   int i = 65;
   float f = 2.5;
   double dbl;

   ch = static_cast<char>(i);   // int to char
   dbl = static_cast<double>(f);   // float to double
   i = static_cast<BYTE>(ch);
}
```

**Static_cast** оператор можно явно преобразовать целочисленное значение в тип перечисления. Если значение типа целого не оказывается в диапазоне значений перечисления, получаемое значение перечисления не определено.

**Static_cast** оператор преобразует значение пустого указателя в значение пустого указателя конечного типа.

Любое выражение можно явно преобразовать в тип void с **static_cast** оператор. При необходимости можно включить тип назначения void **const**, **volatile**, или **__unaligned** атрибута.

**Static_cast** оператор не может удалять **const**, **volatile**, или **__unaligned** атрибуты. См. в разделе [оператор const_cast](../cpp/const-cast-operator.md) сведения об удалении этих атрибутов.

**C++ИЛИ ИНТЕРФЕЙСА КОМАНДНОЙ СТРОКИ:** Из-за опасности выполнения непроверенных приведений в верхней части сжимаемые сборщик мусора, использование **static_cast** должен быть только в важных для производительности коде при наличии уверенности, он будет работать правильно. Если необходимо использовать **static_cast** в режиме выпуска, замените его [safe_cast](../extensions/safe-cast-cpp-component-extensions.md) в отладочных сборках, для достижения успеха.

## <a name="see-also"></a>См. также

[Операторы приведения](../cpp/casting-operators.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)