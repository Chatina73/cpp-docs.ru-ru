---
title: Преобразования типов и безопасность типов (современный C++)
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 629b361a-2ce1-4700-8b5d-ab4f57b245d5
ms.openlocfilehash: 201f09cc9ac17f76634103c9c9b6c0259c8a8637
ms.sourcegitcommit: 1819bd2ff79fba7ec172504b9a34455c70c73f10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/09/2018
ms.locfileid: "51332625"
---
# <a name="type-conversions-and-type-safety-modern-c"></a>Преобразования типов и безопасность типов (современный C++)

В этом документе определяет распространенных проблем преобразования типа и описывает, как их избежать в коде C++.

При написании программы на языке C++, важно убедиться, что он является строго типизированным. Это означает, что каждая переменная, аргумент функции и функции возвращают значение хранятся допустимые виды данных, и что операции, включающие значения разных типов «смысла» и не приведет к потере данных, неверной интерпретации битовых шаблонов, или повреждение памяти. Это программа, которая никогда не явно или неявно преобразует значения из одного типа в другой является строго типизированным по определению. Тем не менее, преобразование типов, включая небезопасные преобразования, иногда требуются. Например, может потребоваться сохранить результат с плавающей точки операции в переменной типа **int**, или может потребоваться передать значение unsigned **int** на функцию, которая принимает со знаком  **int**. В обоих примерах показано небезопасные преобразования, так как они могут привести к потере данных или повторной интерпретации значения.

Когда компилятор обнаруживает небезопасным преобразованием, она выдает ошибку или предупреждение. Ошибка прекращает компиляцию; Предупреждение позволяет компиляции продолжить, но указывает на возможную ошибку в коде. Тем не менее даже если программа компилируется без предупреждений, он по-прежнему может содержать код, который приводит к неявного преобразования типов, которые выдавать неверные результаты. Тип ошибки может также быть вызвана явные преобразования или приведения, в коде.

## <a name="implicit-type-conversions"></a>Неявные преобразования типов

Если выражение содержит различные встроенные типы операндов, и без явных приведений присутствуют, компилятор использует встроенную *стандартные преобразования* для преобразования одного из операндов, чтобы типы соответствуют. Компилятор пытается преобразований в строго определенную последовательность до первой успешной попытки. Если выбранный преобразование рекламной акции, компилятор не выдает предупреждение. Если сужающее преобразование, компилятор выдает предупреждение о возможной потере данных. Происходит ли фактической потери данных зависит от фактических значений связанных, но мы рекомендуем использовать это предупреждение как ошибку. Если определяемый пользователем тип, компилятор пытается использовать преобразований, которые вы указали в определении класса. Если не удается найти приемлемое преобразование, компилятор выдает ошибку и не компилируется программа. Дополнительные сведения о правилах, которые управляют стандартные преобразования см. в разделе [стандартные преобразования](../cpp/standard-conversions.md). Дополнительные сведения о пользовательских преобразованиях см. в разделе [заданных пользователем преобразований (C + +/ CLI)](../dotnet/user-defined-conversions-cpp-cli.md).

### <a name="widening-conversions-promotion"></a>Расширяющие преобразования (повышение)

В расширяющее преобразование значение в небольших переменной присваивается переменной большего размера без потери данных. Поскольку расширяющие преобразования всегда являются безопасными, компилятор выполняет их автоматически и не выдает предупреждения. Следующие преобразования являются расширяющими преобразованиями.

|Исходный тип|Кому|
|----------|--------|
|Все подписанные или не подписанные целочисленного типа, кроме **long long** или **__int64**|**double**|
|**bool** или **char**|Встроенный тип|
|**короткий** или **wchar_t**|**int**, **long**, **long long**|
|**int**, **long**|**long long**|
|**float**|**double**|

### <a name="narrowing-conversions-coercion"></a>Сужающие преобразования (приведения)

Компилятор выполняет сужающие преобразования неявным образом, но выводится предупреждение о возможной потере данных. Эти предупреждения занять очень серьезно. Если вы уверены, что без потери данных произойдет, так как значения в переменной большего размера всегда помещается в переменную меньшего размера, затем добавьте явное приведение, чтобы компилятор больше не будет выдавать предупреждение. Если вы не уверены, что преобразование безопасен, добавьте в код какого-либо рода проверка во время выполнения для обработки возможной потерей данных, таким образом, чтобы он не вызывает программу вырабатывать неверные результаты.

Преобразование из чисел с плавающей точкой, тип в целочисленный тип является сужающим преобразованием, так как дробной части числа с плавающей запятой удаляется и потери.

В следующем примере кода показаны некоторые неявные сужающие преобразования, а также предупреждений, которые компилятор выдает для них.

```cpp
int i = INT_MAX + 1; //warning C4307:'+':integral constant overflow
wchar_t wch = 'A'; //OK
char c = wch; // warning C4244:'initializing':conversion from 'wchar_t'
              // to 'char', possible loss of data
unsigned char c2 = 0xfffe; //warning C4305:'initializing':truncation from
                           // 'int' to 'unsigned char'
int j = 1.9f; // warning C4244:'initializing':conversion from 'float' to
              // 'int', possible loss of data
int k = 7.7; // warning C4244:'initializing':conversion from 'double' to
             // 'int', possible loss of data
```

### <a name="signed---unsigned-conversions"></a>Автоматический - без знака преобразования

Целочисленный тип со знаком и без знака какой всегда имеют одинаковый размер, но они могут отличаться интерпретацию битовый шаблон для преобразования значения. В следующем примере кода показано, что происходит, когда тот же битовый шаблон интерпретируется как значение со знаком и как целое число без знака. Битовый шаблон, хранимые в обоих `num` и `num2` никогда не меняется от приведенного на предыдущем рисунке.

```cpp
using namespace std;
unsigned short num = numeric_limits<unsigned short>::max(); // #include <limits>
short num2 = num;
cout << "unsigned val = " << num << " signed val = " << num2 << endl;
// Prints: unsigned val = 65535 signed val = -1

// Go the other way.
num2 = -1;
num = num2;
cout << "unsigned val = " << num << " signed val = " << num2 << endl;
// Prints: unsigned val = 65535 signed val = -1
```

Обратите внимание на то, что значения являются интерпретации в обоих направлениях. Если программа создает странным результатам, в которых кажется знак значения инвертированы по сравнению с ожиданиям, найдите неявные преобразования целочисленных типов со знаком и без знака. В следующем примере результат выражения (0 - 1) неявным образом преобразуется из **int** для **unsigned int** при его сохранении в `num`. Это приводит к повторной интерпретации битовый шаблон.

```cpp
unsigned int u3 = 0 - 1;
cout << u3 << endl; // prints 4294967295
```

Компилятор не выдает предупреждение о неявные преобразования целочисленных типов со знаком и без знака. Таким образом мы рекомендуем полностью избежать со знаком для без преобразования. Если их невозможно избежать, добавьте в код проверку среды выполнения, чтобы определить, является ли преобразуемое значение больше или равно нулю и меньше или равно максимальному значению типа со знаком. Значения в этом диапазоне будут перенесены из подписи без знака или без знака для подписанных без интерпретировать.

### <a name="pointer-conversions"></a>Преобразования указателей

Во многих выражениях массиве в стиле неявно преобразуется в указатель на первый элемент в массиве и постоянное преобразование может произойти автоматически. Несмотря на то, что это очень удобно, это также допустить ошибку. Например в следующем примере кода неудачную кажется бессмысленные, а еще он будет компилироваться в Visual C++ и возвращает результат «p». Во-первых, константным литералом «Help» строка преобразуется в `char*` , указывающий на первый элемент массива; этому указателю увеличивается три элемента, чтобы он теперь указывает на последний элемент «p».

```cpp
char* s = "Help" + 3;
```

## <a name="explicit-conversions-casts"></a>Явные преобразования (приведения)

С помощью операции приведения, можно указать компилятору, что для преобразования значения одного типа в другой тип. Компилятор вызовет ошибку, в некоторых случаях, если два типа не полностью связаны, но в других случаях он не вызовут ошибку даже, если операция не является строго типизированным. Используйте приведения осторожностью, поскольку преобразование из одного типа в другой возможный источник ошибок в работе программы. Тем не менее иногда требуются приведения и не все приведения одинаково опасны. Действующие использоваться приведения к типу случае, когда код выполняет сужающее преобразование, и вы знаете, что преобразование не вызывает программу вырабатывать неверные результаты. По сути, это указывает компилятору, что вы знаете, что вы выполняете и остановки беспокоить вас с предупреждениями о нем. Другим вариантом использования является преобразование из указателя на производный класс в указатель на базовый класс. Другим вариантом использования является отвергает **const**- ness переменной для передачи в функцию, которая требует непустой -**const** аргумент. Большая часть этих операций приведения связана с некоторым риском.

В стиле программирования C, один и тот же оператор приведение в стиле C используется для всех видов приведения.

```cpp
(int) x; // old-style cast, old-style syntax
int(x); // old-style cast, functional syntax
```

Оператор приведения типов C-стиль идентичен оператор вызова (), поэтому inconspicuous в коде и легко не заметить. Оба являются неправильный, так как они трудно распознаваемых во обзора или поиска, и они разрозненных, для вызова любого сочетания **статический**, **const**, и **reinterpret_cast**. Выяснение приведения старого стиля фактически может быть сложной и ошибкам. По этим причинам при приведение является обязательным, рекомендуется использовать один из следующих операторов приведения типа, что в некоторых случаях являются значительно более строго типизированными и который гораздо более явно express цель программирования:

- **static_cast**, только для приведения, которые проверяются при компиляции времени. **static_cast** возвращает ошибку, если компилятор обнаруживает, что необходимо для приведения между типами, которые не являются полностью совместимыми. Его также можно использовать для приведения между указатель на базовый и указателя на производный, но компилятор всегда не может определить, будет ли безопасный во время выполнения таких преобразований.

    ```cpp
    double d = 1.58947;
    int i = d;  // warning C4244 possible loss of data
    int j = static_cast<int>(d);       // No warning.
    string s = static_cast<string>(d); // Error C2440:cannot convert from
                                       // double to std:string

    // No error but not necessarily safe.
    Base* b = new Base();
    Derived* d2 = static_cast<Derived*>(b);
    ```

   Дополнительные сведения см. в разделе [static_cast](../cpp/static-cast-operator.md).

- **dynamic_cast**, для безопасного, флажки для среды выполнения приведения указателя на базовый для указателя на производный. Объект **dynamic_cast** является более безопасным, чем **static_cast** нисходящее приведение типа, но среда выполнения проверки влечет за собой дополнительные издержки.

    ```cpp
    Base* b = new Base();

    // Run-time check to determine whether b is actually a Derived*
    Derived* d3 = dynamic_cast<Derived*>(b);

    // If b was originally a Derived*, then d3 is a valid pointer.
    if(d3)
    {
       // Safe to call Derived method.
       cout << d3->DoSomethingMore() << endl;
    }
    else
    {
       // Run-time check failed.
       cout << "d3 is null" << endl;
    }

    //Output: d3 is null;
    ```

   Дополнительные сведения см. в разделе [dynamic_cast](../cpp/dynamic-cast-operator.md).

- **const_cast**для приведение **const**- ness переменной или преобразование не -**const** переменную **const**. Приведение **const**-ness с помощью этого оператора является просто как ошибкам как используется приведение к типу, за исключением того, что при использовании в стиле **приведением const** вы скорее случайно выполнить приведение. Иногда необходимо удалять **const**-ness переменной, например, для передачи **const** в функцию, принимающий отличный от**const** параметра. Следующий пример показывает, как это сделать.

    ```cpp
    void Func(double& d) { ... }
    void ConstCast()
    {
       const double pi = 3.14;
       Func(const_cast<double&>(pi)); //No error.
    }
    ```

   Дополнительные сведения см. в разделе [const_cast](../cpp/const-cast-operator.md).

- **reinterpret_cast**для приведения между несвязанные типы, такие как **указатель** для **int**.

    > [!NOTE]
    >  Этот оператор cast используется не так часто, что и остальные, и он имеет не обязательно будет переносимым в другие компиляторы.

   В следующем примере показано как **reinterpret_cast** отличается от **static_cast**.

    ```cpp
    const char* str = "hello";
    int i = static_cast<int>(str);//error C2440: 'static_cast' : cannot
                                  // convert from 'const char *' to 'int'
    int j = (int)str; // C-style cast. Did the programmer really intend
                      // to do this?
    int k = reinterpret_cast<int>(str);// Programming intent is clear.
                                       // However, it is not 64-bit safe.
    ```

   Дополнительные сведения см. в разделе [оператор reinterpret_cast](../cpp/reinterpret-cast-operator.md).

## <a name="see-also"></a>См. также

[Тип системы C++](../cpp/cpp-type-system-modern-cpp.md)<br/>
[Возвращение к C++](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)