---
title: Преобразования типов и безопасность типов
ms.date: 11/19/2019
ms.topic: conceptual
ms.assetid: 629b361a-2ce1-4700-8b5d-ab4f57b245d5
ms.openlocfilehash: 28adbc261b5b4376f947e00695fe66650739438d
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87223542"
---
# <a name="type-conversions-and-type-safety"></a>Преобразования типов и безопасность типов

В этом документе описаны распространенные проблемы преобразования типов и описывается, как избежать их использования в коде C++.

При написании программы на языке C++ важно убедиться, что она является строго типизированной. Это означает, что каждая переменная, аргумент функции и возвращаемое значение функции сохраняют допустимый тип данных и операции, затрагивающие значения различных типов, и не вызывают потерю данных, неверную интерпретацию битовых шаблонов или повреждение памяти. Неявное или неявное преобразование значений одного типа в другой является типобезопасным по определению. Однако иногда требуются преобразования типов, даже ненадежные преобразования. Например, может возникнуть необходимость сохранить результат операции с плавающей запятой в переменной типа **`int`** или передать значение в **`unsigned int`** функцию, которая принимает объект **`signed int`** . В обоих примерах показаны ненадежные преобразования, так как они могут привести к потере данных или повторной интерпретации значения.

Когда компилятор обнаруживает ненадежное преобразование, он выдает ошибку или предупреждение. Произошла ошибка при остановке компиляции. Предупреждение позволяет продолжить компиляцию, но указывает на возможную ошибку в коде. Однако даже если программа компилируется без предупреждений, она по-прежнему может содержать код, который вызывает неявные преобразования типов, приводящие к неправильным результатам. Ошибки типов также могут вводиться явными преобразованиями или приведениями в коде.

## <a name="implicit-type-conversions"></a>Неявные преобразования типов

Если выражение содержит операнды различных встроенных типов и явные приведения отсутствуют, компилятор использует встроенные *стандартные преобразования* для преобразования одного из операндов, чтобы типы совпадали. Компилятор пытается выполнить преобразования в четко определенной последовательности, пока она не завершится успешно. Если выбранное преобразование является повышением, компилятор не выдает предупреждение. Если преобразование является узким, компилятор выдает предупреждение о возможной утрате данных. Происходит ли фактическая потери данных, зависит от фактических значений, но рекомендуется считать это предупреждение как ошибку. Если включен определяемый пользователем тип, компилятор пытается использовать преобразования, указанные в определении класса. Если не удается найти допустимое преобразование, компилятор выдает ошибку и не компилирует программу. Дополнительные сведения о правилах, регулирующих стандартные преобразования, см. в разделе [стандартные преобразования](../cpp/standard-conversions.md). Дополнительные сведения о пользовательских преобразованиях см. в разделе пользовательские [преобразования (C++/CLI)](../dotnet/user-defined-conversions-cpp-cli.md).

### <a name="widening-conversions-promotion"></a>Расширяющие преобразования (продвижение)

В расширяющем преобразовании значение меньшей переменной присваивается более крупной переменной без потери данных. Поскольку расширяющие преобразования всегда являются надежными, компилятор выполняет их автоматически и не выдает предупреждения. Следующие преобразования являются расширяющими преобразованиями.

|От|Кому|
|----------|--------|
|Любой **`signed`** или **`unsigned`** целочисленный тип, кроме **`long long`** или**`__int64`**|**`double`**|
|**`bool`** или **`char`**|Любой другой встроенный тип|
|**`short`** или **`wchar_t`**|**`int`**, **`long`**, **`long long`**|
|**`int`**, **`long`**|**`long long`**|
|**`float`**|**`double`**|

### <a name="narrowing-conversions-coercion"></a>Сужающие преобразования (приведение)

Компилятор выполняет сужающие преобразования неявным образом, но предупреждает о возможной потере данных. Выведите эти предупреждения очень серьезно. Если вы уверены, что не произойдет потери данных, так как значения в переменной большего размера всегда помещаются в меньшую переменную, добавьте явное приведение, чтобы компилятор больше не выдавал предупреждение. Если вы не уверены, что преобразование является надежным, добавьте в код какую-либо проверку среды выполнения для обработки возможной потери данных, чтобы программа не выводила неверных результатов.

Преобразование из типа с плавающей запятой в целочисленный тип является узким преобразованием, так как дробная часть значения с плавающей запятой отбрасывается и теряется.

В следующем примере кода показаны некоторые неявные сужающие преобразования и предупреждения, которые возникают компилятором.

```cpp
int i = INT_MAX + 1; //warning C4307:'+':integral constant overflow
wchar_t wch = 'A'; //OK
char c = wch; // warning C4244:'initializing':conversion from 'wchar_t'
              // to 'char', possible loss of data
unsigned char c2 = 0xfffe; //warning C4305:'initializing':truncation from
                           // 'int' to 'unsigned char'
int j = 1.9f; // warning C4244:'initializing':conversion from 'float' to
              // 'int', possible loss of data
int k = 7.7; // warning C4244:'initializing':conversion from 'double' to
             // 'int', possible loss of data
```

### <a name="signed---unsigned-conversions"></a>Преобразования со знаком — без знака

Целочисленный тип со знаком и его неподписанный аналог всегда имеют одинаковый размер, но они отличаются тем, как битовый шаблон интерпретируется для преобразования значения. В следующем примере кода показано, что происходит, когда один и тот же битовый шаблон интерпретируется как значение со знаком и как значение без знака. Битовый шаблон, хранящийся как `num` , и `num2` никогда не изменяется из того, что показано на предыдущем рисунке.

```cpp
using namespace std;
unsigned short num = numeric_limits<unsigned short>::max(); // #include <limits>
short num2 = num;
cout << "unsigned val = " << num << " signed val = " << num2 << endl;
// Prints: unsigned val = 65535 signed val = -1

// Go the other way.
num2 = -1;
num = num2;
cout << "unsigned val = " << num << " signed val = " << num2 << endl;
// Prints: unsigned val = 65535 signed val = -1
```

Обратите внимание, что значения переинтерпретируемают в обоих направлениях. Если программа создает нечетные результаты, при которых знак значения кажется инвертированным от того, что вы ожидаете, найдите неявные преобразования между целыми типами со знаком и без знака. В следующем примере результат выражения (0-1) неявно преобразуется в **`int`** , **`unsigned int`** когда он сохраняется в `num` . Это приводит к переинтерпретации битового шаблона.

```cpp
unsigned int u3 = 0 - 1;
cout << u3 << endl; // prints 4294967295
```

Компилятор не предупреждает о неявных преобразованиях между целыми типами со знаком и без знака. Поэтому рекомендуется полностью избегать беззнаковых преобразований. Если вы не можете избежать их, добавьте в код проверку среды выполнения, чтобы определить, является ли преобразуемое значение большим или равным нулю и меньше или равно максимальному значению типа со знаком. Значения в этом диапазоне будут передаваться из входных файлов в неподписанный или из неподписанных в подписывание без переинтерпретации.

### <a name="pointer-conversions"></a>Преобразования указателей

Во многих выражениях массив в стиле C неявно преобразуется в указатель на первый элемент в массиве, а преобразования констант могут выполняться автоматически. Хотя это и удобно, это, вероятно, подвержено ошибкам. Например, следующий плохо спроектированный пример кода кажется бессмысленное, но он компилирует и выдает результат "p". Во-первых, строковый константный литерал "Help" преобразуется в объект **`char*`** , указывающий на первый элемент массива; этот указатель затем увеличивается на три элемента, чтобы теперь указывал на последний элемент "p".

```cpp
char* s = "Help" + 3;
```

## <a name="explicit-conversions-casts"></a>Явные преобразования (приведения)

С помощью операции приведения можно указать компилятору преобразовать значение одного типа в другой тип. В некоторых случаях компилятор вызовет ошибку, если эти два типа полностью не связаны, но в других случаях не вызывает ошибку, даже если операция не является строго типизированной. Используйте приведение с осторожностью, так как любое преобразование из одного типа в другой является потенциальным источником ошибок программы. Однако иногда требуется выполнить приведения, а не все приведения являются опасными. Одно эффективное использование приведения заключается в том, что в коде выполняется понижающие преобразования и известно, что преобразование не приводит к тому, что программа выдает неверные результаты. Фактически, это говорит компилятору о том, что вы делаете, а также о том, что вы выполняете предупреждения. Другой способ заключается в приведении из класса указателя на класс, производный от указатель на базовый. Другой способ заключается в приведении параметра **`const`** -rvalue характеристики переменной, чтобы передать ее в функцию, для которой требуется не **`const`** аргумент. Большинство этих операций приведения к некоторым рискам требует определенного риска.

В программировании в стиле C для всех типов приведений используется один и тот же оператор приведения в стиле C.

```cpp
(int) x; // old-style cast, old-style syntax
int(x); // old-style cast, functional syntax
```

Оператор приведения в стиле C идентичен оператору call () и, следовательно, инконспикуаус в коде и легко пропускаться. Оба являются некорректными, так как они трудно распознать на взгляде или найти, и они достаточно разнороды для вызова любой комбинации **`static`** , **`const`** и **`reinterpret_cast`** . Понять, что такое приведение старого стиля, действительно может быть трудно и подвержено ошибкам. По всем этим причинам, если требуется приведение, рекомендуется использовать один из следующих операторов приведения в C++, который в некоторых случаях значительно более строго типизирован, и что явно упрощает намерение программирования:

- **`static_cast`**, для приведений, которые проверяются только во время компиляции. **`static_cast`** Возвращает ошибку, если компилятор обнаруживает, что вы пытаетесь выполнить приведение типов, которые полностью несовместимы. Его также можно использовать для приведения между указателями на базовые и производные указатели, но компилятор не всегда может определить, будут ли такие преобразования небезопасны во время выполнения.

    ```cpp
    double d = 1.58947;
    int i = d;  // warning C4244 possible loss of data
    int j = static_cast<int>(d);       // No warning.
    string s = static_cast<string>(d); // Error C2440:cannot convert from
                                       // double to std:string

    // No error but not necessarily safe.
    Base* b = new Base();
    Derived* d2 = static_cast<Derived*>(b);
    ```

   Дополнительные сведения см. на веб-сайте [`static_cast`](../cpp/static-cast-operator.md).

- **`dynamic_cast`**, для безопасного выполнения приведения указателя на Base к типу, который проверяется средой. Объект **`dynamic_cast`** является более безопасным **`static_cast`** , чем для типов, но проверка среды выполнения требует некоторых дополнительных издержек.

    ```cpp
    Base* b = new Base();

    // Run-time check to determine whether b is actually a Derived*
    Derived* d3 = dynamic_cast<Derived*>(b);

    // If b was originally a Derived*, then d3 is a valid pointer.
    if(d3)
    {
       // Safe to call Derived method.
       cout << d3->DoSomethingMore() << endl;
    }
    else
    {
       // Run-time check failed.
       cout << "d3 is null" << endl;
    }

    //Output: d3 is null;
    ```

   Дополнительные сведения см. на веб-сайте [`dynamic_cast`](../cpp/dynamic-cast-operator.md).

- **`const_cast`**, для приведения параметра **`const`** -rvalue характеристики переменной или **`const`** для преобразования непеременной в значение **`const`** . Приведение **`const`** незавершенного использования — rvalue характеристики с помощью этого оператора, как и при использовании приведения в стиле C, за исключением того, что у **`const_cast`** вас меньше вероятность того, что приведение выполняется случайно. Иногда необходимо выполнить приведение **`const`** rvalue характеристики переменной, например, чтобы передать **`const`** переменную в функцию, которая принимает не **`const`** параметр. В приведенном ниже примере показано, как это сделать.

    ```cpp
    void Func(double& d) { ... }
    void ConstCast()
    {
       const double pi = 3.14;
       Func(const_cast<double&>(pi)); //No error.
    }
    ```

   Дополнительные сведения см. в разделе [const_cast](../cpp/const-cast-operator.md).

- **`reinterpret_cast`**, для приведения между несвязанными типами, такими как тип указателя и **`int`** .

    > [!NOTE]
    >  Этот оператор приведения не используется так часто, как другие, и не гарантирует перенос в другие компиляторы.

   В следующем примере показано **`reinterpret_cast`** отличие от **`static_cast`** .

    ```cpp
    const char* str = "hello";
    int i = static_cast<int>(str);//error C2440: 'static_cast' : cannot
                                  // convert from 'const char *' to 'int'
    int j = (int)str; // C-style cast. Did the programmer really intend
                      // to do this?
    int k = reinterpret_cast<int>(str);// Programming intent is clear.
                                       // However, it is not 64-bit safe.
    ```

   Дополнительные сведения см. в разделе [ `reinterpret_cast` оператор](../cpp/reinterpret-cast-operator.md).

## <a name="see-also"></a>См. также статью

[Система типов C++](../cpp/cpp-type-system-modern-cpp.md)<br/>
[Добро пожаловать в C++](../cpp/welcome-back-to-cpp-modern-cpp.md)<br/>
[Справочник по языку C++](../cpp/cpp-language-reference.md)<br/>
[Стандартная библиотека C++](../standard-library/cpp-standard-library-reference.md)
