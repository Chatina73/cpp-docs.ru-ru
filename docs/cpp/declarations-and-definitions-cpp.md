---
title: Объявления и определения (C++)
ms.date: 12/12/2019
ms.assetid: 678f1424-e12f-45e0-a957-8169e5fef6cb
ms.openlocfilehash: 7aa9e07a471ed5a32ecc8f13690f1a1bf08b655f
ms.sourcegitcommit: 8e285a766523e653aeeb34d412dc6f615ef7b17b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2020
ms.locfileid: "80077207"
---
# <a name="declarations-and-definitions-c"></a>Объявления и определения (C++)

C++ Программа состоит из различных сущностей, таких как переменные, функции, типы и пространства имен. Каждая из этих сущностей должна быть *объявлена* , прежде чем их можно будет использовать. В объявлении указывается уникальное имя сущности, а также сведения о ее типе и других характеристиках. В C++ точке, где объявлено имя, — это точка, в которой он становится видимым для компилятора. Нельзя ссылаться на функцию или класс, объявленные в более поздней точке в единице компиляции. Переменные должны быть объявлены как можно ближе до точки, в которой они используются.

В следующем примере показаны некоторые объявления:

```cpp
#include <string>

void f(); // forward declaration

int main()
{
    const double pi = 3.14; //OK
    int i = f(2); //OK. f is forward-declared
    std::string str; // OK std::string is declared in <string> header
    C obj; // error! C not yet declared.
    j = 0; // error! No type specified.
    auto k = 0; // OK. type inferred as int by compiler.
}

int f(int i)
{
    return i + 42;
}

namespace N {
   class C{/*...*/};
}
```

В строке 5 объявлена функция `main`. В строке 7 переменная **const** с именем `pi` объявляется и *инициализируется*. В строке 8 целочисленное `i` объявляется и инициализируется значением, созданным функцией `f`. Имя `f` является видимым для компилятора из-за *прямого объявления* в строке 3.

В строке 9 объявлена переменная с именем `obj` типа `C`. Однако это объявление вызывает ошибку, так как `C` не объявлено до последующего в программе и не объявлена как непрямая. Чтобы устранить эту ошибку, можно либо переместить полное *определение* `C` перед `main` или добавить в него прямую декларацию. Это поведение отличается от других языков, таких как C#, в которых функции и классы можно использовать до их точки объявления в исходном файле.

В строке 10 объявляется переменная с именем `str` типа `std::string`. Имя `std::string` является видимым, так как оно представлено в [файле заголовка](header-files-cpp.md) `string`, который объединяется с исходным файлом в строке 1. `std` — пространство имен, в котором объявлен класс `string`.

В строке 11 возникает ошибка, так как имя `j` не объявлено. Объявление должно предоставлять тип, в отличие от других языков, таких как javaScript. В строке 12 используется ключевое слово `auto`, которое указывает компилятору вывести тип `k` на основе значения, с которым оно инициализируется. Компилятор в этом случае выбирает `int` для типа.  

## <a name="declaration-scope"></a>Область видимости объявления

Имя, введенное в объявлении, допустимо в пределах *области* , в которой происходит объявление. В предыдущем примере переменные, объявленные внутри функции `main`, являются *локальными переменными*. Можно объявить другую переменную с именем `i` за пределами Main, в *глобальной области видимости*, и она будет полностью отдельной сущностью. Однако такое дублирование имен может привести к путанице и ошибкам программиста, и их следует избегать. В строке 21 класс `C` объявляется в области видимости `N`пространства имен. Использование пространств имен помогает избежать *конфликтов имен*. Большинство C++ стандартных имен библиотек объявляются в пространстве имен `std`. Дополнительные сведения о взаимодействии правил определения области с объявлениями см. в разделе [Scope](../cpp/scope-visual-cpp.md).

## <a name="definitions"></a>определения

Некоторые сущности, включая функции, классы, перечисления и константные переменные, должны быть определены в дополнение к объявлению. *Определение* предоставляет компилятору все сведения, необходимые для создания машинного кода, когда сущность используется позже в программе. В предыдущем примере строка 3 содержит объявление для функции `f` но *Определение* функции предоставляется в строках с 15 по 18. В строке 21 класс `C` объявлен и определен (хотя в соответствии с определением класс не выполняет никаких действий). Константная переменная должна быть определена, иными словами, которой было присвоено значение, в той же инструкции, в которой она объявлена. Объявление встроенного типа, например `int`, автоматически определяется определением, так как компилятор знает, сколько пространства нужно выделить.

В следующем примере показаны объявления, которые также являются определениями:

```cpp
// Declare and define int variables i and j.
int i;
int j = 10;

// Declare enumeration suits.
enum suits { Spades = 1, Clubs, Hearts, Diamonds };

// Declare class CheckBox.
class CheckBox : public Control
{
public:
    Boolean IsChecked();
    virtual int     ChangeState() = 0;
};
```

Ниже приведены некоторые объявления, которые не являются определениями.

```cpp
extern int i;
char *strchr( const char *Str, const char Target );
```

## <a name="typedefs-and-using-statements"></a>Определения типов и операторы using

В более ранних C++версиях ключевое слово [typedef](aliases-and-typedefs-cpp.md) используется для объявления нового имени, которое является *псевдонимом* для другого имени. Например, тип `std::string` — другое имя для `std::basic_string<char>`. Должно быть очевидно, почему программисты используют имя typedef, а не фактическое имя. В современном C++случае ключевое слово [using](aliases-and-typedefs-cpp.md) предпочтительнее, чем typedef, но идея одинакова: новое имя объявлено для сущности, которая уже объявлена и определена.

## <a name="static-class-members"></a>Члены статических классов

Поскольку члены статических данных класса являются дискретными переменными, общими для всех объектов класса, они должны быть определены и инициализированы вне определения класса. (Дополнительные сведения см. в разделе [классы](../cpp/classes-and-structs-cpp.md).)

## <a name="extern-declarations"></a>объявления extern

C++ Программа может содержать более одной [единицы компиляции](header-files-cpp.md). Чтобы объявить сущность, определенную в отдельной единице компиляции, используйте ключевое слово [extern](extern-cpp.md) . Сведения в объявлении достаточны для компилятора, но если определение сущности не найдено на шаге компоновки, компоновщик вызовет ошибку.

## <a name="in-this-section"></a>В этом разделе

[классы хранилищ](storage-classes-cpp.md);<br/>
[const](const-cpp.md)<br/>
[constexpr](constexpr-cpp.md)<br/>
[extern](extern-cpp.md)<br/>
[Инициализаторы](initializers.md)<br/>
[Псевдонимы и определения типов](aliases-and-typedefs-cpp.md)<br/>
[Использование объявления](using-declaration.md)<br/>
[volatile](volatile-cpp.md)<br/>
[decltype](decltype-cpp.md)<br/>
[Атрибуты вC++](attributes.md)<br/>

## <a name="see-also"></a>См. также:

[Основные понятия](../cpp/basic-concepts-cpp.md)<br/>
