---
title: Битовые поля в C++
ms.date: 11/19/2018
helpviewer_keywords:
- bitfields [C++]
- fields [C++], bit
- bit fields
ms.assetid: 6f4b62e3-cc1d-4e5d-bf34-05904104f71a
ms.openlocfilehash: bba57d495553e9622fcece9d036fc4f6eff3fa04
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75301604"
---
# <a name="c-bit-fields"></a>Битовые поля в C++

Классы и структуры могут содержать члены, которые занимают меньше пространства в памяти, чем целочисленный тип. Эти члены определяются как битовые поля. Синтаксис для спецификации *объявления члена* в битовом поле приведен ниже:

## <a name="syntax"></a>Синтаксис

*декларатор* **:** *константное выражение*

## <a name="remarks"></a>Заметки

*Декларатор* (необязательный) — это имя, по которому осуществляется доступ к элементу в программе. Он должен иметь один из целочисленных типов (включая перечисляемые типы). *Константа-выражение* указывает количество битов, занимаемых элементом в структуре. Анонимные битовые поля, (т. е. битовые поля без идентификатора) можно использовать для заполнения.

> [!NOTE]
> Неименованное битовое поле Width 0 приводит к выравниванию следующего битового поля до границы следующего **типа** , где **Type** — это тип элемента.

В следующем примере объявляется структура, которая содержит битовые поля:

```cpp
// bit_fields1.cpp
// compile with: /LD
struct Date {
   unsigned short nWeekDay  : 3;    // 0..7   (3 bits)
   unsigned short nMonthDay : 6;    // 0..31  (6 bits)
   unsigned short nMonth    : 5;    // 0..12  (5 bits)
   unsigned short nYear     : 8;    // 0..100 (8 bits)
};
```

На следующем рисунке показана концептуальная структура памяти для объекта типа `Date`.

![Макет памяти объекта Date](../cpp/media/vc38uq1.png "Структура памяти объекта данных") <br/>
Структура памяти объекта типа Date

Обратите внимание, что `nYear` имеет размер 8 бит и приведет к переполнению границы слова объявленного типа **без знака** **Short**. Поэтому он начинается в начале нового **неподписанного** **короткого**знака. Совсем не обязательно, чтобы все битовые поля помещались в один объект базового типа; в зависимости от количества бит, запрошенных в объявлении, выделяются новые единицы хранения.

**Блок, относящийся только к системам Майкрософт**

Данные, объявленные в качестве битовых полей, упорядочиваются от младшего бита к старшему, как показано на рисунке выше.

**Завершение блока, относящегося только к системам Майкрософт**

Объявление структуры может содержать неименованное поле длиной 0, как показано в следующем примере.

```cpp
// bit_fields2.cpp
// compile with: /LD
struct Date {
   unsigned nWeekDay  : 3;    // 0..7   (3 bits)
   unsigned nMonthDay : 6;    // 0..31  (6 bits)
   unsigned           : 0;    // Force alignment to next boundary.
   unsigned nMonth    : 5;    // 0..12  (5 bits)
   unsigned nYear     : 8;    // 0..100 (8 bits)
};
```

затем макет памяти показан на следующем рисунке:

![Макет объекта Date с битовым&#45;полем нулевой длины](../cpp/media/vc38uq2.png "Макет объекта Date с битовым&#45;полем нулевой длины") <br/>
Структура объекта типа Date с битовым полем нулевой длины

Базовый тип битового поля должен быть целочисленным типом, как описано в разделе [встроенные типы](../cpp/fundamental-types-cpp.md).

Если инициализатор для ссылки типа `const T&` является левосторонним значением, указывающим на битовое поле типа `T`, ссылка не привязывается к битовому полю напрямую. Вместо этого ссылка привязывается к временной инициализированной переменной для хранения значения битового поля.

## <a name="restrictions-on-bit-fields"></a>Ограничения для битовых полей

В следующем списке указаны ошибочные операции с битовыми полями:

- Получение адреса битового поля.

- Инициализация**неконстантной** ссылки с битовым полем.

## <a name="see-also"></a>См. также:

[Классы и структуры](../cpp/classes-and-structs-cpp.md)