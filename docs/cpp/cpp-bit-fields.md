---
title: Битовые поля в C++
ms.date: 11/19/2018
helpviewer_keywords:
- bitfields [C++]
- fields [C++], bit
- bit fields
ms.assetid: 6f4b62e3-cc1d-4e5d-bf34-05904104f71a
ms.openlocfilehash: 747920378472cc091928a080e303a0543e287aaa
ms.sourcegitcommit: 9e891eb17b73d98f9086d9d4bfe9ca50415d9a37
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2018
ms.locfileid: "52175097"
---
# <a name="c-bit-fields"></a>Битовые поля в C++

Классы и структуры могут содержать члены, которые занимают меньше пространства в памяти, чем целочисленный тип. Эти члены определяются как битовые поля. Синтаксис для битового поля *члена декларатора* спецификации следующим образом:

## <a name="syntax"></a>Синтаксис

*декларатор* **:** *константного выражения*

## <a name="remarks"></a>Примечания

(Необязательно) *декларатор* — это имя, по которому этот член будет доступен в программе. Он должен иметь один из целочисленных типов (включая перечисляемые типы). *Константное_выражение* указывает количество битов, которые член занимает в структуре. Анонимные битовые поля, (т. е. битовые поля без идентификатора) можно использовать для заполнения.

> [!NOTE]
> Неименованное битовое поле шириной 0 обеспечивает выравнивание следующего битового поля к следующему **тип** границы, где **тип** тип члена.

В следующем примере объявляется структура, которая содержит битовые поля:

```cpp
// bit_fields1.cpp
// compile with: /LD
struct Date {
   unsigned short nWeekDay  : 3;    // 0..7   (3 bits)
   unsigned short nMonthDay : 6;    // 0..31  (6 bits)
   unsigned short nMonth    : 5;    // 0..12  (5 bits)
   unsigned short nYear     : 8;    // 0..100 (8 bits)
};
```

На следующем рисунке показана концептуальная структура памяти для объекта типа `Date`.

![Структура памяти объекта даты](../cpp/media/vc38uq1.png "структура памяти объекта даты") <br/>
Структура памяти объекта типа Date

Обратите внимание, что `nYear` 8 бит длиннее и может переполнить границу слова для объявленного типа **без знака** **короткие**. Таким образом, он начался в начале нового **без знака** **короткие**. Совсем не обязательно, чтобы все битовые поля помещались в один объект базового типа; в зависимости от количества бит, запрошенных в объявлении, выделяются новые единицы хранения.

**Блок, относящийся только к системам Microsoft**

Данные, объявленные в качестве битовых полей, упорядочиваются от младшего бита к старшему, как показано на рисунке выше.

**Завершение блока, относящегося только к системам Майкрософт**

Объявление структуры может содержать неименованное поле длиной 0, как показано в следующем примере.

```cpp
// bit_fields2.cpp
// compile with: /LD
struct Date {
   unsigned nWeekDay  : 3;    // 0..7   (3 bits)
   unsigned nMonthDay : 6;    // 0..31  (6 bits)
   unsigned           : 0;    // Force alignment to next boundary.
   unsigned nMonth    : 5;    // 0..12  (5 bits)
   unsigned nYear     : 8;    // 0..100 (8 bits)
};
```

распределение памяти, то как показано на следующем рисунке:

![Структура объекта даты с нулевым&#45;битовое поле длины](../cpp/media/vc38uq2.png "даты из макета объект с нулевым&#45;битовое поле длины") <br/>
Структура объекта типа Date с битовым полем нулевой длины

Базовый тип битового поля должен быть целочисленный тип, как описано в разделе [фундаментальные типы](../cpp/fundamental-types-cpp.md).

Если инициализатор для ссылка типа `const T&` является ссылкой lvalue, на который ссылается на битовое поле типа `T`, ссылка не привязан к битовое поле напрямую. Вместо этого во временный объект инициализируется для хранения значения битового поля привязана ссылка.

## <a name="restrictions-on-bit-fields"></a>Ограничения для битовых полей

В следующем списке указаны ошибочные операции с битовыми полями:

- Получение адреса битового поля.

- Инициализация отличный от**const** ссылку с битовым полем.

## <a name="see-also"></a>См. также

[Классы и структуры](../cpp/classes-and-structs-cpp.md)