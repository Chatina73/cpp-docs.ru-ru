---
title: Числовые, логические литералы и константы-указатели (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- literals, C++
- constants, literals
- literals [C++]
ms.assetid: 17c09fc3-3ad7-47e2-8b48-ba8ae994edc8
ms.openlocfilehash: 467300501ffbbf8063e203d4c7395af34a954ed0
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75301370"
---
# <a name="numeric-boolean-and-pointer-literals"></a>Числовые, логические литералы и константы указателей

Литерал — это элемент программы, который непосредственно представляет значение. В этой статье описываются литералы целого типа, с плавающей запятой, логического типа и типа указателя. Дополнительные сведения о строковых и символьных литералах см. в разделе [строковые иC++символьные литералы ()](../cpp/string-and-character-literals-cpp.md). Можно также определить собственные литералы на основе любой из этих категорий. Дополнительные сведения см. в разделе пользовательские [литералы (C++)](../cpp/user-defined-literals-cpp.md) .

. Литералы можно использовать во многих контекстах, но наиболее часто они используются для инициализации именованных переменных и для передачи аргументов в функции.

```cpp
const int answer = 42; // integer literal
double d = sin(108.87);     //floating point literal passed to sin function
bool b = true;              // boolean literal
MyClass* mc = nullptr;      // pointer literal
```

Иногда важно указывать компилятору, как следует обрабатывать литерал или какой конкретный тип ему предоставить. Это делается путем добавления к литералу префиксов или суффиксов. Например, префикс 0x сообщает компилятору, что следует интерпретировать число, следующее за этим префиксом, как шестнадцатеричное значение, например 0x35. Суффикс ЛНОЕ указывает компилятору обрабатывать значение как тип **Long без знака** , как в 5894345ULL. Полный список префиксов и суффиксов для каждого типа литерала см. в следующих разделах.

## <a name="integer-literals"></a>Целочисленные литералы

Целочисленные литералы начинаются с цифры и не имеют дробных частей или экспонент. Целочисленные литералы можно задавать в десятеричной, восьмеричной или шестнадцатеричной форме. Они могут обозначать знаковые или беззнаковые, а также длине или короткие типы.

Если префикс или суффикс отсутствует, компилятор выдает целочисленное значение типа **int** (32 бит), если оно подходит, в противном случае — значение типа **Long** (64 бит).

Чтобы указать десятичный целочисленный литерал, начинайте спецификацию с любой цифры, кроме нуля. Например:

```cpp
int i = 157;   // Decimal literal
int j = 0198;       // Not a decimal number; erroneous octal literal
int k = 0365;       // Leading zero specifies octal literal, not decimal
int m = 36'000'000  // digit separators make large values more readable
int
```

Чтобы указать восьмеричный целочисленный литерал, начинайте спецификацию с нуля, за которым следует ряд цифр в диапазоне от 0 до 7. Цифры 8 и 9 при указании восьмеричного литерала будут ошибками. Например:

```cpp
int i = 0377;   // Octal literal
int j = 0397;        // Error: 9 is not an octal digit
```

Для указания шестнадцатеричного целочисленного литерала спецификация должна начинаться с префикса `0x` или `0X` (регистр символа «x» не имеет значения), за которым следует ряд цифр в диапазоне от `0` до `9` и от `a` (или `A`) до `f` (или `F`). Шестнадцатеричные цифры от `a` (или `A`) до `f` (или `F`) представляют собой значения в диапазоне от 10 до 15. Например:

```cpp
int i = 0x3fff;   // Hexadecimal literal
int j = 0X3FFF;        // Equal to i
```

Чтобы указать тип без знака, используйте либо суффикс `u`, либо `U`. Чтобы указать тип long, используйте либо суффикс `l`, либо `L`. Для указания 64-разрядного целочисленного типа используется суффикс LL или ll. Суффикс i64 по-прежнему поддерживается, но следует избегать его, так как он характерен только для Майкрософт и не является переносимым. Например:

```cpp
unsigned val_1 = 328u;             // Unsigned value
long val_2 = 0x7FFFFFL;                 // Long value specified
                                        //  as hex literal
unsigned long val_3 = 0776745ul;        // Unsigned long value
auto val_4 = 108LL;                           // signed long long
auto val_4 = 0x8000000000000000ULL << 16;     // unsigned long long
```

**Разделители цифр**. символ одинарной кавычки (апостроф) можно использовать для разделения значений в больших числах, чтобы облегчить чтение людям. Разделители не влияют на компиляцию.

```cpp
long long i = 24'847'458'121
```

## <a name="floating-point-literals"></a>Литералы с плавающей запятой

Литералы с плавающей запятой задают значения, которые должны иметь дробную часть. Эти значения содержат десятичные разделители ( **.** ) и могут содержать экспоненты.

Литералы с плавающей запятой имеют «мантиссу», которая определяет значение числа, «экспоненту», которая определяет порядок числа, и необязательный суффикс, задающий тип константы. Мантисса задается как последовательность цифр, затем точка, за которой следует необязательная последовательность цифр, представляющая дробную часть числа. Например:

```cpp
18.46
38.
```

Если указан показатель степени, он задает порядок числа в виде степени 10, как показано в следующем примере:

```cpp
18.46e0      // 18.46
18.46e1           // 184.6
```

Показатель степени можно указать с помощью `e` или `E`, которые имеют одинаковое значение, за которым следует необязательный знак (+ или-) и последовательность цифр.  Если указан показатель степени, десятичная точка в конце целых чисел не требуется, например `18E0`.

Литералы с плавающей запятой по умолчанию имеют тип **Double**. Используя суффиксы `f` или `l` (или `F` или `L` — суффикс не учитывает регистр), литерал может быть задан как **float** или **long double**соответственно.

Хотя **длинные Double** и **Double** имеют одно и то же представление, они имеют разные типы. Например, можно задать приведенные ниже перегруженные функции

```cpp
void func( double );
```

и

```cpp
void func( long double );
```

## <a name="boolean-literals"></a>Логические литералы

Логические литералы — **true** и **false**.

## <a name="pointer-literal-c11"></a>Литерал-указатель (C++11)

C++вводит литерал [nullptr](../cpp/nullptr.md) для указания нулевого инициализированного указателя. В переносимом коде необходимо использовать **nullptr** вместо целочисленного типа нуля или макросов, таких как null.

## <a name="binary-literals-c14"></a>Двоичные литералы (C++14)

Двоичный литерал можно задать с помощью префикса `0B` или `0b` и последовательности, состоящей из 1 и 0:

```cpp
auto x = 0B001101 ; // int
auto y = 0b000001 ; // int
```

## <a name="avoid-using-literals-as-magic-constants"></a>Избегайте использования литералов как «магических констант»

Несмотря на то что это не всегда является хорошим стилем программирования, можно использовать литералы непосредственно в выражениях и операторах:

```cpp
if (num < 100)
    return "Success";
```

В предыдущем примере, возможно, лучше было бы использовать именованную константу, которая более точно передает смысл, например MAXIMUM_ERROR_THRESHOLD. И если возвращаемое значение Success видят конечные пользователи, то, возможно, лучше было бы использовать именованную строковую константу, которая хранится в одном месте в файле, где ее можно локализовать на другие языки. Использование именованных констант помогает вам и другим пользователям понимать назначение кода.

## <a name="see-also"></a>См. также:

[Лексические соглашения](../cpp/lexical-conventions.md)<br/>
[C++Строковые литералы](../cpp/string-and-character-literals-cpp.md)<br/>
[C++Пользовательские литералы](../cpp/user-defined-literals-cpp.md)