---
title: Числовые, логические литералы и литералы-указатели (C++)
ms.date: 11/04/2016
helpviewer_keywords:
- literals, C++
- constants, literals
- literals [C++]
ms.assetid: 17c09fc3-3ad7-47e2-8b48-ba8ae994edc8
ms.openlocfilehash: f263e9a2ed357cdc80ec29fc5d1b6d58c9e093e4
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62245106"
---
# <a name="numeric-boolean-and-pointer-literals--c"></a>Числовые, логические литералы и литералы-указатели (C++)

Литерал — это элемент программы, который непосредственно представляет значение. В этой статье описываются литералы целого типа, с плавающей запятой, логического типа и типа указателя. Сведения о строковых и символьных литералах см. в разделе [строковые и символьные литералы (C++)](../cpp/string-and-character-literals-cpp.md). Можно также определить собственные литералы на основе любого из этих категорий; Дополнительные сведения см. в разделе [определяемые пользователем литералы (C++)](../cpp/user-defined-literals-cpp.md)

. Литералы можно использовать во многих контекстах, но наиболее часто они используются для инициализации именованных переменных и для передачи аргументов в функции.

```cpp
const int answer = 42; // integer literal
double d = sin(108.87);     //floating point literal passed to sin function
bool b = true;              // boolean literal
MyClass* mc = nullptr;      // pointer literal
```

Иногда важно указывать компилятору, как следует обрабатывать литерал или какой конкретный тип ему предоставить. Это делается путем добавления к литералу префиксов или суффиксов. Например, префикс 0x сообщает компилятору, что следует интерпретировать число, следующее за этим префиксом, как шестнадцатеричное значение, например 0x35. Суффикс ull сообщает компилятору считать значение **long long без знака** тип, как показано 5894345ULL. Полный список префиксов и суффиксов для каждого типа литерала см. в следующих разделах.

## <a name="syntax"></a>Синтаксис

## <a name="integer-literals"></a>Целочисленные литералы

Целочисленные литералы начинаются с цифры и не имеют дробных частей или экспонент. Целочисленные литералы можно задавать в десятеричной, восьмеричной или шестнадцатеричной форме. Они могут обозначать знаковые или беззнаковые, а также длине или короткие типы.

Если ни одного префикса или суффикса, компилятор будет предоставлять тип целочисленного литерала **int** (32 бита), если значение помещается в журнал, в противном случае он будет предоставлять тип **long long** (64 бита).

Чтобы указать десятичный целочисленный литерал, начинайте спецификацию с любой цифры, кроме нуля. Пример:

```cpp
int i = 157;   // Decimal literal
int j = 0198;       // Not a decimal number; erroneous octal literal
int k = 0365;       // Leading zero specifies octal literal, not decimal
int m = 36'000'000  // digit separators make large values more readable
int
```

Чтобы указать восьмеричный целочисленный литерал, начинайте спецификацию с нуля, за которым следует ряд цифр в диапазоне от 0 до 7. Цифры 8 и 9 при указании восьмеричного литерала будут ошибками. Пример:

```cpp
int i = 0377;   // Octal literal
int j = 0397;        // Error: 9 is not an octal digit
```

Для указания шестнадцатеричного целочисленного литерала спецификация должна начинаться с префикса `0x` или `0X` (регистр символа «x» не имеет значения), за которым следует ряд цифр в диапазоне от `0` до `9` и от `a` (или `A`) до `f` (или `F`). Шестнадцатеричные цифры от `a` (или `A`) до `f` (или `F`) представляют собой значения в диапазоне от 10 до 15. Пример:

```cpp
int i = 0x3fff;   // Hexadecimal literal
int j = 0X3FFF;        // Equal to i
```

Чтобы указать тип без знака, используйте `u` или `U` суффикс. Для указания типа long, используется `l` или `L` суффикс. Для указания 64-разрядного целочисленного типа используется суффикс LL или ll. Суффикс i64 по-прежнему поддерживается, но следует избегать его, так как он характерен только для Майкрософт и не является переносимым. Пример:

```cpp
unsigned val_1 = 328u;             // Unsigned value
long val_2 = 0x7FFFFFL;                 // Long value specified
                                        //  as hex literal
unsigned long val_3 = 0776745ul;        // Unsigned long value
auto val_4 = 108LL;                           // signed long long
auto val_4 = 0x8000000000000000ULL << 16;     // unsigned long long
```

**Разделители между цифрами**: Можно использовать символ одинарной кавычки (апостроф) для разделения значений разряда в больших числах, чтобы сделать их более удобными для удобочитаемости. Разделители не влияют на компиляцию.

```cpp
long long i = 24'847'458'121
```

## <a name="floating-point-literals"></a>Литералы с плавающей запятой

Литералы с плавающей запятой задают значения, которые должны иметь дробную часть. Эти значения содержат десятичные точки (**.**) и могут содержать показатели степени.

Литералы с плавающей запятой имеют «мантиссу», которая определяет значение числа, «экспоненту», которая определяет порядок числа, и необязательный суффикс, задающий тип константы. Мантисса задается как последовательность цифр, затем точка, за которой следует необязательная последовательность цифр, представляющая дробную часть числа. Пример:

```cpp
18.46
38.
```

Если указан показатель степени, он задает порядок числа в виде степени 10, как показано в следующем примере:

```cpp
18.46e0      // 18.46
18.46e1           // 184.6
```

Показатель степени могут быть определены с помощью `e` или `E`, которые имеют одинаковое значение, затем следует необязательный знак (+ или -) и последовательность цифр.  Если указан показатель степени, десятичная точка в конце целых чисел не требуется, например `18E0`.

Литералы с плавающей запятой по умолчанию тип **двойные**. С помощью суффиксов `f` или `l` (или `F` или `L` — суффикс выполняется без учета регистра), литерала может быть указан как **float** или **long double**, соответственно.

Несмотря на то что **long double** и **двойные** имеют одинаковое представление, они не относятся к одному типу. Например, можно задать приведенные ниже перегруженные функции

```cpp
void func( double );
```

и

```cpp
void func( long double );
```

## <a name="boolean-literals"></a>Логические литералы

Логические литералы — **true** и **false**.

## <a name="pointer-literal-c11"></a>Литерал-указатель (C++11)

В C++ появилась [nullptr](../cpp/nullptr.md) литерала, чтобы задать для указателя, инициализируемого нулевым значением. В переносимом коде **nullptr** следует использовать вместо нуля целочисленного типа или макросов, таких как NULL.

## <a name="binary-literals-c14"></a>Двоичные литералы (C++14)

Двоичный литерал можно задать с помощью префикса `0B` или `0b` и последовательности, состоящей из 1 и 0:

```cpp
auto x = 0B001101 ; // int
auto y = 0b000001 ; // int
```

## <a name="avoid-using-literals-as-magic-constants"></a>Избегайте использования литералов как «магических констант»

Несмотря на то что это не всегда является хорошим стилем программирования, можно использовать литералы непосредственно в выражениях и операторах:

```cpp
if (num < 100)
    return "Success";
```

В предыдущем примере, возможно, лучше было бы использовать именованную константу, которая более точно передает смысл, например MAXIMUM_ERROR_THRESHOLD. И если возвращаемое значение Success видят конечные пользователи, то, возможно, лучше было бы использовать именованную строковую константу, которая хранится в одном месте в файле, где ее можно локализовать на другие языки. Использование именованных констант помогает вам и другим пользователям понимать назначение кода.

## <a name="see-also"></a>См. также

[Лексические соглашения](../cpp/lexical-conventions.md)<br/>
[Строковые литералы в C++](../cpp/string-and-character-literals-cpp.md)<br/>
[Определяемые пользователем литералы C++](../cpp/user-defined-literals-cpp.md)