---
title: Числовые, логические литералы и константы-указатели (C++)
description: Форматы Standard языка C++ для целых чисел, чисел с плавающей запятой, логических значений и литералов-указателей.
ms.date: 11/04/2016
helpviewer_keywords:
- literals, C++
- constants, literals
- literals [C++]
ms.assetid: 17c09fc3-3ad7-47e2-8b48-ba8ae994edc8
ms.openlocfilehash: f817fcca35a741dac29047e214897758cdc93edb
ms.sourcegitcommit: c0c9cdae79f19655e809a4979227c51bb19cff63
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2021
ms.locfileid: "102236716"
---
# <a name="numeric-boolean-and-pointer-literals"></a>Числовые, логические литералы и литералы-указатели

Литерал — это элемент программы, который непосредственно представляет значение. В этой статье рассматриваются литералы типа Integer, float-Point, Boolean и Pointer. Дополнительные сведения о строковых и символьных литералах см. в разделе [строковые и символьные литералы (C++)](../cpp/string-and-character-literals-cpp.md). Можно также определить собственные литералы на основе любой из этих категорий. Дополнительные сведения см. в разделе [определяемые пользователем литералы (C++)](../cpp/user-defined-literals-cpp.md).

Литералы можно использовать во многих контекстах, но наиболее часто они используются для инициализации именованных переменных и для передачи аргументов в функции.

```cpp
const int answer = 42;      // integer literal
double d = sin(108.87);     // floating point literal passed to sin function
bool b = true;              // boolean literal
MyClass* mc = nullptr;      // pointer literal
```

Иногда важно указывать компилятору, как следует обрабатывать литерал или какой конкретный тип ему предоставить. Это делается путем добавления префиксов или суффиксов к литералу. Например, префикс `0x` указывает компилятору интерпретировать число, следующее за ним, как шестнадцатеричное значение, например `0x35` . `ULL`Суффикс указывает компилятору обрабатывать значение как **`unsigned long long`** тип, как в `5894345ULL` . Полный список префиксов и суффиксов для каждого типа литерала см. в следующих разделах.

## <a name="integer-literals"></a>Целочисленные литералы

Целочисленные литералы начинаются с цифры и не имеют дробных частей или экспонент. Целочисленные литералы можно указать в десятичной, двоичной, восьмеричной или шестнадцатеричной форме. При необходимости можно указать целочисленный литерал как неподписанный, а в качестве типа long или long — с помощью суффикса.

Если префикс или суффикс отсутствует, компилятор выдает целочисленный тип литерального значения **`int`** (32 бит), если значение подходит, в противном случае присваивает ему тип **`long long`** (64 бит).

Чтобы указать десятичный целочисленный литерал, начинайте спецификацию с любой цифры, кроме нуля. Пример:

```cpp
int i = 157;        // Decimal literal
int j = 0198;       // Not a decimal number; erroneous octal literal
int k = 0365;       // Leading zero specifies octal literal, not decimal
int m = 36'000'000  // digit separators make large values more readable
```

Чтобы указать восьмеричный целочисленный литерал, начинайте спецификацию с нуля, за которым следует ряд цифр в диапазоне от 0 до 7. Цифры 8 и 9 при указании восьмеричного литерала будут ошибками. Пример:

```cpp
int i = 0377;   // Octal literal
int j = 0397;   // Error: 9 is not an octal digit
```

Чтобы указать шестнадцатеричный целочисленный литерал, начните спецификацию с `0x` или `0X` (регистр «x не важен)», за которым следует последовательность цифр в диапазоне от `0` до `9` и `a` (или `A` ) до `f` (или `F` ). Шестнадцатеричные цифры от `a` (или `A`) до `f` (или `F`) представляют собой значения в диапазоне от 10 до 15. Пример:

```cpp
int i = 0x3fff;   // Hexadecimal literal
int j = 0X3FFF;   // Equal to i
```

Чтобы указать тип без знака, используйте либо `u` суффикс, либо `U` . Чтобы указать тип long, используйте либо суффикс, `l` либо `L` . Для указания 64-разрядного целочисленного типа используется суффикс LL или ll. Суффикс I64 по-прежнему поддерживается, но не рекомендуется. Он относится только к Майкрософт и не является переносимым. Пример:

```cpp
unsigned val_1 = 328u;                  // Unsigned value
long val_2 = 0x7FFFFFL;                 // Long value specified
                                        //  as hex literal
unsigned long val_3 = 0776745ul;        // Unsigned long value
auto val_4 = 108LL;                           // signed long long
auto val_4 = 0x8000000000000000ULL << 16;     // unsigned long long
```

**Разделители цифр**. символ одинарной кавычки (апостроф) можно использовать для разделения значений в больших числах, чтобы облегчить чтение людям. Разделители не влияют на компиляцию.

```cpp
long long i = 24'847'458'121
```

## <a name="floating-point-literals"></a>Литералы с плавающей запятой

Литералы с плавающей запятой задают значения, которые должны иметь дробную часть. Эти значения содержат десятичные разделители ( **`.`** ) и могут содержать экспоненты.

Литералы с плавающей запятой имеют *значащим* (иногда называется *мантиссаом*), который указывает значение числа. Они имеют *показатель степени*, который указывает величину числа. И имеют необязательный суффикс, указывающий тип литерала. Значащим указывается как последовательность цифр, за которыми следует точка, за которой следует дополнительная последовательность цифр, представляющая дробную часть числа. Пример:

```cpp
18.46
38.
```

Если указан показатель степени, он задает порядок числа в виде степени 10, как показано в следующем примере:

```cpp
18.46e0      // 18.46
18.46e1      // 184.6
```

Показатель степени можно указать с помощью `e` или `E` , который имеет то же значение, за которым следует необязательный знак (+ или-) и последовательность цифр.  Если указан показатель степени, десятичная точка в конце целых чисел не требуется, например `18E0`.

Литералы с плавающей запятой по умолчанию имеют тип **`double`** . Используя суффиксы или OR `f` `l` `F` `L` (суффикс не учитывает регистр), литерал можно указать как **`float`** или **`long double`** .

Хотя **`long double`** и **`double`** имеют одинаковое представление, они имеют разные типы. Например, можно использовать перегруженные функции, такие как

```cpp
void func( double );
```

и

```cpp
void func( long double );
```

## <a name="boolean-literals"></a>логические литералы

Логические литералы: **`true`** и **`false`** .

## <a name="pointer-literal-c11"></a>Литерал-указатель (C++11)

C++ вводит [`nullptr`](../cpp/nullptr.md) литерал для указания нулевого инициализированного указателя. В переносимом коде **`nullptr`** следует использовать вместо целочисленного типа нуля или макросов, таких как `NULL` .

## <a name="binary-literals-c14"></a>Двоичные литералы (C++14)

Двоичный литерал можно задать с помощью префикса `0B` или `0b` и последовательности, состоящей из 1 и 0:

```cpp
auto x = 0B001101 ; // int
auto y = 0b000001 ; // int
```

## <a name="avoid-using-literals-as-magic-constants"></a>Избегайте использования литералов как «магических констант»

Несмотря на то что это не всегда является хорошим стилем программирования, можно использовать литералы непосредственно в выражениях и операторах:

```cpp
if (num < 100)
    return "Success";
```

В предыдущем примере рекомендуется использовать именованную константу, которая передает ясное значение, например "MAXIMUM_ERROR_THRESHOLD". Если конечные пользователи видят возвращаемое значение Success, возможно, лучше использовать именованную строковую константу. Строковые константы можно хранить в одном месте в файле, который может быть локализован на другие языки. Использование именованных констант помогает обоим и другим пользователям понять смысл кода.

## <a name="see-also"></a>См. также раздел

[Лексические соглашения](../cpp/lexical-conventions.md)<br/>
[Строковые литералы C++](../cpp/string-and-character-literals-cpp.md)<br/>
[Определяемые пользователем литералы C++](../cpp/user-defined-literals-cpp.md)
