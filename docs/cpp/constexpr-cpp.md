---
title: constexpr (C++)
ms.date: 08/05/2019
f1_keywords:
- constexpr_cpp
ms.assetid: c6458ccb-51c6-4a16-aa61-f69e6f4e04f7
ms.openlocfilehash: 5c98436f537b34b1c9050e057971938d48792db1
ms.sourcegitcommit: c3bf94210bdb73be80527166264d49e33784152c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/06/2019
ms.locfileid: "68821095"
---
# <a name="constexpr-c"></a>constexpr (C++)

Ключевое слово **constexpr** было введено в c++ 11 и улучшено в c++ 14. Это означает *константное выражение*. Как и **const**, его можно применять к переменным, чтобы при попытке какого-либо кода изменить значение возникала ошибка компилятора. В отличие от **const**, **constexpr** также можно применять к функциям и конструкторам классов. **constexpr** указывает, что значение или возвращаемое значение является константой и, если возможно, вычислено во время компиляции.

Целочисленное значение **constexpr** можно использовать везде, где требуется константное целое, например в аргументах шаблона и в объявлениях массивов. Если значение может быть вычислено во время компиляции, а не во время выполнения, оно может помочь ускорить работу программы и уменьшить объем памяти.

Для ограничения сложности вычислений времени компиляции и их возможного влияния на время компиляции стандарт C++ 14 требует, чтобы типы в константных выражениях были [литеральными типами](trivial-standard-layout-and-pod-types.md#literal_types).

## <a name="syntax"></a>Синтаксис

> **constexpr** *литерал типа* *идентификатор* **=** *константное_выражение* **;** 
>  **constexpr** *литерал типа* *идентификатор* **{** *константного выражения* **}** **;** 
>  **constexpr** *литерал типа* *идентификатор* **(** *params* **)** **;** 
>  **constexpr** *ctor* **(** *params* **)** **;**

## <a name="parameters"></a>Параметры

*params*<br/>
Один или несколько параметров, каждый из которых должен быть типом литерала и сам должен быть константным выражением.

## <a name="return-value"></a>Возвращаемое значение

Переменная или функция constexpr должна возвращать [литеральный тип](trivial-standard-layout-and-pod-types.md#literal_types).

## <a name="constexpr-variables"></a>переменные constexpr

Основное различие между переменными const и constexpr заключается в том, что инициализация переменной const может быть отложена до времени выполнения. Переменная constexpr должна быть инициализирована во время компиляции.  Все переменные constexpr относятся к типу const.

- Переменная может быть объявлена с помощью **constexpr**, если она имеет литеральный тип и инициализирована. Если инициализация выполняется конструктором, конструктор должен быть объявлен как **constexpr**.

- Ссылка может быть объявлена как constexpr, если объект, на который она ссылается, был инициализирован с помощью константного выражения, а любые неявные преобразования, вызываемые во время инициализации, также являются константными выражениями.

- Все объявления переменных или функций **constexpr** должны иметь спецификатор **constexpr** .

```cpp
constexpr float x = 42.0;
constexpr float y{108};
constexpr float z = exp(5, 3);
constexpr int i; // Error! Not initialized
int j = 0;
constexpr int k = j + 1; //Error! j not a constant expression
```

## <a name="constexpr_functions"></a>функции constexpr

Функция **constexpr** , возвращаемое значение которого может быть вычислена во время компиляции, если это требуется для использования кода. Для использования кода требуется возвращаемое значение во время компиляции, например, для инициализации переменной **constexpr** или предоставления аргумента шаблона, не являющегося типом. Если его аргументы являются значениями **constexpr** , функция **constexpr** выдает константу времени компиляции. При вызове с аргументами, отличными от**constexpr** , или когда его значение не требуется во время компиляции, оно создает значение во время выполнения, например обычную функцию. (Это двойное поведение избавляет от необходимости писать версии **constexpr** и не-**constexpr** для одной и той же функции.)

Функция **constexpr** или конструктор неявно встроена в **строку**.

К функциям constexpr применяются следующие правила.

- Функция **constexpr** должна принимать и возвращать только [типы литералов](trivial-standard-layout-and-pod-types.md#literal_types).

- Функция **constexpr** может быть рекурсивной.

- Он не может быть [виртуальным](../cpp/virtual-cpp.md). Конструктор не может быть определен как constexpr, если включающий класс имеет какие-либо виртуальные базовые классы.

- Тело может быть определено как `= default` или `= delete`.

- Текст не может содержать операторы **goto** или блоки try.

- Явная специализация шаблона, не относящегося к constexpr, может быть объявлена как **constexpr**:

- Явная специализация шаблона **constexpr** также не обязательно должна быть **constexpr**:

Следующие правила применяются к функциям **constexpr** в Visual Studio 2017 и более поздних версий:

- Он может содержать операторы **If** и **switch** , а также все операторы цикла, в том числе **для**, на основе диапазонов для, **while**и **do-while**.

- Он может содержать объявления локальных переменных, но переменная должна быть инициализирована, должна быть литеральным типом и не может быть статической или локальной в потоке. Локально объявленная переменная не обязательно должна быть константой и может изменяться.

- Нестатическая функция-член constexpr не обязательно должна быть неявно константой.

```cpp
constexpr float exp(float x, int n)
{
    return n == 0 ? 1 :
        n % 2 == 0 ? exp(x * x, n / 2) :
        exp(x * x, (n - 1) / 2) * x;
};
```

> [!TIP]
> В отладчике Visual Studio при отладке неоптимизированной отладочной сборки можно определить, вычисляется ли функция **constexpr** во время компиляции, поместив в нее точку останова. Попадание в точку останова означает, что функция была вызвана во время выполнения.  Если попадания в точку останова не происходит, это означает, что функция была вызвана во время компиляции.

## <a name="extern-constexpr"></a>extern constexpr

Параметр компилятора [/Zc: externConstexpr](../build/reference/zc-externconstexpr.md) приводит к тому, что компилятор применяет [внешнюю компоновку](../c-language/external-linkage.md) к переменным, объявленным с помощью **extern constexpr**. В более ранних версиях Visual Studio и по умолчанию или при указании параметра **/Zc: externConstexpr** в Visual Studio применяет внутреннюю компоновку к переменным **constexpr** , даже если используется ключевое слово **extern** . Параметр **/Zc: externConstexpr** доступен начиная с Visual Studio 2017 с обновлением 15,6 и по умолчанию отключен. Параметр/permissive-не включает **/Zc: externConstexpr**.

## <a name="example"></a>Пример

В следующем примере показаны переменные **constexpr** , функции и определяемый пользователем тип. В последней инструкции в методе Main () функция-член **constexpr** GetValue () является вызовом во время выполнения, поскольку значение не обязательно должно быть известно во время компиляции.

```cpp
// constexpr.cpp
// Compile with: cl /EHsc /W4 constexpr.cpp
#include <iostream>

using namespace std;

// Pass by value
constexpr float exp(float x, int n)
{
    return n == 0 ? 1 :
        n % 2 == 0 ? exp(x * x, n / 2) :
        exp(x * x, (n - 1) / 2) * x;
};

// Pass by reference
constexpr float exp2(const float& x, const int& n)
{
    return n == 0 ? 1 :
        n % 2 == 0 ? exp2(x * x, n / 2) :
        exp2(x * x, (n - 1) / 2) * x;
};

// Compile-time computation of array length
template<typename T, int N>
constexpr int length(const T(&)[N])
{
    return N;
}

// Recursive constexpr function
constexpr int fac(int n)
{
    return n == 1 ? 1 : n * fac(n - 1);
}

// User-defined type
class Foo
{
public:
    constexpr explicit Foo(int i) : _i(i) {}
    constexpr int GetValue() const
    {
        return _i;
    }
private:
    int _i;
};

int main()
{
    // foo is const:
    constexpr Foo foo(5);
    // foo = Foo(6); //Error!

    // Compile time:
    constexpr float x = exp(5, 3);
    constexpr float y { exp(2, 5) };
    constexpr int val = foo.GetValue();
    constexpr int f5 = fac(5);
    const int nums[] { 1, 2, 3, 4 };
    const int nums2[length(nums) * 2] { 1, 2, 3, 4, 5, 6, 7, 8 };

    // Run time:
    cout << "The value of foo is " << foo.GetValue() << endl;
}
```

## <a name="requirements"></a>Требования

Visual Studio 2015 или более поздней версии.

## <a name="see-also"></a>См. также

[Объявления и определения](../cpp/declarations-and-definitions-cpp.md)\
[const](../cpp/const-cpp.md)
