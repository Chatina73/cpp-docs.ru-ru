---
title: Смешивание исключений C (структурированная) и C++
description: Как смешивать обработку структурированных исключений и исключений C++ и некоторые потенциальные проблемы.
ms.date: 08/24/2020
helpviewer_keywords:
- exceptions [C++], mixed C and C++
- C++ exception handling, mixed-language
- structured exception handling [C++], mixed C and C++
- catch keyword [C++], mixed
- try-catch keyword [C++], mixed-language
ms.assetid: a149154e-36dd-4d1a-980b-efde2a563a56
ms.openlocfilehash: 98ce2335ff3b08b7a5d71e03305c481ba068e5e6
ms.sourcegitcommit: efc8c32205c9d610f40597556273a64306dec15d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/26/2020
ms.locfileid: "88898416"
---
# <a name="mixing-c-structured-and-c-exceptions"></a>Смешивание исключений C (структурированная) и C++

Если вы хотите написать переносимый код, использование структурированной обработки исключений (SEH) в программе C++ не рекомендуется. Однако иногда может потребоваться компиляция с использованием [`/EHa`](../build/reference/eh-exception-handling-model.md) и смешение структурированных исключений и исходного кода C++, а также необходимость в некоторых средствах для обработки обоих видов исключений. Поскольку структурированный обработчик исключений не имеет концепции объектов или типизированных исключений, он не может управлять исключениями, созданными кодом C++. Однако **`catch`** обработчики C++ могут управлять структурированными исключениями. Синтаксис обработки исключений C++ ( **`try`** , **`throw`** , **`catch`** ) не принимается компилятором C, но структурированный синтаксис обработки исключений ( **`__try`** , **`__except`** , **`__finally`** ) поддерживается компилятором C++.

[`_set_se_translator`](../c-runtime-library/reference/set-se-translator.md)Дополнительные сведения об обработке структурированных исключений в виде исключений C++ см. в разделе.

При смешении структурированных и C++ исключений следует учитывать следующие возможные проблемы:

- Исключения C++ и структурированные исключения не могут смешиваться в одной и той же функции.

- Обработчики завершения ( **`__finally`** блоки) всегда выполняются даже во время очистки после возникновения исключения.

- Обработка исключений C++ может перехватывать и сохранять семантику очистки во всех модулях, скомпилированных с помощью [`/EH`](../build/reference/eh-exception-handling-model.md) параметров компилятора, которые обеспечивают семантику очистки.

- Могут возникнуть ситуации, в которых функции деструктора не вызываются для всех объектов. Например, структурированное исключение может возникнуть при попытке выполнить вызов функции через неинициализированный указатель функции. Если параметры функции являются объектами, созданными до вызова, деструкторы этих объектов не вызываются во время очистки стека.

## <a name="next-steps"></a>Дальнейшие действия

- [Использование `setjmp` или `longjmp` в программах на C++](../cpp/using-setjmp-longjmp.md)

  См. Дополнительные сведения об использовании `setjmp` и `longjmp` в программах на C++.

- [Обработка структурированных исключений в C++](../cpp/exception-handling-differences.md)

  См. примеры способов использования C++ для управления структурированными исключениями.

## <a name="see-also"></a>См. также

[Современные рекомендации по C++ для исключений и обработки ошибок](../cpp/errors-and-exception-handling-modern-cpp.md)
