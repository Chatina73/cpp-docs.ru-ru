---
title: Смешивание исключений C (структурированная) и C++
ms.date: 08/14/2018
helpviewer_keywords:
- exceptions [C++], mixed C and C++
- C++ exception handling, mixed-language
- structured exception handling [C++], mixed C and C++
- catch keyword [C++], mixed
- try-catch keyword [C++], mixed-language
ms.assetid: a149154e-36dd-4d1a-980b-efde2a563a56
ms.openlocfilehash: 72ddde9bc284a005c77694d599a8e9a3908cb2d0
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87233695"
---
# <a name="mixing-c-structured-and-c-exceptions"></a>Смешивание исключений C (структурированная) и C++

Если вы хотите написать переносимый код, использование структурированной обработки исключений (SEH) в программе C++ не рекомендуется. Однако иногда может потребоваться компилировать с помощью [/EHa](../build/reference/eh-exception-handling-model.md) и смешивать структурированные исключения и исходный код C++, а также требовать некоторых средств для обработки обоих видов исключений. Поскольку структурированный обработчик исключений не имеет концепции объектов или типизированных исключений, он не может управлять исключениями, созданными кодом C++. Однако **`catch`** обработчики C++ могут управлять структурированными исключениями. Синтаксис обработки исключений C++ ( **`try`** , **`throw`** , **`catch`** ) не принимается компилятором C, но структурированный синтаксис обработки исключений (**__try**, **`__except`** , **`__finally`** ) поддерживается компилятором C++.

Сведения об обработке структурированных исключений в виде исключений C++ см. в разделе [_set_se_translator](../c-runtime-library/reference/set-se-translator.md) .

При смешении структурированных и C++ исключений следует учитывать следующие возможные проблемы:

- Исключения С++ и структурированные исключения невозможно комбинировать в одной функции.

- Обработчики завершения ( **`__finally`** блоки) всегда выполняются даже во время очистки после возникновения исключения.

- Обработка исключений C++ может перехватывать и сохранять семантику очистки во всех модулях, скомпилированных с помощью параметров компилятора [/EH](../build/reference/eh-exception-handling-model.md) , которые обеспечивают семантику очистки.

- Могут возникнуть ситуации, когда функции деструктора не вызываются для всех объектов. Например, если структурированное исключение возникает при попытке выполнить вызов функции через неинициализированный указатель функции, а эта функция принимает в качестве объектов параметров, созданных до вызова, деструкторы этих объектов не вызываются во время очистки стека.

## <a name="next-steps"></a>Дальнейшие шаги

- [Использование setjmp или longjmp в программах на языке C++](../cpp/using-setjmp-longjmp.md)

  См. Дополнительные сведения об использовании `setjmp` и `longjmp` в программах на C++.

- [Обработка структурированных исключений в C++](../cpp/exception-handling-differences.md)

  См. примеры способов использования C++ для управления структурированными исключениями.

## <a name="see-also"></a>См. также статью

[Современные рекомендации по C++ для исключений и обработки ошибок](../cpp/errors-and-exception-handling-modern-cpp.md)
