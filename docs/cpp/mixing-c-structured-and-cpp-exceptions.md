---
title: Смешивание C (структурированной) C++ и исключений
ms.date: 08/14/2018
helpviewer_keywords:
- exceptions [C++], mixed C and C++
- C++ exception handling, mixed-language
- structured exception handling [C++], mixed C and C++
- catch keyword [C++], mixed
- try-catch keyword [C++], mixed-language
ms.assetid: a149154e-36dd-4d1a-980b-efde2a563a56
ms.openlocfilehash: e49731f1c81057002eaae2bef16cda4a5cf86f8d
ms.sourcegitcommit: 654aecaeb5d3e3fe6bc926bafd6d5ace0d20a80e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2019
ms.locfileid: "74246463"
---
# <a name="mixing-c-structured-and-c-exceptions"></a>Смешивание C (структурированной) C++ и исключений

Если вы хотите написать переносимый код, использование структурированной обработки исключений (SEH) в C++ программе не рекомендуется. Однако иногда может потребоваться компиляция с использованием [/EHa](../build/reference/eh-exception-handling-model.md) и смешение структурированных исключений и C++ исходного кода, а также необходимость в некоторых средствах для обработки исключений обоих типов. Поскольку структурированный обработчик исключений не имеет концепции объектов или типизированных исключений, он не может управлять исключениями C++ , создаваемыми кодом. C++ Однако обработчики **catch** могут управлять структурированными исключениями. C++синтаксис обработки исключений (**try**, **throw**, **catch**) не принимается компилятором C, но структурированный синтаксис обработки исключений (**__try**, **__except**, **__finally**) поддерживается C++ компилятором.

Дополнительные сведения об обработке структурированных исключений как C++ исключений см. в разделе [_set_se_translator](../c-runtime-library/reference/set-se-translator.md).

При смешении структурированных C++ и исключений следует учитывать следующие возможные проблемы.

- Исключения С++ и структурированные исключения невозможно комбинировать в одной функции.

- Обработчики завершения (блоки **__finally** ) всегда выполняются даже во время очистки после возникновения исключения.

- C++Обработка исключений может перехватывать и сохранять семантику очистки во всех модулях, скомпилированных с помощью параметров компилятора [/EH](../build/reference/eh-exception-handling-model.md) , которые обеспечивают семантику очистки.

- Могут возникнуть ситуации, когда функции деструктора не вызываются для всех объектов. Например, если структурированное исключение возникает при попытке выполнить вызов функции через неинициализированный указатель функции, а эта функция принимает в качестве объектов параметров, созданных до вызова, деструкторы этих объектов не вызываются. во время очистки стека.

## <a name="next-steps"></a>Следующие шаги

- [Использование setjmp или longjmp в C++ программах](../cpp/using-setjmp-longjmp.md)

  Дополнительные сведения об использовании `setjmp` и `longjmp` в C++ разделе программы.

- [Обработка структурированных исключений в C++](../cpp/exception-handling-differences.md)

  См. примеры способов, которые можно использовать C++ для управления структурированными исключениями.

## <a name="see-also"></a>См. также

[Современные C++ рекомендации по исключениям и обработке ошибок](../cpp/errors-and-exception-handling-modern-cpp.md)
