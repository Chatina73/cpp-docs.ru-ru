---
title: Практическое руководство. Разработка с учетом безопасности исключений
ms.custom: how-to
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: 19ecc5d4-297d-4c4e-b4f3-4fccab890b3d
ms.openlocfilehash: 37ebcc646864774b15513c9e1891ba14e0705298
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "59237202"
---
# <a name="how-to-design-for-exception-safety"></a>Практическое руководство. Разработка с учетом безопасности исключений

Одним из преимуществ механизм обработки исключений является исполнения, вместе с данными об исключении, переход непосредственно из оператор, который вызывает исключение к первому catch инструкция, которая его обрабатывает. Обработчик может быть любое количество уровней вверх в стеке вызовов. Функции, вызываемые между оператором try и оператор throw не требуются какие-либо исключения, которое возникает исключение.  Тем не менее они должны быть разработаны таким образом, они могут выходят за пределы области действия «неожиданно» в любой точке, где исключение может распространяться вверх от ниже и таким образом без расставаясь частично созданные объекты, утечка памяти, или структур данных, которые находятся в состоянии, непригодном для использования.

## <a name="basic-techniques"></a>Основные методы

Политику надежной обработки исключений требует тщательного и должны быть частью процесса разработки. Как правило обнаруживаются и исключение на нижних уровнях модуля программного обеспечения большинство исключений, но обычно эти уровни не имеют достаточно информации для обработки ошибки или не предоставляет сообщение для конечных пользователей. На среднем уровне функции можно перехватить и повторно создавать исключение, если у них проверяемый объект исключения, или у них есть дополнительные полезные сведения для обеспечения верхнего уровня, который в конечном счете перехватывает исключение. Функция следует перехватывать и «проглотить» исключение, только в том случае, если это возможность полностью восстановить из него. Во многих случаях правильное поведение на средней уровнях является let исключения распространяются вверх по стеку вызовов. Даже на самый высокий уровень может понадобиться разрешить завершение программы, если исключение покидает программу в состояние, в котором невозможно гарантировать правильность необработанное исключение.

Независимо от того, как функция обрабатывает исключение, которое позволяет гарантировать, что это «безопасный в отношении исключений,» при его разработке нужно в соответствии с следующие базовые правила.

### <a name="keep-resource-classes-simple"></a>Усложнять классы ресурсов

При инкапсулировать управления ресурсами вручную в классах, используйте класс, который не выполняет никаких действий, за исключением управления одного ресурса. Сохраняя класс простой, уменьшить риск появления утечку ресурсов. Используйте [интеллектуальные указатели](../cpp/smart-pointers-modern-cpp.md) по возможности, как показано в следующем примере. В этом примере намеренно искусственный и упрощен, чтобы выделить различия при `shared_ptr` используется.

```cpp
// old-style new/delete version
class NDResourceClass {
private:
    int*   m_p;
    float* m_q;
public:
    NDResourceClass() : m_p(0), m_q(0) {
        m_p = new int;
        m_q = new float;
    }

    ~NDResourceClass() {
        delete m_p;
        delete m_q;
    }
    // Potential leak! When a constructor emits an exception,
    // the destructor will not be invoked.
};

// shared_ptr version
#include <memory>

using namespace std;

class SPResourceClass {
private:
    shared_ptr<int> m_p;
    shared_ptr<float> m_q;
public:
    SPResourceClass() : m_p(new int), m_q(new float) { }
    // Implicitly defined dtor is OK for these members,
    // shared_ptr will clean up and avoid leaks regardless.
};

// A more powerful case for shared_ptr

class Shape {
    // ...
};

class Circle : public Shape {
    // ...
};

class Triangle : public Shape {
    // ...
};

class SPShapeResourceClass {
private:
    shared_ptr<Shape> m_p;
    shared_ptr<Shape> m_q;
public:
    SPShapeResourceClass() : m_p(new Circle), m_q(new Triangle) { }
};
```

### <a name="use-the-raii-idiom-to-manage-resources"></a>Использовать идиому RAII для управления ресурсами

Для исключений, функцию необходимо убедиться, что объекты, что он включает выделенные с помощью `malloc` или **новый** уничтожаются, и все ресурсы, такие как дескрипторы файлов закрыты или освободить, даже если возникает исключение. *Получение ресурса есть инициализация* идиому (RAII) связывает управления таких ресурсов, времени существования автоматические переменные. Когда функции выходит за пределы области, из-за исключения, либо путем обычного возвращения вызываются деструкторы для все полностью созданные автоматические переменные. Объект оболочка RAII, таких как смарт-указатель вызывает соответствующий удалить или закрыть функции в деструкторе. В коде исключений немедленно передать владение каждого ресурса в каком-либо объекта RAII критически важно. Обратите внимание, что `vector`, `string`, `make_shared`, `fstream`, и других аналогичных классов обработки Получение ресурса для вас.  Тем не менее `unique_ptr` и традиционные `shared_ptr` конструкции являются особыми, так как получение ресурса выполняется пользователем, а не объект; таким образом, они считаются *ресурсов выпуска является уничтожение* , но сомнительные как RAII.

## <a name="the-three-exception-guarantees"></a>Трех гарантий исключения

Как правило, безопасность исключений рассматривается с точки зрения трех гарантий исключения, которые обеспечивают функции: *гарантии нет сбоев*, *строгую гарантию*и *базовую гарантию* .

### <a name="no-fail-guarantee"></a>Гарантии нет сбоев

Гарантии нет сбоев (или «нет-throw») — это надежная технология гарантии того, что функция может предоставить. В нем сообщается, что функция не исключение или разрешить одно распространение. Тем не менее, вы не можете задать надежно таких гарантий Если (a) вы знаете, что все функции, эта функция вызывает, также не от сбоев, (б) вы знаете, что перехватываются любые исключения, возникающие, прежде чем они достигнут этой функции или (c) вы знаете, как для перехвата и правильно обрабатывать все исключения, которые может достигнуть этой функции.

Строгую гарантию и базовую гарантию полагаться на предположении, что деструкторы — это не от сбоев. Все контейнеры и типы в стандартной библиотеке гарантирует, что деструкторы, не вызывают. Кроме того, есть требование, обратное: Стандартная библиотека требует, что определяемые пользователем типы, которые получают к нему — например, как аргументы шаблонов — должен иметь деструкторы, не создающие исключения.

### <a name="strong-guarantee"></a>Строгую гарантию

Состояния строгую гарантию, что если функция выходит за пределы области из-за исключения, он будет не утечки памяти и программы состояние не будет изменен. Функция, которая предоставляет строгую гарантию является по сути транзакцией, которая имеет семантику commit или rollback: либо полностью выполняется, либо не влияет.

### <a name="basic-guarantee"></a>Базовую гарантию

Базовую гарантию является самым слабым по три. Тем не менее возможно, лучшим выбором при строгую гарантию слишком дорого, потребления памяти или производительности. Базовый гарантировать состояний, что если возникает исключение, происходит утечка памяти, и объект является по-прежнему в рабочем состоянии, несмотря на то, что данные были изменены.

## <a name="exception-safe-classes"></a>Классы исключений

Класс может обеспечить собственную безопасность исключений, даже в том случае, если он используется операцией небезопасных функций, предотвращая сам частично созданный или частично уничтожается. Если конструктор класса завершает работу до завершения, объект еще не создан, и его деструктор не будет вызван. Несмотря на то, что автоматические переменные, которые инициализируются до исключения будут иметь деструкторы, вызывается динамически выделяемую память или ресурсы, которые не управляются с помощью смарт-указателя или произойдет утечка аналогично автоматической переменной.

Встроенные типы являются все нет сбоев и стандартные библиотечные типы поддерживают базовую гарантию как минимум. Придерживайтесь следующих рекомендаций для любого определяемого пользователем типа, который должен быть исключений.

- Используйте интеллектуальные указатели или других оболочек типа RAII для управления ресурсами. Избегайте функции управления ресурсами в вашей деструктор класса, так как деструктор не будет вызываться, если конструктор вызывает исключение. Тем не менее если класс является диспетчер выделенных ресурсов, который управляет только один ресурс, то это вполне можно использовать для управления ресурсами деструктор.

- Понять, что исключение, создаваемое в конструктор базового класса не может проглатываться в конструктор производного класса. Если вы хотите перевести и заново создать исключение базового класса в производный конструктор, используйте блоком function try.

- Рассмотрите возможность хранить все данные о состоянии класса в элемент данных, который заключается в интеллектуальный указатель, особенно в том случае, если класс имеет смысл «инициализацию, которая может завершиться ошибкой». Несмотря на то, что C++ допускает для неинициализированных данных элементов, он не поддерживает экземпляры класса неактивное состояние или частично инициализированную. Конструктор необходимо, завершится успехом или ошибкой; объект не создается, если конструктор не выполняется до завершения.

- Не допускать создания исключений для выхода из деструктора. Основные постулат C++ является то, что деструкторы никогда не должен разрешать исключению распространяться вверх по стеку вызовов. Если деструктор необходимо выполнить операцию может вызвать исключение, его необходимо таким образом в блок try блок catch и проглатывать исключение. Стандартная библиотека предоставляет такую гарантию на все деструкторы, которые он определяет.

## <a name="see-also"></a>См. также

[Обработка ошибок и исключений (современный C++)](../cpp/errors-and-exception-handling-modern-cpp.md)<br/>
[Практическое руководство. Интерфейс между кодом с исключениями и без исключений](../cpp/how-to-interface-between-exceptional-and-non-exceptional-code.md)
