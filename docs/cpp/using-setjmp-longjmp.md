---
title: Использование setjmp и longjmp
ms.date: 08/14/2018
f1_keywords:
- longjmp_cpp
- setjmp_cpp
helpviewer_keywords:
- C++ exception handling, setjmp/longjmp functions
- setjmpex.h
- longjmp function in C++ programs
- setjmp.h
- setjmp function
- setjmp function, C++ programs
ms.assetid: 96be8816-f6f4-4567-9a9c-0c3c720e37c5
ms.openlocfilehash: 6adbe22eb684c9a1dda080f6d35a99c55d6c3d30
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227001"
---
# <a name="using-setjmp-and-longjmp"></a>Использование setjmp и longjmp

При совместном использовании [setjmp](../c-runtime-library/reference/setjmp.md) и [longjmp](../c-runtime-library/reference/longjmp.md) они предоставляют способ выполнения нелокальной **`goto`** . Они обычно используются в коде C для передачи управления выполнения в код обработки ошибок или восстановления в ранее вызванной подпрограмме без использования стандартных соглашений о вызове или возврате.

> [!CAUTION]
> Поскольку `setjmp` и `longjmp` не поддерживают правильное уничтожение объектов кадра стека между компиляторами C++, и, поскольку они могут ухудшить производительность, предотвращая оптимизацию локальных переменных, мы не рекомендуем использовать их в программах на C++. Вместо этого рекомендуется использовать **`try`** **`catch`** конструкции и.

Если вы решили использовать `setjmp` и `longjmp` в программе на C++, также включите \<setjmp.h> или \<setjmpex.h> , чтобы обеспечить правильное взаимодействие между функциями и структурной обработкой исключений (SEH) или C++.

**Блок, относящийся только к системам Microsoft**

Если для компиляции кода C++ используется параметр [/EH](../build/reference/eh-exception-handling-model.md) , деструкторы локальных объектов вызываются во время очистки стека. Однако при использовании параметра **/EHs** или **/EHsc** для компиляции и одной из функций, использующих вызовы, [за исключением](../cpp/noexcept-cpp.md) вызовов, то `longjmp` деструктор для этой функции может не произойти, в зависимости от состояния оптимизатора.

В переносимом коде при `longjmp` выполнении вызова правильное уничтожение объектов на основе кадров явно не гарантируется стандартом и может не поддерживаться другими компиляторами. Чтобы сообщить, что на уровне предупреждений 4 вызывается `setjmp` предупреждение C4611: взаимодействие между "_setjmp" и уничтожением объектов C++ не является переносимым.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Смешивание исключений C (структурированная) и C++](../cpp/mixing-c-structured-and-cpp-exceptions.md)
