---
title: Маркеры и наборы символов
ms.date: 12/10/2019
helpviewer_keywords:
- Tokens (C++)
- Character sets
- basic source character set (C++)
- universal character names
- basic execution character set (C++)
ms.assetid: 379a2af6-6422-425f-8352-ef0bca6c0d74
ms.openlocfilehash: 1f6dbe2faa6348d61ec00b411cc35e8ef5ceb57a
ms.sourcegitcommit: a5fa9c6f4f0c239ac23be7de116066a978511de7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/20/2019
ms.locfileid: "75301617"
---
# <a name="tokens-and-character-sets"></a>Маркеры и наборы символов

Текст C++ программы состоит из маркеров и *пробелов*. Токен — это наименьший элемент на C++, который имеет значение для компилятора. C++ Синтаксический анализатор распознает следующие типы токенов:

- [Ключевые слова](../cpp/keywords-cpp.md)
- [Идентификаторы](../cpp/identifiers-cpp.md)
- [Числовые, логические литералы и литералы-указатели](../cpp/numeric-boolean-and-pointer-literals-cpp.md)
- [Строковые и символьные литералы](../cpp/string-and-character-literals-cpp.md)
- [Определенные пользователем литералы](../cpp/user-defined-literals-cpp.md)
- [Инструкции](../cpp/cpp-built-in-operators-precedence-and-associativity.md)
- [Символы пунктуации](../cpp/punctuators-cpp.md)

Маркеры обычно разделяются *пробелом, что*может быть одним или несколькими:

- пустые поля
- Символы горизонтальной и вертикальной табуляции
- Символы перевода строки
- Веб-каналы форм
- Comments

## <a name="basic-source-character-set"></a>Основная кодировка исходного кода

C++ Стандарт задает *основную кодировку исходного кода* , которую можно использовать в исходных файлах. Для представления символов вне этого набора можно указывать дополнительные символы, используя *универсальные имена символов*. Реализация КОМПИЛЯТОРОМ MSVC допускает дополнительные символы. Основная кодировка *исходного кода* состоит из 96 символов, которые могут использоваться в исходных файлах. Этот набор включает символ пробела, горизонтальной и вертикальной табуляции, управляющие символы перевода страницы и новой строки, а также следующий набор графических символов:

`a b c d e f g h i j k l m n o p q r s t u v w x y z`

`A B C D E F G H I J K L M N O P Q R S T U V W X Y Z`

`0 1 2 3 4 5 6 7 8 9`

`_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ " '`

**Блок, относящийся только к системам Майкрософт**

КОМПИЛЯТОРОМ MSVC включает `$`ный символ в качестве члена основной кодировки источника. КОМПИЛЯТОРОМ MSVC также позволяет использовать дополнительный набор символов в исходных файлах в зависимости от кодировки файла. По умолчанию Visual Studio сохраняет исходные файлы, используя кодовую страницу по умолчанию. Когда исходные файлы сохраняются с использованием кодовой страницы, зависящей от языкового стандарта, или кодовой страницы Юникода, КОМПИЛЯТОРОМ MSVC позволяет использовать любой из символов этой кодовой страницы в исходном коде, за исключением кодов элементов управления, явно разрешенных в базовой кодировке исходного кода. Например, японские символы можно поместить в комментарии, идентификаторы или строковые литералы, если файл сохраняется с использованием кодовой страницы японского языка. КОМПИЛЯТОРОМ MSVC не допускает последовательностей символов, которые нельзя преобразовать в допустимые многобайтовые символы или кодовые точки Юникода. В зависимости от параметров компилятора не все допустимые символы могут отображаться в идентификаторах. Дополнительные сведения см. в разделе [Identifiers](../cpp/identifiers-cpp.md).

**Завершение блока, относящегося только к системам Майкрософт**

### <a name="universal-character-names"></a>универсальные имена символов

Поскольку программы на C++ могут использовать гораздо больше символов, чем указано в основной кодировке исходного кода, можно указать эти символы в переносимом виде, используя *универсальные имена символов*. Универсальное имя состоит из последовательности символов, представляющих кодовую точку Юникода.  Оно может иметь две формы. Используйте `\UNNNNNNNN` для представления кодовой точки Юникода в форме U+NNNNNNNN, где NNNNNNNN — шестнадцатеричный номер кодовой точки из восьми цифр. Используйте код `\uNNNN` из четырех цифр для представления кодовой точки Юникода в форме U+0000NNNN.

Универсальные имена символов можно использовать в идентификаторах и в строковых и символьных литералах. Универсальное имя нельзя использовать для представления суррогатной кодовой точки в диапазоне от 0xD800 до 0xDFFF. Вместо этого используйте нужную кодовую точку: компилятор автоматически создает все необходимые суррогаты. К универсальным именам символов, которые могут использоваться в идентификаторах, применяются дополнительные ограничения. Дополнительные сведения см. в разделах [Identifiers](../cpp/identifiers-cpp.md) и [String and Character Literals](../cpp/string-and-character-literals-cpp.md).

**Блок, относящийся только к системам Майкрософт**

Компилятор Майкрософт C++ считает символ в форме универсального имени символа и литеральной формы взаимозаменяемым. Например, можно объявить идентификатор, используя форму универсального имени символа, и использовать его в форме литерала:

```cpp
auto \u30AD = 42; // \u30AD is 'キ'
if (キ == 42) return true; // \u30AD and キ are the same to the compiler
```

Формат расширенных символов в буфере обмена Windows зависит от параметров языкового стандарта приложения. Вырезание и вставка этих символов с переносом в код из другого приложения может вызвать использование непредвиденных кодировок. Это может привести к ошибкам синтаксического анализа без видимой причины в коде. Перед вставкой расширенных символов рекомендуется выбирать в качестве кодировки исходного файла кодовую страницу Юникода. Кроме того, для создания расширенных символов рекомендуется использовать IME или приложение "Таблица символов".

**Завершение блока, относящегося только к системам Майкрософт**

### <a name="execution-character-sets"></a>Наборы символов выполнения

*Наборы символов выполнения* представляют символы и строки, которые могут присутствовать в скомпилированной программе. Эти наборы символов состоят из всех символов, разрешенных в исходном файле, а также управляющих символов, представляющих предупреждения, Backspace, возврат каретки и символ null. Кодировка выполнения имеет представление, определяемое языковым стандартом.
