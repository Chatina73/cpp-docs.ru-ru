---
title: Классы хранения (C++)
description: В статических, экстернах и thread_local ключевых слов указывается продолжительность жизни, связь и местоположение памяти переменной или функции.
ms.date: 12/11/2019
f1_keywords:
- thread_local_cpp
- static_cpp
- register_cpp
helpviewer_keywords:
- storage classes [C++], basic concepts
ms.assetid: f10e1c56-6249-4eb6-b08f-09ab1eef1992
ms.openlocfilehash: 75ccb11689b4863d2d0df5edd6d066be6bd3858c
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81365350"
---
# <a name="storage-classes"></a>Классы хранилищ

*Класс хранения* в контексте переменных деклараций C q — это разоспектор типа, который регулирует место службы, связи и памяти объектов. Каждый объект может иметь только один класс хранения. Переменные, определяемые в блоке, имеют автоматическое хранилище, если иное не указано с помощью **экстернационных**или **thread_local** спецификаторов. **static** Автоматически создаваемые объекты и переменные не имеют компоновки. Они не доступны для кода за пределами блока. Память выделяется для них автоматически, когда выполнение входит в блок и разблокировано при выходе блока.

**Примечания**

1. [Изменяемое](../cpp/mutable-data-members-cpp.md) ключевое слово можно считать спецификатором класса хранения. Однако он доступен только в списке членов в определении класса.

1. **Визуальная студия 2010 и позже:** **Автоматическое** ключевое слово больше не является спецификатором хранения в классе СЗ, а ключевое слово **регистра** устаревает. **Visual Studio 2017 версия 15.7 и позже:** (доступно с [/std:c'17](../build/reference/std-specify-language-standard-version.md)): Ключевое слово **регистра** удаляется с языка СЗ.

```cpp
   register int val; // warning C5033: 'register' is no longer a supported storage class
```

## <a name="static"></a><a name="static"></a>Статический

**Статическое** ключевое слово может быть использовано для декларировании переменных и функций в глобальном диапазоне, области пространства имен и области класса. Статические переменные также могут быть объявлены в локальной области видимости.

Статическая длительность означает, что объект или переменная выделяется при запуске программы и освобождается при ее завершении. Внешняя компоновка означает, что имя переменной видно за пределами файла, в котором эта переменная объявлена. Внутренняя компоновка означает, что имя не видно за пределами файла, в котором объявлена переменная. По умолчанию объект или переменная, определенные в глобальном пространстве имен, имеют статическую длительность и внешнюю компоновку. **Статическое** ключевое слово может быть использовано в следующих ситуациях.

1. Когда вы объявляете переменную или функцию в области файла (глобальная и/или область пространства имен), **статическое** ключевое слово указывает, что переменная или функция имеет внутреннюю связь. При объявлении переменной она имеет статическую длительность и компилятор инициализирует ее со значением 0, если не указано другое значение.

1. Когда вы объявляете переменную в функции, **статическое** ключевое слово указывает, что переменная сохраняет свое состояние между вызовами к этой функции.

1. Когда вы объявляете участника данных в декларации класса, **статическое** ключевое слово указывает, что одна копия участника является общей для всех экземпляров класса. Статические данные-член должны быть определены в области видимости файла. Интегральный элемент данных, который вы объявляете как **const static,** может иметь инициализатор.

1. Когда вы объявляете функцию участника в декларации класса, **статическое** ключевое слово указывает, что функция является общей для всех экземпляров класса. Функция статического элемента не может получить доступ к элементу экземпляра, поскольку функция не имеет неявного **этого** указателя. Для доступа к члену экземпляра следует объявить функцию с параметром, являющимся указателем или ссылкой на экземпляр.

1. Объявление членов объединения как статических невозможно. Тем не менее, глобально объявленный анонимный союз должен быть явно объявлен **статичным.**

Этот пример показывает, как объявленная **статическая** переменная в функции сохраняет свое состояние между вызовами к этой функции.

```cpp
// static1.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
void showstat( int curr ) {
   static int nStatic;    // Value of nStatic is retained
                          // between each function call
   nStatic += curr;
   cout << "nStatic is " << nStatic << endl;
}

int main() {
   for ( int i = 0; i < 5; i++ )
      showstat( i );
}
```

```Output
nStatic is 0
nStatic is 1
nStatic is 3
nStatic is 6
nStatic is 10
```

Этот пример показывает использование **статического** в классе.

```cpp
// static2.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
class CMyClass {
public:
   static int m_i;
};

int CMyClass::m_i = 0;
CMyClass myObject1;
CMyClass myObject2;

int main() {
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;

   myObject1.m_i = 1;
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;

   myObject2.m_i = 2;
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;

   CMyClass::m_i = 3;
   cout << myObject1.m_i << endl;
   cout << myObject2.m_i << endl;
}
```

```Output
0
0
1
1
2
2
3
3
```

В этом примере показана локальная переменная, объявленная **статикой** в функции члена. Статическая переменная доступна всей программе; все экземпляры типа будут совместно использовать одну и ту же копию этой переменной.

```cpp
// static3.cpp
// compile with: /EHsc
#include <iostream>
using namespace std;
struct C {
   void Test(int value) {
      static int var = 0;
      if (var == value)
         cout << "var == value" << endl;
      else
         cout << "var != value" << endl;

      var = value;
   }
};

int main() {
   C c1;
   C c2;
   c1.Test(100);
   c2.Test(100);
}
```

```Output
var != value
var == value
```

Начиная с версии C++ 11 для инициализации статических локальных переменных гарантируется потокобезопасность. Эту функцию иногда называют *волшебной статикой.* Однако в многопоточном приложении все последующие назначения должны быть синхронизированы. Функция статического инициализации, безопасная для потоков, может быть отключена с помощью [флага /C:threadSafeInit-,](../build/reference/zc-threadsafeinit-thread-safe-local-static-initialization.md) чтобы избежать зависимости от CRT.

## <a name="extern"></a><a name="extern"></a>Extern

Объекты и переменные, объявленные **как extern,** объявляют объект, который определяется в другой единице перевода или в прилагаемой области как имеющий внешнюю связь. Для получения дополнительной информации, [Translation units and linkage](program-and-linkage-cpp.md) [см.](extern-cpp.md)

## <a name="thread_local-c11"></a><a name="thread_local"></a>thread_local (СЗ11)

Переменная, объявленная **с thread_local,** доступна только по потоку, на котором он создан. Переменная создается при создании потока и уничтожается при его уничтожении. Каждый поток имеет свою собственную копию переменной. В Windows **thread_local** функционально эквивалентно атрибуту Microsoft __declspec [(потоку).](../cpp/thread.md)

```cpp
thread_local float f = 42.0; // Global namespace. Not implicitly static.

struct S // cannot be applied to type definition
{
    thread_local int i; // Illegal. The member must be static.
    thread_local static char buf[10]; // OK
};

void DoSomething()
{
    // Apply thread_local to a local variable.
    // Implicitly "thread_local static S my_struct".
    thread_local S my_struct;
}
```

Что следует отметить о **thread_local** спецификатора:

- Динамически инициализированные переменные потока-локальных в DLL не могут быть правильно инициализированы на всех потоках вызова. Дополнительные сведения см. [здесь](thread.md).

- Спецификатор **thread_local** может сочетаться со **статичным** или **экстернационным.**

- Вы можете применять **thread_local** только к декларациям и определениям данных; **thread_local** не может быть использованв в функциональных декларациях или определениях.

- Можно указать **thread_local** только на элементы данных со статической продолжительностью хранения. Это включает в себя глобальные объекты данных (как **статические,** так и **extern),** локальные статические объекты и статические члены групп. Любая локальная переменная, объявленная **thread_local** неявно статична, если не предусмотрен другой класс хранения; другими словами, **thread_local** при области `thread_local static`блока thread_local эквивалентно .

- Необходимо указать **thread_local** как для объявления, так и для определения локального объекта потока, независимо от того, происходит ли декларация и определение в одном файле или отдельных файлах.

В Windows **thread_local** функционально эквивалентен [__declspec (потоку),](../cpp/thread.md) за исключением того, что **__declspec (поток)** может быть применен к определению типа и действителен в Коде C. Когда это возможно, используйте **thread_local,** потому что она является частью стандарта СЗз и поэтому является более портативной.

## <a name="register"></a><a name="register"></a>Зарегистрировать

**Visual Studio 2017 версия 15.3 и позже** (доступна с [/std:c'17](../build/reference/std-specify-language-standard-version.md)): Ключевое слово **регистра** больше не поддерживается класс хранения. Ключевое слово по-прежнему зарезервировано в стандарте для использования в будущем.

```cpp
   register int val; // warning C5033: 'register' is no longer a supported storage class
```

## <a name="example-automatic-vs-static-initialization"></a>Пример: автоматическая против статическая инициализация

Локальные автоматически создаваемые объекты или переменные инициализируются каждый раз, когда поток элемента управления достигает их определения. Локальные статические объекты или переменные инициализируются, когда поток элемента управления достигает их определения в первый раз.

Рассмотрим следующий пример, в котором определяется класс, который регистрирует инициализацию и удаление объектов, а затем определяет три объекта: `I1`, `I2` и `I3`.

```cpp
// initialization_of_objects.cpp
// compile with: /EHsc
#include <iostream>
#include <string.h>
using namespace std;

// Define a class that logs initializations and destructions.
class InitDemo {
public:
    InitDemo( const char *szWhat );
    ~InitDemo();

private:
    char *szObjName;
    size_t sizeofObjName;
};

// Constructor for class InitDemo
InitDemo::InitDemo( const char *szWhat ) :
    szObjName(NULL), sizeofObjName(0) {
    if ( szWhat != 0 && strlen( szWhat ) > 0 ) {
        // Allocate storage for szObjName, then copy
        // initializer szWhat into szObjName, using
        // secured CRT functions.
        sizeofObjName = strlen( szWhat ) + 1;

        szObjName = new char[ sizeofObjName ];
        strcpy_s( szObjName, sizeofObjName, szWhat );

        cout << "Initializing: " << szObjName << "\n";
    }
    else {
        szObjName = 0;
    }
}

// Destructor for InitDemo
InitDemo::~InitDemo() {
    if( szObjName != 0 ) {
        cout << "Destroying: " << szObjName << "\n";
        delete szObjName;
    }
}

// Enter main function
int main() {
    InitDemo I1( "Auto I1" ); {
        cout << "In block.\n";
        InitDemo I2( "Auto I2" );
        static InitDemo I3( "Static I3" );
    }
    cout << "Exited block.\n";
}
```

```Output
Initializing: Auto I1
In block.
Initializing: Auto I2
Initializing: Static I3
Destroying: Auto I2
Exited block.
Destroying: Auto I1
Destroying: Static I3
```

Этот пример показывает, как `I1`и `I2`когда `I3` объекты, и инициализированы и когда они будут уничтожены.

Есть несколько моментов, чтобы отметить о программе:

- Во-первых, `I1` и `I2` автоматически удаляются, когда поток элемента управления выходит за пределы блока, в котором они определены.

- Во-вторых, в C++ не обязательно объявлять объекты или переменные в начале блока. Более того, эти объекты инициализируются, только если поток элемента управления достигает их определения. `I2` (и `I3` являются примерами таких определений.) Выход показывает, когда именно они инициализированы.

- Наконец, статические локальные переменные, например `I3`, сохраняют свои значения длительности программы, но удаляются при завершении работы программы.

## <a name="see-also"></a>См. также раздел

[Декларации и определения](../cpp/declarations-and-definitions-cpp.md)
