---
title: Связывание исполняемого файла с библиотекой DLL
ms.date: 08/22/2019
helpviewer_keywords:
- run time [C++], linking
- dynamic load linking [C++]
- linking [C++], DLLs
- DLLs [C++], linking
- implicit linking [C++]
- explicit linking [C++]
- executable files [C++], linking to DLLs
- loading DLLs [C++]
ms.assetid: 7592e276-dd6e-4a74-90c8-e1ee35598ea3
ms.openlocfilehash: 2f907fedcaaf9897749ee0eb6a7ea5a33e1af679
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79422838"
---
# <a name="link-an-executable-to-a-dll"></a>Связывание исполняемого файла с библиотекой DLL

Исполняемый файл ссылается на (или загружает) библиотеку DLL одним из двух способов:

- *Неявная компоновка*, при которой операционная система ЗАГРУЖАЕТ библиотеку DLL одновременно с исполняемым файлом, который ее использует. Клиентский исполняемый файл вызывает экспортированные функции библиотеки DLL таким же образом, как если бы функции были статически связаны и содержатся в исполняемом файле. Неявная компоновка иногда называется *статической нагрузкой* или *динамической компоновкой во время загрузки*.

- *Явная компоновка*, при которой операционная система ЗАГРУЖАЕТ библиотеку DLL по запросу во время выполнения. Исполняемый файл, использующий библиотеку DLL посредством явной компоновки, должен явно загружать и выгружать библиотеку DLL. Он также должен настроить указатель на функцию для доступа к каждой функции, которую она использует из библиотеки DLL. В отличие от вызовов функций в статической или неявно связанной библиотеке DLL, клиентский исполняемый файл должен вызывать экспортированные функции в явно связанной библиотеке DLL через указатели функций. Явное связывание иногда называется *динамической нагрузкой* или *динамической компоновкой во время выполнения*.

Исполняемый объект может использовать любой метод связывания для связи с одной и той же библиотекой DLL. Более того, эти методы не являются взаимоисключающими. один исполняемый файл может неявно связываться с библиотекой DLL, а другой может быть присоединен к нему явным образом.

<a name="determining-which-linking-method-to-use"></a>

## <a name="determine-which-linking-method-to-use"></a>Определение используемого метода связывания

Необходимость использования неявного связывания или явного связывания является архитектурным решением, которое необходимо внести в приложение. Каждый из способов имеет свои преимущества и недостатки.

### <a name="implicit-linking"></a>Неявная компоновка

Неявная компоновка возникает, когда код приложения вызывает экспортированную функцию DLL. При компиляции или собрании исходного кода для вызывающего исполняемого файла вызов функции DLL создает ссылку на внешнюю функцию в коде объекта. Чтобы разрешить эту внешнюю ссылку, приложение должно создать связь с библиотекой импорта (LIB-файлом), предоставляемой создателем библиотеки DLL.

Библиотека импорта содержит только код для загрузки библиотеки DLL и реализации вызовов функций в библиотеке DLL. Поиск внешней функции в библиотеке импорта информирует компоновщик о том, что код этой функции находится в библиотеке DLL. Чтобы разрешить внешние ссылки на библиотеки DLL, компоновщик просто добавляет сведения в исполняемый файл, который сообщает системе, где найти код библиотеки DLL при запуске процесса.

Когда система запускает программу, содержащую динамически связанные ссылки, она использует сведения из исполняемого файла программы для размещения необходимых библиотек DLL. Если библиотека DLL не может быть найдена, система завершает процесс и отображает диалоговое окно, которое сообщает об ошибке. В противном случае система сопоставляет модули DLL с адресным пространством процесса.

Если какая-либо из библиотек DLL имеет функцию точки входа для кода инициализации и завершения, например `DllMain`, операционная система вызывает функцию. Один из параметров, передаваемых в функцию точки входа, указывает код, указывающий, что библиотека DLL присоединяется к процессу. Если функция точки входа не возвращает значение TRUE, система завершает процесс и сообщает об ошибке.

Наконец, система изменяет исполняемый код процесса, чтобы предоставить начальные адреса для функций DLL.

Как и остальная часть кода программы, загрузчик сопоставляет код DLL с адресным пространством процесса при запуске процесса. Операционная система загружает его в память только при необходимости. В результате атрибуты кода `PRELOAD` и `LOADONCALL`, используемые DEF-файлами для управления загрузкой в предыдущих версиях Windows, больше не имеют смысла.

### <a name="explicit-linking"></a>Явная компоновка

Большинство приложений используют неявное связывание, так как это самый простой метод связывания для использования. Однако бывают случаи, когда требуется явное связывание. Ниже приведены некоторые распространенные причины использования явной компоновки.

- Приложение не знает имя библиотеки DLL, которая загружается до времени выполнения. Например, приложение может получить имя библиотеки DLL и экспортированные функции из файла конфигурации при запуске.

- Процесс, использующий неявное связывание, завершается операционной системой, если библиотека DLL не найдена при запуске процесса. В этой ситуации процесс, использующий явное связывание, не завершается и может попытаться восстановиться после ошибки. Например, процесс может уведомить пользователя об ошибке и указать другой путь к библиотеке DLL.

- Процесс, использующий неявное связывание, также завершается, если какая-либо из библиотек DLL, с которой он связан, имеет функцию `DllMain`, которая завершается ошибкой. В этой ситуации процесс, использующий явное связывание, не завершается.

- Приложение, неявно ссылающееся на многие библиотеки DLL, может быть запущено медленнее, так как при загрузке приложения Windows загружает все библиотеки DLL. Чтобы повысить производительность при запуске, приложение может использовать неявную компоновку только для библиотек DLL, необходимых сразу после загрузки. Она может использовать явную компоновку для загрузки других библиотек DLL только в том случае, если они необходимы.

- Явная компоновка позволяет избежать необходимости связывать приложение с помощью библиотеки импорта. Если изменения в библиотеке DLL приводят к изменению порядковых номеров экспорта, приложениям не нужно повторно связываться, если они вызывают `GetProcAddress` используя имя функции, а не порядковое значение. Приложения, использующие неявное связывание, по-прежнему должны повторно связываться с измененной библиотекой импорта.

Ниже приведены две опасности явного связывания, с которыми следует обратить внимание:

- Если библиотека DLL имеет `DllMain` функцию точки входа, операционная система вызывает функцию в контексте потока, который вызвал `LoadLibrary`. Функция точки входа не вызывается, если библиотека DLL уже присоединена к процессу из-за предыдущего вызова `LoadLibrary`, не имеющего соответствующего вызова функции `FreeLibrary`. Явная компоновка может вызвать проблемы, если библиотека DLL использует функцию `DllMain` для инициализации каждого потока процесса, так как все потоки, которые уже существуют при вызове `LoadLibrary` (или `AfxLoadLibrary`), не инициализируются.

- Если библиотека DLL объявляет данные статического экстента как `__declspec(thread)`, это может привести к сбою защиты при явной связи. После того как библиотека DLL загружена путем вызова `LoadLibrary`, она вызывает сбой защиты всякий раз, когда код ссылается на эти данные. (Статические данные экстента включают как глобальные, так и локальные статические элементы). Именно поэтому при создании библиотеки DLL следует избегать использования локального хранилища потока. Если это невозможно, сообщите пользователям библиотеки DLL о потенциальных ловушках динамической загрузки библиотеки DLL. Дополнительные сведения см. [в разделе Использование локального хранилища потоков в библиотеке динамической компоновки (Windows SDK)](/windows/win32/Dlls/using-thread-local-storage-in-a-dynamic-link-library).

<a name="linking-implicitly"></a>

## <a name="how-to-use-implicit-linking"></a>Использование неявной компоновки

Чтобы использовать библиотеку DLL с помощью неявной компоновки, клиентские исполняемые файлы должны получить их от поставщика библиотеки DLL:

- Один или несколько файлов заголовков (h-файлы), которые содержат объявления экспортированных данных, функций и C++ классов в библиотеке DLL. Классы, функции и данные, экспортированные библиотекой DLL, должны быть помечены как `__declspec(dllimport)` в файле заголовка. Дополнительные сведения см. в статье [dllexport, dllimport](../cpp/dllexport-dllimport.md).

- Библиотека импорта для ссылки на исполняемый файл. Компоновщик создает библиотеку импорта при построении библиотеки DLL. Дополнительные сведения см. [в разделе lib files as input компоновщика](reference/dot-lib-files-as-linker-input.md).

- Собственно DLL-файл.

Чтобы использовать данные, функции и классы в библиотеке DLL путем неявной компоновки, любой исходный файл клиента должен содержать файлы заголовков, объявляющие их. С точки зрения кода вызовы экспортированных функций аналогичны любым другим вызовам функций.

Для сборки исполняемого файла клиента необходимо выполнить компоновку с библиотекой импорта библиотеки DLL. Если используется внешний файл makefile или система сборки, укажите библиотеку импорта вместе с другими связанными файлами или библиотеками объектов.

Операционная система должна иметь возможность размещать DLL-файл при загрузке вызывающего исполняемого файла. Это означает, что при установке приложения необходимо либо развернуть, либо проверить существование библиотеки DLL.

<a name="linking-explicitly"></a>

## <a name="how-to-link-explicitly-to-a-dll"></a>Явное связывание с библиотекой DLL

Чтобы использовать библиотеку DLL с помощью явной компоновки, приложения должны вызвать функцию для явной загрузки библиотеки DLL во время выполнения. Для явного связывания с библиотекой DLL приложение должно:

- Вызовите [LoadLibraryEx](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexw) или аналогичную функцию для загрузки библиотеки DLL и получения маркера модуля.

- Вызовите [GetProcAddress](getprocaddress.md) , чтобы получить указатель на функцию для каждой экспортированной функции, которая вызывается приложением. Поскольку приложения вызывают функции DLL через указатель, компилятор не создает внешние ссылки, поэтому нет необходимости связываться с библиотекой импорта. Однако необходимо иметь инструкцию `typedef` или `using`, определяющую сигнатуру вызова экспортированных вызываемых функций.

- Вызовите [FreeLibrary](freelibrary-and-afxfreelibrary.md) , когда завершите работу с библиотекой DLL.

Например, этот пример функции вызывает `LoadLibrary` для загрузки библиотеки DLL с именем MyDLL, вызывает `GetProcAddress` для получения указателя на функцию с именем "DLLFunc1", вызывает функцию и сохраняет результат, а затем вызывает `FreeLibrary` для выгрузки библиотеки DLL.

```C
#include "windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(DWORD,UINT*);

HRESULT LoadAndCallSomeFunction(DWORD dwParam1, UINT * puParam2)
{
    HINSTANCE hDLL;               // Handle to DLL
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
    HRESULT hrReturnVal;

    hDLL = LoadLibrary("MyDLL");
    if (NULL != hDLL)
    {
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "DLLFunc1");
        if (NULL != lpfnDllFunc1)
        {
            // call the function
            hrReturnVal = lpfnDllFunc1(dwParam1, puParam2);
        }
        else
        {
            // report the error
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }
    return hrReturnVal;
}
```

В отличие от этого примера, в большинстве случаев следует вызывать `LoadLibrary` и `FreeLibrary` в приложении только один раз для конкретной библиотеки DLL. Особенно это справедливо, если вы намерены вызывать несколько функций в библиотеке DLL или многократно вызывать функции DLL.

## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Работа с библиотеками импорта и файлами экспорта](reference/working-with-import-libraries-and-export-files.md)

- [Порядок поиска библиотек динамической компоновки](/windows/win32/Dlls/dynamic-link-library-search-order)

## <a name="see-also"></a>См. также раздел

[Создание библиотек DLL C/C++ в Visual Studio](dlls-in-visual-cpp.md)
