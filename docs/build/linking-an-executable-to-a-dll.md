---
title: Связывание исполняемого файла с библиотекой DLL
ms.date: 11/04/2016
helpviewer_keywords:
- run time [C++], linking
- dynamic load linking [C++]
- linking [C++], DLLs
- DLLs [C++], linking
- implicit linking [C++]
- explicit linking [C++]
- executable files [C++], linking to DLLs
- loading DLLs [C++]
ms.assetid: 7592e276-dd6e-4a74-90c8-e1ee35598ea3
ms.openlocfilehash: c4f9ea7a3606612189e85401b75a0577896fd90e
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69493223"
---
# <a name="link-an-executable-to-a-dll"></a>Связывание исполняемого файла с библиотекой DLL

Исполняемый файл ссылается на (или загружает) библиотеку DLL одним из двух способов:

- *Неявная компоновка*, при которой операционная система ЗАГРУЖАЕТ библиотеку DLL при загрузке исполняемого файла. Клиентский исполняемый файл вызывает экспортированные функции библиотеки DLL так же, как если бы функции были статически связаны и содержались в исполняемом файле. Неявная компоновка иногда называется *статической* нагрузкой или *динамической компоновкой во время загрузки*.

- *Явная компоновка*, при которой операционная система ЗАГРУЖАЕТ библиотеку DLL по запросу во время выполнения. Исполняемый файл, использующий библиотеку DLL путем явного связывания, должен вызывать функции для явной загрузки и выгрузки библиотеки DLL и доступа к функциям, экспортируемым библиотекой DLL. В отличие от вызовов функций в статически связанной библиотеке, клиентский исполняемый файл должен вызывать экспортированные функции в библиотеке DLL через указатель функции. Явное связывание иногда называется *динамической* нагрузкой или *динамической компоновкой во время выполнения*.

Исполняемый объект может использовать любой метод связывания для связи с одной и той же библиотекой DLL. Более того, эти методы не являются взаимоисключающими. один исполняемый объект может неявно связать с библиотекой DLL, а другой — явным образом.

<a name="determining-which-linking-method-to-use"></a>

## <a name="link-an-executable-to-a-dll"></a>Связывание исполняемого файла с библиотекой DLL

Необходимость использования неявного связывания или явного связывания является архитектурным решением, которое необходимо внести в приложение. У каждого метода есть свои преимущества и недостатки.

### <a name="implicit-linking"></a>Неявная компоновка

Неявная компоновка возникает, когда код приложения вызывает экспортированную функцию DLL. При компиляции или собрании исходного кода для вызывающего исполняемого файла вызов функции DLL создает ссылку на внешнюю функцию в коде объекта. Чтобы разрешить эту внешнюю ссылку, приложение должно создать связь с библиотекой импорта (LIB-файлом), предоставляемой создателем библиотеки DLL.

Библиотека импорта содержит только код для загрузки библиотеки DLL и реализации вызовов функций в библиотеке DLL. Поиск внешней функции в библиотеке импорта информирует компоновщик о том, что код этой функции находится в библиотеке DLL. Чтобы разрешить внешние ссылки на библиотеки DLL, компоновщик просто добавляет сведения в исполняемый файл, который сообщает системе, где найти код библиотеки DLL при запуске процесса.

Когда система запускает программу, содержащую динамически связанные ссылки, она использует сведения из исполняемого файла программы для размещения необходимых библиотек DLL. Если библиотека DLL не найдена, система завершает процесс и отображает диалоговое окно, которое сообщает об ошибке. В противном случае система сопоставляет модули DLL с адресным пространством процесса.

Если какая-либо из библиотек DLL имеет функцию точки входа для инициализации и завершения кода `DllMain`, например, операционная система вызывает функцию. Один из параметров, передаваемых в функцию точки входа, указывает код, указывающий, что библиотека DLL присоединяется к процессу. Если функция точки входа не возвращает значение TRUE, система завершает процесс и сообщает об ошибке.

Наконец, система изменяет исполняемый код процесса, чтобы предоставить начальные адреса для функций DLL.

Как и остальная часть кода программы, код DLL сопоставляется с адресным пространством процесса, когда процесс запускается и загружается в память только при необходимости. В результате `PRELOAD` атрибуты кода и `LOADONCALL` , используемые DEF-файлами для управления загрузкой в предыдущих версиях Windows, больше не имеют смысла.

### <a name="explicit-linking"></a>Явная компоновка

Большинство приложений используют неявное связывание, так как это самый простой метод связывания для использования. Однако бывают случаи, когда требуется явное связывание. Ниже приведены некоторые распространенные причины использования явной компоновки.

- Приложение не знает имя библиотеки DLL, которая загружается до времени выполнения. Например, приложение может получить имя библиотеки DLL и экспортированные функции из файла конфигурации при запуске.

- Процесс, использующий неявное связывание, завершается операционной системой, если библиотека DLL не найдена при запуске процесса. В этой ситуации процесс, использующий явное связывание, не завершается и может попытаться восстановиться после ошибки. Например, процесс может уведомить пользователя об ошибке и указать другой путь к библиотеке DLL.

- Процесс, использующий неявное связывание, также завершается, если какая-либо из библиотек `DllMain` DLL, с которой он связан, имеет функцию, которая завершается ошибкой. В этой ситуации процесс, использующий явное связывание, не завершается.

- Приложение, неявно ссылающееся на многие библиотеки DLL, может быть запущено медленнее, так как при загрузке приложения Windows загружает все библиотеки DLL. Чтобы повысить производительность при запуске, приложение может напрямую ссылаться только на те библиотеки DLL, которые требуются сразу после загрузки, и ожидать, пока другие библиотеки DLL не будут должным образом ссылаться на них.

- Явная компоновка позволяет избежать необходимости связывать приложение с помощью библиотеки импорта. Если изменения в библиотеке DLL приводят к изменению порядковых номеров экспорта, то приложения, использующие явное связывание, не должны повторно `GetProcAddress` связываться, если они вызываются с использованием имени функции, а не порядкового значения, тогда как приложения, использующие неявное связывание, должны повторно ссылаться на Новая библиотека импорта.

Ниже приведены две опасности явного связывания, с которыми следует обратить внимание:

- Если библиотека DLL имеет `DllMain` функцию точки входа, операционная система вызывает функцию в контексте потока, вызвавшего. `LoadLibrary` Функция точки входа не вызывается, если библиотека DLL уже присоединена к процессу из-за предыдущего вызова метода `LoadLibrary` , не имеющего соответствующего вызова `FreeLibrary` функции. Явная компоновка может вызвать проблемы, если библиотека DLL `DllMain` использует функцию для выполнения инициализации каждого потока процесса, так как потоки, которые уже существуют `LoadLibrary` при вызове (или `AfxLoadLibrary`), не инициализируются.

- Если библиотека DLL объявляет данные статического экстента как `__declspec(thread)`, это может привести к сбою защиты при явной связи. После того как библиотека DLL будет загружена путем `LoadLibrary`вызова, она вызывает ошибку защиты, когда код ссылается на эти данные. (Статические данные экстента включают как глобальные, так и локальные статические элементы). Поэтому при создании библиотеки DLL следует либо избегать использования локального хранилища потока, либо информировать пользователей библиотеки DLL о потенциальных ловушках динамической загрузки библиотеки DLL. Дополнительные сведения см. [в разделе Использование локального хранилища потоков в библиотеке динамической компоновки (Windows SDK)](/windows/win32/Dlls/using-thread-local-storage-in-a-dynamic-link-library).

<a name="linking-implicitly"></a>

## <a name="link-an-executable-to-a-dll"></a>Связывание исполняемого файла с библиотекой DLL

Чтобы использовать библиотеку DLL с помощью неявной компоновки, клиентские исполняемые файлы должны получить их от поставщика библиотеки DLL:

- Один или несколько файлов заголовков (h-файлов), содержащих объявления экспортированных данных, функций и (или C++ ) классов в библиотеке DLL. Классы, функции и данные, экспортированные библиотекой DLL, должны быть помечены `__declspec(dllimport)` в файле заголовка. Дополнительные сведения см. в статье [dllexport, dllimport](../cpp/dllexport-dllimport.md).

- Библиотека импорта для ссылки на исполняемый файл. Компоновщик создает библиотеку импорта при построении библиотеки DLL. Дополнительные сведения см. в разделе [. LIB файлы](reference/dot-lib-files-as-linker-input.md).

- Собственно DLL-файл.

Для использования библиотеки DLL неявной компоновкой исполняемый файл должен включать файлы заголовков, объявляющие данные C++ , функции или классы, ЭКСПОРТИРУЕМые библиотекой DLL в каждом исходном файле, который содержит вызовы экспортированных данных, функций и классов. С точки зрения кода вызовы экспортированных функций аналогичны любым другим вызовам функций.

Чтобы создать вызывающий исполняемый файл, необходимо выполнить компоновку с библиотекой импорта. Если используется внешняя сборка makefile или система сборки, укажите имя файла библиотеки импорта, в которой будут перечислены другие файлы (obj) или библиотеки, которые вы свяжете.

Операционная система должна иметь возможность размещать DLL-файл при загрузке вызывающего исполняемого файла. Это означает, что приложение должно развернуть или проверить существование библиотеки DLL при установке приложения.

<a name="linking-explicitly"></a>

## <a name="how-to-link-explicitly-to-a-dll"></a>Явное связывание с библиотекой DLL

Чтобы использовать библиотеку DLL с помощью явной компоновки, приложения должны вызвать функцию для явной загрузки библиотеки DLL во время выполнения. Для явного связывания с библиотекой DLL приложение должно:

- Вызовите [LoadLibrary](loadlibrary-and-afxloadlibrary.md), `LoadLibraryEx`или аналогичную функцию для загрузки библиотеки DLL и получения маркера модуля.

- Вызовите [GetProcAddress](getprocaddress.md) , чтобы получить указатель на функцию для каждой экспортированной функции, которая вызывается приложением. Поскольку приложения вызывают функции DLL через указатель, компилятор не создает внешние ссылки, поэтому нет необходимости связываться с библиотекой импорта. Однако необходимо наличие `typedef` оператора или `using` , определяющего сигнатуру вызова экспортируемых функций, которые вызываются.

- Вызовите [FreeLibrary](freelibrary-and-afxfreelibrary.md) , когда завершите работу с библиотекой DLL.

Например, этот пример функции вызывает `LoadLibrary` загрузку библиотеки DLL с именем MyDLL, вызывает `GetProcAddress` метод для получения указателя на функцию с именем «DLLFunc1», вызывает функцию и сохраняет результат, а затем вызывает метод `FreeLibrary` для выгрузки библиотеки DLL.

```C
#include "windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(DWORD,UINT*);

HRESULT LoadAndCallSomeFunction(DWORD dwParam1, UINT * puParam2)
{
    HINSTANCE hDLL;               // Handle to DLL
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
    HRESULT hrReturnVal;

    hDLL = LoadLibrary("MyDLL");
    if (NULL != hDLL)
    {
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "DLLFunc1");
        if (NULL != lpfnDllFunc1)
        {
            // call the function
            hrReturnVal = lpfnDllFunc1(dwParam1, puParam2);
        }
        else
        {
            // report the error
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }
    return hrReturnVal;
}
```

В отличие от этого примера, в большинстве случаев в приложении следует `LoadLibrary` вызывать `FreeLibrary` и только один раз для конкретной библиотеки DLL, особенно если вы собираетесь многократно вызывать несколько функций в библиотеке DLL или вызывать функции DLL.

## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Работа с библиотеками импорта и файлами экспорта](reference/working-with-import-libraries-and-export-files.md)

- [Порядок поиска библиотек динамической компоновки](/windows/win32/Dlls/dynamic-link-library-search-order)

## <a name="see-also"></a>См. также

[Создание библиотек DLL C/C++ в Visual Studio](dlls-in-visual-cpp.md)
