---
title: Связывание исполняемого файла с библиотекой DLL
ms.date: 11/04/2016
helpviewer_keywords:
- run time [C++], linking
- dynamic load linking [C++]
- linking [C++], DLLs
- DLLs [C++], linking
- implicit linking [C++]
- explicit linking [C++]
- executable files [C++], linking to DLLs
- loading DLLs [C++]
ms.assetid: 7592e276-dd6e-4a74-90c8-e1ee35598ea3
ms.openlocfilehash: 998ec23d2d0f16069783529aebafc8b91bb15834
ms.sourcegitcommit: bff17488ac5538b8eaac57156a4d6f06b37d6b7f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2019
ms.locfileid: "57418819"
---
# <a name="link-an-executable-to-a-dll"></a>Связывание исполняемого файла с библиотекой DLL

Исполняемый файл связывает (или загружает) библиотеку DLL одним из двух способов:

- *Неявное связывание*, где операционная система загружает библиотеку DLL после загрузки исполняемого файла. Клиентский исполняемый файл вызывает экспортированные функции библиотеки DLL, как если функции были статически связанные и содержащихся в исполняемый файл. Неявное связывание иногда называется *статической загрузкой* или *динамическое связывание во время загрузки*.

- *Явное связывание*, где операционная система загружает библиотеку DLL по запросу во время выполнения. Исполняемый файл, использующий библиотеку DLL, явное связывание должен делать вызовы функции для явной загрузки и выгрузки библиотеки DLL и доступа к функций, экспортируемых посредством библиотеки DLL. В отличие от вызовов функций в статически скомпонованной библиотекой исполняемый файл клиента необходимо вызвать экспортированные функции в библиотеке DLL через указатель функции. Явное связывание иногда называется *динамической нагрузке* или *динамической компоновкой во время выполнения*.

Исполняемый файл можно использовать независимо от выбранного метода, чтобы связать с той же библиотеки DLL. Кроме того эти методы не являются взаимоисключающими; один исполняемый файл неявно связывается с библиотекой DLL, и другой можно к ней подключить явным образом.

<a name="determining-which-linking-method-to-use"></a>

## <a name="determine-which-linking-method-to-use"></a>Определение подходящего метода связывания

Следует ли использовать связывание неявное или явное связывание является архитектурным решением, необходимые для вашего приложения. Существуют, преимущества и недостатки каждого метода.

### <a name="implicit-linking"></a>Неявное связывание

Неявное связывание происходит, когда код приложения вызывает экспортированную функцию DLL. Если исходный код для вызывающего исполняемого файла или компилируется, вызов функции DLL создает внешнюю ссылку на функцию в коде объекта. Чтобы устранить эта внешняя ссылка, приложение должно быть скомпоновано с библиотекой импорта (LIB-файл), предоставляется автором библиотеки DLL.

Библиотека импорта содержит только код для загрузки библиотеки DLL и реализации вызовов функций в библиотеке DLL. Поиск внешней функции в библиотеке импорта информирует компоновщик, что код для этой функции находится в библиотеке DLL. Для разрешения внешних ссылок на библиотеки DLL, компоновщик просто добавляет информацию в исполняемый файл, который сообщает системе, где можно найти код библиотеки DLL при запуске процесса.

Когда система запускает программу, содержащую динамически связанные ссылки, она использует информацию в исполняемый файл программы для определения необходимых библиотек DLL. Если не удается найти библиотеку DLL, система завершает процесс и отображает диалоговое окно, которое сообщает об ошибке. В противном случае система сопоставляет модули библиотеки DLL в адресное пространство процесса.

Если любой из библиотеки DLL есть функция точки входа для кода инициализации и завершения например `DllMain`, операционная система вызывает функцию. Один из параметров, переданных в функцию точки входа указывает, что код, указывающий библиотеку DLL, присоединения к процессу. Если функция точки входа не возвращает значение TRUE, система завершает процесс и сообщает об ошибке.

Наконец система изменяет исполняемый код процесса, чтобы предоставить начальные адреса для функций DLL.

Как в остальной части кода программы код библиотеки DLL сопоставлен в адресное пространство процесса при запуске процесса и загружается в память только при необходимости. В результате `PRELOAD` и `LOADONCALL` атрибуты кода, используемые DEF-файлы для контроля загрузки в предыдущих версиях Windows, больше не требуются.

### <a name="explicit-linking"></a>Явное связывание

Большинство приложений использует неявное связывание, поскольку он является простым методом для использования. Однако бывают случаи, когда просто необходимо явное связывание. Ниже приведены некоторые распространенные причины для использования явного связывания.

- Приложение не знает имя библиотеки DLL, загружаемой до времени выполнения. Например приложение может получить имя библиотеки DLL и экспортированные функции из файла конфигурации при запуске.

- В процесс, использующий неявное связывание прерывается операционной системой, если библиотека DLL не найдена во время запуска процесса. В процесс, использующий явное связывание не завершается в данной ситуации и может попытаться исправить последствия ошибки. Например процесс может уведомить пользователя об ошибке и запросить у него другой путь к библиотеке DLL.

- В процесс, использующий неявное связывание также завершается, если любой из библиотек DLL, она привязывается к имеют `DllMain` функцию, которая завершается ошибкой. В этом случае процесс, использующий явное связывание не завершен.

- Приложение, которое неявным образом связано со многими библиотеками DLL может быть медленным запуститься, поскольку Windows загружает все библиотеки DLL при загрузке приложения. Чтобы повысить производительность при запуске, приложение можно связать неявно только эти библиотеки DLL, необходимые сразу после загрузки и подождите, пока не обязаны явно ссылаться на них другие библиотеки DLL.

- Явное связывание устраняет необходимость связать приложение с помощью библиотеки импорта. Если изменения в библиотеке DLL порядковые номера экспорта для изменения, приложения, использующие явное связывание нет необходимости выполнить повторную компоновку, если они вызывают `GetProcAddress` используя имя функции и не порядковое значение, тогда как приложения, использующие неявное связывание должны выполнить повторное связывание новую библиотеку импорта.

Ниже приведены моменты явное связывание, которые следует учитывать.

- Если библиотека DLL должна `DllMain` функцию точки входа, операционная система вызывает функцию в контексте потока, который вызвал `LoadLibrary`. Функция точки входа не вызывается, если библиотека DLL уже присоединена к процессу из-за предыдущего вызова `LoadLibrary` , имел не последовал вызов `FreeLibrary` функции. Явное связывание может вызвать проблемы, если библиотека DLL использует `DllMain` функции для выполнения инициализации для каждого потока процесса, поскольку потоки, которые уже существуют при `LoadLibrary` (или `AfxLoadLibrary`) вызывается не инициализируются.

- Если библиотека DLL объявляет статические данные в виде `__declspec(thread)`, он может привести к сбою защиты при использовании явного связывания. После загрузки библиотеки DLL с помощью вызова `LoadLibrary`, происходит сбой защиты всякий раз, когда код ссылается на эти данные. (Статические данные включают глобальные и локальные статические элементы). Таким образом при создании библиотеки DLL, следует избегать использования локальной памяти потока, или уведомить пользователей Библиотеки о возможных ловушках динамической загрузки библиотеки DLL. Дополнительные сведения см. в разделе [с помощью локального хранилища потока в библиотеке динамической компоновки (Windows SDK)](/windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library).

<a name="linking-implicitly"></a>

## <a name="how-to-link-implicitly-to-a-dll"></a>Неявное связывание с библиотекой DLL

С помощью неявного связывания библиотеки DLL, исполняемые файлы клиента необходимо получить эти файлы от поставщика библиотеки DLL:

- Один или несколько файлы заголовков (h-файлы), которые содержат объявления экспортированных данных, функций и классов C++ в библиотеке DLL. Классы, функции и данные, экспортированные посредством библиотеки DLL должны все быть помечены `__declspec(dllimport)` в файле заголовка. Дополнительные сведения см. в разделе [dllexport, dllimport](../cpp/dllexport-dllimport.md).

- Библиотека импорта для связывания в исполняемый файл. При построении библиотеки DLL, компоновщик создает библиотеку импорта. Дополнительные сведения см. в разделе [. LIB-файлы](../build/reference/dot-lib-files-as-linker-input.md).

- Фактический файл DLL.

С помощью неявного связывания библиотеки DLL, исполняемый файл должен включать файлы заголовков, которые объявляют данных, функций или классах C++, экспортируемых посредством библиотеки DLL в каждый исходный файл, содержащий вызовы экспортированные данные, функции и классы. С точки зрения программирования вызовы к экспортированным функциям аналогичны вызову функции.

Чтобы построить вызывающий исполняемый файл, необходимо связать с библиотекой импорта. Если вы используете внешний сборочный файл проекта или систему сборки, укажите имя файла библиотеки импорта, в котором указаны другие файлы объектов (OBJ) или библиотеки, которые можно связать.

Операционной системы должен иметь возможность найти DLL-файла, при загрузке вызывающего исполняемого файла. Это означает, что приложение необходимо развернуть или проверить существование DLL-библиотеки, при установке приложения.

<a name="linking-explicitly"></a>

## <a name="how-to-link-explicitly-to-a-dll"></a>Явно связывание с библиотекой DLL

Использовать библиотеку DLL, явное связывание, приложения необходимо убедиться в вызов функции для явной загрузки библиотеки DLL во время выполнения. Для явного связывания с библиотекой DLL, приложение должно удовлетворять следующим требованиям:

- Вызовите [LoadLibrary](loadlibrary-and-afxloadlibrary.md), `LoadLibraryEx`, или загрузить библиотеку DLL и получить дескриптор модуля ту же функцию.

- Вызовите [GetProcAddress](getprocaddress.md) получить указатель на функцию к каждому экспортировать функцию, которая вызывает приложение. Поскольку приложения вызывают функции DLL через указатель, компилятор не создает внешних ссылок, поэтому нет необходимости для связывания с библиотекой импорта. Тем не менее, необходимо иметь `typedef` или `using` оператор, который определяет сигнатуру вызова экспортированных функций, которые можно вызвать.

- Вызовите [FreeLibrary](freelibrary-and-afxfreelibrary.md) при действий с библиотекой DLL.

Например, в этом примере функции вызывает `LoadLibrary` загрузить библиотеку DLL с именем «MyDLL», вызывает `GetProcAddress` для получения указателя на функцию с именем «DLLFunc1», вызывает функцию и сохраняет результат, а затем вызывает `FreeLibrary` выгрузить библиотеку DLL.

```C
#include "windows.h"

typedef HRESULT (CALLBACK* LPFNDLLFUNC1)(DWORD,UINT*);

HRESULT LoadAndCallSomeFunction(DWORD dwParam1, UINT * puParam2)
{
    HINSTANCE hDLL;               // Handle to DLL
    LPFNDLLFUNC1 lpfnDllFunc1;    // Function pointer
    HRESULT hrReturnVal;

    hDLL = LoadLibrary("MyDLL");
    if (NULL != hDLL)
    {
        lpfnDllFunc1 = (LPFNDLLFUNC1)GetProcAddress(hDLL, "DLLFunc1");
        if (NULL != lpfnDllFunc1)
        {
            // call the function
            hrReturnVal = lpfnDllFunc1(dwParam1, puParam2);
        }
        else
        {
            // report the error
            hrReturnVal = ERROR_DELAY_LOAD_FAILED;
        }
        FreeLibrary(hDLL);
    }
    else
    {
        hrReturnVal = ERROR_DELAY_LOAD_FAILED;
    }
    return hrReturnVal;
}
```

В отличие от в этом примере, в большинстве случаев следует вызывать `LoadLibrary` и `FreeLibrary` только один раз в приложении для заданной библиотеки DLL, особенно в том случае, если вы собираетесь вызовите несколько функций в библиотеке DLL или библиотеки DLL функции несколько раз.

## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Работа с библиотеками импорта и файлами экспорта](../build/reference/working-with-import-libraries-and-export-files.md)

- [Порядок поиска библиотеки динамической компоновки](/windows/desktop/Dlls/dynamic-link-library-search-order)

## <a name="see-also"></a>См. также

[DLL в Visual C++](../build/dlls-in-visual-cpp.md)
