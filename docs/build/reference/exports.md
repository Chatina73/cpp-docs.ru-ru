---
title: EXPORTS
ms.date: 09/07/2018
f1_keywords:
- EXPORTS
helpviewer_keywords:
- EXPORTS .def file statement
ms.assetid: dbcd7579-b855-44c4-bd27-931e157657f7
ms.openlocfilehash: 8338f27d35d3779a55b83b70c7a3eef285a91f46
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69492888"
---
# <a name="exports"></a>EXPORTS

Начинает раздел, состоящий из одного или нескольких определений экспорта, в которых указываются имена или порядковые номера экспортируемых функций или данных. Каждое определение должно находиться в отдельной строке.

```DEF
EXPORTS
   definition
```

## <a name="remarks"></a>Примечания

Первое *Определение* может находиться в той же строке, что и `EXPORTS` ключевое слово, или в следующей строке. В файле DEF могут содержаться один или несколько операторов `EXPORTS`.

Для *определения* экспорта используется следующий синтаксис:

> *ИмяЗаписи* *internal_name other_module. exported_name*] Ordinal\[неимя] ]\[ **\@** |\[ __=__ \[ \[ **Частный**] | **Данные]** ] \[

*Имязаписи* — это имя функции или переменной, которую необходимо экспортировать. Оно является обязательным. Если экспортируемое имя отличается от имени в библиотеке DLL, укажите имя экспорта в библиотеке DLL с помощью *internal_name*. Например, если библиотека DLL экспортирует функцию `func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=func1
```

Если экспортируемое имя относится к другому модулю, укажите имя экспорта в библиотеке DLL с помощью *other_module. exported_name*. Например, если библиотека DLL экспортирует функцию `other_module.func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=other_module.func1
```

Если экспортируемое имя относится к другому модулю, который экспортирует по порядковому номеру, укажите порядковый номер экспорта в библиотеке DLL с помощью *other_module*. *порядковый номер.* __#__ Например, если библиотека DLL экспортирует функцию из другого модуля, где она имеет порядковый номер 42, и вы хотите, чтобы вызывающие объекты использовали `func2`ее как, следует указать:

```DEF
EXPORTS
   func2=other_module.#42
```

Так как компилятор компилятором MSVC использует декорирование имен C++ для функций, необходимо либо использовать декорированное имя *internal_name* , либо определить экспортированные функции с `extern "C"` помощью в исходном коде. Компилятор также добавляет функции C, использующие соглашение о вызовах [__stdcall](../../cpp/stdcall.md) с префиксом подчеркивания (\_), и суффикс, состоящий из символа at (\@), за которым следует число байтов (в десятичной системе) в списке аргументов.

Чтобы найти внутренние имена, созданные компилятором, используйте средство [dumpbin](dumpbin-reference.md) или параметр компоновщика [/Map](map-generate-mapfile.md) . Декорированные имена зависят от компилятора. Если вы экспортируете декорированные имена в файле DEF, сборка исполняемых файлов, связанных с библиотекой DLL, должна осуществляться с помощью той же версии компилятора. Таким образом обеспечивается совпадение декорированных имен в вызывающем объекте с экспортированными именами в файле DEF.

Можно использовать \@ *порядковый номер* , чтобы указать, что число, а не имя функции, передается в таблицу экспорта библиотеки DLL. Многие библиотеки DLL Windows экспортируют порядковые номера для поддержки устаревшего кода. В 16-разрядном коде Windows часто использовались порядковые номера, так как это позволяло уменьшить размер DLL. Мы не рекомендуем экспортировать функции по порядковым номерам, если это не требуется клиентам библиотеки DLL для поддержки устаревшего кода. Файл LIB будет содержать сопоставление между порядковым номером и функцией, что позволит использовать имя функции, как обычно в проектах, использующих DLL.

С помощью необязательного ключевого слова « **имя** » можно экспортировать только по порядковому номеру и уменьшить размер таблицы экспорта в ИТОГОВОЙ библиотеке DLL. Однако если вы хотите использовать [GetProcAddress](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) для библиотеки DLL, необходимо выяснить порядковый номер, так как имя будет недействительным.

Необязательное ключевое слово **Private** предотвращает включение аргумента *Имязаписи* в библиотеку импорта, созданную ссылкой. Оно не влияет на экспорт в образ, также созданный с помощью LINK.

Необязательные **данные** ключевого слова указывают, что экспорт — это данные, а не код. Например, переменную с именем `exported_global`, содержащую данные, можно экспортировать так.

```DEF
EXPORTS
   exported_global DATA
```

Существует четыре способа экспорта определения; здесь они перечислены в порядке предпочтительности:

1. Ключевое слово [__declspec (dllexport)](../../cpp/dllexport-dllimport.md) в исходном коде

1. оператор `EXPORTS` в файле DEF;

1. Спецификация [/Export](export-exports-a-function.md) в команде LINK

1. Директива [комментария](../../preprocessor/comment-c-cpp.md) в исходном коде формы `#pragma comment(linker, "/export: definition ")`. В следующем примере показана директива комментария #pragma перед объявлением функции, `PlainFuncName` где — это недекорированное имя `_PlainFuncName@4` , а — декорированное имя функции:

    ```cpp
    #pragma comment(linker, "/export:PlainFuncName=_PlainFuncName@4")
    BOOL CALLBACK PlainFuncName( Things * lpParams)
    ```

Директива #pragma полезна, если необходимо экспортировать недекорированное имя функции и иметь разные экспортируемые компоненты в зависимости от конфигурации сборки (например, в 32-разрядных или 64-разрядных сборках).

Все эти методы можно использовать в одной программе. Когда программа LINK создает программу, содержащую экспорты, она также создает библиотеку импорта (если только при построении не используется файл EXP).

Ниже приведен пример раздела EXPORTS.

```DEF
EXPORTS
   DllCanUnloadNow      @1          PRIVATE
   DllWindowName = WindowName       DATA
   DllGetClassObject    @4 NONAME   PRIVATE
   DllRegisterServer    @7
   DllUnregisterServer
```

Если экспортируется переменная из библиотеки DLL с помощью файла DEF, вам не надо указывать `__declspec(dllexport)` для переменной. Однако в любом файле, использующем библиотеку DLL, вы должны использовать `__declspec(dllimport)` для объявления данных.

## <a name="see-also"></a>См. также

[Правила для операторов определения модуля](rules-for-module-definition-statements.md)
