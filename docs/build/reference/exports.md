---
title: EXPORTS
ms.date: 09/07/2018
f1_keywords:
- EXPORTS
helpviewer_keywords:
- EXPORTS .def file statement
ms.assetid: dbcd7579-b855-44c4-bd27-931e157657f7
ms.openlocfilehash: 33b70c680bfc3db24f5326a2027fa9ec4740e3f2
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2019
ms.locfileid: "57814141"
---
# <a name="exports"></a>EXPORTS

Начинает раздел, состоящий из одного или нескольких определений экспорта, в которых указываются имена или порядковые номера экспортируемых функций или данных. Каждое определение должно находиться в отдельной строке.

```DEF
EXPORTS
   definition
```

## <a name="remarks"></a>Примечания

Первый *определение* может располагаться на той же строке, что `EXPORTS` ключевое слово или в следующей строке. В файле DEF могут содержаться один или несколько операторов `EXPORTS`.

Синтаксис для экспорта *определение* является:

> *имя*\[__=__*internal_name*|*other_module.exported_name*] \[ **\@** _порядковый номер_ \[ **NONAME**]] \[ \[ **PRIVATE**] | \[ **Данных**]]

*имя* — имя функции или переменной, которое вы хотите экспортировать. Оно является обязательным. Если имя, которое вы экспортируете отличается от имени в библиотеке DLL, укажите имя экспорта в DLL с помощью *internal_name*. Например, если библиотека DLL экспортирует функцию `func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=func1
```

Если имя, которое можно экспортировать из некоторых других модуля, укажите имя экспорта в DLL с помощью *other_module.exported_name*. Например, если библиотека DLL экспортирует функцию `other_module.func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=other_module.func1
```

Если имя, которое можно экспортировать из другого модуля, который экспортирует по порядковому номеру, укажите экспорта порядкового номера в библиотеке DLL с помощью *other_module*.__#__ *порядковый номер*. Например, если библиотека DLL экспортирует функцию из другого модуля это порядковый номер 42, куда вы хотите вызывающим сторонам использовать его как `func2`, следует указать:

```DEF
EXPORTS
   func2=other_module.#42
```

Так как компилятор MSVC использует Декорирование имен для функций C++, необходимо использовать декорированное имя *internal_name* или определить экспортируемые функции с помощью `extern "C"` в исходном коде. Компилятор также декорирует функции C, использующие [__stdcall](../../cpp/stdcall.md) соглашение о вызовах с символа подчеркивания (\_) префикса и суффикса содержит знак (\@) за которым следует число байтов (в десятичном формате) в список аргументов.

Чтобы найти декорированные имена, созданные компилятором, используйте [DUMPBIN](dumpbin-reference.md) средства или компоновщик [/MAP](map-generate-mapfile.md) параметр. Декорированные имена зависят от компилятора. Если вы экспортируете декорированные имена в файле DEF, сборка исполняемых файлов, связанных с библиотекой DLL, должна осуществляться с помощью той же версии компилятора. Таким образом обеспечивается совпадение декорированных имен в вызывающем объекте с экспортированными именами в файле DEF.

Можно использовать \@ *порядковый номер* для указания, что число, а не имя функции, переходит в таблице экспорта DLL. Многие библиотеки DLL Windows экспортируют порядковые номера для поддержки устаревшего кода. В 16-разрядном коде Windows часто использовались порядковые номера, так как это позволяло уменьшить размер DLL. Мы не рекомендуем экспортировать функции по порядковым номерам, если это не требуется клиентам библиотеки DLL для поддержки устаревшего кода. Файл LIB будет содержать сопоставление между порядковым номером и функцией, что позволит использовать имя функции, как обычно в проектах, использующих DLL.

С помощью необязательного **NONAME** ключевое слово, можно экспортировать только порядковый номер и сократить размер таблицы экспорта в итоговому файлу DLL. Тем не менее если вы хотите использовать [GetProcAddress](/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress) в DLL, необходимо знать порядковый номер, поскольку имя не будет допустимым.

Необязательное ключевое слово **ЧАСТНОГО** предотвращает *имя* включаются в библиотеке импорта, созданной LINK. Оно не влияет на экспорт в образ, также созданный с помощью LINK.

Необязательное ключевое слово **данных** указывает, что экспорт содержит данные, а не код. Например, переменную с именем `exported_global`, содержащую данные, можно экспортировать так.

```DEF
EXPORTS
   exported_global DATA
```

Существует четыре способа экспорта определения; здесь они перечислены в порядке предпочтительности:

1. [__Declspec(dllexport)](../../cpp/dllexport-dllimport.md) ключевое слово в исходном коде

1. оператор `EXPORTS` в файле DEF;

1. [/EXPORT](export-exports-a-function.md) спецификации в команде LINK

1. Объект [комментарий](../../preprocessor/comment-c-cpp.md) директив в исходном коде, в формате `#pragma comment(linker, "/export: definition ")`. В следующем примере показано comment-директива #pragma перед объявлением функции, где `PlainFuncName` недекорированное имя, и `_PlainFuncName@4` декорированное имя функции:

    ```cpp
    #pragma comment(linker, "/export:PlainFuncName=_PlainFuncName@4")
    BOOL CALLBACK PlainFuncName( Things * lpParams)
    ```

Директиву #pragma полезно в том случае, если вам нужно экспортировать имени объявление функции, а у различных операций экспорта в зависимости от конфигурации сборки (например, в 32-разрядная или 64-разрядных сборок).

Все эти методы можно использовать в одной программе. Когда программа LINK создает программу, содержащую экспорты, она также создает библиотеку импорта (если только при построении не используется файл EXP).

Ниже приведен пример раздела EXPORTS.

```DEF
EXPORTS
   DllCanUnloadNow      @1          PRIVATE
   DllWindowName = WindowName       DATA
   DllGetClassObject    @4 NONAME   PRIVATE
   DllRegisterServer    @7
   DllUnregisterServer
```

Если экспортируется переменная из библиотеки DLL с помощью файла DEF, вам не надо указывать `__declspec(dllexport)` для переменной. Однако в любом файле, использующем библиотеку DLL, вы должны использовать `__declspec(dllimport)` для объявления данных.

## <a name="see-also"></a>См. также

[Правила для операторов определения модуля](rules-for-module-definition-statements.md)
