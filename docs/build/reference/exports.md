---
description: 'Дополнительные сведения: EXPORTs'
title: EXPORTS
ms.date: 09/07/2018
f1_keywords:
- EXPORTS
helpviewer_keywords:
- EXPORTS .def file statement
ms.assetid: dbcd7579-b855-44c4-bd27-931e157657f7
ms.openlocfilehash: b886f626854012c3cc477fcb11ac74a1e7776299
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97192348"
---
# <a name="exports"></a>EXPORTS

Начинает раздел, состоящий из одного или нескольких определений экспорта, в которых указываются имена или порядковые номера экспортируемых функций или данных. Каждое определение должно находиться в отдельной строке.

```DEF
EXPORTS
   definition
```

## <a name="remarks"></a>Комментарии

Первое *Определение* может находиться в той же строке, что `EXPORTS` и ключевое слово, или в следующей строке. В файле DEF могут содержаться один или несколько операторов `EXPORTS`.

Для *определения* экспорта используется следующий синтаксис:

>  \[ Имязаписи __=__ *internal_name* | *other_module.exported_name*] \[ **\@** _Ordinal_ \[ **Name**] \[ ] \[ **Частный**] | \[ **Данные**]]

*Имязаписи* — это имя функции или переменной, которую необходимо экспортировать. Это обязательный шаг. Если экспортируемое имя отличается от имени в библиотеке DLL, укажите имя экспорта в библиотеке DLL с помощью *internal_name*. Например, если библиотека DLL экспортирует функцию `func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=func1
```

Если экспортируемое имя относится к другому модулю, укажите имя экспорта в библиотеке DLL с помощью *other_module. exported_name*. Например, если библиотека DLL экспортирует функцию `other_module.func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=other_module.func1
```

Если экспортируемое имя относится к другому модулю, который экспортирует по порядковому номеру, укажите порядковый номер экспорта в библиотеке DLL с помощью *other_module*. __#__ *порядковый номер*. Например, если библиотека DLL экспортирует функцию из другого модуля, где она имеет порядковый номер 42, и вы хотите, чтобы вызывающие объекты использовали ее как `func2` , следует указать:

```DEF
EXPORTS
   func2=other_module.#42
```

Так как компилятор КОМПИЛЯТОРОМ MSVC использует декорирование имен для функций C++, необходимо либо использовать декорированное имя *internal_name* либо определить экспортированные функции с помощью `extern "C"` в исходном коде. Компилятор также добавляет функции C, использующие соглашение о вызовах [__stdcall](../../cpp/stdcall.md) с префиксом подчеркивания ( \_ ) и суффиксом, состоящим из символа at ( \@ ), за которым следует число байтов (в десятичной системе) в списке аргументов.

Чтобы найти внутренние имена, созданные компилятором, используйте средство [dumpbin](dumpbin-reference.md) или параметр компоновщика [/Map](map-generate-mapfile.md) . Декорированные имена зависят от компилятора. Если вы экспортируете декорированные имена в файле DEF, сборка исполняемых файлов, связанных с библиотекой DLL, должна осуществляться с помощью той же версии компилятора. Таким образом обеспечивается совпадение декорированных имен в вызывающем объекте с экспортированными именами в файле DEF.

Можно использовать \@ *порядковый номер* , чтобы указать, что число, а не имя функции, передается в таблицу экспорта библиотеки DLL. Многие библиотеки DLL Windows экспортируют порядковые номера для поддержки устаревшего кода. В 16-разрядном коде Windows часто использовались порядковые номера, так как это позволяло уменьшить размер DLL. Мы не рекомендуем экспортировать функции по порядковому номеру, если клиенты библиотеки DLL не нуждаются в них для поддержки прежних версий. Файл LIB будет содержать сопоставление между порядковым номером и функцией, что позволит использовать имя функции, как обычно в проектах, использующих DLL.

С помощью необязательного ключевого слова « **имя** » можно экспортировать только по порядковому номеру и уменьшить размер таблицы экспорта в ИТОГОВОЙ библиотеке DLL. Однако если вы хотите использовать [GetProcAddress](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) для библиотеки DLL, необходимо выяснить порядковый номер, так как имя будет недействительным.

Необязательное ключевое слово **Private** предотвращает включение аргумента *Имязаписи* в библиотеку импорта, созданную ссылкой. Оно не влияет на экспорт в образ, также созданный с помощью LINK.

Необязательные **данные** ключевого слова указывают, что экспорт — это данные, а не код. Например, переменную с именем `exported_global`, содержащую данные, можно экспортировать так.

```DEF
EXPORTS
   exported_global DATA
```

Существует четыре способа экспорта определения; здесь они перечислены в порядке предпочтительности:

1. Ключевое слово [__declspec (dllexport)](../../cpp/dllexport-dllimport.md) в исходном коде

1. оператор `EXPORTS` в файле DEF;

1. Спецификация [/Export](export-exports-a-function.md) в команде LINK

1. Директива [комментария](../../preprocessor/comment-c-cpp.md) в исходном коде формы `#pragma comment(linker, "/export: definition ")` . В следующем примере показана директива комментария #pragma перед объявлением функции, где `PlainFuncName` — это недекорированное имя, а `_PlainFuncName@4` — декорированное имя функции:

    ```cpp
    #pragma comment(linker, "/export:PlainFuncName=_PlainFuncName@4")
    BOOL CALLBACK PlainFuncName( Things * lpParams)
    ```

Директива #pragma полезна, если необходимо экспортировать недекорированное имя функции и иметь разные экспортируемые компоненты в зависимости от конфигурации сборки (например, в 32-разрядных или 64-разрядных сборках).

Все эти методы можно использовать в одной программе. Когда программа LINK создает программу, содержащую экспорты, она также создает библиотеку импорта (если только при построении не используется файл EXP).

Ниже приведен пример раздела EXPORTS.

```DEF
EXPORTS
   DllCanUnloadNow      @1          PRIVATE
   DllWindowName = WindowName       DATA
   DllGetClassObject    @4 NONAME   PRIVATE
   DllRegisterServer    @7
   DllUnregisterServer
```

Если экспортируется переменная из библиотеки DLL с помощью файла DEF, вам не надо указывать `__declspec(dllexport)` для переменной. Однако в любом файле, использующем библиотеку DLL, вы должны использовать `__declspec(dllimport)` для объявления данных.

## <a name="see-also"></a>См. также раздел

[Правила для Module-Definitionных инструкций](rules-for-module-definition-statements.md)
