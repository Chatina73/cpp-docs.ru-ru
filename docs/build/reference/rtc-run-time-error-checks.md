---
title: /RTC (проверки ошибок во время выполнения)
ms.date: 11/04/2016
f1_keywords:
- /rtc
- VC.Project.VCCLCompilerTool.SmallerTypeCheck
- VC.Project.VCCLCompilerTool.UninitializedVariableCheck
- VC.Project.VCCLCompilerTool.StackFrameCheck
- VC.Project.VCCLCompilerTool.BasicRuntimeChecks
helpviewer_keywords:
- /RTCs compiler option [C++]
- -RTC1 compiler option [C++]
- run-time errors, error checks
- -RTCu compiler option [C++]
- /RTC1 compiler option [C++]
- /RTCc compiler option [C++]
- /RTCu compiler option [C++]
- __MSVC_RUNTIME_CHECKS macro
- -RTCs compiler option [C++]
- RTCs compiler option
- RTC1 compiler option
- run-time errors, run-time checks
- run-time checks, /RTC option
- RTCu compiler option
- RTCc compiler option
- -RTCc compiler option [C++]
ms.assetid: 9702c558-412c-4004-acd5-80761f589368
ms.openlocfilehash: 49f0e4bace5f3dd199b58854e838204bd2cd5f3b
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87222021"
---
# <a name="rtc-run-time-error-checks"></a>/RTC (проверки ошибок во время выполнения)

Используется для включения и отключения функции проверки ошибок во время выполнения в сочетании с директивой pragma [runtime_checks](../../preprocessor/runtime-checks.md) .

## <a name="syntax"></a>Синтаксис

```
/RTC1
/RTCc
/RTCs
/RTCu
```

## <a name="arguments"></a>Аргументы

**1**<br/>
Эквивалент **/RTC** `su` .

**ц**<br/>
Сообщает, когда значение присвоено меньшему типу данных и приводит к потери данных. Например, если значение типа `short 0x101` присваивается переменной типа **`char`** .

Этот параметр сообщает о ситуациях, в которых предполагается усечение, например, если требуется, чтобы первые восемь бит **`int`** возвращены как **`char`** . Поскольку **/RTC** `c` вызывает ошибку во время выполнения, если в результате назначения теряются какие-либо сведения, можно скрыть сведения, необходимые, чтобы избежать ошибки во время выполнения в результате использования **/RTC** `c` . Пример:

```
#include <crtdbg.h>

char get8bits(int value, int position) {
   _ASSERT(position < 32);
   return (char)(value >> position);
   // Try the following line instead:
   // return (char)((value >> position) & 0xff);
}

int main() {
   get8bits(12341235,3);
}
```

**#d0**<br/>
Включает проверку ошибок во время выполнения кадра стека следующим образом.

- Инициализация локальных переменных для ненулевого значения. Это помогает выявить ошибки, которые не отображаются при работе в режиме отладки. Существует большая вероятность того, что переменные стека будут по-прежнему иметь нулевое значение в отладочной сборке по сравнению с построением выпуска из-за оптимизации компилятора переменных стека в сборке выпуска. Когда в программе используется область стека, компилятор никогда не сбрасывает его в 0. Таким образом, последующие неинициализированные переменные стека, которые используют одну и ту же область стека, могут возвращать значения, оставшиеся перед использованием этой памяти стека.

- Обнаружение перезапусков и неполных запусков локальных переменных, таких как массивы. **/RTC** `s` не будет обнаруживать переполнения при доступе к памяти, полученной в результате заполнения компилятора в структуре. Заполнение может осуществляться с [помощью](../../cpp/align-cpp.md)метода [alignment,/Zp (выравнивание членов структуры)](zp-struct-member-alignment.md)или типа " [Pack](../../preprocessor/pack.md)" или при упорядочении элементов структуры таким образом, чтобы требовать от компилятора добавлять заполнение.

- Проверка указателя стека, которая обнаруживает повреждение указателя стека. Повреждение указателя стека может быть вызвано несоответствием соглашения о вызовах. Например, с помощью указателя функции вы вызываете функцию в библиотеке DLL, которая экспортируется как [__stdcall](../../cpp/stdcall.md) , но вы объявляете указатель на функцию как [__cdecl](../../cpp/cdecl.md).

**u**<br/>
Сообщает, когда переменная используется без инициализации. Например, инструкция, которая создает `C4701` ошибку во время выполнения, может также формироваться в **/RTC** `u` . Любая инструкция, создающая [Предупреждение компилятора (уровень 1 и уровень 4) C4700](../../error-messages/compiler-warnings/compiler-warning-level-1-and-level-4-c4700.md) , выдаст ошибку времени выполнения в **/RTC** `u` .

Однако рассмотрим следующий фрагмент кода:

```cpp
int a, *b, c;
if ( 1 )
b = &a;
c = a;  // No run-time error with /RTCu
```

Если переменная могла быть инициализирована, она не будет выводиться во время выполнения с помощью **/RTC** `u` . Например, после присвоения псевдониму переменной с помощью указателя компилятор не будет вести трассировку и использовать неинициализированные переменные. По сути, можно инициализировать переменную, используя ее адрес. Оператор & работает как оператор присваивания в этой ситуации.

## <a name="remarks"></a>Remarks

Проверки ошибок во время выполнения — это способ поиска проблем в выполняемом коде; Дополнительные сведения см. [в разделе инструкции. Использование проверок во время выполнения машинного кода](/visualstudio/debugger/how-to-use-native-run-time-checks).

Если вы компилируете программу из командной строки с помощью любого из параметров компилятора **/RTC** , все инструкции по [оптимизации](../../preprocessor/optimize.md) директивы pragma в коде будут завершаться ошибкой без ошибок. Это обусловлено тем, что проверки ошибок во время выполнения не являются допустимыми в сборке выпуска (оптимизированной).

Для сборок разработки следует использовать **/RTC** . **/RTC** не следует использовать для розничной сборки. **/RTC** нельзя использовать с оптимизацией компилятора ([Параметры/O (оптимизация кода)](o-options-optimize-code.md)). Образ программы, созданный с помощью **/RTC** , будет немного больше и немного медленнее, чем образ, созданный с параметром **/OD** (до 5% медленнее, чем сборка **/OD** ).

Директива препроцессора __MSVC_RUNTIME_CHECKS будет определена при использовании любого параметра **/RTC** или [/gz](gz-enable-stack-frame-run-time-error-checking.md).

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Откройте папку **C/C++** .

1. Перейдите на страницу свойств **Создание кода** .

1. Измените одно или оба из следующих свойств: **Обычная проверка времени выполнения** или **Проверка типа меньшего размера**.

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. описание свойств <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.BasicRuntimeChecks%2A> и <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.SmallerTypeCheck%2A>.

## <a name="see-also"></a>См. также раздел

[Параметры компилятора MSVC](compiler-options.md)<br/>
[Синтаксис командной строки компилятора КОМПИЛЯТОРОМ MSVC](compiler-command-line-syntax.md)<br/>
[Практическое руководство. Настройка проверок во время выполнения машинного кода](/visualstudio/debugger/how-to-use-native-run-time-checks)
