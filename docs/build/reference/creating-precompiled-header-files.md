---
title: Создание файлов предкомпилированных заголовков
ms.date: 11/04/2016
f1_keywords:
- pch
helpviewer_keywords:
- precompiled header files, creating
- PCH files, creating
- cl.exe compiler, precompiling code
- .pch files, creating
ms.assetid: e2cdb404-a517-4189-9771-c869c660cb1b
ms.openlocfilehash: 3014b2da9f9d9e03e9ea791c9a97ff59f842e8ae
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50482619"
---
# <a name="creating-precompiled-header-files"></a>Создание файлов предкомпилированных заголовков

Компиляторы Microsoft C и C++ содержат параметры для предварительной компиляции любого кода C или C++, включая встроенный код. Данная возможность позволяет скомпилировать стабильное тело кода, сохранять скомпилированное состояние кода в файле, а при последующих компиляциях объединять предварительно скомпилированный код с кодом, который еще находится в стадии разработки. Каждая последующая компиляция выполняется быстрее, так как стабильный код не нужно компилировать повторно.

В этом разделе рассматриваются следующие темы предкомпилированного заголовка:

- [Случаи использования предварительной компиляции исходного кода](#when-to-precompile-source-code)

- [Два варианта предварительной компиляции кода](#two-choices-for-precompiling-code)

- [Правила согласованности предкомпилированных заголовков](#precompiled-header-consistency-rules)

- [Правила целостности для пофайлового использования предкомпилированных заголовков](#consistency-rules-for-per-file-use-of-precompiled-headers)

- [Правила целостности для параметров компилятора /Yc и /Yu](#consistency-rules-for-yc-and-yu)

- [Использование предкомпилированных заголовков в проекте](#using-precompiled-headers-in-a-project)

- [PCH-файлы в процессе сборки](#pch-files-in-the-build-process)

- [Образец файла makefile для PCH](#sample-makefile-for-pch)

- [Пример кода для PCH](#example-code-for-pch)

Справочные сведения о параметрах компилятора, связанных с предкомпилированными заголовками, см. в разделе [/Y (предкомпилированные заголовки)](../../build/reference/y-precompiled-headers.md).

<a name="when-to-precompile-source-code"></a>

## <a name="when-to-precompile-source-code"></a>Случаи использования предварительной компиляции исходного кода

Предварительно скомпилированный код полезен при разработке приложений для сокращения времени компиляции, особенно в том случае, если:

- Всегда используется большая часть кода, которые редко изменяются.

- Программа состоит из нескольких модулей, каждый из которых использует стандартный набор включаемых файлов и те же параметры компиляции. В этом случае все файлы включения могут быть предварительно откомпилированы в одну предкомпилированного заголовка.

Первой компиляции — тот, который создает файл предкомпилированного заголовка (PCH) — немного дольше, чем последующие компиляции. Последующие компиляции происходят быстрее, включив предварительно скомпилированный код.

Можно предварительно скомпилировать программ на языках C и C++. В программирования C++ это распространенная практика размещать интерфейсы классов в файлах заголовков. Эти файлы позже могут быть включены в программах, использующих класс. Путем предварительной компиляции эти заголовки, можно уменьшить время, необходимое для компиляции программы.

> [!NOTE]
>  Несмотря на то, что можно использовать только один файл предкомпилированного заголовка (PCH) в исходном файле, можно использовать несколько PCH-файлы в проекте.

<a name="two-choices-for-precompiling-code"></a>

# <a name="two-choices-for-precompiling-code"></a>Два варианта предварительной компиляции кода

С помощью Visual C++ можно предварительно скомпилировать код C или C++; Вы не ограничены предварительную компиляцию только файлы заголовков.

Предварительная компиляция требует планирования, но он обеспечивает значительно быстрее компиляциях, если предварительной компиляции исходного кода, компиляции.

Выполняет предварительную компиляцию кода, когда вы знаете, что исходные файлы используются общие наборы файлов заголовков, но не включайте их в том же порядке или когда требуется включить в предварительную компиляцию исходного кода.

Параметры предварительно скомпилированного заголовка [/Yc (создать предкомпилированный заголовочный файл)](../../build/reference/yc-create-precompiled-header-file.md) и [/Yu (использование файла предкомпилированного заголовка)](../../build/reference/yu-use-precompiled-header-file.md). Используйте **/Yc** для создания предкомпилированного заголовка. При использовании с необязательным [hdrstop](../../preprocessor/hdrstop.md) директивы pragma **/Yc** позволяет предварительной компиляции обоих файлов заголовков и исходного кода. Выберите **/Yu** использовать существующий предкомпилированный заголовок в существующей компиляции. Можно также использовать **/FP** с **/Yc** и **/Yu** варианты, чтобы альтернативное имя для предкомпилированного заголовка.

Параметр компилятора справочных разделах по **/Yu** и **/Yc** обсуждаются способы доступа к этой функции в среде разработки.

<a name="precompiled-header-consistency-rules"></a>

## <a name="precompiled-header-consistency-rules"></a>Правила согласованности предкомпилированных заголовков

Поскольку PCH-файлы содержат сведения о среде машины и адрес памяти о программе, следует использовать только PCH-файл на компьютере, в котором он был создан.

<a name="consistency-rules-for-per-file-use-of-precompiled-headers"></a>

## <a name="consistency-rules-for-per-file-use-of-precompiled-headers"></a>Правила целостности для пофайлового использования предкомпилированных заголовков

[/Yu](../../build/reference/yu-use-precompiled-header-file.md) параметры компилятора позволяют указать, какой файл PCH, следует использовать.

При использовании PCH-файл, компилятор предполагает той же среде компиляции — использует одинаковые параметры компилятора, директивы pragma и т. д., которая использовалась при создании PCH-файл, если не указано иное. Если компилятор обнаруживает несовместимость, он выдает предупреждение и определяет несоответствие, где это возможно. Такие предупреждения не обязательно указывают на проблему с файлом PCH; они просто предупреждает пользователя о возможных конфликтах. В следующих разделах описываются требования к согласованности для PCH-файлы.

### <a name="compiler-option-consistency"></a>Правила целостности для параметров компилятора

Следующие параметры компилятора можно вызвать предупреждение о нарушении целостности, при использовании PCH-файл:

- Макросы, созданные с помощью препроцессора (/ D) должен быть одинаковым в разных компиляции, создавшей PCH-файл и текущей компиляции. Состояние определенных констант не проверяется, но результаты могут быть непредсказуемы их изменение.

- PCH-файлы не работают с параметрами /E и /EP.

- PCH-файлы должны создаваться с помощью либо создать Обзор информацию (/ FR) параметр или исключить локальные переменные (/ Fr) параметра, прежде чем эти параметры можно использовать для последующих компиляциях с использованием PCH-файл.

### <a name="c-70-compatible-z7"></a>Совместимость с C 7.0 (/ Z7)

Если этот параметр действует, когда создается PCH-файл, последующих компиляциях с использованием PCH-файл можно использовать отладочную информацию.

Если совместимость с C 7.0 (/ Z7) параметр не действует при создании PCH-файл, последующих компиляциях с использованием PCH-файл и/Z7 приводят к возникновению предупреждения. Отладочная информация помещается в текущий OBJ-файле, и локальные символы, определенные в PCH-файл не доступны в отладчик.

### <a name="include-path-consistency"></a>Согласованность путей включения

PCH-файл не содержит сведения о пути включения, которая была действующей при его создании. При использовании PCH-файл, компилятор всегда использует путем включения, заданным в текущей компиляции.

### <a name="source-file-consistency"></a>Согласованность исходных файлов

При использовании параметра использование файла предкомпилированного заголовка (/Yu), компилятор игнорирует все директивы препроцессора (включая прагма-директивы), которые отображаются в исходном коде, который будет предварительно скомпилировать. Компиляции, определенной такие директивы препроцессора должен быть таким же, как компиляции с использованием параметра Создание файла предкомпилированного заголовка (/Yc).

### <a name="pragma-consistency"></a>Директива pragma согласованности

Директивы pragma, обработано во время создания PCH-файл, обычно затрагивает файл, с помощью которого впоследствии используется PCH-файл. `comment` И `message` директивы pragma не влияют на остальной части компиляции.

Эти директивы pragma влияют на код только в PCH-файл; они не влияют на код, который впоследствии использует PCH-файл:

||||
|-|-|-|
|`comment`|`page`|`subtitle`|
|`linesize`|`pagesize`|`title`|
|`message`|`skip`||

Эти директивы pragma затрагивают остальная часть компиляции с параметром предкомпилированного заголовка и сохраняются как часть предкомпилированного заголовка.

||||
|-|-|-|
|`alloc_text`|`include_alias`|`pack`|
|`auto_inline`|`init_seg`|`pointers_to_members`|
|`check_stack`|`inline_depth`|`setlocale`|
|`code_seg`|`inline_recursion`|`vtordisp`|
|`data_seg`|`intrinsic`|`warning`|
|`function`|`optimize`||

<a name="consistency-rules-for-yc-and-yu"></a>

## <a name="consistency-rules-for-yc-and-yu"></a>Правила целостности для параметров компилятора /Yc и /Yu

При использовании предкомпилированного заголовка, созданных с помощью параметров компилятора /Yc и /Yu компилятор сравнивает текущей среды компиляции для того, который был создан PCH-файл. Не забудьте указать среду, совместимую с предыдущей (используя одинаковые параметры компилятора, директивы pragma и т. д.) для текущей компиляции. Если компилятор обнаруживает несовместимость, он выдает предупреждение и определяет несоответствие, где это возможно. Такие предупреждения не обязательно указывают на проблему с файлом предкомпилированного Заголовка; они просто предупреждает пользователя о возможных конфликтах. В следующих разделах объясняется требований к согласованности для предкомпилированных заголовков.

### <a name="compiler-option-consistency"></a>Правила целостности для параметров компилятора

В этой таблице перечислены параметры компилятора, которые могут вызвать предупреждение о нарушении целостности, при использовании предкомпилированного заголовка.

|Параметр|name|Правило|
|------------|----------|----------|
|/D|Определяет константы и макросы|Должно быть одинаковым в разных компиляции, создавшей предкомпилированного заголовка и текущей компиляции. Состояние определенных констант не проверяется, но к непредсказуемым результатам может произойти, если файлы зависят от значений измененных констант.|
|/E или /EP|Копирует выходные данные препроцессора в стандартный вывод|Предкомпилированные заголовки не работают с параметром /E или /EP.|
|/FR или/fr|Создать сведения обозревателя исходного кода Майкрософт|/Fr и /FR параметры можно использовать с параметром /Yu они использовались в силе во время создания предкомпилированного заголовка. Последующих компиляциях с использованием предкомпилированного заголовка также создать информацию обозревателя исходного кода. Информация для браузера помещается в единый SBR-файл и имеется ссылка в другие файлы в так же, как Информация CodeView. Не может переопределить размещение данных обозревателя исходного кода.|
|/ GA, /GD, /GE, /Gw или /GW|Параметры протокола в Windows|Должно быть одинаковым в разных компиляции, создавшей предкомпилированного заголовка и текущей компиляции. Если эти параметры не совпадают, будет выдано предупреждение.|
|/ZI|Создает полную отладочную информацию|Если этот параметр действует при создании предкомпилированного заголовка, последующих компиляциях с использованием предварительной компиляции можно использовать эту отладочную информацию. Если/ZI не работают при создании предкомпилированного заголовка, последующих компиляциях с использованием предварительной компиляции и параметр/ZI приводят к возникновению предупреждения. Отладочная информация помещается в текущем файле объекта, и локальные символы, определенные в заголовке недоступны для отладчика.|

> [!NOTE]
>  Средство предкомпилированного заголовка предназначен для использования только в исходные файлы C и C++.

<a name="using-precompiled-headers-in-a-project"></a>

## <a name="using-precompiled-headers-in-a-project"></a>Использование предкомпилированных заголовков в проекте

Предыдущих разделах представлены общие сведения о предкомпилированных заголовков: параметров компилятора /Yc и /Yu, параметр/FP и [hdrstop](../../preprocessor/hdrstop.md) директивы pragma. В этом разделе описывается способ использования вручную параметров предкомпилированных заголовков в проекте; заканчивается примером файла makefile и код, который он управляет.

Другой подход к использованию вручную параметров предкомпилированных заголовков в проекте изучите один из файлов makefile, расположенных в каталоге MFC\SRC, которая создается во время установки Visual C++ по умолчанию. Эти файлы makefile требуют аналогичный подход представленному в этом разделе, но лучше использовать макросы Microsoft программы обслуживания программ (NMAKE) и обеспечивают больший контроль процесса построения.

<a name="pch-files-in-the-build-process"></a>

## <a name="pch-files-in-the-build-process"></a>PCH-файлы в процессе построения

База кода проекта программного обеспечения обычно содержится в нескольких C или C++ исходные файлы, файлы объектов, библиотек и файлы заголовков. Как правило в файл makefile сочетание этих элементов в исполняемый файл. На рисунке ниже показана структура файла makefile, использует файл предкомпилированного заголовка. Имена макроса NMAKE и имена файлов в этой схеме согласованы с методами в примере кода в [образец файла Makefile для PCH](#sample-makefile-for-pch) и [пример кода для PCH](#example-code-for-pch).

На рисунке используется три устройства Схематическое чтобы показать поток процесса построения. Именованные прямоугольники представляют файл или макрос; три представляют один или несколько файлов. Темные области представляют каждое действие компиляции или компоновки. Стрелки показывают, какие файлы и макросы объединяются во время компиляции или процесс связывания.

![Файл makefile, использующий файл предкомпилированного заголовка](../../build/reference/media/vc30ow1.gif "структура файла Makefile, использует файл предкомпилированного заголовка")
##### <a name="structure-of-a-makefile-that-uses-a-precompiled-header-file"></a>Структура файла Makefile, использующий файл предкомпилированного заголовка

Начиная с верхней части диаграммы, STABLEHDRS и BOUNDRY являются макрос (NMAKE), в которых перечисляются файлы, которые не могут потребоваться повторной компиляции. Эти файлы компилируются в командной строке

`CL /c /W3 /Yc$(BOUNDRY) applib.cpp myapp.cpp`

только в том случае, если файл предкомпилированного заголовка (STABLE.pch) не существует, или при внесении изменений в файлы, перечисленные в два макроса. В любом случае предкомпилированного файла заголовка будет содержать код только из файлов, перечисленных в макросе STABLEHDRS. Вывод списка последнего файла, который необходимо предварительно скомпилировать в макросе BOUNDRY.

Файлы, указанные в этих макросах может быть файлов заголовков или исходные файлы C или C++. (Один PCH-файл не может использоваться с модулями на языках C и C++.) Обратите внимание, что можно использовать **hdrstop** макрос, чтобы остановить предварительную компиляцию в определенной точке в файле BOUNDRY. См. в разделе [hdrstop](../../preprocessor/hdrstop.md) Дополнительные сведения.

Далее на, рисунке файл APPLIB.obj представляет код поддержки, используемый в конечном приложении. Он создается из APPLIB.cpp, файлов, перечисленных в макросе UNSTABLEHDRS и предварительно скомпилированного кода из файла предкомпилированного заголовка.

MYAPP.obj представляет конечное приложение. Он создается из MYAPP.cpp, файлов, перечисленных в макросе UNSTABLEHDRS и предварительно скомпилированного кода из файла предкомпилированного заголовка.

Наконец исполняемый файл (MYAPP. Exe-ФАЙЛ) создается путем связывания файлов, перечисленных в макросе ОБЪЕКТОВ (рисунке файл APPLIB.obj и MYAPP.obj).

<a name="sample-makefile-for-pch"></a>

## <a name="sample-makefile-for-pch"></a>Образец файла makefile для PCH

Следующий файл makefile использует макросы и! ЕСЛИ! ELSE! Структура команд управления потоком ENDIF для упрощения адаптации к проекту.

```NMAKE
# Makefile : Illustrates the effective use of precompiled
#            headers in a project
# Usage:     NMAKE option
# option:    DEBUG=[0|1]
#            (DEBUG not defined is equivalent to DEBUG=0)
#
OBJS = myapp.obj applib.obj
# List all stable header files in the STABLEHDRS macro.
STABLEHDRS = stable.h another.h
# List the final header file to be precompiled here:
BOUNDRY = stable.h
# List header files under development here:
UNSTABLEHDRS = unstable.h
# List all compiler options common to both debug and final
# versions of your code here:
CLFLAGS = /c /W3
# List all linker options common to both debug and final
# versions of your code here:
LINKFLAGS = /NOD /ONERROR:NOEXE
!IF "$(DEBUG)" == "1"
CLFLAGS   = /D_DEBUG $(CLFLAGS) /Od /Zi /f
LINKFLAGS = $(LINKFLAGS) /COD
LIBS      = slibce
!ELSE
CLFLAGS   = $(CLFLAGS) /Oselg /Gs
LINKFLAGS = $(LINKFLAGS)
LIBS      = slibce
!ENDIF
myapp.exe: $(OBJS)
    link $(LINKFLAGS) @<<
$(OBJS), myapp, NUL, $(LIBS), NUL;
<<
# Compile myapp
myapp.obj  : myapp.cpp $(UNSTABLEHDRS)  stable.pch
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    myapp.cpp
# Compile applib
applib.obj : applib.cpp $(UNSTABLEHDRS) stable.pch
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    applib.cpp
# Compile headers
stable.pch : $(STABLEHDRS)
    $(CPP) $(CLFLAGS) /Yc$(BOUNDRY)    applib.cpp myapp.cpp
```

Помимо STABLEHDRS BOUNDRY и UNSTABLEHDRS макросы, показанный на рисунке «Структура из Makefile, использует файл предкомпилированного заголовка» [PCH-файлы в процессе построения](#pch-files-in-the-build-process), это makefile предоставляет макрос CLFLAGS и LINKFLAGS макрос. Чтобы получить список параметры компилятора и компоновщика, которые применяются ли построение отладочной или окончательной версии исполняемого файла приложения, необходимо использовать эти макросы. Есть также макрос LIBS где перечислены библиотеки, необходимые требуются в вашем проекте.

Файл makefile также использует! ЕСЛИ! ELSE! ENDIF для обнаружения ли вы определить символ DEBUG в командной строке (NMAKE):

```NMAKE
NMAKE DEBUG=[1|0]
```

Эта функция позволяет использовать тот же файл makefile во время разработки и в окончательной версии программы, используйте DEBUG = 0 в окончательной версии. Следующие командные строки эквивалентны:

```NMAKE
NMAKE
NMAKE DEBUG=0
```

Дополнительные сведения о файлах makefile, см. в разделе [справочнике NMAKE](../../build/nmake-reference.md). Также см. в разделе [параметры компилятора](../../build/reference/compiler-options.md) и [параметры компоновщика](../../build/reference/linker-options.md).

<a name="example-code-for-pch"></a>

## <a name="example-code-for-pch"></a>Пример кода для PCH

Следующие исходные файлы используются в makefile, описанном в [PCH-файлы в процессе построения](#pch-files-in-the-build-process) и [образец файла Makefile для PCH](#sample-makefile-for-pch). Обратите внимание, что комментарии содержатся важные сведения.

```cpp
// ANOTHER.H : Contains the interface to code that is not
//             likely to change.
//
#ifndef __ANOTHER_H
#define __ANOTHER_H
#include<iostream>
void savemoretime( void );
#endif // __ANOTHER_H
```

```cpp
// STABLE.H : Contains the interface to code that is not likely
//            to change. List code that is likely to change
//            in the makefile's STABLEHDRS macro.
//
#ifndef __STABLE_H
#define __STABLE_H
#include<iostream>
void savetime( void );
#endif // __STABLE_H
```

```cpp
// UNSTABLE.H : Contains the interface to code that is
//              likely to change. As the code in a header
//              file becomes stable, remove the header file
//              from the makefile's UNSTABLEHDR macro and list
//              it in the STABLEHDRS macro.
//
#ifndef __UNSTABLE_H
#define __UNSTABLE_H
#include<iostream.h>
void notstable( void );
#endif // __UNSTABLE_H
```

```cpp
// APPLIB.CPP : This file contains the code that implements
//              the interface code declared in the header
//              files STABLE.H, ANOTHER.H, and UNSTABLE.H.
//
#include"another.h"
#include"stable.h"
#include"unstable.h"
// The following code represents code that is deemed stable and
// not likely to change. The associated interface code is
// precompiled. In this example, the header files STABLE.H and
// ANOTHER.H are precompiled.
void savetime( void )
    { cout << "Why recompile stable code?\n"; }
void savemoretime( void )
    { cout << "Why, indeed?\n\n"; }
// The following code represents code that is still under
// development. The associated header file is not precompiled.
void notstable( void )
    { cout << "Unstable code requires"
            << " frequent recompilation.\n";
    }
```

```cpp
// MYAPP.CPP : Sample application
//             All precompiled code other than the file listed
//             in the makefile's BOUNDRY macro (stable.h in
//             this example) must be included before the file
//             listed in the BOUNDRY macro. Unstable code must
//             be included after the precompiled code.
//
#include"another.h"
#include"stable.h"
#include"unstable.h"
int main( void )
{
    savetime();
    savemoretime();
    notstable();
}
```

## <a name="see-also"></a>См. также

[Справочные сведения о сборке C/C++](../../build/reference/c-cpp-building-reference.md)<br/>
[Параметры компилятора](../../build/reference/compiler-options.md)