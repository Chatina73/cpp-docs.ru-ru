---
description: 'Дополнительные сведения: ограничения/CLR'
title: Ограничения /clr
ms.date: 11/04/2016
helpviewer_keywords:
- /clr compiler option [C++], restrictions
ms.assetid: 385f6462-2c68-46d6-810e-469553ead447
ms.openlocfilehash: eb74aea8f1d6fcae4738f17f5fae2a4761350341
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97193010"
---
# <a name="clr-restrictions"></a>Ограничения /clr

Обратите внимание на следующие ограничения использования **/clr**:

- В структурированном обработчике исключений существуют ограничения на использование `_alloca` при компиляции с параметром **/clr**. Дополнительные сведения см. в разделе [_alloca](../../c-runtime-library/reference/alloca.md).

- Использование проверки ошибок во время выполнения не допускается с **/clr**. Дополнительная информация есть в статье [Практическое руководство. Настройка проверок во время выполнения машинного кода](/visualstudio/debugger/how-to-use-native-run-time-checks).

- Когда **/clr** используется для компиляции программы, которая использует только стандартный синтаксис C++, к использованию встроенной сборки применяются следующие правила:

  - Встроенный код сборки, который предполагает наличие знаний о макете собственного стека, соглашениях о вызовах за пределами текущей функции или других подробных сведений о компьютере, может завершиться ошибкой, если эта информация применяется к кадру стека для управляемой функции. Функции, содержащие встроенный код сборки, создаются как неуправляемые функции, как если бы они были помещены в отдельный модуль, скомпилированный без **/clr**.

  - Встроенный код сборки в функциях, который передает параметры функции, созданные копированием, не поддерживается.

- [Функции vprintf](../../c-runtime-library/vprintf-functions.md) нельзя вызывать из программы, скомпилированной с **/clr**.

- Модификатор [naked](../../cpp/naked-cpp.md) [__declspec](../../cpp/declspec.md) игнорируется при /clr.

- Функция-преобразователя, заданная [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md), повлияет только на перехваты в неуправляемом коде. Дополнительные сведения см. в разделе [Обработка исключений](../../extensions/exception-handling-cpp-component-extensions.md).

- Сравнение указателей на функции не разрешено с **/clr**.

- Использование функций, которые не являются полным прототипом, не разрешено с **/clr**.

- Следующие параметры компилятора не поддерживаются с **/clr**:

  - **/EHsc** и **/EHs** (**/clr** подразумевает **/EHa** (см. [Параметр /EH (модель обработки исключений)](eh-exception-handling-model.md))

  - **/fp:strict** и **/fp:except** (см. [/fp (Определение поведения с плавающей запятой)](fp-specify-floating-point-behavior.md))

  - [/Zd](z7-zi-zi-debug-information-format.md)

  - [/GM](gm-enable-minimal-rebuild.md)

  - [/MT](md-mt-ld-use-run-time-library.md)

  - [/RTC](rtc-run-time-error-checks.md)

  - [/ZI](z7-zi-zi-debug-information-format.md)

- Сочетание определения препроцессора `_STATIC_CPPLIB` (`/D_STATIC_CPPLIB`) и параметра компилятора **/clr** не поддерживается. Это происходит потому, что определение приводит к компоновке с помощью статической многопоточной стандартной библиотеки C++, которая не поддерживается. Дополнительные сведения см. в разделе [/MD, /MT, /LD (использование библиотеки времени выполнения)](md-mt-ld-use-run-time-library.md).

- Использование **/ZI** с **/clr** влияет на производительность. Дополнительные сведения см. в разделе [/Zi](z7-zi-zi-debug-information-format.md).

- Передача расширенного символа в под.NET Framework вывода без указания параметра [/Zc: wchar_t](zc-wchar-t-wchar-t-is-native-type.md) или без приведения символа в **`__wchar_t`** вызов приводит к отображению выходных данных в виде `unsigned short int` . Пример:

    ```cpp
    Console::WriteLine(L' ')              // Will output 32.
    Console::WriteLine((__wchar_t)L' ')   // Will output a space.
    ```

- [/GS](gs-buffer-security-check.md) игнорируется при компиляции с параметром **/clr**, если только функция не имеет статус `#pragma` [неуправляемая](../../preprocessor/managed-unmanaged.md) или если функция должна компилироваться в машинный код, и в этом случае компилятор выдаст предупреждение C4793, которое отключено по умолчанию.

- Требования к сигнатуре функции управляемого приложения см. в разделе [/ENTRY](entry-entry-point-symbol.md).

- Приложения, скомпилированные с **/openmp** и **/clr**, могут выполняться только в одном процессе области приложений.  Дополнительные сведения см. в разделе [/openmp (включение поддержки OpenMP 2.0)](openmp-enable-openmp-2-0-support.md).

- Функции, которые принимают переменное число аргументов (varargs), будут создаваться как собственные функции. Все управляемые типы данных в позиции аргументов переменных будут маршалированы в собственные типы. Обратите внимание, что типы <xref:System.String?displayProperty=fullName> фактически являются строками с широкими символами, но они маршалируются в однобайтовые символьные строки. Поэтому если описатель printf — %S (wchar_t *), он будет маршалировать в строку %s.

- Если вы используете макрос va_arg, можно получить непредвиденные результаты при компиляции с **/clr:pure**. Дополнительные сведения см. в разделе [va_arg, va_copy, va_end, va_start](../../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md). Параметры компилятора **/clr:pure** и **/clr:safe** не рекомендуется использовать в Visual Studio 2015, и они не поддерживаются в Visual Studio 2017 и более поздних версий. Код, который должен быть "чистым" или "безопасным", необходимо портировать на C#.

- Не следует вызывать из управляемого кода любые функции, которые обходят стек для получения сведений о параметрах (аргументы функции); уровень P/Invoke отправляет эти сведения вниз по стеку.  Например, не компилируйте прокси или заглушку с **/clr**.

- Функции компилируются в управляемый код, когда это возможно, но не все конструкции C++ можно преобразовать в управляемый код.  Это определение производится по функциям. Если какую-то часть функции невозможно преобразовать в управляемый код, вся функция преобразуется в машинный код. Следующие варианты мешают компилятору создать управляемый код.

  - Созданные компилятором преобразователи или вспомогательные функции. Собственные преобразователи создаются для всех вызовов функций через указатель функции, включая вызовы виртуальных функций.

  - Функции, которые вызывают `setjmp` или `longjmp`.

  - Функции, использующие определенные встроенные подпрограммы для управления ресурсами компьютера напрямую. Например, использование `__enable` и `__disable`, `_ReturnAddress` и `_AddressOfReturnAddress` или встроенных функций мультимедиа приводит к машинному коду.

  - Функции, которые следуют директиве `#pragma unmanaged`. (Обратите внимание, что обратное, `#pragma managed`, также поддерживается.)

  - Функция, которая содержит ссылки на выровненные типы, то есть типы, объявленные с помощью `__declspec(align(...))`.

## <a name="see-also"></a>См. также раздел

- [/clr (компиляция среды выполнения)](clr-common-language-runtime-compilation.md)
