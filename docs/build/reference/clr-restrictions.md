---
title: Ограничения /clr
ms.date: 11/04/2016
helpviewer_keywords:
- /clr compiler option [C++], restrictions
ms.assetid: 385f6462-2c68-46d6-810e-469553ead447
ms.openlocfilehash: 205345a4261f5db8eb80b3bda6e5ea55544a33d0
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50639354"
---
# <a name="clr-restrictions"></a>Ограничения /clr

Обратите внимание на следующие ограничения на использование **/CLR**:

- В структурированный обработчик исключений, существуют ограничения на использование `_alloca` при компиляции с параметром **/CLR**. Дополнительные сведения см. в разделе [_alloca](../../c-runtime-library/reference/alloca.md).

- Использование проверки ошибок во время выполнения не работает с **/CLR**. Дополнительная информация есть в статье [Практическое руководство. Настройка проверок во время выполнения машинного кода](/visualstudio/debugger/how-to-use-native-run-time-checks).

- Когда **/CLR** — используется для компиляции программы, использующей только стандартный синтаксис C++, с использованием встроенной сборке применяются следующие правила:

  - Встроенный код ассемблера, предполагает наличие знаний собственный стек макета, соглашения о вызовах за пределами текущей функции или другие низкоуровневые сведения о компьютере невозможно, если эта информация применяется кадр стека для управляемой функции. Функции, содержащие встроенный код сборки будут создаваться как неуправляемые функции, как если бы они были помещены в отдельный модуль, который был скомпилирован без **/CLR**.

  - Встроенный код ассемблера в функциях, которые передают параметры функции создан конструктором копирования не поддерживается.

- [Функции vprintf](../../c-runtime-library/vprintf-functions.md) нельзя вызывать из программы, скомпилированной с **/CLR**.

- [С атрибутом naked](../../cpp/naked-cpp.md) [__declspec](../../cpp/declspec.md) модификатор учитывается в/CLR.

- Функция-преобразователь задается [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md) будет только в перехватчиках в неуправляемом коде. См. в разделе [обработка исключений](../../windows/exception-handling-cpp-component-extensions.md) Дополнительные сведения.

- Сравнение указателей на функции не разрешено **/CLR**.

- Не разрешено использование функций, которые не являются полным прототипом **/CLR**.

- Не поддерживает следующие параметры компилятора **/CLR**:

  - **/ EHsc** и **/EHs** (**/CLR** подразумевает **/EHa** (см. в разделе [/EH (модель обработки исключений)](../../build/reference/eh-exception-handling-model.md))

  - **/ fp: strict** и **/fp: except** (см. в разделе [/fp (определение поведения с плавающей запятой)](../../build/reference/fp-specify-floating-point-behavior.md))

  - [/Zd](../../build/reference/z7-zi-zi-debug-information-format.md)

  - [/Gm](../../build/reference/gm-enable-minimal-rebuild.md)

  - [/MT](../../build/reference/md-mt-ld-use-run-time-library.md)

  - [/RTC](../../build/reference/rtc-run-time-error-checks.md)

  - [/ZI](../../build/reference/z7-zi-zi-debug-information-format.md)

- Сочетание `_STATIC_CPPLIB` определение препроцессора (`/D_STATIC_CPPLIB`) и **/CLR** параметр компилятора не поддерживается. Это происходит оттого, что определение приводит приложение для связи с статический многопоточных стандартной библиотеки C++, который не поддерживается. Дополнительные сведения см. в разделе [/MD, / MT, /LD (использование библиотеки времени выполнения)](../../build/reference/md-mt-ld-use-run-time-library.md) раздела.

- При использовании **/ZI** с **/CLR**, это влияет на производительность. Дополнительные сведения см. в разделе [/ZI](../../build/reference/z7-zi-zi-debug-information-format.md).

- Процедура передачи расширенных символов в .NET Framework выходных данных без указания [/Zc: wchar_t](../../build/reference/zc-wchar-t-wchar-t-is-native-type.md) или без приведения символ, который `__wchar_t` вызовет выходные данные отображаются в виде `unsigned short int`. Пример:

    ```cpp
    Console::WriteLine(L' ')              // Will output 32.
    Console::WriteLine((__wchar_t)L' ')   // Will output a space.
    ```

- [/ GS](../../build/reference/gs-buffer-security-check.md) игнорируется при компиляции с параметром **/CLR**, если функция не применяются `#pragma` [неуправляемых](../../preprocessor/managed-unmanaged.md) или если функция должна компилироваться в машинный код, в этом случае компилятор выдаст предупреждение C4793, которое отключено по умолчанию.

- См. в разделе [/Entry](../../build/reference/entry-entry-point-symbol.md) для требования к подписи функция управляемого приложения.

- Приложения, скомпилированные с **/OpenMP** и **/CLR** может выполняться только в процессе единственной области приложений.  См. в разделе [/OpenMP (Включение поддержки OpenMP 2.0)](../../build/reference/openmp-enable-openmp-2-0-support.md) Дополнительные сведения.

- Функции, которые принимают переменное число аргументов (varargs) будут создаваться в машинном коде. Все управляемые типы данных в позиции аргументов переменных будут маршалированы в собственные типы. Обратите внимание, что <xref:System.String?displayProperty=fullName> типы являются фактически двухбайтовые строки, но они маршалируются в однобайтовый символ строки. Поэтому если спецификатор printf %S (wchar_t *), он будет упакован в %s строка вместо.

- При использовании va_arg-макрос, можно получить непредвиденные результаты при компиляции с параметром **/CLR: pure**. Дополнительные сведения см. в разделе [va_arg, va_copy, va_end, va_start](../../c-runtime-library/reference/va-arg-va-copy-va-end-va-start.md). **/CLR: pure** и **/CLR: safe** параметры компилятора признаны устаревшими в Visual Studio 2015 и не поддерживается в Visual Studio 2017. Код, который должен быть «чистым» или «безопасных» должна быть перенесена в C#.

- Не следует вызывать, из управляемого кода, любые функции, обход стека для получения сведений о параметре (аргументы функции); на уровне P/Invoke вызывает эти сведения дальше по стеку.  Например, не компилируются прокси или заглушку с **/CLR**.

- Функции компилируются в управляемый код, когда это возможно, но не все конструкции C++ можно преобразовать в управляемый код.  Производится на основе функции, функции. Если любой части функции невозможно преобразовать в управляемый код, всей функции преобразуется в машинный код вместо этого. Следующие варианты предотвращения создания управляемого кода компилятор.

  - Созданный компилятором преобразователи и вспомогательные функции. Преобразователи в машинном коде создаются для всех вызовов функций через указатель функции, включая вызовов виртуальных функций.

  - Функции, вызывающие `setjmp` или `longjmp`.

  - Функции, использующие определенные встроенные процедуры непосредственное изменение ресурсов компьютера. Например, использование `__enable` и `__disable`, `_ReturnAddress` и `_AddressOfReturnAddress`, или встроенные функции мультимедиа будет все результирующие в машинном коде.

  - Функции ниже `#pragma unmanaged` директива. (Обратите внимание, что обратное, `#pragma managed`, также поддерживается.)

  - Функция, которая содержит ссылки на выровненных типов, то есть типы, объявленные с помощью `__declspec(align(...))`.

## <a name="see-also"></a>См. также

- [/clr (компиляция среды выполнения)](../../build/reference/clr-common-language-runtime-compilation.md)
