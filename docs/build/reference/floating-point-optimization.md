---
title: Оптимизация с плавающей запятой MSVC
ms.date: 03/09/2018
ms.topic: conceptual
ms.openlocfilehash: 78c5c310f2f348b5cfa5a92feb65e265d28560d9
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2019
ms.locfileid: "57814375"
---
# <a name="microsoft-visual-c-floating-point-optimization"></a>Microsoft Visual C++ с плавающей запятой оптимизации

Получите дескриптор на оптимизации код с плавающей запятой с помощью компилятора Microsoft C++ метод управления семантику с плавающей точкой. Создание программы быстрого гарантией того, что только безопасные оптимизации выполняются на код с плавающей запятой.

## <a name="optimization-of-floating-point-code-in-c"></a>Оптимизация кода с плавающей запятой в C++

Оптимизирующий компилятор C++ не только преобразует исходный код в машинный код, он размещает инструкциям таким образом, повысить эффективность и/или сократить размер машины. К сожалению многие распространенные методы оптимизации не всегда безопасно при применении к вычислений с плавающей запятой. Хорошим примером этого может отображаться с помощью следующего алгоритма суммирование, взятое из Песоцкий Дэвид, «Что каждый компьютер по обработке и анализу следует знать о арифметики с плавающей запятой», *вычислений опросы*, 1991 марта, стр. 203:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0, C=0, Y, T;
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = T;
   }
   return sum;
}
```

Эта функция добавляет n **float** значения в векторе массива `A`. В теле цикла алгоритм вычисляет значение «исправления», который применяется к следующему шагу суммирования. Этот метод значительно снижает совокупное ошибки округления, по сравнению с простой суммирование, при этом сохраняя O(n) временная сложность.

Компилятор C++ упрощенный предположить, что арифметических операций с плавающей запятой следует те же правила алгебры арифметические вещественное число. Таким компилятором может ошибочно заключить, что

> C = T - sum - Y ==> (sum+Y)-sum-Y ==> 0;

То есть значение машинного C, всегда константу, равную нулю. Если это постоянное значение затем передается в последующих выражений, тело цикла уменьшается до простой совокупность. Точнее,

> Y = A[i] - C ==> Y = A[i]<br/>T = sum + Y ==> T = sum + A[i]<br/>sum = T ==> sum = sum + A[i]

Таким образом, компилятору упрощенный, логические преобразования `KahanSum` функция могла бы:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0; // C, Y & T are now unused
   for (int i=0; i<n; i++)
      sum = sum + A[i];
   return sum;
}
```

Несмотря на то, что преобразованные алгоритм выполняется быстрее, *– совсем не точное представление намерения программиста*. Исправление тщательно созданных ошибок был полностью удален, и нас остается с алгоритмом суммирование простой, непосредственно с его связанной ошибкой.

Само собой сложные компилятор C++ будет знать, что алгебраические правил типа Real арифметических операций не применимы преимущественно к арифметических операций с плавающей запятой. Тем не менее даже сложные компилятор C++ может по-прежнему неправильно интерпретировать намерения программиста.

Рассмотрим обычно для оптимизации, которые содержат столько значения в регистры максимально (вызываемый «регистре» значение). В `KahanSum` примере, эта оптимизация может быть предпринята попытка регистрах переменные `C`, `Y` и `T` так, как они используются только в теле цикла. Если точность register 52bits (double) вместо 23bits (одно), эта оптимизация эффективно тип способствует `C`, `Y` и `T` ввода **двойные**. Если переменную суммы не аналогично регистрации, он останется кодировкой одиночной точности. Этот алгоритм преобразует семантику `KahanSum` следующим

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0;
   double C=0, Y, T; // now held in-register
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = (float) T;
   }
   return sum;
}
```

Несмотря на то что `Y`, `T` и `C` теперь вычисляются на более высокая точность, новая кодировка может привести к неточностям результат, в зависимости от значения в `A[]`. Таким образом даже внешне безвредным оптимизации могут иметь негативные последствия.

Оптимизация проблемы такого рода не ограничено только «непростой задачей» код с плавающей запятой. Даже простые алгоритмы с плавающей запятой может завершиться ошибкой при оптимизации неправильно. Рассмотрим простой и суммирование direct алгоритма:

```cpp
float Sum( const float A[], int n )
{
   float sum=0;
   for (int i=0; i<n; i++)
      sum = sum + A[i];
   return sum;
}
```

Поскольку некоторые устройства с плавающей запятой может одновременно выполнять несколько операций, компилятор может потребоваться привлечь оптимизации скалярная редукция. Эта оптимизация эффективно преобразует простой функции Sum выше на следующие:

```cpp
float Sum( const float A[], int n )
{
   int n4 = n-n%4; // or n4=n4&(~3)
   int i;
   float sum=0, sum1=0, sum2=0, sum3=0;
   for (i=0; i<n4; i+=4)
   {
      sum = sum + A[i];
      sum1 = sum1 + A[i+1];
      sum2 = sum2 + A[i+2];
      sum3 = sum3 + A[i+3];
   }
   sum = sum + sum1 + sum2 + sum3;
   for (; i<n; i++)
      sum = sum + A[i];
   return sum;
}
```

Функция теперь поддерживает четыре отдельных суммированием, которые могут обрабатываться параллельно на каждом этапе. Несмотря на то, что оптимизированной функции, теперь намного быстрее, оптимизированные результаты может быть значительно отличается от неоптимизированных результаты. В это изменение компилятор предполагается, что ассоциативные сложения с плавающей запятой; то есть что эти два выражения являются эквивалентными: `(a + b) + c == a + (b + c)`. Тем не менее ассоциативность не всегда является верным для чисел с плавающей запятой. Вместо вычисления суммирования как:

```cpp
sum = A[0]+A[1]+A[2]+...+A[n-1];
```

функция преобразованные теперь вычисляет результат в виде

```cpp
sum = (A[0]+A[4]+A[8]+...)
    + (A[1]+A[5]+A[9]+...)
    + (A[2]+A[6]+A[10]+...)
    + (A[3]+A[7]+A[11]+...);
```

Для некоторых значений `A[]`, этот другой порядок операций сложения может привести к непредвиденным результатам. Для дальнейшей усложним дело, некоторые программисты можно предвидеть такая оптимизация и компенсировать их соответствующим образом. В этом случае программы можно создать массив `A` в другом порядке, чтобы оптимизированного суммы выдает ожидаемые результаты. Кроме того во многих случаях точность оптимизированного результат может быть «достаточно близко». Это особенно важно в тех случаях, когда оптимизация обеспечивает привлекательных преимущества скорости. Видеоигр, например, требуется как значительно ускорить максимально, но часто не требуют очень точный результат вычислений с плавающей запятой. За принятие компилятора таким образом необходимо предоставить механизм для программистов для управления часто разрозненных цели скорости и точности.

Некоторые компиляторы разрешить компромисса между скоростью и точностью, предоставляя отдельный параметр для каждого типа оптимизации. Это позволяет разработчикам отключить оптимизацию, которые вызывают изменения в точности с плавающей запятой для своего конкретного приложения. Хотя это решение может предлагать высокую степень контроля над компилятор, он предоставляет несколько дополнительных проблем:

- Неясно, часто которого переключается для включения или отключения.
- Отключение любой единый оптимизации могут отрицательно повлиять на производительность код не с плавающей запятой.
- Каждый дополнительный параметр влечет за собой множество новых комбинаций; количество сочетаний быстро становится громоздким.

Таким образом предоставляя отдельными коммутаторами для каждого оптимизации может показаться привлекательным, с помощью таких компиляторов может быть громоздким и ненадежным.

Большинство компиляторов C++ предлагают *согласованности* модель с плавающей запятой, (через **/op** или **/fltconsistency** переключаться) который позволяет разработчикам создавать программы с с помощью строгую семантику с плавающей запятой. Когда задействованы, эта модель запрещает использовать большинство видов оптимизации в вычислениях с плавающей запятой предоставляя распространения параметров оптимизации для кода не число с плавающей запятой компилятор. Модель согласованности, однако имеет темный стороне. Для получения прогнозируемых результатов в разных архитектурах FPU, почти все реализации **/op** round промежуточных выражений для пользователя, указанной точности; например, рассмотрим следующее выражение:

```cpp
float a, b, c, d, e;
// . . .
a = b * c + d * e;
```

Чтобы создать согласованный и воспроизводимой результат в разделе **/op**, это выражение вычисляется, как если бы было реализовано следующим образом:

```cpp
float x = b  *c;
float y = d * e;
a = x + y;
```

Окончательный результат теперь страдает от одиночной точности, округления *на каждом этапе в вычислении выражения*. Несмотря на то, что эту интерпретацию не будет прерывать выполнение строго какие-либо семантики правила C++, это практически никогда не лучший способ оценки выражений с плавающей запятой. Это обычно гораздо полезнее, для вычисления промежуточных результатов в максимально точности, насколько это возможно. Например, было бы лучше вычислить значение выражения `a = b * c + d * e` в более высокая точность, как показано на

```cpp
double x = b * c;
double y = d * e;
double z = x + y;
a = (float)z;
```

или что еще лучше

```cpp
long double x = b * c;
long double y = d * e
long double z = x + y;
a = (float)z;
```

При вычислении промежуточные результаты в более высокая точность, конечным результатом является значительно более точным. Иронии используя модель согласованности, вероятность возникновения ошибок увеличивается, точно в том случае, когда пользователь пытается уменьшить ошибки путем отключения оптимизаций unsafe. Таким образом модель согласованности может серьезно снизить эффективность одновременно позволяет добавиться не гарантируется повышения точности. Для серьезных программистов, числовой не показаться очень хороший компромисс и является основной причиной, что модель не обычно благоприятный прием.

Начиная с версии 8.0 (Visual C++® 2005), Microsoft C++ компилятор предоставляет гораздо лучшим вариантом. Она позволяет программистам выбрать один из трех режимов общие с плавающей запятой: fp: precise, fp: FAST и fp: strict.

- В разделе fp: precise, только безопасные оптимизации выполняются на код с плавающей запятой и, в отличие от **/op**, постоянно промежуточных вычисления выполняются с наивысшим практические точностью.
- режим fp: fast снижает правила с плавающей запятой, что обеспечивает более интенсивный способ оптимизации за счет точности.
- fp: строгий режим предоставляет все общие правильность fp: точное при Включение семантику fp исключения и предотвращение недопустимых преобразования при наличии изменений в среде Выполнения (например, изменения до регистра точности, округления направление и т.д.).

Семантика исключения с плавающей запятой можно управлять независимо друг от друга с помощью параметра командной строки или директивы pragma компилятора; по умолчанию отключены семантику исключения с плавающей запятой в разделе fp: точные и включены в разделе fp: strict. Компилятор также позволяет управлять чувствительность к среде Выполнения и некоторые с плавающей запятой определенные оптимизации, такие как сокращения. Эта модель последовательных дает разработчикам высокую степень контроля над компиляции кода с плавающей запятой без нагрузку слишком много параметров компилятора или Перспектива нежелательные побочные эффекты.

## <a name="the-fpprecise-mode-for-floating-point-semantics"></a>Fp: режиме для семантику с плавающей точкой

Режим семантику с плавающей запятой по умолчанию — fp: точным. Если выбран этот режим, компилятор строго соответствует набор правил безопасности при оптимизации операций с плавающей запятой. Эти правила позволяют компилятору создавать эффективный машинный код, сохраняя точность вычислений с плавающей запятой. Для упрощения производства fast программы — fp: точная модель отключает семантику исключения с плавающей запятой (несмотря на то, что они могут быть явно включены). Корпорацией Майкрософт были отобраны fp: точностью, как режим с плавающей запятой по умолчанию, так как он создает быструю и точную программы.

В явной форме запросить fp: режиме с помощью компилятора командной строки, используйте [/fp: точное](fp-specify-floating-point-behavior.md) переключения:

> CL/fp: точное source.cpp

Это указывает компилятору на необходимость использовать fp: семантику, при создании кода для файла source.cpp. Fp: точная модель также может быть вызван для отдельных функций, функции с помощью [float_control-прагма компилятора](#the-float-control-pragma).

В разделе fp: режиме, компилятор никогда не выполняет все оптимизации, повлиять на точность вычислений с плавающей запятой. Компилятор правильно всегда округляет в назначения, приведении типов и вызовы функций и промежуточные округления будет постоянно выполняться на такую же точность как регистрирует FPU. Безопасные оптимизации, такие как сокращения, включены по умолчанию. Семантику исключения и чувствительности среды FPU отключены по умолчанию.

|fp: семантику|Объяснение|
|-|-|
|Семантики округления|Явные округление в назначения, приведении типов и вызывает функцию. Промежуточных выражений будет вычисляться в точности регистра.|
|Алгебраические преобразования|Строгое соответствие не ассоциативность, отличных от дистрибутивности алгебры с плавающей запятой, если преобразование гарантированно всегда дают одинаковые результаты.|
|Сокращения|Разрешено по умолчанию. Дополнительные сведения см. раздел [fp_contract-прагма](#the-fp-contract-pragma).|
|Порядок вычисления с плавающей запятой|Компилятор может изменить порядок вычисления выражений с плавающей запятой, при условии, что окончательные результаты, не изменяются.|
|Доступ к сопроцессору FPU|По умолчанию отключено. Дополнительные сведения см. раздел [fenv_access-прагма](#the-fenv-access-pragma). Точность по умолчанию и режим округления предполагается, что.|
|Семантика исключения с плавающей запятой|По умолчанию отключено. Дополнительные сведения см. в разделе [/fp: except](fp-specify-floating-point-behavior.md).|

### <a name="rounding-semantics-for-floating-point-expressions-under-fpprecise"></a>Округление семантику для выражений с плавающей запятой в разделе fp: точное

Fp: точная модель всегда выполняет промежуточных вычислений с наивысшим практические точностью, явно округления только в определенные моменты в вычисление выражений. Округление с пользовательской точностью всегда выполняется в четырех местах: (a) при назначении, (б), если выполняется приведение типа, (c) когда значение с плавающей запятой передается как аргумент для функции и (d) когда возвращается значение с плавающей запятой из функция. Так как промежуточный вычисления всегда выполняются с точностью register, точность промежуточных результатов зависит платформы (то, что точность всегда будет по крайней мере так точна, как пользователь, указанный точности).

Рассмотрим выражение присваивания в следующем коде. Выражения в правой части назначения оператор «=» будет вычислена в точности register, а затем явно округляется до типа в левой части назначения.

```cpp
float a, b, c, d;
double x;
...
x = a*b + c*d;
```

вычисляется как

```cpp
float a, b, c, d;
double x;
...
register tmp1 = a*b;
register tmp2 = c*d;
register tmp3 = tmp1+tmp2;
x = (double) tmp3;
```

Чтобы явным образом выполнять округление промежуточный результат, вводят приведение типа. Например, если приведенный выше код изменяется путем добавления явное приведение типа, промежуточного выражения (c * d) округляется до типа приведение типа.

```cpp
float a, b, c, d;
double x;
// . . .
x = a*b + (float)(c*d);
```

вычисляется как

```cpp
float a, b, c, d;
double x;
// . . .
register tmp1 = a*b;
float tmp2 = c*d;
register tmp3 = tmp1+tmp2;
x = (double) tmp3;
```

Один из этого метода округления подразумевается, что некоторые кажущиеся эквивалентное преобразования в действительности не имеют идентичные семантику. Например следующее преобразование разделяет одного выражения присваивания в два выражения присваивания.

```cpp
float a, b, c, d;
// . . .
a = b*(c+d);
```

не эквивалентно

```cpp
float a, b, c, d;
// . . .
a = c+d;
a = b*a;
```

Аналогичным образом:

```cpp
a = b*(c+d);
```

не эквивалентно

```cpp
a = b*(a=c+d);
```

Эти кодировки не имеет одинаковой семантикой, поскольку второй кодировки каждого представили операции дополнительное назначение, а также таким образом точке дополнительных округления.

Если функция возвращает значение с плавающей запятой, значение будет округляться до типа функции. Когда значение с плавающей запятой передается как параметр функции, значение будет округляться до типа параметра. Пример:

```cpp
float sumsqr(float a, float b)
{
   return a*a + b*b;
}
```

вычисляется как

```cpp
float sumsqr(float a, float b)
{
    register tmp3 = a*a;
    register tmp4 = b*b;
    register tmp5 = tmp3+tmp4;
    return (float) tmp5;
}
```

Аналогичным образом:

```cpp
float w, x, y, z;
double c;
...
c = symsqr(w*x+y, z);
```

вычисляется как

```cpp
float x, y, z;
double c;
...
register tmp1 = w*x;
register tmp2 = tmp1+y;
float tmp3 = tmp2;
c = symsqr( tmp3, z);
```

### <a name="architecture-specific-rounding-under-fpprecise"></a>Округление конкретной архитектуры в разделе fp: точное

|Процессор|Точность для промежуточных выражений округления|
|-|-|
|x86|Промежуточные выражения вычисляются на точность 53 бита по умолчанию с расширенный диапазон, предоставляемые 16-разрядную экспоненту. Если эти значения 53:16, «сбрасываются» к памяти (как это может произойти во время вызова функции), будут сведены расширенный диапазон экспоненты до 11-бит. То есть временно записанных значения приводятся к типу формат стандартный двойной точности с только 11-разрядную экспоненту.<br/>Пользователь может переключиться в расширенный 64-битной точности, округления промежуточных путем изменения слово с плавающей точкой управления с помощью `_controlfp` и разрешив доступ к сопроцессору FPU (см. в разделе [fenv_access-прагма](#the-fenv-access-pragma)). Тем не менее когда значения регистров повышения точности, сбрасываются на область памяти, промежуточные результаты по-прежнему быть округленное до двойной точности.<br/>Данный конкретный семантической подлежит изменению.|
|amd64|Семантика FP на amd64, немного отличаются от других платформ. Для повышения производительности промежуточные операции вычисляются на широкой точность один из операндов, а не на широкой точность, предусмотренную.  Для принудительного вычисления нужно вычислить с помощью более широкой точность, чем операндов, пользователям необходимо представить на хотя бы один операнд в выражении вложенные операции приведения.<br/>Данный конкретный семантической подлежит изменению.|

### <a name="algebraic-transformations-under-fpprecise"></a>Алгебраические преобразования в разделе fp: точное

Когда fp: режиме включен, компилятор никогда не будет выполнять алгебраические преобразования *если конечным результатом является, вероятно идентичных*. Многие знакомы алгебраические правила вещественное число арифметические всегда не содержат при выполнении арифметических операций с плавающей запятой. Например, следующие выражения являются эквивалентными Reals, но не обязательно для числа с плавающей запятой.

|Form|Описание|
|-|-|
|`(a+b)+c = a+(b+c)`|Ассоциативные правила для добавления|
|`(a*b)*c = a*(b*c)`|Ассоциативные правила для умножения|
|`a*(b+c) = a*b + b*c`|Распределение умножения над сложением|
|`(a+b)(a-b) = a*a-b*b`|Алгебраические факторинг|
|`a/b = a*(1/b)`|Деление на обратную величину|
|`a*1.0 = a`|Мультипликативный идентификатор|

Как показано в примере Знакомство с функцией `KahanSum`, компилятор может не поддавайтесь искушению выполнять различные алгебраические преобразования для создания программ значительно быстрее. Несмотря на то, что зависит от таких алгебраические преобразования оптимизации почти всегда являются неправильными, существуют случаи, для которых они безопасны идеально. Например, иногда рекомендуется заменить деление *константы* значение с умножением умножения обратное-константы:

```cpp
const double four = 4.0;
double a, b;
...

a = b/four;
```

Могут быть преобразованы в

```cpp
const double four = 4.0;
const double tmp0 = 1/4.0;
double a, b;
...
a = b*tmp0;
```

Это безопасный преобразования, поскольку оптимизатор может определить во время компиляции, x / 4.0 == x*(1/4.0) для всех значений с плавающей запятой из x, включая бесконечности и NaN. Заменив операции деления с умножения, компилятор можно сохранить несколько циклов, особенно на FPUs, которые не реализуют непосредственно деления, но требуется компилятор создает сочетание приближения обратная величина и multiply add инструкции. Компилятор может выполнить такую оптимизацию под fp: точным только в том случае, если замена умножения получается полностью же результат, что деления. Компилятор также могут выполнять тривиальные преобразования, в разделе fp: precise, предоставляемых результаты идентичны. К ним относятся следующие методы.

|Form|Описание
|-|-|
|`(a+b) == (b+a)`|Коммутативной правило для добавления|
|`(a*b) == (b*a)`|Коммутативной правило для умножения|
|`1.0*x*y == x*1.0*y == x*y*1.0 == x*y`|Умножение 1.0|
|`x/1.0*y == x*y/1.0 == x*y`|Деление 1.0|
|`2.0*x == x+x`|Умножение на 2.0|

### <a name="contractions-under-fpprecise"></a>Сокращения в разделе fp: точное

Ключевой особенностью архитектуры множество современных единиц с плавающей запятой является возможность выполнения операций умножения, следуют дополнения в одну операцию без промежуточных ошибок округления. К примеру, архитектуру Intel Itanium инструкции для каждой из этих троичный операций объединения (*b + c), (* b + c) и (c-a * b), в одной инструкции с плавающей запятой (fma, fms и fnma соответственно). Этих инструкций с одинарной быстрее, чем выполнение отдельных умножения и добавьте инструкции, а являются более точные, так как не производится никакого округления промежуточных продукта. Эта оптимизация может значительно ускорить работу функции, содержащий ряд с чередованием multiply и добавление операций. Например рассмотрим следующий алгоритм, который вычисляет скалярное произведение двух векторов многомерный.

```cpp
float dotProduct( float x[], float y[], int n )
{
   float p=0.0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}
```

Это вычисление можно выполнить ряд "умножить" добавьте инструкции в формате p = p + x [i] * y [i].

Оптимизации сокращения может управляться независимо друг от друга с помощью `fp_contract` pragma компилятора. По умолчанию fp: точная модель позволяет для сокращения, так как они повышают точность и скорость. В разделе fp: precise, компилятор никогда не буду выражение с явной округления.
Примеры

```cpp
float a, b, c, d, e, t;
...
d = a*b + c;         // may be contracted
d += a*b;            // may be contracted
d = a*b + e*d;       // may be contracted into a mult followed by a mult-add
etc...

d = (float)a*b + c;  // won't be contracted because of explicit rounding

t = a*b;             // (this assignment rounds a*b to float)
d = t + c;           // won't be contracted because of rounding of a*b
```

### <a name="order-of-floating-point-expression-evaluation-under-fpprecise"></a>Порядок вычисления выражений с плавающей запятой в разделе fp: точное

Оптимизации, которые сохраняет порядок вычисления выражений с плавающей запятой всегда являются безопасными и поэтому допускаемые fp: режиме. Рассмотрим следующую функцию, которая вычисляет скалярное произведение двух векторов n мерный в одиночной точности. Первый блок кода ниже исходной функции как его можно закодировать, программист, следует той же функции после частичной оптимизации каналов.

```cpp
//original function
float dotProduct( float x[], float y[], int n )
{
   float p=0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}

//after a partial loop-unrolling
float dotProduct( float x[], float y[], int n )
{
   int n4= n/4*4; // or n4=n&(~3);
   float p=0;
   int i;

   for (i=0; i<n4; i+=4)
   {
      p+=x[i]*y[i];
      p+=x[i+1]*y[i+1];
      p+=x[i+2]*y[i+2];
      p+=x[i+3]*y[i+3];
   }

   // last n%4 elements
   for (; i<n; i++)
      p+=x[i]*y[i];

   return p;
}
```

Такая оптимизация полезна уменьшается число условного ветвления цикла по 75%. Кроме того увеличив количество операций в теле цикла, компилятор теперь может имеет больше возможностей для дальнейшей оптимизации. Например, некоторые FPUs может иметь возможность выполнять multiply add += p x [i] * y [i] при одновременно выборке значения x [i + 1] и y [i + 1] для использования на следующем шаге. Такая оптимизация вполне безопасен для вычислений с плавающей запятой, так как он сохраняет порядок операций.

Часто бывает выгодно для компилятора для изменения порядка всей операции, чтобы создать более быстрый код. Рассмотрим следующий код.

```cpp
double a, b, c, d;
double x, y, z;
...
x = a*a*a + b*b*b + c*c*c;
...
y = a*a + b*b + c*c;
...
z = a + b + c;
```

Семантические правила C++ указывают, что программа должен создать результаты, как если бы ее сначала вычислить x, а затем y и наконец z. Предположим, что у компилятора есть только четыре доступных регистров с плавающей запятой. Если компилятору предписывается для вычисления x, y и z в порядке, она может выбрать для создания кода с помощью следующей семантикой:

```cpp
double a, b, c, d;
double x, y, z;
register r0, r1, r2, r3;
...
// Compute x
r0 = a;         // r1 = a*a*a
r1 = r0*r0;
r1 = r1*r0;
r0 = b;         // r2 = b*b*b
r2 = r0*r0;
r2 = r2*r0;
r0 = c;         // r3 = c*c*c
r3 = r0*r0;
r3 = r3*r0;
r0 = r1 + r2;
r0 = r0 + r3;
x = r0;         // x = r1+r2+r3
// . . .
// Compute y
r0 = a;         // r1 = a*a
r1 = r0*r0;
r0 = b;         // r2 = b*b
r2 = r0*r0;
r0 = c;         // r3 = c*c
r3 = r0*r0;
r0 = r1 + r2;
r0 = r0 + r3;
y = r0;         // y = r1+r2+r3
// . . .
// Compute z
r1 = a;
r2 = b;
r3 = c;
r0 = r1 + r2;
r0 = r0 + r3;
z = r0;         // z = r1+r2+r3
```

Есть несколько четко избыточные операции этой кодировки. Если компилятор строго соответствует семантические правила C++, этот порядок не требуется потому, что программа может получить доступ к среде FPU между каждого назначения. Тем не менее значения по умолчанию для fp: точное разрешить компилятору оптимизировать, как если бы, если программа не обращается к среде, что позволяет изменить порядок этих выражений. Затем это бесплатно для удаления избыточных данных путем вычисления три значения в обратном порядке, как показано ниже:

```cpp
double a, b, c, d;
double x, y, z;
register r0, r1, r2, r3;
...
// Compute z
r1 = a;
r2 = b;
r3 = c;
r0 = r1+r2;
r0 = r0+r3;
z = r0;
...
// Compute y
r1 = r1*r1;
r2 = r2*r2;
r3 = r3*r3;
r0 = r1+r2;
r0 = r0+r3;
y = r0;
...
// Compute x
r0 = a;
r1 = r1*r0;
r0 = b;
r2 = r2*r0;
r0 = c;
r3 = r3*r0;
r0 = r1+r2;
r0 = r0+r3;
x = r0;
```

Эта кодировка предпочтителен очевидно, уменьшено почти 40% количество инструкций,-fp. Результаты для x, y и z одинаковы как и раньше, но вычисляется с меньшими издержками.

В разделе fp: precise, компилятор может также *чередования* общих вложенных выражений, таким образом, чтобы создать более быстрый код. Например код для вычисления этих корней квадратного уравнения может быть написан следующим образом:

```cpp
double a, b, c, root0, root1;
...
root0 = (-b + sqrt(b*b-4*a*c))/(2*a);
root1 = (-b - sqrt(b*b-4*a*c))/(2*a);
```

Несмотря на то, что эти выражения отличаются только по одной операции, программист написал его таким образом, чтобы гарантировать, что каждое значение корневого повторное вычисление наивысший практические точности. В разделе fp: precise, компилятор может свободно чередования вычисления root0 и root1 для удаления общих вложенных выражений без потери точности. К примеру следующие было удалено несколько лишние шаги при этом точное одинаковый результат.

```cpp
double a, b, c, root0, root1;
...
register tmp0 = -b;
register tmp1 = sqrt(b*b-4*a*c);
register tmp2 = 2*a;
root0 = (tmp0+tmp1)/tmp2;
root1 = (tmp0-tmp1)/tmp2;
```

Другие виды оптимизации могут попытаться переместить вычисления определенных независимых выражений. Рассмотрим следующий алгоритм, который содержит условное ветвь в тело цикла.

```cpp
vector<double> a(n);
double d, s;
// . . .
for (int i=0; i<n; i++)
{
   if (abs(d)>1.0)
      s = s+a[i]/d;
   else
      s = s+a[i]*d;
}
```

Компилятор может обнаружить, значение выражения (abs(d) > 1) является инвариантным в теле цикла. Это позволяет компилятору «вернуть» if инструкции вне тела цикла, преобразование приведенный выше код на следующие:

```cpp
vector<double> a(n);
double d, s;
// . . .
if (abs(d)>1.0)
   for (int i=0; i<n; i++)
      s = s+a[i]/d;
else
   for (int i=0; i<n; i++)
      s = s+a[i]*d;
```

После преобразования больше не Условная ветвь в любом из тел циклов, что значительно повышает общую производительность цикла. Вполне безопасен этот тип оптимизации, так как определения значения выражения (abs(d) > 1.0) не зависит от других выражений.

При наличии доступ к сопроцессору FPU или исключения с плавающей запятой такого рода оптимизации являются contraindicated, так как они изменяют семантической поток. Такая оптимизация доступны только в разделе fp: режиме потому, что доступ к сопроцессору FPU и семантику исключения с плавающей запятой отключены по умолчанию. Функции, которые обращаются к среде Выполнения можно явно отключить такую оптимизацию с помощью `fenv_access` pragma компилятора. Аналогичным образом, следует использовать функции с помощью исключений с плавающей запятой `float_control(except ... )` pragma компилятора (или использовать **/fp: except** параметр командной строки).

Таким образом, fp: режиме позволяет компилятору изменить порядок вычисления выражений с плавающей запятой, при условии, что окончательные результаты, не изменяются и что результаты не зависимых от среды Выполнения или исключений с плавающей запятой.

### <a name="fpu-environment-access-under-fpprecise"></a>Доступ к сопроцессору FPU в разделе fp: точное

Когда fp: режиме включен, компилятор предполагает, что программы с ними изменения среды Выполнения. Как уже говорилось ранее, это предположение обеспечивает компилятору возможность изменения порядка или перемещения операций с плавающей запятой для повышения эффективности в группе fp: точным.

Некоторые программы могут изменяться с плавающей запятой округления оси с помощью `_controlfp` функции. Например некоторые программы вычисления верхней и нижней границы ошибки на арифметические операции, выполняя вычисления же дважды, сначала при округление в сторону отрицательной бесконечности, затем а округление в сторону положительной бесконечности. Поскольку FPU предоставляет удобный способ округления, программист может потребоваться изменить режим округления путем изменения среды Выполнения. Следующий код вычисляет точное ошибка граница умножения с плавающей запятой путем изменения среды Выполнения.

```cpp
double a, b, cLower, cUpper;
// . . .
_controlfp( _RC_DOWN, _MCW_RC );    // round to -&infin;
cLower = a*b;
_controlfp( _RC_UP, _MCW_RC );    // round to +&infin;
cUpper = a*b;
_controlfp( _RC_NEAR, _MCW_RC );    // restore rounding mode
```

В разделе fp: precise, компилятор всегда предполагает FPU среды по умолчанию, поэтому оптимизатор будет игнорировать вызовы `_controlfp` и сократить выше назначения, которые cUpper = cLower = * b; это очевидно, что были бы получены неверные результаты. Чтобы предотвратить такую оптимизацию, необходимо включить доступ к сопроцессору FPU с помощью `fenv_access` pragma компилятора.

Другие программы могут попытаться обнаружить определенные ошибки, с плавающей запятой, проверив слова FPU состояния. Например следующий код проверяет условия деления на ноль и неточный

```cpp
double a, b, c, r;
float x;
// . . .
_clearfp();
r = (a*b + sqrt(b*b-4*a*c))/(2*a);
if (_statusfp() & _SW_ZERODIVIDE)
   handle divide by zero as a special case
_clearfp();
x = r;
if (_statusfp() & _SW_INEXACT)
   handle inexact error as a special case
etc...
```

В разделе fp: precise, оптимизаций, изменяющих порядок вычисления выражений может измениться точек, в которых возникновении определенных ошибок. Программы, доступ к слова состояния следует включить доступ к сопроцессору FPU с помощью `fenv_access` pragma компилятора.

Дополнительные сведения см. раздел [fenv_access-прагма](#the-fenv-access-pragma).

### <a name="floating-point-exception-semantics-under-fpprecise"></a>Семантика исключения с плавающей запятой в разделе fp: точное

По умолчанию отключены семантику исключения с плавающей запятой в разделе fp: точным. Большинство программистов C++ предпочитают обработать исключительные условия с плавающей запятой без использования системы или исключения C++. Кроме того как уже говорилось ранее, отключение семантику исключения с плавающей запятой позволяет компилятора гибкость при оптимизации операций с плавающей запятой. Использовать **/fp: за исключением** переключения или `float_control` директиву pragma, чтобы включить семантику исключения с плавающей запятой, при использовании fp: точная модель.

Дополнительные сведения см. раздел [Включение семантику исключения с плавающей запятой](#enabling-floating-point-exception-semantics).

## <a name="the-fpfast-mode-for-floating-point-semantics"></a>Режим fp: fast семантику с плавающей точкой

При включении режима fp: FAST, компилятор снижает правила виде этот fp: точное использует при оптимизации операций с плавающей запятой. Этот режим используется позволяет компилятору оптимизировать код с плавающей запятой для повышения быстродействия за счет точности с плавающей запятой и правильности. Программы, которые не следует полагаться на очень точный результат вычислений с плавающей запятой могут возникнуть значительные быстродействия, включив режим fp: FAST.

Режим с плавающей запятой fp: fast включается с помощью [/fp:fast](fp-specify-floating-point-behavior.md) параметр компилятора командной строки следующим образом:

> cl /fp:fast source.cpp

В этом примере предписывает компилятору использовать семантику fp: fast при создании кода для файла source.cpp. Fp: fast модели также может быть вызван для отдельных функций, функции с помощью `float_control` pragma компилятора.

Дополнительные сведения см. раздел [float_control-прагма](#the-float-control-pragma).

В режиме fp: fast компилятор может выполнить оптимизаций, изменяющих точность вычислений с плавающей запятой. Компилятор не может правильно округлять в назначения, приведении типов или вызовы функций и промежуточные округления не всегда будет выполняться. С плавающей запятой оптимизировать код, например сокращения, всегда включены. Семантика исключения с плавающей запятой и чувствительности среды FPU отключены и недоступны.

|семантика fp: fast|Объяснение
|-|-|
|Семантики округления|Явные округление в назначения, приведении типов и вызовы функций могут игнорироваться.<br/>Промежуточных выражений может округляться в меньше, чем регистрация точности в соответствии с требованиями к производительности.|
|Алгебраические преобразования|Компилятор может преобразовать выражения, в соответствии с вещественное число ассоциативный дистрибутивности алгебраических; Эти преобразования не обязательно быть точным или правильный.|
|Сокращения|Всегда включена; Невозможно отключить, директивы pragma `fp_contract`|
|Порядок вычисления с плавающей запятой|Компилятор может изменить порядок вычисления выражений с плавающей запятой, даже в том случае, если такие изменения могут изменяться окончательные результаты.|
|Доступ к сопроцессору FPU|Отключено. Недоступно|
|Семантика исключения с плавающей запятой|Отключено. Недоступно|

### <a name="rounding-semantics-for-floating-point-expressions-under-fpfast"></a>Округление семантику для выражений с плавающей запятой в разделе fp: fast

В отличие от fp: точная модель, модель fp: fast выполняет промежуточных вычислений в самое подходящее точности. Округление в назначения, приведении типов и вызовы функций может не произойти. Например, первая функция ниже впервые представлены три переменные одинарной точности (`C`, `Y` и `T`). Компилятор может выбрать регистрах эти переменные, фактически повышение типа `C`, `Y` и `T` для двойной точности.

Исходную функцию:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0, C=0, Y, T;
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = T;
   }
   return sum;
}
```

Незарегистрированные переменные:

```cpp
float KahanSum( const float A[], int n )
{
   float sum=0;
   double C=0, Y, T; // now held in-register
   for (int i=0; i<n; i++)
   {
      Y = A[i] - C;
      T = sum + Y;
      C = T - sum - Y;
      sum = (float) T;
   }
   return sum;
}
```

В этом примере fp: fast subverted цель исходной функции. Конечный результат, содержащееся в переменной оптимизированных для операций `sum`, может быть довольно perturbed из правильный результат.

В разделе fp: fast компилятор будет пытаться обычно поддерживать по крайней мере точности, заданной параметром исходный код. Однако в некоторых случаях компилятор может выбрать для выполнения промежуточных выражений в *снизить точность* чем указано в исходном коде. Например первый блок кода ниже вызывает двойной точности версию функция квадратного корня. В разделе fp: FAST, в некоторых случаях, например когда результата и операндов функции явно приведен к одиночной точности, компилятор может выбрать замените вызов двойной точности `sqrt` с помощью вызова с точностью до одной `sqrtf`функции. Поскольку приведения убедитесь, что значения, передаваемые в `sqrt` и значение, выдаваемое округляются до одинарной точности, округления место меняется только. Если значение, поступающих на sqrt было значение двойной точности, и компилятор выполнить это преобразование, как половина битов точности может быть проблема.

Исходную функцию

```cpp
double sqrt(double);
// . . .
double a, b, c;
float f1, f2;
// . . .
float length = (float)sqrt((float)(a*a + b*b + c*c));
float sum = (float) ((double)f1 + (double)f2);
```

Оптимизированная функция

```cpp
float sqrtf(float)...
// . . .
double a, b, c;
float f1, f2;
// . . .
double tmp0 = a*a + b*b + c*c;
float tmp1 = tmp0;    // round of parameter value
float length = sqrtf(tmp1); // rounded sqrt result
float sum = f1 + f2;
```

Несмотря на то что менее точными, эта оптимизация может быть особенно полезным при нацеливании на процессоры, которые предоставляют одиночной точности, внутренние версии функций, таких как `sqrt`. Точно так же при компилятор будет использовать такую оптимизацию зависит платформы и контекст.

Кроме того нет отсутствует гарантированную согласованность для точность промежуточных вычислений, которые могут выполняться на любом уровне точности, доступных для компилятора. Несмотря на то, что компилятор попытается поддерживать по крайней мере уровень точности, как указано в коде, fp: fast позволяет оптимизатору нисходящее приведение типа промежуточных вычислений при формировании машинный код меньшего размера или быстрее. Например компилятор может дополнительно оптимизировать код выше округляемое некоторые промежуточные операции умножения до одинарной точности.

```cpp
float sqrtf(float)...
// . . .
double a, b, c;
float f1, f2;
// . . .
float tmp0 = a*a;     // round intermediate a*a to single-precision
float tmp1 = b*b;     // round intermediate b*b to single-precision
double tmp2 = c*c;    // do NOT round intermediate c*c to single-precision
float tmp3 = tmp0 + tmp1 + tmp2;
float length = sqrtf(tmp3);
float sum = f1 + f2;
```

Этот способ округления дополнительных может результатом его использования на меньшие точности с плавающей запятой единицы, например SSE2, для выполнения некоторых промежуточные результаты вычислений. Точность округления fp: fast определяется таким образом платформы; код, который компилируется для одного процессора не обязательно будет работать для другого процессора. Он остается пользователю, чтобы определить, если скорость получаемые преимущества перевешивают проблемы точности.

Если оптимизация использования fp: fast особенно проблематичным для определенной функции, с плавающей запятой изменения режима работы локально для fp: точно с помощью `float_control` pragma компилятора.

### <a name="algebraic-transformations-under-fpfast"></a>Алгебраические преобразования в разделе fp: fast

Режим fp: fast позволяет компилятору выполнять различные выражения точки небезопасный алгебраические преобразования с плавающей запятой. Например следующие оптимизации небезопасный может использоваться в разделе fp: FAST.

||||
|-|-|-|
|Исходный код|Шаг #1|Шаг #2
|`double a, b, c;`<br/>`double x, y, z;`<br/><br/>`y = (a + b);`<br/>`z = y – a – b;`<br/><br/>`c = x – z;`<br/><br/>`c = x * z;`<br/><br/>`c = x - z;`<br/><br/>`c = x + z;`<br/><br/>`c = z-x;`|`double a, b, c;`<br/>`double x, y, z;`<br/><br/>`y = (a + b);`<br/>`z = 0;`<br/><br/>`c = x – 0;`<br/><br/>`c = x * 0;`<br/><br/>`c = x - 0;`<br/><br/>`c = x + 0;`<br/><br/>`c = 0 - x;`|`double a, b, c;`<br/>`double x, y, z;`<br/><br/>`y = (a + b);`<br/>`z = 0;`<br/><br/>`c = x;`<br/><br/>`c = 0;`<br/><br/>`c = x;`<br/><br/>`c = x;`<br/><br/>`c = -x;`|

На шаге 1, компилятор соблюдает, `z = y – a – b` всегда равно нулю. Несмотря на то, что это технически недопустимый наблюдения, оно разрешено в соответствии fp: FAST. Компилятор распространяет постоянное значение ноль для каждого последующего использования переменной z. На шаге 2, дальнейшей компилятор оптимизирует код, наблюдая за, `x - 0 == x`, `x * 0 == 0`и т. д. Опять же несмотря на то, что эти наблюдения, строго не допускаются, они разрешены fp: FAST. Оптимизированный код теперь выполняется гораздо быстрее, но также может значительно менее точным или даже неверен.

Любой из следующих правил (небезопасно) алгебраические может использоваться оптимизатором, при включении режима fp: FAST:

|||
|-|-|
|Form|Описание:|
|`(a + b) + c = a + (b + c)`|Ассоциативные правила для добавления|
|`(a * b) * c = a * (b * c)`|Ассоциативные правила для умножения|
|`a * (b + c) = a * b + b * c`|Распределение умножения над сложением|
|`(a + b)(a - b) = a * a - b * b`|Алгебраические факторинг|
|`a / b = a * (1 / b)`|Деление на обратную величину|
|`a * 1.0 = a, a / 1.0 = a`|Мультипликативный идентификатор|
|`a ± 0.0 = a, 0.0 - a = -a`|Аддитивный|
|`a / a = 1.0, a - a = 0.0`|Отмена|

Если оптимизация использования fp: fast особенно проблематичным для конкретной функции, с плавающей запятой изменения режима работы локально для fp: точно с помощью `float_control` pragma компилятора.

### <a name="order-of-floating-point-expression-evaluation-under-fpfast"></a>Порядок вычисления выражений с плавающей запятой в разделе fp: fast

В отличие от fp: precise, fp: fast позволяет компилятору изменять порядок операций с плавающей запятой, таким образом, чтобы создать более быстрый код. Таким образом некоторые оптимизации под fp: fast не может сохранять последовательности выражений. Например рассмотрим следующую функцию, которая вычисляет скалярное произведение двух векторов многомерный.

```cpp
float dotProduct( float x[], float y[],
                  int n )
{
   float p=0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}
```

В разделе fp: FAST, оптимизатор может выполнять скалярная редукция из `dotProduct` работать эффективно модернизировать функцию следующим образом:

```cpp
float dotProduct( float x[], float y[],int n )
{
    int n4= n/4*4; // or n4=n&(~3);
    float p=0, p2=0, p3=0, p4=0;
    int i;

    for (i=0; i<n4; i+=4)
    {
        p+=x[i]*y[i];
        p2+=x[i+1]*y[i+1];
        p3+=x[i+2]*y[i+2];
        p4+=x[i+3]*y[i+3];
    }
    p+=p2+p3+p4;

    // last n%4 elements
    for (; i<n; i++)
    p+=x[i]*y[i];

    return p;
}
```

В оптимизированной версии функции четыре отдельных суммированием продукта создаются одновременно и затем добавляются друг с другом. Эта оптимизация может ускорить вычисления `dotProduct` с сокращенным фактор из четырех в зависимости от целевой процессор, но результат может быть таким образом неточной, как вывести ее из строя. Если такая оптимизация особенно проблематичным, для одной функции или преобразования, с плавающей запятой изменения режима работы локально для fp: точно с помощью `float_control` pragma компилятора.

## <a name="the-fpstrict-mode-for-floating-point-semantics"></a>Fp: strict режим для семантику с плавающей точкой

Когда fp: строгий режим включен, компилятор соответствует те же правила виде этот fp: точное использует при оптимизации операций с плавающей запятой. Этот режим также обеспечивает семантику исключения с плавающей запятой и чувствительности к среде Выполнения и отключает определенные оптимизации, такие как сокращения. Это строгий режим работы.

Fp: strict с плавающей запятой режим включается с помощью [/fp: strict](fp-specify-floating-point-behavior.md) параметр компилятора командной строки следующим образом:

> cl /fp:strict source.cpp

В этом примере предписывает компилятору использовать fp: строгую семантику, при создании кода для файла source.cpp. Fp: strict модели также может быть вызван для отдельных функций, функции с помощью `float_control` pragma компилятора.

Дополнительные сведения см. раздел [float_control-прагма](#the-float-control-pragma).

В разделе fp: строгий режим, компилятор никогда не выполняет все оптимизации, повлиять на точность вычислений с плавающей запятой. Компилятор правильно всегда округляет в назначения, приведении типов и вызовы функций и промежуточные округления будет постоянно выполняться на такую же точность как регистрирует FPU. Семантика исключения с плавающей запятой и чувствительности FPU среды включены по умолчанию. Некоторые оптимизации, такие как сокращения, отключены, так как компилятор не может гарантировать правильность во всех случаях.

|fp: strict семантику|Объяснение|
|-|-|
|Семантики округления|Явные округление в назначения, приведении типов и вызывает функцию<br/>Промежуточных выражений будет вычисляться в точности регистра.<br/>Совпадение с кодом fp: точное|
|Алгебраические преобразования|Строгое соответствие не ассоциативность, отличных от дистрибутивности алгебры с плавающей запятой, если преобразование гарантированно всегда дают одинаковые результаты.<br/>Совпадение с кодом fp: точное|
|Сокращения|Этот параметр всегда отключен|
|Порядок вычисления с плавающей запятой|Компилятор не изменит порядок вычисления выражений с плавающей запятой|
|Доступ к сопроцессору FPU|Всегда включен.|
|Семантика исключения с плавающей запятой|По умолчанию включено.|

### <a name="floating-point-exception-semantics-under-fpstrict"></a>Семантика исключения с плавающей запятой в разделе fp: strict

По умолчанию включены исключения с плавающей запятой семантику fp: strict модели. Чтобы отключить эту семантику, использовать **/fp: за исключением-** переключения или введения `float_control(except, off)` директивы pragma.

Дополнительные сведения см. разделы [Включение семантику исключения с плавающей запятой](#enabling-floating-point-exception-semantics) и [float_control Pragma](#the-float-control-pragma).

## <a name="the-fenvaccess-pragma"></a>Fenv_access-прагма

Использование:

```cpp
#pragma fenv_access( [ on  | off ] )
```

[Fenv_access](../../preprocessor/fenv-access.md) pragma позволяет компилятору указание сделать определенные оптимизации, которые могут подвергнуть опасности FPU проверки флагов и изменения режима FPU. Когда состояние `fenv_access` отключена, можно предположить, что компилятор режимы по умолчанию FPU вступают в силу и флагами FPU не проверяются. По умолчанию, отключения доступа среды fp: режиме, хотя он может быть явно включено с помощью этой директивы #pragma. В разделе fp: strict, `fenv_access` всегда включен и не могут быть отключены. В разделе fp: fast `fenv_access` всегда отключен и не может быть включен.

Как описано в fp: точное разделе некоторые программисты могут изменяться с плавающей запятой округления направление с помощью `_controlfp` функции. Например для вычисления ошибки верхней и нижней границы на арифметические операции, некоторые программы выполнять выполняется вычисление дважды, сначала при округление в сторону отрицательной бесконечности, а затем при округление в сторону положительной бесконечности. Поскольку FPU предоставляет удобный способ округления, программист может потребоваться изменить режим округления путем изменения среды Выполнения. Следующий код вычисляет точное ошибка граница умножения с плавающей запятой путем изменения среды Выполнения.

```cpp
double a, b, cLower, cUpper;
// . . .
_controlfp( _RC_DOWN, _MCW_RC );    // round to -infinity
cLower = a*b;
_controlfp( _RC_UP, _MCW_RC );       // round to +infinity
cUpper = a*b;
_controlfp( _RC_NEAR, _MCW_RC );    // restore rounding mode
```

При отключении `fenv_access` pragma позволяет компилятору считать, среда Выполнения по умолчанию; таким образом оптимизатор игнорировать вызовы `_controlfp` и сократить выше назначения, которые `cUpper = cLower = a*b`. Если этот параметр включен, однако `fenv_access` предотвращает такую оптимизацию.

Программы также проверить состояние слова FPU для обнаружения определенных ошибок с плавающей запятой. Например следующий код проверяет условия деления на ноль и неточный

```cpp
double a, b, c, r;
float x;
// . . .
_clearfp();
r = (a*b + sqrt(b*b-4*a*c))/(2*a);
if (_statusfp() & _SW_ZERODIVIDE)
   handle divide by zero as a special case
_clearfp();
x = (a*b + sqrt(b*b-4*a*c))/(2*a);
if (_statusfp() & _SW_INEXACT)
   handle inexact error as a special case
etc...
```

Когда `fenv_access` будет отключен, компилятор может изменить порядок выполнения выражений с плавающей запятой, таким образом, возможно, воздействия FPU проверки состояния. Включение `fenv_access` предотвращает такую оптимизацию.

## <a name="the-fpcontract-pragma"></a>Fp_contract-прагма

Использование:

```cpp
#pragma fp_contract( [ on | off ] )
```

Как описано в fp: точное разделе сокращением является компонентом фундаментальных архитектурных для многих современных устройств с плавающей запятой. Сокращения предоставляют возможность выполнения операций умножения, следуют дополнения в одну операцию без промежуточных ошибок округления. Этих инструкций с одинарной быстрее, чем выполнение отдельных умножения и добавьте инструкции, а являются более точные, так как не производится никакого округления промежуточных продукта. Проясняет операции можно вычисляет значение `(a*b+c)` так, как в том случае, если обе операции были вычисления с бесконечной точностью и затем округляется до ближайшего числа с плавающей запятой. Эта оптимизация может значительно ускорить работу функции, содержащий ряд с чередованием multiply и добавление операций. Например рассмотрим следующий алгоритм, который вычисляет скалярное произведение двух векторов многомерный.

```cpp
float dotProduct( float x[], float y[], int n )
{
   float p=0.0;
   for (int i=0; i<n; i++)
      p += x[i]*y[i];
   return p;
}
```

Это вычисление можно выполнить ряд "умножить" добавьте инструкции формы `p = p + x[i]*y[i]`.

[Fp_contract](../../preprocessor/fp-contract.md) директива pragma указывает, может быть сокращена выражений с плавающей запятой. По умолчанию fp: режиме позволяет для сокращения, так как они повышают точность и скорость. Сокращения всегда включены для режима fp: FAST. Тем не менее, так как сокращения могут подвергнуть опасности явное обнаружение условий ошибки `fp_contract` pragma всегда отключен в разделе fp: строгий режим. Примеры выражений, которые могут быть уменьшены при `fp_contract` pragma включен:

```cpp
float a, b, c, d, e, t;
...
d = a*b + c;         // may be contracted
d += a*b;            // may be contracted
d = a*b + e*d;       // may be contracted into a mult followed by a mult-add etc...

d = (float)a*b + c;  // won't be contracted because of explicit rounding

t = a*b;             // (this assignment rounds a*b to float)
d = t + c;           // won't be contracted because of rounding of a*b
```

## <a name="the-floatcontrol-pragma"></a>Float_control-прагма

**/Fp: точное**, **/fp:fast**, **/fp: strict** и **/fp: except** управляет семантику с плавающей точкой на файл, файл основы. [Float_control](../../preprocessor/float-control.md) директива #pragma обеспечивает такой элемент управления на основе функции, функции.

Использование:

```cpp
#pragma float_control(push)
#pragma float_control(pop)
#pragma float_control( precise, on | off [, push] )
#pragma float_control( except, on | off [, push] )
```

Директивы pragma `float_control(push)` и `float_control(pop)` соответственно отправка и отображение текущего состояния с плавающей запятой режим и параметра exception в стек. Обратите внимание, что состояние `fenv_access` и `fp_contract` директива pragma не затрагивает `pragma float_control(push/pop)`.

Вызов директива pragma `float_control(precise, on)` включит и `float_control(precise, off)` приведет к отключению семантику для точном режиме. Аналогично pragma `float_control(except, on)` включит и `float_control(except, off)` приведет к отключению семантику исключения. Семантику исключения можно включить только в том случае, если семантику также включены. При необязательный `push` присутствует аргумент состояния `float_control` параметры передаются перед изменением семантику.

### <a name="setting-the-floating-point-semantic-mode-on-a-function-by-function-basis"></a>Изменение режима с плавающей запятой семантики на основе функции, функция

Параметры командной строки на самом деле являются сокращением для задания параметров директивы pragma четыре разных с плавающей запятой. Чтобы явно выбрать с плавающей запятой семантической режима на основе функции, функции, выберите каждый из четырех директив pragma с плавающей запятой параметр как описано в следующей таблице:

||||||
|-|-|-|-|-|
||float_control(precise)|float_control(except)|fp_contract|fenv_access|
|/ fp: strict|вкл.|вкл.|Отключение|вкл.|
|/fp:strict /fp:except-|вкл.|Отключение|Отключение|вкл.|
|/ fp: точное|вкл.|Отключение|вкл.|Отключение|
|/ fp: precise/fp: except|вкл.|вкл.|вкл.|Отключение|
|/fp:fast|Отключение|Отключение|вкл.|Отключение|

Например, ниже явным образом включает семантику fp: FAST.

```cpp
#pragma float_control( except, off )   // disable exception semantics
#pragma float_control( precise, off )  // disable precise semantics
#pragma fp_contract(on)                // enable contractions
#pragma fenv_access(off)               // disable fpu environment sensitivity
```

> [!Note]
> Прежде чем отключать «семантику» семантику исключения должен быть отключен.

## <a name="enabling-floating-point-exception-semantics"></a>Включение семантику исключения с плавающей запятой

Определенные исключительных условий с плавающей запятой, например деления на ноль, может привести к FPU информировать аппаратное исключение. По умолчанию отключены исключения с плавающей запятой. Исключения с плавающей запятой включены путем изменения контрольного слова FPU с `_controlfp` функции. Например следующий код позволяет исключение деления на ноль с плавающей запятой:

```cpp
_clearfp(); // always call _clearfp before
            // enabling/unmasking a FPU exception
_controlfp( _EM_ZERODIVIDE, _MCW_EM );
```

Если включено исключение деления на ноль, все операции деления с знаменатель, равным нулю вызовет исключение FPU сигнала.

Чтобы восстановить контрольного слова FPU режим по умолчанию, вызовите `_controlfp(_CW_DEFAULT, ~0)`.

Включение семантику исключения с плавающей запятой с **/fp: except** флаг не так же, как включение исключения с плавающей запятой. Если включены семантику исключения с плавающей запятой, компилятор необходимо учитывать вероятность того, что все операции с плавающей запятой может вызвать исключение. Поскольку FPU — это единица процессора, инструкции, выполнив на FPU могут выполняться параллельно с инструкциями на другие единицы измерения.

При включении исключения с плавающей запятой FPU будет приостановить выполнение нежелательного инструкции и сообщить об исключительным условием, задав слова FPU состояния. Когда ЦП достигает следующей инструкции с плавающей запятой, он сначала проверяет наличие любые ожидающие исключения FPU. Если ожидающего исключения, обработчик перехватывает его путем вызова обработчика исключений, предоставляемые операционной системой. Это означает, что при операции с плавающей запятой обнаруживает исключительным условием, соответствующее исключение не будут обнаружены до выполнения следующей операции с плавающей запятой. Например следующий код перехватывает исключение деления на нуль:

```cpp
double a, b, c;
// . . .
// ...unmasking of FPU exceptions omitted...
__try
{
   b/c; // assume c==0.0
   printf("This line shouldn't be reached when c==0.0\n");
   c = 2.0*b;
}
__except( EXCEPTION_EXECUTE_HANDLER )
{
   printf("SEH Exception Detected\n");
}
// . . .
```

Если возникает условие ошибки деления на ноль, в выражении = b/c, FPU не ловушки/raise исключение до следующей операции с плавающей запятой в выражении 2.0 * b. Это приводит к приведенным ниже:

```Output
This line shouldn't be reached when c==0.0
SEH Exception Detected
```

Следует, printf, соответствующее первой строки выходных данных не был достигнут; он достигнут, поскольку исключения с плавающей запятой, из-за выражение b/c не возникло, до выполнения 2.0 * b. Чтобы породить исключение сразу после выполнения b/c, компилятор должен вводить инструкцию «Ожидание»:

```cpp
// . . .
   __try
   {
      b/c; // assume this expression will cause a "divide-by-zero" exception
      __asm fwait;
      printf("This line shouldn't be reached when c==0.0\n");
      c = 2.0*b;
   }
// . . .
```

Эта инструкция «ожидать» заставляет обработчик для синхронизации с состоянием FPU и обработки исключений, ожидающие. Компилятор будет создавать только эти «ожидать» инструкции, если включены семантику с плавающей точкой. При отключении эту семантику, как по умолчанию, программы могут возникнуть ошибки происходила, аналогичное приведенному выше, при использовании исключений с плавающей запятой.

Если включены семантику с плавающей точкой, компилятор будет не только вводить инструкции «ожидание», он будет также запретить компилятору выполнять незаконно оптимизации с плавающей запятой кода при наличии возможных исключений. Сюда входят все преобразования, изменяющие точек, в которых вызываются исключения. Из-за эти факторы Включение семантику с плавающей точкой может значительно снизить эффективность созданный машинный код, что также снизит производительность приложения.

Семантика исключения с плавающей запятой включены по умолчанию в разделе fp: strict режим. Чтобы включить эту семантику в fp: режиме, добавьте **/fp: за исключением** переключиться в режим командной строки компилятора. Семантика исключения с плавающей запятой может также включать и отключать функции, функций с помощью `float_control` директивы pragma.

### <a name="floating-point-exceptions-as-c-exceptions"></a>Исключения с плавающей запятой как исключения C++

Как все аппаратные исключения, исключения с плавающей запятой по своей природе не вызывают исключения C++, но вместо этого триггера структурированное исключение. Чтобы сопоставить исключения с плавающей запятой структурированные исключения C++, пользователей может стать причиной преобразователя пользовательского исключения SEH. Во-первых представляют исключения C++, соответствующий каждой исключения с плавающей запятой.

```cpp
class float_exception : public std::exception {};

class fe_denormal_operand : public float_exception {};
class fe_divide_by_zero : public float_exception {};
class fe_inexact_result : public float_exception {};
class fe_invalid_operation : public float_exception {};
class fe_overflow : public float_exception {};
class fe_stack_check : public float_exception {};
class fe_underflow : public float_exception {};
```

Затем вводят функцию преобразования, который обнаружит с плавающей запятой исключение SEH и соответствующие исключения C++. Чтобы использовать эту функцию, задайте translator обработчик структурированных исключений для текущего потока процесса с [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md) функции из библиотеки времени выполнения.

```cpp
void se_fe_trans_func( unsigned int u, EXCEPTION_POINTERS* pExp )
{
    switch (u)
    {
    case STATUS_FLOAT_DENORMAL_OPERAND:   throw fe_denormal_operand();
    case STATUS_FLOAT_DIVIDE_BY_ZERO:     throw fe_divide_by_zero();
   etc...
    };
}
// . . .
_set_se_translator(se_fe_trans_func);
```

После инициализации это сопоставление исключений с плавающей запятой будет вести себя, как будто они являются исключениями C++. Пример:

```cpp
try
{
   // floating-point code that might throw divide-by-zero
   // or other floating-point exception
}
catch(fe_divide_by_zero)
{
    cout << "fe_divide_by_zero exception detected" << endl;
}
catch(float_exception)
{
    cout << "float_exception exception detected" << endl;
}
```

## <a name="references"></a>Ссылки

[Что следует знать об арифметических операций с плавающей запятой каждый компьютер по анализу и обработке](http://pages.cs.wisc.edu/~david/courses/cs552/S12/handouts/goldberg-floating-point.pdf) , Дэвид Песоцкий.

## <a name="see-also"></a>См. также

[Оптимизация кода](../optimizing-your-code.md)<br/>
