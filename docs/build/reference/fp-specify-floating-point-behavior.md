---
title: /fp (определение поведения с плавающей запятой)
ms.date: 11/09/2018
f1_keywords:
- VC.Project.VCCLCompilerTool.floatingPointModel
- VC.Project.VCCLWCECompilerTool.FloatingPointExceptions
- /fp
- VC.Project.VCCLWCECompilerTool.floatingPointModel
- VC.Project.VCCLCompilerTool.FloatingPointExceptions
helpviewer_keywords:
- -fp compiler option [C++]
- /fp compiler option [C++]
ms.assetid: 10469d6b-e68b-4268-8075-d073f4f5d57e
ms.openlocfilehash: 7a8ae885bbbf00ae916505bf5df646b32268a17a
ms.sourcegitcommit: 6280a4c629de0f638ebc2edd446de2a9b11f0406
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/12/2020
ms.locfileid: "90040916"
---
# <a name="fp-specify-floating-point-behavior"></a>/fp (определение поведения с плавающей запятой)

Указывает, как компилятор обрабатывает выражения с плавающей запятой, оптимизации и исключения. Параметры **/FP** определяют, допускает ли сформированный код изменения среды с плавающей запятой в режим округления, маски исключений и поведение в нормальном режиме, а также указывает, будут ли проверки состояния с плавающей точкой возвращать текущие и точные результаты. Он определяет, создает ли компилятор код, сохраняющий исходную операцию и упорядочение выражений, и соответствует стандарту для распространения NaN или, если вместо этого генерирует более эффективный код, который может переупорядочивать или объединять операции и использовать упрощенные преобразования алгебраические, не разрешенные стандартом.

## <a name="syntax"></a>Синтаксис

> **/FP:**[**Точная**  |  **строго**  |  **Высокая скорость**,  |  **Кроме**[ **-** ]]

### <a name="arguments"></a>Аргументы

#### <a name="precise"></a>точен

По умолчанию компилятор использует `/fp:precise` поведение.

В `/fp:precise` компиляторе сохраняет упорядочивание выражений источника и округление свойств кода с плавающей запятой при формировании и оптимизации объектного кода для целевого компьютера. Компилятор округляет до точности исходного кода по четырем конкретным точкам во время вычисления выражения: в назначениях при приведении типов при передаче аргумента с плавающей запятой в вызов функции и при возвращении значения с плавающей запятой из вызова функции. Промежуточные вычисления могут выполняться при точности компьютеров. Приведение приведений можно использовать для явного округления промежуточных вычислений.

Компилятор не выполняет преобразования алгебраические для выражений с плавающей запятой, таких как повторное связывание или распространение, если преобразование не гарантировано приводить к появлению побитового идентичного результата.
Выражения, использующие специальные значения (NaN, + Infinity,-Infinity,-0,0), обрабатываются в соответствии со спецификациями IEEE-754. Например, принимает значение, `x != x` **`true`** если x — NaN. *Контракты*с плавающей точкой, то есть машинные инструкции, которые объединяют операции с плавающей запятой, могут быть созданы в разделе `/fp:precise` .

Компилятор создает код, предназначенный для выполнения в [среде с плавающей запятой по умолчанию](#the-default-floating-point-environment) , и предполагает, что среда с плавающей точкой не доступна или не изменяется во время выполнения. То есть предполагается, что код не снимает маскировку исключений с плавающей запятой, считывает или пишет регистры состояния с плавающей запятой или изменяет режим округления.

Если код с плавающей запятой не зависит от порядка операций и выражений в операторах с плавающей запятой (например, если вы не хотите, чтобы `a * b + a * c` он был вычислен как `(b + c) * a` или `2 * a` как `a + a` ), рассмотрим параметр [/FP: Fast](#fast) , который может создавать более быстрый и эффективный код. Если код зависит от порядка операций и выражений, а также для доступа или изменения среды с плавающей запятой (например, для изменения режимов округления или для перехвата исключений с плавающей запятой) используйте [/FP:](#strict)Round.

#### <a name="strict"></a>strict

`/fp:strict` имеет поведение, аналогичное `/fp:precise` , то есть компилятор сохраняет упорядочение источника и свойства округления кода с плавающей запятой при формировании и оптимизации объектного кода для целевого компьютера, а также следит за стандартом при обработке специальных значений. Кроме того, программа может безопасно получать доступ к среде с плавающей точкой и изменять ее во время выполнения.

В среде `/fp:strict` компилятор создает код, который позволяет программе безопасно отменять маскировку исключений с плавающей запятой, читать или записывать регистры состояния операций с плавающей запятой или изменять режимы округления. При вычислении выражения он округляет до точности исходного кода по четырем точкам: в назначениях при приведении типов с плавающей запятой в вызове функции и при возврате значения с плавающей запятой из вызова функции. Промежуточные вычисления могут выполняться при точности компьютеров. Приведение приведений можно использовать для явного округления промежуточных вычислений. Компилятор не выполняет преобразования алгебраические для выражений с плавающей запятой, таких как повторное связывание или распространение, если преобразование не гарантировано приводить к появлению побитового идентичного результата. Выражения, использующие специальные значения (NaN, + Infinity,-Infinity,-0,0), обрабатываются в соответствии со спецификациями IEEE-754. Например, принимает значение, `x != x` **`true`** если x — NaN. В не создаются контракты с плавающей точкой `/fp:strict` .

`/fp:strict` является более затратным для вычислений, чем `/fp:precise` потому, что компилятор должен вставлять дополнительные инструкции для перехвата исключений и позволить программам получать доступ к среде с плавающей точкой и изменять ее во время выполнения. Если код не использует эту возможность, но требует упорядочения исходного кода и округления или использует специальные значения, используйте `/fp:precise` . В противном случае рассмотрите возможность использования `/fp:fast` , что может привести к быстрому и меньшему объему кода.

#### <a name="fast"></a>быстрая

`/fp:fast`Параметр позволяет компилятору изменять порядок, комбинировать или упростить операции с плавающей запятой, чтобы оптимизировать код с плавающей запятой для ускорения и пропускной точки. Компилятор может опускать округление в операторах присваивания, приведениях или вызовах функций. Он может изменять порядок операций или выполнять преобразования алгебраические, например, используя ассоциативные и дистрибутиве законы, даже если такие преобразования приводят к наблюдаемому разному поведению округления. Из-за этой улучшенной оптимизации результат некоторых вычислений с плавающей запятой может отличаться от результатов, полученных другими `/fp` параметрами. Специальные значения (NaN, + Infinity,-Infinity,-0,0) могут не распространяться или работать исключительно в соответствии со стандартом IEEE-754. В можно создавать контракты с плавающей точкой `/fp:fast` . Компилятор по-прежнему привязан к базовой архитектуре в `/fp:fast` , а дополнительные оптимизации могут быть доступны с помощью параметра [/Arch](arch-minimum-cpu-architecture.md) .

В `/fp:fast` компиляторе создается код, предназначенный для выполнения в среде с плавающей запятой по умолчанию, и предполагается, что среда с плавающей запятой недоступна или не изменяется во время выполнения. То есть предполагается, что код не снимает маскировку исключений с плавающей запятой, считывает или пишет регистры состояния с плавающей запятой или изменяет режим округления.

`/fp:fast` предназначен для программ, не требующих полного упорядочения исходного кода и округления выражений с плавающей запятой, и не полагайтесь на стандартные правила обработки специальных значений, таких как NaN. Если код с плавающей запятой требует сохранения порядка исходного кода и округления или зависит от стандартного поведения специальных значений, используйте [/FP: точную](#precise). Если код обращается к среде с плавающей запятой или изменяет ее, чтобы изменить режим округления, снимите маску исключений с плавающей запятой или проверьте состояние с плавающей запятой, используйте [/FP:](#strict)Round.

#### <a name="except"></a>except

`/fp:except`Параметр создает код, гарантирующий, что любые немаскированные исключения с плавающей запятой вызываются в той точке, где они происходят, и что никакие дополнительные исключения с плавающей запятой не вызываются. По умолчанию `/fp:strict` параметр включает `/fp:except` , а не `/fp:precise` . `/fp:except`Параметр несовместим с `/fp:fast` . Параметр может быть явно отключен нами `/fp:except-` .

Обратите внимание, что не `/fp:except` включает исключения с плавающей запятой сама по себе, но необходимо, чтобы программы включили исключения с плавающей запятой. Сведения о том, как включить исключения с плавающей запятой, см. в разделе [_controlfp](../../c-runtime-library/reference/control87-controlfp-control87-2.md) .

## <a name="remarks"></a>Комментарии

`/fp`В одной командной строке компилятора можно указать несколько параметров. `/fp:strict` `/fp:fast` `/fp:precise` В каждый момент времени может действовать только один из параметров, и. Если в командной строке указано более одного из этих параметров, параметр имеет более высокий приоритет, и компилятор выдает предупреждение. `/fp:strict`Параметры и `/fp:except` несовместимы с `/clr` .

Параметр [/Za](za-ze-disable-language-extensions.md) (совместимость с ANSI) несовместим с `/fp` .

### <a name="using-compiler-directives-to-control-floating-point-behavior"></a>Использование директив компилятора для управления поведением с плавающей запятой

Компилятор предоставляет три директивы директивы pragma для переопределения поведения с плавающей запятой, указанного в командной строке: [float_control](../../preprocessor/float-control.md), [fenv_access](../../preprocessor/fenv-access.md)и [fp_contract](../../preprocessor/fp-contract.md). Эти директивы можно использовать для управления поведением операций с плавающей запятой на уровне функций, а не внутри функции. Обратите внимание, что эти директивы не соответствуют непосредственно `/fp` параметрам. В этой таблице показано, как `/fp` директивы Options и pragma сопоставляются друг с другом. Дополнительные сведения см. в документации по отдельным параметрам и директивам директивы pragma.

| Параметр | float_control (точное) | float_control (за исключением) | fenv_access | fp_contract |
|-|-|-|-|-|
|`/fp:fast`|off|off|off|on|
|`/fp:precise`|on|off|off|on|
|`/fp:strict`|on|on|on|off|

### <a name="the-default-floating-point-environment"></a>Среда с плавающей точкой по умолчанию

При инициализации процесса устанавливается *Среда с плавающей точкой по умолчанию* . Эта среда маскирует все исключения с плавающей запятой, устанавливает режим округления для округления до ближайшего ( `FE_TONEAREST` ), сохраняет значения поднормали (денормализованные), использует точность по умолчанию значащим (мантисса) для **`float`** **`double`** значений, и **`long double`** , и, где поддерживается, устанавливает элемент управления бесконечности в режим аффинных по умолчанию.

### <a name="floating-point-environment-access-and-modification"></a>Доступ и изменение среды с плавающей точкой

Среда выполнения Microsoft Visual C++ предоставляет несколько функций для доступа к среде с плавающей запятой и ее изменения. К ним относятся [_controlfp](../../c-runtime-library/reference/control87-controlfp-control87-2.md), [_clearfp](../../c-runtime-library/reference/clear87-clearfp.md)и [_statusfp](../../c-runtime-library/reference/status87-statusfp-statusfp2.md) , а также их варианты. Чтобы обеспечить правильное поведение программы, когда код обращается к среде с плавающей запятой или изменяет ее, `fenv_access` необходимо включить параметр либо с помощью `/fp:strict` параметра, либо с помощью `fenv_access` директивы pragma, чтобы эти функции имели любой результат. Если `fenv_access` параметр не включен, доступ или изменение среды с плавающей запятой может привести к непредвиденному поведению программы: код может не учитывать запрошенные изменения в среде с плавающей запятой; регистры состояния с плавающей запятой не могут сообщать ожидаемые или текущие результаты, а непредвиденные исключения с плавающей запятой могут не возникать.

Когда код обращается к среде с плавающей запятой или изменяет ее, необходимо соблюдать осторожность при объединении кода `fenv_access` с включенным кодом, который не `fenv_access` включен. В коде `fenv_access` , где не включено, компилятор предполагает, что используется среда с плавающей запятой по умолчанию платформы и что состояние с плавающей запятой недоступно или не изменено. Рекомендуется сохранить и восстановить локальную среду с плавающей запятой до состояния по умолчанию перед передачей управления в функцию, которая не `fenv_access` включена. В этом примере показано, как `float_control` можно установить и восстановить директиву pragma:

```cpp
#pragma float_control(strict, on, push)
// Code that uses /fp:strict mode
#pragma float_control(pop)
```

### <a name="floating-point-rounding-modes"></a>Режимы округления с плавающей запятой

В `/fp:precise` и `/fp:fast` компилятор создает код, предназначенный для выполнения в среде с плавающей запятой по умолчанию, и предполагает, что среда недоступна или изменена во время выполнения. То есть предполагается, что код не снимает маскировку исключений с плавающей запятой, считывает или пишет регистры состояния с плавающей запятой или изменяет режим округления.  Однако некоторым программам необходимо изменить среду с плавающей запятой. Например, в этом образце вычисляются ошибки, связанные с операциями умножения с плавающей запятой путем изменения режима округления с плавающей запятой.

```cpp
// fp_error_bounds.cpp
#include <iostream>
#include <limits>
using namespace std;

int main(void)
{
    float a = std::<float>::max();
    float b = -1.1;
    float cLower = 0.0;
    float cUpper = 0.0;
    unsigned int control_word = 0;
    int err = 0;

    // compute lower error bound.
    // set rounding mode to -infinity.
    err = _controlfp_s(&control_word, _RC_DOWN, _MCW_RC);
    if (err)
    {
        cout << "_controlfp_s(&control_word, _RC_DOWN, _MCW_RC) failed with error:" << err << endl;
    }  
    cLower = a * b;

    // compute upper error bound.
    // set rounding mode to +infinity.
    err = _controlfp_s(&control_word, _RC_UP, _MCW_RC);
    if (err)
    {
        cout << "_controlfp_s(&control_word, _RC_UP, _MCW_RC) failed with error:" << err << endl;
    }
    cUpper = a * b;

    // restore default rounding mode.
    err = _controlfp_s(&control_word, _CW_DEFAULT, _MCW_RC);
    if (err)
    {
        cout << "_controlfp_s(&control_word, _CW_DEFAULT, _MCW_RC) failed with error:" << err << endl;
    }
    // display error bounds.
    cout << "cLower = " << cLower << endl;
    cout << "cUpper = " << cUpper << endl;
    return 0;
}
```

Так как компилятор предполагает, что среда с плавающей запятой по умолчанию находится в `/fp:fast` , и вы `/fp:precise` можете игнорировать вызовы `_controlfp_s` . Например, при компиляции с использованием `/O2` и `/fp:precise` для архитектуры x86, границы не вычисляются, а образец программы выводит:

```Output
cLower = -inf
cUpper = -inf
```

При компиляции с обеих `/O2` `/fp:strict` платформ и для архитектуры x86 пример программы выводит:

```Output
cLower = -inf
cUpper = -3.40282e+38
```

### <a name="floating-point-special-values"></a>Специальные значения с плавающей точкой

В условиях `/fp:precise` и `/fp:strict` выражениях, в которых используются специальные значения (NaN, + Infinity,-Infinity,-0,0), ведут себя в соответствии со спецификациями IEEE-754. В среде `/fp:fast` поведение этих специальных значений может не соответствовать стандарту IEEE-754.

В этом примере демонстрируется другое поведение специальных значений в разделе `/fp:precise` , `/fp:strict` а также `/fp:fast` :

```cpp
// fp_special_values.cpp
#include <stdio.h>
#include <cmath>

float gf0 = -0.0;

int main()
{
    float f1 = INFINITY;
    float f2 = NAN;
    float f3 = -INFINITY;
    bool a, b;
    float c, d, e;
    a = (f1 == f1);
    b = (f2 == f2);
    c = (f1 - f1);
    d = (f2 - f2);
    printf("INFINITY == INFINITY : %d\n", a);
    printf("NAN == NAN           : %d\n", b);
    printf("INFINITY - INFINITY  : %f\n", c);
    printf("NAN - NAN            : %f\n", d);

    e = gf0 / abs(f3);
    printf("std::signbit(-0.0/-INFINITY): %d\n", std::signbit(c));
    return 0;
}
```

При компиляции с `/O2` `/fp:precise` `/O2` `/fp:strict` архитектурой или для архитектуры x86 выходные данные согласуются со спецификацией IEEE-754:

```Output
INFINITY == INFINITY : 1
NAN == NAN           : 0
INFINITY - INFINITY  : -nan(ind)
NAN - NAN            : -nan(ind)
std::signbit(-0.0/-INFINITY): 1
```

При компиляции с `/O2` `/fp:fast` архитектурой для x86 выходные данные не согласуются с IEEE-754:

```Output
INFINITY == INFINITY : 1
NAN == NAN           : 1
INFINITY - INFINITY  : 0.000000
NAN - NAN            : 0.000000
std::signbit(-0.0/-INFINITY): 0
```

### <a name="floating-point-algebraic-transformations"></a>Преобразования алгебраические с плавающей точкой

В `/fp:precise` и `/fp:strict` компилятор не выполняет математические преобразования, за исключением случаев, когда преобразование гарантированно создает побитовый идентичный результат. Компилятор может выполнять такие преобразования в `/fp:fast` . Например, выражение `a * b + a * c` в функции Sample `algebraic_transformation` может быть скомпилировано в `a * (b + c)` разделе `/fp:fast` . Такие преобразования не выполняются в `/fp:precise` или `/fp:strict` , а компилятор создает `a * b + a * c` .

```cpp
float algebraic_transformation (float a, float b, float c)
{
    return a * b + a * c;
}
```

### <a name="floating-point-explicit-casting-points"></a>Явные точки приведения с плавающей точкой

В разделе `/fp:precise` и `/fp:strict` компилятор округляет до точности исходного кода на четырех конкретных точках во время вычисления выражения: в назначениях при приведении типов при передаче аргумента с плавающей запятой в вызов функции и при возвращении значения с плавающей запятой из вызова функции. Приведение приведений можно использовать для явного округления промежуточных вычислений. В среде `/fp:fast` компилятор не создает явные приведения на этих точках, чтобы гарантировать точность исходного кода. В этом примере демонстрируется поведение при различных `/fp` параметрах.

```cpp
float casting(float a, float b)
{
    return 5.0*((double)(a+b));
}
```

При компиляции с помощью `/O2` `/fp:precise` или `/O2` `/fp:strict` можно увидеть, что явные приведения типов вставляются как в приведении, так и в точке возврата функции в созданном коде для архитектуры x64:

```asm
        addss    xmm0, xmm1
        cvtss2sd xmm0, xmm0
        mulsd    xmm0, QWORD PTR __real@4014000000000000
        cvtsd2ss xmm0, xmm0
        ret      0
```

В `/O2` `/fp:fast` созданном коде упрощен, так как все приведения типов оптимизированы:

```asm
        addss    xmm0, xmm1
        mulss    xmm0, DWORD PTR __real@40a00000
        ret      0
```

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите страницу свойств **Свойства "**  >  Создание кода**C/C++**"  >  **Code Generation** .

1. Измените свойство **модель с плавающей точкой** .

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.floatingPointModel%2A>.

## <a name="see-also"></a>См. также раздел

[Параметры компилятора MSVC](compiler-options.md)<br/>
[Синтаксис командной строки компилятора КОМПИЛЯТОРОМ MSVC](compiler-command-line-syntax.md)<br/>
