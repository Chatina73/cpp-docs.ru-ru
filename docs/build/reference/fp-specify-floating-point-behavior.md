---
title: /fp (определение поведения с плавающей запятой)
ms.date: 11/09/2018
f1_keywords:
- VC.Project.VCCLCompilerTool.floatingPointModel
- VC.Project.VCCLWCECompilerTool.FloatingPointExceptions
- /fp
- VC.Project.VCCLWCECompilerTool.floatingPointModel
- VC.Project.VCCLCompilerTool.FloatingPointExceptions
helpviewer_keywords:
- -fp compiler option [C++]
- /fp compiler option [C++]
ms.assetid: 10469d6b-e68b-4268-8075-d073f4f5d57e
ms.openlocfilehash: 402b59c4aee34a413a08235aab2327ca64e7db39
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79439683"
---
# <a name="fp-specify-floating-point-behavior"></a>/fp (определение поведения с плавающей запятой)

Указывает, как компилятор обрабатывает выражения с плавающей запятой, оптимизации и исключения. Параметры **/FP** определяют, допускает ли сформированный код изменения среды с плавающей запятой в режим округления, маски исключений и поведение в нормальном режиме, а также указывает, будут ли проверки состояния с плавающей точкой возвращать текущие и точные результаты. Он определяет, создает ли компилятор код, сохраняющий исходную операцию и порядок выражений, и соответствует стандарту для распространения NaN или, если вместо этого генерирует более эффективный код, который может переупорядочить или объединить операции и использовать упрощение Алгебраические преобразования, запрещенные стандартом.

## <a name="syntax"></a>Синтаксис

> **/FP:** [**точная** | **строго** | **fast** | **за исключением**[ **-** ]]

### <a name="arguments"></a>Аргументы

#### <a name="precise"></a>точен

По умолчанию компилятор использует поведение `/fp:precise`.

В разделе `/fp:precise` компилятор сохраняет упорядочивание выражений источника и округление свойств кода с плавающей запятой при формировании и оптимизации объектного кода для целевого компьютера. Компилятор округляет до точности исходного кода по четырем конкретным точкам во время вычисления выражения: в назначениях при приведении типов при передаче аргумента с плавающей запятой в вызов функции и при возвращении значения с плавающей запятой из вызова функции. Промежуточные вычисления могут выполняться при точности компьютеров. Приведение приведений можно использовать для явного округления промежуточных вычислений.

Компилятор не выполняет преобразования алгебраические для выражений с плавающей запятой, таких как повторное связывание или распространение, если преобразование не гарантировано приводить к появлению побитового идентичного результата.
Выражения, использующие специальные значения (NaN, + Infinity,-Infinity,-0,0), обрабатываются в соответствии со спецификациями IEEE-754. Например, `x != x` возвращает **значение true** , если x — NaN. *Контракты*с плавающей точкой, то есть машинные инструкции, которые объединяют операции с плавающей запятой, могут создаваться в разделе `/fp:precise`.

Компилятор создает код, предназначенный для выполнения в [среде с плавающей запятой по умолчанию](#the-default-floating-point-environment) , и предполагает, что среда с плавающей точкой не доступна или не изменяется во время выполнения. То есть предполагается, что код не снимает маскировку исключений с плавающей запятой, считывает или пишет регистры состояния с плавающей запятой или изменяет режим округления.

Если код с плавающей запятой не зависит от порядка операций и выражений в операторах с плавающей запятой (например, если вы не хотите, чтобы `a * b + a * c` вычислено как `(b + c) * a` или `2 * a` как `a + a`), рассмотрим параметр [/FP: Fast](#fast) , который может создавать более быстрый и эффективный код. Если код зависит от порядка операций и выражений, а также для доступа или изменения среды с плавающей запятой (например, для изменения режимов округления или для перехвата исключений с плавающей запятой) используйте [/FP:](#strict)Round.

#### <a name="strict"></a>strict

`/fp:strict` имеет поведение, аналогичное `/fp:precise`, то есть компилятор сохраняет упорядочение источника и свойства округления кода с плавающей запятой при формировании и оптимизации объектного кода для целевого компьютера и следит за стандартом при обработке специальных значений. Кроме того, программа может безопасно получать доступ к среде с плавающей точкой и изменять ее во время выполнения.

В разделе `/fp:strict`компилятор создает код, который позволяет программе безопасно отменять маскировку исключений с плавающей запятой, читать или записывать регистры состояния операций с плавающей запятой или изменять режимы округления. При вычислении выражения он округляет до точности исходного кода по четырем точкам: в назначениях при приведении типов с плавающей запятой в вызове функции и при возврате значения с плавающей запятой из вызова функции. Промежуточные вычисления могут выполняться при точности компьютеров. Приведение приведений можно использовать для явного округления промежуточных вычислений. Компилятор не выполняет преобразования алгебраические для выражений с плавающей запятой, таких как повторное связывание или распространение, если преобразование не гарантировано приводить к появлению побитового идентичного результата. Выражения, использующие специальные значения (NaN, + Infinity,-Infinity,-0,0), обрабатываются в соответствии со спецификациями IEEE-754. Например, `x != x` возвращает **значение true** , если x — NaN. В `/fp:strict`не создаются контракты с плавающей точкой.

`/fp:strict` вычислительно дороже, чем `/fp:precise`, так как компилятор должен вставлять дополнительные инструкции для перехвата исключений и позволить программам получать доступ к среде с плавающей запятой или изменять ее во время выполнения. Если код не использует эту возможность, но требует упорядочения исходного кода и округления или использует специальные значения, используйте `/fp:precise`. В противном случае рассмотрите возможность использования `/fp:fast`, что может привести к более быстрому и короткому коду.

#### <a name="fast"></a>ускоряет

Параметр `/fp:fast` позволяет компилятору изменять порядок, комбинировать или упростить операции с плавающей запятой, чтобы оптимизировать код с плавающей запятой для ускорения и пропускной точки. Компилятор может опускать округление в операторах присваивания, приведениях или вызовах функций. Он может изменять порядок операций или выполнять преобразования алгебраические, например, используя ассоциативные и дистрибутиве законы, даже если такие преобразования приводят к наблюдаемому разному поведению округления. Из-за этой улучшенной оптимизации результат некоторых вычислений с плавающей запятой может отличаться от результатов, полученных другими параметрами `/fp`. Специальные значения (NaN, + Infinity,-Infinity,-0,0) могут не распространяться или работать исключительно в соответствии со стандартом IEEE-754. При `/fp:fast`могут быть созданы контракты с плавающей точкой. Компилятор по-прежнему привязан к базовой архитектуре в разделе `/fp:fast`, а дополнительные оптимизации могут быть доступны с помощью параметра [/Arch](arch-minimum-cpu-architecture.md) .

В разделе `/fp:fast`компилятор создает код, предназначенный для выполнения в среде с плавающей запятой по умолчанию, и предполагает, что среда с плавающей запятой недоступна или не изменяется во время выполнения. То есть предполагается, что код не снимает маскировку исключений с плавающей запятой, считывает или пишет регистры состояния с плавающей запятой или изменяет режим округления.

`/fp:fast` предназначен для программ, не требующих тщательного упорядочения исходного кода и округления выражений с плавающей запятой, и не полагайтесь на стандартные правила обработки специальных значений, таких как NaN. Если код с плавающей запятой требует сохранения порядка исходного кода и округления или зависит от стандартного поведения специальных значений, используйте [/FP: точную](#precise). Если код обращается к среде с плавающей запятой или изменяет ее, чтобы изменить режим округления, снимите маску исключений с плавающей запятой или проверьте состояние с плавающей запятой, используйте [/FP:](#strict)Round.

#### <a name="except"></a>except

Параметр `/fp:except` создает код, гарантирующий, что любые немаскированные исключения с плавающей запятой вызываются в той точке, где они происходят, и что никакие дополнительные исключения с плавающей запятой не вызываются. По умолчанию параметр `/fp:strict` включает `/fp:except`, а `/fp:precise` — нет. Параметр `/fp:except` несовместим с `/fp:fast`. Параметр можно явно отключить в `/fp:except-`.

Обратите внимание, что `/fp:except` не включает исключения с плавающей запятой сами по себе, но необходимо, чтобы программы включили исключения с плавающей запятой. Сведения о том, как включить исключения с плавающей запятой, см. в разделе [_controlfp](../../c-runtime-library/reference/control87-controlfp-control87-2.md) .

## <a name="remarks"></a>Remarks

В одной командной строке компилятора можно указать несколько параметров `/fp`. Одновременно могут действовать только один из параметров `/fp:strict`, `/fp:fast`и `/fp:precise`. Если в командной строке указано более одного из этих параметров, параметр имеет более высокий приоритет, и компилятор выдает предупреждение. Параметры `/fp:strict` и `/fp:except` несовместимы с `/clr`.

Параметр [/Za](za-ze-disable-language-extensions.md) (совместимость с ANSI) несовместим с `/fp`.

### <a name="using-compiler-directives-to-control-floating-point-behavior"></a>Использование директив компилятора для управления поведением с плавающей запятой

Компилятор предоставляет три директивы директивы pragma для переопределения поведения с плавающей запятой, указанного в командной строке: [float_control](../../preprocessor/float-control.md), [fenv_access](../../preprocessor/fenv-access.md)и [fp_contract](../../preprocessor/fp-contract.md). Эти директивы можно использовать для управления поведением операций с плавающей запятой на уровне функций, а не внутри функции. Обратите внимание, что эти директивы не соответствуют непосредственно параметрам `/fp`. В этой таблице показано, как параметры `/fp` и директивы pragma сопоставляются друг с другом. Дополнительные сведения см. в документации по отдельным параметрам и директивам директивы pragma.

||float_control (точное)|float_control (за исключением)|fenv_access|fp_contract|
|-|-|-|-|-|
|`/fp:fast`|off|off|off|on|
|`/fp:precise`|on|off|off|on|
|`/fp:strict`|on|on|on|off|

### <a name="the-default-floating-point-environment"></a>Среда с плавающей точкой по умолчанию

При инициализации процесса устанавливается *Среда с плавающей точкой по умолчанию* . Эта среда маскирует все исключения с плавающей запятой, устанавливает режим округления для округления до ближайшего (`FE_TONEAREST`), сохраняет значения поднормали (денормализованные), использует точность по умолчанию значащим (мантисса) для значений **float**, **Double**и **long double** и, где поддерживается, устанавливает элемент управления бесконечности в режим аффинных по умолчанию.

### <a name="floating-point-environment-access-and-modification"></a>Доступ и изменение среды с плавающей точкой

Среда выполнения Microsoft C++ Visual среды предоставляет несколько функций для доступа к среде с плавающей запятой и ее изменения. К ним относятся [_controlfp](../../c-runtime-library/reference/control87-controlfp-control87-2.md), [_clearfp](../../c-runtime-library/reference/clear87-clearfp.md)и [_statusfp](../../c-runtime-library/reference/status87-statusfp-statusfp2.md) , а также их варианты. Чтобы обеспечить правильное поведение программы, когда код обращается к среде с плавающей запятой или изменяет ее, `fenv_access` должны быть включены либо с помощью параметра `/fp:strict`, либо с помощью директивы `fenv_access` pragma, чтобы эти функции имели какое-либо воздействие. Если `fenv_access` не включена, доступ или изменение среды с плавающей запятой может привести к непредвиденному поведению программы: код может не учитывать запрошенные изменения в среде с плавающей запятой; регистры состояния операций с плавающей запятой не могут сообщать о ожидаемых или текущих результатах; непредвиденные исключения с плавающей запятой могут возникать, а ожидаемые исключения с плавающей запятой могут не произойти.

Когда код обращается к среде с плавающей запятой или изменяет ее, необходимо соблюдать осторожность при объединении кода, в котором `fenv_access` включена с кодом, для которого не включено `fenv_access`. В коде, где `fenv_access` не включена, компилятор предполагает, что платформа с плавающей запятой по умолчанию действует и что состояние с плавающей запятой не имеет доступа или не изменяется. Рекомендуется сохранить и восстановить локальную среду с плавающей запятой до состояния по умолчанию перед передачей управления в функцию, которая не включает `fenv_access`. В этом примере показано, как можно установить и восстановить директиву pragma `float_control`.

```cpp
#pragma float_control(strict, on, push)
// Code that uses /fp:strict mode
#pragma float_control(pop)
```

### <a name="floating-point-rounding-modes"></a>Режимы округления с плавающей запятой

В обоих `/fp:precise` и `/fp:fast` компилятор создает код, предназначенный для выполнения в среде с плавающей запятой по умолчанию, и предполагает, что среда недоступна или изменена во время выполнения. То есть предполагается, что код не снимает маскировку исключений с плавающей запятой, считывает или пишет регистры состояния с плавающей запятой или изменяет режим округления.  Однако некоторым программам необходимо изменить среду с плавающей запятой. Например, в этом образце вычисляются ошибки, связанные с операциями умножения с плавающей запятой путем изменения режима округления с плавающей запятой.

```cpp
// fp_error_bounds.cpp
#include <iostream>
#include <limits>
using namespace std;

int main(void)
{
    float a = std::<float>::max();
    float b = -1.1;
    float cLower = 0.0;
    float cUpper = 0.0;
    unsigned int control_word = 0;
    int err = 0;

    // compute lower error bound.
    // set rounding mode to -infinity.
    err = _controlfp_s(&control_word, _RC_DOWN, _MCW_RC);
    if (err)
    {
        cout << "_controlfp_s(&control_word, _RC_DOWN, _MCW_RC) failed with error:" << err << endl;
    }  
    cLower = a * b;

    // compute upper error bound.
    // set rounding mode to +infinity.
    err = _controlfp_s(&control_word, _RC_UP, _MCW_RC);
    if (err)
    {
        cout << "_controlfp_s(&control_word, _RC_UP, _MCW_RC) failed with error:" << err << endl;
    }
    cUpper = a * b;

    // restore default rounding mode.
    err = _controlfp_s(&control_word, _CW_DEFAULT, _MCW_RC);
    if (err)
    {
        cout << "_controlfp_s(&control_word, _CW_DEFAULT, _MCW_RC) failed with error:" << err << endl;
    }
    // display error bounds.
    cout << "cLower = " << cLower << endl;
    cout << "cUpper = " << cUpper << endl;
    return 0;
}
```

Так как компилятор предполагает, что среда с плавающей запятой по умолчанию находится в `/fp:fast` и `/fp:precise` можно игнорировать вызовы `_controlfp_s`. Например, при компиляции с использованием как `/O2`, так `/fp:precise` для архитектуры x86, границы не вычисляются, а образец программы выводит:

```Output
cLower = -inf
cUpper = -inf
```

При компиляции с `/O2` и `/fp:strict` архитектуры x86 пример программы выводит:

```Output
cLower = -inf
cUpper = -3.40282e+38
```

### <a name="floating-point-special-values"></a>Специальные значения с плавающей точкой

В разделах `/fp:precise` и `/fp:strict`выражения, использующие специальные значения (NaN, + Infinity,-Infinity,-0,0), ведут себя в соответствии со спецификациями IEEE-754. В `/fp:fast`поведение этих специальных значений может быть несоответствующим стандарту IEEE-754.

В этом примере демонстрируется другое поведение специальных значений в разделах `/fp:precise`, `/fp:strict` и `/fp:fast`.

```cpp
// fp_special_values.cpp
#include <stdio.h>
#include <cmath>

float gf0 = -0.0;

int main()
{
    float f1 = INFINITY;
    float f2 = NAN;
    float f3 = -INFINITY;
    bool a, b;
    float c, d, e;
    a = (f1 == f1);
    b = (f2 == f2);
    c = (f1 - f1);
    d = (f2 - f2);
    printf("INFINITY == INFINITY : %d\n", a);
    printf("NAN == NAN           : %d\n", b);
    printf("INFINITY - INFINITY  : %f\n", c);
    printf("NAN - NAN            : %f\n", d);

    e = gf0 / abs(f3);
    printf("std::signbit(-0.0/-INFINITY): %d\n", std::signbit(c));
    return 0;
}
```

При компиляции с `/O2` `/fp:precise` или `/O2` `/fp:strict` для архитектуры x86 выходные данные согласуются со спецификацией IEEE-754:

```Output
INFINITY == INFINITY : 1
NAN == NAN           : 0
INFINITY - INFINITY  : -nan(ind)
NAN - NAN            : -nan(ind)
std::signbit(-0.0/-INFINITY): 1
```

При компиляции с `/O2` `/fp:fast` для архитектуры x86 выходные данные не согласуются с IEEE-754:

```Output
INFINITY == INFINITY : 1
NAN == NAN           : 1
INFINITY - INFINITY  : 0.000000
NAN - NAN            : 0.000000
std::signbit(-0.0/-INFINITY): 0
```

### <a name="floating-point-algebraic-transformations"></a>Преобразования алгебраические с плавающей точкой

В разделе `/fp:precise` и `/fp:strict`компилятор не выполняет математические преобразования, если только преобразование не гарантировано создает побитовый идентичный результат. Компилятор может выполнять такие преобразования в `/fp:fast`. Например, выражение `a * b + a * c` в примере функции `algebraic_transformation` может быть скомпилировано в `a * (b + c)` в `/fp:fast`. Такие преобразования не выполняются в `/fp:precise` или `/fp:strict`, и компилятор создает `a * b + a * c`.

```cpp
float algebraic_transformation (float a, float b, float c)
{
    return a * b + a * c;
}
```

### <a name="floating-point-explicit-casting-points"></a>Явные точки приведения с плавающей точкой

В разделе `/fp:precise` и `/fp:strict`компилятор округляет до точности исходного кода на четырех конкретных точках во время вычисления выражения: в назначениях при приведении типов при передаче аргумента с плавающей запятой в вызов функции и при возвращении значения с плавающей запятой из вызова функции. Приведение приведений можно использовать для явного округления промежуточных вычислений. В разделе `/fp:fast`компилятор не создает явные приведения на этих точках, чтобы гарантировать точность исходного кода. В этом примере демонстрируется поведение при использовании различных параметров `/fp`.

```cpp
float casting(float a, float b)
{
    return 5.0*((double)(a+b));
}
```

При компиляции с помощью `/O2` `/fp:precise` или `/O2` `/fp:strict`можно увидеть, что явные приведения типов вставляются как в приведении, так и в точке возврата функции в созданном коде для архитектуры x64:

```asm
        addss    xmm0, xmm1
        cvtss2sd xmm0, xmm0
        mulsd    xmm0, QWORD PTR __real@4014000000000000
        cvtsd2ss xmm0, xmm0
        ret      0
```

В разделе `/O2` `/fp:fast` созданный код упрощен, так как все приведения типов оптимизированы:

```asm
        addss    xmm0, xmm1
        mulss    xmm0, DWORD PTR __real@40a00000
        ret      0
```

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите **Свойства конфигурации** > странице свойств **создания кода** **C++ C/**  > .

1. Измените свойство **модель с плавающей точкой** .

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.floatingPointModel%2A>.

## <a name="see-also"></a>См. также раздел

[Параметры компилятора MSVC](compiler-options.md)<br/>
[Синтаксис командной строки компилятора MSVC](compiler-command-line-syntax.md)<br/>
 