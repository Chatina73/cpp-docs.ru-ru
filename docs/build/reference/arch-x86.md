---
title: /arch (x86)
ms.date: 10/01/2019
ms.assetid: 9dd5a75d-06e4-4674-aade-33228486078d
ms.openlocfilehash: b1e5501f6edd3eb016395380ff476250c0c388b9
ms.sourcegitcommit: 4517932a67bbf2db16cfb122d3bef57a43696242
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/02/2019
ms.locfileid: "71816319"
---
# <a name="arch-x86"></a>/arch (x86)

Задает архитектуру для создания кода на платформе x86. См. также: [/Arch (x64)](arch-x64.md) и [/Arch (ARM)](arch-arm.md).

## <a name="syntax"></a>Синтаксис

```
/arch:[IA32|SSE|SSE2|AVX|AVX2|AVX512]
```

## <a name="arguments"></a>Аргументы

**/Arch: IA32**<br/>
Указывает на то, что расширенные инструкции не используются. Также указывает на использование инструкций x87 для вычислений с плавающей запятой.

**/Arch: SSE**<br/>
Позволяет использовать инструкции SSE.

**/Arch: SSE2**<br/>
Позволяет использовать инструкции SSE2. Это инструкция по умолчанию на платформах x86, если не указан параметр **/Arch** .

**/Arch: AVX**<br/>
Позволяет использовать инструкции Intel AVX.

**/Arch: AVX2**<br/>
Позволяет использовать инструкции Intel AVX 2.

**/Arch: AVX512**<br/>
Включает использование инструкций Intel Advanced Vector Extensions 512.

## <a name="remarks"></a>Примечания

Параметр **/Arch** включает или отключает использование определенных расширений набора инструкций, особенно для векторного вычисления, доступного в процессорах от Intel и AMD. Как правило, более новые процессоры могут поддерживать дополнительные расширения, поддерживаемые более старыми процессорами, хотя вы должны обратиться к документации по конкретному процессору или проверить поддержку расширения набора инструкций с помощью [__. CPUID](../../intrinsics/cpuid-cpuidex.md) перед выполнением кода с помощью расширения набора инструкций.

**/Arch** влияет только на создание кода для собственных функций. При использовании [параметра/clr](clr-common-language-runtime-compilation.md) для компиляции **/Arch** не влияет на создание кода для управляемых функций.

Параметры **/Arch** ссылаются на расширения набора инструкций со следующими характеристиками.

- **IA32** — это устаревший, 32-разрядный набор инструкций x86 без каких-либо векторных операций и использование x87 для вычислений с плавающей запятой.

- **SSE** позволяет выполнять вычисления с векторами до четырех значений с плавающей запятой одиночной точности. Также были добавлены соответствующие скалярные инструкции с плавающей точкой.

- **SSE2** позволяет выполнять вычисление с 128-битным вектором с одинарной точностью, двойной точностью и 1, 2, 4 или 8-байтным целочисленным значением. Также были добавлены скалярные инструкции двойной точности.

- **AVX** представил альтернативную кодировку для векторных и скалярных инструкций с плавающей запятой, которая допускает векторы 128 бит или 256 бит, а также нулевое расширение всех векторных результатов до полного размера вектора. (Для совместимости с предыдущими версиями в случае с векторными инструкциями в формате SSE сохраняются все биты, кроме бита 127.) Большинство операций с плавающей запятой расширены до 256 бит.

- **AVX2** расширяет большинство целочисленных операций до 256-разрядных векторов и позволяет использовать инструкции по добавлению плавких предохранителей (FMA).

- В **AVX512** появилась еще одна форма кодирования инструкций, которая допускает 512-разрядные векторы, а также некоторые другие дополнительные функции. Также были добавлены инструкции для дополнительных операций.

Оптимизатор выбирает, когда и как использовать векторные инструкции в зависимости от того, какой параметр **/Arch** указан. Скалярные вычисления с плавающей запятой выполняются с инструкциями SSE или AVX, если они доступны. Некоторые соглашения о вызовах указывают передачу аргументов с плавающей запятой в стеке x87. в результате код может использовать сочетание инструкций x87 и SSE/AVX для вычислений с плавающей запятой. Инструкции целочисленного вектора также можно использовать для некоторых 64-разрядных целочисленных операций, если они доступны.

Помимо векторных и скалярных инструкций с плавающей запятой, каждый параметр **/Arch** может также разрешить использование других невекторных инструкций, связанных с этим параметром. Примером является семейство инструкций Кмовкк, которое впервые появилось на процессорах Intel Pentium Pro. Поскольку инструкции SSE появились в последующем процессоре Intel Pentium III, инструкции Кмовкк могут быть созданы, за исключением случаев, когда указан параметр **/arch: IA32** .

Операции с плавающей запятой обычно округляются до двойной точности (64-бит) в коде x87, но можно использовать `_controlfp`, чтобы изменить управляющее слово FP, включая установку элемента управления точности с расширенной точностью (80-бит) или одинарную точность (32-bit). Дополнительные сведения см. в разделе [_control87, _controlfp, \__control87_2](../../c-runtime-library/reference/control87-controlfp-control87-2.md). SSE и AVX имеют отдельные инструкции с одинарной точностью и двойной точностью для каждой операции, поэтому не существует эквивалента для кода SSE/AVX. Это может изменить способ округления результатов, когда результат операции с плавающей запятой используется непосредственно в дальнейших вычислениях, вместо того чтобы назначать его пользовательской переменной. Рассмотрим следующий пример.

```cpp
r = f1 * f2 + d;  // Different results are possible on SSE/SSE2.
```

При явном назначении:

```cpp
t = f1 * f2;   // Do f1 * f2, round to the type of t.
r = t + d;     // This should produce the same overall result
               // whether x87 stack is used or SSE/SSE2 is used.
```

**/Arch** и [/QIfist](qifist-suppress-ftol.md) нельзя использовать в одном компилируемого объекта. Параметр **/QIfist** изменяет режим округления при преобразовании с плавающей запятой на целое число. По умолчанию используется усечение (округление в сторону нуля), в то время как параметр **/QIfist** задает использование режима округления в среде с плавающей запятой. Так как это изменяет поведение всех преобразований с плавающей запятой на целые числа, этот флаг является устаревшим. При компиляции для SSE или AVX можно округлить значение с плавающей запятой до целого, используя режим округления в среде с плавающей запятой, используя встроенную последовательность функций:

```cpp
int convert_float_to_int(float x) {
    return _mm_cvtss_si32(_mm_set_ss(x));
}

int convert_double_to_int(double x) {
    return _mm_cvtsd_si32(_mm_set_sd(x));
}
```

Макросы `_M_IX86_FP`, `__AVX__`, `__AVX2__`, `__AVX512F__`, `__AVX512CD__`, `__AVX512BW__`, `__AVX512DQ__` и `__AVX512VL__` указывают, какой параметр компилятора **/Arch** был использован. Для получения дополнительной информации см. [Predefined Macros](../../preprocessor/predefined-macros.md). Параметр **/arch: AVX2** и макрос `__AVX2__` были введены в Visual Studio 2013 обновление 2, версия 12.0.34567.1. Ограниченная поддержка **/arch: AVX512** была добавлена в visual Studio 2017 и развернута в visual Studio 2019.

### <a name="to-set-this-compiler-option-for-avx-avx2-avx512-ia32-sse-or-sse2-in-visual-studio"></a>Установка этого параметра компилятора для AVX, AVX2, AVX512, IA32, SSE или SSE2 в Visual Studio

1. Откройте диалоговое окно **страницы свойств** для проекта. Подробнее см. в статье [Настройка компилятора C++ и свойств сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите **Свойства конфигурации**, папку **C/C++**  .

1. Выберите страницу свойств **Создание кода** .

1. Измените свойство **включить расширенную инструкцию SET** .

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.EnableEnhancedInstructionSet%2A>.

## <a name="see-also"></a>См. также

[/arch (минимальная архитектура ЦПУ)](arch-minimum-cpu-architecture.md)<br/>
[Параметры компилятора MSVC](compiler-options.md)<br/>
[Синтаксис командной строки компилятора MSVC](compiler-command-line-syntax.md)
