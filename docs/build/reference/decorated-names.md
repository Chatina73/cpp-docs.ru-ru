---
title: Внутренние имена
ms.date: 09/05/2018
helpviewer_keywords:
- decorated names, definition
- name decoration [C++]
- names [C++], decorated
ms.assetid: a4e9ae8e-b239-4454-b401-4102793cb344
ms.openlocfilehash: f6d81029d20d9aaca96ff184f48e94a9ce35d56e
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81320505"
---
# <a name="decorated-names"></a>Внутренние имена

Функции, данные и объекты в программах на языках C и C++ внутренне представляются декорированными именами. *Украшенное имя* — это закодированная строка, созданная компилятором во время компиляции объекта, данных или определения функций. Оно содержит соглашения о вызовах, типы, параметры функции и другие сведения, а также имя. Это имя украшения, также известный как *имя mangling*, помогает linker найти правильные функции и объекты при соединении исполняемой.

Украшенные именования конвенций изменились в различных версиях Visual Studio, а также может быть различным на различных целевых архитектур. Для правильной связи с исходными файлами, созданными с помощью Visual Studio, DLL и библиотек и библиотек C и C', следует собирать с помощью одного и того же набора инструментов компилятора, флагов и целевой архитектуры.

> [!NOTE]
> Библиотеки, построенные с Visual Studio 2015, могут быть использованы приложениями, построенными с Visual Studio 2017 или Visual Studio 2019.

## <a name="using-decorated-names"></a><a name="Using"></a>Использование украшенных имен

Как правило, не нужно знать внутреннее имя, чтобы написать код, который успешно компилируется и компонуется. Внутренние имена — это внутренние средства для компилятора и компоновщика. Инструменты обычно могут обрабатывать имя в недекорированной форме. Тем не менее внутреннее имя иногда требуется при указании имени функции для компоновщика и других средств. Например, для сопоставления перегруженных функций C++, элементов пространств имен, конструкторов, деструкторов и специальных функций-членов класса, необходимо указать внутреннее имя. Дополнительные сведения о флагах и других ситуациях, для которых требуются внутренние имена, см. в документации по средствам и параметрам, которые вы используете.

При изменении имени функции, класса, соглашении о вызовах, типа возвращаемого значения или какого-либо параметра внутреннее имя также изменяется. В этом случае необходимо получить новое внутреннее имя и использовать его везде, где оно указано.

Декорирование имен также важно при компоновке с кодом, написанным на других языках программирования, или при использовании других компиляторов. Разные компиляторы используют различные соглашения о дополнении имен. Если исполняемый файл связывается с кодом, написанным на другом языке, необходимо уделить особое внимание сопоставлению экспортированных и импортированных параметров и соглашений о вызовах. Языкассамблея должен использовать имена украшенных MSVC и вызывать конвенции для ссылки на исходный код, написанный с помощью MSVC.

## <a name="format-of-a-c-decorated-name"></a><a name="Format"></a>Формат украшенного имени СЗ

Внутреннее имя функции C++ содержит следующие сведения.

- Имя функции.

- Класс, членом которого является функция, если это функция-член. Это может быть класс, в который входит содержащий функцию класс, и т. д.

- Пространство имен, которой принадлежит функция, если она входит в пространство имен.

- Типы параметров функции.

- Соглашение о вызовах.

- Тип значения, возвращаемого функцией.

Имена функций и классов кодируются во внутреннем имени. Остальная часть внутреннего имени — это код, который имеет смысл только для компилятора и компоновщика. Ниже приведены примеры внешних и внутренних имен C++.

|Внешнее имя|Внутреннее имя|
|----------------------|--------------------|
|`int a(char){int i=3;return i;};`|`?a@@YAHD@Z`|
|`void __stdcall b::c(float){};`|`?c@b@@AAGXM@Z`|

## <a name="format-of-a-c-decorated-name"></a><a name="FormatC"></a>Формат c украшенного имени

Формат декорирования для функции C зависит от соглашения о вызовах, используемого в ее объявлении, как показано в следующей таблице. Этот же формат используется, если в коде C++ объявлена компоновка `extern "C"`. Соглашение о вызовах по умолчанию — `__cdecl`. Обратите внимание, что в 64-разрядной среде, функции не декорируются.

|Соглашение о вызовах|Оформление|
|------------------------|----------------|
|`__cdecl`|Ведущий подчеркнуть (**)**|
|`__stdcall`|Ведущий подчеркнуть (**)** и отставание**\@** на знак ( ) следуют количество байтов в списке параметров в десятичной|
|`__fastcall`|Ведущая и трейдинговая по знакам ()**\@** с последующим десятичным числом, представляющим количество байтов в списке параметров|
|`__vectorcall`|Два трейлинга**\@** на знаках () с последующим десятичным числом байтов в списке параметров|

## <a name="viewing-decorated-names"></a><a name="Viewing"></a>Просмотр украшенных имен

Вы можете получить внутреннюю форму имени символа после компиляции исходного файла, содержащего данные, объект, определение или прототип функции. Для просмотра внутренних имен в программе можно использовать один из следующих методов.

#### <a name="to-use-a-listing-to-view-decorated-names"></a>Использование листинга для просмотра внутренних имен

1. Создайте список путем компиляции исходного файла, содержащего определение данных, объекта или функции или прототипа с опцией компилятора [типа листинга,](fa-fa-listing-file.md) установленной для сборки с исходным кодом (**/FAs**).

   Например, `cl /c /FAs example.cpp` введите запрос команды разработчика для создания файла листинга, example.asm.

2. В полученном файле листинга найдите строку, которая начинается с PUBLIC и завершается точкой с запятой, за которой следует внешнее имя данных или функции. Символ между PUBLIC и точкой с запятой представляет внутреннее имя.

#### <a name="to-use-dumpbin-to-view-decorated-names"></a>Использование служебной программы DUMPBIN для просмотра внутренних имен

1. Чтобы увидеть экспортированные символы в файле .obj или .lib, введите `dumpbin /symbols` `objfile` запрос команды разработчика.

2. Чтобы найти внутреннюю форму символа, найдите внешнее имя в скобках. Украшенное имя находится на той же линии, после символа трубы (&#124;) и перед неукрашенным именем.

## <a name="viewing-undecorated-names"></a><a name="Undecorated"></a>Просмотр неукрашенных имен

Можно использовать программу undname.exe для преобразования внутреннего имени в недекорированную форму. В этом примере показано, как это работает.

```
C:\>undname ?func1@a@@AAEXH@Z
Microsoft (R) C++ Name Undecorator
Copyright (C) Microsoft Corporation. All rights reserved.

Undecoration of :- "?func1@a@@AAEXH@Z"
is :- "private: void __thiscall a::func1(int)"
```

## <a name="see-also"></a>См. также раздел

[Дополнительные инструменты сборки MSVC](c-cpp-build-tools.md)<br/>
[Использование ключевого слова extern для задания компоновки](../../cpp/using-extern-to-specify-linkage.md)
