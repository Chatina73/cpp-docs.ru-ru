---
title: Внутренние имена
ms.date: 09/05/2018
helpviewer_keywords:
- decorated names, definition
- name decoration [C++]
- names [C++], decorated
ms.assetid: a4e9ae8e-b239-4454-b401-4102793cb344
ms.openlocfilehash: 20e7f5855b771caf23217e5c17db50a890e28113
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87223854"
---
# <a name="decorated-names"></a>Внутренние имена

Функции, данные и объекты в программах на языках C и C++ внутренне представляются декорированными именами. *Декорированное имя* представляет собой закодированную строку, созданную компилятором во время компиляции объекта, данных или определения функции. Оно содержит соглашения о вызовах, типы, параметры функции и другие сведения, а также имя. Это декорирование имен, также называемое *искажением имен*, помогает компоновщику находить правильные функции и объекты при связывании исполняемого файла.

Декорированные соглашения об именовании изменились в различных версиях Visual Studio и могут отличаться в разных целевых архитектурах. Для правильной связи с исходными файлами, созданными с помощью Visual Studio, библиотеки DLL и библиотеки C++ должны быть скомпилированы с использованием того же набора инструментов компилятора, флагов и целевой архитектуры.

> [!NOTE]
> Библиотеки, созданные с помощью Visual Studio 2015, можно использовать в приложениях, созданных с помощью Visual Studio 2017 или Visual Studio 2019.

## <a name="using-decorated-names"></a><a name="Using"></a>Использование декорированных имен

Как правило, не нужно знать внутреннее имя, чтобы написать код, который успешно компилируется и компонуется. Внутренние имена — это внутренние средства для компилятора и компоновщика. Инструменты обычно могут обрабатывать имя в недекорированной форме. Тем не менее внутреннее имя иногда требуется при указании имени функции для компоновщика и других средств. Например, для сопоставления перегруженных функций C++, элементов пространств имен, конструкторов, деструкторов и специальных функций-членов класса, необходимо указать внутреннее имя. Дополнительные сведения о флагах и других ситуациях, для которых требуются внутренние имена, см. в документации по средствам и параметрам, которые вы используете.

При изменении имени функции, класса, соглашении о вызовах, типа возвращаемого значения или какого-либо параметра внутреннее имя также изменяется. В этом случае необходимо получить новое внутреннее имя и использовать его везде, где оно указано.

Декорирование имен также важно при компоновке с кодом, написанным на других языках программирования, или при использовании других компиляторов. Разные компиляторы используют различные соглашения о дополнении имен. Если исполняемый файл связывается с кодом, написанным на другом языке, необходимо уделить особое внимание сопоставлению экспортированных и импортированных параметров и соглашений о вызовах. Код языка ассемблера должен использовать декорированные имена КОМПИЛЯТОРОМ MSVC и соглашения о вызовах для ссылки на исходный код, написанный с помощью КОМПИЛЯТОРОМ MSVC.

## <a name="format-of-a-c-decorated-name"></a><a name="Format"></a>Формат декорированного имени C++

Внутреннее имя функции C++ содержит следующие сведения.

- Имя функции.

- Класс, членом которого является функция, если это функция-член. Это может быть класс, в который входит содержащий функцию класс, и т. д.

- Пространство имен, которой принадлежит функция, если она входит в пространство имен.

- Типы параметров функции.

- Соглашение о вызовах.

- Тип значения, возвращаемого функцией.

Имена функций и классов кодируются во внутреннем имени. Остальная часть внутреннего имени — это код, который имеет смысл только для компилятора и компоновщика. Ниже приведены примеры внешних и внутренних имен C++.

|Внешнее имя|Внутреннее имя|
|----------------------|--------------------|
|`int a(char){int i=3;return i;};`|`?a@@YAHD@Z`|
|`void __stdcall b::c(float){};`|`?c@b@@AAGXM@Z`|

## <a name="format-of-a-c-decorated-name"></a><a name="FormatC"></a>Формат декорированного имени C

Формат декорирования для функции C зависит от соглашения о вызовах, используемого в ее объявлении, как показано в следующей таблице. Этот же формат используется, если в коде C++ объявлена компоновка `extern "C"`. По умолчанию используется соглашение о вызовах **`__cdecl`** . Обратите внимание, что в 64-разрядной среде, функции не декорируются.

|Соглашение о вызовах|Оформление|
|------------------------|----------------|
|**`__cdecl`**|Символ подчеркивания в начале ( **`_`** )|
|**`__stdcall`**|Начальный символ подчеркивания () и символ в конце **`_`** знака ( **`@`** ), за которым следует число байтов в списке параметров в десятичном формате|
|**`__fastcall`**|Начальные и конечные знаки в **`@`** символах (), за которыми следует десятичное число, представляющее число байтов в списке параметров|
|**`__vectorcall`**|Две конечные знаки in ( **`@@`** ), за которыми следует десятичное число байтов в списке параметров|

## <a name="viewing-decorated-names"></a><a name="Viewing"></a>Просмотр декорированных имен

Вы можете получить внутреннюю форму имени символа после компиляции исходного файла, содержащего данные, объект, определение или прототип функции. Для просмотра внутренних имен в программе можно использовать один из следующих методов.

#### <a name="to-use-a-listing-to-view-decorated-names"></a>Использование листинга для просмотра внутренних имен

1. Создайте список, выполнив компиляцию исходного файла, содержащего данные, объект или определение функции или прототип с параметром компилятора [Тип файла листинга](fa-fa-listing-file.md) , установленным в Assembly с исходным кодом (**/FAS**).

   Например, введите `cl /c /FAs example.cpp` в командной строке разработчика, чтобы создать файл листинга, example. asm.

2. В полученном файле листинга найдите строку, которая начинается с PUBLIC и завершается точкой с запятой, за которой следует внешнее имя данных или функции. Символ между PUBLIC и точкой с запятой представляет внутреннее имя.

#### <a name="to-use-dumpbin-to-view-decorated-names"></a>Использование служебной программы DUMPBIN для просмотра внутренних имен

1. Чтобы просмотреть экспортированные символы в obj-или LIB-файле, введите `dumpbin /symbols` `objfile` в командной строке разработчика.

2. Чтобы найти внутреннюю форму символа, найдите внешнее имя в скобках. Декорированное имя находится на той же строке после символа вертикальной черты (&#124;) и перед недекорированным именем.

## <a name="viewing-undecorated-names"></a><a name="Undecorated"></a>Просмотр недекорированных имен

Можно использовать программу undname.exe для преобразования внутреннего имени в недекорированную форму. В этом примере показано, как это работает.

```
C:\>undname ?func1@a@@AAEXH@Z
Microsoft (R) C++ Name Undecorator
Copyright (C) Microsoft Corporation. All rights reserved.

Undecoration of :- "?func1@a@@AAEXH@Z"
is :- "private: void __thiscall a::func1(int)"
```

## <a name="see-also"></a>См. также статью

[Дополнительные средства сборки КОМПИЛЯТОРОМ MSVC](c-cpp-build-tools.md)<br/>
[Использование ключевого слова extern для задания компоновки](../../cpp/using-extern-to-specify-linkage.md)
