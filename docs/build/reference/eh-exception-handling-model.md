---
title: /EH (модель обработки исключений)
description: Справочное руководство по опциям компилятора компилятора Microsoft C 'EH (модель обработки исключений) в Visual Studio.
ms.date: 04/14/2020
f1_keywords:
- VC.Project.VCCLWCECompilerTool.ExceptionHandling
- /eh
- VC.Project.VCCLCompilerTool.ExceptionHandling
helpviewer_keywords:
- exception handling, compiler model
- cl.exe compiler, exception handling
- EH compiler option [C++]
- -EH compiler option [C++]
- /EH compiler option [C++]
no-loc:
- SEH
- try
- catch
- throw
- extern
- finally
- noexcept
ms.assetid: 754b916f-d206-4472-b55a-b6f1b0f2cb4d
ms.openlocfilehash: 68d6af657e7c20c0f5e84674dd91803beb35fba0
ms.sourcegitcommit: 0e4feb35b47c507947262d00349d4a893863a6d3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/15/2020
ms.locfileid: "81396294"
---
# <a name="eh-exception-handling-model"></a>/EH (модель обработки исключений)

Определяет поддержку модели обработки исключений, генерируемую компилятором. Аргументы указывают, `catch(...)` следует ли применять синтаксис как к структурированным, так и throw к стандартным исключениям СЗ, предполагается ли **noexcept** ** extern код "C"** с исключениями и следует ли оптимизировать некоторые проверки.

## <a name="syntax"></a>Синтаксис

> **`/EHa`**[**`-`**]\
> **`/EHs`**[**`-`**]\
> **`/EHc`**[**`-`**]\
> **`/EHr`**[**`-`**]

## <a name="arguments"></a>Аргументы

**`a`**\
Позволяет раскручивать стандартный стек СЗЗ. При использовании `catch(...)` синтаксиса ловит как структурированные (асинхронные), так и стандартные исключения с се (синхронными). **`/EHa`** перекрывает **`/EHs`** **`/EHc`** и аргументы, и аргументы.

**`s`**\
Позволяет раскручивать стандартный стек СЗЗ. Ловит только стандартные исключения C, `catch(...)` когда вы используете синтаксис. Если **`/EHc`** не указано также, компилятор предполагает, throw что функции, объявленные ** extern как "C",** могут быть исключением с КЗ.

**`c`**\
При использовании с **`/EHs`**, компилятор предполагает, что функции, ** extern объявленные как "C"** никогда не throw исключение C. Он не имеет никакого **`/EHa`** эффекта **`/EHca`** при использовании с (то есть, эквивалентно **`/EHa`**). **`/EHc`** игнорируется, **`/EHs`** если **`/EHa`** указаны или не указаны.

**`r`**\
Сообщает компилятору всегда создавать проверки прекращения выполнения для всех **noexcept** функций. По умолчанию проверки **noexcept** времени выполнения могут быть оптимизированы, если компилятор определяет функцию вызова только небросающих функций. Эта опция обеспечивает строгое соответствие СЗ за счет некоторого дополнительного кода. **`/EHr`** игнорируется, **`/EHs`** если **`/EHa`** указаны или не указаны.

**`-`**\
Очищает предыдущий аргумент опции. Например, **`/EHsc-`** интерпретируется как **`/EHs /EHc-`** **`/EHs`**, и эквивалентно .

**`/EH`** аргументы могут быть указаны отдельно или в сочетании, в любом порядке. Если указывается несколько экземпляров одного и того же аргумента, последний переопределяет предыдущие.  Например, **`/EHr- /EHc /EHs`** то же **`/EHscr-`** самое, что **`/EHscr- /EHr`** и **`/EHscr`** эффект.

## <a name="remarks"></a>Remarks

### <a name="default-exception-handling-behavior"></a>Поведение обработки исключений по умолчанию

Компилятор всегда генерирует код, поддерживающий асинхронную структурированную обработку исключений ().SEH По умолчанию (т.е. если нет, **`/EHsc`** **`/EHs`** или **`/EHa`** опция указана), компилятор поддерживает SEH обработчиков в родной оговорке C. `catch(...)` Тем не менее, он также генерирует код, который лишь частично поддерживает исключения СЗ. Исключение исключения по умолчанию, раскручивающее код, не [try](../../cpp/try-throw-and-catch-statements-cpp.md) уничтожает автоматические объекты C'' за пределами блоков, которые выходят за рамки из-за исключения. Утечка ресурсов и неопределенное поведение могут привести к тому, что исключение с кинуло.

### <a name="standard-c-exception-handling"></a>Стандартная обработка исключений СЗ

Полная поддержка компилятора для модели обработки исключений **`/EHsc`** Standard C, которая безопасно раскручивает объекты стека, требует (рекомендуется), **`/EHs`** или **`/EHa`**.

Если вы **`/EHs`** **`/EHsc`** используете `catch(...)` или , то catch ваши положения не асинхронные структурированные исключения. Любые нарушения <xref:System.Exception?displayProperty=fullName> доступа и управляемые исключения не доявляются. И объекты в области при возникновении асинхронного исключения не уничтожаются, даже если код обрабатывает асинхронное исключение. Такое поведение является аргументом для того, чтобы оставить структурированные исключения без обработки. Вместо этого, считайте эти исключения фатальными.

При **`/EHs`** использовании **`/EHsc`** или использовании компилятор предполагает, **throw** что исключения могут возникать только в выписке или при вызове функции. Это предположение позволяет компилятору устранить код для отслеживания срока службы многих неуправляемых объектов, что может значительно уменьшить размер кода. Если вы **`/EHa`** используете, ваше исполняемое изображение может быть больше и медленнее, потому что компилятор не оптимизирует **try** блоки так агрессивно. Он также оставляет в исключениях фильтры, которые автоматически очищают локальные throw объекты, даже если компилятор не видит кода, который может быть исключением из C..

### <a name="structured-and-standard-c-exception-handling"></a>Структурированная и стандартная обработка исключений сОт

Опция **`/EHa`** компилятора обеспечивает безопасное раскручивание стека как для асинхронных исключений, так и для исключений C.'. Он поддерживает обработку как стандартных сИ, так и структурированных исключений с помощью родного клаузулы C'. `catch(...)` Для SEH реализации **`/EHa`** без указания можно использовать **__try,** **__except**и **__finally** синтаксис. Для получения дополнительной информации [см.](../../cpp/structured-exception-handling-c-cpp.md)

> [!IMPORTANT]
> Определение **`/EHa`** и попытка обработки всех `catch(...)` исключений с помощью может быть опасной. В большинстве случаев восстановление после асинхронного исключения невозможно, и такие исключения следует считать неустранимыми. При их перехвате и продолжении работы возможно повреждение процесса и возникновение ошибок, которые трудно обнаружить и исправить.
>
> Несмотря на поддержку SEHWindows и Visual C, мы настоятельно рекомендуем использовать обработку исключений iSO-стандарта с применением s (или).**`/EHsc`** **`/EHs`** Это делает ваш код более портативным и гибким. Иногда все еще могут быть SEH случаи, когда вы должны использовать в устаревшем коде или для определенных видов программ. Это требуется в коде, составленном для поддержки общего времени выполнения языка[(/clr),](clr-common-language-runtime-compilation.md)например. Для получения дополнительной информации [см.](../../cpp/structured-exception-handling-c-cpp.md)
>
> Мы рекомендуем никогда не связывать **`/EHa`** файлы объектов, составленные с использованием файлов, составленных с использованием **`/EHs`** или **`/EHsc`** в одном и том же исполняемом модуле. Если вам приходится обрабатывать асинхронное исключение, **`/EHa`** **`/EHa`** используя любой элемент модуля, используйте для компиляции всего кода в модуле. Можно использовать структурированный синтаксис обработки исключений в том **`/EHs`** же модуле, что и код, компилированный с помощью. Тем не менее, вы SEH не можете смешивать синтаксис с КЗ **try**, **throw** и **catch** в той же функции.

Используйте, **`/EHa`** если catch вы хотите, чтобы исключение, **throw** которое подняло что-то другое, чем . В этом примере создается и перехватывается структурированное исключение:

```cpp
// compiler_options_EHA.cpp
// compile with: /EHa
#include <iostream>
#include <excpt.h>
using namespace std;

void fail()
{
    // generates SE and attempts to catch it using catch(...)
    try
    {
        int i = 0, j = 1;
        j /= i;   // This will throw a SE (divide by zero).
        printf("%d", j);
    }
    catch(...)
    {
        // catch block will only be executed under /EHa
        cout << "Caught an exception in catch(...)." << endl;
    }
}

int main()
{
    __try
    {
        fail();
    }

    // __except will only catch an exception here
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // if the exception was not caught by the catch(...) inside fail()
        cout << "An exception was caught in __except." << endl;
    }
}
```

### <a name="exception-handling-under-clr"></a>Обработка исключений под /clr

Опция **`/clr`** **`/EHa`** подразумевает (то **`/clr /EHa`** есть, является излишним). Компилятор генерирует ошибку, если **`/EHs`** или **`/EHsc`** используется после **`/clr`**. Оптимизация не влияет на это поведение. При ловле исключения компилятор вызывает деструкторов класса для любых объектов, которые находятся в той же области, что и исключение. Если исключение не поймано, эти деструктора не запускаться.

Для получения информации **`/clr`** об ограничениях на обработку исключений [в](../../c-runtime-library/reference/set-se-translator.md)соответствии с _set_se_translator см.

### <a name="runtime-exception-checks"></a>Проверки исключений в течение выполнения

Опция **`/EHr`** заставляет проверки прерывания выполнения **noexcept** во всех функциях, которые имеют атрибут. По умолчанию проверки времени выполнения могут быть оптимизированы, если бэк-энд компилятора определяет, что функция вызывает только *небросающие* функции. К функциям, не создающим исключения, относятся все функции с атрибутом, указывающим, что исключения не создаются. Они включают **noexcept** в `throw()` `__declspec(nothrow)`себя функции, отмеченные, и, когда **`/EHc`** указано, ** extern "C"** функции. К функциям, не создающим исключения, также относятся функции, которые компилятор путем проверки определяет как не создающие исключения. Вы можете явно установить поведение **`/EHr-`** по умолчанию с помощью .

Атрибут, не бросающийся, не является гарантией того, что исключения не могут быть брошены функцией. В отличие от **noexcept** поведения функции, компилятор MSVC рассматривает `throw()` `__declspec(nothrow)`исключение, брошенное функцией, объявленной с использованием, или ** extern "C"** как неопределенное поведение. Функции, использовавающие эти три атрибута декларирования, не обеспечивают соблюдение проверок завершения выполнения для исключений. Можно использовать **`/EHr`** опцию, чтобы помочь определить это неопределенное поведение, заставив компилятор **noexcept** генерировать проверки времени выполнения для необработанных исключений, которые избегают функции.

## <a name="set-the-option-in-visual-studio-or-programmatically"></a>Установите опцию в Visual Studio или программно

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите Поколение кода **конфигурации** > **C/C'.** > **Code Generation**.

1. Измените значение свойства **Включить C++ исключения** .

   Можно также задать для параметра **Включить C++ исключения** значение **Нет**, а затем на странице свойств **Командная строка** в поле **Дополнительные параметры** добавить параметр компилятора.

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A>.

## <a name="see-also"></a>См. также раздел

[Параметры компилятора MSVC](compiler-options.md)\
[MSVC Компилятор Командно-линейный синтаксис](compiler-command-line-syntax.md)\
[Ошибки и обработка исключений](../../cpp/errors-and-exception-handling-modern-cpp.md)\
[Исключения Спецификацииthrow( )](../../cpp/exception-specifications-throw-cpp.md)\
[Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)
