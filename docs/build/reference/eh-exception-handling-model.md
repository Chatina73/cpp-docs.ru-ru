---
title: /EH (модель обработки исключений)
description: Справочное руководство по параметрам компилятора Microsoft C++/EH (модель обработки исключений) в Visual Studio.
ms.date: 04/14/2020
f1_keywords:
- VC.Project.VCCLWCECompilerTool.ExceptionHandling
- /eh
- VC.Project.VCCLCompilerTool.ExceptionHandling
helpviewer_keywords:
- exception handling, compiler model
- cl.exe compiler, exception handling
- EH compiler option [C++]
- -EH compiler option [C++]
- /EH compiler option [C++]
no-loc:
- ':::no-loc(SEH):::'
- ':::no-loc(try):::'
- ':::no-loc(catch):::'
- ':::no-loc(throw):::'
- ':::no-loc(extern):::'
- ':::no-loc(finally):::'
- ':::no-loc(noexcept):::'
ms.assetid: 754b916f-d206-4472-b55a-b6f1b0f2cb4d
ms.openlocfilehash: f158e951d595d5934ff513254871710db5920bf1
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87232720"
---
# <a name="eh-exception-handling-model"></a>/EH (модель обработки исключений)

Указывает поддержку модели обработки исключений, созданную компилятором. Аргументы указывают, следует ли применять `:::no-loc(catch):::(...)` синтаксис к структурированным и стандартным исключениям C++, независимо от того, предполагается ли код ** :::no-loc(extern)::: "C"** :::no-loc(throw)::: исключениями и нужно ли оптимизировать определенные **`:::no-loc(noexcept):::`** проверки.

## <a name="syntax"></a>Синтаксис

> **`/EHa`**[**`-`**]\
> **`/EHs`**[**`-`**]\
> **`/EHc`**[**`-`**]\
> **`/EHr`**[**`-`**]

## <a name="arguments"></a>Аргументы

**`a`**\
Включает стандартный сброс стека C++. При использовании синтаксиса перехватывает как структурированные (асинхронные), так и стандартные исключения C++ (синхронные) `:::no-loc(catch):::(...)` . **`/EHa`** переопределяет **`/EHs`** оба **`/EHc`** аргумента и.

**`s`**\
Включает стандартный сброс стека C++. При использовании синтаксиса перехватывает только стандартные исключения C++ `:::no-loc(catch):::(...)` . Если **`/EHc`** не указано иное, компилятор предполагает, что функции, объявленные как ** :::no-loc(extern)::: "C"** , могут иметь :::no-loc(throw)::: исключение C++.

**`c`**\
При использовании с **`/EHs`** компилятор предполагает, что функции, объявленные как ** :::no-loc(extern)::: "C"** , никогда не являются :::no-loc(throw)::: исключением C++. Он не действует при использовании с **`/EHa`** (то есть **`/EHca`** эквивалентно **`/EHa`** ). **`/EHc`** игнорируется, если не **`/EHs`** **`/EHa`** указан.

**`r`**\
Указывает компилятору всегда создавать проверки завершения среды выполнения для всех **`:::no-loc(noexcept):::`** функций. По умолчанию проверка среды выполнения **`:::no-loc(noexcept):::`** может быть оптимизирована, если компилятор определит, что функция вызывает только функции, не относящиеся к оператору :::no-loc(throw)::: . Этот параметр обеспечивает жесткое соответствие C++ затратам на некоторый дополнительный код. **`/EHr`** игнорируется, если не **`/EHs`** **`/EHa`** указан.

**`-`**\
Очищает предыдущий аргумент параметра. Например, **`/EHsc-`** интерпретируется как **`/EHs /EHc-`** , и эквивалентно **`/EHs`** .

**`/EH`** аргументы можно указывать отдельно или вместе в любом порядке. Если задано несколько экземпляров одного и того же аргумента, последний из них переопределяет все предыдущие.  Например, **`/EHr- /EHc /EHs`** имеет то же значение **`/EHscr-`** , что и, и **`/EHscr- /EHr`** имеет тот же результат, что и **`/EHscr`** .

## <a name="remarks"></a>Remarks

### <a name="default-exception-handling-behavior"></a>Поведение обработки исключений по умолчанию

Компилятор всегда создает код, поддерживающий асинхронную обработку исключений ( :::no-loc(SEH)::: ). По умолчанию (то есть если не **`/EHsc`** **`/EHs`** **`/EHa`** указан параметр, или) компилятор поддерживает :::no-loc(SEH)::: обработчики в собственном `:::no-loc(catch):::(...)` предложении C++. Однако он также создает код, который лишь частично поддерживает исключения C++. Код очистки исключений по умолчанию не уничтожает автоматические объекты C++ за пределами [:::no-loc(try):::](../../cpp/:::no-loc(try):::-:::no-loc(throw):::-and-:::no-loc(catch):::-statements-cpp.md) блоков, которые выходят за пределы области действия из-за исключения. Утечки ресурсов и неопределенное поведение могут возникать, если исключение C++ равно :::no-loc(throw)::: n.

### <a name="standard-c-exception-handling"></a>Стандартная обработка исключений C++

Полная поддержка компилятора для стандартной модели обработки исключений C++, которая безопасно раскрутка объектов стека, требует **`/EHsc`** (рекомендуется), **`/EHs`** или **`/EHa`** .

Если используется **`/EHs`** или **`/EHsc`** , то `:::no-loc(catch):::(...)` предложения не являются :::no-loc(catch)::: асинхронными структурированными исключениями. Все нарушения прав доступа и управляемые <xref:System.Exception?displayProperty=fullName> исключения переходят в неперехваченные. И объекты в области видимости, когда асинхронное исключение не уничтожается, даже если код обрабатывает асинхронное исключение. Это поведение является аргументом для необработанных структурированных исключений. Вместо этого рассмотрите эти исключения как неустранимые.

При использовании **`/EHs`** или **`/EHsc`** компилятор предполагает, что исключения могут происходить только в **`:::no-loc(throw):::`** операторе или вызове функции. Это предположение позволяет компилятору исключать код для отслеживания времени существования множества объектов, не поддерживающих обмотку, что может значительно сократить размер кода. Если используется **`/EHa`** , исполняемый образ может быть больше и медленнее, так как компилятор не оптимизирует **`:::no-loc(try):::`** блоки как агрессивно. Он также оставляет фильтры исключений, которые автоматически удаляют локальные объекты, даже если компилятор не увидит код, который может содержать :::no-loc(throw)::: исключение C++.

### <a name="structured-and-standard-c-exception-handling"></a>Структурированная и стандартная обработка исключений C++

**`/EHa`** Параметр компилятора обеспечивает безопасность очистки стека как для асинхронных исключений, так и для исключений C++. Он поддерживает обработку как стандартных C++, так и структурированных исключений с помощью собственного `:::no-loc(catch):::(...)` предложения c++. Для реализации :::no-loc(SEH)::: без указания **`/EHa`** можно использовать синтаксис **__ :::no-loc(try)::: **, **`__except`** и **`__:::no-loc(finally):::`** . Дополнительные сведения см. в разделе [структурированная обработка исключений](../../cpp/structured-exception-handling-c-cpp.md).

> [!IMPORTANT]
> Указание **`/EHa`** и :::no-loc(try)::: использование для управления всеми исключениями с помощью `:::no-loc(catch):::(...)` может быть опасно. В большинстве случаев восстановление после асинхронного исключения невозможно, и такие исключения следует считать неустранимыми. При их перехвате и продолжении работы возможно повреждение процесса и возникновение ошибок, которые трудно обнаружить и исправить.
>
> Несмотря на то что поддержка Windows и Visual C++ :::no-loc(SEH)::: , настоятельно рекомендуется использовать стандартную обработку исключений C++ ( **`/EHsc`** или) ISO **`/EHs`** . Это делает код более переносимым и гибким. По-прежнему может потребоваться использовать :::no-loc(SEH)::: в устаревшем коде или для определенных видов программ. Это необходимо, например, в коде, скомпилированном для поддержки среды CLR ([/CLR](clr-common-language-runtime-compilation.md)). Дополнительные сведения см. в разделе [структурированная обработка исключений](../../cpp/structured-exception-handling-c-cpp.md).
>
> Рекомендуется никогда не привязать объектные файлы, скомпилированные с помощью **`/EHa`** , к объектам, скомпилированным с помощью **`/EHs`** или **`/EHsc`** в том же исполняемом модуле. Если необходимо реализовать асинхронное исключение с помощью **`/EHa`** любого места в модуле, используйте **`/EHa`** для компиляции всего кода в модуле. Синтаксис структурированной обработки исключений можно использовать в том же модуле, что и код, компилируемый с помощью **`/EHs`** . Однако нельзя смешивать :::no-loc(SEH)::: синтаксис с C++ **`:::no-loc(try):::`** , **`:::no-loc(throw):::`** и в одной и той **`:::no-loc(catch):::`** же функции.

Используйте **`/EHa`** , если требуется :::no-loc(catch)::: исключение, вызванное не объектом **`:::no-loc(throw):::`** . В этом примере создается и :::no-loc(catch)::: ES структурированного исключения:

```cpp
// compiler_options_EHA.cpp
// compile with: /EHa
#include <iostream>
#include <excpt.h>
using namespace std;

void fail()
{
    // generates SE and attempts to :::no-loc(catch)::: it using :::no-loc(catch):::(...)
    :::no-loc(try):::
    {
        int i = 0, j = 1;
        j /= i;   // This will :::no-loc(throw)::: a SE (divide by zero).
        printf("%d", j);
    }
    :::no-loc(catch):::(...)
    {
        // :::no-loc(catch)::: block will only be executed under /EHa
        cout << "Caught an exception in :::no-loc(catch):::(...)." << endl;
    }
}

int main()
{
    __:::no-loc(try):::
    {
        fail();
    }

    // __except will only :::no-loc(catch)::: an exception here
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // if the exception was not caught by the :::no-loc(catch):::(...) inside fail()
        cout << "An exception was caught in __except." << endl;
    }
}
```

### <a name="exception-handling-under-clr"></a>Обработка исключений в/CLR

**`/clr`** Параметр подразумевает (то есть **`/EHa`** **`/clr /EHa`** является избыточным). Компилятор выдает ошибку, если **`/EHs`** или **`/EHsc`** используется после **`/clr`** . Оптимизация не влияет на это поведение. При перехвате исключения компилятор вызывает деструкторы класса для всех объектов, наявляющихся в той же области, что и исключение. Если исключение не перехвачено, эти деструкторы не выполняются.

Дополнительные сведения об ограничениях обработки исключений в см **`/clr`** . в разделе [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md).

### <a name="runtime-exception-checks"></a>Проверки исключений времени выполнения

**`/EHr`** Параметр задает принудительную проверку завершения выполнения во всех функциях, имеющих **`:::no-loc(noexcept):::`** атрибут. По умолчанию проверки среды выполнения могут быть оптимизированы, если серверная части компилятора определяет, что функция вызывает только функции, *не :::no-loc(throw)::: * применяясь. Несамостоятельные :::no-loc(throw)::: функции — это любые функции с атрибутом, который указывает, что исключения не могут быть :::no-loc(throw)::: n. К ним относятся функции, помеченные как **`:::no-loc(noexcept):::`** , `:::no-loc(throw):::()` , `__declspec(no:::no-loc(throw):::)` и, если **`/EHc`** заданы функции ** :::no-loc(extern)::: "C"** . Функции, не применяющие :::no-loc(throw)::: к работе, также включают все, что компилятор определяет как несамостоятельный анализ :::no-loc(throw)::: . Поведение по умолчанию можно задать явным образом с помощью **`/EHr-`** .

Несамостоятельный :::no-loc(throw)::: атрибут не гарантирует, что в функции исключения не могут быть :::no-loc(throw)::: n. В отличие от поведения **`:::no-loc(noexcept):::`** функции, компилятор компилятором MSVC считает исключение :::no-loc(throw)::: n функцией, объявленной с помощью `:::no-loc(throw):::()` , `__declspec(no:::no-loc(throw):::)` или ** :::no-loc(extern)::: "C"** как неопределенного поведения. Функции, использующие эти три атрибута объявления, не применяют проверки завершения среды выполнения для исключений. Можно использовать **`/EHr`** параметр, чтобы определить это неопределенное поведение, заставляя компилятор создавать проверки среды выполнения для необработанных исключений, которые обрабатывают **`:::no-loc(noexcept):::`** функцию.

## <a name="set-the-option-in-visual-studio-or-programmatically"></a>Установка параметра в Visual Studio или программным способом

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите **Свойства конфигурации**  >  Создание кода**C/C++**  >  **Code Generation**.

1. Измените значение свойства **Включить C++ исключения** .

   Можно также задать для параметра **Включить C++ исключения** значение **Нет**, а затем на странице свойств **Командная строка** в поле **Дополнительные параметры** добавить параметр компилятора.

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A>.

## <a name="see-also"></a>См. также статью

[Параметры компилятора КОМПИЛЯТОРОМ MSVC](compiler-options.md)\
[Синтаксис командной строки компилятора КОМПИЛЯТОРОМ MSVC](compiler-command-line-syntax.md)\
[Ошибки и обработка исключений](../../cpp/errors-and-exception-handling-modern-cpp.md)\
[Спецификации исключений ( :::no-loc(throw)::: )](../../cpp/exception-specifications-:::no-loc(throw):::-cpp.md)\
[Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)
