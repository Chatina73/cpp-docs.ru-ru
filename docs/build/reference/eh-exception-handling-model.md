---
title: Параметр /EH (модель обработки исключений)
ms.date: 08/14/2018
f1_keywords:
- VC.Project.VCCLWCECompilerTool.ExceptionHandling
- /eh
- VC.Project.VCCLCompilerTool.ExceptionHandling
helpviewer_keywords:
- exception handling, compiler model
- cl.exe compiler, exception handling
- EH compiler option [C++]
- -EH compiler option [C++]
- /EH compiler option [C++]
ms.assetid: 754b916f-d206-4472-b55a-b6f1b0f2cb4d
ms.openlocfilehash: 8546b14995317afb57e4cc23a5d6f81c2172a1a6
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328294"
---
# <a name="eh-exception-handling-model"></a>Параметр /EH (модель обработки исключений)

Указывает тип обработки исключений, используемый компилятором, условия отказа от проверки исключений для оптимизации работы, а также необходимость уничтожения объектов C++, которые выходят за пределы области видимости в результате исключения. Если **/EH** не указан, компилятор позволяет коду ловить как асинхронные структурированные исключения, так и исключения СЗ, но не уничтожает объекты C,', которые выходят за рамки из-за асинхронного исключения.

## <a name="syntax"></a>Синтаксис

> **/EH**-**с**|**а****с**с**r****-**

## <a name="arguments"></a>Аргументы

**a**<br/>
Модель обработки исключений, которая ловит как асинхронные (структурированные), так и синхронные исключения с помощью синтаксиса СЗ. `catch(...)`

**s**<br/>
Модель обработки исключений, которая ловит только синхронные исключения и говорит компилятору, чтобы предположить, что функции, объявленные **как extern "C",** могут выбросить исключение.

**C**<br/>
При использовании **с s** (**/EHsc),** ловит только исключения СЗ и говорит компилятору предположить, что функции, объявленные как **extern "C"** никогда не бросают исключение C. **/EHca** эквивалентно **/EHa**.

**R**<br/>
Сообщает компилятору всегда генерировать проверки завершения выполнения для всех **функций noexcept.** По умолчанию проверки времени выполнения **для noexcept** могут быть оптимизированы, если компилятор определяет функцию вызова только небросая функций.

## <a name="remarks"></a>Remarks

Параметр компилятора **/EHa** используется для поддержки асинхронной структурированной обработки исключений (SEH) с предложением `catch(...)` неуправляемого кода C++. Для реализации SEH без указания **/EHa**можно использовать **__try,** **__except**и **__finally** синтаксис. Хотя Windows и Visual C++ поддерживают SEH, настоятельно рекомендуется использовать обработку исключений C++ в соответствии со стандартом ISO (**/EHs** или **/EHsc**), поскольку это повышает переносимость и гибкость кода. Тем не менее, в существующем коде или для определенных видов программ, например, в коде, составленном для поддержки общего времени выполнения языка ([/clr (Common Language Runtime Compilation))](clr-common-language-runtime-compilation.md)— возможно, вам все же придется использовать SEH. Дополнительные сведения см. в разделе [Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md).

Указание параметра **/EHa** и попытка обрабатывать все исключения с помощью предложения `catch(...)` может быть небезопасно. В большинстве случаев восстановление после асинхронного исключения невозможно, и такие исключения следует считать неустранимыми. При их перехвате и продолжении работы возможно повреждение процесса и возникновение ошибок, которые трудно обнаружить и исправить.

Если используется параметр **/EHs** или **/EHsc**, предложение `catch(...)` не перехватывает асинхронные структурированные исключения. Нарушения прав доступа и управляемые исключения <xref:System.Exception?displayProperty=fullName> не перехватываются, и объекты, которые находятся в области видимости при возникновении асинхронного исключения, не удаляются, даже если асинхронное исключение обрабатывается.

Если вы используете **/EHa,** изображение может быть больше и может работать менее хорошо, потому что компилятор не оптимизирует блок **попытки,** как агрессивно. Также он сохраняет фильтры исключений, которые автоматически вызывают деструкторы всех локальных объектов, даже если компилятор не видит код, который мог бы вызывать исключение C++. Это обеспечивает безопасное развертывание стека как для асинхронных исключений, так и для исключений C++. При использовании **/EHs**компилятор предполагает, что исключения могут возникать только в выписке **броска** или при вызове функции. Это позволяет компилятору исключить код для отслеживания времени существования многих нераскручиваемых объектов, значительно уменьшая объем кода.

Мы рекомендуем не связывать объекты, комнизируемые с помощью **/EHa** вместе с объектами, компилируемыми с помощью **/EHs** или **/EHsc** в одном и том же исполняемом модуле. Если необходимо обрабатывать асинхронные исключения с помощью параметра **/EHa** в каком-либо месте модуля, используйте параметр **/EHa** для компиляции всего кода модуля. Вы можете использовать структурированный синтаксис обработки исключений в том же модуле, что и код, который компилируется с помощью **/EHs,** но вы не можете смешивать синтаксис SEH с **попыткой,** **броском**и **уловом** в той же функции.

Используйте **/EHa,** если вы хотите поймать исключение, которое подняло на что-то другое, чем **бросок.** В этом примере создается и перехватывается структурированное исключение:

```cpp
// compiler_options_EHA.cpp
// compile with: /EHa
#include <iostream>
#include <excpt.h>
using namespace std;

void fail() {   // generates SE and attempts to catch it using catch(...)
   try {
      int i = 0, j = 1;
      j /= i;   // This will throw a SE (divide by zero).
      printf("%d", j);
   }
   catch(...) {   // catch block will only be executed under /EHa
      cout<<"Caught an exception in catch(...)."<<endl;
   }
}

int main() {
   __try {
      fail();
   }

   // __except will only catch an exception here
   __except(EXCEPTION_EXECUTE_HANDLER) {
      // if the exception was not caught by the catch(...) inside fail()
      cout << "An exception was caught in __except." << endl;
   }
}
```

При использовании параметра **/EHc** необходимо указать параметр **/EHs** или **/EHa** . Опция **/clr** подразумевает **/EHa** (т.е. **/clr** **/EHa** является излишним). Компилятор генерирует ошибку, если **/EHs** или **/EHsc** используется после **/clr**. Оптимизации не влияют на это поведение. В случае перехвата исключения компилятор вызывает деструктор класса или деструкторы объектов, которые находятся в той же области видимости, что и исключение. Если исключение не перехватывается, эти деструкторы не выполняются.

Дополнительные сведения об ограничениях обработки исключений при использовании параметра **/clr**см. в разделе [_set_se_translator](../../c-runtime-library/reference/set-se-translator.md).

Опция может быть очищена **-** с помощью символа. Например, **/EHsc-** интерпретируется как **/EHs** **/EHc-** и эквивалентен **/EHs**.

Опция компилятора **/EHr** заставляет проверки прекращения времени выполнения во всех функциях, которые имеют атрибут **noexcept.** По умолчанию проверки времени выполнения могут быть исключены оптимизацией, если внутренний сегмент компилятора определяет, что функция вызывает только функции, *не создающие исключения* . К функциям, не создающим исключения, относятся все функции с атрибутом, указывающим, что исключения не создаются. Это включает в себя `throw()` `__declspec(nothrow)`функции отмечены **noexcept**, , , и, когда **/EHc** указан, **extern "C"** функции. К функциям, не создающим исключения, также относятся функции, которые компилятор путем проверки определяет как не создающие исключения. Можно явно задать значение по умолчанию, используя **/EHr-**.

Тем не менее атрибут, запрещающий формирование исключений, не гарантирует, что функция не сможет создавать исключения. В отличие от поведения функции **noexcept,** компилятор MSVC `throw()`рассматривает `__declspec(nothrow)`исключение, брошенное функцией, объявленной с использованием, или **экстерное "C"** как неопределенное поведение. Функции, использующие эти три атрибута объявления, не выполняют проверки завершения времени выполнения для исключений. Вы можете использовать опцию **/EHr,** чтобы помочь вам определить это неопределенное поведение, заставив компилятор генерировать проверки времени выполнения для необработанных исключений, которые избегают функции **noexcept.**

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите Поколение кода **конфигурации** > **C/C'.** > **Code Generation**.

1. Измените значение свойства **Включить C++ исключения** .

   Можно также задать для параметра **Включить C++ исключения** значение **Нет**, а затем на странице свойств **Командная строка** в поле **Дополнительные параметры** добавить параметр компилятора.

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.ExceptionHandling%2A>.

## <a name="see-also"></a>См. также раздел

[Параметры компилятора MSVC](compiler-options.md)<br/>
[MSVC Компилятор Командно-линейный синтаксис](compiler-command-line-syntax.md)<br/>
[Обработка ошибок и исключений](../../cpp/errors-and-exception-handling-modern-cpp.md)<br/>
[Спецификации исключений (throw)](../../cpp/exception-specifications-throw-cpp.md)<br/>
[Structured Exception Handling (C/C++)](../../cpp/structured-exception-handling-c-cpp.md)
