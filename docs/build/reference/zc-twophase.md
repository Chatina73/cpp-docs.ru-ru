---
title: /Zc:twoPhase-(отключение двухэтапного поиска имени)
ms.date: 03/06/2018
f1_keywords:
- twoPhase
- /Zc:twoPhase
- VC.Project.VCCLCompilerTool.EnforceTypeConversionRules
helpviewer_keywords:
- twoPhase
- disable two-phase name lookup
- /Zc:twoPhase
ms.openlocfilehash: ebd577bc25a2789e3a6b328a4c9cd2e1596d04da
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2019
ms.locfileid: "57821408"
---
# <a name="zctwophase--disable-two-phase-name-lookup"></a>/Zc:twoPhase-(отключение двухэтапного поиска имени)

Когда **/Zc:twoPhase-** параметр указан, компилятор выполняет синтаксический анализ и создает экземпляр класса шаблонов и функции в так же, не соответствующих как версиях Visual Studio до Visual Studio 2017 версии 15.3.

## <a name="syntax"></a>Синтаксис

> **/Zc:twoPhase-**

## <a name="remarks"></a>Примечания

В Visual Studio 2017 версии 15.3 и более поздних версий, по умолчанию компилятор использует двухэтапный поиск имен для разрешения имен шаблона. Если **/Zc:twoPhase-** указан, компилятор переходит в его предыдущего несоответствующих шаблона и функцию шаблона имя разрешения и подстановки поведение класса.

**/Zc:twoPhase-** параметр, чтобы включить несоответствующее поведение не задано по умолчанию. [/ Permissive-](permissive-standards-conformance.md) параметр неявно задает соответствующих поведение компилятора двухэтапного поиска, но его можно переопределить с помощью **/Zc:twoPhase-**.

Файлы заголовков Windows SDK в версии 10.0.15063.0 (Creators Update или Redstone 2) и более ранних версий не работают в режиме совместимости. Необходимо использовать **/Zc:twoPhase-** для компиляции кода для этих версий пакета SDK, при использовании Visual Studio 2017 версии 15.3 и более поздних версий. Версии пакета SDK для Windows, начиная с версии 10.0.15254.0 (Redstone 3 или Fall Creators Update) правильно работают в режиме совместимости и не требуют **/Zc:twoPhase-** параметр.

Используйте **/Zc:twoPhase-** Если код требует старое поведение для правильной компиляции. Настоятельно рекомендуется обновлять код, чтобы соответствовать стандарту.

### <a name="compiler-behavior-under-zctwophase-"></a>Поведение компилятора /Zc:twoPhase-

В версиях до Visual Studio 2017 версии 15.3, компилятора и когда **/Zc:twoPhase-** указан, компилятор использует это поведение:

- Он анализирует только объявление шаблона класса head и список базовых классов. Текст шаблона записывается в виде поток лексем. Нет тело функции, инициализаторы, аргументы по умолчанию или noexcept аргументы анализируются. Шаблон класса псевдо создан для типа "под вопросом" для проверки правильности объявления в шаблоне класса. Рассмотрим следующий шаблон класса.

   ```cpp
   template <typename T> class Derived : public Base<T> { ... }
   ```

   Объявление шаблона, `template <typename T`>, заголовка класса `class Derived`и список базовых классов `public Base<T>` анализируются, но в теле шаблона записывается в виде поток лексем.

- При синтаксическом анализе функции-шаблона, компилятор анализирует только сигнатуры функции. Тело функции никогда не анализируется. Вместо этого передается как поток лексем.

Таким образом Если текст шаблона содержит синтаксические ошибки и никогда не создается шаблон, никогда не выявляются ошибки.

Другой эффект такого поведения, заключается в разрешении перегрузки. Из-за того, в который поток лексем развернут на веб-узле при создании экземпляра символы, которые не были видны в объявлении шаблона может быть видимым в момент создания экземпляра и участвует в разрешении перегрузки. Это может привести к шаблонам, изменяющие поведение на основе кода, не было открыто при определении шаблона, в отличие от стандартного.

Например, рассмотрим следующий код.

```cpp
#include <cstdio>

void func(void*) { std::puts("The call resolves to void*") ;}

template<typename T> void g(T x)
{
    func(0);
}

void func(int) { std::puts("The call resolves to int"); }

int main()
{
    g(3.14);
}
```

При компиляции в **/Zc:twoPhase-**, эта программа выводит «вызов разрешается в тип int». В режиме совместимости в разделе **/ permissive-**, эта программа выводит «вызов возвращает значение void *», так как Вторая перегруженная версия `func` не отображается, когда компилятор обнаруживает шаблон.

*Зависимые имена*, имена, которые зависят от параметра шаблона, имеют режим просмотра, который отличается также в разделе **/Zc:twoPhase-**. В режиме совместимости зависимые имена не привязаны в точке определения шаблона. Вместо этого эти имена, разрешаются при создании экземпляра шаблона. Для вызовов функций с именем зависимые функции имя привязан к набору функций, видимых в точке вызова в определении шаблона, как описано выше. В точке определения шаблона и где шаблона создается точки добавляются дополнительные перегрузки из поиске с зависимостью от аргументов. Два этапа двухэтапного поиска являются поиск имен независимые во время определения шаблона и подстановки для зависимых имен во время создания экземпляра шаблона. В разделе **/Zc:twoPhase-**, компилятор не выполняет поиске с зависимостью от аргументов отдельно от обычных, неполное Уточняющий запрос (то есть он не выполняет двухэтапного поиска), поэтому могут получиться другие результаты разрешения перегрузки.

Вот еще один пример:

```cpp
// zctwophase1.cpp
// Compile by using
// cl /EHsc /W4 /permissive- zctwophase1.cpp
// cl /EHsc /W4 /permissive- /Zc:twoPhase- zctwophase1.cpp

#include <cstdio>

void func(long) { std::puts("func(long)"); }

template <typename T> void tfunc(T t) {
    func(t);
}

void func(int) { std::puts("func(int)"); }

namespace NS {
    struct S {};
    void func(S) { std::puts("NS::func(NS::S)"); }
}

int main() {
    tfunc(1729);
    NS::S s;
    tfunc(s);
}
```

При компиляции без **/Zc:twoPhase-**, при выполнении этого кода

```Output
func(long)
NS::func(NS::S)
```

При компиляции с **/Zc:twoPhase-**, при выполнении этого кода

```Output
func(int)
NS::func(NS::S)
```

В режиме совместимости в разделе **/ permissive-**, вызов `tfunc(1729)` разрешается `void func(long)` перегрузку, не `void func(int)` перегрузки в **/Zc:twoPhase-**, так как неполное `func(int)` объявляется после определения шаблона и не обнаруженных в ходе поиске с зависимостью от аргументов. Но `void func(S)` участвовать в поиске с зависимостью от аргументов, поэтому он добавляется в перегрузку, задать для вызова `tfunc(s)` несмотря на то, что он объявлен как после функции шаблона.

### <a name="update-your-code-for-two-phase-conformance"></a>Обновите код для двухэтапной соответствия требованиям

Более старые версии компилятора не требуют ключевые слова `template` и `typename` везде стандарт C++ требует их. Эти ключевые слова в некоторые положения требуются для устранения неоднозначности как компиляторы должен выделять зависимое имя первой фазе поиска. Пример:

`T::Foo<a || b>(c);`

Согласование компилятор анализирует `Foo` как переменную в области `T`, то есть этот код является логическим- или выражение с `T::foo < a` как левый операнд и `b > (c)` правым операндом. Если вы хотели использовать `Foo` как шаблон функции, необходимо указать, что это шаблон, добавив `template` ключевое слово:

`T::template Foo<a || b>(c);`

В версиях до Visual Studio 2017 версии 15.3 и когда **/Zc:twoPhase-** указан, компилятор позволяет этот код без `template` ключевое слово и интерпретирует его как вызов функции шаблона с аргументом `a || b`, так как он анализирует шаблоны в ограниченном режиме. На первом этапе приведенный выше код не вообще синтаксический анализ. На втором этапе имеется достаточный контекст, чтобы определить, что `T::Foo` является шаблоном, а не переменной, поэтому компилятор не предписывает использование ключевого слова.

Это поведение также можно просмотреть, удалив ключевое слово `typename` перед именами в тело функции шаблона, инициализаторы, аргументы по умолчанию и noexcept аргументы. Пример:

```cpp
template<typename T>
typename T::TYPE func(typename T::TYPE*)
{
    /* typename */ T::TYPE i;
}
```

Если вы не используете ключевое слово `typename` в теле функции этот код компилируется **/Zc:twoPhase-**, но не при использовании **/ permissive-**. `typename` Для указания того, что требуется ключевое слово `TYPE` зависит. Так как текст не анализируется в разделе **/Zc:twoPhase-**, does't компилятора требуется ключевое слово. В **/ permissive-** режим совместимости, код без `typename` ключевое слово возникнут ошибки. Перенос кода в Visual Studio 2017 версии 15.3 и более поздней, вставить `typename` ключевое слово, где он отсутствует.

Аналогичным образом рассмотрим следующий код:

```cpp
template<typename T>
typename T::template X<T>::TYPE func(typename T::TYPE)
{
    typename T::/* template */ X<T>::TYPE i;
}
```

В разделе **/Zc:twoPhase-** в старых компиляторах, компилятор требуется только `template` ключевое слово в строке 2. По умолчанию, а в режиме совместимости, компилятор теперь также требует `template` ключевое слово в строке 4, чтобы указать, что `T::X<T>` является шаблоном. Найдите код, в котором отсутствует ключевое слово и задать в нем для соответствия стандарту кода.

Дополнительные сведения о вопросах соответствия, см. в разделе [улучшения соответствия C++ в Visual Studio](../../cpp-conformance-improvements-2017.md) и [нестандартное поведение](../../cpp/nonstandard-behavior.md).

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Дополнительные сведения см. в разделе [свойств компилятора и собранной задать C++ в Visual Studio](../working-with-project-properties.md).

1. Выберите **свойства конфигурации** > **C/C++** > **командной строки** страницу свойств.

1. Изменить **Дополнительные параметры** свойство **/Zc:twoPhase-** и выберите **ОК**.

## <a name="see-also"></a>См. также

[/Zc (соответствие)](zc-conformance.md)<br/>
