---
title: /kernel (создание двоичного режима ядра)
ms.date: 11/04/2016
f1_keywords:
- /kernel
- /kernel-
ms.assetid: 6d7fdff0-c3d1-4b78-9367-4da588ce8b05
ms.openlocfilehash: 0df133922af90a91d5c1ae1ad3caebe11d854b8f
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50509661"
---
# <a name="kernel-create-kernel-mode-binary"></a>/kernel (создание двоичного режима ядра)

Создает двоичный файл, который может выполняться в ядре Windows.

## <a name="syntax"></a>Синтаксис

```
/kernel[-]
```

## <a name="arguments"></a>Аргументы

**/kernel**<br/>
Код в текущем проекте компилируется и связывается с помощью набора правил языка C++, относящиеся к коду, который будет выполняться в режиме ядра.

**/kernel-**<br/>
Код в текущем проекте компилируется и связывается без использования правилами языка C++, относящиеся к коду, который будет выполняться в режиме ядра.

## <a name="remarks"></a>Примечания

Существует не `#pragma` эквивалентно элементу управления этот параметр.

Указание **/kernel** сообщает компилятора и компоновщика арбитраже, какие возможности языка допустимы в режиме ядра и убедитесь, что у вас есть достаточно эффективными возможностями, чтобы избежать нестабильности среды выполнения, который уникален в в режиме ядра C++. Это достигается, запретив использование возможностей языка C++, которые нарушают в режиме ядра, а также предоставляя предупреждения для функции языка C++, которые потенциально может нарушить работу системы, но не может быть отключено.

**/Kernel** параметр применяется к компилятор и компоновщик этапов построения и устанавливается на уровне проекта. Передайте **/kernel** параметр для указания компилятору, что итоговый файл, после установки связи должны быть загружены в ядре Windows. Компилятор будет сузить спектр возможностей языка C++ подмножеством, которая совместима с ядром.

В следующей таблице перечислены изменения в поведении компилятора при **/kernel** указан.

|Тип поведения|**/ kernel** поведение|
|-------------------|---------------------------|
|Обработка исключений С++|Отключено. Все экземпляры `throw` и `try` ключевые слова выдавать ошибку компилятора (за исключением спецификация исключений `throw()`). Не **/EH** параметры совместимы с **/kernel**, за исключением **/EH-**.|
|RTTI|Отключено. Все экземпляры `dynamic_cast` и `typeid` ключевые слова выдавать ошибку компилятора, если не `dynamic_cast` используется статически.|
|`new` и `delete`|Необходимо явно определить `new()` или `delete()` оператор; компилятор ни среда выполнения будет поставлять определение по умолчанию.|

Пользовательские соглашения о вызовах, [/GS](../../build/reference/gs-buffer-security-check.md) параметр сборки все оптимизации разрешены и при использовании **/kernel** параметр. Встраивание не во многом зависит от **/kernel**, с той же семантикой, компилятор учитывает. Если вы хотите убедиться, что `__forceinline` учитывается встраивания квалификатор, убедитесь, что предупреждение [C4714](../../error-messages/compiler-warnings/compiler-warning-level-4-c4714.md) таким образом, вы знаете, когда определенный `__forceinline` функция не является встроенной.

При передаче компилятор **/kernel** коммутатора, предопределяет макрос препроцессора, которая называется `_KERNEL_MODE` и имеет значение **1**. Это можно использовать для условной компиляции кода на наличие в среде выполнения в пользовательском режиме или режиме ядра. Например следующий код указывает, что класс должен быть в сегменте невыгружаемой памяти, при компиляции для выполнения в режиме ядра.

```cpp
#ifdef _KERNEL_MODE
#define NONPAGESECTION __declspec(code_seg("$kerneltext$"))
#else
#define NONPAGESECTION
#endif

class NONPAGESECTION MyNonPagedClass
{
   // ...
};
```

Некоторые следующие сочетания целевой архитектуры и **/arch** параметр вызвать ошибку, если они используются с **/kernel**:

- **/ arch: {SSE&#124;SSE2&#124;AVX}** x86 не поддерживаются. Только **/arch: IA32** поддерживается с **/kernel** на x86.

- **/ arch: AVX** не поддерживается с **/kernel** в x64.

Построение с **/kernel** также передает **/kernel** компоновщику. Ей является, как это влияет на поведение компоновщика:

- Последовательная компоновка отключена. Если вы добавите **/ incremental** в командную строку, компоновщик выдает это Неустранимая ошибка:

   **LINK: Неустранимая ошибка LNK1295: «/ INCREMENTAL» не совместим с "/ KERNEL" спецификации; связать без «/ INCREMENTAL»**

- Компоновщик проверяет каждый объектный файл (или любой член включены архива из статических библиотек) см. в разделе ли он может были скомпилированы с помощью **/kernel** параметр, однако не. Если какие-либо экземпляры соответствует этому критерию, компоновщик по-прежнему успешно ссылки, но могут выдавать предупреждение, как показано в следующей таблице.

   ||**/ kernel** obj|**/kernel-** obj, MASM obj или cvtresed|Набор **/kernel** и **/kernel-** объектов|
   |-|----------------------|-----------------------------------------------|-------------------------------------------------|
   |**/ kernel ссылку**|Да|Да|Да, с предупреждением LNK4257|
   |**ссылка**|Да|Да|Да|

   **Связующий объект LNK4257 не компилируется с помощью параметра/kernel; образ нельзя запустить**

**/Kernel** параметр и **/Driver** параметр друг от друга и не влияет на другое.

### <a name="to-set-the-kernel-compiler-option-in-visual-studio"></a>Установка параметра компилятора/kernel в Visual Studio

1. Откройте **страницы свойств** диалоговое окно для проекта. Дополнительные сведения см. в разделе [Работа со свойствами проекта](../../ide/working-with-project-properties.md).

1. Выберите **C/C++** папки.

1. Выберите **командной строки** страницу свойств.

1. В **Дополнительные параметры** , добавьте `/kernel` или `/kernel-`.

## <a name="see-also"></a>См. также

[Параметры компилятора](../../build/reference/compiler-options.md)<br/>
[Настройка параметров компилятора](../../build/reference/setting-compiler-options.md)