---
title: Профильная оптимизация
ms.date: 03/14/2018
helpviewer_keywords:
- profile-guided optimizations
- optimization, profile-guided [C++]
ms.assetid: 2225c307-d3ae-42c1-8345-a5a959d132dc
ms.openlocfilehash: eb23d91de210ddc9e12886924af3450ce67330d3
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50632561"
---
# <a name="profile-guided-optimizations"></a>Профильная оптимизация

Профильная оптимизация позволяет оптимизировать выходной файл, используя данные из тестовых запусков EXE- или DLL-файла. Данные представляют, как программа, вероятно, будет работать в рабочей среде.

Профильные оптимизации доступны только x86 или x64 компиляции в машинный код. Оптимизация, зависимая от профиля недоступны для выходных файлов, которые выполняются на среду. Даже если создать сборку со смешанным машинным и управляемым кодом (с помощью **/CLR** параметр компилятора), нельзя использовать профильную оптимизацию только для машинного кода. Если вы попытаетесь выполнить сборку проекта с этими параметрами, заданными в интегрированной среде разработки, приводит к ошибке сборки.

> [!NOTE]
> Сведения, собранные из теста профилирования, запускают переопределения оптимизаций, которые бы в противном случае вступят в силу, если указать **/Ob**, **/Os**, или **/Ot**. Дополнительные сведения см. в разделе [/Ob (расширение встраиваемых функций)](../../build/reference/ob-inline-function-expansion.md) и [/Os /Ot (приоритет размера кода или скорости кода)](../../build/reference/os-ot-favor-small-code-favor-fast-code.md).

## <a name="steps-to-optimize-your-app"></a>Шаги для оптимизации приложения

Чтобы использовать профильную оптимизацию, выполните следующие действия для оптимизации приложения.

- Компиляции одного или нескольких файлов исходного кода с [/GL](../../build/reference/gl-whole-program-optimization.md).

   Каждый модуль, построенный с **/GL** можно проверить во время тестовых запусков профильной оптимизации для захвата поведение во время выполнения. Каждый модуль в построении профильной оптимизации не нужно компилировать с использованием **/GL**. Однако только те модули, скомпилированные с использованием **/GL** будут обработаны и доступны для профильной оптимизации.

- Компоновку с использованием [/LTCG](../../build/reference/ltcg-link-time-code-generation.md) и [/genprofile или/fastgenprofile](../../build/reference/genprofile-fastgenprofile-generate-profiling-instrumented-build.md).

   Использование обеих **/LTCG** и **/genprofile** или **/fastgenprofile** создает PGD-файла, при выполнении инструментированного приложения. После добавления данных тестового запуска в PGD-файл они могут использоваться как входные данные для следующего этапа компоновки (создание оптимизированного образа). При указании **/genprofile**, при необходимости можно добавить **PGD =**_filename_ аргумент, чтобы указать нестандартным именем или расположением PGD-файла. Сочетание **/LTCG** и **/genprofile** или **/fastgenprofile** параметры компоновщика заменяет нерекомендуемый **/LTCG: PGINSTRUMENT** параметр компоновщика.

- Профилирование приложения.

   Каждый раз профилируемый сеанс EXE или профилируемый DLL-ФАЙЛ выгружается, *appname*! # .pgc файл создается. PGC-файл содержит сведения об определенном тестовом запуске приложения. # — Это номер, начиная с 1, которое увеличивается в зависимости от числа других *appname*! # .pgc файлы в каталоге. Можно удалить PGC-файл, если тестовый запуск не представляет сценарий, который вы хотите оптимизировать.

   Во время выполнения теста, вы можете принудительно закрытие в текущий момент PGC-файла и создание нового PGC-файл с [pgosweep](../../build/reference/pgosweep.md) программы (например, если конец тестового сценария не совпадает с завершением работы приложения).

   Приложения можно также напрямую вызывать функцию профильной Оптимизации, [использованием PgoAutoSweep](pgoautosweep.md), для сбора данных профиля точке вызова как PGC-файл. Это можно получить более точный контроль кода, охваченных записанные данные в файлах .pgc. Пример использования этой функции, см. в разделе [использованием PgoAutoSweep](pgoautosweep.md) документации.

   При создании вашей инструментированной сборки по умолчанию сбор данных выполняется в режиме не являющихся потокобезопасными, который выполняется быстрее, но может быть не вполне точной. С помощью **EXACT** аргумент **/genprofile** или **/fastgenprofile**, сбор данных можно указать в режиме поточно ориентированными, который обеспечивает более точные результаты, но медленнее. Этот параметр также доступна при установке устаревших [PogoSafeMode](environment-variables-for-profile-guided-optimizations.md#pogosafemode) переменной среды или устаревший **/POGOSAFEMODE** параметр компоновщика, при создании инструментированной сборки.

- Компоновку с использованием **/LTCG** и **/useprofile**.

   Использовать оба метода **/LTCG** и [/useprofile](useprofile.md) параметры компоновщика для создания оптимизированного образа. На этом шаге в качестве входных данных принимается PGD-файл. При указании **/useprofile**, при необходимости можно добавить **PGD =**_filename_ аргумент, чтобы указать нестандартное имя или расположение PGD-файла. Это имя можно также указать с помощью устаревших **/PGD** параметр компоновщика. Сочетание **/LTCG** и **/useprofile** заменяет нерекомендуемый **/LTCG: PGOPTIMIZE** и **/LTCG: PGUPDATE** параметры компоновщика.

Можно даже создать оптимизированный выходной файл и позже определить, что дополнительное профилирование будет полезно для создания более оптимизированного образа. Если инструментированный образ и соответствующий PGD-файл, можно выполнить дополнительные тестовые запуски и перестроить оптимизированный образ с новым PGD-файлом с использованием тех же **/LTCG** и **/useprofile** параметры компоновщика .

## <a name="optimizations-performed-by-pgo"></a>Оптимизацию, выполняемую с профильной Оптимизации

Ниже приведен список профильных оптимизаций.

- **Встраивание** — например, если существует функция A, что часто вызывает функцию B и функция B относительно невелико, а затем оптимизация, зависимая от профиля будет встроит функцию B в функцию A.

- **Отражение виртуального вызова** — Если виртуальный вызов или другой вызов через указатель функции часто предназначен для определенной функции, Профильная оптимизация может вставить условно выполняемый прямой вызов функции частым атакам, и прямой вызов может быть встроенным.

- **Распределение регистров** — Оптимизация с результатами данных профиля в лучше регистры.

- **Простая блочная оптимизация** -Простая блочная оптимизация позволяет часто выполняемые основные блоки, которые временно выполняются во фрейме должно быть помещено в тот же набор страниц (локально). Это минимизирует число используемых страниц, уменьшая тем самым затраты памяти.

- **Оптимизация размера и скорости** -функции, где программа тратит много времени могут быть оптимизированы по скорости.

- **Структура функции** — на основании графа вызовов и профилировать поведение "Вызывающий/вызываемый", функции, как правило, вдоль одного пути выполнения, помещаются в одном разделе.

- **Оптимизация условного ветвления** — с помощью зондов значений Профильная оптимизация может определить, если заданное значение в операторе switch используется чаще, чем другие значения.  Затем это значение может быть извлечено из оператора switch.  То же можно сделать с инструкциями if/else, где оптимизатор может упорядочить их так, чтобы блок if или else размещался первым в зависимости от того, какой блок чаще получает значение true.

- **Отделение неиспользуемого кода** -код, который не вызывается во время профилирования, перемещается в специальный раздел, который добавляется в конец набора разделов. Это позволяет вынести раздел с часто используемых страниц.

- **Отделение кода EH** — код EH, который выполняется можно поместить в отдельный раздел при профильной оптимизации удается определить, что исключения возникают только при исключительных условиях.

- **Внутренние функции памяти** -расширение компонентов можно оптимизировать, если он может определяться, если встроенная функция, которая часто вызывается. Встроенная функция может также быть оптимизирована на основе размера блока перемещения или копирования.

Если вы используете Visual Studio 2013, можно использовать автоматический [профиль подключаемый модуль профильной оптимизации](../../build/reference/profile-guided-optimization-in-the-performance-and-diagnostics-hub.md) Visual c++ в концентраторе производительности и диагностики упростить и ускорить процесс оптимизации в среде Visual Studio. Этот подключаемый модуль не доступен в более поздних версиях Visual Studio.

## <a name="next-steps"></a>Следующие шаги

Дополнительные сведения об этих переменных среды, функции и средства, которые можно использовать в оптимизация, зависимая от профиля:

[Переменные среды для профильной оптимизации](../../build/reference/environment-variables-for-profile-guided-optimizations.md)<br/>
Эти переменные могут использоваться для указания поведения времени выполнения сценариев тестирования. Они признаны нерекомендуемыми новые параметры компоновщика; чтение, которые помогут вам выполнить переход из переменных среды параметров компоновщика.

[PgoAutoSweep](pgoautosweep.md)<br/>
Функции можно добавить в приложение для обеспечения контроля системы отслеживания измененных данных файла детальных .pgc.

[pgosweep](../../build/reference/pgosweep.md)<br/>
Это программа командной строки, который записывает все данные профиля в файл PGC закрывает PGC-файл и открывает новый файл .pgc.

[pgomgr](../../build/reference/pgomgr.md)<br/>
Это программа командной строки, который добавляет профиль данных из одного или нескольких файлов .pgc в PGD-файл.

[Практическое руководство. Слияние нескольких профилей PGO в единый профиль](../../build/reference/how-to-merge-multiple-pgo-profiles-into-a-single-profile.md)<br/>
Примеры **pgomgr** использования.

## <a name="see-also"></a>См. также

[Средства сборки С/C++](../../build/reference/c-cpp-build-tools.md)
