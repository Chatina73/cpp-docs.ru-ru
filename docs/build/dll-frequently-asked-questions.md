---
title: Вопросы и ответы о библиотеках DLL MFC
ms.date: 05/06/2019
helpviewer_keywords:
- troubleshooting [C++], DLLs
- DLLs [C++], frequently asked questions
- FAQs [C++], DLLs
ms.assetid: 09dd068e-fc33-414e-82f7-289c70680256
ms.openlocfilehash: e12817e016376d5b76ec67e8bd10fbd3e85dbdda
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87229848"
---
# <a name="dll-frequently-asked-questions"></a>Вопросы и ответы по библиотекам DLL

Ниже представлены некоторые часто задаваемые вопросы о библиотеках DLL.

- [Допускается ли создание в библиотеке DLL MFC нескольких потоков?](#mfc_multithreaded_1)

- [Допускается ли обращение к библиотеке DLL MFC из многопоточного приложения в различных потоках?](#mfc_multithreaded_2)

- [Какие классы и функции MFC не могут использоваться в библиотеке DLL MFC?](#mfc_prohibited_classes)

- [Какие методы оптимизации следует использовать для увеличения скорости загрузки клиентского приложения?](#mfc_optimization)

- [В обычной библиотеке DLL MFC обнаружена утечка памяти, однако видимые ошибки в коде отсутствуют. Как найти утечку памяти?](#memory_leak)

## <a name="can-an-mfc-dll-create-multiple-threads"></a><a name="mfc_multithreaded_1"></a> Допускается ли создание в библиотеке DLL MFC нескольких потоков?

За исключением инициализации, библиотека DLL MFC может безопасно создавать несколько потоков, если в ней используются функции локального хранилища (TLS) потока Win32, такие как **TlsAlloc**, для выделения локального хранилища потоков. Однако если библиотека DLL MFC использует **`__declspec(thread)`** для выделения локального хранилища потоков, клиентское приложение должно быть неявно связано с библиотекой DLL. Если клиентское приложение явно ссылается на библиотеку DLL, вызов **LoadLibrary** не загрузит библиотеку DLL. Дополнительные сведения о локальных переменных потока в библиотеках DLL см. в разделе о [потоке](../cpp/thread.md).

Библиотека DLL MFC, которая создает новый поток MFC во время запуска, перестает отвечать на запросы при загрузке приложением. Это происходит каждый раз при создании потока путем вызова `AfxBeginThread` или `CWinThread::CreateThread` внутри следующих элементов:

- `InitInstance` объекта, производного от `CWinApp`, в обычной библиотеке DLL MFC.

- Переданная функция `DllMain` или **RawDllMain** в обычной библиотеке DLL MFC.

- Переданная функция `DllMain` или **RawDllMain** в библиотеке DLL расширения MFC.

## <a name="can-a-multithreaded-application-access-an-mfc-dll-in-different-threads"></a><a name="mfc_multithreaded_2"></a> Допускается ли обращение к библиотеке DLL MFC из многопоточного приложения в различных потоках?

Многопоточные приложения могут получать доступ к обычным библиотекам DLL MFC, которые динамически связываются с библиотеками DLL расширения MFC и MFC из разных потоков. Приложение может получить доступ к обычным библиотекам DLL MFC, которые статически связываются с MFC из нескольких потоков, созданных в приложении.

## <a name="are-there-any-mfc-classes-or-functions-that-cannot-be-used-in-an-mfc-dll"></a><a name="mfc_prohibited_classes"></a> Какие классы и функции MFC не могут использоваться в библиотеке DLL MFC?

Библиотеки DLL расширения используют класс, производный от `CWinApp`, клиентского приложения. Они не должны иметь собственный класс, производный от `CWinApp`.

Обычные библиотеки DLL MFC должны иметь класс, производный от `CWinApp`, и один объект этого класса приложения так же, как и приложение MFC. В отличие от объекта `CWinApp` приложения, у объекта `CWinApp` библиотеки DLL нет основного генератора сообщений.

Обратите внимание, что механизм `CWinApp::Run` не применяется к библиотеке DLL, так как в приложении есть основной генератор сообщений. Если библиотека DLL открывает немодальные диалоговые окна или имеет собственное основное окно кадра, основной генератор сообщений приложения должен вызвать подпрограмму, экспортированную библиотекой DLL, которая, в свою очередь, вызывает функцию-член `CWinApp::PreTranslateMessage` объекта приложения библиотеки DLL.

## <a name="what-optimization-techniques-should-i-use-to-improve-the-client-application39s-performance-when-loading"></a><a name="mfc_optimization"></a> Какие методы оптимизации следует использовать для увеличения скорости загрузки клиентского приложения?

Если библиотека DLL является обычной библиотекой DLL MFC, которая статически связана с MFC, то изменение ее на обычную библиотеку DLL MFC, которая динамически связана с MFC, сокращает размер файла.

Если в библиотеке DLL содержится большое количество экспортированных функций, используйте DEF-файл для экспорта функций (вместо использования **`__declspec(dllexport)`** ), а также [атрибут NONAME](exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md) DEF-файла для каждой экспортированной функции. Атрибут NONAME приводит к сохранению только порядкового значения, а не имени функции в таблице экспорта библиотеки DLL, что сокращает размер файла.

Библиотеки DLL, которые неявно связаны с приложением, загружаются при загрузке приложения. Чтобы повысить производительность при загрузке, попробуйте разделить библиотеку DLL на разные библиотеки DLL. Помещайте все функции, необходимые вызывающему приложению сразу после загрузки, в одну библиотеку DLL, и настройте вызывающее приложение для неявной связи с этой библиотекой DLL. Помещайте остальные функции, которые не нужны вызывающему приложению сразу, в другую библиотеку DLL, и настройте вызывающее приложение для явной связи с этой библиотекой DLL. Дополнительные сведения см. в разделе [Связывание исполняемого файла с библиотекой DLL](linking-an-executable-to-a-dll.md#determining-which-linking-method-to-use).

## <a name="there39s-a-memory-leak-in-my-regular-mfc-dll-but-my-code-looks-fine-how-can-i-find-the-memory-leak"></a><a name="memory_leak"></a> В обычной библиотеке DLL MFC обнаружена утечка памяти, однако видимые ошибки в коде отсутствуют. Как найти утечку памяти?

Одной из возможных причин утечки памяти является тот факт, что MFC создает временные объекты, используемые внутри функций обработчика сообщений. В приложениях MFC эти временные объекты автоматически очищаются в функции `CWinApp::OnIdle()`, которая вызывается между сообщениями обработки. Однако в библиотеках динамической компоновки (DLL) MFC функция `OnIdle()` не вызывается автоматически. В результате временные объекты не очищаются автоматически. Чтобы очистить временные объекты, библиотека DLL должна периодически явно вызывать `OnIdle(1)`.

## <a name="see-also"></a>См. также

[Создание библиотек DLL C/C++ в Visual Studio](dlls-in-visual-cpp.md)
