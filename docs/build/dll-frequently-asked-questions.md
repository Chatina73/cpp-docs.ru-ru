---
title: Вопросы и ответы по библиотеке DLL MFC
ms.date: 11/04/2016
helpviewer_keywords:
- troubleshooting [C++], DLLs
- DLLs [C++], frequently asked questions
- FAQs [C++], DLLs
ms.assetid: 09dd068e-fc33-414e-82f7-289c70680256
ms.openlocfilehash: 4d6490691583162fc95042601bd85566f693d049
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50629142"
---
# <a name="dll-frequently-asked-questions"></a>Вопросы и ответы по библиотекам DLL

Ниже представлены некоторые часто задаваемые вопросы (FAQ) о библиотеках DLL.

- [Создаются ли библиотеке DLL MFC нескольких потоков?](#mfc_multithreaded_1)

- [Можно многопоточного приложения доступ к библиотеке DLL MFC в различных потоках?](#mfc_multithreaded_2)

- [Существуют ли классы MFC или функции, которые не могут использоваться в библиотеке DLL MFC?](#mfc_prohibited_classes)

- [Способы оптимизации следует использовать для повышения производительности клиентского приложения при загрузке?](#mfc_optimization)

- [Имеется утечка памяти в в обычной библиотеке DLL MFC, но мой код выглядит хорошо. Как найти утечки памяти?](#memory_leak)

## <a name="mfc_multithreaded_1"></a> Создаются ли библиотеке DLL MFC нескольких потоков?

За исключением того, во время инициализации библиотеки DLL MFC допускается создание нескольких потоков до тех пор, пока он использует локальное хранилище (TLS) функции, такие как поток Win32 **TlsAlloc** выделить локальное хранилище потока. Тем не менее если в библиотеке DLL MFC используется **__declspec(thread)** для выделения локальной памяти потока, клиентское приложение должно быть неявно связано на библиотеку DLL. Если клиентское приложение явным образом связано с библиотекой DLL, вызов **LoadLibrary** не будет успешно загрузить библиотеку DLL. Дополнительные сведения о локальные переменные потока в библиотеках DLL, см. в разделе [поток](../cpp/thread.md).

MFC DLL, которая создает новый поток MFC при запуске программа зависает при загрузке приложением. Сюда входят всякий раз, когда поток создается путем вызова `AfxBeginThread` или `CWinThread::CreateThread` внутри:

- `InitInstance` Из `CWinApp`-производный объект в обычной библиотеки DLL MFC.

- Указанный `DllMain` или **RawDllMain** функции в обычную библиотеку DLL MFC.

- Указанный `DllMain` или **RawDllMain** функции в библиотеки DLL расширения MFC.

## <a name="mfc_multithreaded_2"></a> Можно многопоточного приложения доступ к библиотеке DLL MFC в различных потоках?

Многопоточные приложения могут обращаться к обычные библиотеки DLL MFC, который динамически связан с MFC и библиотеки DLL расширения MFC из разных потоков. И, начиная с Visual C++ версии 4.2, приложение может получить доступ к обычные библиотеки DLL MFC, статической компоновке с MFC из нескольких потоков, которые созданы в приложении.

До версии 4.2 только один внешний поток мог подключиться к обычной MFC DLL, статически компонуемые с MFC.

Обратите внимание, что термин USRDLL больше не используется в документации по Visual C++. Обычной MFC DLL, статически компонуемые с MFC имеет те же характеристики, как бывший USRDLL.

## <a name="mfc_prohibited_classes"></a> Существуют ли классы MFC или функции, которые не могут использоваться в библиотеке DLL MFC?

Использование библиотек DLL расширения `CWinApp`-производный класс клиентского приложения. Они не могут иметь свои собственные `CWinApp`-производного класса.

Обычные библиотеки DLL MFC должен иметь `CWinApp`-производный класс и один объект этого класса, как в приложении MFC. В отличие от `CWinApp` объект приложения, `CWinApp` объект библиотеки DLL не имеет цикла обработки сообщений.

Обратите внимание, что поскольку `CWinApp::Run` механизм не применяется в DLL-библиотеку, приложение имеет основной конвейер сообщений. Если библиотеки DLL открывает безрежимные диалоговые окна или фрейма главного окна свои собственные, приложения главный цикл обработки сообщений должен вызывать процедуру, экспортируемые библиотеки DLL, которая в свою очередь вызывает `CWinApp::PreTranslateMessage` функция-член объекта приложения библиотеки DLL.

## <a name="mfc_optimization"></a> Способы оптимизации следует использовать для улучшения клиентское приложение&#39;s производительности при загрузке?

Если ваш DLL – обычной MFC DLL, статически компонуемые с MFC, изменив ее на обычную библиотеку DLL MFC, динамически компонуемые с MFC уменьшает размер файла.

Если DLL имеет большое количество функций, используйте DEF-файл для экспорта функций (вместо использования **__declspec(dllexport)**) и использовать в DEF-файле [NONAME-атрибут](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md) на каждой экспортируемой функции. Атрибут NONAME приводит только порядковый номер и имя функции не должны храниться в таблице экспорта библиотеки DLL, которая уменьшает размер файла.

Библиотеки DLL, которые являются косвенным образом связывается с приложения загружаются при загрузке приложения. Для повышения производительности при загрузке, попробуйте разделить такую библиотеку DLL в разные библиотеки DLL. Поместите все функции, которые требуются вызывающему приложению сразу после загрузки в одну DLL и вызывающее приложение неявно ссылаются на эту Библиотеку. Поместите другие функции, которые вызывающему приложению не требуется сразу в другую библиотеку DLL, и у приложения явным образом связать с этой библиотекой DLL. Дополнительные сведения см. в разделе [Определение подходящего метода связывания использовать](../build/linking-an-executable-to-a-dll.md#determining-which-linking-method-to-use).

## <a name="memory_leak"></a> Существует&#39;s утечки памяти в в обычной библиотеке DLL MFC, но мой код выглядит хорошо. Как найти утечки памяти?

Одной из возможных причин утечки памяти является то, что MFC создает временные объекты, которые используются внутри функций обработчиков сообщений. В приложениях MFC, эти временные объекты автоматически очищаются в `CWinApp::OnIdle()` функция, вызываемая между обработки сообщений. Тем не менее, в MFC-библиотеки динамической компоновки (DLL) `OnIdle()` функция не вызывается автоматически. Таким образом временные объекты не удаляются автоматически. Чтобы очистить временные объекты, необходимо явно вызывать библиотеки DLL `OnIdle(1)` периодически.

## <a name="see-also"></a>См. также

[DLL в Visual C++](../build/dlls-in-visual-cpp.md)