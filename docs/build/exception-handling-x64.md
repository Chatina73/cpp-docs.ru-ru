---
title: x64 обработки исключений
ms.date: 12/17/2018
helpviewer_keywords:
- C++ exception handling, x64
- exception handling, x64
ms.assetid: 41fecd2d-3717-4643-b21c-65dcd2f18c93
ms.openlocfilehash: 33206dfb885239839c3a64436b6b540fc7d4e6e5
ms.sourcegitcommit: ff3cbe4235b6c316edcc7677f79f70c3e784ad76
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/19/2018
ms.locfileid: "53627544"
---
# <a name="x64-exception-handling"></a>x64 обработки исключений

Обзор структурированной обработки исключений и обработки исключений C++, кодирования, соглашений и поведение в x64. Общие сведения об обработке исключений см. в разделе [обработка исключений в Visual C++](../cpp/exception-handling-in-visual-cpp.md).

## <a name="unwind-data-for-exception-handling-debugger-support"></a>Данные для обработки исключений, поддержки отладчика очистки

Для обработки исключений и поддержки отладки, необходимы несколько структур данных.

### <a name="struct-runtimefunction"></a>структура RUNTIME_FUNCTION

Обработка исключений на основе таблицы требуется запись таблицы для всех функций, которые выделяют пространство стека или вызова другой функции (например, функции неконечным). Функция записи таблицы имеют формат:

|||
|-|-|
|ULONG|Начальный адрес функции|
|ULONG|Конечный адрес функции|
|ULONG|Адрес очистки|

Структура RUNTIME_FUNCTION должна быть DWORD выравнивания в памяти. Все адреса задаются относительно образа, то есть они являются 32-разрядные смещения от начальный адрес образа, который содержит запись в таблице функций. Эти записи отсортированы и помещены в раздел .pdata образа PE32 +. Для динамически создаваемых функций [JIT-компиляторов] среда выполнения для поддержки этих функций необходимо использовать RtlInstallFunctionTableCallback или RtlAddFunctionTable для предоставления этих сведений в операционную систему. Невыполнение этого требования приведет к ненадежной обработки исключений и отладки процессов.

### <a name="struct-unwindinfo"></a>Структура UNWIND_INFO

Информационная структура очищения данных используется для записи эффектов функция имеет указатель стека и сохранения защищенных регистров в стек.

|||
|-|-|
|UBYTE: 3|Версия|
|UBYTE: 5|Флаги|
|UBYTE|Размер пролога|
|UBYTE|Число кодов очистки.|
|UBYTE: 4|Регистр кадра|
|UBYTE: 4|Смещение регистра кадров (масштабировать)|
|USHORT \* n|Массив кодов очистки|
|переменная|Может быть формы (1) или (2) ниже|

(1) обработчик исключений

|||
|-|-|
|ULONG|Адрес обработчика исключений|
|Переменная|Обработчик конкретного языка данных (необязательно)|

(2) по цепочке раскрутки

|||
|-|-|
|ULONG|Начальный адрес функции|
|ULONG|Конечный адрес функции|
|ULONG|Адрес очистки|

Структура UNWIND_INFO должна быть DWORD выравнивания в памяти. Вот что означает каждое поле:

- **Version**

   Номер версии для очистки данных, в данный момент 1.

- **флаги**

   В настоящее время определены три флага:

   |Flag|Описание:|
   |-|-|
   |`UNW_FLAG_EHANDLER`| Функция имеет обработчик исключений, который должен быть вызван при поиске функций, которые необходимо изучить исключения.|
   |`UNW_FLAG_UHANDLER`| Функция имеет обработчик завершения, который должен вызываться при очистке исключения.|
   |`UNW_FLAG_CHAININFO`| Это раскрутки, структура не является первичной для процедуры. Вместо этого связанных данных раскрутки запись представляет собой содержание предыдущей записи RUNTIME_FUNCTION. Сведения см. в разделе [Chained очистки структуры](#chained-unwind-info-structures). Если этот флаг установлен, необходимо очистить флаги UNW_FLAG_EHANDLER и UNW_FLAG_UHANDLER. Кроме того кадр регистра и исправлена стека выделения поля должны иметь те же значения, как и в основной раскрутки.|

- **Размер пролога**

   Длина пролога функции в байтах.

- **Число кодов очистки.**

   Число слотов в массиве кодов очистки. Некоторые коды очистки, например, UWOP_SAVE_NONVOL требуют больше одного слота в массиве.

- **Регистр кадра**

   Если не равен нулю, то функция использует указатель фрейма (FP) и это поле — это количество защищенных регистр, используемый в качестве указателя кадра, используя ту же кодировку поле сведений об операции узлов UNWIND_CODE.

- **Смещение (масштабировать) регистра кадра**

   Если поле регистра кадра не равно нулю, это поле остается масштабированное смещение от RSP, который применяется к FP регистрации после его установки. Фактический регистр FP имеет значение RSP + 16 \* это число, что позволяет смещения от 0 до 240. Это смещение разрешает направление регистр FP в середину локального выделения стека для динамических кадров стека, обеспечивая лучшую плотность кода через более коротких инструкций (Дополнительные инструкции можно использовать для смещения 8-разрядное знаковое число).

- **Массив кодов очистки**

   Массив элементов, объясняет влияние пролога на неизменяемые регистры и RSP. См. в разделе об использовании UNWIND_CODE для значений отдельных элементов. Для выравнивания этот массив всегда имеет четное число записей, и последняя запись потенциально неиспользуемые. В этом случае массив является один больше времени, чем указано по числу полей кодов очистки.

- **Адрес обработчика исключений**

   Указатель функции исключения для конкретных языков или обработчик завершения, если флаг UNW_FLAG_CHAININFO clear и один из флагов UNW_FLAG_EHANDLER или UNW_FLAG_UHANDLER устанавливается значение.

- **Обработчик конкретного языка данных**

   Данные обработчика исключений конкретного языка функции. Формат этих данных не указано и полностью определяется обработчик используется конкретное исключение.

- **Связанные сведения об очистке:**

   Если установлен флаг UNW_FLAG_CHAININFO структура UNWIND_INFO завершается с тремя UWORDs.  Эти UWORDs представляют данные RUNTIME_FUNCTION для функции в цепочке очистки.

### <a name="struct-unwindcode"></a>Структура UNWIND_CODE

В массиве кодов очистки используется для записи последовательности операций в прологе, влияющих на неизменяемые регистры и RSP. Каждый элемент кода имеет следующий формат:

|||
|-|-|
|UBYTE|Смещение в прологе|
|UBYTE: 4|Код операции очистки|
|UBYTE: 4|Сведения об операции|

Массив сортируется по убыванию смещения в прологе.

#### <a name="offset-in-prolog"></a>Смещение в прологе

Смещение от начала пролога конец инструкции, выполняющий эту операцию, плюс 1 (то есть смещение начала следующей инструкции).

#### <a name="unwind-operation-code"></a>Код операции очистки

Примечание. Определенные коды операций требуется смещение без знака со значением в локальном стеке. Это смещение относится с самого начала, то есть наименьший адрес выделения основных стека. Если поле регистра кадра стека в UNWIND_INFO равно нулю, это смещение относится от RSP. Если поле регистра кадра не равно нулю, это смещение от где RSP был задан, если регистр FP было установлено. Это соответствует значению регистр FP минус величина смещения регистр FP (16 \* масштабированное смещение регистра кадра стека в UNWIND_INFO). Если используется регистр FP, затем любой код раскрутки смещение должно использоваться только после того как регистр FP установлено в прологе.

Для всех кодов операций, за исключением `UWOP_SAVE_XMM128` и `UWOP_SAVE_XMM128_FAR`, смещение всегда кратно 8, так как все стека интересующие значения хранятся на 8-байтовым границам (сам стек всегда является 16-байтовым). Для кодов операций с коротким смещением (менее 512 КБ) завершающий USHORT в узлах кода содержит смещение, разделенное на 8. Для кодов операций длинным смещением (512K < = смещение < 4 ГБ), окончательный двумя узлами USHORT для этого кода содержат смещение (в формате с прямым порядком байтов).

Для кодов операций `UWOP_SAVE_XMM128` и `UWOP_SAVE_XMM128_FAR`, смещение кратно всегда 16, так как все операции XMM 128-разрядный должно находиться на 16-байтовый выровненную память. Таким образом, используется коэффициент масштабирования 16 для `UWOP_SAVE_XMM128`, использовать смещение до 1 МБ.

Код операции очистки является одним из следующих значений:

- `UWOP_PUSH_NONVOL` (0) 1 узел

  Отправьте регистр защищенным целочисленным, уменьшение RSP по 8. Сведения об операции — номер регистра. Из-за ограничения, накладываемые на эпилога `UWOP_PUSH_NONVOL` кодов очистки должен быть первым в прологе и соответственно, последними в массиве кодов очистки. Этот относительный порядок применяется для всех других кодов очистки, за исключением `UWOP_PUSH_MACHFRAME`.

- `UWOP_ALLOC_LARGE` (1) 2 или 3 узлов

  Выделите большого объема в стеке. Существует две формы. Сведения об операции равен 0, то размер выделенной памяти, разделенный на 8 записывается в следующую ячейку, позволяя выделение до 512 K - 8. Если сведений об операции значение 1, то немасштабированным размер выделения записывается в следующие две ячейки в формате с прямым порядком байтов, что позволяет выделять до 4 ГБ - 8.

- `UWOP_ALLOC_SMALL` (2) узел 1

  Выделите небольшого объема в стеке. Размер выделения — это поле сведений об операции \* 8 + 8, что позволяет выделять от 8 до 128 байт.

  Код очистки для выделения памяти в стеке следует всегда использовать наиболее короткую кодировку:

  |**Размер выделения**|**Код очистки**|
  |-|-|
  |от 8 до 128 байт|`UWOP_ALLOC_SMALL`|
  |136 до 512 КБ — 8 байт|`UWOP_ALLOC_LARGE`, сведений об операции = 0|
  |512 КБ до 4 ГБ — 8 байт|`UWOP_ALLOC_LARGE`, сведений об операции = 1|

- `UWOP_SET_FPREG` (3) 1 узел

  Установите регистр указателя кадра, задав для некоторых смещение текущего RSP регистра. Смещение равно поле регистра кадра смещения (масштабирования) в UNWIND_INFO \* 16, что позволяет смещения от 0 до 240. Использование смещения позволяет установить указатель кадра, который указывает на середину фиксированного выделения стека, помогая плотность кода, позволяя несколько обращений к использовать форм коротких инструкций. Поле сведений об операции зарезервирован и не должны использоваться.

- `UWOP_SAVE_NONVOL` (4) 2 узлов

  Сохраните энергонезависимый регистр целых чисел в стеке, используя функцию MOV вместо Push-уведомления. Этот код в основном используется для *отведения сохранения*, в котором сохранен защищенный регистр в стек в позицию, которая ранее была выделена. Сведения об операции — номер регистра. Смещение стека масштабируется по 8 записывается в следующей ячейке кода завершающей операции, как описано ранее в примечании.

- `UWOP_SAVE_NONVOL_FAR` (5) 3 узлов

  Сохраните энергонезависимый регистр целых чисел в стеке с длинным смещением, используя функцию MOV вместо Push-уведомления. Этот код в основном используется для *отведения сохранения*, в котором сохранен защищенный регистр в стек в позицию, которая ранее была выделена. Сведения об операции — номер регистра. Смещение немасштабированным стека записывается в следующих двух кода завершающей операции, как описано ранее в примечании.

- `UWOP_SAVE_XMM128` (8) 2 узлов

  Сохраните все 128 байт энергонезависимого регистра XMM в стеке. Сведения об операции — номер регистра. Смещение стека масштабируется на 16 записывается в следующую ячейку.

- `UWOP_SAVE_XMM128_FAR` (9) 3 узлов

  Сохраните все 128 байт энергонезависимого регистра XMM в стеке с длинным смещением. Сведения об операции — номер регистра. Смещение немасштабированным стека записывается в следующие две ячейки.

- `UWOP_PUSH_MACHFRAME` (10) 1 узел

  Передача машинного кадра.  Используется для записи воздействия аппаратного прерывания или исключения. Существует две формы. Сведения об операции равен 0, один из этих кадров был отправлен в стек:

  |||
  |-|-|
  |RSP + 32|SS|
  |RSP + 24|Старый RSP|
  |RSP + 16|EFLAGS|
  |RSP + 8|CS|
  |RSP|ЗАРЕЗЕРВИРОВАННОГО IP-АДРЕСА|

  Если сведения об операции имеет значение 1, затем один из этих кадров был отправлен:

  |||
  |-|-|
  |RSP + 40|SS|
  |RSP + 32|Старый RSP|
  |RSP + 24|EFLAGS|
  |RSP + 16|CS|
  |RSP + 8|ЗАРЕЗЕРВИРОВАННОГО IP-АДРЕСА|
  |RSP|Код ошибки|

  Этот код очистки всегда отображается в фиктивном прологе, который никогда не выполняется, но вместо этого отображается перед реальной точкой входа подпрограммы прерывания и существует только для предоставления место для имитации передачи машинного кадра. `UWOP_PUSH_MACHFRAME` Записывает эту имитацию, что означает, что компьютер концептуально выполнил эту операцию:

  1. Обратного адреса RIP с вершины стека в *Temp*
  
  1. Передача SS

  1. Старый RSP Push-уведомлений

  1. Push-EFLAGS

  1. Передача CS

  1. Push- *Temp*

  1. Передача кода ошибки (если сведений об операции значение 1)

  Simulated `UWOP_PUSH_MACHFRAME` операции уменьшает RSP на 40 (сведений об операции значение 0) или 48 (сведений об операции значение 1).

#### <a name="operation-info"></a>Сведения об операции

Значения битов info операции зависит от кода операции. Для кодирования регистра общего назначения (целое число), такое сопоставление используется:

|||
|-|-|
|0|RAX|
|1|RCX|
|2|RDX|
|3|RBX|
|4|RSP|
|5|RBP|
|6|RSI|
|7|RDI|
|8 – 15|R8 для R15|

### <a name="chained-unwind-info-structures"></a>По цепочке очистки структуры

Если установлен флаг UNW_FLAG_CHAININFO имеет значение, то структура данных раскрутки является вторичной, а общего исключения обработчик/по цепочке-поле содержит первичную информацию раскрутки. Этот пример кода извлекает основной сведения очистки, при условии, что `unwindInfo` является структура, которая имеет UNW_FLAG_CHAININFO флаг.

```cpp
PRUNTIME_FUNCTION primaryUwindInfo = (PRUNTIME_FUNCTION)&(unwindInfo->UnwindCode[( unwindInfo->CountOfCodes + 1 ) & ~1]);
```

Связанные сведения можно использовать в двух ситуациях. Во-первых он может использоваться для несмежных сегментах кода. Используя связанные сведения, можно уменьшить размер требуемой информации раскрутки, так как вам не нужно дублировать массив кодов очистки из основной информации раскрутки.

Связанные сведения также можно группировать энергозависимых регистров. Компилятор может отложить сохранение некоторых энергозависимых регистров до выхода из пролога записи функции. Это можно зафиксировать благодаря наличию основных данных раскрутки для части в функцию перед группировкой кода и последующей установки связанных данных с ненулевой размер пролога, где коды очистки в связанные данные отражают сохраняет резервные неизменяемые регистры. В этом случае коды очистки представляют все экземпляры UWOP_SAVE_NONVOL. Это группа, которая сохраняет неизменяемые регистры с помощью Push-уведомления или изменяет RSP регистр с помощью выделения дополнительных основных стека не поддерживается.

Иногда называют UNWIND_INFO элемент, имеющий UNW_FLAG_CHAININFO набор может содержать запись RUNTIME_FUNCTION которого UNWIND_INFO элемент также содержит значение, UNW_FLAG_CHAININFO *несколько отведения сохранения*. В итоге связанных данных раскрутки указатели образовать UNWIND_INFO элемент, имеющий UNW_FLAG_CHAININFO очищен; Это основной элемент UNWIND_INFO, указывающая на фактическую точку входа процедуры.

## <a name="unwind-procedure"></a>Процедура очистки

В массиве кодов очистки сортируется в порядке убывания. При возникновении исключения, полный контекст сохраняется операционной системой в записи контекста. Затем вызывается логика обработки исключений, которая многократно выполняет следующие действия, чтобы найти обработчик исключений:

1. Используйте текущий RIP, хранящиеся в записи контекста для поиска таблице RUNTIME_FUNCTION, описывающий текущую функцию (или часть функции, для связанных записей UNWIND_INFO).

1. Если записи в таблице функций обнаруживается, то в конечной функцией, и RSP непосредственно решает возвращают указатель. Возвращают указатель на [RSP] сохраняется в обновленном контексте, смоделированный RSP увеличивается на 8 и повторить шаг 1.

1. При обнаружении записи в таблице функции RIP может лежать в трех регионах:) в заключительной части, b) в прологе или c) в коде, которые могут быть включены в обработчик исключений.

   - Case) если RIP лежит в заключительной части, то элемент управления выходит из функции, может существовать обработчик исключения для этой функции и последствия эпилога необходимо продолжить для вычисления контекста вызывающей функции. Чтобы определить, если RIP в заключительной части, поток кода из зарезервированного IP-адреса, в проверке. Если поток кода могут быть сопоставлены с конечной части допустимого эпилога, то он находится в заключительной части и моделировании оставшуюся часть эпилога, с помощью записи контекста, обновляются при каждой инструкцией по обработке. После этого продолжается, шаг 1.

   - Случай b), если RIP находится в прологе, то элемент управления не вошел в функцию, может существовать обработчик исключения для этой функции и влияние пролога должны быть отменены для вычисления контекста вызывающей функции. RIP лежит в прологе, если расстояние от начала функции до RIP меньше или равен размеру пролога, закодированные в раскрутки. Результаты в прологе очищаются при просмотре вперед по массиве кодов очистки для первой записи со смещением, меньшим или равным смещению RIP от начала функции, а затем Отмена результата для всех остальных элементов в массиве кодов очистки. Шаг 1, затем повторяется.

   - Случай c), если RIP находится за пределами пролога или эпилога и функция имеет обработчик исключений (UNW_FLAG_EHANDLER имеет значение), то вызывается обработчик конкретного языка. Обработчик просматривает данные и вызывает соответствующие функции фильтра. Обработчик конкретного языка может возвращать, что исключение было обработано или что поиск будет продолжен. Его также можно инициировать очистку напрямую.

1. Если обработчик конкретного языка возвращается в состояние обработано, то выполнение продолжается с использованием исходной записи контекста.

1. Если отсутствует обработчик конкретного языка или обработчик возвращается в состояние «продолжить», записи контекста должен быть развернут в состояние вызывающего объекта. Это достигается путем обработки всех элементов массива кода очистки, Отмена результата каждого из них. Шаг 1, затем повторяется.

При объединении в цепочку очистки данные, по-прежнему соблюдаются следующие основные шаги. Единственное отличие том, что во время прохода в массиве кодов очистки для очистки для пролога, по достижении конца массива, она затем привязывается к раскрутки родительского и выполняется обход всей очистки массиву. Эта привязка продолжается до раскрутки без флага UNW_CHAINED_INFO и после окончания прохода его массиве кодов очистки.

Данные раскрутки наименьший набор имеет размер 8 байт. Этот объект представляет функцию, которая 128 байтов стека или меньше и сэкономить один защищенный регистр. Это также размер связанной структуры данных очистки для пролога нулевой длины без кодов очистки.

## <a name="language-specific-handler"></a>Обработчик конкретного языка

Относительный адрес обработчик конкретного языка присутствует в UNWIND_INFO всякий раз, когда флаги UNW_FLAG_EHANDLER или UNW_FLAG_UHANDLER установлены. Как описано в предыдущем разделе, обработчик конкретного языка вызывается как часть поиска обработчика исключений или как часть очистка. Он имеет этот прототип:

```cpp
typedef EXCEPTION_DISPOSITION (*PEXCEPTION_ROUTINE) (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN ULONG64 EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PDISPATCHER_CONTEXT DispatcherContext
);
```

**ExceptionRecord** предоставляет указатель на запись исключения, имеющий стандартное определение Win64.

**EstablisherFrame** — это адрес базового выделения основных стека для этой функции.

**ContextRecord** указывает на контекст исключения во время (в случае обработчик исключений) было создано исключение или текущего «очистить» контекста (в случае обработчик завершения).

**DispatcherContext** указывает на контекст dispatcher для этой функции. Он содержит это определение:

```cpp
typedef struct _DISPATCHER_CONTEXT {
    ULONG64 ControlPc;
    ULONG64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG64 EstablisherFrame;
    ULONG64 TargetIp;
    PCONTEXT ContextRecord;
    PEXCEPTION_ROUTINE LanguageHandler;
    PVOID HandlerData;
} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;
```

**ControlPc** является значением зарезервированного IP-адреса в пределах этой функции. Это значение является адрес исключения или адрес, по которому элемент управления влево функцию установления. RIP используется для определения, является ли элемент управления в рамках защищенной конструкции внутри этой функции, например, `__try` блокировать `__try` / `__except` или `__try` / `__finally`.

**"Imagebase"** представляет собой основу образа (адрес загрузки) модуля, содержащего данную функцию, добавляемым к 32-разрядные смещения, используемые в функции записи и раскрутки для записи относительных адресов.

**FunctionEntry** указателем на RUNTIME_FUNCTION функцию записи, содержащий функцию и очистки относительные адреса основного образа сведения для этой функции.

**EstablisherFrame** — это адрес базового выделения основных стека для этой функции.

**TargetIp** предоставляет необязательный инструкции адрес, который указывает адрес продолжения очистку. Этот адрес учитывается, если **EstablisherFrame** не указан.

**ContextRecord** указывает на контекст исключения для использования в коде системы диспетчеризации или раскрутки исключение.

**LanguageHandler** указывает языкового подпрограмму обработчика вызова.

**HandlerData** указывает на данные языкового обработчика для этой функции.

## <a name="unwind-helpers-for-masm"></a>Завершение вспомогательных процедур для MASM

Для записи правильной ассемблера, имеется набор псевдо операций, которые могут использоваться параллельно с фактической сборке инструкции для создания соответствующих pdata и xdata. Существует также набор макросов, которые обеспечивают упрощенное использование псевдо операций для наиболее распространенных случаях.

### <a name="raw-pseudo-operations"></a>Необработанные псевдо операций

|Псевдо-операции|Описание:|
|-|-|
|PROC КАДРА \[:*обработчика ошибок*]|Причины MASM для создания функции запись в .pdata таблицы и очистки информацию в XDATA для функции структурной обработки исключений очистки поведение.  Если *обработчика ошибок* присутствует, данная процедура вводится в xdata как обработчик конкретного языка.<br /><br /> При использовании атрибута КАДРА, его следует указать. Директива ENDPROLOG.  Если функция является конечной (как определено в [типы функций](../build/stack-usage.md#function-types)) атрибута FRAME необязателен, как и остальная часть этих псевдо операций.|
|. PUSHREG *регистрации*|Создает UWOP_PUSH_NONVOL запись для указанного номера регистра с использованием текущего смещения в прологе.<br /><br /> Это свойство следует использовать только с защищенных целочисленные регистры.  Push-уведомлений переменные регистры, использовать. ALLOCSTACK 8 вместо|
|. SETFRAME *зарегистрировать*, *смещение*|Заливки в окне регистрации поля и смещение в информацию очистки с помощью указанного регистра и смещения. Смещение должно быть кратным 16 и меньше или равно 240. Эта директива также создает в коде завершения UWOP_SET_FPREG очистки запись для указанного регистра, с помощью текущего смещения пролога.|
|. ALLOCSTACK *размер*|Создает UWOP_ALLOC_SMALL или UWOP_ALLOC_LARGE заданного размера для текущего смещения в прологе.<br /><br /> *Размер* операнд должен быть кратен 8.|
|. SAVEREG *зарегистрировать*, *смещение*|Создает UWOP_SAVE_NONVOL или UWOP_SAVE_NONVOL_FAR запись для указанного регистра и смещение, с помощью текущего смещения пролога. MASM выбирает наиболее эффективную кодировку.<br /><br /> *Смещение* должны быть положительными и кратен 8. *Смещение* указывается относительно процедуры кадра, который обычно находится в RSP, или указатель немасштабированным кадра.|
|. SAVEXMM128 *зарегистрировать*, *смещение*|Создает UWOP_SAVE_XMM128 или UWOP_SAVE_XMM128_FAR запись для указанного регистра XMM и смещение, с помощью текущего смещения пролога. MASM выбирает наиболее эффективную кодировку.<br /><br /> *Смещение* должны быть положительными и кратен 16.  *Смещение* указывается относительно процедуры кадра, который обычно находится в RSP, или указатель немасштабированным кадра.|
|. PUSHFRAME \[ *кода*]|Создает запись UWOP_PUSH_MACHFRAME очистки кода. Если необязательный *кода* указан, операция очистки кода присваивается модификатор 1. В противном случае модификатор равно 0.|
|.ENDPROLOG|Сигнализирует об окончании объявлений пролога.  Должен существовать в первые 255 байт функции.|

Ниже приведен пример пролога функции использование большинства кодов операций.

```MASM
sample PROC FRAME
    db      048h; emit a REX prefix, to enable hot-patching
    push rbp
    .pushreg rbp
    sub rsp, 040h
    .allocstack 040h
    lea rbp, [rsp+020h]
    .setframe rbp, 020h
    movdqa [rbp], xmm7
    .savexmm128 xmm7, 020h ;the offset is from the base of the frame
                           ;not the scaled offset of the frame
    mov [rbp+018h], rsi
    .savereg rsi, 038h
    mov [rsp+010h], rdi
    .savereg rdi, 010h ; you can still use RSP as the base of the frame
                       ; or any other register you choose
    .endprolog

; you can modify the stack pointer outside of the prologue (similar to alloca)
; because we have a frame pointer.
; if we didn’t have a frame pointer, this would be illegal
; if we didn’t make this modification,
; there would be no need for a frame pointer

    sub rsp, 060h

; we can unwind from the next AV because of the frame pointer

    mov rax, 0
    mov rax, [rax] ; AV!

; restore the registers that weren’t saved with a push
; this isn’t part of the official epilog, as described in section 2.5

    movdqa xmm7, [rbp]
    mov rsi, [rbp+018h]
    mov rdi, [rbp-010h]

; Here’s the official epilog

    lea rsp, [rbp-020h]
    pop rbp
    ret
sample ENDP
```

### <a name="masm-macros"></a>Макросы MASM

Чтобы упростить использование [необработанных операций псевдо](#raw-pseudo-operations), имеется набор макросов, определенных в файле ksamd64.inc, который может использоваться для создания типичных прологов и эпилогов.

|Макрос|Описание:|
|-|-|
|alloc_stack(n)|Выделяет кадр стека n байт (с помощью `sub rsp, n`) и создает соответствующую информацию (.allocstack n) для раскрутки|
|save_reg *reg*, *loc*|Сохраняет защищенный регистр *reg* стека на RSP смещение *loc*и создает соответствующую информацию для раскрутки. (.savereg reg, loc)|
|push_reg *reg*|Помещает защищенный регистр *reg* в стеке и создает соответствующую информацию для раскрутки. (.pushreg reg)|
|rex_push_reg *reg*|Сохраняет защищенный регистр в стеке с помощью извещающей 2 byte и выдает соответствующую информацию (.pushreg reg), это следует использовать при первой инструкции в функции, чтобы убедиться, что функция является исправлять "Горячий" Push-уведомления для раскрутки.|
|save_xmm128 *reg*, *loc*|Сохраняет защищенный регистр XMM *reg* стека на RSP смещение *loc*и создает соответствующую информацию (.savexmm128 reg, loc) для раскрутки|
|set_frame *reg*, *смещение*|Задает регистр кадра *reg* быть RSP + *смещение* (с помощью `mov`, или `lea`) и создает соответствующую информацию (.set_frame reg, смещение) для раскрутки|
|push_eflags|Помещает eflags с `pushfq` инструкции и создает соответствующую информацию (".alloc_stack 8") для раскрутки|

Ниже приведен пример пролога функции надлежащего использования макросов.

```MASM
SkFrame struct
    Fill    dq ?; fill to 8 mod 16
    SavedRdi dq ?; saved register RDI
    SavedRsi dq ?; saved register RSI
SkFrame ends

sampleFrame struct
    Filldq?; fill to 8 mod 16
    SavedRdidq?; Saved Register RDI
    SavedRsi  dq?; Saved Register RSI
sampleFrame ends

sample2 PROC FRAME
    alloc_stack(sizeof sampleFrame)
    save_reg rdi, sampleFrame.SavedRdi
    save_reg rsi, sampleFrame.SavedRsi
    .end_prolog

; function body

    mov rsi, sampleFrame.SavedRsi[rsp]
    mov rdi, sampleFrame.SavedRdi[rsp]

; Here’s the official epilog

    add rsp, (sizeof sampleFrame)
    ret
sample2 ENDP
```

## <a name="unwind-data-definitions-in-c"></a>Описание раскрутки данных в языке C

Вот описание раскрутки данных:

```C
typedef enum _UNWIND_OP_CODES {
    UWOP_PUSH_NONVOL = 0, /* info == register number */
    UWOP_ALLOC_LARGE,     /* no info, alloc size in next 2 slots */
    UWOP_ALLOC_SMALL,     /* info == size of allocation / 8 - 1 */
    UWOP_SET_FPREG,       /* no info, FP = RSP + UNWIND_INFO.FPRegOffset*16 */
    UWOP_SAVE_NONVOL,     /* info == register number, offset in next slot */
    UWOP_SAVE_NONVOL_FAR, /* info == register number, offset in next 2 slots */
    UWOP_SAVE_XMM128 = 8, /* info == XMM reg number, offset in next slot */
    UWOP_SAVE_XMM128_FAR, /* info == XMM reg number, offset in next 2 slots */
    UWOP_PUSH_MACHFRAME   /* info == 0: no error-code, 1: error-code */
} UNWIND_CODE_OPS;

typedef union _UNWIND_CODE {
    struct {
        UBYTE CodeOffset;
        UBYTE UnwindOp : 4;
        UBYTE OpInfo   : 4;
    };
    USHORT FrameOffset;
} UNWIND_CODE, *PUNWIND_CODE;

#define UNW_FLAG_EHANDLER  0x01
#define UNW_FLAG_UHANDLER  0x02
#define UNW_FLAG_CHAININFO 0x04

typedef struct _UNWIND_INFO {
    UBYTE Version       : 3;
    UBYTE Flags         : 5;
    UBYTE SizeOfProlog;
    UBYTE CountOfCodes;
    UBYTE FrameRegister : 4;
    UBYTE FrameOffset   : 4;
    UNWIND_CODE UnwindCode[1];
/*  UNWIND_CODE MoreUnwindCode[((CountOfCodes + 1) & ~1) - 1];
*   union {
*       OPTIONAL ULONG ExceptionHandler;
*       OPTIONAL ULONG FunctionEntry;
*   };
*   OPTIONAL ULONG ExceptionData[]; */
} UNWIND_INFO, *PUNWIND_INFO;

typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    ULONG UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

#define GetUnwindCodeEntry(info, index) \
    ((info)->UnwindCode[index])

#define GetLanguageSpecificDataPtr(info) \
    ((PVOID)&GetUnwindCodeEntry((info),((info)->CountOfCodes + 1) & ~1))

#define GetExceptionHandler(base, info) \
    ((PEXCEPTION_HANDLER)((base) + *(PULONG)GetLanguageSpecificDataPtr(info)))

#define GetChainedFunctionEntry(base, info) \
    ((PRUNTIME_FUNCTION)((base) + *(PULONG)GetLanguageSpecificDataPtr(info)))

#define GetExceptionDataPtr(info) \
    ((PVOID)((PULONG)GetLanguageSpecificData(info) + 1)
```

## <a name="see-also"></a>См. также

[x64 программные соглашения](../build/x64-software-conventions.md)