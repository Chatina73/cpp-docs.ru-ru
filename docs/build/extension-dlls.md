---
title: Библиотеки DLL расширения
ms.date: 11/04/2016
f1_keywords:
- afxdll
helpviewer_keywords:
- memory [C++], DLLs
- MFC extension DLLs [C++]
- AFXDLL library
- shared resources [C++]
- MFC DLLs [C++], MFC extension DLLs
- DLLs [C++], extension
- shared DLL versions [C++]
- resource sharing [C++]
- extension DLLs [C++]
- extension DLLs [C++], about MFC extension DLLs
ms.assetid: f69ac3d4-e474-4b1c-87a1-6738843a135c
ms.openlocfilehash: 28954ff1c77b7dcc530392fce095ed9df5c29cbf
ms.sourcegitcommit: bff17488ac5538b8eaac57156a4d6f06b37d6b7f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2019
ms.locfileid: "57414568"
---
# <a name="mfc-extension-dlls"></a>Библиотеки DLL расширений MFC

Расширения MFC DLL представляет собой библиотеку DLL, которая обычно реализуют классы многократного использования, производные от существующих классов библиотеки Microsoft Foundation Class.

Библиотеки DLL расширения MFC предоставляет следующие функции и требования:

- Исполняемый файл клиента должно быть приложение MFC, скомпилированные с использованием `_AFXDLL` определен.

- Библиотеки DLL расширения MFC также может использоваться обычной библиотеки DLL MFC, динамически компонуемые с MFC.

- Библиотеки DLL расширений MFC, которые должны быть скомпилированы с `_AFXEXT` определен. Это заставляет `_AFXDLL` также и гарантирует, что объявлений загружается из файлах заголовков MFC. Это также гарантирует, что `AFX_EXT_CLASS` определяется как `__declspec(dllexport)` при построении библиотеки DLL, который необходим, если вы используете этот макрос для объявления классов в библиотеке DLL расширения MFC.

- Библиотеки DLL расширений MFC не следует создавать экземпляр класса, производного от `CWinApp`, но полагаются на клиентское приложение (или DLL) для предоставления этого объекта.

- Библиотеки DLL расширений MFC однако обеспечивают `DllMain` функции и выполнить любую необходимую инициализацию.

Библиотеки DLL расширения создаются с помощью версии библиотеки MFC (также называется общей версии MFC). Только исполняемыми приложениями MFC (приложения или обычные библиотеки DLL MFC), построенные с помощью общей версии MFC можно использовать библиотеки DLL расширения MFC. Клиентское приложение и библиотека DLL расширения MFC необходимо использовать ту же версию MFCx0.dll. С помощью библиотеки DLL расширения MFC можно создать новые пользовательские классы из MFC и затем предложить это расширенная версия MFC, к приложениям, которые вызывают библиотеку DLL.

Библиотеки DLL расширения можно использовать также для передачи объекты, производные от приложения и библиотеки DLL. Функции-члены, связанные с переданный объект существует в модуле, в котором был создан объект. Так как эти функции экспортируются правильно при использовании общей версии библиотеки DLL MFC, можно свободно передавать MFC или MFC-производный объект указатели между приложением и библиотеки DLL, он загружает расширения MFC.

Библиотеки DLL расширения MFC использует общей версии MFC таким же образом, приложение использует общедоступную версию библиотеки DLL MFC, с помощью несколько дополнительных факторов:

- Он не имеет `CWinApp`-объект, производный от. Он должен работать с `CWinApp`-производным объектом клиентского приложения. Это означает, что клиентское приложение, которому принадлежит, основной конвейер сообщений, цикл простоя и т. д.

- Он вызывает `AfxInitExtensionModule` в его `DllMain` функции. Следует проверить возвращаемое значение функции. Если возвращено нулевое значение из `AfxInitExtensionModule`, возвращают 0 из вашей `DllMain` функции.

- Он создает **CDynLinkLibrary** объекта во время инициализации, если расширения MFC DLL собирается экспортировать `CRuntimeClass` объектов или ресурсов для приложения.

До версии MFC 4.0 этот тип из библиотеки DLL, был вызван AFXDLL. AFXDLL ссылается `_AFXDLL` символ препроцессора, который определяется при построении библиотеки DLL.

Импортируемые библиотеки для общей версии MFC присваиваются в соответствии с соглашением, описанным в [соглашения об именовании библиотек DLL MFC](../mfc/mfc-library-versions.md#mfc-static-library-naming-conventions). Visual C++ предоставляет предварительно созданные версии библиотек DLL MFC, а также ряд из отличных от библиотек DLL MFC, можно использовать и распространять с приложением. Все они описаны в файле Redist.txt, который устанавливается в папку Program Files\Microsoft Visual Studio.

При экспорте с использованием DEF-файла, поместите следующий код в начале и конце файла заголовка:

```cpp
#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA
// <body of your header file>
#undef AFX_DATA
#define AFX_DATA
```

Эти четыре строки убедитесь, что ваш код компилируется правильно для библиотеки DLL расширения MFC. Если исключить эти четыре строки может привести к библиотеки DLL для компиляции или некорректно.

Если необходимо передать MFC или MFC-производный объект указатель или из библиотеки DLL MFC, библиотеки DLL должны быть библиотеки DLL расширения MFC. Функции-члены, связанные с переданный объект существует в модуле, в котором был создан объект. Так как эти функции экспортируются правильно при использовании общей версии библиотеки DLL MFC, можно свободно передавать MFC или MFC-производный объект указатели между приложением и библиотеки DLL, он загружает расширения MFC.

Из-за проблемы искажения и экспорта имен C++ список экспорта из расширения MFC DLL могут отличаться между отладочные и розничные версии той же библиотеки DLL и библиотеки DLL для различных платформ. Версии MFCx0.dll около 2 000 экспортированных точек входа; отладочные версии MFCx0D.dll — имеется около 3000 экспортированных точек входа.

## <a name="memory-management"></a>Управление памятью

MFCx0.dll и все расширения MFC, библиотеки DLL загружаются в клиентское приложение адресное пространство используют же распределитель памяти, загрузка ресурсов и другие глобальные состояния MFC, как если бы они были в одном приложении. Это важно, так как библиотеки MFC DLL и обычные библиотеки DLL MFC выполнять прямо противоположно и каждой библиотеки DLL, выделение за пределами пула памяти.

Если библиотеки DLL расширения MFC выделяет память, что память можно свободно смешивается с любым другим объектом, выделенными в приложение. Кроме того в случае сбоя приложения, динамически скомпонованную с MFC защиты операционной системы обеспечивает целостность любого другого приложения MFC DLL.

Аналогичным образом другие глобальные состояния MFC, такие как текущий исполняемый файл для загрузки ресурсов, также являются общими между клиентским приложением и все библиотеки DLL расширения MFC также самой MFCx0.dll.

## <a name="sharing-resources-and-classes"></a>Совместное использование ресурсов и классы

Экспорт ресурсов осуществляется по списку ресурсов. Каждое приложение содержит однонаправленный список **CDynLinkLibrary** объектов. При поиске ресурса, сначала в текущем модуле ресурсов выполняют большую часть стандартных реализаций MFC, загружающих ресурсы (`AfxGetResourceHandle`) и если ресурс не найден стека список **CDynLinkLibrary** объектов Попытка загрузки запрошенного ресурса.

Проход по списку имеет недостатки, что он немного медленнее и требует управления уровнями идентификатора ресурса. Он имеет то преимущество, что клиентское приложение, которое содержит ссылки на несколько библиотек DLL расширения MFC можно использовать любой предоставленный библиотекой DLL ресурсов без указания дескриптора экземпляра библиотеки DLL. `AfxFindResourceHandle` API-Интерфейс, используемый для просмотра списка ресурсов для поиска для данного сопоставления. Она принимает имя и тип ресурса и возвращает дескриптор ресурса, где он был обнаружен (или NULL).

Если вы не хотите проходят по списку и загружать ресурсы только из определенного места, используйте функции `AfxGetResourceHandle` и `AfxSetResourceHandle` для сохранения старого дескриптора и задайте новый маркер. Не забудьте восстановить старый дескриптор ресурсов, прежде чем вернуться в клиентское приложение. Пример использования этого подхода для явной загрузки меню, см. в разделе Testdll2 .cpp в образце MFC [DLLHUSK](https://github.com/Microsoft/VCSamples/tree/master/VC2010Samples/MFC/advanced/dllhusk).

Аналогично динамического создания объектов MFC, предоставляется имя MFC. Механизм десериализации объекта MFC должен иметь все `CRuntimeClass` объекты зарегистрированы, чтобы его можно восстановить путем динамического создания объектов C++ требуемого типа, в зависимости от того, что было сохранено ранее.

В нашем примере MFC [DLLHUSK](https://github.com/Microsoft/VCSamples/tree/master/VC2010Samples/MFC/advanced/dllhusk), список выглядит примерно так:

```
head ->   DLLHUSK.EXE   - or -   DLLHUSK.EXE
               |                      |
          TESTDLL2.DLL           TESTDLL2.DLL
               |                      |
          TESTDLL1.DLL           TESTDLL1.DLL
               |                      |
           MFCOxxD.DLL                |
               |                      |
           MFCDxxD.DLL                |
               |                      |
            MFCxxD.DLL            MFCxx.DLL
```

где *xx* — это номер версии; например, 42 представляет версии 4.2.

MFCxx.dll является обычно последним в списке ресурсов и в списке классов. MFCxx.dll включает все стандартные ресурсы MFC, включая строку запроса для всех стандартных идентификаторов команд. Позволяет поместить его в конец списка, библиотеки DLL и клиентское приложение не имеет свою собственную копию стандартные ресурсы MFC, а вместо этого полагаться на общие ресурсы в MFCxx.dll.

Объединение ресурсов и имена классов всех библиотек DLL в пространство имен клиентского приложения есть недостаток, что необходимо соблюдать осторожность, идентификаторов и имен, выберите.

[DLLHUSK](https://github.com/Microsoft/VCSamples/tree/master/VC2010Samples/MFC/advanced/dllhusk) пример управляет пространство имен общих ресурсов с помощью нескольких файлов заголовков.

Если библиотеки DLL расширения MFC необходимо сохранить дополнительные данные для каждого приложения, можно наследовать новый класс из **CDynLinkLibrary** и создать его в `DllMain`. При запуске, библиотеки DLL можно проверить список текущего приложения **CDynLinkLibrary** объектов для поиска для конкретной библиотеки DLL расширения MFC.

### <a name="what-do-you-want-to-do"></a>Выберите действие

- [Инициализация библиотеки DLL расширения MFC](../build/run-time-library-behavior.md#initializing-extension-dlls)

### <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Советы по использованию общих файлов ресурсов](../mfc/tn035-using-multiple-resource-files-and-header-files-with-visual-cpp.md)

- [Версия библиотеки DLL MFC](../mfc/tn033-dll-version-of-mfc.md)

- [Обычные библиотеки DLL MFC, статически компонуемые с MFC](../build/regular-dlls-statically-linked-to-mfc.md)

- [Обычные библиотеки DLL MFC, динамически компонуемые с MFC](../build/regular-dlls-dynamically-linked-to-mfc.md)

- [Использование библиотек DLL расширений MFC для баз данных, OLE и сокетов в обычных DLL-библиотеках MFC](../build/using-database-ole-and-sockets-extension-dlls-in-regular-dlls.md)

## <a name="see-also"></a>См. также

[DLL в Visual C++](../build/dlls-in-visual-cpp.md)
