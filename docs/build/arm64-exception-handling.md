---
title: Обработка исключений ARM64
ms.date: 11/19/2018
ms.openlocfilehash: 921029704e4bf5adabfbe0a82387dadc911b9036
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2019
ms.locfileid: "57816156"
---
# <a name="arm64-exception-handling"></a>Обработка исключений ARM64

Windows на ARM64 использует же механизм структурированной обработки исключений для асинхронных исключений, генерируемых оборудования и синхронных программных исключений. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. В этом документе описывается обработка исключений в Windows на ARM64, а также вспомогательные функции языка, используемых кодом, созданных в ассемблер ARM Microsoft и компилятором MSVC.

## <a name="goals-and-motivation"></a>Цели и причины создания

Соглашения об исключение очистки данных и это описание, предназначены для:

1. Предоставьте достаточно описание, которое разрешает очистки без кода, проверка во всех случаях.

   - Анализа кода требует, чтобы быть оповещен в код. Это позволяет избежать выполнения очистки в некоторых случаях целесообразно (трассировки, выборка, отладка).

   - Анализ кода является сложным; компилятору необходимо соблюдать осторожность формировать только инструкции, средство очистки способен декодирования.

   - Если очистка не может быть полностью описано при помощи кодов очистки, затем в некоторых случаях он должен возвращаться к декодирование инструкции. Это увеличивает общую сложность и в идеале можно предотвратить.

1. Поддержка очистки в середине пролога и эпилога среднего.

   - Очистка используется дольше, чем обработка исключений в Windows, поэтому крайне важно, что мы сможем выполнять значение точный очистки даже если в последовательность кода пролога и эпилога.

1. Занимают минимальный объем места.

   - Коды очистки должен не вычисляются для значительного увеличения двоичный размер.

   - Так как коды очистки, скорее всего, будет заблокирован в памяти, компактную гарантирует минимальные издержки для каждого загруженном двоичном коде.

## <a name="assumptions"></a>Допущения

Ниже приведены допущения, сделанные в описание обработки исключений.

1. Прологи и эпилоги стремятся зеркально отображать либо другой. Использует преимущества этого общую черту: размер метаданные, необходимые для описания очистки может значительно сократить. В теле функции не имеет ли операции пролога или операции эпилога выполняются с опережением. Оба случая должны давать одинаковые результаты.

1. Функции, как правило, в целом относительно небольшой размер. Несколько операций оптимизации для пространства используют это для достижения наиболее эффективной упаковки данных.

1. Отсутствует условный код в эпилога.

1. Регистр указателя фрейма выделенный: Если сохранен в другом регистре в прологе, который зарегистрирован (r29) не затрагиваются вся функция, что в любой момент может восстановить исходный.

1. Если только сохранен в другом регистре, все операции с указателем стека строго происходит в пределах пролога и эпилога.

1. Макет кадра стека организована, как описано в следующем разделе.

## <a name="arm64-stack-frame-layout"></a>Макет кадра стека ARM64

![Макет кадра стека](media/arm64-exception-handling-stack-frame.png "макет кадра стека")

Для фрейма связанных функций пары «fp-lr» могут быть сохранены в любой позиции в локальной переменной в зависимости от рекомендации по оптимизации. Целью является максимальное количество локальных переменных, которые могут быть достигнута по одной одной инструкции, на основе указателя фрейма (r29) или указателя стека (sp). Тем не менее для `alloca` функции, должны быть соединены и r29 должен указывать на нижней части стека. Чтобы разрешить большее покрытие register пара addressing-mode, энергонезависимой зарегистрировать aave, области располагаются в верхней части стека локальной сети. Ниже приведены примеры, иллюстрирующие некоторые из наиболее эффективный последовательности пролога. Ради ясности и лучшее расположение кэша порядок хранения вызываемой сохранения регистров в все канонические Прологи — в порядке «растущей вверх». `#framesz` ниже представляет размер всего стека (за исключением области alloca). `#localsz` и `#outsz` обозначают размер локальной сети (включая сохранения область для \<r29, lr > пары) и исходящие размер параметра, соответственно.

1. Объединять в цепочки, #localsz \<= 512

    ```asm
        stp    r19,r20,[sp,-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,16]            // save in FP regs (optional)
        stp    r0,r1,[sp,32]            // home params (optional)
        stp    r2,r3,[sp, 48]
        stp    r4,r5,[sp,64]
        stp    r6,r7,[sp,72]
        stp    r29, lr, [sp, -#localsz]!    // save <r29,lr> at bottom of local area
        mov    r29,sp                   // r29 points to bottom of local
        sub    sp, #outsz               // (optional for #outsz != 0)
    ```

1. Объединять в цепочки, #localsz > 512

    ```asm
        stp    r19,r20,[sp,-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,16]            // save in FP regs (optional)
        stp    r0,r1,[sp,32]            // home params (optional)
        stp    r2,r3,[sp, 48]
        stp    r4,r5,[sp,64]
        stp    r6,r7,[sp,72]
        sub    sp,#localsz+#outsz       // allocate remaining frame
        stp    r29, lr, [sp, #outsz]    // save <r29,lr> at bottom of local area
        add    r29,sp, #outsz           // setup r29 points to bottom of local area
    ```

1. Применение, конечным функциям (lr несохраненные)

    ```asm
        stp    r19,r20,[sp, -72]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    r21,r22,[sp, 16]
        str    r23 [sp,32]
        stp    d8,d9,[sp,40]            // save FP regs (optional)
        stp    d10,d11,[sp,56]
        sub    sp,#framesz-72           // allocate the remaining local area
    ```

   Все локальные осуществляется на основании SP. \<r29, lr > указывает на предыдущий кадр анимации. Для размер кадра \<= 512, «sub sp,...» может быть оптимизацией, если области реестров сохранен перемещается в нижней части стека. Недостатком этого является не согласуется с другими макеты выше, что сохраненный реестров участвовать диапазона для пары реестров и до и после индексированных смещения режим адресации.

1. Применение, не являющихся конечными функции (lr сохраняется в области сохранения Int)

    ```asm
        stp    r19,r20,[sp,-80]!        // pre-indexed, save in 1st FP/INT reg-pair
        stp    r21,r22,[sp,16]          // ...
        stp    r23, lr,[sp, 32]         // save last Int reg and lr
        stp    d8,d9,[sp, 48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,64]          // ...
        sub    sp,#framesz-80           // allocate the remaining local area
    ```

   Или с четным числом Сохраняемые регистры Int,

    ```asm
        stp    r19,r20,[sp,-72]!        // pre-indexed, save in 1st FP/INT reg-pair
        stp    r21,r22,[sp,16]          // ...
        str    lr,[sp, 32]              // save lr
        stp    d8,d9,[sp, 40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,56]          // ...
        sub    sp,#framesz-72           // allocate the remaining local area
    ```

   Сохранить только r19:

    ```asm
        sub    sp, sp, #16              // reg save area allocation*
        stp    r19,lr,[sp,0]            // save r19, lr
        sub    sp,#framesz-16           // allocate the remaining local area
    ```

   \* Reg Сохранить область выделения не свертывается в stp, поскольку stp предварительно индексированных reg-lr не могут быть представлены с кодами очистки.

   Все локальные осуществляется на основании SP. \<r29 > указывает на предыдущий кадр анимации.

1. Объединять в цепочки, #framesz \<= 512, #outsz = 0

    ```asm
        stp    r29, lr, [sp, -#framesz]!    // pre-indexed, save <r29,lr>
        mov    r29,sp                       // r29 points to bottom of stack
        stp    r19,r20,[sp, #framesz -32]   // save INT pair
        stp    d8,d9,[sp, #framesz -16]     // save FP pair
    ```

   Сравнивая пролога #1 выше, преимущество заключается в, готовы для выполнения сразу же после выделения инструкции только один стек все register сохранить инструкции. Таким образом отсутствует антивирусная зависимость на пакет, который предотвращает реализации параллелизма на уровне инструкций.

1. Объединять в цепочки, размер пакета > 512 (необязательно для функций без alloca)

    ```asm
        stp    r29, lr, [sp, -80]!          // pre-indexed, save <r29,lr>
        stp    r19,r20,[sp,16]              // save in INT regs
        stp    r21,r22,[sp,32]              // ...
        stp    d8,d9,[sp,48]                // save in FP regs
        stp    d10,d11,[sp,64]
        mov    r29,sp                       // r29 points to top of local area
        sub    sp,#framesz-80               // allocate the remaining local area
    ```

   В целях оптимизации r29 можно поместить в любом месте в локальной сети для обеспечения большее покрытие «reg пары» и до/после-indexed смещение режим адресации. "Локальные" ниже указатели на фреймы может осуществляться в зависимости от SP.

1. Объединять в цепочки, размер пакета > 4 КБ, независимо от alloca(),

    ```asm
        stp    r29, lr, [sp, -80]!          // pre-indexed, save <r29,lr>
        stp    r19,r20,[sp,16]              // save in INT regs
        stp    r21,r22,[sp,32]              // ...
        stp    d8,d9,[sp,48]                // save in FP regs
        stp    d10,d11,[sp,64]
        mov    r29,sp                       // r29 points to top of local area
        mov    r8, #framesz/16
        bl     chkstk
        sub    sp, r8*16                    // allocate remaining frame
                                            // end of prolog
        ...
        sp = alloca                         // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,r29                       // sp points to top of local area
        ldp    d10,d11, [sp,64],
        ...
        ldp    r29, lr, [sp], -80           // post-indexed, reload <r29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>ARM64 сведений об обработке исключений

### <a name="pdata-records"></a>записи .pdata

Записи .pdata — это упорядоченный массив элементов фиксированной длины, которые описывают каждый стеком функцию в двоичном файле PE. Внимательно прочитайте фразу «стеком»: конечным функциям, которой не требуется локальное хранилище и который не нужно сохранить или восстановить неизменяемые регистры не требуется запись .pdata; Это должна быть явно, пропущена для экономии места. Очистки из одной из этих функций можно просто получить обратный адрес LR для перемещения вверх, чтобы вызывающий объект.

Каждая запись .pdata для ARM64 — 8 байт. Общий формат областей, в каждой записи запустить 32-разрядный относительный виртуальный адрес функции в первом слове, следуют это секунда с, содержит указатель на блок .xdata переменной длины или упакованным словом, описывающий каноническую последовательность очистки функции.

![макет записи .pdata](media/arm64-exception-handling-pdata-record.png "макета записи .pdata")

Ниже приведены поля.

- **Функция запуска RVA** является 32-разрядный относительный виртуальный адрес начала функции.

- **Флаг** представляет собой 2-битовое поле, указывающее, как интерпретировать остальные 30 бит второго слова .pdata. Если **флаг** равно 0, то оставшиеся биты формируют **RVA сведения исключение** (с низкой два бита неявно 0). Если **флаг** не равно нулю, то оставшиеся биты формируют **упакованные данные очистки** структуры.

- **Исключение сведения RVA** — это адрес структуры сведений исключении переменной длины, хранимых в разделе .xdata. Эти данные должны быть выровнены по 4-байтовой границе.

- **Упакованные данные очистки** представляет собой сжатое описание операции, необходимые для выполнения очистки из функции в канонической форме. В этом случае запись .XDATA не требуется.

### <a name="xdata-records"></a>записи .xdata

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись .XDATA переменной длины. Адрес этой записи хранится во втором слове записи .PDATA. Формат .xdata — это упакованный набор слов переменной длины:

![макет записи .xdata](media/arm64-exception-handling-xdata-record.png "макета записи .xdata")

Эти данные разбиваются на четыре раздела:

1. 1 или 2 слов Заголовок описания общий размер структуры и предоставляя ключевые функциональные данные. Второе слово присутствует, только если оба **число эпилога** и **слов кодов** поля задается значение 0. Ниже приведены битовые поля в заголовке.

   1. **Функция длина** представляет собой 18-битовое поле, указывающее общую длину функции в байтах, поделенное на 4. Если функция является размером более 1 МБ, несколько записей pdata и xdata должен использоваться для описания функции. См. в разделе [крупных функций](#large-functions) более подробные сведения.

   2. **Vers** представляет собой 2-битовое поле, описывающий версию оставшиеся xdata. На момент написания этой статьи, определяется только версия 0 и таким образом не допускаются значения 1 – 3.

   В. **X** представляет собой 1-битовое поле, указывающее наличие (1) или отсутствие (0) данных исключения.

   Г. **E** используется одно битовое поле указывает, что сведения, описывающие единый эпилога, упакована в заголовок (1) не потребует дополнительных слов более поздней версии (0).

   Д. **Число эпилога** представляет собой 5-битовое поле, имеющее два значения в зависимости от состояния **E** бит:

      1. Если **E** имеет значение 0: счетчик общее число областей исключений, описанных в разделе 2. Если присутствует более 31 области существует в функции, а затем **слов кодов** поле должно быть присвоено значение 0 указывает на необходимость в слове расширения.

      2. Если **E** имеет значение 1, то это поле указывает индекс первого кода очистки, описывающий один и только эпилога.

   f. **Код слова** представляет собой 5-битовое поле, которое указывает число 32-разрядных слова, необходимые для размещения всех кодов очистки в разделе 4. Если требуются более 31 слов (т. е. более чем 124 очистки байты кода), то это поле должен иметь значение 0, чтобы указать на потребность в слове расширения.

   ж. **Расширенный счетчик эпилога** и **слов расширенных кодов** 16-разрядных и 8-разрядных полей, соответственно, освободить место для кодирования необычайно большого числа эпилога или слов кодов очистки необычайно большого числа. Слово расширения, на котором эти поля присутствует, только если оба **число эпилога** и **слов кодов** поля в первом слове заголовка задается значение 0.

1. После данных об исключении Если **число эпилога** не равно нулю, список сведений об областях эпилога одной слово упакованы и хранятся в порядке увеличения начального смещения. Каждая область содержит следующие биты:

   1. **Запуск смещение эпилога** представляет собой 18-битовое поле, описывающее смещение в байтах, поделенное на 4 эпилога относительно начала функции

   2. **RES** представляет собой 4-битовое поле, которое зарезервировано для будущего расширения. Оно должно иметь значение 0.

   В. **Начальный индекс эпилога** является 10-битный (2 разряда больше, чем **слов расширенных кодов**) поле, указывающее индекс байта первого очистки кода, описывающего этот эпилог.

1. После списка областей эпилога идет массив байтов, содержащий коды очистки, подробно описаны в следующем разделе. Этот массив дополняется в конец ближайшей границы полного слова. Байты хранятся с прямым порядком, чтобы их можно было напрямую получать в соответствующем режиме.

1. Наконец, после байтов кодов очистки (и, если **X** равным 1 бит в заголовке) содержит сведения об обработчике исключений. Он состоит из одного **RVA обработчик исключений** адрес обработчика исключений, сопровождаемую переменной длины, объем данных, необходимый для обработчика исключений.

Запись .xdata выше спроектирована таким образом, можно получить первые 8 байт и из, вычислить полный размер записи (минус длина данных переменного размера исключения ниже). В следующем фрагменте кода вычисляет размер записи:

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 27) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x0f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    Size += 4 * EpilogScopes;
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;        // exception handler RVA
    }
    return Size;
}
```

Следует отметить, несмотря на то, что пролог и каждый эпилог имеет собственный индекс в кодах очистки, таблица используется ими совместно, что это вполне возможно, (а не полностью редко), они могут совместно использовать те же коды (см. Пример 2 в приложении A ниже). Создателям компиляторов следует оптимизировать для этого случая, в частности потому, что наибольший индекс, который можно задать, равно 255, таким образом уменьшая число кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет пул последовательностей, описывающий, как устранить влияние пролога, в том порядке, в котором должны быть отменены операции. Коды очистки может рассматриваться как набор мининаборы инструкций, закодированная в виде строки байтов. По завершении выполнения адрес возврата в вызывающую функцию находится в регистре lr, и всех неизменяемых регистров восстанавливаются значения во время вызова функции.

Если исключения были гарантированно только возникают в теле функции (и никогда не пролога или эпилога любого), а затем было бы необходимо только одну последовательность. Однако модель очистки Windows требует, что эта возможность выполнения очистки из частично выполненного пролога или эпилога. Чтобы выполнить это требование, коды очистки были тщательно спроектированы таким образом, однозначно сопоставляемые 1:1 с каждым соответствующим кодом операции в пролога и эпилога. Эта особенность имеет несколько разных применений.

1. Считая число кодов очистки, можно вычислить длину пролога и эпилога.

1. Считая число инструкций после начала области эпилога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы завершить частично выполненную очистку функционировании эпилога.

1. Считая число инструкций до окончания пролога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы отменить только те части пролога, выполнение которых завершилось.

Коды очистки, кодируются в соответствии с в таблице ниже. Все коды очистки — для байтовых одним/double, за исключением того, который выделяет огромные стек. Полностью есть 21 код очистки. Очистки кода сопоставления ровно один команды в пролога и эпилога для очистку частично выполненных Прологи и эпилоги.

|Код очистки|Биты и интерпретации|
|-|-|
|`alloc_s`|000xxxxx: выделить небольшой стек с размером \< 512 (2 ^ 5 * 16).|
|`save_r19r20_x`|    001zzzzz: Сохранить \<r19 r20 > парой в [sp-#Z * 8]!, смещение предварительно индексированных > =-248 |
|`save_fplr`|        01zzzzzz: Сохранить \<r29, lr > связываться в [sp + #Z * 8], смещение \<= 504. |
|`save_fplr_x`|        10zzzzzz: Сохранить \<r29, lr > связываться в [sp-(#Z + 1) * 8]!, смещение предварительно индексированных > = -512 |
|`alloc_m`|        11000xxx "xxxxxxxx: выделить огромная стопка с размером \< 16 КБ (2 ^ 11 * 16). |
|`save_regp`|        110010xx "xxzzzzzz: сохранить r(19+#X) парой в [sp + #Z * 8], смещение \<= 504 |
|`save_regp_x`|        110011xx "xxzzzzzz: сохранить r(19+#X) пары в [sp-(#Z + 1) * 8]!, смещение предварительно индексированных > = -512 |
|`save_reg`|        110100xx "xxzzzzzz: сохраните reg r(19+#X) в [sp + #Z * 8], смещение \<= 504 |
|`save_reg_x`|        1101010 x "xxxzzzzz: сохраните reg r(19+#X) в [sp-(#Z + 1) * 8]!, смещение предварительно индексированных > = -256 |
|`save_lrpair`|         1101011 x "xxzzzzzz: сохранить пару \<r19 + 2 *#X, lr > в [sp + #Z*8], смещение \<= 504 |
|`save_fregp`|        1101100 x "xxzzzzzz: сохранить d(8+#X) пары в [sp + #Z * 8], смещение \<= 504 |
|`save_fregp_x`|        1101101 x "xxzzzzzz: сохранить d(8+#X) пары в [sp-(#Z + 1) * 8]!, смещение предварительно индексированных > = -512 |
|`save_freg`|        1101110 x "xxzzzzzz: сохраните reg d(8+#X) в [sp + #Z * 8], смещение \<= 504 |
|`save_freg_x`|        11011110' xxxzzzzz: сохраните reg d(8+#X) в [sp-(#Z + 1) * 8]!, смещение предварительно индексированных > = -256 |
|`alloc_l`|         xxxxxxxx «xxxxxxxx» xxxxxxxx 11100000': выделить огромная стопка с размером \< 256 МБ (2 ^ 24 * 16) |
|`set_fp`|        11100001: Настройка r29: с: mov r29, sp |
|`add_fp`|        11100010' xxxxxxxx: Настройка r29 с: Добавление r29, sp, #x * 8 |
|`nop`|            11100011: нет очистки операции является обязательным. |
|`end`|            11100100: конец кода очистки. Подразумевает ret в эпилога. |
|`end_c`|        11100101: конец кода очистки в текущей цепочке области. |
|`save_next`|        11100110: сохранить Далее долговременного Int или FP зарегистрировать пары. |
|`arithmetic(add)`|    11100111' 000zxxxx: добавить файл cookie reg(z) lr (0 = x28, 1 = sp); Добавление lr, lr, reg(z) |
|`arithmetic(sub)`|    11100111' 001zxxxx: sub reg(z) файл cookie из lr (0 = x28, 1 = sp); Sub lr, lr, reg(z) |
|`arithmetic(eor)`|    11100111' 010zxxxx: eor lr с reg(z) файл cookie (0 = x28, 1 = sp); EOR lr, lr, reg(z) |
|`arithmetic(rol)`|    11100111' 0110xxxx: имитации rol из lr с reg-файл cookie (x28); xip0 = neg x28; RoR lr, xip0 |
|`arithmetic(ror)`|    11100111' 100zxxxx: ror lr с reg(z) файл cookie (0 = x28, 1 = sp); lr RoR, lr, reg(z) |
| |            11100111: xxxz---:---зарезервированные |
| |              11101xxx: Зарезервировано для пользовательских стека ниже случаи создается только для подпрограммы asm |
| |              11101001: Пользовательский стек для MSFT_OP_TRAP_FRAME |
| |              11101010: Пользовательский стек для MSFT_OP_MACHINE_FRAME |
| |              11101011: Пользовательский стек для MSFT_OP_CONTEXT |
| |              1111xxxx: зарезервированные |

В инструкциях с большими значениями, охватывающими несколько байт старшие биты сохраняются первыми. Выше коды очистки спроектированы таким образом, что, просто посмотрев на первый байт кода, его невозможно знать общий размер в байтах кода очистки. Учитывая, что каждый код очистки точно сопоставить с инструкцией в пролога и эпилога, чтобы вычислить размер пролога или эпилога, все, что необходимо сделать — предоставление поэтапного с самого начала последовательности до конца, с помощью таблицей подстановки или аналогичное устройство, чтобы определить, как долго cor — отвечает opcode.

Обратите внимание, что после индексированных смещения addressing не допускается в прологе. Все диапазоны смещения (#Z) соответствует кодировке STP/STR адресации, за исключением `save_r19r20_x` в какие 248 достаточно для всех сохраняют области (10 регистры Int + 8 регистры FP + 8 входной регистры).

`save_next` необходимо следовать сохранения для Int или FP volatile регистрации пары: `save_regp`, `save_regp_x`, `save_fregp`, `save_fregp_x`, `save_r19r20_x`, или другой `save_next`. Она сохраняет Далее паре регистров в следующую ячейку 16-байтовый в порядке «масштабирование». `save-next` Следуя `save_next` , обозначающий, что последняя пара регистр Int относится к первой пары регистр FP.

Так как размер обычных вернуться и переходов инструкции одинаковы, нет необходимости из разделенных `end` код для вызова с префиксом tail сценариев очистки.

`end_c` позволяет обработать фрагменты непоследовательных функции в целях оптимизации. Объект `end_c` которого указывает на конец кодов очистки в текущей области может стоять еще один ряд кода очистки, завершился с реальными `end`. Коды очистки между `end_c` и `end` представляют операции пролога в родительской области («фантомную» прологу).  Дополнительные сведения и примеры, описанные в разделе ниже.

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для очистки функций, Прологи и эпилоги выполните каноническая форма описано ниже, упакованные данные могут быть использованы, полностью устраняя необходимость в записи .xdata и значительно снижает стоимость предоставления очистки данных. Канонические Прологи и эпилоги предназначены для удовлетворения общих требований простой функции, которая не требует обработчика исключений и выполняет его операции настройки и в стандартном порядке.

Формат записи .pdata с упакованным очистки данные будут выглядеть следующим образом:

![запись .pdata с упакованные данные очистки](media/arm64-exception-handling-packed-unwind-data.png "запись .pdata с упакованные данные очистки")

Ниже приведены поля.

- **Функция запуска RVA** является 32-разрядный относительный виртуальный адрес начала функции.
- **Флаг** представляет собой 2-битовое поле, как описано выше, статусу:
  - 00 = упакованные данные очистки не используются; оставшиеся биты пункты запись .xdata ниже
  - 01 = упакованные данные, используемые как описано ниже, с одной пролога и эпилога в начале и конце области очистки
  - 10 = упакованные данные, как описано ниже, для кода без пролога и эпилога; очистки Это удобно для описания сегменты отдельная функция.
  - 11 = зарезервировано;
- **Функция длина** представляет собой 11-битовое поле, которое предоставляет длину всей функции в байтах, поделенное на 4. Если функция является размером более 8 КБ, вместо этого необходимо использовать полную запись .xdata.
- **Размера кадра** представляет собой 9-битовое поле, указывающее количество байт в стеке, выделенной для этой функции, деленное на 16. Функции, выделяющие более байт (8 КБ-16) стека необходимо использовать полную запись .xdata. Сюда входят локальной переменной, исходящие область параметров, сохраняемые вызываемого объектов Int и FP область и область домашней параметров, за исключением динамического выделения области.
- **CR** представляет собой 2-битовый флаг, указывающее, включаются ли функция Дополнительные инструкции по настройке цепочки кадров и возврата ссылку:
  - 00 = применение функции \<r29, lr > пары не сохраняется в стеке.
  - 01 = применение функции \<lr > сохраняется в стеке
  - 10 = зарезервировано;
  - 11 = цепочке функция инструкцию пары хранилища и нагрузки используется в пролога и эпилога \<r29, lr >
- **H** — 1-битовый флаг, указывающее, является ли функция начальное расположение целочисленный параметр регистрирует (r0 — r7) путем их сохранения в самом начале функции. (0 = не помещает в начальное, 1 = помещает в начальное расположение).
- **RegI** представляет собой 4-битовое поле, представляющее число неизменяемых INT регистров (r19 r28) сохраняется в расположении каноническую стека.
- **RegF** представляет собой 3-битовое поле, представляющее число неизменяемых FP регистров (d8 d15) сохраняется в расположении каноническую стека. (0 = не FP регистр сохраняется, m > 0: m + 1 FP регистры сохраняются). Для функции сохранения только один регистр FP, упакованные очистки данных не может использоваться.

Канонические Прологи, которые делятся на категории 1, 2 (без исходящих область параметров), 3 и 4 в разделе выше может быть представлена формата упакованных данных очистки.  Эпилога, канонические функции выполните очень аналогичную форму, за исключением **H** не оказывает влияния, `set_fp` инструкции указан, и порядок шагов, а также инструкции на каждом шаге переставляются в эпилога. Алгоритм упакованный xdata включает следующие шаги, описанные в следующей таблице.

Шаг 0. Выполните предварительное вычисление размера каждой области.

Шаг 1. Сохраните Int вызываемой сохраненные регистры.

Шаг 2. Этот шаг является вспомогательным инструментом для типа 4, в первых разделах. в конце области Int сохраняется LR.

Шаг 3. Сохраните FP вызываемой сохраненные регистры.

Шаг 4. Сохраните входные аргументы в области домашней параметров.

Шаг 5. Выделить оставшиеся стек, включая локальной сети \<r29, lr > пары, а исходящие область параметров. 5а соответствует канонического типа 1. 5b и 5c — для канонического типа 2. 5d и 5e предназначены для оба типа 3 и введите 4.

Шаг №|Значения флагов|Кол-во инструкции|Код операции|Код очистки
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 < **regI** < = 10|RegI / 2 + **RegI** % 2|`stp r19,r20,[sp,#savsz]!`<br/>`stp r21,r22,[sp,16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**== 01 *|1|`str lr,[sp, #intsz-8]`\*|`save_reg`
3|0 < **RegF** < = 7|(RegF + 1) / 2 +<br/>(RegF + 1) % 2).|`stp d8,d9,[sp, #intsz]`\*\*<br/>`stp d10,d11,[sp, #intsz+16]`<br/>`...`<br/>`str d(8+RegF),[sp, #intsz+#fpsz-8]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** == 1|4|`stp r0,r1,[sp, #intsz+#fpsz]`<br/>`stp r2,r3,[sp, #intsz+#fpsz+16]`<br/>`stp r4,r5,[sp, #intsz+#fpsz+32]`<br/>`stp r6,r7,[sp, #intsz+#fpsz+48]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5а|**CR** == 11 & & #locsz<br/> <= 512|2|`stp r29,lr,[sp,-#locsz]!`<br/>`mov r29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5б|**CR** == 11 &AMP; &AMP;<br/>512 < #locsz < = 4088|3|`sub sp,sp, #locsz`<br/>`stp r29,lr,[sp,0]`<br/>`add r29, sp, 0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5c|**CR** == 11 & & #locsz > 4088|4|`sub sp,sp,4088`<br/>`sub sp,sp, (#locsz-4088)`<br/>`stp r29,lr,[sp,0]`<br/>`add r29, sp, 0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5d|(**CR** == 00 \| \| **CR**== 01) &AMP; &AMP;<br/>#locsz < = 4088|1|`sub sp,sp, #locsz`|`alloc_s`/`alloc_m`
5e|(**CR** == 00 \| \| **CR**== 01) &AMP; &AMP;<br/>#locsz > 4088|2|`sub sp,sp,4088`<br/>`sub sp,sp, (#locsz-4088)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* Если **CR** == 01 и **RegI** является нечетным числом, шаг 2 и объединяется в один save_regp последнего save_rep на шаге 1.

\*\* Если **RegI** == **CR** == 0, и **RegF** ! = 0, первый stp с плавающей запятой не предекрементный.

\*\*\* Нет соответствующей инструкции для `mov r29, sp` присутствует в эпилога. Если функция требует восстановления sp из r29, то мы не могут использовать упакованные данные очистки.

### <a name="unwinding-partial-prologs-and-epilogs"></a>Очистка частичного Прологи и эпилоги

Наиболее распространенные очистки ситуация одно место возникновения исключения или вызов в тело функции, не пролога и эпилога все. В этом случае очистки несложно: просто средство очистки начинается выполнение коды в массиве очистки, начиная с индекса 0 и продолжая до обнаружения конечного кода операции.

Более сложно правильно очистки в случае, где происходит возникновении исключения или прерывания во время выполнения пролога или эпилога. В таких ситуациях кадр стека создан лишь частично, и для этого достаточно для определения именно то, что было сделано, чтобы правильно отменить это.

В качестве примера рассмотрим последовательностью пролога и эпилога:

```asm
0000:    stp    r29, lr, [sp, -256]!        // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,224]              // save_fregp 0, 224
0008:    stp    r19,r20,[sp,240]            // save_regp 0, 240
000c:    mov    r29,sp                      // set_fp
         ...
0100:    mov    sp,r29                      // set_fp
0104:    ldp    r19,r20,[sp,240]            // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    r29, lr, [sp, -256]!        // save_fplr_x  256 (post-indexed load)
0110:    ret     lr                         // end
```

Рядом с каждым кодом операции находится подходящий код очистки описания этой операции. Первый следует заметить, что набор кодов очистки для пролога является точным зеркальным отражением коды очистки для эпилога (без учета последней инструкции эпилога). Это распространенная ситуация, и по этой причине Очистка коды для пролога всегда предполагается хранить в обратном порядке от порядка выполнения пролога.

Таким образом для пролога и эпилога, решена общий набор кодов очистки:

`set_fp`, `save_regp 0,240`, `save_fregp,0,224`, `save_fplr_x_256`, `end`

Начиная с вариантом эпилога (более простым, как в обычном порядке), нулевым смещением в эпилога (которая начинается смещение 0x100 в функции), мы хотели выполнить полную последовательность освобождения, как очистка не еще не выполнено. Если мы оказались одну инструкцию (по смещению 2 в эпилоге), мы может успешно выполнить очистку, пропустив первый код очистки. Обобщение этой ситуации, при условии, что взаимно однозначное сопоставление между кодами операций и кодами очистки, мы можно указать, что если мы Очистка осуществляется из n инструкция в эпилоге, мы должны пропустить первый коды очистки n и начать выполнение оттуда.

Оказывается, что аналогичная логика работает для пролога, за исключением в обратном порядке. Если мы Очистка осуществляется с нулевого смещения пролога, нам бы выполнять никаких действий. Если мы развернута из смещения 2, который является одной инструкции в, а затем будут отображаться для запуска выполнения очистки последовательности предпоследнего кода очистки с конца (Помните, что коды хранятся в обратном порядке). И здесь слишком мы можно подготовить к работе, если мы Очистка осуществляется из n инструкция в прологе, мы должны начать выполнять коды очистки n в конце списка кодов.

Теперь не всегда так, точно соответствовать кодов пролога и эпилога. По этой причине массиве очистки может потребоваться наличие нескольких последовательностей кодов. Чтобы определить смещение место начала обработки кодов, используйте следующую логику:

1. Если очистка выполняется из тела функции, просто начинайте выполнять коды очистки с индекса 0 и продолжается до превышения код операций «end».

1. Если очистка выполняется из эпилога, используйте начальный индекс эпилога конкретных предоставлен области эпилога отправной точки. Вычислить, сколько байт PC в вопросе — от начала эпилога. Затем перейдите вперед кодов очистки, пропуск кодов очистки, пока не учитываются все уже выполненным инструкциям. Затем выполните, начиная с этой точки.

1. Если очистка осуществляется из пролога, используйте индекс 0 в качестве отправной точки. Вычислить длину кода пролога из последовательности и затем вычислить, сколько байт PC в вопросе — от конца пролога. Затем перейдите вперед кодов очистки, пропуск кодов очистки, пока не учитываются все инструкции еще не выполнен. Затем выполните, начиная с этой точки.

В результате этих правил, коды очистки для пролога всегда должны указываться первыми в массиве, и они также эти коды используются для очистки в общем случае, когда очистка осуществляется из тела. Какие-либо код эпилога последовательности должны следовать сразу после.

### <a name="function-fragments"></a>Фрагменты функции

Для целей оптимизации кода и по другим причинам рекомендуется разделить функцию на отдельные фрагменты (также называемые регионами). После этого, каждый результирующий фрагмент функции требует собственную запись .pdata (и возможно xdata) записи.

Для отдельных дополнительный фрагмент, который имеет свой собственный пролога предполагается, что отсутствие подстройки стека выполняется путем его пролога. Все стека свободному пространству вторичным регионов для предварительного выделения его родительской области (или именем узла области). В этом случае со стеком указатель строго в исходном прологе функции.

Типичный случай фрагментов функции — «разделение кода» с помощью этого компилятора может переместить область кода из его функции узла. Существуют три нетипичных случаях, на которые могут быть возвращены с разделением кода.

#### <a name="example"></a>Пример

- (область 1: начать)

    ```asm
        stp     r29, lr, [sp, -256]!    // save_fplr_x  256 (pre-indexed store)
        stp     r19,r20,[sp,240]        // save_regp 0, 240
        mov     r29,sp                  // set_fp
        ...
    ```

- (область 1: конец)
- (области 3: начать)

    ```asm
        ...
    ```

- (области 3: конец)
- (2 региона: начать)

    ```asm
    ...
        mov     sp,r29                  // set_fp
        ldp     r19,r20,[sp,240]        // save_regp 0, 240
        ldp     r29, lr, [sp, -256]!    // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (2 региона: конец)

1. Только пролог (регион 1: все эпилога находятся в отдельных регионах):

   Только пролог необходимо описать. Это не может быть представлен формат compact .pdata. В случае полного .xdata, он может быть представлен, задав число эпилога = 0. См. в разделе региона 1 в приведенном выше примере.

   Коды очистки: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Только эпилога (2 региона: пролог находится в области узла)

   Предполагается, что элементом управления время перехода в этом регионе, все коды пролога выполнялись. Частичное освобождение может произойти в эпилога так же, как обычная функция. Этот тип области не может быть представлен compact .pdata. В полный xdata записи, его можно закодировать с помощью «фантомную» пролога, заключенных в скобки `end_c` и `end` очистки кода пары.  Начальный символ `end_c` указывает размер пролога равен нулю. Эпилога начальный индекс указывает единый эпилога `set_fp`.

   Код для региона 2 очистки: `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Прологи ни эпилога (области 3: Прологи и эпилоги все находятся в других фрагментах):

   Формат Compact .pdata могут устанавливаться через Установка для флага = 10. С полную запись .xdata, эпилога Count = 1. Развернуть код зависит от того, что и для региона 2 выше, но также указывает начальный индекс эпилога на `end_c`. Частичное освобождение никогда не произойдет в этой области кода.

Другой более сложным случаем фрагментов функции является «сжать упаковки» с помощью этого компилятора, можно отложить сохранение некоторых вызываемой сохранения регистров до выхода из пролога записи функции.

- (область 1: начать)

    ```asm
        stp     r29, lr, [sp, -256]!    // save_fplr_x  256 (pre-indexed store)
        stp     r19,r20,[sp,240]        // save_regp 0, 240
        mov     r29,sp                  // set_fp
        ...
    ```

- (2 региона: начать)

    ```asm
        stp     r21,r22,[sp,224]        // save_regp 2, 224
        ...
        ldp     r21,r22,[sp,224]        // save_regp 2, 224
    ```

- (2 региона: конец)

    ```asm
        ...
        mov     sp,r29                  // set_fp
        ldp     r19,r20,[sp,240]        // save_regp 0, 240
        ldp     r29, lr, [sp, -256]!    // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (область 1: конец)

В прологе региона 1, предварительно выделяется пространство стека. Обратите внимание, что этот регион 2 будет иметь один и тот же код очистки, даже он перемещается за пределы ее функции узла.

Регион 1: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end` с Начальный индекс эпилога, указывает на `set_fp` обычным образом.

Регион 2: `save_regp 2, 224`, `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`. Указывает начальный индекс эпилога сначала код очистки `save_regp 2, 224`.

### <a name="large-functions"></a>Большие функции

Фрагменты можно использовать для описания функций, размер которых превышает 1 млн предела, обусловленного битовые поля в заголовке .xdata. Чтобы описать очень большую функцию следующим образом, он просто необходимо разбить на фрагменты размером менее 1 МБ. Каждого фрагмента требуется Подстройка, чтобы он эпилога не разбивается на несколько частей.

Только первый фрагмент функции содержит пролог; все остальные фрагменты помечаются как имеющие нет пролога. В зависимости от количества эпилога присутствует каждый фрагмент может содержать ноль или более эпилога. Имейте в виду, что область каждого эпилога в фрагменте указывает начальное смещение относительно начала фрагмента, а не начала функции.

Если фрагмент без пролога и эпилога, нет, он по-прежнему требует собственную запись .pdata (и возможно xdata) записи, чтобы описать очистку из тела функции.

## <a name="examples"></a>Примеры

### <a name="example-1-frame-chained-compact-form"></a>Пример 1: Подключенные кадра, компакт формы

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>Пример 2: Подключенные кадра, в полной форме с зеркальной пролога и эпилога

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

Обратите внимание на то, что индекс EpilogStart [0] указывает на той же последовательности кода очистки пролога.

### <a name="example-3-variadic-unchained-function"></a>Пример 3. Применение с переменным числом аргументов, функция

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

Примечание. EpilogStart индекс [4] указывает на середине кода очистки пролога (частично массиве очистки повторного использования).

## <a name="see-also"></a>См. также

[Обзор соглашений ARM64 ABI](arm64-windows-abi-conventions.md)<br/>
[Обработка исключений ARM](arm-exception-handling.md)
