---
title: Обработка исключений в ARM64
description: Описание соглашения об обработке исключений и данные, используемые Windows на устройствах ARM64.
ms.date: 11/19/2018
ms.openlocfilehash: b1137e4e46e1127ea5452e93e1d8d9452ba0ea4d
ms.sourcegitcommit: dc77cf3b5b644d8e2adf595540b98194ab95c6e1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/05/2021
ms.locfileid: "106377272"
---
# <a name="arm64-exception-handling"></a>Обработка исключений в ARM64

Windows на устройствах ARM64 использует один механизм структурированной обработки исключений для асинхронных аппаратных и синхронных программных исключений. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. В этом документе описывается обработка исключений в Windows на устройствах ARM64, а также вспомогательные функции языка, которые использует код, созданный ассемблером Microsoft ARM и компилятором MSVC.

## <a name="goals-and-motivation"></a>Цели и причины для использования

Соглашения о данных очистки исключений и эти сведения предназначены для реализации следующих задач.

1. Предоставление описания, достаточного для выполнения очистки без проверки кода во всех случаях.

   - Для анализа кода требуется, чтобы код был страничным. Это позволяет избежать очистки в некоторых обстоятельствах, где это полезно (трассировка, выборка, отладка).

   - Анализ кода является сложным процессом, поэтому компилятор должен генерировать только те инструкции, которые может декодировать средство очистки.

   - Если очистка не может быть полностью описана с помощью кодов очистки, в некоторых случаях необходимо вернуться к декодированию инструкций. Это повышает общую сложность, и в идеале этой ситуации следует избегать.

1. Поддержка очистки в середине пролога и середине эпилога.

   - Очистка в Windows используется не только для обработки исключений. Крайне важно обеспечить правильную очистку кода, даже если он находится в середине пролога или эпилога.

1. Использование минимального объема пространства.

   - Во избежание значительного увеличения размера двоичного файла коды очистки не должны агрегироваться.

   - Так как коды очистки, скорее всего, будут заблокированы в памяти, небольшое пространство обеспечивает минимальные издержки для каждого загруженного двоичного файла.

## <a name="assumptions"></a>Допущения

Эти предположения вносятся в описание обработки исключений:

1. Прологи и эпилоги стремятся зеркально отображать друг друга. Используя эту общую особенность, можно значительно сократить объем метаданных, необходимых для описания очистки. В теле функции не имеет никакого значения, выполнены ли операции пролога или операции эпилога выполняются с опережением. Оба случая должны давать одинаковые результаты.

1. Как правило, функции в целом имеют относительно небольшой размер. На этом основано несколько оптимизаций для более эффективной упаковки данных.

1. В эпилогах нет условного кода.

1. Выделенный регистр указателя кадра: Если указатель стека сохранен в другом регистре (x29) в прологе, этот регистр не используется на протяжении работы функции. Это означает, что исходный указатель стека может быть восстановлен в любое время.

1. Если только указатель стека не сохранен в другом регистре, все операции с ним должны производиться исключительно в пределах пролога и эпилога.

1. Схема кадра стека организована так, как описано в следующем разделе.

## <a name="arm64-stack-frame-layout"></a>Схема кадра стека ARM64

![схема кадра стека](media/arm64-exception-handling-stack-frame.png "схема кадра стека")

Для функций, связанных с кадрами, пара FP и LR может быть сохранена в любой позиции в области локальных переменных в зависимости от соображений оптимизации. Цель — максимально увеличить количество локальных переменных, к которым может получить доступ одна инструкция на основе указателя фрейма (x29) или указателя стека (sp). Однако для функций `alloca` она должна быть сцеплена, и указатель x29 должен указывать на нижнюю часть стека. Чтобы обеспечить лучшее покрытие с регистрацией в режиме адресации, области сохранения в неизменяемых регистрах располагаются в верхней части локального стека. Ниже приведены примеры, иллюстрирующие несколько наиболее эффективных последовательностей пролога. Чтобы обеспечить простоту и улучшить локальность кэша, сохраняемые вызываемой функцией регистры во всех канонических прологах хранятся в возрастающем порядке. `#framesz` ниже соответствует размеру всего стека (за исключением области выделения). `#localsz` и `#outsz` обозначают размер локальной области (включая область сохранения для пары \<x29, lr>) и размер исходящего параметра соответственно.

1. Со сцеплением, #localsz \<= 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        stp    x29,lr,[sp,#-localsz]!   // save <x29,lr> at bottom of local area
        mov    x29,sp                   // x29 points to bottom of local
        sub    sp,sp,#outsz             // (optional for #outsz != 0)
    ```

1. Со сцеплением, #localsz > 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        sub    sp,sp,#(localsz+outsz)   // allocate remaining frame
        stp    x29,lr,[sp,#outsz]       // save <x29,lr> at bottom of local area
        add    x29,sp,#outsz            // setup x29 points to bottom of local area
    ```

1. Конечные функции без сцепления (lr не сохранен)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]
        str    x23,[sp,#32]
        stp    d8,d9,[sp,#40]           // save FP regs (optional)
        stp    d10,d11,[sp,#56]
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   Доступ ко всем локальным переменным осуществляется на основе указателя стека. \<x29,lr> указывает на предыдущий кадр. Для кадра размером \<= 512 можно оптимизировать "sub sp, ...", если сохраненная область регистров перемещена в нижнюю часть стека. Недостаток этого подхода заключается в том, что он не согласуется с другими приведенными выше схемами, а сохраненные регистры являются частью диапазона для режима pair-regs и режима адресации предындексированного и постындексированного смещения.

1. Неконечные функции без сцепления (lr сохранен в сохраненной области Int)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        stp    x23,lr,[sp,#32]          // save last Int reg and lr
        stp    d8,d9,[sp,#48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#64]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   Или с четным числом сохраненных регистров типа Int,

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        str    lr,[sp,#32]              // save lr
        stp    d8,d9,[sp,#40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#56]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   Сохранен только x19:

    ```asm
        sub    sp,sp,#16                // reg save area allocation*
        stp    x19,lr,[sp]              // save x19, lr
        sub    sp,sp,#(framesz-16)      // allocate the remaining local area
    ```

   \* Выделение области хранения регистра не было сведено в stp, так как предындексированный reg-lr stp не может быть представлен с помощью кодов очистки.

   Доступ ко всем локальным переменным осуществляется на основе указателя стека. \<x29> указывает на предыдущий кадр.

1. Со сцеплением, #framesz \<= 512, #outsz = 0

    ```asm
        stp    x29,lr,[sp,#-framesz]!       // pre-indexed, save <x29,lr>
        mov    x29,sp                       // x29 points to bottom of stack
        stp    x19,x20,[sp,#(framesz-32)]   // save INT pair
        stp    d8,d9,[sp,#(framesz-16)]     // save FP pair
    ```

   По сравнению с первым примером пролога выше, преимущество здесь заключается в том, что все инструкции сохранения регистров готовы к выполнению только после одной инструкции выделения стека. Это означает, что нет никакой антизависимости от sp, которая запрещает параллелизм на уровне инструкций.

1. Со сцеплением, размер кадра > 512 (необязательно для функций без alloca)

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        sub    sp,sp,#(framesz-80)          // allocate the remaining local area
    ```

   В целях оптимизации x29 можно поместить в любое место в локальной области, чтобы обеспечить лучшее покрытие в режиме "reg-pair" и режиме адресации предындексированного и постындексированного смещения. Доступ к локальным переменным под указателями кадров можно получить на основе SP.

1. Со сцеплением, размер кадра > 4 КБ, с alloca() или без него

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        mov    x15,#(framesz/16)
        bl     __chkstk
        sub    sp,sp,x15,lsl#4              // allocate remaining frame
                                            // end of prolog
        ...
        sub    sp,sp,#alloca                // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,x29                       // sp points to top of local area
        ldp    d10,d11,[sp,#64]
        ...
        ldp    x29,lr,[sp],#80              // post-indexed, reload <x29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>Сведения об обработке исключений в ARM64

### <a name="pdata-records"></a>Записи .PDATA

Записи .PDATA представляют собой упорядоченный массив с элементами фиксированной длины, которые описывают каждую работающую со стеком функцию в двоичном файле PE. Фраза "работа со стеком" имеет большое значение: конечным функциям, которым не нужно локальное хранилище и не нужно сохранять или восстанавливать неизменяемых регистров, не требуется запись .PDATA. Для экономии пространства эти записи должны быть опущены явным образом. Очистка из одной из этих функций может получить адрес возврата непосредственно из LR, чтобы перейти к вызывающему объекту.

Длина каждой записи .PDATA для ARM64 составляет 8 байтов. Общий формат записи имеет следующий вид: 32-разрядный относительный виртуальный адрес (RVA) в начале функции в первом слове, после которого идет второе слово с указателем на блок .XDATA переменной длины или упакованным словом, описывающим каноническую последовательность очистки функции.

![схема записи .PDATA](media/arm64-exception-handling-pdata-record.png "схема записи .PDATA")

Используются следующие поля.

- **Function Start RVA** (Относительный виртуальный адрес начала функции) представляет собой 32-битовый относительный виртуальный адрес начала функции.

- **Flag** (Флаг) представляет собой 2-битовое поле, указывающее, как правильно интерпретировать остальные 30 бит второго слова .PDATA. Если **Flag** (Флаг) имеет значение 0, то оставшиеся биты формируют **Exception Information RVA** (Относительный виртуальный адрес сведений об исключении) (при этом два младших бита неявно становятся равны 0). Если **Flag** (Флаг) имеет ненулевое значение, то оставшиеся биты формируют структуру **Packed Unwind Data** (Упакованные данные очистки).

- **Exception Information RVA** (Относительный виртуальный адрес сведений об исключении) представляет собой адрес структуры сведений об исключении переменной длины, хранимой в разделе XDATA. Эти данные должны быть выровнены по 4-байтовой границе.

- **Упакованные данные очистки** представляют собой сжатое описание операций, необходимых для выполнения очистки из функции в канонической форме. В этом случае запись .XDATA не требуется.

### <a name="xdata-records"></a>Записи .XDATA

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись .XDATA переменной длины. Адрес этой записи хранится во втором слове записи .PDATA. Формат .XDATA представляет собой упакованный набор слов переменной длины.

![схема записи .XDATA](media/arm64-exception-handling-xdata-record.png "схема записи .XDATA")

Эти данные состоят из четырех разделов.

1. Заголовок из одного или двух слов, описывающий общий размер структуры и предоставляющий ключевые функциональные данные. Второе слово присутствует только в том случае, если для обоих полей **Epilog Count** (Число эпилогов) и **Code Words** (Слова кодов) задано значение 0. Заголовок содержит следующие битовые поля:

   1\. **Function Length** (Длина функции) представляет собой 18-битовое поле. Оно указывает общую длину функции в байтах, поделенную на 4. Если размер функции больше 1 МББ, для ее описания следует создать несколько записей .PDATA и .XDATA. Дополнительные сведения см. в разделе [Большие функции](#large-functions).

   2\. **Vers** (Версия) представляет собой 2-битовое поле. Оно описывает версию оставшейся записи .XDATA. Сейчас определена только версия 0, поэтому значения 1–3 запрещены.

   В. **X** представляет собой 1-битовое поле. Оно указывает наличие (1) или отсутствие (0) данных исключения.

   Г. **E** представляет собой 1-битовое поле. Оно указывает, что информация с описанием отдельного эпилога упакована в заголовок (1) и позднее не потребует дополнительных слов (0).

   Д. **Epilog Count** (Число эпилогов) представляет собой 5-битовое поле, имеющее два значения в зависимости от состояния бита **E**:

      1. Если **E** равен 0, то он указывает общее число областей эпилога, описанных в разделе 2. Если в функции присутствует более 31 области, для поля **Code Words** (Слова кодов) следует установить значение 0, чтобы указать на потребность в слове расширения.

      2. Если **E** равен 1, это поле указывает индекс первого кода очистки, описывающего единственный эпилог.

   f. **Code Words** (Слова кодов) представляет собой 5-битовое поле, которое указывает число 32-разрядных слов, требуемое для размещения всех кодов очистки в разделе 3. Если требуется более 31 слова (то есть имеется более чем 124 байт кода очистки), для этого поля следует установить значение 0, чтобы указать на потребность в слове расширения.

   ж. **Extended Epilog Count** (Расширенное число эпилогов) и **Extended Code Words** (Расширенные слова кодов) представляют собой 16- и 8-битовые поля, соответственно. Они предоставляют дополнительное место для кодирования необычайно большого числа эпилогов или слов кода очистки. Слово расширения, содержащее это поле, присутствует только в том случае, если для полей **Epilog Count** (Число эпилогов) и **Code Words** (Слова кодов) в первом слове заголовка задано значение 0.

1. Если значение поля **Epilog Count** (Число эпилогов) не равно нулю, то список сведений об областях эпилога, которые по одной упакованы в слова, идет после заголовка и дополнительного расширенного заголовка. Они хранятся в порядке увеличения начального смещения. Каждая область содержит следующие биты:

   1\. **Epilog Start Offset** (Смещение начала эпилога) представляет собой 18-битовое поле, которое описывает смещение эпилога в байтах, поделенное на 4, относительно начала функции.

   2\. **Res** (Зарезервировано) представляет собой 4-битовое поле, зарезервированное для расширения в будущем. Оно должно иметь значение 0.

   В. **Epilog Start Index** (Индекс начала эпилога) представляет собой 10-битовое поле (на 2 бита больше, чем поле **Extended Code Words** (Расширенные слова кодов)). Оно указывает индекс байта первого кода очистки, описывающего этот эпилог.

1. После списка областей эпилога идет массив байтов с кодами очистки, которые подробно описаны в одном из следующих разделов. Этот массив дополняется в конец ближайшей границы полного слова. В этот массив записываются коды очистки. Они начинаются с ближайшего к телу функции и переходят к краям функции. Байты для каждого кода очистки хранятся в обратном порядке, поэтому они могут быть получены напрямую, начиная со старшего байта, который определяет операцию и длину остальной части кода.

1. Наконец, если поле **X** в заголовке равно 1, после байтов кодов очистки располагаются сведения об обработчике исключений. Он состоит из одного **относительного виртуального адреса обработчика исключений**, содержащего адрес самого обработчика исключений. После него сразу идет объем данных переменной длины, требуемых этому обработчику исключений.

Запись .XDATA спроектирована таким образом, что можно получить первые 8 байтов и вычислить полный размер записи без учета размера последующих данных об исключении, имеющих переменную длину. Следующий фрагмент кода вычисляет размер записи:

```cpp
ULONG ComputeXdataSize(PULONG Xdata)
{
    ULONG Size;
    ULONG EpilogScopes;
    ULONG UnwindWords;

    if ((Xdata[0] >> 22) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x1f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    if (!(Xdata[0] & (1 << 21))) {
        Size += 4 * EpilogScopes;
    }

    Size += 4 * UnwindWords;

    if (Xdata[0] & (1 << 20)) {
        Size += 4;  // Exception handler RVA
    }

    return Size;
}
```

Хотя пролог и каждый эпилог имеют собственный индекс в кодах очистки, эта таблица используется ими совместно. Довольно распространена ситуация, когда все они используют одинаковые коды очистки. (См. пример 2 в разделе [Примеры](#examples).) Разработчикам компилятора следует предусмотреть оптимизацию такого случая, в частности потому, что самый большой индекс, который можно указать, равен 255, что ограничивает общее число кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет собой пул последовательностей, описывающий, как устранить влияние пролога, и содержащий операции в порядке их отмены. Коды очистки представляют собой небольшие наборы инструкций, закодированные в виде строки байтов. После окончания выполнения адрес возврата в вызывающую функцию находится в регистре LR. А для всех неизменяемых регистров восстанавливаются значения, актуальные на момент вызова функции.

Если бы существовала уверенность в том, что исключения возникают только в теле функции и никогда не возникают в прологе или эпилоге, потребовалась бы всего одна последовательность. Однако модель очистки Windows требует, чтобы код мог выполнять очистку из частично выполненного пролога или эпилога. Чтобы выполнить это требование, коды очистки были тщательно спроектированы для обеспечения однозначного сопоставления с каждым соответствующим кодом операции в прологе и эпилоге. Эта особенность имеет несколько разных применений.

1. Сосчитав число кодов очистки, можно вычислить длину пролога и эпилога.

1. Считая число инструкций после начала области эпилога, можно пропустить эквивалентное число кодов очистки. Затем можно выполнить оставшуюся часть последовательности, чтобы завершить частично выполненную очистку, произведенную эпилогом.

1. Считая число инструкций до окончания пролога, можно пропустить эквивалентное число кодов очистки. Затем можно выполнить оставшуюся часть последовательности, чтобы отменить только те части пролога, выполнение которых завершилось.

Коды очистки кодируются в соответствии с таблицей ниже. Все коды очистки представляют собой один или два байта, за исключением того, который выделяет огромный стек. Всего доступен 21 код очистки. Каждый код очистки соответствует ровно одной инструкции в прологе или эпилоге, что делает возможной очистку частично выполненных прологов и эпилогов.

|Код очистки|Биты и интерпретация|
|-|-|
|`alloc_s`|000xxxxx: выделение небольшого стека размером \< 512 (2^5 * 16).|
|`save_r19r20_x`|    001zzzzz: сохранение пары \<x19,x20> в `[sp-#Z*8]!`, предварительно индексированное смещение >= –248 |
|`save_fplr`|        01zzzzzz: сохранение пары \<x29,lr> в `[sp+#Z*8]`, смещение \<= 504. |
|`save_fplr_x`|        10zzzzzz: сохранение пары \<x29,lr> в `[sp-(#Z+1)*8]!`, предварительно индексированное смещение >= –512 |
|`alloc_m`|        11000xxx'xxxxxxxx: выделение большого стека размером \< 16 КБ (2^11 * 16). |
|`save_regp`|        110010xx'xxzzzzzz: сохранение пары x(19+#X) в `[sp+#Z*8]`, смещение \<= 504 |
|`save_regp_x`|        110011xx'xxzzzzzz: сохранение пары x(19+#X) в `[sp-(#Z+1)*8]!`, предындексированное смещение >= -512 |
|`save_reg`|        110100xx'xxzzzzzz: сохранение регистра x(19+#X) в `[sp+#Z*8]`, смещение \<= 504 |
|`save_reg_x`|        1101010x'xxxzzzzz: сохранение регистра x(19+#X) в `[sp-(#Z+1)*8]!`, предындексированное смещение >= -256 |
|`save_lrpair`|         1101011x'xxzzzzzz: сохранение пары \<x(19+2*#X),lr> в `[sp+#Z*8]`, смещение \<= 504 |
|`save_fregp`|        1101100x'xxzzzzzz: сохранение пары d(8+#X) в `[sp+#Z*8]`, смещение \<= 504 |
|`save_fregp_x`|        1101101x'xxzzzzzz: сохранение пары d(8+#X) в `[sp-(#Z+1)*8]!`, предындексированное смещение >= -512 |
|`save_freg`|        1101110x'xxzzzzzz: сохранение регистра d(8+#X) в `[sp+#Z*8]`, смещение \<= 504 |
|`save_freg_x`|        11011110'xxxzzzzz: сохранение регистра d(8+#X) в `[sp-(#Z+1)*8]!`, предындексированное смещение >= -256 |
|`alloc_l`|         11100000'xxxxxxxx'xxxxxxxx'xxxxxxxx: выделение большого стека размером \< 256 МБ (2^24 *16) |
|`set_fp`|        11100001: настройка x29 с: `mov x29,sp` |
|`add_fp`|        11100010'xxxxxxxx: настройка x29 с: `add x29,sp,#x*8` |
|`nop`|            11100011: операция очистки не требуется. |
|`end`|            11100100: конец кода очистки. Предполагает использование ret в эпилоге. |
|`end_c`|        11100101: конец кода очистки в текущей сцепленной области. |
|`save_next`|        11100110: сохранение следующей неизменяемой или пары регистра типа Int или FP. |
| |            11100111: зарезервировано |
| |              11101xxx: зарезервировано для случаев использования настаиваемого стека ниже, создаваемых только для подпрограмм ASM |
| |              11101000: настраиваемый стек для MSFT_OP_TRAP_FRAME |
| |              11101001: настраиваемый стек для MSFT_OP_MACHINE_FRAME |
| |              11101010: настраиваемый стек для MSFT_OP_CONTEXT |
| |              11101100: настраиваемый стек для MSFT_OP_CLEAR_UNWOUND_TO_CALL |
| |              1111xxxx: зарезервировано |

В инструкциях с большими значениями, охватывающими несколько байт, старшие биты сохраняются первыми. Это позволяет определять общий размер кода очистки в байтах путем поиска только первого байта кода. Поскольку каждый код очистки однозначно сопоставлен с инструкцией в прологе или эпилоге, можно вычислить размер пролога или эпилога. Выполите проход от начала и до конца последовательности и воспользуйтесь таблицей подстановки или аналогичным методом, чтобы определить длину соответствующего кода операции.

В прологе не допускается адресация постындексированного смещения. Все диапазоны смещения (#Z) соответствуют кодированию адресации STP/STR, за исключением `save_r19r20_x`, где 248 достаточно для всех областей сохранения (10 регистров типа Int + 8 регистров типа FP регистров + 8 входных регистров).

`save_next` должен следовать за парой изменяемых регистров регистра типа Int или FP: `save_regp`, `save_regp_x`, `save_fregp`, `save_fregp_x`, `save_r19r20_x` или другим `save_next`. Он сохраняет следующую пару регистров в следующем 16-байтовом слоте в возрастающем порядке. `save_next` ссылается на первую пару регистров типа FP, если следует за `save-next`, обозначающим последнюю пару регистров типа Int.

Поскольку обычные инструкции возврата и перехода имеют одинаковый размер, использовать разделенный код очистки `end` в сценариях заключительного вызова не требуется.

`end_c` предназначен для управления несмежными фрагментами функций в целях оптимизации. За `end_c`, указывающим конец кодов очистки в текущей области, должен следовать другая последовательность кодов очистки, заканчивающаяся реальным `end`. Коды очистки между `end_c` и `end` представляют операции пролога в родительском регионе (фиктивном прологе).  Дополнительные сведения и примеры описаны в разделе ниже.

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для функций, прологи и эпилоги которых соответствуют описанной ниже канонической форме, можно использовать упакованные данные очистки. Это полностью устраняет потребность в записи .XDATA и значительно сокращает затраты на предоставление данных очистки. Канонические прологи и эпилоги предназначены для удовлетворения общих требований простой функции. Эта функция не требует обработчика событий и выполняет операции настройки и удаления в стандартном порядке.

Формат записи .PDATA с упакованными данными очистки выглядит следующим образом:

![запись .PDATA с упакованными данными очистки](media/arm64-exception-handling-packed-unwind-data.png "запись .PDATA с упакованными данными очистки")

Используются следующие поля.

- **Function Start RVA** (Относительный виртуальный адрес начала функции) представляет собой 32-битовый относительный виртуальный адрес начала функции.
- **Flag** (Флаг) — это 2-битовое поле, как описано выше, со следующими значениями:
  - 00 = упакованные данные очистки не используются; оставшиеся биты указывают на запись .XDATA.
  - 01 = упакованные данные очистки, используемые с одним прологом и эпилога в начале и в конце области.
  - 10 = упакованные данные очистки, используемые для кода без пролога и эпилога. Полезно для описания отдельных сегментов функций
  - 11 = зарезервировано.
- **Function Length** (Длина функции) представляет собой 11-битовое поле, которое предоставляет длину всей функции в байтах, поделенную на 4. Если размер функции больше 8 КБ, следует использовать полную запись .XDATA.
- **Frame Size** (Размер кадра) представляет собой 9-битовое поле, которое указывает число выделенных для этой функции бит в стеке, поделенное на 16. Функции, выделяющие более 8–16 КБ стека, должны использовать полную запись .XDATA. Она включает область локальных переменных, область исходящих параметров, область сохраняемых вызываемой функцией регистров типа Int и FP, начальную область параметров, но исключает область динамического выделения.
- **CR** представляет собой 2-битовый флаг, который указывает, содержит ли функция дополнительные инструкции по настройке цепочки кадров и возвращаемой ссылки:
  - 00 = функция без сцепления, пара \<x29,lr> не сохранена в стеке.
  - 01 = функция без сцепления, \<lr> сохранен в стеке
  - 10 = зарезервировано
  - 11 = функция со сцеплением, инструкция пары хранения или загрузки используется в прологе или эпилоге \<x29,lr>
- **H** — это 1-битовый флаг, указывающий, помещает ли функция регистры параметров типа INT в начальное расположение (x0–x7), сохраняя их в самом начале функции. (0 = не помещает в начальное расположение, 1 = помещает в начальное расположение.)
- **RegI** представляет собой 4-битовое поле, указывающее число неизменяемых регистров типа INT (x19–x28), сохраненных в каноническом расположении стека.
- **RegF** представляет собой 3-битовое поле, указывающее число неизменяемых регистров типа FP (d8–d15), сохраненных в каноническом расположении стека. (RegF=0: регистры типа FP не сохранены; RegF>0: сохранено регистров типа FP: RegF+1.) Упакованные данные очистки нельзя использовать для функций, которые сохраняют только один регистр типа FP.

Канонические прологи, которые попадают в категории 1, 2 (без области исходящих параметров), 3 и 4 в разделе выше, могут быть представлены в упакованном формате очистки.  Эпилоги для канонических функций имеют аналогичную форму, за исключением того, что **H** не оказывает никакого влияния, инструкция `set_fp` опускается, и порядок выполнения шагов и инструкции в каждом шаге в эпилоге является обратным. Алгоритм для упакованной записи .XDATA работает так, как описано в следующей таблице.

Шаг 0. Предварительное вычисление размера каждой области.

Шаг 1. Сохранение сохраняемых вызываемой функцией регистров типа Int.

Шаг 2. Этот шаг относится к типу 4 в предыдущих разделах. lr сохраняется в конце области Int.

Шаг 3. Сохранение сохраняемых вызываемой функцией регистров типа FP.

Шаг 4. Сохранение входных аргументов в начальной области параметров.

Шаг 5. Выделение оставшегося стека, включая локальную область, пару \<x29,lr> и область исходящих параметров. 5a соответствует каноническому типу 1. 5b и 5c относятся к каноническому типу 2. 5d and 5e относятся к типу 3 и типу 4.

Номер шага|Значения флагов|Число инструкций|Код операции|Код очистки
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 < **RegI** <= 10|RegI / 2 + **RegI** % 2|`stp x19,x20,[sp,#savsz]!`<br/>`stp x21,x22,[sp,#16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**==01*|1|`str lr,[sp,#(intsz-8)]`\*|`save_reg`
3|0 < **RegF** <=7|(RegF + 1) / 2 +<br/>(RegF + 1) % 2)|`stp d8,d9,[sp,#intsz]`\*\*<br/>`stp d10,d11,[sp,#(intsz+16)]`<br/>`...`<br/>`str d(8+RegF),[sp,#(intsz+fpsz-8)]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** == 1|4|`stp x0,x1,[sp,#(intsz+fpsz)]`<br/>`stp x2,x3,[sp,#(intsz+fpsz+16)]`<br/>`stp x4,x5,[sp,#(intsz+fpsz+32)]`<br/>`stp x6,x7,[sp,#(intsz+fpsz+48)]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5а|**CR** == 11 && #locsz<br/> <= 512|2|`stp x29,lr,[sp,#-locsz]!`<br/>`mov x29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5б|**CR** == 11 &&<br/>512 < #locsz <= 4080|3|`sub sp,sp,#locsz`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5c|**CR** == 11 && #locsz > 4080|4|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5d|(**CR** == 00 \|\| **CR**==01) &&<br/>#locsz <= 4080|1|`sub sp,sp,#locsz`|`alloc_s`/`alloc_m`
5e|(**CR** == 00 \|\| **CR**==01) &&<br/>#locsz > 4080|2|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* Если **CR** == 01, и **RegI** является нечетным числом, шаг 2 и последний save_rep на шаге 1 объединяются в один save_regp.

\*\* Если **RegI** == **CR** == 0 и **RegF** != 0, первый stp для операции с плавающей запятой выполняет предварительное уменьшение.

\*\*\* В эпилоге отсутствуют инструкции, соответствующие `mov x29,sp`. Если функции требуется восстановление sp из x29, упакованные данные очистки использовать нельзя.

### <a name="unwinding-partial-prologs-and-epilogs"></a>Очистка частичных прологов и эпилогов

Наиболее распространенным случаем очистки является возникновение исключения в теле функции, не затрагивающее пролог и все эпилоги. В этом случае очистка выполняется очень просто: средство очистки начинает выполнение кодов в массиве очистки, начиная с индекса 0, и продолжает до тех пор, пока не будет обнаружен конечный код операции.

Если исключение возникает во время выполнения пролога или эпилога, правильно выполнить очистку еще сложнее. В таких ситуациях кадр стека создается только частично. Проблема заключается в том, чтобы определить, что именно было сделано, чтобы правильно отменить это.

Например, возьмем следующую последовательность пролога и эпилога.

```asm
0000:    stp    x29,lr,[sp,#-256]!          // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,#224]             // save_fregp 0, 224
0008:    stp    x19,x20,[sp,#240]           // save_regp 0, 240
000c:    mov    x29,sp                      // set_fp
         ...
0100:    mov    sp,x29                      // set_fp
0104:    ldp    x19,x20,[sp,#240]           // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    x29,lr,[sp],#256            // save_fplr_x  256 (post-indexed load)
0110:    ret    lr                          // end
```

Рядом с каждым кодом операции находится подходящий код очистки, описывающий эту операцию. Как видно, последовательность кодов очистки для пролога является зеркальным отображением кодов очистки для эпилога (без учета последней инструкции эпилога). Это распространенный случай, и именно поэтому всегда предполагается, что коды очистки для пролога хранятся в обратном порядке по сравнению с порядком выполнения пролога.

Таким образом, пролог и эпилог имеют общий набор кодов очистки:

`set_fp`, `save_regp 0,240`, `save_fregp,0,224`, `save_fplr_x_256`, `end`

Ситуация с эпилогом гораздо проще, так как действия выполняются в обычном порядке. Если процесс начинается с нулевого смещения в эпилоге (со смещения 0x100 в функции), будет выполнена полная последовательность очистки, так как очистка еще не выполнялась. Если очистка выполняется из первой инструкции (со смещения 2 в эпилоге), пропускается первый код очистки. Эту ситуацию можно обобщить и предположить однозначное сопоставление между кодами операций и кодами очистки. Затем, чтобы начать очистку с инструкции *n* в эпилоге, следует пропустить первые *n* кодов очистки и начать выполнение оттуда.

Аналогичная логика работает и в обратном порядке для пролога. Если очистка осуществляется с нулевого смещения в прологе, ничего выполнять не требуется. Если начать очистку со смещения 2, то есть с погружением в одну инструкцию, последовательность очистки должна начаться с предпоследнего кода очистки. (Помните, что коды хранятся в обратном порядке.) И здесь тоже можно обобщить: если начать очистку с инструкции n в прологе, выполнение следует начинать с n кодов очистки с конца списка кодов.

Коды пролога и эпилога не всегда совпадают полностью. В этом случае в массиве очистки может потребоваться наличие нескольких последовательностей кодов. Чтобы определить смещение для начала обработки кодов, используйте следующую логику.

1. Если очистка выполняется из тела функции, начинайте выполнять коды очистки с индекса 0 и продолжайте до достижения конечного кода операции.

1. Если очистка выполняется из эпилога, используйте в качестве отправной точки специальный начальный индекс эпилога, указанный в области эпилога. Вычислите, на сколько байт PC отстоит от начала эпилога. Затем перейдите по кодам очистки, пропустив такое число кодов очистки, которое соответствует уже выполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

1. Если очистка осуществляется из пролога, начните с индекса 0 в кодах очистки. Вычислите длину кода пролога из последовательности, а затем рассчитайте, на сколько байт PC отстоит от конца пролога. Затем перейдите по кодам очистки, пропустив такое число кодов очистки, которое соответствует еще не выполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

Эти правила означают, что коды очистки для пролога должны всегда стоять в массиве первыми. И именно эти коды используются для очистки в общем случае, когда очистка осуществляется из тела. Сразу после последовательности кода для пролога должны идти специальные последовательности для эпилога.

### <a name="function-fragments"></a>Фрагменты функции

В целях оптимизации кода и по другим причинам может оказаться целесообразным разделить функцию на отдельные фрагменты (также называемые регионами). После разделения каждому результирующему фрагменту функции требуется своя собственная запись .PDATA (а возможно, и запись .XDATA).

Если у разделенного вторичного фрагмента есть собственный пролог, выполнять подстройку стека в этом прологе не следует. Все пространство стека, необходимое вторичному региону, должно быть предварительно выделено его родительским регионом (или главным регионом). Это позволяет осуществить работу с указателем стека исключительно в исходном прологе функции.

Типичным случаем использования фрагментов функции является разделение кода, когда компилятор может переместить регион кода из главной функции. Существует три нестандартных случая, которые могут возникнуть в результате разделения кода.

#### <a name="example"></a>Пример

- (регион 1: начало)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (регион 1: конец)

- (регион 3: начало)

    ```asm
        ...
    ```

- (регион 3: конец)

- (регион 2: начало)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (регион 2: конец)

1. Только пролог (регион 1: все эпилоги находятся в отдельных регионах):

   Необходимо описать только пролог. Он не может быть представлен в кратком формате .PDATA. В полном формате .XDATA его можно представить, установив значение числа эпилогов равным нулю. См. регион 1 в примере выше.

   Коды очистки: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Только эпилоги (регион 2: пролог находится в главном регионе)

   Предполагается, что при переходе в этот регион были выполнены все коды пролога. Частичная очистка может выполняться в эпилогах так же, как в обычной функции. Этот тип региона не может быть представлен посредством краткой записи .PDATA. В полной записи .XDATA его можно закодировать с помощью "фантомного" пролога, заключенного в скобки с помощью пары кода очистки `end_c` и `end`.  Начальный `end_c` указывает, что размер пролога равен нулю. Начальный индекс эпилога для одного эпилога указывает на `set_fp`.

   Код очистки для региона 2: `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Нет прологов или эпилогов (регион 3: прологи все эпилоги находятся в других фрагментах):

   Краткий формат записи .PDATA можно применить, задав флагу значение 10. В полной записи .XDATA число эпилогов равно 1. Код очистки совпадает с кодом для региона 2 выше, но индекс начала эпилога также указывает на `end_c`. В этом регионе кода никогда не будет выполняться частичная очистка.

Еще одним более сложным случаем использования фрагментов функции является перенос сжатия. Компилятор может отложить сохранение некоторых сохраняемых вызываемой функцией регистров, пока не выйдет за пределы пролога записи функции.

- (регион 1: начало)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (регион 2: начало)

    ```asm
        stp     x21,x22,[sp,#224]       // save_regp 2, 224
        ...
        ldp     x21,x22,[sp,#224]       // save_regp 2, 224
    ```

- (регион 2: конец)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (регион 1: конец)

В прологе региона 1 пространство стека выделено заранее. Как видно, в регионе 2 будет использоваться тот же код очистки, даже если он перемещается из главной функции размещения.

Регион 1: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`, где индекс начала эпилога указывает на `set_fp`, как обычно.

Регион 2: `save_regp 2, 224`, `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`. Индекс начала эпилога указывает на первый код очистки `save_regp 2, 224`.

### <a name="large-functions"></a>Большие функции

Фрагменты можно использовать для описания функций, размер которых превышает предел в 1 МБ, накладываемый битовыми полями в заголовке .XDATA. Чтобы описать очень большую функцию, подобную этой, ее необходимо разбить на фрагменты меньше 1 МБ. Для каждого фрагмента требуется подстройка, чтобы он не разбивал эпилог на множество частей.

Только первый фрагмент функции будет содержать пролог, все остальные фрагменты помечаются как не содержащие пролог. В зависимости от имеющегося числа эпилогов каждый фрагмент может содержать от нуля до нескольких эпилогов. Помните, что область каждого эпилога во фрагменте указывает начальное смещение относительно начала данного фрагмента, а не начала функции.

Если фрагмент не содержит ни пролог, ни эпилог, ему все равно требуется отдельная запись .PDATA (и, возможно, запись .XDATA), чтобы описать очистку из тела функции.

## <a name="examples"></a>Примеры

### <a name="example-1-frame-chained-compact-form"></a>Пример 1: Со сцеплением кадров, кратная форма

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>Пример 2: Со сцеплением кадров, полная форма с зеркальными прологом и эпилогом

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

Индекс начала эпилога [0] указывает на ту же последовательность кода очистки пролога.

### <a name="example-3-variadic-unchained-function"></a>Пример 3. Функция без сцепления с переменным числом аргументов

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

Индекс начала эпилога [4] указывает на середину кода очистки пролога (частичное повторное использование массива очистки).

## <a name="see-also"></a>См. также

[Общие сведения о соглашениях ABI ARM64](arm64-windows-abi-conventions.md)<br/>
[Обработка исключений ARM](arm-exception-handling.md)
