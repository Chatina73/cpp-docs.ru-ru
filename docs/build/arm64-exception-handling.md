---
title: Обработка исключений в ARM64
ms.date: 11/19/2018
ms.openlocfilehash: b4f9a5d6f86f8b88ef42525e6a9bb1b4071585ce
ms.sourcegitcommit: a9f1a1ba078c2b8c66c3d285accad8e57dc4539a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/08/2019
ms.locfileid: "72037797"
---
# <a name="arm64-exception-handling"></a>Обработка исключений в ARM64

Windows в ARM64 использует один и тот же механизм структурированной обработки исключений для асинхронных исключений, генерируемых оборудованием, и синхронных исключений, созданных программным обеспечением. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. В этом документе описывается обработка исключений в Windows в ARM64 и вспомогательные методы языка, используемые кодом, создаваемым ассемблером Microsoft ARM и компилятором КОМПИЛЯТОРОМ MSVC.

## <a name="goals-and-motivation"></a>Цели и мотивация

Правила очистки данных об исключениях и их описание предназначены для следующих действий:

1. Предоставьте достаточное описание, чтобы разрешить раскрутку без проверки кода во всех случаях.

   - Для анализа кода требуется, чтобы код был разстраничным. Это предотвращает раскрутку в некоторых обстоятельствах, когда это полезно (трассировка, выборка, отладка).

   - Анализ кода является сложным; компилятор должен быть аккуратным только для создания инструкций, которые могут быть декодированы в процессе декодирования.

   - Если раскрутка не может быть полностью описана с помощью кодов очистки, в некоторых случаях она должна возвращаться к декодированию инструкций. Это увеличит общую сложность, и в идеале это будет избегать.

1. Поддержка очистки в середине-прологе и середине-эпилога.

   - В Windows используется очистка в целях обработки исключений, поэтому очень важно выполнить точную очистку, даже если в середине последовательности кода пролога или эпилога.

1. Занимать минимальный объем пространства.

   - Для значительного увеличения двоичного размера коды очистки не должны выполнять статистическую обработку.

   - Так как коды очистки, скорее всего, будут заблокированы в памяти, небольшое место для каждого загруженного двоичного файла обеспечивает минимальный объем ресурсов.

## <a name="assumptions"></a>Допущения

Это предположения, сделанные в описании обработки исключений:

1. Журналы и эпилоги, как правило, являются зеркальными. Используя эту общую особенность, можно значительно сократить размер метаданных, необходимых для описания раскрутки. В теле функции не имеет значения, будут ли отменены операции пролога или операции эпилога выполняются в перенаправлении. Оба случая должны давать одинаковые результаты.

1. Функции обычно находятся в целом, чтобы быть относительно небольшими. Для достижения наиболее эффективной упаковки данных используется несколько способов оптимизации пространства.

1. В эпилоги нет условного кода.

1. Регистр указателя выделенного фрейма: Если пакет обновления сохранен в другом регистре (X29) в прологе, Регистр остается нетронутым по всей функции, чтобы исходный пакет обновления можно было восстановить в любое время.

1. Если пакет обновления не сохранен в другом регистре, все манипуляции указателя стека выполняются строго внутри пролога и эпилога.

1. Макет кадра стека организован так, как описано в следующем разделе.

## <a name="arm64-stack-frame-layout"></a>Макет кадра стека ARM64

![](media/arm64-exception-handling-stack-frame.png "Макет стека") кадров стека

Для связанных с кадрами функций пара FP и LR может быть сохранена в любой позиции в локальной переменной в зависимости от соображений оптимизации. Цель — максимально увеличить количество локальных переменных, к которым может получить доступ одна инструкция на основе указателя фрейма (X29) или указателя стека (SP). Однако для функций `alloca` она должна быть сцеплена, а X29 должна указывать на нижнюю часть стека. Чтобы обеспечить лучшее покрытие с регистрацией в режиме адресации, области сохранения в неизменяемых регистрах располагаются в верхней части локального стека. Ниже приведены примеры, иллюстрирующие несколько наиболее эффективных последовательностей пролога. Чтобы обеспечить простоту и улучшить локальность кэша, порядок хранения вызываемых регистров во всех канонических журналах находится в возрастающем порядке. `#framesz` ниже соответствует размеру всего стека (за исключением области выделения). `#localsz` и `#outsz` обозначают размер локальной области (включая область сохранения для пары \<x29, LR >) и размер исходящего параметра соответственно.

1. Цепочка, #localsz \< = 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        stp    x29,lr,[sp,#-localsz]!   // save <x29,lr> at bottom of local area
        mov    x29,sp                   // x29 points to bottom of local
        sub    sp,sp,#outsz             // (optional for #outsz != 0)
    ```

1. Цепочка, #localsz > 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        sub    sp,sp,#(localsz+outsz)   // allocate remaining frame
        stp    x29,lr,[sp,#outsz]       // save <x29,lr> at bottom of local area
        add    x29,sp,#outsz            // setup x29 points to bottom of local area
    ```

1. Несцепленные конечные функции (LR не сохранено)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]
        str    x23,[sp,#32]
        stp    d8,d9,[sp,#40]           // save FP regs (optional)
        stp    d10,d11,[sp,#56]
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   Доступ ко всем локальным файлам осуществляется на основе SP. \<x29, LR > указывает на предыдущий кадр. Для размера кадра \< = 512, "RESP..." можно оптимизировать, если сохраненная область регс перемещается в нижнюю часть стека. Недостаток этого заключается в том, что он не согласуется с другими макетами, и сохраненный регс принимает часть диапазона для пары-регс и предварительного и поэтапного смещения.

1. Неконечные функции без привязке (LR сохраняются в сохраненной области int)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        stp    x23,lr,[sp,#32]          // save last Int reg and lr
        stp    d8,d9,[sp,#48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#64]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   Или с четным числом сохраненных регистров int,

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        str    lr,[sp,#32]              // save lr
        stp    d8,d9,[sp,#40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#56]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   X19 сохраненные:

    ```asm
        sub    sp,sp,#16                // reg save area allocation*
        stp    x19,lr,[sp]              // save x19, lr
        sub    sp,sp,#(framesz-16)      // allocate the remaining local area
    ```

   \* выделение области хранения reg не включается в STP, так как предварительно индексированное STP-LR не может быть представлено с кодами очистки.

   Доступ ко всем локальным файлам осуществляется на основе SP. \<x29 > указывает на предыдущий кадр.

1. Цепочка, #framesz \< = 512, #outsz = 0

    ```asm
        stp    x29,lr,[sp,#-framesz]!       // pre-indexed, save <x29,lr>
        mov    x29,sp                       // x29 points to bottom of stack
        stp    x19,x20,[sp,#(framesz-32)]   // save INT pair
        stp    d8,d9,[sp,#(framesz-16)]     // save FP pair
    ```

   В сравнении с #1 прологе выше преимущество заключается в том, что все инструкции по сохранению регистра готовы к выполнению сразу после выполнения одной инструкции по выделению стека. Таким образом, не существует никакой защиты от SP, препятствующего параллелизму на уровне инструкций.

1. Цепочка, размер кадра > 512 (необязательно для функций без выделения)

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        sub    sp,sp,#(framesz-80)          // allocate the remaining local area
    ```

   Для целей оптимизации X29 можно поместить в любое место в локальной области, чтобы обеспечить лучшее покрытие в режиме "Reg-пары" и режимах смещения до/пост-индексед. Доступ к локальным переменным под указателями кадров можно получить на основе SP.

1. Цепочка, размер кадра > 4 КБ, с разблокировками или без них ()

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        mov    x15,#(framesz/16)
        bl     __chkstk
        sub    sp,sp,x15,lsl#4              // allocate remaining frame
                                            // end of prolog
        ...
        sub    sp,sp,#alloca                // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,x29                       // sp points to top of local area
        ldp    d10,d11,[sp,#64]
        ...
        ldp    x29,lr,[sp],#80              // post-indexed, reload <x29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>Сведения об обработке исключений ARM64

### <a name="pdata-records"></a>записи pData

Записи. pdata — это упорядоченный массив элементов фиксированной длины, описывающих каждую функцию управления стеком в двоичном файле PE. Обратите внимание на фразу "Управление стеком": конечные функции, для которых не требуется локальное хранилище, а для сохранения и восстановления неизменяемых регистров не требуется запись. pData. чтобы сэкономить место, их следует опустить явным образом. Очистка от одной из этих функций может просто получить обратный адрес от LR, чтобы перейти к вызывающему объекту.

Каждая запись. pdata для ARM64 имеет длину 8 байт. В общем формате каждой записи размещается 32-разрядный RVA функции start в первом слове, за которым следует второй символ, который содержит либо указатель на блок переменной длины. XData, либо упакованное слово, описывающее каноническую последовательность очистки функции.

![. pdata запись Layout](media/arm64-exception-handling-pdata-record.png ". pdata макет записи")

Поля имеют следующие значения.

- **Начальный RVA функции** — это 32-разрядный RVA начала функции.

- **Флаг** — это 2-битовое поле, которое указывает, как интерпретировать оставшиеся 30 бит второго слова. pData. Если **флаг** имеет значение 0, остальные биты формируют **RVA сведений об исключении** (с низкими двумя битами неявно 0). Если **флаг** не равен нулю, остальные биты формируют **упакованную структуру данных очистки** .

- **RVA сведений об исключении** — это адрес структуры сведений об исключении переменной длины, хранящейся в разделе. XData. Эти данные должны быть выровнены по 4-байтовой границе.

- **Упакованные данные очистки** — это сжатое описание операций, необходимых для очистки от функции при условии канонической формы. В этом случае запись .XDATA не требуется.

### <a name="xdata-records"></a>записи. XData

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись .XDATA переменной длины. Адрес этой записи хранится во втором слове записи .PDATA. Формат XData является упакованным набором слов с переменной длиной:

![. XData]. формат записи(media/arm64-exception-handling-xdata-record.png ". XData")

Эти данные разбиваются на четыре раздела:

1. Один или два слова, описывающие общий размер структуры и предоставляющие данные о ключевых функциях. Второе слово имеется только в том случае, если в полях количество и **код** **эпилога** задано значение 0. Это битовые поля в заголовке:

   1\. **Длина функции** — это 18-разрядное поле, указывающее общую длину функции в байтах, деленную на 4. Если функция больше 1 МБ, то для описания функции необходимо использовать несколько записей pData и XData. Дополнительные сведения см. в разделе [крупные функции](#large-functions) .

   2\. Вариант «инверсия **» — это** 2-битовое поле, описывающее версию оставшегося XData. На момент написания этой статьи определена только версия 0, поэтому значения 1-3 не разрешены.

   В. **X** — это 1 битовое поле, указывающее присутствие (1) или отсутствие (0) данных исключения.

   Г. **E** — это одно битовое поле, указывающее, что информация, описывающая один заключительный фрагмент, упаковывается в заголовок (1), а не требует дополнительных слов области позже (0).

   Д. **Счетчик эпилогаs** — это 5-битовое поле, которое имеет два значения в зависимости от состояния **E** bit:

      1. Если параметр **E** имеет значение 0, то он указывает общее число областей эпилога, описанных в разделе 2. Если в функции существует более 31 области, то в поле **кода** Words должно быть установлено значение 0, чтобы указать, что требуется расширение.

      2. Если параметру **E** задано значение 1, то в этом поле указывается индекс первого кода очистки, который описывает только один и только эпилога.

   f. **Слова Code** — это 5-битовое поле, которое указывает число 32-разрядных слов, которые должны содержать все коды очистки в разделе 3. Если требуется более 31 слова (т. е. более 124 байт кода очистки), то для этого поля необходимо задать значение 0, чтобы указать, что требуется расширение.

   ж. **Расширенные счетчики эпилога** и **расширенного кода** — это 16-разрядные и 8-битовые поля соответственно, которые предоставляют больше пространства для кодирования необычно большого числа эпилоги или необычного большого количества слов кода очистки. Слово расширения, содержащее эти поля, имеется только в том случае, если в первом заголовке в полях « **количество эпилога** » и « **код** » в текстовом слове «значение 0».

1. После заголовков и дополнительного расширенного заголовка, описанного выше, если **Счетчик эпилога** не равен нулю, то представляет собой список сведений об областях эпилога, упакованный один в слово и сохранен в порядке возрастания начального смещения. Каждая область содержит следующие биты:

   1\. **Начальное смещение эпилога** — это 18-разрядное поле, описывающее смещение в байтах, разделенное на 4, в результате выполнения заключительной части функции.

   2\. **RES** — это 4-битовое поле, зарезервированное для будущего расширения. Оно должно иметь значение 0.

   В. **Начальный индекс эпилога** — это 10-битное поле (2 большего числа битов, чем **Расширенное слово кода**), указывающее байтовый индекс первого кода очистки, описывающего этот эпилога.

1. После списка областей эпилога создается массив байтов, содержащих коды очистки, которые подробно описаны в следующем разделе. Этот массив дополняется в конец ближайшей границы полного слова. Коды очистки записываются в этот массив, начиная с ближайшего к тексту функции, перемещаясь к краям функции. Байты для каждого кода очистки хранятся в порядке с обратным порядком байтов, поэтому они могут быть получены напрямую, начиная с наиболее значимого байта, который определяет операцию и длину остальной части кода.

1. Наконец, после байтов кода очистки, если бит **X** в заголовке был установлен равным 1, то поступает информация об обработчике исключений. Это состоит из одного **RVA обработчика исключений** , предоставляющего адрес самого обработчика исключений, за которым следует объем данных переменной длины, необходимый обработчику исключений.

Запись. XData выше разработана таким образом, что можно получить первые 8 байтов и из него вычислит полный размер записи (за вычетом длины данных об исключениях, размер которых приведен ниже). Следующий фрагмент кода вычислит размер записи:

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 27) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x0f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    Size += 4 * EpilogScopes;
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;        // exception handler RVA
    }
    return Size;
}
```

Следует отметить, что хотя у пролога и каждого эпилога есть собственный индекс в кодах очистки, эта таблица является общей для них и полностью возможна (и не совсем редки), что все они могут совместно использовать одни и те же коды (см. Пример 2 в разделе "примеры" веч ...). Модули записи компилятора должны оптимизировать в этом случае, в частности, потому, что наибольший индекс, который можно указать, равен 255, что ограничивает общее количество кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет собой пул последовательностей, описывающих, как отменить эффекты пролога в том порядке, в котором операции должны быть отменены. Коды очистки можно рассматривать как свернутый набор инструкций, закодированный как строка байтов. После завершения выполнения обратный адрес вызывающей функции находится в регистре LR, а все непостоянные регистры восстанавливаются в значениях во время вызова функции.

Если исключения были гарантированно только когда-либо находились в теле функции (и никогда не с прологом или с каким-либо эпилога), потребуется только одна последовательность. Однако модель очистки Windows требует, чтобы мы могли изменяться из частично выполненного пролога или эпилога. Чтобы удовлетворить это требование, коды очистки были тщательно спроектированы таким образом, что они однозначно сопоставляют 1:1 каждому соответствующему коду операции в прологе и эпилога. Эта особенность имеет несколько разных применений.

1. Подсчитайте количество кодов очистки, можно вычислить длину пролога и эпилога.

1. Подчисляя количество инструкций, предшествующих началу области эпилога, можно пропустить эквивалентное число кодов очистки и выполнить оставшуюся часть последовательности для завершения частично выполненной очистки, выполняемой в процессе выполнения.

1. Подчисляя количество инструкций до конца пролога, можно пропустить эквивалентное число кодов очистки и выполнить оставшуюся часть последовательности, чтобы отменить только те части пролога, которые завершили выполнение.

Коды очистки кодируются в соответствии с таблицей ниже. Все коды очистки представляют собой один или два байта, за исключением того, который выделяет огромный стек. Полностью имеется 21 код очистки. Каждый код очистки сопоставляет ровно одну инструкцию в прологе или эпилога, чтобы можно было очищать частично выполненные журналы и эпилоги.

|Код очистки|Биты и интерпретация|
|-|-|
|`alloc_s`|000xxxxx: выделение мелкого стека с размером \< 512 (2 ^ 5 * 16).|
|`save_r19r20_x`|    001zzzzz: сохранение пары \<x19, x20 > в [SP-#Z * 8]!, предварительно индексированное смещение > =-248 |
|`save_fplr`|        01zzzzzz: Save \<x29, LR > парой [SP + #Z * 8], offset \< = 504. |
|`save_fplr_x`|        10zzzzzz: Save \<x29, LR > парой at [SP-(#Z + 1) * 8]!, предварительно индексированное смещение > =-512 |
|`alloc_m`|        11000xxx'xxxxxxxx: выделение большого стека размером \< 16 КБ (2 ^ 11 * 16). |
|`save_regp`|        110010xx'xxzzzzzz: сохранение пары x (19 + #X) в [SP + #Z * 8], offset \< = 504 |
|`save_regp_x`|        110011xx'xxzzzzzz: сохраните пару x (19 + #X) в [SP-(#Z + 1) * 8]!, предварительно индексированное смещение > =-512 |
|`save_reg`|        110100xx'xxzzzzzz: сохранить reg x (19 + #X) в [SP + #Z * 8], offset \< = 504 |
|`save_reg_x`|        1101010x'xxxzzzzz: сохранить reg x (19 + #X) в [SP-(#Z + 1) * 8]!, предварительно индексированное смещение > =-256 |
|`save_lrpair`|         1101011x'xxzzzzzz: Save пары \<x (19 + 2 *#X), lr > at [SP + #Z*8], смещение \< = 504 |
|`save_fregp`|        1101100x'xxzzzzzz: сохранить пару d (8 + #X) в [SP + #Z * 8], offset \< = 504 |
|`save_fregp_x`|        1101101x'xxzzzzzz: сохранить пару d (8 + #X) в [SP-(#Z + 1) * 8]!, предварительно индексированное смещение > =-512 |
|`save_freg`|        1101110x'xxzzzzzz: сохранение reg d (8 + #X) в [SP + #Z * 8], смещение \< = 504 |
|`save_freg_x`|        11011110 ' ксксксззззз: Save reg d (8 + #X) в [SP-(#Z + 1) * 8]!, предварительно индексированное смещение > =-256 |
|`alloc_l`|         11100000 "кскскскскскскскс'кскскскскскскскс'кскскскскскскскс: выделение большого стека с размером \< 256M (2 ^ 24 * 16) |
|`set_fp`|        11100001: Настройте X29: with: MOV X29, SP |
|`add_fp`|        11100010 "xxxxxxxx: Настройка X29 с помощью: Add X29, SP, #x * 8 |
|`nop`|            11100011: операция очистки не требуется. |
|`end`|            11100100: конец кода очистки. Включает RET в эпилога. |
|`end_c`|        11100101: конец кода очистки в текущей последовательной области. |
|`save_next`|        11100110: Сохраните следующую пару регистров int или FP, не зависящую от volatile. |
|`arithmetic(add)`|    11100111 ' 000zxxxx: добавить файл cookie reg (z) в LR (0 = x28, 1 = SP); Добавление LR, LR, reg (z) |
|`arithmetic(sub)`|    11100111 ' 001zxxxx: подфайл cookie reg (z) от LR (0 = x28, 1 = SP); Подсистема LR, LR, reg (z) |
|`arithmetic(eor)`|    11100111 "010zxxxx: EOR LR с файлом cookie reg (z) (0 = x28, 1 = SP); EOR LR, LR, reg (z) |
|`arithmetic(rol)`|    11100111 "0110xxxx: моделирует ROL LR с помощью файла cookie reg (x28); xip0 = нерасходный x28; ROR LR, xip0 |
|`arithmetic(ror)`|    11100111 "100zxxxx: ROR LR с файлом cookie reg (z) (0 = x28, 1 = SP); ROR LR, LR, reg (z) |
| |            11100111: ксксксз----:----зарезервировано |
| |              11101xxx: зарезервировано для настраиваемых вариантов стека ниже, созданных только для подпрограмм ASM |
| |              11101000: Пользовательский стек для MSFT_OP_TRAP_FRAME |
| |              11101001: Пользовательский стек для MSFT_OP_MACHINE_FRAME |
| |              11101010: Пользовательский стек для MSFT_OP_CONTEXT |
| |              11101100: Пользовательский стек для MSFT_OP_CLEAR_UNWOUND_TO_CALL |
| |              1111xxxx: зарезервировано |

В инструкциях с большими значениями, охватывающими несколько байт, сначала сохраняются наиболее значимые биты. Приведенные выше коды очистки спроектированы таким образом, что путем простого поиска первого байта кода можно понять общий размер кода очистки в байтах. Учитывая, что каждый код очистки полностью сопоставлен с инструкцией в прологе/эпилога, для расчета размера пролога или эпилога все, что нужно сделать, — это пройти от начала последовательности до конца, используя таблицу подстановки или аналогичное устройство для определения того, как долго Cor ответный код операции —.

Обратите внимание, что в прологе не допускается использование последующей индексной адресации. Все диапазоны смещения (#Z) соответствуют кодированию адресации STP/STR, за исключением `save_r19r20_x`, где 248 достаточно для всех областей сохранения (10 регистров int + 8 FP регистров + 8 входных регистров).

`save_next` должен следовать паре регистров для сохранения переменной int или FP: `save_regp`, `save_regp_x`, `save_fregp`, `save_fregp_x`, `save_r19r20_x` или другой `save_next`. Она сохраняет следующую пару регистров в следующем 16-байтовом слоте в возрастающем порядке. `save-next` после `save_next`, обозначающий последнюю пару регистра int, означает первую пару регистра FP.

Так как размер обычных инструкций возврата и перехода одинаковы, нет необходимости разделять код очистки `end` для сценариев заключительного вызова.

`end_c` рассчитан на обработку несмежных фрагментов функций в целях оптимизации. Значение `end_c`, обозначающее окончание кодов очистки в текущей области, должно сопровождаться еще одной серией кода очистки, которая заканчивается реальным `end`. Коды очистки между `end_c` и `end` представляют операции пролога в родительском регионе ("Фантом").  Дополнительные сведения и примеры описаны в разделе ниже.

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для функций, чьи журналы и эпилоги следуют канонической форме, описанной ниже, можно использовать Упакованные данные для очистки, устраняя необходимость в записи. XData полностью и значительно уменьшая затраты на предоставление данных очистки. Канонические журналы и эпилоги предназначены для удовлетворения общих требований простой функции, которая не требует обработчика исключений и выполняет операции установки и уничтожения в стандартном порядке.

Формат записи pData с упакованными данными очистки выглядит следующим образом:

![запись pData с упакованными данными раскрутки](media/arm64-exception-handling-packed-unwind-data.png ". pdata с упакованными данными очистки")

Поля имеют следующие значения.

- **Начальный RVA функции** — это 32-разрядный RVA начала функции.
- **Флаг** — это 2-битовое поле, как описано выше, со следующими значениями:
  - 00 = Упакованные данные очистки не используются; оставшиеся биты указывают на запись. XData
  - 01 = Упакованные данные очистки, используемые, как описано ниже, с одним прологом и эпилога в начале и в конце области
  - 10 = Упакованные данные для очистки, используемые, как описано ниже, для кода без пролога и эпилога; Это полезно для описания сегментов отдельных функций.
  - 11 = зарезервировано;
- **Длина функции** — это 11-разрядное поле, предоставляющее длину всей функции в байтах, деленную на 4. Если функция больше 8 КБ, то вместо нее следует использовать полную запись типа XData.
- **Размер кадра** — это 9-разрядное поле, указывающее число байтов в стеке, выделенное для этой функции, деленное на 16. Функции, выделяющие больше (8 КБ-16) байт в стеке, должны использовать полную запись. XData. Сюда входит область локальных переменных, исходящая область параметров, вызываемая хранимая область int и FP, а также корневая область параметров, но без динамической области выделения.
- **CR** — это 2-разрядный флаг, указывающий, содержит ли функция дополнительные инструкции по настройке цепочки кадров и возвращаемой ссылки:
  - 00 = функция без сцепления, \<x29, LR > пара не сохраняется в стеке.
  - 01 = функция, не связанная с сцеплением, \<lr > сохраняется в стеке
  - 10 = зарезервировано;
  - 11 = цепочка функций, инструкция Store/Load в прологе/эпилога \<x29, LR >
- **H** — это 1-разрядный флаг, указывающий, регистрируется ли функция дома с целочисленным параметром (x0-120x7x1), сохраняя их в самом начале функции. (0 = не является домашним регистром, 1 = регистры домов).
- **Рег** — это 4-битовое поле, указывающее количество регистров int, не являющихся переменными (x19-x28), сохраненных в каноническом расположении стека.
- **Регф** — это 3-разрядное поле, указывающее количество регистров FP (D8-D15), которые были сохранены в каноническом расположении стека. (Регф = 0: регистр FP не сохраняется; Регф > 0: Регистры Регф + 1 с плавающей запятой сохранены). Упакованные данные очистки нельзя использовать для функций, которые сохраняют только один регистр FP.

Канонические журналы, которые попадают в категории 1, 2 (без исходящего параметра), 3 и 4 в разделе выше, могут быть представлены упакованным форматом очистки.  Эпилоги для канонических функций имеет очень похожую форму, за исключением того, что **H** не оказывает никакого воздействия, инструкция `set_fp` опущена, и порядок шагов, а также инструкции в каждом шаге отменяются в заключительном порядке. Алгоритм для упакованного XData следует этим действиям, описанным в следующей таблице.

Шаг 0. Выполните предварительное вычисление размера каждой области.

Шаг 1. Сохранить вызываемый объект int — сохраненные регистры.

Шаг 2. Этот шаг относится к типу 4 в ранних разделах. LR сохраняется в конце области int.

Шаг 3. Сохранить вызываемый объект FP — сохраненные регистры.

Шаг 4. Сохраните входные аргументы в домашней области параметров.

Шаг 5. Выделение оставшегося стека, включая локальную область, \<x29, LR > пару и исходящие параметры. 5A соответствует каноническому типу 1. 5b и 5C относятся к каноническому типу 2. 5D и 5e относятся к типу 3 и типу 4.

Первом #|Значения флагов|число инструкций|Код операции|Код очистки
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 < **рег** < = 10|Рег/2 + **Рег** % 2|`stp x19,x20,[sp,#savsz]!`<br/>`stp x21,x22,[sp,#16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**= = 01 *|1|`str lr,[sp,#(intsz-8)]`\*|`save_reg`
3|0 < **регф** < = 7|(Регф + 1)/2 +<br/>(Регф + 1)% 2)|`stp d8,d9,[sp,#intsz]`\*\*<br/>`stp d10,d11,[sp,#(intsz+16)]`<br/>`...`<br/>`str d(8+RegF),[sp,#(intsz+fpsz-8)]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** = = 1|4|`stp x0,x1,[sp,#(intsz+fpsz)]`<br/>`stp x2,x3,[sp,#(intsz+fpsz+16)]`<br/>`stp x4,x5,[sp,#(intsz+fpsz+32)]`<br/>`stp x6,x7,[sp,#(intsz+fpsz+48)]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5а|**CR** = = 11 & & #locsz<br/> < = 512|2|`stp x29,lr,[sp,#-locsz]!`<br/>`mov x29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5б|**CR** = = 11 & &<br/>512 < #locsz < = 4080|3|`sub sp,sp,#locsz`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5C|**CR** = = 11 & & #locsz > 4080|4|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
d|(**CR** = = 00 \| @ NO__T-2 **CR**= = 01) & &<br/>#locsz < = 4080|1|`sub sp,sp,#locsz`|`alloc_s`/`alloc_m`
5e|(**CR** = = 00 \| @ NO__T-2 **CR**= = 01) & &<br/>#locsz > 4080|2|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* если **CR** = = 01 и **Рег** — нечетное число, шаг 2 и последняя save_rep на шаге 1 объединяются в один save_regp.

\* @ no__t-1 Если **рег** == **CR** = = 0 и **регф** ! = 0, первый STP для операции с плавающей запятой выполняет предварительное уменьшение.

\* @ no__t-1 @ no__t-2 в эпилога отсутствует инструкция, соответствующая `mov x29,sp`. Упакованные данные очистки нельзя использовать, если функции требуется восстановление SP из X29.

### <a name="unwinding-partial-prologs-and-epilogs"></a>Раскрутка частичных журналов и эпилоги

Наиболее распространенной ситуацией при очистке является ситуация, в которой исключение или вызов возникли в теле функции, от пролога и всех эпилоги. В этом случае очистка выполняется очень просто: в начале кода начинается выполнение кодов в массиве очистки, начиная с индекса 0, и продолжается до тех пор, пока не будет обнаружен конечный код операции.

В случае, когда происходит исключение или прерывание при выполнении пролога или эпилога, труднее выполнить правильную очистку. В таких ситуациях кадр стека создается только частично, и хитрость заключается в том, чтобы точно определить, что было сделано, чтобы правильно отменить его.

Например, возьмем этот Пролог и последовательность эпилога:

```asm
0000:    stp    x29,lr,[sp,#-256]!          // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,#224]             // save_fregp 0, 224
0008:    stp    x19,x20,[sp,#240]           // save_regp 0, 240
000c:    mov    x29,sp                      // set_fp
         ...
0100:    mov    sp,x29                      // set_fp
0104:    ldp    x19,x20,[sp,#240]           // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    x29,lr,[sp],#256            // save_fplr_x  256 (post-indexed load)
0110:    ret    lr                          // end
```

Рядом с каждым кодом операций должен быть соответствующий код очистки, описывающий эту операцию. В первую очередь следует обратить внимание на то, что ряд кодов очистки для пролога представляет собой точную зеркальную копию кодов очистки для эпилога (не считая завершающей инструкции эпилога). Это распространенная ситуация, и по этой причине предполагается, что коды очистки для пролога всегда хранятся в обратном порядке от порядка выполнения пролога.

Таким образом, для пролога и эпилога мы оставили общий набор кодов очистки:

`set_fp`, `save_regp 0,240`, `save_fregp,0,224`, `save_fplr_x_256`, `end`

Начиная с случая эпилога (в обычном порядке), смещение 0 внутри эпилога (которое начинается со смещения 0x100 в функции), мы планируем выполнить полную последовательность очистки, так как очистка еще не выполнена. Если мы намерены выполнить одну инструкцию в (со смещением 2 в заключительном фрагменте), мы можем успешно завершить очистку, пропустив первый код очистки. Обобщение этой ситуации при условии сопоставления кодов операций и кода очистки 1:1, мы можем указать, что при очистке из инструкции n в заключительной части мы должны пропустить первые n кодов завершения и начать выполнять их отсюда.

Оказывается, что аналогичная логика работает для пролога, за исключением обратных. Если в прологе выполняется очистка от смещения 0, мы хотим выполнить ничего. Если отменить смещение 2, то есть одну инструкцию в, то нам пришлось бы начать выполнять последовательность очистки от конца кода (Помните, что коды хранятся в обратном порядке). Кроме того, мы можем обобщать, что при очистке из инструкции n в прологе мы должны начать выполнять n кодов очистки из конца списка кодов.

Теперь не всегда происходит точное совпадение кодов пролога и эпилога. По этой причине массив очистки может содержать несколько последовательностей кодов. Чтобы определить смещение места начала обработки кодов, используйте следующую логику:

1. При очистке в теле функции просто начните выполнение кодов очистки с индексом 0 и продолжайте до тех пор, пока не будет достигнуто значение "End".

1. При очистке из эпилога в качестве отправной точки используется начальный индекс, указанный в области эпилога. Вычислите количество байтов, которое задается на рассматриваемом компьютере, с начала эпилога. Затем пройдите вперед по кодам очистки, пропуская коды очистки до тех пор, пока все уже выполненные инструкции не будут учитываться для. Затем выполните команду, начиная с этой точки.

1. При очистке в прологе Используйте индекс 0 в качестве отправной точки. Вычислит длину кода пролога из последовательности, а затем вычислите количество байтов, которое данный компьютер находится в конце пролога. Затем пройдите вперед по кодам очистки, пропуская коды очистки до тех пор, пока не будут созданы все инструкции, которые еще не выполнены. Затем выполните команду, начиная с этой точки.

В результате этих правил коды очистки для пролога всегда должны быть первыми в массиве, а также коды, используемые для очистки в общем случае раскрутки в теле. Все последовательности кода, связанные с эпилога, должны следовать сразу после.

### <a name="function-fragments"></a>Фрагменты функций

Для целей оптимизации кода и других причин может быть предпочтительнее разделить функцию на отдельные фрагменты (также называемые регионами). Когда это будет сделано, каждому результирующему фрагменту функции требуется своя отдельная запись pData (и, возможно, XData).

Для отдельных вторичных фрагментов, имеющих собственный Пролог, ожидается, что в его прологе не выполняется корректировка стека. Все пространство стека, необходимое для вторичных регионов, должно быть предварительно выделено родительским регионом (или именем области узла). Это обеспечивает обработку указателя стека строго в исходном прологе функции.

Типичным случаем фрагментов-функций является «разделение кода», и этот компилятор может перемещать область кода из своей функции размещения. Существует три необычных случая, которые могут быть вызваны разделением кода.

#### <a name="example"></a>Пример

- (регион 1: начало)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (регион 1: конец)
- (регион 3: начало)

    ```asm
        ...
    ```

- (регион 3: конец)
- (регион 2: начало)

    ```asm
    ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (регион 2: конец)

1. Только Пролог (регион 1. все эпилоги находятся в отдельных регионах):

   Необходимо описать только Пролог. Он не может быть представлен в формате Compact. pData. В полном регистре. XData это можно представить, установив значение счетчика эпилога = 0. См. область 1 в приведенном выше примере.

   Коды очистки: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Только эпилоги (регион 2: Пролог находится в регионе узла)

   Предполагается, что при переходе по времени в этот регион были выполнены все коды пролога. Частичная очистка может выполняться в эпилоги так же, как и в обычной функции. Этот тип региона не может быть представлен Compact. pData. В полной записи XData его можно закодировать с помощью "фантомного" пролога, заключенного в пару кодов очистки `end_c` и `end`.  Ведущий `end_c` указывает, что размер пролога равен нулю. Начальный индекс эпилога одного пункта эпилога в `set_fp`.

   Код очистки для региона 2: `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Без журналов или эпилоги (регион 3: журналы и все эпилоги находятся в других фрагментах):

   Формат Compact. pdata можно применить с помощью флага установки = 10. С полной записью XData, число эпилога = 1. Код очистки такой же, как и для региона 2, но начальный индекс эпилога также указывает на `end_c`. Частичная очистка никогда не будет выполняться в этом регионе кода.

Еще один более сложный случай фрагментов функций — «сжатие по словам», при котором компилятор может отложить сохранение некоторых вызываемых, сохраненных, до тех пор, пока не будет находиться в прологе записи функции.

- (регион 1: начало)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (регион 2: начало)

    ```asm
        stp     x21,x22,[sp,#224]       // save_regp 2, 224
        ...
        ldp     x21,x22,[sp,#224]       // save_regp 2, 224
    ```

- (регион 2: конец)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (регион 1: конец)

В прологе области 1 пространство стека предварительно выделено. Обратите внимание, что регион 2 будет иметь такой же код очистки, даже если он перемещается из своей функции размещения.

Регион 1: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end` с эпилога Start индекс, указывает на `set_fp` обычным образом.

Регион 2: `save_regp 2, 224`, `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`. Начальный индекс эпилога указывает на первый код очистки `save_regp 2, 224`.

### <a name="large-functions"></a>Крупные функции

Фрагменты можно использовать для описания функций, превышающих ограничение в 1 МБ, наложенное битовыми полями в заголовке. XData. Для описания очень большой функции, подобной этой, необходимо разбить на фрагменты меньше 1м. Каждый фрагмент должен быть скорректирован таким образом, чтобы он не разбивает эпилога на несколько частей.

Только первый фрагмент функции будет содержать Пролог; все остальные фрагменты помечаются как не имеющие пролога. В зависимости от числа эпилоги каждый фрагмент может содержать ноль или более эпилоги. Помните, что каждая область эпилога в фрагменте определяет его начальное смещение относительно начала фрагмента, а не начала функции.

Если фрагмент не имеет пролога и не содержит эпилога, он по-прежнему нуждается в собственной записи. pdata (и, возможно,. XData), чтобы описать, как раскрутить его в теле функции.

## <a name="examples"></a>Примеры

### <a name="example-1-frame-chained-compact-form"></a>Пример 1: Сцепление кадров, компактный формат

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>Пример 2: Цепочка фреймов, полная форма с зеркальным прологом & эпилога

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

Обратите внимание, что Епилогстарт индекс [0] указывает на ту же последовательность кода очистки пролога.

### <a name="example-3-variadic-unchained-function"></a>Пример 3. Variadic несцепленная функция

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

Примечание. Епилогстарт индекс [4] указывает на середину кода очистки пролога (частично повторное использование массива очистки).

## <a name="see-also"></a>См. также

[Общие сведения о соглашениях ABI ARM64](arm64-windows-abi-conventions.md)<br/>
[Обработка исключений ARM](arm-exception-handling.md)
