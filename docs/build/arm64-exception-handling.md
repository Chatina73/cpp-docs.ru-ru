---
title: Обработка исключений в ARM64
description: Описывает соглашения об обработке исключений и данные, используемые Windows в ARM64.
ms.date: 11/19/2018
ms.openlocfilehash: 1ed147a27cfeb545e2a5fe265df8113a5befac73
ms.sourcegitcommit: 170f5de63b0fec8e38c252b6afdc08343f4243a6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/11/2019
ms.locfileid: "72276830"
---
# <a name="arm64-exception-handling"></a>Обработка исключений в ARM64

Windows в ARM64 использует один и тот же механизм структурированной обработки исключений для асинхронных исключений, генерируемых оборудованием, и синхронных исключений, созданных программным обеспечением. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. В этом документе описывается обработка исключений в Windows в ARM64 и вспомогательные методы языка, используемые кодом, создаваемым ассемблером Microsoft ARM и компилятором КОМПИЛЯТОРОМ MSVC.

## <a name="goals-and-motivation"></a>Цели и мотивация

Правила очистки данных об исключениях и их описание предназначены для следующих действий:

1. Предоставьте достаточное описание, чтобы разрешить раскрутку без проверки кода во всех случаях.

   - Для анализа кода требуется, чтобы код был разстраничным. Это предотвращает раскрутку в некоторых обстоятельствах, где это полезно (трассировка, выборка, отладка).

   - Анализ кода является сложным; компилятор должен быть аккуратным, чтобы создавались только инструкции, которые могут быть декодированы.

   - Если очистка не может быть полностью описана с помощью кодов очистки, в некоторых случаях необходимо вернуться к декодированию инструкций. Это увеличит общую сложность, и в идеале это будет избегать.

1. Поддержка очистки в середине-прологе и середине-эпилога.

   - В Windows используется очистка в целях обработки исключений. Очень важно, чтобы код мог аккуратно очищаться даже в середине последовательности кода пролога или эпилога.

1. Занимать минимальный объем пространства.

   - Для значительного увеличения двоичного размера коды очистки не должны выполнять статистическую обработку.

   - Так как коды очистки, скорее всего, будут заблокированы в памяти, небольшое место для каждого загруженного двоичного файла обеспечивает минимальный объем ресурсов.

## <a name="assumptions"></a>Допущения

Эти предположения вносятся в описание обработки исключений:

1. Журналы и эпилоги, как правило, являются зеркальными. Используя эту общую особенность, можно значительно сократить размер метаданных, необходимых для описания раскрутки. В теле функции не имеет значения, были ли отменены операции пролога, или операции эпилога выполняются в прямом направлении. Оба случая должны давать одинаковые результаты.

1. Функции обычно находятся в целом, чтобы быть относительно небольшими. Несколько способов оптимизации пространства полагаются на этот факт для достижения наиболее эффективной упаковки данных.

1. В эпилоги нет условного кода.

1. Регистр указателя выделенного фрейма: Если пакет обновления сохранен в другом регистре (X29) в прологе, регистрация остается нетронутой по всей функции. Это означает, что исходный пакет обновления может быть восстановлен в любое время.

1. Если пакет обновления не сохранен в другом регистре, все манипуляции указателя стека выполняются строго внутри пролога и эпилога.

1. Макет кадра стека организован так, как описано в следующем разделе.

## <a name="arm64-stack-frame-layout"></a>Макет кадра стека ARM64

![](media/arm64-exception-handling-stack-frame.png "Макет стека") кадров стека

Для функций, связанных с кадрами, пара FP и LR может быть сохранена в любой позиции в области локальных переменных в зависимости от соображений оптимизации. Цель — максимально увеличить количество локальных переменных, к которым может получить доступ одна инструкция на основе указателя фрейма (X29) или указателя стека (SP). Однако для функций `alloca` она должна быть сцеплена, а X29 должна указывать на нижнюю часть стека. Чтобы обеспечить лучшее покрытие с регистрацией в режиме адресации, области сохранения в неизменяемых регистрах располагаются в верхней части локального стека. Ниже приведены примеры, иллюстрирующие несколько наиболее эффективных последовательностей пролога. Чтобы обеспечить простоту и улучшить локальность кэша, порядок хранения вызываемых регистров во всех канонических журналах находится в возрастающем порядке. `#framesz` ниже соответствует размеру всего стека (за исключением области выделения). `#localsz` и `#outsz` обозначают размер локальной области (включая область сохранения для пары \<x29, LR >) и размер исходящего параметра соответственно.

1. Цепочка, #localsz \< = 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        stp    x29,lr,[sp,#-localsz]!   // save <x29,lr> at bottom of local area
        mov    x29,sp                   // x29 points to bottom of local
        sub    sp,sp,#outsz             // (optional for #outsz != 0)
    ```

1. Цепочка, #localsz > 512

    ```asm
        stp    x19,x20,[sp,#-96]!        // pre-indexed, save in 1st FP/INT pair
        stp    d8,d9,[sp,#16]            // save in FP regs (optional)
        stp    x0,x1,[sp,#32]            // home params (optional)
        stp    x2,x3,[sp,#48]
        stp    x4,x5,[sp,#64]
        stp    x6,x7,[sp,#72]
        sub    sp,sp,#(localsz+outsz)   // allocate remaining frame
        stp    x29,lr,[sp,#outsz]       // save <x29,lr> at bottom of local area
        add    x29,sp,#outsz            // setup x29 points to bottom of local area
    ```

1. Несцепленные конечные функции (LR не сохранено)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]
        str    x23,[sp,#32]
        stp    d8,d9,[sp,#40]           // save FP regs (optional)
        stp    d10,d11,[sp,#56]
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   Доступ ко всем локальным файлам осуществляется на основе SP. \<x29, LR > указывает на предыдущий кадр. Для размера кадра \< = 512, "RESP..." можно оптимизировать, если сохраненная область регс перемещается в нижнюю часть стека. Недостаток этого подхода заключается в том, что он не согласуется с другими макетами, и сохраненный регс принимает часть диапазона для регс и сквозного смещения.

1. Неконечные функции без привязке (LR сохраняются в сохраненной области int)

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        stp    x23,lr,[sp,#32]          // save last Int reg and lr
        stp    d8,d9,[sp,#48]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#64]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   Или с четным числом сохраненных регистров int,

    ```asm
        stp    x19,x20,[sp,#-80]!       // pre-indexed, save in 1st FP/INT reg-pair
        stp    x21,x22,[sp,#16]         // ...
        str    lr,[sp,#32]              // save lr
        stp    d8,d9,[sp,#40]           // save FP reg-pair (optional)
        stp    d10,d11,[sp,#56]         // ...
        sub    sp,sp,#(framesz-80)      // allocate the remaining local area
    ```

   X19 сохраненные:

    ```asm
        sub    sp,sp,#16                // reg save area allocation*
        stp    x19,lr,[sp]              // save x19, lr
        sub    sp,sp,#(framesz-16)      // allocate the remaining local area
    ```

   \* выделение области хранения reg не делится на STP, так как предварительно индексированный STP-LR не может быть представлен с кодами очистки.

   Доступ ко всем локальным файлам осуществляется на основе SP. \<x29 > указывает на предыдущий кадр.

1. Цепочка, #framesz \< = 512, #outsz = 0

    ```asm
        stp    x29,lr,[sp,#-framesz]!       // pre-indexed, save <x29,lr>
        mov    x29,sp                       // x29 points to bottom of stack
        stp    x19,x20,[sp,#(framesz-32)]   // save INT pair
        stp    d8,d9,[sp,#(framesz-16)]     // save FP pair
    ```

   По сравнению с первым примером пролога здесь преимущество заключается в том, что все инструкции по сохранению регистра готовы к выполнению только после одной инструкции по выделению стека. Это означает отсутствие зависимости от SP, препятствующего параллелизму на уровне инструкций.

1. Цепочка, размер кадра > 512 (необязательно для функций без выделения)

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        sub    sp,sp,#(framesz-80)          // allocate the remaining local area
    ```

   Для целей оптимизации X29 можно поместить в любое место в локальной области, чтобы обеспечить лучшее покрытие в режиме "Reg-пары" и режимах смещения до/пост-индексед. Доступ к локальным переменным под указателями кадров можно получить на основе SP.

1. Цепочка, размер кадра > 4 КБ, с разблокировками или без них ()

    ```asm
        stp    x29,lr,[sp,#-80]!            // pre-indexed, save <x29,lr>
        stp    x19,x20,[sp,#16]             // save in INT regs
        stp    x21,x22,[sp,#32]             // ...
        stp    d8,d9,[sp,#48]               // save in FP regs
        stp    d10,d11,[sp,#64]
        mov    x29,sp                       // x29 points to top of local area
        mov    x15,#(framesz/16)
        bl     __chkstk
        sub    sp,sp,x15,lsl#4              // allocate remaining frame
                                            // end of prolog
        ...
        sub    sp,sp,#alloca                // more alloca() in body
        ...
                                            // beginning of epilog
        mov    sp,x29                       // sp points to top of local area
        ldp    d10,d11,[sp,#64]
        ...
        ldp    x29,lr,[sp],#80              // post-indexed, reload <x29,lr>
    ```

## <a name="arm64-exception-handling-information"></a>Сведения об обработке исключений ARM64

### <a name="pdata-records"></a>записи pData

Записи. pdata — это упорядоченный массив элементов фиксированной длины, описывающих каждую функцию управления стеком в двоичном файле PE. Фраза "обработка с помощью стека" имеет большое значение: конечные функции, которые не требуют локального хранилища и не нуждаются в сохранении и восстановлении неизменяемых регистров, не требуют записи. pData. Для экономии пространства эти записи должны быть опущены явным образом. Очистка от одной из этих функций может получить обратный адрес непосредственно от LR, чтобы перейти к вызывающему объекту.

Каждая запись. pdata для ARM64 имеет длину 8 байт. В общем формате каждой записи помещается 32-разрядный RVA функции start в первом слове, за которым следует второе слово, содержащее указатель на блок переменной length. xdata или упакованное слово, описывающее каноническую последовательность очистки функции.

![. pdata запись Layout](media/arm64-exception-handling-pdata-record.png ". pdata макет записи")

Поля имеют следующие значения.

- **Начальный RVA функции** — это 32-разрядный RVA начала функции.

- **Флаг** — это 2-битовое поле, которое указывает, как интерпретировать оставшиеся 30 бит второго слова. pData. Если **флаг** имеет значение 0, оставшиеся биты формируют **RVA сведений об исключении** (с двумя младшими битами неявно 0). Если **флаг** не равен нулю, остальные биты формируют **упакованную структуру данных очистки** .

- **RVA сведений об исключении** — это адрес структуры сведений об исключении переменной длины, хранящейся в разделе. XData. Эти данные должны быть выровнены по 4-байтовой границе.

- **Упакованные данные очистки** — это сжатое описание операций, необходимых для очистки от функции при условии канонической формы. В этом случае запись .XDATA не требуется.

### <a name="xdata-records"></a>записи. XData

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись .XDATA переменной длины. Адрес этой записи хранится во втором слове записи .PDATA. Формат XData является упакованным набором слов с переменной длиной:

![. XData]. формат записи(media/arm64-exception-handling-xdata-record.png ". XData")

Эти данные разбиваются на четыре раздела:

1. Один или два слова, описывающие общий размер структуры и предоставляющие данные о ключевых функциях. Второе слово имеется только в том случае, если в полях количество и **код** **эпилога** задано значение 0. Заголовок содержит следующие битовые поля:

   1\. **Длина функции** — это 18-разрядное поле. Указывает общую длину функции в байтах, деленную на 4. Если функция больше 1 МБ, для описания функции необходимо использовать несколько записей. pdata и. XData. Дополнительные сведения см. в разделе [крупные функции](#large-functions) .

   2\. « **Сторно** » — это 2-битовое поле. Он описывает версию оставшегося. XData. В настоящее время определена только версия 0, поэтому значения 1-3 не разрешены.

   В. **X** является 1-битовым полем. Он указывает на присутствие (1) или отсутствие (0) данных исключения.

   Г. **E** — это 1 битовое поле. Он указывает, что информация, описывающая один заключительный фрагмент, упаковывается в заголовок (1), а не требует дополнительных слов области позже (0).

   Д. **Счетчик эпилогаs** — это 5-битовое поле, которое имеет два значения в зависимости от состояния **E** bit:

      1. Если значение **E** равно 0, то оно указывает общее число областей эпилога, описанных в разделе 2. Если в функции существует более 31 области, то в поле **кода** Words должно быть установлено значение 0, чтобы указать, что требуется расширение.

      2. Если значение **E** равно 1, то в этом поле указывается индекс первого кода очистки, который описывает только один и только эпилога.

   f. **Слова Code** — это 5-битовое поле, которое указывает число 32-разрядных слов, которые должны содержать все коды очистки в разделе 3. Если требуется более 31 слова (т. е. Если количество байтов кода очистки превышает 124), то это поле должно быть равно 0, чтобы указать, что требуется расширение слова.

   ж. **Расширенные значения счетчика эпилога** и **расширенного кода** являются 16-и 8-битовыми полями соответственно. Они предоставляют больше пространства для кодирования необычного большого числа эпилоги или слишком большого количества слов кода очистки. Слово расширения, содержащее эти поля, имеется только в том случае, если в первом заголовке указано значение 0 для полей " **число эпилога** " и " **код слова** ".

1. Если **Счетчик эпилога** не равен нулю, список сведений об областях эпилога, упакованный в слово, поступает после заголовка и дополнительного расширенного заголовка. Они хранятся в порядке возрастания начального смещения. Каждая область содержит следующие биты:

   1\. **Начальное смещение эпилога** — это 18-битовое поле, которое имеет смещение в байтах, деленное на 4, относительно начала функции.

   2\. **RES** — это 4-битовое поле, зарезервированное для будущего расширения. Оно должно иметь значение 0.

   В. **Начальный индекс эпилога** — это 10-разрядное поле (2 более разрядов, чем **Расширенные слова кода**). Указывает байтовый индекс первого кода очистки, который описывает этот эпилога.

1. После списка областей эпилога создается массив байтов, содержащих коды очистки, которые подробно описаны в следующем разделе. Этот массив дополняется в конец ближайшей границы полного слова. Коды очистки записываются в этот массив. Они начинаются с одного ближайшего к основному тексту функции и переходят к краям функции. Байты для каждого кода очистки хранятся в порядке с обратным порядком байтов, поэтому они могут быть получены напрямую, начиная с наиболее значимого байта, который определяет операцию и длину остальной части кода.

1. Наконец, после байтов кода очистки, если бит **X** в заголовке был установлен равным 1, то поступает информация об обработчике исключений. Он состоит из одного **RVA обработчика исключений** , который предоставляет адрес самого обработчика исключений. За ним следует объем данных переменной длины, необходимый обработчику исключений.

Запись. XData разработана таким образом, что можно получить первые 8 байтов и использовать их для расчета полного размера записи, за вычетом длины данных об исключении с переменным размером. Следующий фрагмент кода вычислит размер записи:

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 27) != 0) {
        Size = 4;
        EpilogScopes = (Xdata[0] >> 22) & 0x1f;
        UnwindWords = (Xdata[0] >> 27) & 0x0f;
    } else {
        Size = 8;
        EpilogScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    Size += 4 * EpilogScopes;
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;        // exception handler RVA
    }
    return Size;
}
```

Несмотря на то, что пролог и каждый эпилога имеют собственный индекс в кодах очистки, к ним применяется Общая таблица. Вполне возможно (и не совсем редким), что все они могут совместно использовать одни и те же коды. (Например, см. Пример 2 в разделе " [примеры](#examples) ".) Модули записи компилятора должны оптимизировать в этом случае, в частности, потому, что наибольший индекс, который можно указать, — 255, что ограничивает общее количество кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет собой пул последовательностей, описывающих, как отменить эффекты пролога, хранимые в том же порядке, в котором операции должны быть отменены. Коды очистки можно рассматривать как небольшой набор инструкций, закодированный как строка байтов. После завершения выполнения обратный адрес вызывающей функции находится в регистре LR. И все невременные регистры восстанавливаются в значениях во время вызова функции.

Если исключения были гарантированно только когда-либо находились в теле функции, а не в прологе или в каких-либо заключительных случаях, потребуется только одна последовательность. Однако модель очистки Windows требует, чтобы код можно было прокрутить из частично выполненного пролога или эпилога. Для удовлетворения этого требования коды очистки были тщательно спроектированы, чтобы они однозначно сопоставляли 1:1 с каждым соответствующим кодом операций в прологе и эпилога. Эта схема имеет несколько последствий.

1. Подсчитайте количество кодов очистки, можно вычислить длину пролога и эпилога.

1. Подчисляя количество инструкций после начала области эпилога, можно пропустить эквивалентное число кодов очистки. Затем мы можем выполнить оставшуюся часть последовательности для завершения частично выполненной очистки, выполненной заключительной частью.

1. Подчисляя количество инструкций до конца пролога, можно пропустить эквивалентное число кодов очистки. Затем мы можем выполнить оставшуюся часть последовательности, чтобы отменить только те части пролога, которые завершили выполнение.

Коды очистки кодируются в соответствии с таблицей ниже. Все коды очистки представляют собой один или два байта, за исключением того, который выделяет огромный стек. Полностью имеется 21 код очистки. Каждый код очистки сопоставляет ровно одну инструкцию в прологе или эпилога, чтобы можно было очищать частично выполненные журналы и эпилоги.

|Код очистки|Биты и интерпретация|
|-|-|
|`alloc_s`|000xxxxx: выделение мелкого стека с размером \< 512 (2 ^ 5 * 16).|
|`save_r19r20_x`|    001zzzzz: сохранение пары \<x19, x20 > в `[sp-#Z*8]!`, предварительно индексированное смещение > =-248 |
|`save_fplr`|        01zzzzzz: Save \<x29, LR > парой в `[sp+#Z*8]`, offset \< = 504. |
|`save_fplr_x`|        10zzzzzz: Save \<x29, LR > парой в `[sp-(#Z+1)*8]!`, предварительно индексированное смещение > =-512 |
|`alloc_m`|        11000xxx'xxxxxxxx: выделение большого стека размером \< 16 КБ (2 ^ 11 * 16). |
|`save_regp`|        110010xx'xxzzzzzz: сохранение пары x (19 + #X) по адресу `[sp+#Z*8]`, смещение \< = 504 |
|`save_regp_x`|        110011xx'xxzzzzzz: сохранить пару x (19 + #X) на `[sp-(#Z+1)*8]!`, предварительно индексированное смещение > =-512 |
|`save_reg`|        110100xx'xxzzzzzz: сохранение reg x (19 + #X) по адресу `[sp+#Z*8]`, смещение \< = 504 |
|`save_reg_x`|        1101010x'xxxzzzzz: сохранение reg x (19 + #X) на `[sp-(#Z+1)*8]!`, предварительно индексированное смещение > =-256 |
|`save_lrpair`|         1101011x'xxzzzzzz: Save паре \<x (19 + 2 * #X), LR > на `[sp+#Z*8]`, offset \< = 504 |
|`save_fregp`|        1101100x'xxzzzzzz: сохранить пару d (8 + #X) по адресу `[sp+#Z*8]`, смещение \< = 504 |
|`save_fregp_x`|        1101101x'xxzzzzzz: сохранить пару d (8 + #X), в `[sp-(#Z+1)*8]!`, предварительно индексированное смещение > =-512 |
|`save_freg`|        1101110x'xxzzzzzz: сохранение reg d (8 + #X) по адресу `[sp+#Z*8]`, смещение \< = 504 |
|`save_freg_x`|        11011110 "ксксксззззз: Save reg d (8 + #X) на `[sp-(#Z+1)*8]!`, предварительно индексированное смещение > =-256 |
|`alloc_l`|         11100000 "кскскскскскскскс'кскскскскскскскс'кскскскскскскскс: выделение большого стека с размером \< 256M (2 ^ 24 * 16) |
|`set_fp`|        11100001: Настройте X29: с: `mov x29,sp` |
|`add_fp`|        11100010 "xxxxxxxx: Настройка X29 с: `add x29,sp,#x*8` |
|`nop`|            11100011: операция очистки не требуется. |
|`end`|            11100100: конец кода очистки. Включает RET в эпилога. |
|`end_c`|        11100101: конец кода очистки в текущей последовательной области. |
|`save_next`|        11100110: Сохраните следующую пару регистров int или FP, не зависящую от volatile. |
|`arithmetic(add)`|    11100111 ' 000zxxxx: добавить файл cookie reg (z) в LR (0 = x28, 1 = SP); `add lr, lr, reg(z)` |
|`arithmetic(sub)`|    11100111 ' 001zxxxx: подфайл cookie reg (z) от LR (0 = x28, 1 = SP); `sub lr, lr, reg(z)` |
|`arithmetic(eor)`|    11100111 "010zxxxx: EOR LR с файлом cookie reg (z) (0 = x28, 1 = SP); `eor lr, lr, reg(z)` |
|`arithmetic(rol)`|    11100111 "0110xxxx: моделирует ROL LR с помощью файла cookie reg (x28); xip0 = нерасходный x28; `ror lr, xip0` |
|`arithmetic(ror)`|    11100111 "100zxxxx: ROR LR с файлом cookie reg (z) (0 = x28, 1 = SP); `ror lr, lr, reg(z)` |
| |            11100111: ксксксз----:----зарезервировано |
| |              11101xxx: зарезервировано для настраиваемых вариантов стека ниже, созданных только для подпрограмм ASM |
| |              11101000: Пользовательский стек для MSFT_OP_TRAP_FRAME |
| |              11101001: Пользовательский стек для MSFT_OP_MACHINE_FRAME |
| |              11101010: Пользовательский стек для MSFT_OP_CONTEXT |
| |              11101100: Пользовательский стек для MSFT_OP_CLEAR_UNWOUND_TO_CALL |
| |              1111xxxx: зарезервировано |

В инструкциях с большими значениями, охватывающими несколько байт, сначала сохраняются наиболее значимые биты. Такая схема позволяет найти общий размер кода очистки в байтах путем поиска только первого байта кода. Поскольку каждый код очистки полностью сопоставлен с инструкцией в прологе или эпилога, можно вычислить размер пролога или эпилога. Вы можете пройти от начала последовательности до конца и использовать таблицу подстановки или аналогичное устройство, чтобы определить, сколько времени соответствует код операции.

В прологе не допускаются одноадресные смещения. Все диапазоны смещения (#Z) соответствуют кодированию адресации STP/STR, за исключением `save_r19r20_x`, в которой 248 достаточно для всех областей сохранения (10 регистров int + 8 FP регистры + 8 входных регистров).

`save_next` должен следовать паре регистров для сохранения переменной int или FP: `save_regp`, `save_regp_x`, `save_fregp`, `save_fregp_x`, `save_r19r20_x` или другой `save_next`. Она сохраняет следующую пару регистров в следующем 16-байтовом слоте в возрастающем порядке. @No__t-0 ссылается на первую пару регистра FP, если она соответствует `save-next`, которая обозначает пару последних целочисленных регистров.

Так как размер обычных инструкций возврата и перехода одинаковы, нет необходимости разделять код очистки `end` для сценариев заключительного вызова.

`end_c` рассчитан на обработку несмежных фрагментов функций в целях оптимизации. Значение `end_c`, указывающее конец кодов очистки в текущей области, должно сопровождаться еще одной серией кода очистки, которая заканчивается реальным `end`. Коды очистки между `end_c` и `end` представляют операции пролога в родительском регионе ("Фантом").  Дополнительные сведения и примеры описаны в разделе ниже.

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для функций, чьи журналы и эпилоги следуют канонической форме, описанной ниже, можно использовать Упакованные данные для раскрутки. Он полностью устраняет необходимость в записи. XData и значительно сокращает затраты на предоставление данных очистки. Канонические журналы и эпилоги предназначены для удовлетворения общих требований простой функции: Одна из которых не требует обработчика исключений и выполняет операции установки и уничтожения в стандартном порядке.

Формат записи pData с упакованными данными очистки выглядит следующим образом:

![запись pData с упакованными данными раскрутки](media/arm64-exception-handling-packed-unwind-data.png ". pdata с упакованными данными очистки")

Поля имеют следующие значения.

- **Начальный RVA функции** — это 32-разрядный RVA начала функции.
- **Флаг** — это 2-битовое поле, как описано выше, со следующими значениями:
  - 00 = Упакованные данные очистки не используются; оставшиеся биты указывают на запись. XData
  - 01 = Упакованные данные очистки, используемые с одним прологом и эпилога в начале и в конце области
  - 10 = Упакованные данные очистки, используемые для кода без каких бы то ни было пролога и эпилога. Полезно для описания отдельных сегментов функций
  - 11 = зарезервировано.
- **Длина функции** — это 11-разрядное поле, предоставляющее длину всей функции в байтах, деленную на 4. Если функция больше 8 КБ, то вместо нее следует использовать полную запись типа XData.
- **Размер кадра** — это 9-разрядное поле, указывающее число байтов в стеке, выделенное для этой функции, деленное на 16. Функции, выделяющие больше (8 КБ-16) байт в стеке, должны использовать полную запись. XData. Она включает область локальных переменных, исходящие параметры, вызываемую область int и FP и область параметров Home, но не позволяет исключить область динамической области выделения.
- **CR** — это 2-разрядный флаг, указывающий, содержит ли функция дополнительные инструкции по настройке цепочки кадров и возвращаемой ссылки:
  - 00 = функция без сцепления, \<x29, LR > пара не сохраняется в стеке.
  - 01 = функция, не связанная с сцеплением, \<lr > сохраняется в стеке
  - 10 = зарезервировано;
  - 11 = цепочка функций, инструкция Store/Load в прологе/эпилога \<x29, LR >
- **H** — это 1-разрядный флаг, указывающий, регистрируется ли функция дома с целочисленным параметром (x0-120x7x1), сохраняя их в самом начале функции. (0 = не является домашним регистром, 1 = регистры домов).
- **Рег** — это 4-битовое поле, указывающее количество регистров int, не являющихся переменными (x19-x28), сохраненных в каноническом расположении стека.
- **Регф** — это 3-разрядное поле, указывающее количество регистров FP (D8-D15), которые были сохранены в каноническом расположении стека. (Регф = 0: регистр FP не сохраняется; Регф > 0: Регистры Регф + 1 с плавающей запятой сохранены). Упакованные данные выкрутки нельзя использовать для функций, которые сохраняют только один регистр FP.

Канонические журналы, которые попадают в категории 1, 2 (без исходящего параметра), 3 и 4 в разделе выше, могут быть представлены упакованным форматом очистки.  Эпилоги для канонических функций соответствует аналогичной форме, за исключением того, что **H** не оказывает никакого влияния, инструкция `set_fp` опущена, и порядок шагов и инструкции в каждом шаге будут отменены в заключительном порядке. Алгоритм для упакованного. XData следует этим действиям, описанным в следующей таблице.

Шаг 0. Предварительное вычисление размера каждой области.

Шаг 1. Сохранить вызываемый объект int — сохраненные регистры.

Шаг 2. Этот шаг относится к типу 4 в ранних разделах. LR сохраняется в конце области int.

Шаг 3. Сохранить вызываемый объект FP — сохраненные регистры.

Шаг 4. Сохраните входные аргументы в домашней области параметров.

Шаг 5. Выделение оставшегося стека, включая локальную область, \<x29, LR > пару и исходящие параметры. 5A соответствует каноническому типу 1. 5b и 5C относятся к каноническому типу 2. 5D и 5e относятся к типу 3 и типу 4.

Первом #|Значения флагов|число инструкций|Код операции|Код очистки
-|-|-|-|-
0|||`#intsz = RegI * 8;`<br/>`if (CR==01) #intsz += 8; // lr`<br/>`#fpsz = RegF * 8;`<br/>`if(RegF) #fpsz += 8;`<br/>`#savsz=((#intsz+#fpsz+8*8*H)+0xf)&~0xf)`<br/>`#locsz = #famsz - #savsz`|
1|0 < **рег** < = 10|Рег/2 + **Рег** %2|`stp x19,x20,[sp,#savsz]!`<br/>`stp x21,x22,[sp,#16]`<br/>`...`|`save_regp_x`<br/>`save_regp`<br/>`...`
2|**CR**= = 01 *|1|`str lr,[sp,#(intsz-8)]`\*|`save_reg`
3|0 < **регф** < = 7|(Регф + 1)/2 +<br/>(Регф + 1) %2)|`stp d8,d9,[sp,#intsz]`\*\*<br/>`stp d10,d11,[sp,#(intsz+16)]`<br/>`...`<br/>`str d(8+RegF),[sp,#(intsz+fpsz-8)]`|`save_fregp`<br/>`...`<br/>`save_freg`
4|**H** = = 1|4|`stp x0,x1,[sp,#(intsz+fpsz)]`<br/>`stp x2,x3,[sp,#(intsz+fpsz+16)]`<br/>`stp x4,x5,[sp,#(intsz+fpsz+32)]`<br/>`stp x6,x7,[sp,#(intsz+fpsz+48)]`|`nop`<br/>`nop`<br/>`nop`<br/>`nop`
5а|**CR** = = 11 & & #locsz<br/> < = 512|2|`stp x29,lr,[sp,#-locsz]!`<br/>`mov x29,sp`\*\*\*|`save_fplr_x`<br/>`set_fp`
5б|**CR** = = 11 & &<br/>512 < #locsz < = 4080|3|`sub sp,sp,#locsz`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`save_fplr`<br/>`set_fp`
5C|**CR** = = 11 & & #locsz > 4080|4|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`<br/>`stp x29,lr,[sp,0]`<br/>`add x29,sp,0`|`alloc_m`<br/>`alloc_s`/`alloc_m`<br/>`save_fplr`<br/>`set_fp`
d|(**CR** = = 00 \| @ NO__T-2 **CR**= = 01) & &<br/>#locsz < = 4080|1|`sub sp,sp,#locsz`|`alloc_s`/`alloc_m`
5e|(**CR** = = 00 \| @ NO__T-2 **CR**= = 01) & &<br/>#locsz > 4080|2|`sub sp,sp,4080`<br/>`sub sp,sp,#(locsz-4080)`|`alloc_m`<br/>`alloc_s`/`alloc_m`

\* если **CR** = = 01 и **Рег** — нечетное число, шаг 2 и последняя save_rep на шаге 1 объединяются в один save_regp.

\* @ no__t-1 Если **рег** == **CR** = = 0 и **регф** ! = 0, первый STP для операции с плавающей запятой выполняет предварительное уменьшение.

\* @ no__t-1 @ no__t-2 в эпилога отсутствует инструкция, соответствующая `mov x29,sp`. Упакованные данные очистки нельзя использовать, если функции требуется восстановление SP из X29.

### <a name="unwinding-partial-prologs-and-epilogs"></a>Раскрутка частичных журналов и эпилоги

Наиболее распространенной ситуацией при очистке является ситуация, в которой исключение или вызов возникли в теле функции, от пролога и всех эпилоги. В этом случае очистка выполняется очень просто: в начале кода начинается выполнение кодов в массиве очистки, начиная с индекса 0, и продолжается до тех пор, пока не будет обнаружен конечный код операции.

В случае, когда происходит исключение или прерывание при выполнении пролога или эпилога, труднее выполнить правильную очистку. В таких ситуациях кадр стека создается только частично. Проблема заключается в том, чтобы определить, что именно было сделано, чтобы правильно отменить его.

Например, возьмем этот Пролог и последовательность эпилога:

```asm
0000:    stp    x29,lr,[sp,#-256]!          // save_fplr_x  256 (pre-indexed store)
0004:    stp    d8,d9,[sp,#224]             // save_fregp 0, 224
0008:    stp    x19,x20,[sp,#240]           // save_regp 0, 240
000c:    mov    x29,sp                      // set_fp
         ...
0100:    mov    sp,x29                      // set_fp
0104:    ldp    x19,x20,[sp,#240]           // save_regp 0, 240
0108:    ldp    d8,d9,[sp,224]              // save_fregp 0, 224
010c:    ldp    x29,lr,[sp],#256            // save_fplr_x  256 (post-indexed load)
0110:    ret    lr                          // end
```

Рядом с каждым кодом операций должен быть соответствующий код очистки, описывающий эту операцию. Можно увидеть, как серия кодов очистки для пролога является точным зеркальным изображением кодов очистки для эпилога (не считая завершающей инструкции эпилога). Это распространенная ситуация, поэтому мы всегда предполагаем, что коды очистки для пролога хранятся в обратном порядке в порядке выполнения пролога.

Таким образом, для пролога и эпилога мы оставили общий набор кодов очистки:

`set_fp`, `save_regp 0,240`, `save_fregp,0,224`, `save_fplr_x_256`, `end`

Заключительный случай — это простой, так как он находится в нормальном порядке. Начиная со смещения 0 в заключительной части (которая начинается со смещения 0x100 в функции), мы ожидаем выполнить полную последовательность очистки, так как очистка еще не выполнена. Если мы намерены выполнить одну инструкцию в (со смещением 2 в заключительном фрагменте), мы можем успешно завершить очистку, пропустив первый код очистки. Мы можем обобщить эту ситуацию и предположить сопоставление 1:1 между кодом операций и кодами очистки. Затем, чтобы начать раскрутку из инструкции *n* в заключительной части, мы должны пропустить первые *n* кодов очистки и начать выполнять их отсюда.

Оказывается, что аналогичная логика работает для пролога, за исключением обратных. Если начать раскрутку из смещения 0 в прологе, мы хотим выполнить Nothing. Если мы отменяем смещение 2, то есть одну инструкцию в, нам нужно начать выполнять последовательность очистки от конца кода. (Помните, что коды хранятся в противоположном порядке.) Кроме того, мы можем обобщать: Если начать раскрутку из инструкции n в прологе, мы должны начать выполнять n кодов очистки из конца списка кодов.

Это не всегда так, что коды пролога и эпилога точно совпадают. Именно поэтому массив очистки может содержать несколько последовательностей кодов. Чтобы определить смещение места начала обработки кодов, используйте следующую логику:

1. При очистке в теле функции Начните выполнение кодов очистки с индексом 0 и продолжайте до тех пор, пока не будет вызвано значение "End".

1. При очистке из эпилога в качестве отправной точки используется начальный индекс, указанный в области эпилога. Вычислите количество байтов, которое задается на рассматриваемом компьютере, с начала эпилога. Затем пройдите вперед по кодам очистки, пропуская коды очистки до тех пор, пока все уже выполненные инструкции не будут учитываться для. Затем выполните команду, начиная с этой точки.

1. При очистке в прологе Используйте индекс 0 в качестве отправной точки. Вычислит длину кода пролога из последовательности, а затем вычислите количество байтов, которое данный компьютер находится в конце пролога. Затем пройдите вперед по кодам очистки, пропуская коды очистки до тех пор, пока не будут созданы все инструкции, которые еще не выполнены. Затем выполните команду, начиная с этой точки.

Эти правила означают, что коды очистки для пролога всегда должны быть первыми в массиве. Кроме того, они являются кодами, используемыми для очистки в общем случае раскрутки в теле. Все последовательности кода, связанные с эпилога, должны следовать сразу после.

### <a name="function-fragments"></a>Фрагменты функций

Для целей оптимизации кода и других причин может быть предпочтительнее разделить функцию на отдельные фрагменты (также называемые регионами). При разбиении каждому результирующему фрагменту функции требуется своя отдельная запись pData (и, возможно, XData).

Для каждого разделенного вторичного фрагмента, имеющего собственный Пролог, ожидается, что в его прологе не выполняется корректировка стека. Все пространство стека, необходимое для дополнительного региона, должно быть предварительно выделено родительским регионом (или именем области узла). Это обеспечивает обработку указателя стека строго в исходном прологе функции.

Типичным случаем фрагментов-функций является «разделение кода», и этот компилятор может перемещать область кода из своей функции размещения. Существует три необычных случая, которые могут быть вызваны разделением кода.

#### <a name="example"></a>Пример

- (регион 1: начало)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (регион 1: конец)

- (регион 3: начало)

    ```asm
        ...
    ```

- (регион 3: конец)

- (регион 2: начало)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (регион 2: конец)

1. Только Пролог (регион 1. все эпилоги находятся в отдельных регионах):

   Необходимо описать только Пролог. Он не может быть представлен в формате Compact. pData. В полном регистре. XData его можно представить, установив значение счетчика эпилога = 0. См. область 1 в приведенном выше примере.

   Коды очистки: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Только эпилоги (регион 2: Пролог находится в регионе узла)

   Предполагается, что при переходе по времени в этот регион были выполнены все коды пролога. Частичная очистка может выполняться в эпилоги так же, как и в обычной функции. Этот тип региона не может быть представлен Compact. pData. В полной записи XData его можно закодировать с помощью "фантомного" пролога, заключенного в пару кодов очистки `end_c` и `end`.  Ведущий `end_c` указывает, что размер пролога равен нулю. Начальный индекс эпилога одного пункта эпилога в `set_fp`.

   Код очистки для региона 2: `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`.

1. Без журналов или эпилоги (регион 3: журналы и все эпилоги находятся в других фрагментах):

   Формат Compact. pdata можно применить с помощью флага установки = 10. С полной записью XData, число эпилога = 1. Код очистки тот же, что и код для региона 2, но начальный индекс эпилога также указывает на `end_c`. Частичная очистка никогда не будет выполняться в этом регионе кода.

Еще один более сложный случай фрагментов функций — «сжатие переносов». Компилятор может отложить сохранение некоторых вызываемых хранимых регистров до тех пор, пока не будет находиться в прологе записи функции.

- (регион 1: начало)

    ```asm
        stp     x29,lr,[sp,#-256]!      // save_fplr_x  256 (pre-indexed store)
        stp     x19,x20,[sp,#240]       // save_regp 0, 240
        mov     x29,sp                  // set_fp
        ...
    ```

- (регион 2: начало)

    ```asm
        stp     x21,x22,[sp,#224]       // save_regp 2, 224
        ...
        ldp     x21,x22,[sp,#224]       // save_regp 2, 224
    ```

- (регион 2: конец)

    ```asm
        ...
        mov     sp,x29                  // set_fp
        ldp     x19,x20,[sp,#240]       // save_regp 0, 240
        ldp     x29,lr,[sp],#256        // save_fplr_x  256 (post-indexed load)
        ret     lr                      // end
    ```

- (регион 1: конец)

В прологе области 1 пространство стека предварительно выделено. Можно увидеть, что регион 2 будет иметь тот же код очистки, даже если он перемещается из своей функции размещения.

Регион 1: `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end` с эпилога Start индекс, указывает на `set_fp` обычным образом.

Регион 2: `save_regp 2, 224`, `end_c`, `set_fp`, `save_regp 0,240`, `save_fplr_x_256`, `end`. Начальный индекс эпилога указывает на первый код очистки `save_regp 2, 224`.

### <a name="large-functions"></a>Крупные функции

Фрагменты можно использовать для описания функций, превышающих ограничение в 1 МБ, наложенное битовыми полями в заголовке. XData. Чтобы описать очень крупную функцию, подобную этой, ее необходимо разбить на фрагменты меньше 1 МБ. Каждый фрагмент должен быть скорректирован таким образом, чтобы он не разбивает эпилога на несколько частей.

Только первый фрагмент функции будет содержать Пролог; все остальные фрагменты помечаются как не имеющие пролога. В зависимости от числа эпилоги каждый фрагмент может содержать ноль или более эпилоги. Помните, что каждая область эпилога в фрагменте определяет его начальное смещение относительно начала фрагмента, а не начала функции.

Если фрагмент не имеет пролога и не содержит эпилога, он по-прежнему нуждается в собственной записи. pdata (и, возможно,. XData), чтобы описать, как раскрутить его в теле функции.

## <a name="examples"></a>Примеры

### <a name="example-1-frame-chained-compact-form"></a>Пример 1: Сцепление кадров, компактный формат

```asm
|Foo|     PROC
|$LN19|
    str     x19,[sp,#-0x10]!        // save_reg_x
    sub     sp,sp,#0x810            // alloc_m
    stp     fp,lr,[sp]              // save_fplr
    mov     fp,sp                   // set_fp
                                    //  end of prolog
    ...

|$pdata$Foo|
    DCD     imagerel     |$LN19|
    DCD     0x416101ed
    ;Flags[SingleProEpi] functionLength[492] RegF[0] RegI[1] H[0] frameChainReturn[Chained] frameSize[2080]
```

### <a name="example-2-frame-chained-full-form-with-mirror-prolog--epilog"></a>Пример 2: Цепочка фреймов, полная форма с зеркальным прологом & эпилога

```asm
|Bar|     PROC
|$LN19|
    stp     x19,x20,[sp,#-0x10]!    // save_regp_x
    stp     fp,lr,[sp,#-0x90]!      // save_fplr_x
    mov     fp,sp                   // set_fp
                                    // end of prolog
    ...
                                    // begin of epilog, a mirror sequence of Prolog
    mov     sp,fp
    ldp     fp,lr,[sp],#0x90
    ldp     x19,x20,[sp],#0x10
    ret     lr

|$pdata$Bar|
    DCD     imagerel     |$LN19|
    DCD     imagerel     |$unwind$cse2|
|$unwind$Bar|
    DCD     0x1040003d
    DCD     0x1000038
    DCD     0xe42291e1
    DCD     0xe42291e1
    ;Code Words[2], Epilog Count[1], E[0], X[0], Function Length[6660]
    ;Epilog Start Index[0], Epilog Start Offset[56]
    ;set_fp
    ;save_fplr_x
    ;save_r19r20_x
    ;end
```

Начальный индекс эпилога [0] указывает на ту же последовательность кода очистки пролога.

### <a name="example-3-variadic-unchained-function"></a>Пример 3. Variadic несцепленная функция

```asm
|Delegate| PROC
|$LN4|
    sub     sp,sp,#0x50
    stp     x19,lr,[sp]
    stp     x0,x1,[sp,#0x10]        // save incoming register to home area
    stp     x2,x3,[sp,#0x20]        // ...
    stp     x4,x5,[sp,#0x30]
    stp     x6,x7,[sp,#0x40]        // end of prolog
    ...
    ldp     x19,lr,[sp]             // beginning of epilog
    add     sp,sp,#0x50
    ret     lr

    AREA    |.pdata|, PDATA
|$pdata$Delegate|
    DCD     imagerel |$LN4|
    DCD     imagerel |$unwind$Delegate|

    AREA    |.xdata|, DATA
|$unwind$Delegate|
    DCD     0x18400012
    DCD     0x200000f
    DCD     0xe3e3e3e3
    DCD     0xe40500d6
    DCD     0xe40500d6
    ;Code Words[3], Epilog Count[1], E[0], X[0], Function Length[18]
    ;Epilog Start Index[4], Epilog Start Offset[15]
    ;nop        // nop for saving in home area
    ;nop        // ditto
    ;nop        // ditto
    ;nop        // ditto
    ;save_lrpair
    ;alloc_s
    ;end
```

Начальный индекс эпилога [4] указывает на середину кода очистки пролога (частичное повторное использование массива очистки).

## <a name="see-also"></a>См. также

[Общие сведения о соглашениях ABI ARM64](arm64-windows-abi-conventions.md)<br/>
[Обработка исключений ARM](arm-exception-handling.md)
