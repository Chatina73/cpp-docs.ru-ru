---
title: Поддержка открытых папок для систем сборки C++ в Visual Studio
ms.date: 12/02/2019
helpviewer_keywords:
- Open Folder Projects in Visual Studio
ms.assetid: abd1985e-3717-4338-9e80-869db5435175
ms.openlocfilehash: 9264aa4bf77de406bdde9042ef9ec4251763f721
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81320964"
---
# <a name="open-folder-support-for-c-build-systems-in-visual-studio"></a>Поддержка открытых папок для систем сборки C++ в Visual Studio

::: moniker range="vs-2015"

Функция Open Folder доступна в Visual Studio 2017 и позже.

::: moniker-end

::: moniker range=">=vs-2017"

В Visual Studio 2017 и более поздних версиях появилась функция "Открыть папку", позволяющая открыть папку исходных файлов и немедленно приступить к написанию кода с поддержкой IntelliSense, просмотра, рефакторинга, отладки и т. п. Когда вы изменяете, создаете и удаляете файлы, Visual Studio автоматически отслеживает эти изменения и постоянно обновляет индекс IntelliSense. Никакие файлы SLN или VCXPROJ не загружаются. При необходимости вы можете указать настраиваемые задачи и параметры запуска, используя простые файлы JSON. Эта функция позволяет интегрировать любую стороннюю систему сборки в Visual Studio. Общие сведения о проекте "Открыть папку" см. в статье [Разработка кода в Visual Studio без использования проектов и решений](/visualstudio/ide/develop-code-in-visual-studio-without-projects-or-solutions).

## <a name="cmake-and-qt"></a>CMake и Зт

CMake интегрирован в Visual Studio IDE в качестве компонента рабочей нагрузки на настольный компьютер СЗ. Рабочий процесс для CMake не идентичен рабочему процессу, описанного в этой статье. Если вы используете CMake, смотрите [проекты CMake в Visual Studio.](cmake-projects-in-visual-studio.md) Вы также можете использовать CMake для создания проектов, или вы можете использовать [расширение визуальной студии для](https://download.qt.io/development_releases/vsaddin/) Visual Studio 2015 или Visual Studio 2017.

## <a name="other-build-systems"></a>Другие системы сборки

Для использования Visual Studio IDE с системой сборки или набором инструментов компилятора, который не поддерживается напрямую из основного меню, выберите **файл Открыто (ru) Фолдер** или нажмите **Ctrl** Перейдите к папке, содержащей файлы исходного кода. Чтобы построить проект, настроить IntelliSense и установить параметры отладки, вы добавляете три файла JSON:

| | |
|-|-|
|CppProperties.json|Указывает сведения о настраиваемой конфигурации для просмотра. При необходимости вы можете создать этот файл в корневой папке проекта. (Не используется в проектах CMake.)|
|tasks.vs.json|Укажите пользовательские команды сборки. Доступ к файлу можно получить в **обозревателе решений**, воспользовавшись пунктом контекстного меню **Настройка задач**.|
|launch.vs.json|Задает аргументы командной строки для отладчика. Доступ к файлу можно получить в **обозревателе решений**, воспользовавшись пунктом контекстного меню **Параметры отладки и запуска**.|

## <a name="configure-code-navigation-with-cpppropertiesjson"></a>Настройка кода навигации с CppProperties.json

Для IntelliSense и просмотра поведения, такие как **Перейти к определению** работать правильно, Visual Studio необходимо знать, какой компилятор вы используете, где системные заголовки, и где любые дополнительные файлы включают расположены, если они не находятся непосредственно в папке вы открыли (папка рабочего пространства). Чтобы указать конфигурацию, можно выбрать **конфигурацию управления** из выпадения в основной панели инструментов:

![Управление выпадением конфигураций](media/manage-configurations-dropdown.png)

Visual Studio предлагает следующие конфигурации по умолчанию:

![Конфигурации по умолчанию](media/default-configurations.png)

Если, например, вы выбираете **x64-Debug,** Visual Studio создает файл под названием *CppProperties.json* в папке корневого проекта:

```json
{
  "configurations": [
    {
      "inheritEnvironments": [
        "msvc_x64"
      ],
      "name": "x64-Debug",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "defines": [
        "WIN32",
        "_DEBUG",
        "UNICODE",
        "_UNICODE"
      ],
      "intelliSenseMode": "windows-msvc-x64"
    }
  ]
}
```

Эта конфигурация наследует переменные среды Visual Studio [x64 Developer Command Prompt.](building-on-the-command-line.md) Одна из этих `INCLUDE` переменных, и вы можете `${env.INCLUDE}` обратиться к нему здесь с помощью макроса. Свойство `includePath` рассказывает Visual Studio, где искать все источники, которые ему нужны для IntelliSense. В этом случае в нем говорится: "Посмотрите во всех каталогах, указанных переменной среды INCLUDE, а также все каталоги в текущем рабочем дереве папки". Свойство `name` это имя, которое появится в выпадающих, и может быть все, что вам нравится. Свойство `defines` предоставляет подсказки IntelliSense, когда он сталкивается с условными блоками компиляции. Свойство `intelliSenseMode` предоставляет некоторые дополнительные подсказки в зависимости от типа компилятора. Несколько вариантов доступны для MSVC, GCC и Clang.

> [!NOTE]
> Если Visual Studio, кажется, игнорирует настройки в *CppProperties.json,* попробуйте добавить `!/CppProperties.json`исключение в файл *.gitignore* следующим образом: .

## <a name="default-configuration-for-mingw-w64"></a>Конфигурация по умолчанию для MinGW-w64

Если вы добавите конфигурацию MinGW-W64, JSON выглядит следующим образом:

```json
{
  {
      "inheritEnvironments": [
        "mingw_64"
      ],
      "name": "Mingw64",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "intelliSenseMode": "linux-gcc-x64",
      "environments": [
        {
          "MINGW64_ROOT": "C:\\msys64\\mingw64",
          "BIN_ROOT": "${env.MINGW64_ROOT}\\bin",
          "FLAVOR": "x86_64-w64-mingw32",
          "TOOLSET_VERSION": "9.1.0",
          "PATH": "${env.BIN_ROOT};${env.MINGW64_ROOT}\\..\\usr\\local\\bin;${env.MINGW64_ROOT}\\..\\usr\\bin;${env.MINGW64_ROOT}\\..\\bin;${env.PATH}",
          "INCLUDE": "${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION};${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\tr1;${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\${env.FLAVOR}",
          "environment": "mingw_64"
        }
      ]
    }
}
```

Обратите `environments` внимание на блок. Он определяет свойства, которые ведут себя как переменные среды и доступны не только в файле *CppProperties.json,* но и в других файлах конфигурации *task.vs.json* и *launch.vs.json.* Конфигурация `Mingw64` наследует `mingw_w64` среду и `INCLUDE` использует ее свойство `includePath`для определения значения. Вы можете добавить другие пути к свойству этого массива по мере необходимости.

Свойство `intelliSenseMode` устанавливается в соответствии со значением, подходящим для GCC. Для получения дополнительной информации обо всех этих свойствах [см.](cppproperties-schema-reference.md)

Когда все работает правильно, вы увидите IntelliSense из заголовков GCC, когда вы наведите на тип:

![GCC IntelliSense](media/gcc-intellisense.png)

## <a name="enable-intellisense-diagnostics"></a>Включить диагностику IntelliSense

Если вы не видите IntelliSense, что вы ожидаете, вы можете устранить неполадки, перейдя в **Инструменты** > **Параметры** > **Текстовый редактор** > **C / C '** > **Расширенный** и настройки **Enable Logging** на **истину**. Для начала попробуйте установить **уровень регистрации** до 5, а **фильтры регистрации** — до 8.

![Ведение журнала диагностики](media/diagnostic-logging.png)

Выход по трубопроводу в **окно вывода** и виден при выборе*вывода от: Визуальный журнал C .* Выход содержит, среди прочего, список фактических включают пути, которые IntelliSense пытается использовать. Если пути не совпадают с теми, что есть в *CppProperties.json,* попробуйте закрыть папку и удалить субфолдер *.vs,* содержащий кэшированные данные просмотра.

### <a name="define-build-tasks-with-tasksvsjson"></a>Определение задач сборки в файле tasks.vs.json

Вы можете автоматизировать скрипты сборки и любые внешние операции с файлами, размещенными в текущей рабочей области, запуская их как задачи в интегрированной среде разработки. Чтобы настроить новую задачу, щелкните правой кнопкой мыши нужный файл или папку и выберите **Настройка задач**.

![Настройка задач "Открыть папку"](media/configure-tasks.png)

Это создает (или открывает) файл *tasks.vs.json* в папке .vs, которую Visual Studio создает в папке корневого проекта. Можно определить в этом файле любую произвольную задачу, а затем вызывать ее из контекстного меню **обозревателя решений**. Для продолжения примера ССЗ следующий фрагмент показывает полный файл *task.vs.json* в качестве одной задачи, которая вызывает *g'.exe* для создания проекта. Предположим, что проект содержит один файл под названием *hello.cpp*.

```json
{
  "version": "0.2.1",
  "tasks": [
    {
      "taskLabel": "build hello",
      "appliesTo": "/",
      "type": "default",
      "command": "g++",
      "args": [
        "-g",
        "-o",
        "hello",
        "hello.cpp"
      ]
    }
  ]
}

```

Файл JSON помещается в *subfolder .vs.* Чтобы увидеть эту папку, нажмите на кнопку **Показать все файлы** в верхней части **Solution Explorer.** Вы можете выполнить эту задачу, нажав правой кнопкой на корневом узло в **Solution Explorer** и выбрав **«привет сборки».** Когда задача будет выполнена, вы должны увидеть новый файл, *hello.exe* в **Solution Explorer.**

Можно определить множество типов задач. В следующем примере показан *файл task.vs.json,* определяющий одну задачу. `taskLabel` определяет имя, отображаемое в контекстном меню. `appliesTo` определяет, для каких файлов можно выполнить эту команду. Свойство `command` относится к переменной среды COMSPEC, которая определяет путь для*консоли (cmd.exe* на Windows). Вы также можете ссылаться на переменные среды, объявленные в CppProperties.json или CMakeSettings.json. Свойство `args` определяет вызываемую командную строку. Макрос `${file}` передает выбранный файл в **обозреватель решений**. Приведенный ниже пример отображает имя для выбранного в этот момент CPP-файла.

```json
{
  "version": "0.2.1",
  "tasks": [
    {
      "taskLabel": "Echo filename",
      "appliesTo": "*.cpp",
      "type": "command",
      "command": "${env.COMSPEC}",
      "args": ["echo ${file}"]
    }
  ]
}
```

После сохранения *tasks.vs.json*вы можете нажать правой кнопкой мыши любой файл *.cpp* в папке, выбрать **имя файла Echo** из контекстного меню и увидеть имя файла, отображаемое в окне вывода.

Дополнительные сведения см. в разделе [Справочник по схеме Tasks.vs.json](tasks-vs-json-schema-reference-cpp.md).

### <a name="configure-debugging-parameters-with-launchvsjson"></a>Настройка параметров отладки с помощью launch.vs.json

Чтобы настроить аргументы командной строки программы и инструкции по отладке, нажмите правой кнопкой мыши на исполняемые в **Solution Explorer** и выберите **настройки отнажатий и запуска.** Это откроет существующий файл *launch.vs.json,* или если его нет, он создаст новый файл с набором минимальных настроек запуска. Сначала вам предоставляется выбор, какую сессию отладки вы хотите настроить. Для отладки проекта MinGw-w64 мы выбираем **запуск C/C для MinGW/Cygwin (gdb).** Это создает конфигурацию запуска для использования *gdb.exe* с некоторыми образованными догадками о значениях по умолчанию. Одним из этих значений по умолчанию является `MINGW_PREFIX`. Вы можете заменить буквальный путь (как показано `MINGW_PREFIX` ниже) или вы можете определить свойство в *CppProperties.json*:

```json
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "cppdbg",
      "name": "hello.exe",
      "project": "hello.exe",
      "cwd": "${workspaceRoot}",
      "program": "${debugInfo.target}",
      "MIMode": "gdb",
      "miDebuggerPath": "c:\\msys64\\usr\\bin\\gdb.exe",
      "externalConsole": true
    }
  ]
}

```

Чтобы начать отладку, выберите исполняемое в отладке, затем нажмите зеленую стрелку:

![Отладка запуска](media/launch-debugger-gdb.png)

Вы должны увидеть диалог **Инициализации Debugger,** а затем внешнее окно консоли, которое работает с вашей программой.

Для получения дополнительной информации [см.](launch-vs-schema-reference-cpp.md)

## <a name="launching-other-executables"></a>Запуск других исполнителей

Настройки запуска можно определить для любого исполняемого на вашем компьютере. Следующий пример запускает *7za* и определяет дополнительные аргументы, `args` добавляя их в массив JSON:

```json
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "default",
      "project": "CPP\\7zip\\Bundles\\Alone\\O\\7za.exe",
      "name": "7za.exe list content of helloworld.zip",
      "args": [ "l", "d:\\sources\\helloworld.zip" ]
    }
  ]
}
```

Когда вы сохраняете этот файл, новая конфигурация отображается в раскрывающемся списке "Цель отладки". Вы можете выбрать ее, чтобы запустить отладчик. Можно создать любое количество конфигураций отладки для любого количества исполняемых файлов. Нажатие клавиши **F5** запускает отладчик, который будет останавливаться на всех заданных точках останова. Все обычные окна отладчика и их функции теперь доступны.

::: moniker-end
