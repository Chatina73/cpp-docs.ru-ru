---
title: Поддержка открытых папок для систем сборки C++ в Visual Studio
ms.date: 08/20/2019
helpviewer_keywords:
- Open Folder Projects in Visual Studio
ms.assetid: abd1985e-3717-4338-9e80-869db5435175
ms.openlocfilehash: 78b1c00b07423e9d02f585c707156a1c843bea6f
ms.sourcegitcommit: ace42fa67e704d56d03c03745b0b17d2a5afeba4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/22/2019
ms.locfileid: "69976022"
---
# <a name="open-folder-support-for-c-build-systems-in-visual-studio"></a>Поддержка открытых папок для систем сборки C++ в Visual Studio

::: moniker range="vs-2015"

Функция открытия папки доступна в Visual Studio 2017 и более поздних версиях.

::: moniker-end

::: moniker range=">=vs-2017"

В Visual Studio 2017 и более поздних версиях появилась функция "Открыть папку", позволяющая открыть папку исходных файлов и немедленно приступить к написанию кода с поддержкой IntelliSense, просмотра, рефакторинга, отладки и т. п. Когда вы изменяете, создаете и удаляете файлы, Visual Studio автоматически отслеживает эти изменения и постоянно обновляет индекс IntelliSense. Никакие файлы SLN или VCXPROJ не загружаются. При необходимости вы можете указать настраиваемые задачи и параметры запуска, используя простые файлы JSON. Эта функция позволяет интегрировать любую систему сборки сторонних разработчиков в Visual Studio. Общие сведения о проекте "Открыть папку" см. в статье [Разработка кода в Visual Studio без использования проектов и решений](/visualstudio/ide/develop-code-in-visual-studio-without-projects-or-solutions).

## <a name="cmake-and-qt"></a>CMak и Qt

CMak интегрирован в интегрированную среду разработки Visual Studio как компонент рабочей нагрузки C++ рабочего стола. Рабочий процесс для CMak не идентичен рабочему процессу, описанному в этой статье. Если вы используете CMak, см. статью о [проектах CMAK в Visual Studio](cmake-projects-in-visual-studio.md). Можно также использовать CMak для сборки проектов Qt или использовать [расширение Qt Visual Studio](https://download.qt.io/development_releases/vsaddin/) для visual Studio 2015 или visual Studio 2017.

## <a name="other-build-systems"></a>Другие системы сборки

Чтобы использовать интегрированную среду разработки Visual Studio с системой сборки или набором средств компилятора, которые не поддерживаются напрямую из главного меню, выберите **файл | Открыть |** Или нажмите клавиши **CTRL + SHIFT + ALT + O**. Перейдите в папку, содержащую файлы исходного кода. Чтобы выполнить сборку проекта, настроить IntelliSense и задать параметры отладки, добавьте три файла JSON:

| | |
|-|-|
|CppProperties.json|Указывает сведения о настраиваемой конфигурации для просмотра. При необходимости вы можете создать этот файл в корневой папке проекта. (Не используется в проектах CMake.)|
|tasks.vs.json|Укажите настраиваемые команды сборки. Доступ к файлу можно получить в **обозревателе решений**, воспользовавшись пунктом контекстного меню **Настройка задач**.|
|launch.vs.json|Задает аргументы командной строки для отладчика. Доступ к файлу можно получить в **обозревателе решений**, воспользовавшись пунктом контекстного меню **Параметры отладки и запуска**.|

## <a name="configure-code-navigation-with-cpppropertiesjson"></a>Настройка навигации по коду с помощью CppProperties. JSON

Для правильной работы функций IntelliSense и обзора, таких как **"перейти к определению"** , Visual Studio необходимо определить, какой компилятор используется, где находятся заголовки системы и где находятся дополнительные включаемые файлы, если они не находятся непосредственно в открытая папка (папка рабочей области). Чтобы указать конфигурацию, можно выбрать **Управление конфигурациями** из раскрывающегося списка на главной панели инструментов:

![Раскрывающееся меню управления конфигурациями](media/manage-configurations-dropdown.png)

В настоящее время Visual Studio предлагает четыре конфигурации по умолчанию, все C++ для компилятора Майкрософт:

![Конфигурации по умолчанию](media/default-configurations.png)

Если, например, вы выбрали **x64-Debug**, Visual Studio создаст файл с именем *CppProperties. JSON* в корневой папке проекта и заполнит его следующим образом:

```json
{
  "configurations": [
    {
      "inheritEnvironments": [
        "msvc_x64"
      ],
      "name": "x64-Debug",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "defines": [
        "WIN32",
        "_DEBUG",
        "UNICODE",
        "_UNICODE"
      ],
      "intelliSenseMode": "windows-msvc-x64"
    }
  ]
}
```

Эта конфигурация "наследует" переменные среды Visual Studio [x64 Командная строка разработчика](building-on-the-command-line.md). Одной из этих переменных является `INCLUDE` , и на нее можно ссылаться с `${env.INCLUDE}` помощью макроса. `includePath` Свойство сообщает Visual Studio, где искать все источники, необходимые для IntelliSense. В этом случае появляется сообщение «просмотрите все каталоги, указанные переменной среды INCLUDE, а также все каталоги в дереве текущей рабочей папки». `name` Свойство — это имя, которое будет отображаться в раскрывающемся списке и может быть любым. `defines` Свойство предоставляет подсказки для IntelliSense при обнаружении блоков условной компиляции. `intelliSenseMode` Свойство предоставляет некоторые дополнительные указания на основе типа компилятора. Для КОМПИЛЯТОРОМ MSVC, GCC и Clang доступны несколько параметров.

## <a name="example-configuration-for-gcc"></a>Пример конфигурации для GCC

Если используется компилятор, отличный от Microsoft C++, необходимо создать пользовательскую конфигурацию и среду в *CppProperties. JSON*. В следующем примере показан полный файл *CppProperties. JSON* с единственной пользовательской конфигурацией для использования GCC в установке MSYS2:

```json
{
  "configurations": [
   {
      "inheritEnvironments": [
        "mingw_64"
      ],
      "name": "Mingw64",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "intelliSenseMode": "linux-gcc-x64",
      "environments": [
        {
          "MINGW64_ROOT": "C:\\msys64\\mingw64",
          "BIN_ROOT": "${env.MINGW64_ROOT}\\bin",
          "FLAVOR": "x86_64-w64-mingw32",
          "TOOLSET_VERSION": "8.3.0",
          "PATH": "${env.MINGW64_ROOT}\\bin;${env.MINGW64_ROOT}\\..\\usr\\local\\bin;${env.MINGW64_ROOT}\\..\\usr\\bin;${env.MINGW64_ROOT}\\..\\bin;${env.PATH}",
          "INCLUDE": "${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION};${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\tr1;${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\${env.FLAVOR}",
          "environment": "mingw_64"
        }
      ]
   }
}
```

Обратите `environments` внимание на блок. Он определяет свойства, которые ведут себя как переменные среды и доступны не только в файле *CppProperties. JSON* , но и в других файлах конфигурации *Task. vs. JSON* и *Launch. vs. JSON*. Конфигурация наследует `mingw_w64` среду и использует ее `INCLUDE` свойство, чтобы указать значение для `includePath`. `Mingw64` При необходимости можно добавить другие пути к этому свойству массива.

> [!WARNING]
> В настоящее время существует известная ошибка, при `INCLUDE` которой значение, `environments` указанное в, неверно передается `includePath` свойству. Эту ошибку можно обойти, добавив Полный литерал include `includePath` в массив.

Для `intelliSenseMode` свойства задано значение, подходящее для GCC. Дополнительные сведения о всех этих свойствах см. в разделе [Справочник по схеме CppProperties](cppproperties-schema-reference.md).

Когда все работает правильно, вы увидите IntelliSense из заголовков GCC при наведении указателя мыши на тип:

![GCC IntelliSense](media/gcc-intellisense.png)

## <a name="enable-intellisense-diagnostics"></a>Включить диагностику IntelliSense

Если вы не видите нужный IntelliSense, можно устранить неполадки, выбрав **Сервис** > **Параметры** > **текстовый редактор** >  > **C/C++** **Дополнительно** и Установите для параметра **включить ведение журнала** **значение true**. Чтобы начать, установите для параметра **уровень ведения журнала** значение 5 и **фильтры ведения журнала** — до 8.

![Ведение журналов диагностики](media/diagnostic-logging.png)

Выходные данные передаются в **окно вывода** и отображаются при выборе **Показать выходные данные из: C++ Визуальный*журнал. Выходные данные содержат, помимо прочего, список фактических путей включения, которые IntelliSense пытается использовать. Если пути не совпадают с этими путями в *CppProperties. JSON*, попробуйте закрыть папку и удалить подпапку *. VS* , которая содержит кэшированные данные обзора.

### <a name="define-build-tasks-with-tasksvsjson"></a>Определение задач сборки в файле tasks.vs.json

Вы можете автоматизировать скрипты сборки и любые внешние операции с файлами, размещенными в текущей рабочей области, запуская их как задачи в интегрированной среде разработки. Чтобы настроить новую задачу, щелкните правой кнопкой мыши нужный файл или папку и выберите **Настройка задач**.

![Настройка задач "Открыть папку"](media/configure-tasks.png)

Это приведет к созданию (или открытию) файла *tasks. vs. JSON* в папке. VS, которую Visual Studio создает в корневой папке проекта. Можно определить в этом файле любую произвольную задачу, а затем вызывать ее из контекстного меню **обозревателя решений**. Чтобы продолжить пример с GCC, в следующем фрагменте кода показан полный файл *tasks. vs. JSON* с единой задачей, которая вызывает *g + +. exe* для построения проекта. Предположим, проект содержит один файл с именем *Hello. cpp*.

```json
{
  "version": "0.2.1",
  "tasks": [
    {
      "taskLabel": "build hello",
      "appliesTo": "/",
      "type": "default",
      "command": "g++",
      "args": [
        "-g",
        "-o",
        "hello",
        "hello.cpp"
      ]
    }
  ]
}

```

JSON-файл помещается в вложенную папку *. VS* , которую можно увидеть, нажав кнопку **Показать все файлы** в верхней части **Обозреватель решений**. Чтобы запустить эту задачу, щелкните правой кнопкой мыши корневой узел в **Обозреватель решений** и выберите команду **собрать Hello**. После завершения задачи вы увидите новый файл *Hello. exe* в **Обозреватель решений**.

Можно определить множество типов задач. В следующем примере показан *файл Tasks. vs. JSON* , который определяет одну задачу. `taskLabel` определяет имя, отображаемое в контекстном меню. `appliesTo` определяет, для каких файлов можно выполнить эту команду. Свойство ссылается на переменную среды ComSpec, которая определяет путь для консоли (*cmd. exe* в Windows). `command` Вы также можете ссылаться на переменные среды, объявленные в CppProperties.json или CMakeSettings.json. Свойство `args` определяет вызываемую командную строку. Макрос `${file}` передает выбранный файл в **обозреватель решений**. Приведенный ниже пример отображает имя для выбранного в этот момент CPP-файла.

```json
{
  "version": "0.2.1",
  "tasks": [
    {
      "taskLabel": "Echo filename",
      "appliesTo": "*.cpp",
      "type": "command",
      "command": "${env.COMSPEC}",
      "args": ["echo ${file}"]
    }
  ]
}
```

После сохранения *tasks. vs. JSON*можно щелкнуть правой кнопкой мыши любой *cpp* -файл в папке, выбрать **echo filename** в контекстном меню и увидеть имя файла, отображаемое в окне Вывод.

Дополнительные сведения см. в разделе [Справочник по схеме Tasks.vs.json](tasks-vs-json-schema-reference-cpp.md).

### <a name="configure-debugging-parameters-with-launchvsjson"></a>Настройка параметров отладки с помощью launch.vs.json

Чтобы настроить аргументы командной строки программы и инструкции по отладке, щелкните правой кнопкой мыши исполняемый файл в **Обозреватель решений** и выберите **параметры отладки и запуска**. При этом откроется существующий файл *Launch. vs. JSON* или, если он не существует, будет создан новый файл с набором минимальных параметров запуска. Сначала вам нужно выбрать тип сеанса отладки, который вы хотите настроить. Для отладки проекта MinGw-W64 мы выбираем **CC++ /Launch для минггв/Cygwin (GDB)** . При этом создается конфигурация запуска для использования *gdb. exe* с некоторыми обученными предположения о значениях по умолчанию. Одно из этих значений по умолчанию — `MINGW_PREFIX`. Вы можете заменить литеральный путь (как показано ниже) или определить `MINGW_PREFIX` свойство в *CppProperties. JSON*:

```json
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "cppdbg",
      "name": "hello.exe",
      "project": "hello.exe",
      "cwd": "${workspaceRoot}",
      "program": "${debugInfo.target}",
      "MIMode": "gdb",
      "miDebuggerPath": "c:\\msys64\\usr\\bin\\gdb.exe",
      "externalConsole": true
    }
  ]
}

```

Чтобы начать отладку, выберите исполняемый файл в раскрывающемся списке Отладка, а затем щелкните зеленую стрелку:

![Запустить отладчик](media/launch-debugger-gdb.png)

Вы должны увидеть диалоговое окно " **Инициализация отладчика** ", а затем внешнее окно консоли, в котором выполняется программа.

Дополнительные сведения см. в разделе [Справочник по схеме Launch. vs. JSON](launch-vs-schema-reference-cpp.md).

## <a name="launching-other-executables"></a>Запуск других исполняемых файлов

Можно определить параметры запуска для любого исполняемого файла на компьютере. В следующем примере запускается *7za* и указываются дополнительные аргументы, которые добавляются в `args` массив JSON:

```json
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "default",
      "project": "CPP\\7zip\\Bundles\\Alone\\O\\7za.exe",
      "name": "7za.exe list content of helloworld.zip",
      "args": [ "l", "d:\\sources\\helloworld.zip" ]
    }
  ]
}
```

Когда вы сохраняете этот файл, новая конфигурация отображается в раскрывающемся списке "Цель отладки". Вы можете выбрать ее, чтобы запустить отладчик. Можно создать любое количество конфигураций отладки для любого количества исполняемых файлов. Нажатие клавиши **F5** запускает отладчик, который будет останавливаться на всех заданных точках останова. Все обычные окна отладчика и их функции теперь доступны.

::: moniker-end
