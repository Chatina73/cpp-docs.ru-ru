---
title: x64 программные соглашения
ms.date: 12/17/2018
helpviewer_keywords:
- x64 coding conventions
- Visual C++, x64 calling conventions
ms.assetid: 750f3d97-1706-4840-b2fc-41a007329a08
ms.openlocfilehash: 11d29b6c31ccecfe5b9c51c2f9311213bd4a6732
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62313859"
---
# <a name="x64-software-conventions"></a>x64 программные соглашения

В этом разделе описываются C++, методология соглашения о вызовах для x64, расширение x86, 64-разрядной архитектуры.

## <a name="overview-of-x64-calling-conventions"></a>Общие сведения о соглашениях о вызовах x64

Два важных отличия между x86 и x64 является возможность адресации 64-разрядных и плоский набор 16 64-битных регистров общего назначения. Имея набор развернутой регистров, использует x64 [__fastcall](../cpp/fastcall.md) соглашение о вызовах и модель обработки исключений RISC-архитектуры. `__fastcall` Соглашение использует регистры для первых четырех аргументов и кадр стека для передачи дополнительных аргументов. Для параметров стека сведения в x64, соглашение о вызовах, включая использование регистра, возвращают значения, а также освобождение стека, см. в разделе [x64 соглашение о вызовах](x64-calling-convention.md).

## <a name="enable-optimization-for-x64"></a>Включить оптимизацию для x64

Следующий параметр компилятора помогает оптимизировать приложение для x64:

- [/favor (оптимизация для особенностей архитектуры)](../build/reference/favor-optimize-for-architecture-specifics.md)

## <a name="types-and-storage"></a>Типы и хранилище

В этом разделе описываются перечисления и хранения типов данных для x64 архитектуры.

### <a name="scalar-types"></a>скалярные типы

Несмотря на то, что имеется возможность доступа к данным с любого выравнивание, рекомендуется Выровнять данные в его естественную границу, или некоторые несколько, чтобы избежать потери производительности. Перечисления являются целочисленных констант и обрабатываются как 32-разрядных целых чисел. В следующей таблице описаны определения типа и рекомендуется для хранения данных, как в случае выравнивания, с помощью следующих значений:

- Byte - 8 бит

- Word - 16 бит

- Двойное - 32 бита

- Quadword - 64 бита

- Octaword - 128 бит

|||||
|-|-|-|-|
|Скалярный тип|Тип данных C|Размер хранилища (в байтах)|Рекомендуемое выравнивание|
|**INT8**|**char**|1|Byte|
|**UINT8**|**unsigned char**|1|Byte|
|**INT16**|**short**|2|Слово|
|**UINT16**|**unsigned short**|2|Слово|
|**INT32**|**int**, **long**|4|Двойное|
|**UINT32**|**целое число без знака, long без знака**|4|Двойное|
|**INT64**|**__int64**|8|Quadword|
|**UINT64**|**unsigned __int64**|8|Quadword|
|**FP32 (одинарная точность)**|**float**|4|Двойное|
|**FP64 (двойная точность)**|**double**|8|Quadword|
|**УКАЗАТЕЛЬ**|__\*__|8|Quadword|
|**__m64**|**__m64 структуры**|8|Quadword|
|**__m128**|**struct __m128**|16|Octaword|

### <a name="aggregates-and-unions"></a>Статические выражения и объединения

Другие типы, такие как массивы, структуры и объединения, имеют более строгие требования к выравниванию, обеспечивающие согласованную статистических функций и объединения хранения и извлечения данных. Ниже приведены определения массива, структуры и объединения.

- Массив

   Содержит упорядоченную группу смежных объектов данных. Каждый объект вызывается *элемент*. Все элементы массива имеют одинаковый тип размера и данных.

- Структура

   Содержит упорядоченную группу объектов данных. В отличие от элементов массива объекты данных в структуре может иметь различные типы данных и размеры. Каждый объект данных в структуре называется *член*.

- Объединение

   Объект, содержащий любое из набора именованных элементов. Члены именованного набора могут быть любого типа. Хранилище, выделенное для объединения равно хранилище, необходимое для наибольшего члена объединения, а также заполнение, необходимое для выравнивания.

В следующей таблице показаны строгие рекомендации по выравниванию для скалярных членов объединений и структур.

||||
|-|-|-|
|Скалярный тип|Тип данных C|Обязательное выравнивание.|
|**INT8**|**char**|Byte|
|**UINT8**|**unsigned char**|Byte|
|**INT16**|**short**|Слово|
|**UINT16**|**unsigned short**|Слово|
|**INT32**|**int**, **long**|Двойное|
|**UINT32**|**целое число без знака, long без знака**|Двойное|
|**INT64**|**__int64**|Quadword|
|**UINT64**|**unsigned __int64**|Quadword|
|**FP32 (одинарная точность)**|**float**|Двойное|
|**FP64 (двойная точность)**|**double**|Quadword|
|**УКАЗАТЕЛЬ**|<strong>\*</strong>|Quadword|
|**__m64**|**__m64 структуры**|Quadword|
|**__m128**|**struct __m128**|Octaword|

Применяются следующие правила выравнивания статистических выражений.

- Выравнивание массива выполняется так же, как выравнивание один из элементов массива.

- Тип выравнивания начала структуры или объединения является максимальным выравниванием любого отдельного члена. Каждому члену структуры или объединения должны размещаться в его правильное выравнивание, как определено в предыдущей таблице, может потребоваться неявное внутреннее заполнение в зависимости от предыдущего члена.

- Размер структуры должен быть целым числом, кратным его выравнивания, чего может потребоваться заполнение после последнего элемента. Так как структуры и объединения могут быть сгруппированы в массивы, каждый элемент массива, структуры или объединения должен начинаются и заканчиваются на ранее определить правильное выравнивание.

- Это возможно, выравнивание данных таким образом, быть больше, чем требований к выравниванию, до тех пор, пока ранее установленных правил.

- Отдельный компилятор может регулировать упаковку структуры по причинам размер. Например [/Zp (выравнивание членов структур)](../build/reference/zp-struct-member-alignment.md) позволяет для подгонки упаковки структур.

### <a name="examples-of-structure-alignment"></a>Примеры выравнивания структуры

Следующие четыре примера каждого объявите выровненные структуры или объединения и соответствующих показателей проиллюстрировать макет структуры или объединения в памяти. Каждый столбец на рисунке представляет байт памяти, а число в столбце указывает смещение, байтов. Имя во второй строке каждом рисунке соответствует имени переменной в объявлении. Затененные столбцы определяют заполнение, необходимое для достижения указанное выравнивание.

#### <a name="example-1"></a>Пример 1

```C
// Total size = 2 bytes, alignment = 2 bytes (word).

_declspec(align(2)) struct {
    short a;      // +0; size = 2 bytes
}
```

![Пример 1. Структура AMD преобразование макета](../build/media/vcamd_conv_ex_1_block.png "структуре пример 1 преобразования AMD")

#### <a name="example-2"></a>Пример 2

```C
// Total size = 24 bytes, alignment = 8 bytes (quadword).

_declspec(align(8)) struct {
    int a;       // +0; size = 4 bytes
    double b;    // +8; size = 8 bytes
    short c;     // +16; size = 2 bytes
}
```

![Пример 2 структура AMD преобразование макета](../build/media/vcamd_conv_ex_2_block.png "структуре пример 2 преобразования AMD")

#### <a name="example-3"></a>Пример 3

```C
// Total size = 12 bytes, alignment = 4 bytes (doubleword).

_declspec(align(4)) struct {
    char a;       // +0; size = 1 byte
    short b;      // +2; size = 2 bytes
    char c;       // +4; size = 1 byte
    int d;        // +8; size = 4 bytes
}
```

![Пример 2 структура AMD преобразование макета](../build/media/vcamd_conv_ex_3_block.png "структуре пример 2 преобразования AMD")

#### <a name="example-4"></a>Пример 4

```C
// Total size = 8 bytes, alignment = 8 bytes (quadword).

_declspec(align(8)) union {
    char *p;      // +0; size = 8 bytes
    short s;      // +0; size = 2 bytes
    long l;       // +0; size = 4 bytes
}
```

![Layouit объединения 4 пример преобразования AMD](../build/media/vcamd_conv_ex_4_block.png "layouit объединения 4 пример преобразования AMD")

### <a name="bitfields"></a>Разряды

Структура битовых полей ограничен 64 бита и может иметь тип автоматический int, int без знака, int64 или int64 без знака. Битовые поля, которые пересекают границу типа будет пропускать биты, чтобы выровнять битовое поле, чтобы далее выравнивание типа. Например целое число битовые поля не может пересекаться с 32-разрядную границу.

### <a name="conflicts-with-the-x86-compiler"></a>Конфликтует с x86 компилятора

Типы данных, размер которых больше, чем 4 байта автоматически не выравниваются в стеке при использовании x86 компилятору выполнять компиляцию приложения. Так как архитектура x86 компилятора является выровненного стека размером 4 байта, размер которых превышает 4 байта, например, 64-разрядное целое число, ничего не может автоматически выровнен по 8 байтам адреса.

Работа с данными без выравнивания имеет два ограничения.

- Он может занять больше времени для доступа к невыровненным расположениям, чем для доступа к выровненные расположениям.

- Невыровненные расположения не может использоваться в блокируемые операции.

Если требуется более строгий выравнивание, используйте `__declspec(align(N))` в объявлениях переменных. В этом случае компилятор динамически выравнивать стек в соответствии с вашими характеристиками. Тем не менее динамически настройку стека во время выполнения может привести к более медленному выполнению приложения.

## <a name="register-usage"></a>Использование регистров

X64 архитектура предоставляет 16 регистров общего назначения (которые далее называются целочисленными регистрами), а также 16 регистров XMM/YMM регистрирует для значений с плавающей запятой. Переменные регистры — это оперативные регистры, которые вызывающий объект считает очищаемыми во время вызова. Неизменяемые регистры должны сохранять свое значение во время вызова функции и при использовании должны сохраняться вызываемым объектом.

### <a name="register-volatility-and-preservation"></a>Регистрация волатильности и сохранение

Следующая таблица описывает использование каждого из регистров в вызовах функций.

||||
|-|-|-|
|Регистровое|Status|Использовать|
|RAX|Переменный|Регистр возвращаемого значения|
|RCX|Переменный|Первый целочисленный аргумент|
|RDX|Переменный|Второй целочисленный аргумент|
|R8|Переменный|Третий целочисленный аргумент|
|R9|Переменный|Четвертый целочисленный аргумент|
|R10:R11|Переменный|Должен сохраняться вызывающим объектом; используется в инструкциях syscall/sysret.|
|R12:R15|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RDI|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RSI|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RBX|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RBP|Неизменяемый|Может использоваться в качестве указателя фрейма; должен сохраняться вызываемым объектом.|
|RSP|Неизменяемый|Указатель стека|
|XMM0, YMM0|Переменный|Первый аргумент FP; первый аргумент векторного типа при использовании `__vectorcall`|
|XMM1, YMM1|Переменный|Второй аргумент FP; второй аргумент векторного типа при использовании `__vectorcall`|
|XMM2, YMM2|Переменный|Третий аргумент FP; третий аргумент векторного типа при использовании `__vectorcall`|
|XMM3, YMM3|Переменный|Четвертый аргумент FP; четвертый аргумент векторного типа при использовании `__vectorcall`|
|XMM4, YMM4|Переменный|Должен сохраняться вызывающим объектом; пятый аргумент векторного типа при использовании `__vectorcall`.|
|XMM5, YMM5|Переменный|Должен сохраняться вызывающим объектом; шестой аргумент векторного типа при использовании `__vectorcall`.|
|XMM6:XMM15, YMM6:YMM15|Неизменяемый (XMM), переменный (верхняя половина YMM)|Должен сохраняться вызываемым объектом. Регистры YMM должны сохраняться вызывающим объектом.|

На выходе из функции и на запись функции к вызовы библиотеки времени выполнения C и вызовы системы Windows, флаг направления в ЦП register флаги ожидается для очистки.

## <a name="stack-usage"></a>Использование стека

Дополнительные сведения о выделение памяти в стеке, выравнивание, типы функций и кадры стека в x64, см. в разделе [x64 стека использования](stack-usage.md).

## <a name="prolog-and-epilog"></a>Пролог и эпилог

Каждой функции, которая выделяет пространство стека, вызывает другие функции, сохраняет неизменяемые регистры или используется структурная обработка исключений должен иметь пролога, адрес ограничения описаны в очистки данных, связанных с соответствующей функции записи в таблице и эпилога в каждого выхода в функции. Сведения о необходимых пролога и эпилога код в x64, см. в разделе [x64 пролога и эпилога](prolog-and-epilog.md).

## <a name="x64-exception-handling"></a>x64 обработки исключений

Сведения о соглашения и структур данных, используемый для реализации структурированной обработки исключений и поведения в x64 обработки исключений C++, см. в разделе [x64 обработки исключений](exception-handling-x64.md).

## <a name="intrinsics-and-inline-assembly"></a>Встроенные функции и встроенные сборки

Одно из ограничений для x64 компилятора желательно использовать не поддерживает встроенный ассемблер. Это означает, что функции, не может быть написаны на C или C++, должны записываться в виде подпрограмм или встроенных функций, поддерживаемых компилятором. Некоторые функции, чувствительны к производительности, а другие нет. Функции, чувствительные к производительности должны быть реализованы как встроенные функции.

Компилятор поддерживает встроенные функции описаны в [встроенные объекты компилятора](../intrinsics/compiler-intrinsics.md).

## <a name="image-format"></a>Формат изображения

X64 формата исполняемого образа используется PE32 +. Исполняемые образы (DLL или exe) ограничены максимальным размером 2 гигабайта, поэтому относительный адресация с 32-разрядное смещение можно использовать для решения данных статическое изображение. Эти данные включают таблицы адресов импорта, строковые константы, глобальные статические данные и т. д.

## <a name="see-also"></a>См. также

[Соглашения о вызовах](../cpp/calling-conventions.md)
