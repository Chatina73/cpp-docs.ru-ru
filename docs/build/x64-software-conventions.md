---
title: Программные соглашения для 64-разрядных систем
ms.date: 12/17/2018
helpviewer_keywords:
- x64 coding conventions
- Visual C++, x64 calling conventions
ms.assetid: 750f3d97-1706-4840-b2fc-41a007329a08
ms.openlocfilehash: 4755cfcf98c9eadbd944e06a56f86ca89a33b0a3
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87223776"
---
# <a name="x64-software-conventions"></a>Программные соглашения для 64-разрядных систем

В этом разделе описывается методология соглашения о вызовах в C++ для x64, 64-разрядного расширения архитектуры x86.

## <a name="overview-of-x64-calling-conventions"></a>Общие сведения о соглашениях о вызовах для архитектуры x64

Двумя важными различиями между архитектурами x86 и x64 являются возможность 64-разрядной адресации и неструктурированный набор из 16 64-разрядных регистров общего назначения. Учитывая расширенный набор регистров, архитектура x64 использует соглашение о вызовах [__fastcall](../cpp/fastcall.md) и модель обработки исключений на основе RISC. Соглашение **`__fastcall`** использует регистры для первых четырех аргументов и кадр стека для передачи дополнительных аргументов. Подробные сведения о соглашении о вызовах x64, в том числе об использовании регистров, параметрах стека, возвращаемых значениях и раскрутке стека, см. в статье [Соглашение о вызовах x64](x64-calling-convention.md).

## <a name="enable-optimization-for-x64"></a>Включение оптимизации для x64

Следующий параметр компилятора позволяет оптимизировать приложение для архитектуры x64:

- [/favor (оптимизация для особенностей архитектуры)](../build/reference/favor-optimize-for-architecture-specifics.md)

## <a name="types-and-storage"></a>Типы данных и их хранение

В этом разделе перечисляются типы данных в архитектуре x64 и занимаемое ими место.

### <a name="scalar-types"></a>Скалярные типы

Несмотря на возможность доступа к данным с любым выравниванием, рекомендуется выравнивать данные по естественной границе или кратной ей границе, чтобы избежать снижения производительности. Перечисления — это целочисленные константы, которые обрабатываются как 32-разрядные целые числа. В таблице ниже представлены определения типов и рекомендуемое место для хранения данных при использовании следующих значений выравнивания:

- байт — 8 битов;

- слово — 16 битов;

- двойное слово — 32 бита;

- учетверенное слово — 64 бита;

- увосьмеренное слово — 128 битов.

|||||
|-|-|-|-|
|Скалярный тип|Тип данных в C|Занимаемое место в памяти (в байтах)|Рекомендуемое выравнивание|
|**INT8**|**`char`**|1|Byte|
|**UINT8**|**`unsigned char`**|1|Byte|
|**INT16**|**`short`**|2|Слово|
|**UINT16**|**`unsigned short`**|2|Слово|
|**INT32**|**`int`** , **`long`**|4|Двойное слово|
|**UINT32**|**unsigned int, unsigned long**|4|Двойное слово|
|**INT64**|**`__int64`**|8|Учетверенное слово|
|**UINT64**|**unsigned __int64**|8|Учетверенное слово|
|**FP32 (одиночная точность)**|**`float`**|4|Двойное слово|
|**FP64 (двойная точность)**|**`double`**|8|Учетверенное слово|
|**POINTER**|__\*__|8|Учетверенное слово|
|**`__m64`**|**struct __m64**|8|Учетверенное слово|
|**`__m128`**|**struct __m128**|16|Увосьмеренное слово|

### <a name="aggregates-and-unions"></a>Статические выражения и объединения

Другие типы, такие как массивы, структуры и объединения, предъявляют более строгие требования к выравниванию, обеспечивающие согласованное извлечение статических выражений и объединений. Ниже приведены определения для массивов, структур и объединений.

- Массив

   Содержит упорядоченную группу смежных объектов данных. Каждый объект называется *элементом*. Все элементы массива имеют одинаковый размер и тип данных.

- structure

   Содержит упорядоченную группу объектов данных. В отличие от элементов массива, объекты данных в структуре могут иметь разные типы данных и размеры. Каждый объект данных в структуре называется *элементом*.

- Объединение

   Объект, содержащий любой из наборов именованных элементов. Элементы именованного набора могут быть любого типа. Объем памяти, выделяемый для объединения, равен объему памяти, необходимому для хранения наибольшего его элемента, к которому прибавляется заполнение, требуемое для выравнивания.

В приведенной ниже таблице показано настоятельно рекомендуемое выравнивание для скалярных элементов объединений и структур.

||||
|-|-|-|
|Скалярный тип|Тип данных в C|Требуемое выравнивание|
|**INT8**|**`char`**|Byte|
|**UINT8**|**`unsigned char`**|Byte|
|**INT16**|**`short`**|Word|
|**UINT16**|**`unsigned short`**|Слово|
|**INT32**|**`int`** , **`long`**|Двойное слово|
|**UINT32**|**unsigned int, unsigned long**|Двойное слово|
|**INT64**|**`__int64`**|Учетверенное слово|
|**UINT64**|**unsigned __int64**|Учетверенное слово|
|**FP32 (одиночная точность)**|**`float`**|Двойное слово|
|**FP64 (двойная точность)**|**`double`**|Учетверенное слово|
|**POINTER**|<strong>\*</strong>|Учетверенное слово|
|**`__m64`**|**struct __m64**|Учетверенное слово|
|**`__m128`**|**struct __m128**|Увосьмеренное слово|

В отношении выравнивания статистического выражения действуют следующие правила:

- Выравнивание массива совпадает с выравниванием одного из его элементов.

- Выравнивание начала структуры или объединения соответствует максимальному выравниванию любого отдельного элемента. Каждый элемент структуры или объединения должен быть правильно выровнен в соответствии с приведенной выше таблицей, для чего может потребоваться неявное внутреннее заполнение в зависимости от предыдущего элемента.

- Размер структуры должен быть кратен ее выравниванию, для чего может потребоваться заполнение после последнего элемента. Так как структуры и объединения могут объединяться в массивы, каждый элемент массива, представляющий собой структуру или объединение, должен начинаться и заканчиваться в ранее определенной позиции выравнивания.

- Данные можно выравнивать с превышением требований к выравниванию при условии, что предыдущие правила соблюдаются.

- Отдельный компилятор может настроить упаковку структуры с целью ограничения ее размера. Например, [/Zp (выравнивание члена структуры)](../build/reference/zp-struct-member-alignment.md) позволяет настраивать упаковку структур.

### <a name="examples-of-structure-alignment"></a>Примеры выравнивания структуры

В каждом из приведенных ниже четырех примеров объявляется выровненная структура или выровненное объединение, а на соответствующих рисунках показано размещение структуры или объединения в памяти. Каждый столбец на рисунке представляет байт памяти, а число в столбце соответствует смещению этого байта. Имя во второй строке на каждом рисунке соответствует имени переменной в объявлении. Затененные столбцы обозначают заполнение, необходимое для обеспечения указанного выравнивания.

#### <a name="example-1"></a>Пример 1

```C
// Total size = 2 bytes, alignment = 2 bytes (word).

_declspec(align(2)) struct {
    short a;      // +0; size = 2 bytes
}
```

![Пример преобразования AMD 1: размещение структуры](../build/media/vcamd_conv_ex_1_block.png "Пример преобразования AMD 1: размещение структуры")

#### <a name="example-2"></a>Пример 2

```C
// Total size = 24 bytes, alignment = 8 bytes (quadword).

_declspec(align(8)) struct {
    int a;       // +0; size = 4 bytes
    double b;    // +8; size = 8 bytes
    short c;     // +16; size = 2 bytes
}
```

![Пример преобразования AMD 2: размещение структуры](../build/media/vcamd_conv_ex_2_block.png "Пример преобразования AMD 2: размещение структуры")

#### <a name="example-3"></a>Пример 3

```C
// Total size = 12 bytes, alignment = 4 bytes (doubleword).

_declspec(align(4)) struct {
    char a;       // +0; size = 1 byte
    short b;      // +2; size = 2 bytes
    char c;       // +4; size = 1 byte
    int d;        // +8; size = 4 bytes
}
```

![Пример преобразования AMD 3: размещение структуры](../build/media/vcamd_conv_ex_3_block.png "Пример преобразования AMD 3: размещение структуры")

#### <a name="example-4"></a>Пример 4

```C
// Total size = 8 bytes, alignment = 8 bytes (quadword).

_declspec(align(8)) union {
    char *p;      // +0; size = 8 bytes
    short s;      // +0; size = 2 bytes
    long l;       // +0; size = 4 bytes
}
```

![Пример преобразования AMD 4: размещение объединения](../build/media/vcamd_conv_ex_4_block.png "Пример преобразования AMD 4: размещение объединения")

### <a name="bitfields"></a>Разряды

Битовые поля структуры ограничены 64 битами и могут иметь тип signed int, unsigned int, int64 или unsigned int64. При пересечении границы типа битовыми полями будут пропускаться биты для выравнивания поля по следующей границе. Например, битовые поля типа integer не могут пересекать границу в 32 бита.

### <a name="conflicts-with-the-x86-compiler"></a>Конфликты с компилятором x86

Типы данных размером более 4 байт не выравниваются в стеке автоматически при использовании компилятора x86 для компиляции приложения. Так как архитектура компилятора x86 представляет собой 4-байтовый выровненный стек, то все типы больше 4 байт, например 64-разрядные целые числа, не могут автоматически выравниваться по 8-байтовому адресу.

Работа с невыровненными данными имеет два последствия.

- Доступ к невыровненным данным может осуществляться медленнее, чем к выровненным.

- Невыровненные расположения нельзя использовать в блокируемых операциях.

Если требуется более строгое выравнивание, используйте `__declspec(align(N))` в объявлениях переменных. В результате компилятор будет динамически выравнивать стек в соответствии с вашими спецификациями. Однако динамическая настройка стека во время выполнения может привести к более медленному выполнению приложения.

## <a name="register-usage"></a>Использование регистров

Архитектура x64 предоставляет 16 регистров общего назначения (которые далее называются целочисленными регистрами), а также 16 регистров XMM/YMM для значений с плавающей запятой. Переменные регистры — это оперативные регистры, которые вызывающий объект считает очищаемыми во время вызова. Неизменяемые регистры должны сохранять свое значение во время вызова функции и при использовании должны сохраняться вызываемым объектом.

### <a name="register-volatility-and-preservation"></a>Изменчивость и сохранение регистров

Следующая таблица описывает использование каждого из регистров в вызовах функций.

||||
|-|-|-|
|Регистровое|Status|Использовать|
|RAX|Переменный|Регистр возвращаемого значения|
|RCX|Переменный|Первый целочисленный аргумент|
|RDX|Переменный|Второй целочисленный аргумент|
|R8|Переменный|Третий целочисленный аргумент|
|R9|Переменный|Четвертый целочисленный аргумент|
|R10:R11|Переменный|Должен сохраняться вызывающим объектом; используется в инструкциях syscall/sysret.|
|R12:R15|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RDI|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RSI|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RBX|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RBP|Неизменяемый|Может использоваться в качестве указателя фрейма; должен сохраняться вызываемым объектом.|
|RSP|Неизменяемый|Указатель стека|
|XMM0, YMM0|Переменный|Первый аргумент FP; первый аргумент векторного типа при использовании **`__vectorcall`**|
|XMM1, YMM1|Переменный|Второй аргумент FP; второй аргумент векторного типа при использовании **`__vectorcall`**|
|XMM2, YMM2|Переменный|Третий аргумент FP; третий аргумент векторного типа при использовании **`__vectorcall`**|
|XMM3, YMM3|Переменный|Четвертый аргумент FP; четвертый аргумент векторного типа при использовании **`__vectorcall`**|
|XMM4, YMM4|Переменный|Должен сохраняться вызывающим объектом; пятый аргумент векторного типа при использовании **`__vectorcall`**|
|XMM5, YMM5|Переменный|Должен сохраняться вызывающим объектом; шестой аргумент векторного типа при использовании **`__vectorcall`**|
|XMM6:XMM15, YMM6:YMM15|Неизменяемый (XMM), переменный (верхняя половина YMM)|Должен сохраняться вызываемым объектом. Регистры YMM должны сохраняться вызывающим объектом.|

При выходе из функций и входе функций в вызовы библиотеки времени выполнения C и системные вызовы Windows флаг направления в регистре флагов ЦП должен сбрасываться.

## <a name="stack-usage"></a>Использование стека

Подробные сведения о выделении стека, выравнивании, типах функций и кадрах стека в архитектуре x64 см. в статье [Использование стека для 64-разрядных систем](stack-usage.md).

## <a name="prolog-and-epilog"></a>Пролог и эпилог

Каждая функция, которая выделяет пространство стека, вызывает другие функции, сохраняет энергонезависимые регистры или использует обработку исключений, должна содержать пролог с ограничениями адресов, описанными в данных очистки, связанных с соответствующей записью таблицы функций, и эпилоги при каждом выходе из функции. Подробные сведения о необходимом коде пролога и эпилога в архитектуре x64 см. в статье [Пролог и эпилог для 64-разрядных систем](prolog-and-epilog.md).

## <a name="x64-exception-handling"></a>Обработка исключений в 64-разрядных системах

Сведения о соглашениях и структурах данных для реализации структурированной обработки исключений и обработки исключений C++ в архитектуре x64 см. в статье [Обработка исключений в 64-разрядных системах](exception-handling-x64.md).

## <a name="intrinsics-and-inline-assembly"></a>Внутренний и подставляемый ассемблерный код

Одним из ограничений для компилятора x64 является отсутствие поддержки встроенного ассемблера. Это означает, что функции, которые нельзя написать на языке C или C++, должны создаваться как подпрограммы или как встроенные функции, поддерживаемые компилятором. Для некоторых функций производительность важна, а для других нет. Функции, для которых производительность важна, должны реализовываться как встроенные.

Встроенные функции, поддерживаемые компилятором, описываются в разделе [Встроенные инструкции компилятора](../intrinsics/compiler-intrinsics.md).

## <a name="image-format"></a>Формат образа

Формат исполняемого образа x64 — PE32+. Размер исполняемых образов (как DLL, так и EXE) ограничен 2 гигабайтами, поэтому для адресации статических данных образов можно использовать относительную адресацию с 32-битным смещением. Эти данные включают в себя таблицу адресов импорта, строковые константы, статические глобальные данные и т. д.

## <a name="see-also"></a>См. также

[Соглашения о вызовах](../cpp/calling-conventions.md)
