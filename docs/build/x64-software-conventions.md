---
title: Программные соглашения для 64-разрядных систем
ms.date: 12/17/2018
helpviewer_keywords:
- x64 coding conventions
- Visual C++, x64 calling conventions
ms.assetid: 750f3d97-1706-4840-b2fc-41a007329a08
ms.openlocfilehash: 11d29b6c31ccecfe5b9c51c2f9311213bd4a6732
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78865604"
---
# <a name="x64-software-conventions"></a>Программные соглашения для 64-разрядных систем

В этом разделе описывается C++ методология соглашения о вызовах для x64, 64-разрядного расширения для архитектуры x86.

## <a name="overview-of-x64-calling-conventions"></a>Общие сведения о соглашениях о вызовах x64

Двумя важными различиями между x86 и x64 являются возможность 64-разрядной адресации и неструктурированный набор 16 64-разрядных регистров для общего использования. Учитывая расширенный набор регистров, x64 использует соглашение о вызове [__fastcall](../cpp/fastcall.md) и модель обработки исключений на основе RISC. Соглашение `__fastcall` использует регистры для первых четырех аргументов и кадр стека для передачи дополнительных аргументов. Дополнительные сведения о соглашении о вызовах x64, включая использование регистров, параметры стека, возвращаемые значения и раскрутку стека, см. в разделе [соглашение о вызовах x64](x64-calling-convention.md).

## <a name="enable-optimization-for-x64"></a>Включить оптимизацию для x64

Следующий параметр компилятора позволяет оптимизировать приложение для x64:

- [/favor (оптимизация для особенностей архитектуры)](../build/reference/favor-optimize-for-architecture-specifics.md)

## <a name="types-and-storage"></a>Типы и хранилище

В этом разделе описывается перечисление и хранение типов данных для архитектуры x64.

### <a name="scalar-types"></a>Скалярные типы

Несмотря на возможность доступа к данным с любым выравниванием, рекомендуется выравнивать данные на своей естественной границе или в нескольких случаях, чтобы избежать потери производительности. Перечисления — это константные целые числа, которые обрабатываются как 32-разрядные целые числа. В следующей таблице описывается определение типа и рекомендуемое хранилище для данных по мере их выравнивания с использованием следующих значений выравнивания:

- Байт-8 бит

- Word-16 бит

- Даублеворд-32 бит

- Куадворд-64 бит

- Октаворд-128 бит

|||||
|-|-|-|-|
|Скалярный тип|Тип данных C|Размер хранилища (в байтах)|Рекомендуемое выравнивание|
|**INT8**|**char**|1|Byte|
|**UINT8**|**unsigned char**|1|Byte|
|**INT16**|**short**|2|Word|
|**UINT16**|**unsigned short**|2|Word|
|**ТИПА**|**int**, **Long**|4|даублеворд|
|**ЗНАЧЕНИЕМ**|**целое число без знака, длинное без знака**|4|даублеворд|
|**INT64**|**__int64**|8|куадворд|
|**UINT64**|**unsigned __int64**|8|куадворд|
|**FP32 (одиночная точность)**|**float**|4|даублеворд|
|**FP64 (двойная точность)**|**double**|8|куадворд|
|**ВИД**|__\*__|8|куадворд|
|**__m64**|**__m64 структуры**|8|куадворд|
|**__m128**|**__m128 структуры**|16|октаворд|

### <a name="aggregates-and-unions"></a>Агрегаты и объединения

Другие типы, такие как массивы, структуры и объединения, имеют более четкие требования к выравниванию, обеспечивающие согласованное агрегирование и извлечение данных. Ниже приведены определения для массивов, структур и объединений.

- Array

   Содержит упорядоченную группу смежных объектов данных. Каждый объект называется *элементом*. Все элементы в массиве имеют одинаковый размер и тип данных.

- Структура

   Содержит упорядоченную группу объектов данных. В отличие от элементов массива, объекты данных в структуре могут иметь разные типы данных и размеры. Каждый объект данных в структуре называется *элементом*.

- Union

   Объект, содержащий любой из наборов именованных элементов. Элементы именованного набора могут иметь любой тип. Хранилище, выделенное для объединения, равно объему хранилища, требуемому для самого крупного члена объединения, и любому заполнению, которое требуется для выравнивания.

В следующей таблице показано строго предложенное выравнивание для скалярных элементов объединений и структур.

||||
|-|-|-|
|Скалярный тип|Тип данных C|Требуемое выравнивание|
|**INT8**|**char**|Byte|
|**UINT8**|**unsigned char**|Byte|
|**INT16**|**short**|Word|
|**UINT16**|**unsigned short**|Word|
|**ТИПА**|**int**, **Long**|даублеворд|
|**ЗНАЧЕНИЕМ**|**целое число без знака, длинное без знака**|даублеворд|
|**INT64**|**__int64**|куадворд|
|**UINT64**|**unsigned __int64**|куадворд|
|**FP32 (одиночная точность)**|**float**|даублеворд|
|**FP64 (двойная точность)**|**double**|куадворд|
|**ВИД**|<strong>\*</strong>|куадворд|
|**__m64**|**__m64 структуры**|куадворд|
|**__m128**|**__m128 структуры**|октаворд|

Применяются следующие правила выравнивания статистического выражения.

- Выравнивание массива совпадает с выравниванием одного из элементов массива.

- Выравнивание начала структуры или объединения является максимальным выравниванием любого отдельного элемента. Каждый элемент в структуре или объединении должен быть правильно выровнен, как определено в предыдущей таблице, что может потребовать неявного внутреннего заполнения в зависимости от предыдущего элемента.

- Размер структуры должен быть кратен его выравниванию, что может потребовать заполнения после последнего элемента. Поскольку структуры и объединения могут быть сгруппированы в массивах, каждый элемент массива структуры или объединения должен начинаться и заканчиваться в соответствии с заранее определенным выравниванием.

- Можно выравнивать данные таким образом, чтобы они были больше, чем требования к выравниванию, при условии, что предыдущие правила сохраняются.

- Отдельный компилятор может настроить упаковку структуры по причинам размера. Например, [/Zp (выравнивание членов структуры)](../build/reference/zp-struct-member-alignment.md) позволяет настраивать упаковку структур.

### <a name="examples-of-structure-alignment"></a>Примеры выравнивания структуры

В следующих четырех примерах каждая из них объявляется с помощью согласованной структуры или объединения, а соответствующие фигуры иллюстрируют макет этой структуры или объединения в памяти. Каждый столбец на рисунке представляет байт памяти, а число в столбце указывает смещение этого байта. Имя во второй строке каждой фигуры соответствует имени переменной в объявлении. Затененные столбцы обозначают заполнение, необходимое для достижения указанного выравнивания.

#### <a name="example-1"></a>Пример 1

```C
// Total size = 2 bytes, alignment = 2 bytes (word).

_declspec(align(2)) struct {
    short a;      // +0; size = 2 bytes
}
```

![Пример преобразования AMD. Структура структуры 1](../build/media/vcamd_conv_ex_1_block.png "Пример преобразования AMD. Структура структуры 1")

#### <a name="example-2"></a>Пример 2

```C
// Total size = 24 bytes, alignment = 8 bytes (quadword).

_declspec(align(8)) struct {
    int a;       // +0; size = 4 bytes
    double b;    // +8; size = 8 bytes
    short c;     // +16; size = 2 bytes
}
```

![Пример преобразования AMD 2. Структура структуры](../build/media/vcamd_conv_ex_2_block.png "Пример преобразования AMD 2. Структура структуры")

#### <a name="example-3"></a>Пример 3

```C
// Total size = 12 bytes, alignment = 4 bytes (doubleword).

_declspec(align(4)) struct {
    char a;       // +0; size = 1 byte
    short b;      // +2; size = 2 bytes
    char c;       // +4; size = 1 byte
    int d;        // +8; size = 4 bytes
}
```

![Пример преобразования AMD 2. Структура структуры](../build/media/vcamd_conv_ex_3_block.png "Пример преобразования AMD 2. Структура структуры")

#### <a name="example-4"></a>Пример 4

```C
// Total size = 8 bytes, alignment = 8 bytes (quadword).

_declspec(align(8)) union {
    char *p;      // +0; size = 8 bytes
    short s;      // +0; size = 2 bytes
    long l;       // +0; size = 4 bytes
}
```

![Пример преобразования AMD 4. лайауит объединения](../build/media/vcamd_conv_ex_4_block.png "Пример преобразования AMD 4. лайауит объединения")

### <a name="bitfields"></a>Разряды

Битовые поля структуры ограничены 64 битами и могут иметь тип целое число со знаком, без знака int, Int64 или без знака Int64. Битовые поля, пересекающие границу типа, будут пропускать биты для выравнивания битовых битов до следующего выравнивания типа. Например, Integer битовых полей может не пересекать границу 32-bit.

### <a name="conflicts-with-the-x86-compiler"></a>Конфликтует с компилятором x86

Типы данных размером более 4 байт не выводятся автоматически в стеке при использовании компилятора x86 для компиляции приложения. Так как архитектура компилятора x86 является 4-байтовым стеком, то все больше 4 байт, например 64-разрядное целое число, не может быть автоматически выставляться по 8 байтам.

Работа с неровными данными имеет два последствия.

- Для доступа к расположениям с неупорядоченным расположением может потребоваться больше времени, чем для доступа к размещенным местам.

- Несогласованные расположения нельзя использовать в операциях с блокировкой.

Если требуется более жесткое выравнивание, используйте `__declspec(align(N))` в объявлениях переменных. Это приводит к тому, что компилятор динамически выровняйте стек в соответствии со своими спецификациями. Однако динамическая настройка стека во время выполнения может привести к более медленному выполнению приложения.

## <a name="register-usage"></a>Регистрация использования

Архитектура x64 обеспечивает 16 регистров общего назначения (в дальнейшем называемых целочисленными регистрами), а также 16 регистров XMM/ИММ, доступных для использования с плавающей точкой. Переменные регистры — это оперативные регистры, которые вызывающий объект считает очищаемыми во время вызова. Неизменяемые регистры должны сохранять свое значение во время вызова функции и при использовании должны сохраняться вызываемым объектом.

### <a name="register-volatility-and-preservation"></a>Регистрация изменчивости и сохранение

Следующая таблица описывает использование каждого из регистров в вызовах функций.

||||
|-|-|-|
|Зарегистрировать|Состояние|Использование|
|RAX|Переменный|Регистр возвращаемого значения|
|RCX|Переменный|Первый целочисленный аргумент|
|RDX|Переменный|Второй целочисленный аргумент|
|R8|Переменный|Третий целочисленный аргумент|
|R9|Переменный|Четвертый целочисленный аргумент|
|R10:R11|Переменный|Должен сохраняться вызывающим объектом; используется в инструкциях syscall/sysret.|
|R12:R15|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RDI|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RSI|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RBX|Неизменяемый|Должен сохраняться вызываемым объектом.|
|RBP|Неизменяемый|Может использоваться в качестве указателя фрейма; должен сохраняться вызываемым объектом.|
|RSP|Неизменяемый|Указатель стека|
|XMM0, YMM0|Переменный|Первый аргумент FP; первый аргумент векторного типа при использовании `__vectorcall`|
|XMM1, YMM1|Переменный|Второй аргумент FP; второй аргумент векторного типа при использовании `__vectorcall`|
|XMM2, YMM2|Переменный|Третий аргумент FP; третий аргумент векторного типа при использовании `__vectorcall`|
|XMM3, YMM3|Переменный|Четвертый аргумент FP; четвертый аргумент векторного типа при использовании `__vectorcall`|
|XMM4, YMM4|Переменный|Должен сохраняться вызывающим объектом; пятый аргумент векторного типа при использовании `__vectorcall`.|
|XMM5, YMM5|Переменный|Должен сохраняться вызывающим объектом; шестой аргумент векторного типа при использовании `__vectorcall`.|
|XMM6:XMM15, YMM6:YMM15|Неизменяемый (XMM), переменный (верхняя половина YMM)|Должен сохраняться вызываемым методом. Регистры YMM должны сохраняться вызывающим объектом.|

При выходе из функций и при вводе функции в вызовы библиотеки времени выполнения C и системных вызовах Windows флаг направления в регистре флагов ЦП должен быть сброшен.

## <a name="stack-usage"></a>Использование стека

Дополнительные сведения о выделении стека, выравнивании, типах функций и кадрах стека в x64 см. в разделе [Использование x64 Stack](stack-usage.md).

## <a name="prolog-and-epilog"></a>Пролог и эпилога

Каждая функция, которая выделяет пространство стека, вызывает другие функции, сохраняет неизменяемые регистры или использует обработку исключений, должна содержать Пролог, ограничения адресов которых описаны в данных очистки, связанных с соответствующей записью таблицы функций, и эпилоги в каждого выхода в функцию. Дополнительные сведения о необходимых прологах и коде эпилога на x64 см. в разделе [x64 Пролог и эпилога](prolog-and-epilog.md).

## <a name="x64-exception-handling"></a>Обработка исключений в 64-разрядных системах

Сведения о соглашениях и структурах данных, используемых для реализации структурированной обработки C++ исключений и поведения обработки исключений в x64, см. в разделе [обработка исключений x64](exception-handling-x64.md).

## <a name="intrinsics-and-inline-assembly"></a>Встроенные функции и Встроенная сборка

Одним из ограничений для компилятора x64 является отсутствие поддержки встроенного ассемблера. Это означает, что функции, которые не могут быть написаны на языке C или C++ , должны быть написаны как подпрограммы или как встроенные функции, поддерживаемые компилятором. Некоторые функции чувствительны к производительности, а другие — нет. Функции, учитывающие производительность, должны быть реализованы в виде встроенных функций.

Встроенные функции, поддерживаемые компилятором, описаны в разделе [встроенные функции компилятора](../intrinsics/compiler-intrinsics.md).

## <a name="image-format"></a>Формат изображения

Формат исполняемого образа x64 — формат PE32 +. Исполняемые образы (DLL и exe) ограничены максимальным размером в 2 гигабайта, поэтому для адресации статических данных изображения можно использовать относительную адресацию с 32-битным смещением. Эти данные включают таблицу адресов импорта, строковые константы, статические глобальные данные и т. д.

## <a name="see-also"></a>См. также раздел

[Соглашения о вызовах](../cpp/calling-conventions.md)
