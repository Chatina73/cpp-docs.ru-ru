---
title: Состояния модулей обычной библиотеки DLL MFC, динамически компонуемые с MFC
ms.date: 11/04/2016
helpviewer_keywords:
- regular MFC DLLs [C++], dynamically linked to MFC
- module states [C++]
- MFC DLLs [C++], regular MFC DLLs
- module states [C++], regular MFC DLLs dynamically linked to
- DLLs [C++], module states
ms.assetid: b4493e79-d25e-4b7f-a565-60de5b32c723
ms.openlocfilehash: 3ab51ca8097bd5ec27e8e7cfd8b8f19d76195664
ms.sourcegitcommit: 8105b7003b89b73b4359644ff4281e1595352dda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/14/2019
ms.locfileid: "57822149"
---
# <a name="module-states-of-a-regular-mfc-dll-dynamically-linked-to-mfc"></a>Состояния модулей обычной библиотеки DLL MFC, динамически компонуемые с MFC

Возможность динамического связывания обычной библиотеки DLL MFC с библиотекой DLL MFC позволяет некоторые очень сложные конфигурации. Например обычной библиотеки DLL MFC и исполняемый файл, который его использует, могут динамически связаться с библиотекой DLL MFC, так и для любой библиотеки DLL расширений MFC.

Эта конфигурация создает проблему по отношению к глобальным данным MFC, такие как указатель на текущий `CWinApp` объект и дескриптор карты.

Прежде чем MFC версии 4.0 глобальные данные хранились в самой библиотеке DLL MFC и были общими для всех модулей в процессе. Так как каждый процесс, использующий библиотеку DLL Win32 получает собственную копию данных DLL, подобная схема предоставляет простой способ отслеживания данных каждого процесса. Кроме того так как модель AFXDLL предполагает, что будет существовать только один `CWinApp` объект и только один набор обработки карты в процессе, эти элементы можно отследить в самой библиотеке DLL MFC.

Но с возможностью динамического связывания обычной библиотеки DLL MFC с библиотекой DLL MFC, теперь можно использовать два или несколько `CWinApp` объектов в процессе, а также два или более наборов сопоставлений дескрипторов. Как MFC хранить список какие из них следует использовать?

Решение заключается в том, чтобы предоставить свою собственную копию этих сведений о состоянии глобальные каждого модуля (приложение или обычная библиотека DLL MFC). Таким образом, вызов **AfxGetApp** в обычных MFC DLL возвращает указатель на `CWinApp` объекта в библиотеке DLL, не тот, в исполняемом файле. Эта копия-module глобальных данных MFC называется состоянием модуля и описан в [Техническая заметка MFC 58](../mfc/tn058-mfc-module-state-implementation.md).

Общая процедура окна MFC автоматически переключается в состояние правильный модуль, поэтому не нужно беспокоиться об этом для любых обработчиков сообщений, реализованные в обычной библиотеки DLL MFC. Но когда исполняемый файл вызывает обычную библиотеку DLL MFC, вам нужно явно задать текущее состояние модуля одну библиотеку DLL. Чтобы сделать это, используйте **AFX_MANAGE_STATE** макрос в каждой функции, экспортированные из библиотеки DLL. Это делается, добавив следующую строку кода в начале функции, экспортированные из библиотеки DLL:

```
AFX_MANAGE_STATE(AfxGetStaticModuleState( ))
```

## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Управление данными состояния модулей MFC](../mfc/managing-the-state-data-of-mfc-modules.md)

- [Обычные библиотеки DLL MFC, динамически компонуемые с MFC](regular-dlls-dynamically-linked-to-mfc.md)

- [Библиотеки DLL расширений MFC](extension-dlls-overview.md)

## <a name="see-also"></a>См. также

[DLL в Visual C++](dlls-in-visual-cpp.md)
