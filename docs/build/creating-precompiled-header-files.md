---
title: Файлы предварительно скомпилированных заголовков
ms.date: 08/19/2019
helpviewer_keywords:
- precompiled header files, creating
- PCH files, creating
- cl.exe compiler, precompiling code
- .pch files, creating
ms.assetid: e2cdb404-a517-4189-9771-c869c660cb1b
ms.openlocfilehash: 273d8cf996c2717339dd20dcbc7512f9c62afa8d
ms.sourcegitcommit: 9d4ffb8e6e0d70520a1e1a77805785878d445b8a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2019
ms.locfileid: "69630489"
---
# <a name="precompiled-header-files"></a>Файлы предварительно скомпилированных заголовков

При создании нового проекта в Visual Studio в проект добавляется *предварительно скомпилированный заголовочный файл* с именем *PCH. h* . (В Visual Studio 2017 и более ранних версиях файл назывался *stdafx. h*.) Цель файла — ускорить процесс сборки. Здесь следует добавить любые стабильные файлы заголовков, например `<vector>`заголовки стандартной библиотеки, такие как. Предкомпилированный заголовок компилируется только в том случае, если он или какие-либо содержащиеся в нем файлы были изменены. Если вы вносите изменения только в исходный код проекта, при сборке будет пропущена компиляция для предкомпилированного заголовка. 

Параметры компилятора для предкомпилированных заголовков имеют значение [/y](reference/y-precompiled-headers.md). На страницах свойств проекта параметры находятся в разделе **Свойства конфигурации > C/C++ > предкомпилированные заголовки**. Можно выбрать не использовать предварительно скомпилированные заголовки, а также указать имя файла заголовка и путь к выходному файлу. 

## <a name="custom-precompiled-code"></a>Пользовательский предварительно скомпилированный код

Для больших проектов, для которых требуется значительное время, может потребоваться создать пользовательские предкомпилированные файлы. Компиляторы Microsoft C и C++ содержат параметры для предварительной компиляции любого кода C или C++, включая встроенный код. Данная возможность позволяет скомпилировать стабильное тело кода, сохранять скомпилированное состояние кода в файле, а при последующих компиляциях объединять предварительно скомпилированный код с кодом, который еще находится в стадии разработки. Каждая последующая компиляция выполняется быстрее, так как стабильный код не нужно компилировать повторно.

## <a name="when-to-precompile-source-code"></a>Случаи использования предварительной компиляции исходного кода

Предварительно скомпилированный код полезен во время цикла разработки, чтобы сократить время компиляции, особенно если:

- Всегда используется большой текст кода, который изменяется редко.

- Программа состоит из нескольких модулей, каждый из которых использует стандартный набор включаемых файлов и те же параметры компиляции. В этом случае все включаемые файлы можно предварительно скомпилировать в один предкомпилированный заголовок.

Первая компиляция, которая создает файл предкомпилированного заголовка (PCH), занимает немного больше времени, чем последующие компиляции. Последующие компиляции могут выполняться быстрее, включая предварительно скомпилированный код.

Можно выполнить предварительную компиляцию C и C++ программ. В C++ программировании распространенной практикой является отделение сведений о интерфейсе класса в файлы заголовков. Впоследствии эти файлы заголовков можно будет включать в программы, использующие класс. Предварительная компиляция этих заголовков позволяет сократить время, затрачиваемое программой на компиляцию.

> [!NOTE]
> Хотя можно использовать только один файл предкомпилированного заголовка (PCH) для каждого исходного файла, можно использовать несколько PCH-файлов в проекте.

## <a name="two-choices-for-precompiling-code"></a>Два варианта предварительной компиляции кода

Можно предварительно скомпилировать любой код C C++ или. Вы не ограничены предварительной компиляцией только файлов заголовков.

Для предварительной компиляции требуется планирование, но при предварительной компиляции исходного кода, отличного от простых файлов заголовков, обеспечивается значительно более быстрая компиляция.

Предварительная компиляция кода, когда известно, что исходные файлы используют общие наборы файлов заголовков, но не содержат их в том же порядке или если требуется включить исходный код в предварительную компиляцию.

Параметры предкомпилированного заголовка — [/Yc (создать предварительно скомпилированный заголовочный файл)](reference/yc-create-precompiled-header-file.md) и [/Yu (использование файла предкомпилированного заголовка)](reference/yu-use-precompiled-header-file.md). Используйте **/Yc** для создания предкомпилированного заголовка. При использовании с необязательной директивой pragma [hdrstop](../preprocessor/hdrstop.md) , **/Yc** позволяет выполнять предварительную компиляцию как файлов заголовков, так и исходного кода. Выберите **/Yu** , чтобы использовать существующий предкомпилированный заголовок в существующей компиляции. Для предоставления альтернативного имени предкомпилированного заголовка можно также использовать **/FP** с параметрами **/Yc** и **/Yu** .

В справочных разделах, посвященных параметрам компилятора для **/Yu** и **/Yc** , описывается, как получить доступ к этой функции в среде разработки.

## <a name="precompiled-header-consistency-rules"></a>Правила согласованности предкомпилированных заголовков

Поскольку файлы PCH содержат сведения о среде компьютера, а также сведения об адресах памяти для программы, следует использовать PCH-файл только на том компьютере, на котором он был создан.

## <a name="consistency-rules-for-per-file-use-of-precompiled-headers"></a>Правила целостности для пофайлового использования предкомпилированных заголовков

Параметр компилятора [/Yu](reference/yu-use-precompiled-header-file.md) позволяет указать, какой PCH файл следует использовать.

При использовании PCH-файла компилятор предполагает ту же среду компиляции, которая использует последовательные параметры компилятора, директивы pragma и т. д., которые действуют при создании PCH-файла, если не указано иное. Если компилятор обнаруживает несогласованность, он выдает предупреждение и по возможности определяет несогласованность. Такие предупреждения не обязательно указывают на проблему с PCH-файлом. они просто предупреждают о возможных конфликтах. Требования к согласованности для PCH файлов описаны в следующих разделах.

### <a name="compiler-option-consistency"></a>Согласованность параметров компилятора

Следующие параметры компилятора могут вызвать предупреждение о несогласованности при использовании PCH-файла:

- Макросы, созданные с помощью параметра препроцессора (/D), должны быть одинаковыми между компиляцией, создавшими PCH-файл и текущей компиляцией. Состояние определенных констант не проверяется, но при этих изменениях могут возникать непредсказуемые результаты.

- Файлы PCH не работают с параметрами/E и/EP.

- PCH-файлы должны быть созданы с помощью параметра создать сведения о просмотре (/FR) или исключить локальные переменные (/fr), прежде чем последующие компиляции, использующие PCH-файл, смогут использовать эти параметры.

### <a name="c-70-compatible-z7"></a>C 7,0-совместимый (/Z7)

Если этот параметр действует при создании PCH-файла, последующие компиляции, использующие PCH-файл, могут использовать отладочную информацию.

Если параметр C 7,0, совместимый с (/Z7), не действует при создании PCH-файла, последующие компиляции, использующие PCH-файл и/Z7, вызывают предупреждение. Отладочная информация помещается в текущий OBJ-файл, а локальные символы, определенные в файле PCH, недоступны отладчику.

### <a name="include-path-consistency"></a>Включить согласованность пути

PCH-файл не содержит сведений о пути включения, который был действителен при создании. При использовании PCH-файла компилятор всегда использует путь include, указанный в текущей компиляции.

### <a name="source-file-consistency"></a>Согласованность исходного файла

При указании параметра использовать предварительно скомпилированный заголовочный файл (/Yu) компилятор игнорирует все директивы препроцессора (включая прагмы), которые отображаются в исходном коде, который будет предварительно скомпилирован. Компиляция, указанная такими директивами препроцессора, должна совпадать с компиляцией, используемой для параметра создания предкомпилированного файла заголовка (/Yc).

### <a name="pragma-consistency"></a>Согласованность директивы pragma

Директивы pragma, обработанные во время создания PCH-файла, обычно влияют на файл, с которым впоследствии используется PCH-файл. Директивы `message` и pragma не влияют на оставшуюся часть компиляции. `comment`

Эти директивы pragma влияют только на код в файле PCH; они не влияют на код, который впоследствии использует PCH файл:

||||
|-|-|-|
|`comment`|`page`|`subtitle`|
|`linesize`|`pagesize`|`title`|
|`message`|`skip`||

Эти директивы pragma сохраняются как часть предкомпилированного заголовка и влияют на оставшуюся часть компиляции, использующую предкомпилированный заголовок:

||||
|-|-|-|
|`alloc_text`|`include_alias`|`pack`|
|`auto_inline`|`init_seg`|`pointers_to_members`|
|`check_stack`|`inline_depth`|`setlocale`|
|`code_seg`|`inline_recursion`|`vtordisp`|
|`data_seg`|`intrinsic`|`warning`|
|`function`|`optimize`||

## <a name="consistency-rules-for-yc-and-yu"></a>Правила целостности для параметров компилятора /Yc и /Yu

При использовании предварительно скомпилированного заголовка, созданного с помощью/Yc или/Yu, компилятор сравнивает текущую среду компиляции с той, которая существовала при создании PCH-файла. Не забудьте указать окружение, соответствующее предыдущему (с помощью параметров компилятора, директивы pragma и т. д.) для текущей компиляции. Если компилятор обнаруживает несогласованность, он выдает предупреждение и по возможности определяет несогласованность. Такие предупреждения не обязательно указывают на проблему с PCH-файлом. они просто предупреждают о возможных конфликтах. В следующих разделах объясняются требования к согласованности для предкомпилированных заголовков.

### <a name="compiler-option-consistency"></a>Согласованность параметров компилятора

В этой таблице перечислены параметры компилятора, которые могут вызвать предупреждение о несогласованности при использовании предкомпилированного заголовка.

|Параметр|name|Правило|
|------------|----------|----------|
|/D|Определение констант и макросов|Должно быть одинаковым между компиляцией, создавшей предкомпилированный заголовок и текущей компиляцией. Состояние определенных констант не проверяется, но непредсказуемые результаты могут возникать, если файлы зависят от значений измененных констант.|
|/E или/EP|Копирование выходных данных препроцессора в стандартный вывод|Предкомпилированные заголовки не работают с параметром/E или/EP.|
|/FR или/FR|Создать сведения о браузере исходного кода Майкрософт|Для параметров/fr и/FR, допустимых с параметром/Yu, они также должны действовать при создании предкомпилированного заголовка. При последующих компиляциях, использующих предкомпилированный заголовок, также создаются сведения о браузере исходного кода. Сведения о браузере помещаются в один SBR-файл, и на него ссылаются другие файлы так же, как и сведения информация CodeView. Нельзя переопределить размещение исходных данных браузера.|
|/GA,/GD,/GE,/GW или/GW|Параметры протокола Windows|Должно быть одинаковым между компиляцией, создавшей предкомпилированный заголовок и текущей компиляцией. Если эти параметры различаются, выдается предупреждающее сообщение.|
|/ZI|Создание полной отладочной информации|Если этот параметр действует при создании предкомпилированного заголовка, последующие компиляции, использующие предварительную компиляцию, могут использовать эту отладочную информацию. Если параметр/Zi не действует при создании предварительно скомпилированного заголовка, последующие компиляции, использующие предварительную компиляцию и параметры/Zi, вызывают предупреждение. Отладочная информация помещается в текущий объектный файл, а локальные символы, определенные в предкомпилированном заголовке, недоступны отладчику.|

> [!NOTE]
>  Средство предварительно откомпилированных заголовков предназначено для использования только C++ в C и исходных файлах.

## <a name="using-precompiled-headers-in-a-project"></a>Использование предкомпилированных заголовков в проекте

В предыдущих разделах представлен обзор предкомпилированных заголовков:/Yc и/Yu, параметр/FP и директива pragma [hdrstop](../preprocessor/hdrstop.md) . В этом разделе описывается метод использования параметров предкомпилированных заголовков в проекте вручную. Он заканчивается примером файла Makefile и управляемым им кодом.

Для другого подхода к использованию параметров предкомпилированных заголовков в проекте вручную изучите один из файлов makefile, расположенных в каталоге МФК\СРК, который создается во время установки Visual Studio по умолчанию. Эти файлы Makefile имеют похожий подход к представленному в этом разделе, но используют макросы программы обслуживания программ Майкрософт (NMAKE) и обеспечивают больший контроль над процессом сборки.

## <a name="pch-files-in-the-build-process"></a>PCH-файлы в процессе построения

База кода проекта программного обеспечения обычно содержится в нескольких файлах C или C++ исходных файлов, объектных файлах, библиотеках и файлах заголовков. Как правило, Makefile координирует сочетание этих элементов в исполняемый файл. На следующем рисунке показана структура файла makefile, использующего предварительно скомпилированный заголовочный файл. Имена макросов и имен файлов в этой диаграмме соответствуют приведенным в примере кода в [образце файла makefile для PCH](#sample-makefile-for-pch) и [примеры кода для PCH](#example-code-for-pch).

На рисунке для отображения последовательности процесса сборки используются три устройства схематическое. Именованные прямоугольники представляют каждый файл или макрос; три макроса представляют один или несколько файлов. Затененные области представляют каждое действие компиляции или компоновки. Стрелки показывают, какие файлы и макросы объединяются во время процесса компиляции или компоновки.

![Структура файла makefile, использующего предварительно скомпилированный заголовочный файл](media/vc30ow1.gif "Структура файла makefile, использующего предварительно скомпилированный заголовочный файл") <br/>
Структура файла makefile, использующего предварительно скомпилированный заголовочный файл

Начиная с верхней части диаграммы, как СТАБЛЕХДРС, так и BOUNDS являются макросами NMAKE, в которых вы перечислите файлы, которые, скорее всего, не потребуют перекомпиляции. Эти файлы компилируются с помощью командной строки

`CL /c /W3 /Yc$(BOUNDRY) applib.cpp myapp.cpp`

только если предкомпилированный заголовочный файл (STABLE. PCH) не существует или если вы вносите изменения в файлы, перечисленные в двух макросах. В любом случае предкомпилированный заголовочный файл будет содержать код только из файлов, перечисленных в макросе СТАБЛЕХДРС. Перечислите последний файл, который необходимо предварительно откомпилировать в ОГРАНИЧЕНном макросе.

Файлы, перечисленные в этих макросах, могут быть файлами заголовков или C++ C или файлами исходного кода. (Один PCH-файл нельзя использовать одновременно с C и C++ модулями.) Обратите внимание, что можно использовать макрос **hdrstop** для отмены предварительной компиляции в какой бы то ни было момент в файле. Дополнительные сведения см. в разделе об [hdrstop](../preprocessor/hdrstop.md) .

Продолжая работу со схемой, АППЛИБ. obj представляет код поддержки, используемый в окончательном приложении. Он создается из АППЛИБ. cpp, файлов, перечисленных в макросе УНСТАБЛЕХДРС, и предварительно скомпилированного кода из предкомпилированного заголовка.

MYAPP. obj представляет конечное приложение. Он создается из файла MYAPP. cpp, файлов, перечисленных в макросе УНСТАБЛЕХДРС, и предварительно скомпилированного кода из предкомпилированного заголовка.

Наконец, исполняемый файл (MYAPP. EXE) создается путем связывания файлов, перечисленных в макросе OBJ-файлы (АППЛИБ. obj и MYAPP. obj).

## <a name="sample-makefile-for-pch"></a>Образец файла makefile для PCH

В следующем файле Makefile используются макросы и! Если,! В ПРОТИВном случае! ENDIF структура команд потока управления для упрощения адаптации к проекту.

```NMAKE
# Makefile : Illustrates the effective use of precompiled
#            headers in a project
# Usage:     NMAKE option
# option:    DEBUG=[0|1]
#            (DEBUG not defined is equivalent to DEBUG=0)
#
OBJS = myapp.obj applib.obj
# List all stable header files in the STABLEHDRS macro.
STABLEHDRS = stable.h another.h
# List the final header file to be precompiled here:
BOUNDRY = stable.h
# List header files under development here:
UNSTABLEHDRS = unstable.h
# List all compiler options common to both debug and final
# versions of your code here:
CLFLAGS = /c /W3
# List all linker options common to both debug and final
# versions of your code here:
LINKFLAGS = /NOD /ONERROR:NOEXE
!IF "$(DEBUG)" == "1"
CLFLAGS   = /D_DEBUG $(CLFLAGS) /Od /Zi /f
LINKFLAGS = $(LINKFLAGS) /COD
LIBS      = slibce
!ELSE
CLFLAGS   = $(CLFLAGS) /Oselg /Gs
LINKFLAGS = $(LINKFLAGS)
LIBS      = slibce
!ENDIF
myapp.exe: $(OBJS)
    link $(LINKFLAGS) @<<
$(OBJS), myapp, NUL, $(LIBS), NUL;
<<
# Compile myapp
myapp.obj  : myapp.cpp $(UNSTABLEHDRS)  stable.pch
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    myapp.cpp
# Compile applib
applib.obj : applib.cpp $(UNSTABLEHDRS) stable.pch
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    applib.cpp
# Compile headers
stable.pch : $(STABLEHDRS)
    $(CPP) $(CLFLAGS) /Yc$(BOUNDRY)    applib.cpp myapp.cpp
```

Помимо макросов СТАБЛЕХДРС, BOUNDS и УНСТАБЛЕХДРС, показанных на рисунке "структура Makefile, которая использует предварительно скомпилированный заголовочный файл" в [файлах PCH в процессе сборки](#pch-files-in-the-build-process), этот файл Makefile предоставляет макрос клфлагс и макрос линкфлагс. Эти макросы необходимо использовать для перечисления параметров компилятора и компоновщика, которые применяются при построении отладочной или финальной версии исполняемого файла приложения. Также существует макрос Library, в котором перечислены библиотеки, необходимые для проекта.

Файл makefile также использует! Если,! В ПРОТИВном случае! ENDIF для определения того, определен ли символ отладки в командной строке NMAKE:

```NMAKE
NMAKE DEBUG=[1|0]
```

Эта функция позволяет использовать один и тот же файл Makefile во время разработки и для финальных версий программы — используйте DEBUG = 0 для финальных версий. Следующие командные строки эквивалентны:

```NMAKE
NMAKE
NMAKE DEBUG=0
```

Дополнительные сведения о файлах Makefile см. в [справочнике по NMAKE](reference/nmake-reference.md). См. также [параметры компилятора компилятором MSVC](reference/compiler-options.md) и [Параметры компоновщика компилятором MSVC](reference/linker-options.md).

## <a name="example-code-for-pch"></a>Пример кода для PCH

Следующие исходные файлы используются в файле makefile, описанном в [файлах PCH в процессе сборки](#pch-files-in-the-build-process) и в [образце файла makefile для PCH](#sample-makefile-for-pch). Обратите внимание, что комментарии содержат важную информацию.

```cpp
// ANOTHER.H : Contains the interface to code that is not
//             likely to change.
//
#ifndef __ANOTHER_H
#define __ANOTHER_H
#include<iostream>
void savemoretime( void );
#endif // __ANOTHER_H
```

```cpp
// STABLE.H : Contains the interface to code that is not likely
//            to change. List code that is likely to change
//            in the makefile's STABLEHDRS macro.
//
#ifndef __STABLE_H
#define __STABLE_H
#include<iostream>
void savetime( void );
#endif // __STABLE_H
```

```cpp
// UNSTABLE.H : Contains the interface to code that is
//              likely to change. As the code in a header
//              file becomes stable, remove the header file
//              from the makefile's UNSTABLEHDR macro and list
//              it in the STABLEHDRS macro.
//
#ifndef __UNSTABLE_H
#define __UNSTABLE_H
#include<iostream.h>
void notstable( void );
#endif // __UNSTABLE_H
```

```cpp
// APPLIB.CPP : This file contains the code that implements
//              the interface code declared in the header
//              files STABLE.H, ANOTHER.H, and UNSTABLE.H.
//
#include"another.h"
#include"stable.h"
#include"unstable.h"
// The following code represents code that is deemed stable and
// not likely to change. The associated interface code is
// precompiled. In this example, the header files STABLE.H and
// ANOTHER.H are precompiled.
void savetime( void )
    { cout << "Why recompile stable code?\n"; }
void savemoretime( void )
    { cout << "Why, indeed?\n\n"; }
// The following code represents code that is still under
// development. The associated header file is not precompiled.
void notstable( void )
    { cout << "Unstable code requires"
            << " frequent recompilation.\n";
    }
```

```cpp
// MYAPP.CPP : Sample application
//             All precompiled code other than the file listed
//             in the makefile's BOUNDRY macro (stable.h in
//             this example) must be included before the file
//             listed in the BOUNDRY macro. Unstable code must
//             be included after the precompiled code.
//
#include"another.h"
#include"stable.h"
#include"unstable.h"
int main( void )
{
    savetime();
    savemoretime();
    notstable();
}
```

## <a name="see-also"></a>См. также

[Справочные сведения о сборке C/C++](reference/c-cpp-building-reference.md)<br/>
[Параметры компилятора MSVC](reference/compiler-options.md)
