---
title: Файлы предварительно скомпилированных заголовков
ms.date: 10/24/2019
helpviewer_keywords:
- precompiled header files, creating
- PCH files, creating
- cl.exe compiler, precompiling code
- .pch files, creating
ms.assetid: e2cdb404-a517-4189-9771-c869c660cb1b
ms.openlocfilehash: 158301ec3caacced1663892071b17ef2b8f8e741
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328671"
---
# <a name="precompiled-header-files"></a>Файлы предварительно скомпилированных заголовков

При создании нового проекта в Visual Studio в проект добавляется *предварительно собранный файл заголовка* *pch.h.* (В Visual Studio 2017 и ранее, файл назывался *stdafx.h.)* Цель файла — ускорить процесс сборки. Любые стабильные файлы заголовка, например заголовки Standard Library, такие как `<vector>`, должны быть включены здесь. Предварительно собранный заголовок компилируется только тогда, когда он или любые файлы, в которые он входит, изменяются. Если вы внесете изменения только в исходный код проекта, сборка пропустит компиляцию для предварительно собранного заголовка.

Параметры компилятора для предварительно компилированных заголовков [/Y](reference/y-precompiled-headers.md). На страницах свойств проекта параметры расположены под **свойствами конфигурации > C/C е > Precompiled Заголовки.** Вы можете не использовать предварительно собранные заголовки, и вы можете указать имя файла заголовка и имя и путь вывода файла.

## <a name="custom-precompiled-code"></a>Пользовательский предварительно компилированный код

Для крупных проектов, для создания — это значительное время, можно рассмотреть возможность создания пользовательских предсобранных файлов. Компиляторы Microsoft C и C++ содержат параметры для предварительной компиляции любого кода C или C++, включая встроенный код. Данная возможность позволяет скомпилировать стабильное тело кода, сохранять скомпилированное состояние кода в файле, а при последующих компиляциях объединять предварительно скомпилированный код с кодом, который еще находится в стадии разработки. Каждая последующая компиляция выполняется быстрее, так как стабильный код не нужно компилировать повторно.

## <a name="when-to-precompile-source-code"></a>Случаи использования предварительной компиляции исходного кода

Предварительно собранный код полезен в течение цикла разработки для сокращения времени компиляции, особенно если:

- Вы всегда используете большой объем кода, который изменяется нечасто.

- Ваша программа состоит из нескольких модулей, все из которых используют стандартный набор файлов и те же варианты компиляции. В этом случае все файлы включаются в один предварительно собранный заголовок.

Первая компиляция, создающая предкомпилированный файл заголовка (PCH), занимает немного больше времени, чем последующие компиляции. Последующие компиляции могут осуществляться быстрее, включив предварительно собранный код.

Вы можете предварительно компилировать как программы C, так и СЗЗ. В программировании СЗ обычно ездопринято, чтобы отделить информацию о интерфейсе класса в файлы заголовка. Эти файлы заголовка позже могут быть включены в программы, которые используют класс. Предварительно компиляция этих заголовков позволяет сократить время, необходимое для компиляции программы.

> [!NOTE]
> Хотя вы можете использовать только один предварительно собранный заголовок (.pch) файл на источник файла, вы можете использовать несколько файлов .pch в проекте.

## <a name="two-choices-for-precompiling-code"></a>Два варианта предварительной компиляции кода

Вы можете предварительно компилировать любой код C или C'; вы не ограничены предварительной компиляцией только файлов заголовка.

Предварительная компиляция требует планирования, но она предлагает значительно более быстрые компиляции, если вы предварительно компилируете исходный код, кроме простых файлов заголовка.

Предварительный код, когда вы знаете, что исходные файлы используют общие наборы файлов заголовка, но не включают их в том же порядке, или когда вы хотите включить исходный код в прекомпиляцию.

Предсборникные параметры [заголовка: /Yc (Создание предкомпилированного файла заголовка)](reference/yc-create-precompiled-header-file.md) и [/Yu (использовать предкомпилированный файл заголовка)](reference/yu-use-precompiled-header-file.md). Используйте **/Yc** для создания предварительно компилированного заголовка. При использовании с дополнительным испарителем [hdrstop,](../preprocessor/hdrstop.md) **/Yc** позволяет предварительно компилировать как заголовок файлов и исходный код. Выберите **/Yu,** чтобы использовать существующий предварительно собранный заголовок в существующей компиляции. Вы также можете использовать **/Fp** с **опциями /Yc** и **/Yu,** чтобы предоставить альтернативное название для предварительно собранного заголовка.

Темы ссылки на вариант компилятора для **/Yu** и **/Yc** обсуждают, как получить доступ к этой функциональности в среде разработки.

## <a name="precompiled-header-consistency-rules"></a>Правила согласованности предкомпилированных заголовков

Поскольку PCH-файлы содержат информацию о среде машины, а также информацию о адресе памяти о программе, следует использовать файл PCH только на машине, где она была создана.

## <a name="consistency-rules-for-per-file-use-of-precompiled-headers"></a>Правила целостности для пофайлового использования предкомпилированных заголовков

Опция компилятора [/Yu](reference/yu-use-precompiled-header-file.md) позволяет указать, какой файл PCH использовать.

При использовании файла PCH компилятор предполагает ту же среду компиляции, которая использует согласованные параметры компилятора, прагмы и так далее, которая была фактически создана при создании файла PCH, если вы не укажете иное. Если компилятор обнаруживает несоответствие, он выдает предупреждение и определяет несоответствие, где это возможно. Такие предупреждения не обязательно указывают на проблему с файлом PCH; они просто предупреждают вас о возможных конфликтах. Требования к согласованности файлов PCH описаны в следующих разделах.

### <a name="compiler-option-consistency"></a>Согласованность опционов компилятора

Следующие параметры компилятора могут вызвать предупреждение о несоответствии при использовании файла PCH:

- Макрос, созданный с помощью опции Preprocessor (/D), должен быть одинаковым между компиляцией, создаващей файл PCH, и текущей компиляцией. Состояние определенных констант не проверяется, но при их изменении могут произойти непредсказуемые результаты.

- PCH-файлы не работают с опциями /E и /EP.

- PCH-файлы должны создаваться либо с помощью опции Generate Browse Info (/FR), либо опции «Исключить локальные переменные» (/Fr), прежде чем последующие компиляции, использующие файл PCH, смогут использовать эти параметры.

### <a name="c-70-compatible-z7"></a>C 7.0-Совместимый (/No7)

Если эта опция действует при создании файла PCH, последующие компиляции, в которые используется файл PCH, могут использовать информацию об отладке.

Если параметр C 7.0-Compatible (/No7) не действует при создании файла PCH, последующие компиляции, в которые используется файл PCH и / No7, вырабатывают предупреждение. Информация об отладке размещается в текущем файле .obj, а локальные символы, определенные в файле PCH, недоступны для отладчика.

### <a name="include-path-consistency"></a>Включить согласованность пути

Файл PCH не содержит информации о пути включения, который был в силе, когда он был создан. При использовании файла PCH компилятор всегда использует путь включения, указанный в текущей компиляции.

### <a name="source-file-consistency"></a>Последовательность исходного файла

При указании опции «Файл предварительного заголовка использования» (/Yu) компилятор игнорирует все предпроцессорные директивы (включая прагмы), которые отображаются в исходном коде, который будет предварительно компилирован. Компиляция, указанная такими предпроцессорными директивами, должна быть такой же, как и компиляция, используемая для опции Create Precompiled Header File (/Yc).

### <a name="pragma-consistency"></a>Последовательность прагмы

Прагмы, обработанные при создании файла PCH, обычно влияют на файл, с которым впоследствии используется файл PCH. Прагмы `comment` и `message` прагмы не влияют на оставшуюся часть компиляции.

Эти прагмы влияют только на код в файле PCH; они не влияют на код, который впоследствии использует файл PCH:

||||
|-|-|-|
|`comment`|`page`|`subtitle`|
|`linesize`|`pagesize`|`title`|
|`message`|`skip`||

Эти прагмы сохраняются как часть предварительно компилированного заголовка и влияют на оставшуюся часть компиляции, использующая предварительно собранный заголовок:

||||
|-|-|-|
|`alloc_text`|`include_alias`|`pack`|
|`auto_inline`|`init_seg`|`pointers_to_members`|
|`check_stack`|`inline_depth`|`setlocale`|
|`code_seg`|`inline_recursion`|`vtordisp`|
|`data_seg`|`intrinsic`|`warning`|
|`function`|`optimize`||

## <a name="consistency-rules-for-yc-and-yu"></a>Правила целостности для параметров компилятора /Yc и /Yu

При использовании предварительно компилированного заголовка, созданного с помощью /Yc или /Yu, компилятор сравнивает текущую среду компиляции с той, которая существовала при создании файла PCH. Не забудьте указать среду, соответствующую предыдущей (используя согласованные варианты компилятора, прагмы и т.д.) для текущей компиляции. Если компилятор обнаруживает несоответствие, он выдает предупреждение и определяет несоответствие, где это возможно. Такие предупреждения не обязательно указывают на проблему с файлом PCH; они просто предупреждают вас о возможных конфликтах. В следующих разделах разъясняются требования к согласованности для предварительно собранных заголовков.

### <a name="compiler-option-consistency"></a>Согласованность опционов компилятора

В этой таблице перечислены параметры компилятора, которые могут вызвать предупреждение о несоответствии при использовании предварительно собранного заголовка:

|Параметр|Имя|Правило|
|------------|----------|----------|
|/D|Определение констант и макросов|Должно быть то же самое между компиляцией, которая создала предварительно собранный заголовок и текущей компиляции. Состояние определенных констант не проверяется, но непредсказуемые результаты могут произойти, если ваши файлы зависят от значений измененных констант.|
|/E или /EP|Копирование допроцессорного вывода на стандартный выход|Предварительно собранные заголовки не работают с опцией /E или /EP.|
|/Fr или /FR|Создание информации об исходных браузерах Майкрософт|Для опций /Fr и /FR, которые будут действительны мишенями с опцией /Yu, они также должны действовать при создании предварительно собранного заголовка. Последующие компиляции, в которые используется предварительно собранный заголовок, также генерируют информацию Об источнике браузера. Информация о браузере размещается в одном файле .sbr и ссылается на другие файлы так же, как и информация CodeView. Вы не можете переопределить размещение информации об исходном браузере.|
|/GA, /GD, /GE, /Gw, или /GW|Параметры протокола Windows|Должно быть то же самое между компиляцией, которая создала предварительно собранный заголовок и текущей компиляции. Если эти параметры отличаются, результаты предупреждающее сообщение.|
|/Zi|Создание информации о полной отладке|Если эта опция действует при создании предварительно компилированного заголовка, последующие компиляции, в которые используется прекомпиляция, могут использовать эту информацию отладки. Если /Ци не действует при создании предварительно компилированного заголовка, последующие компиляции, в которые используется прекомпиляция и опция /ци, вызывают предупреждение. Информация об отладке помещается в файл текущего объекта, а локальные символы, определенные в предварительно компилированном заголовке, недоступны для отладчика.|

> [!NOTE]
> Предварительно собранный заголовок предназначен для использования только в исходных файлах C и C.'.

## <a name="using-precompiled-headers-in-a-project"></a>Использование предкомпилированных заголовков в проекте

Предыдущие разделы представляют обзор предварительно собранных заголовков: /Yc и /Yu, опция /Fp и прагма [hdrstop.](../preprocessor/hdrstop.md) В этом разделе описывается метод использования ручных предварительно собранных заголовков в проекте; он заканчивается примером makefile и код, который он управляет.

Для другого подхода к использованию ручных предварительно собранных заголовков в проекте изучите один из makefiles, расположенный в каталоге MFC-SRC, который создается во время установки Visual Studio по умолчанию. Эти makefiles принять аналогичный подход к одному представленв в этом разделе, но более широко использовать Microsoft Program Maintenance Utility (NMAKE) макросы, и предлагают больший контроль над процессом сборки.

## <a name="pch-files-in-the-build-process"></a>PCH-файлы в процессе построения

Кодовая база программного проекта обычно содержится в нескольких исходных файлах C или C, файлах объектов, библиотеках и заголовках. Как правило, makefile координирует комбинацию этих элементов в исполняемый файл. Следующая цифра показывает структуру makefile, который использует предварительно собранный файл заголовка. Имена макросов NMAKE и имена файлов на этой диаграмме согласуются с именами файлов в примере кода, найденного в [примере Makefile для PCH](#sample-makefile-for-pch) и [Example Code для PCH.](#example-code-for-pch)

На рисунке используются три схематических устройства, чтобы показать ход процесса сборки. Названные прямоугольники представляют каждый файл или макрос; три макроса представляют один или несколько файлов. Затененные области представляют каждое действие компиляции или ссылки. Стрелки показывают, какие файлы и макросы объединяются во время процесса компиляции или соединения.

![Структура makefile, который использует предварительно собранный файл заголовка](media/vc30ow1.gif "Структура makefile, который использует предварительно собранный файл заголовка") <br/>
Структура Makefile, который использует предкомпилированный файл заголовка

Начиная с верхней части диаграммы, как STABLEHDRS и BOUNDRY являются МакросN NMAKE, в которых вы перечисляете файлы, которые вряд ли нуждаются в перекомпиляции. Эти файлы компилируются строкой команды

`CL /c /W3 /Yc$(BOUNDRY) applib.cpp myapp.cpp`

только если предварительно собранный файл заголовка (STABLE.pch) не существует или если вы внесете изменения в файлы, перечисленные в двух макросах. В любом случае предварительно собранный файл заголовка будет содержать код только из файлов, перечисленных в макросе STABLEHDRS. Перечислите последний файл, который вы хотите предварительно компилировать в макросе BOUNDRY.

Файлы, которые вы перечисляете в этих макросах, могут быть либо файлами заголовка, либо файлами c или C' source. (Один файл PCH не может быть использован как с модулями C, так и с C') Обратите внимание, что вы можете использовать макрос **hdrstop,** чтобы остановить прекомпиляцию в какой-то момент в файле BOUNDRY. Дополнительную информацию можно узнать на данный простой от [нее.](../preprocessor/hdrstop.md)

Продолжая вниз по диаграмме, APPLIB.obj представляет код поддержки, используемый в конечном приложении. Он создается из APPLIB.cpp, файлов, перечисленных в макросе UNSTABLEHDRS, и предварительно компилированного кода из предварительно компилированного заголовка.

MYAPP.obj представляет вашу окончательную заявку. Он создается из MYAPP.cpp, файлов, перечисленных в макросе UNSTABLEHDRS, и предварительно компилированного кода из предварительно компилированного заголовка.

Наконец, исполняемый файл (MYAPP. EXE) создается путем увязки файлов, перечисленных в макросе OBJS (APPLIB.obj и MYAPP.obj).

## <a name="sample-makefile-for-pch"></a>Образец файла makefile для PCH

Следующий makefile использует макросы и ! Если! Еще! Структура управления потоком ENDIF для упрощения адаптации к проекту.

```NMAKE
# Makefile : Illustrates the effective use of precompiled
#            headers in a project
# Usage:     NMAKE option
# option:    DEBUG=[0|1]
#            (DEBUG not defined is equivalent to DEBUG=0)
#
OBJS = myapp.obj applib.obj
# List all stable header files in the STABLEHDRS macro.
STABLEHDRS = stable.h another.h
# List the final header file to be precompiled here:
BOUNDRY = stable.h
# List header files under development here:
UNSTABLEHDRS = unstable.h
# List all compiler options common to both debug and final
# versions of your code here:
CLFLAGS = /c /W3
# List all linker options common to both debug and final
# versions of your code here:
LINKFLAGS = /nologo
!IF "$(DEBUG)" == "1"
CLFLAGS   = /D_DEBUG $(CLFLAGS) /Od /Zi
LINKFLAGS = $(LINKFLAGS) /COD
LIBS      = slibce
!ELSE
CLFLAGS   = $(CLFLAGS) /Oselg /Gs
LINKFLAGS = $(LINKFLAGS)
LIBS      = slibce
!ENDIF
myapp.exe: $(OBJS)
    link $(LINKFLAGS) @<<
$(OBJS), myapp, NUL, $(LIBS), NUL;
<<
# Compile myapp
myapp.obj  : myapp.cpp $(UNSTABLEHDRS)  stable.pch
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    myapp.cpp
# Compile applib
applib.obj : applib.cpp $(UNSTABLEHDRS) stable.pch
    $(CPP) $(CLFLAGS) /Yu$(BOUNDRY)    applib.cpp
# Compile headers
stable.pch : $(STABLEHDRS)
    $(CPP) $(CLFLAGS) /Yc$(BOUNDRY)    applib.cpp myapp.cpp
```

Помимо STABLEHDRS, BOUNDRY и UNSTABLEHDRS макросы показано на рисунке "Структура Makefile, который использует предварительно собранный файл заголовка" в [PCH файлов в процессе сборки](#pch-files-in-the-build-process), этот makefile обеспечивает CLFLAGS макро с макросом и MACRO. Эти макросы необходимо использовать для определения параметров компилятора и связующим звена, которые применяются независимо от того, создаете ли вы отладку или окончательную версию исполняемого файла приложения. Существует также макрос LIBS, где вы перечисляете библиотеки, необходимые для проекта.

Makefile также использует! Если! Еще! ENDIF для определения символа DEBUG в командной строке NMAKE:

```NMAKE
NMAKE DEBUG=[1|0]
```

Эта функция позволяет использовать тот же makefile во время разработки и для окончательных версий вашей программы - использовать DEBUG-0 для окончательных версий. Следующие командные строки эквивалентны:

```NMAKE
NMAKE
NMAKE DEBUG=0
```

Для получения дополнительной информации о makefiles, [см.](reference/nmake-reference.md) Также смотрите [параметры компилятора MSVC](reference/compiler-options.md) и [параметры MSVC Linker.](reference/linker-options.md)

## <a name="example-code-for-pch"></a>Пример кода для PCH

Следующие исходные файлы используются в makefile, описанном в [PCH Файлов в процессе сборки](#pch-files-in-the-build-process) и [образец Makefile для PCH](#sample-makefile-for-pch). Обратите внимание, что комментарии содержат важную информацию.

```cpp
// ANOTHER.H : Contains the interface to code that is not
//             likely to change.
//
#ifndef __ANOTHER_H
#define __ANOTHER_H
#include<iostream>
void savemoretime( void );
#endif // __ANOTHER_H
```

```cpp
// STABLE.H : Contains the interface to code that is not likely
//            to change. List code that is likely to change
//            in the makefile's STABLEHDRS macro.
//
#ifndef __STABLE_H
#define __STABLE_H
#include<iostream>
void savetime( void );
#endif // __STABLE_H
```

```cpp
// UNSTABLE.H : Contains the interface to code that is
//              likely to change. As the code in a header
//              file becomes stable, remove the header file
//              from the makefile's UNSTABLEHDR macro and list
//              it in the STABLEHDRS macro.
//
#ifndef __UNSTABLE_H
#define __UNSTABLE_H
#include<iostream>
void notstable( void );
#endif // __UNSTABLE_H
```

```cpp
// APPLIB.CPP : This file contains the code that implements
//              the interface code declared in the header
//              files STABLE.H, ANOTHER.H, and UNSTABLE.H.
//
#include"another.h"
#include"stable.h"
#include"unstable.h"
using namespace std;
// The following code represents code that is deemed stable and
// not likely to change. The associated interface code is
// precompiled. In this example, the header files STABLE.H and
// ANOTHER.H are precompiled.
void savetime( void )
    { cout << "Why recompile stable code?\n"; }
void savemoretime( void )
    { cout << "Why, indeed?\n\n"; }
// The following code represents code that is still under
// development. The associated header file is not precompiled.
void notstable( void )
    { cout << "Unstable code requires"
            << " frequent recompilation.\n";
    }
```

```cpp
// MYAPP.CPP : Sample application
//             All precompiled code other than the file listed
//             in the makefile's BOUNDRY macro (stable.h in
//             this example) must be included before the file
//             listed in the BOUNDRY macro. Unstable code must
//             be included after the precompiled code.
//
#include"another.h"
#include"stable.h"
#include"unstable.h"
int main( void )
{
    savetime();
    savemoretime();
    notstable();
}
```

## <a name="see-also"></a>См. также раздел

[Ссылка на сборку C/C++](reference/c-cpp-building-reference.md)<br/>
[Параметры компилятора MSVC](reference/compiler-options.md)
