---
title: Профильная оптимизация
ms.date: 04/23/2019
helpviewer_keywords:
- profile-guided optimizations
- optimization, profile-guided [C++]
ms.assetid: 2225c307-d3ae-42c1-8345-a5a959d132dc
ms.openlocfilehash: 46619e77861b6a3a78d74ce6c6d9173a3a5f270f
ms.sourcegitcommit: 283cb64fd7958a6b7fbf0cd8534de99ac8d408eb
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2019
ms.locfileid: "64857330"
---
# <a name="profile-guided-optimizations"></a>Профильная оптимизация

Профильная оптимизация (PGO) позволяет оптимизировать весь исполняемый файл, где оптимизатор использует данные из тестовых запусков файла .exe или .dll. Данные представляют скорее всего, производительность программы в рабочей среде.

Профильные оптимизации доступны только x86 или x64 компиляции в машинный код. Оптимизация, зависимая от профиля недоступны для исполняемых файлов, которые выполняются на среду. Даже если создать сборку со смешанным машинным и управляемым кодом (с помощью **/CLR** параметр компилятора), нельзя использовать профильную оптимизацию только для машинного кода. Если вы попытаетесь выполнить сборку проекта с этими параметрами, заданными в интегрированной среде разработки, приводит к ошибке сборки.

> [!NOTE]
> Сведения, собранные из теста профилирования, запускают переопределения оптимизаций, которые бы в противном случае вступят в силу, если указать **/Ob**, **/Os**, или **/Ot**. Дополнительные сведения см. в разделе [/Ob (расширение встраиваемых функций)](reference/ob-inline-function-expansion.md) и [/Os /Ot (приоритет размера кода или скорости кода)](reference/os-ot-favor-small-code-favor-fast-code.md).

## <a name="steps-to-optimize-your-app"></a>Шаги для оптимизации приложения

Чтобы использовать профильную оптимизацию, выполните следующие действия для оптимизации приложения.

- Компиляции одного или нескольких файлов исходного кода с [/GL](reference/gl-whole-program-optimization.md).

   Каждый модуль, построенный с **/GL** можно проверить во время тестовых запусков профильной оптимизации для захвата поведение во время выполнения. Каждый модуль в построении профильной оптимизации не должен компилироваться с **/GL**. Однако только те модули, скомпилированные с использованием **/GL** будут обработаны и доступны для профильной оптимизации.

- Компоновку с использованием [/LTCG](reference/ltcg-link-time-code-generation.md) и [/genprofile или/fastgenprofile](reference/genprofile-fastgenprofile-generate-profiling-instrumented-build.md).

   Использование обеих **/LTCG** и **/genprofile** или **/fastgenprofile** создает `.pgd` файлов при выполнении инструментированного приложения. После добавления данных тестового запуска `.pgd` файл, он может использоваться в качестве входных данных для следующего этапа компоновки (Создание оптимизированного образа). При указании **/genprofile**, при необходимости можно добавить **PGD =**_filename_ аргумент, чтобы указать нестандартное имя или расположение `.pgd` файл. Сочетание **/LTCG** и **/genprofile** или **/fastgenprofile** параметры компоновщика заменяет нерекомендуемый **/LTCG: PGINSTRUMENT** параметр компоновщика.

- Профилирование приложения.

   Завершает каждый раз, когда профилируемый сеанс EXE или профилируемый DLL-ФАЙЛ выгружается, `appname!N.pgc` создается файл. Объект `.pgc` файл содержит сведения об определенном тестовом запуске приложения. *AppName* — это имя вашего приложения и *N* номера начиная с 1, которое увеличивается зависит от числа других `appname!N.pgc` файлы в каталоге. Вы можете удалить `.pgc` файла, если тестовый запуск не представляет сценарий, который вы хотите оптимизировать.

   При выполнении теста, вы можете принудительно замыкание уже открытой `.pgc` файла и создание нового `.pgc` файл с [pgosweep](pgosweep.md) программы (например, если конец тестового сценария не совпадает с приложением Завершение работы).

   Приложения можно также напрямую вызывать функцию профильной Оптимизации, [использованием PgoAutoSweep](pgoautosweep.md), для сбора данных профиля точке вызова как `.pgc` файл. Оно предоставляет более точный контроль кода, охваченных записанные данные в вашей `.pgc` файлов. Пример использования этой функции, см. в разделе [использованием PgoAutoSweep](pgoautosweep.md) документации.

   При создании вашей инструментированной сборки по умолчанию сбор данных выполняется в режиме не являющихся потокобезопасными, который выполняется быстрее, но могут быть неточными. С помощью **EXACT** аргумент **/genprofile** или **/fastgenprofile**, сбор данных можно указать в режиме поточно ориентированными, который является более точным, но медленнее. Этот параметр также доступна при установке устаревших [PogoSafeMode](environment-variables-for-profile-guided-optimizations.md#pogosafemode) переменной среды или устаревший **/POGOSAFEMODE** параметр компоновщика, при создании инструментированной сборки.

- Компоновку с использованием **/LTCG** и **/useprofile**.

   Использовать оба метода **/LTCG** и [/useprofile](reference/useprofile.md) параметры компоновщика для создания оптимизированного образа. Этот шаг принимает в качестве входного `.pgd` файл. При указании **/useprofile**, при необходимости можно добавить **PGD =**_filename_ аргумент, чтобы указать нестандартное имя или расположение `.pgd` файл. Это имя можно также указать с помощью устаревших **/PGD** параметр компоновщика. Сочетание **/LTCG** и **/useprofile** заменяет нерекомендуемый **/LTCG: PGOPTIMIZE** и **/LTCG: PGUPDATE** параметры компоновщика.

Его можно даже создать оптимизированный исполняемый файл и позже определить, что дополнительное профилирование будет полезно для создания более оптимизированного образа. Если инструментированный образ и его `.pgd` файл доступны, можно выполнить дополнительные тестовые запуски и перестроить оптимизированный образ с новой `.pgd` файла с использованием тех же **/LTCG** и   **/useprofile** параметры компоновщика.

## <a name="optimizations-performed-by-pgo"></a>Оптимизацию, выполняемую с профильной Оптимизации

Оптимизация, зависимая от профиля включают эти проверки и улучшения:

- **Встраивание** — например, если функция A часто вызывает функцию B, а функция B является относительно небольшой, то Профильная оптимизация встроит функцию B в функцию A.

- **Отражение виртуального вызова** -Если виртуального вызова или другой вызов через указатель функции часто предназначен для определенной функции, Профильная оптимизация может вставить условно выполняемый прямой вызов распространенных функции, и прямой вызов могут подставляться.

- **Распределение регистров** -оптимизации на основе результатов данных профиля улучшает распределение регистров.

- **Простая блочная оптимизация** -Простая блочная оптимизация позволяет часто выполняемые основные блоки, которые временно выполняются во фрейме должно быть помещено в тот же набор страниц (локально). Сводит к минимуму количество используемых страниц, что сводит к минимуму дополнительная нагрузка на память.

- **Оптимизация размера и скорости** -функции, где программа тратит больше всего времени выполнения могут быть оптимизированы по скорости.

- **Структура функции** — на основании графа вызовов и профилировать поведение "Вызывающий/вызываемый", функции, как правило, вдоль одного пути выполнения, помещаются в одном разделе.

- **Оптимизация условного ветвления** — с помощью зондов значений Профильная оптимизация может определить, если заданное значение в операторе switch используется чаще, чем другие значения.  Затем это значение может быть извлечено из оператора switch.  То же можно сделать с помощью `if`... `else` инструкции, где оптимизатор может упорядочить `if`... `else` таким образом, чтобы или `if` или `else` блок помещается во-первых, в зависимости от того, какой блок имеет более часто true.

- **Отделение неиспользуемого кода** -код, который не вызывается во время профилирования, перемещается в специальный раздел, который добавляется в конец набора разделов. Он позволяет вынести раздел с часто используемых страниц.

- **Отделение кода EH** — код EH, так как только исключительно выполняется, его можно поместить в отдельный раздел. Он будет перемещаться при профильной оптимизации удается определить, что исключения возникают только при исключительных условиях.

- **Внутренние функции памяти** - ли расширить встроенный или не зависит от ли он часто вызывается. Встроенная функция может также быть оптимизирована на основе размера блока перемещения или копирования.

## <a name="next-steps"></a>Следующие шаги

Дополнительные сведения об этих переменных среды, функции и средства, которые можно использовать в оптимизация, зависимая от профиля:

[Переменные среды для профильной оптимизации](environment-variables-for-profile-guided-optimizations.md)<br/>
Эти переменные использовались для указания поведения времени выполнения сценариев тестирования. Они теперь устарело и заменено новые параметры компоновщика. В этом документе показано, как переместить из переменных среды для параметров компоновщика.

[PgoAutoSweep](pgoautosweep.md)<br/>
Функции можно добавить в приложение для обеспечения точного `.pgc` управлением системы отслеживания измененных данных файлов.

[pgosweep](pgosweep.md)<br/>
Это программа командной строки, который записывает все данные профиля для `.pgc` файл закрывается `.pgc` файл и открывает новую `.pgc` файл.

[pgomgr](pgomgr.md)<br/>
Это программа командной строки, который добавляет профиль данных из одного или нескольких `.pgc` файлы `.pgd` файл.

[Практическое руководство. Слияние нескольких профилей PGO в единый профиль](how-to-merge-multiple-pgo-profiles-into-a-single-profile.md)<br/>
Примеры **pgomgr** использования.

## <a name="see-also"></a>См. также

[Дополнительные средства сборки MSVC](reference/c-cpp-build-tools.md)
