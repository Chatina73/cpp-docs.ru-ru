---
title: Пролог и эпилог
ms.date: 11/04/2016
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
ms.openlocfilehash: 2b54737edd46a5e108a211ee032889885be2b1da
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50543121"
---
# <a name="prolog-and-epilog"></a>Пролог и эпилог

Каждой функции, которая выделяет пространство стека, вызовы других функций, сохраняет неизменяемые регистры или используется структурная обработка исключений должен иметь пролога, адрес ограничения описаны в очистки данных, связанных с соответствующей функции записи в таблице (см. в разделе [(X64) обработки исключений](../build/exception-handling-x64.md)). Прологе сохранение регистров во свои домашние адреса при необходимости, помещает неизменяемые регистры в стек аргумента, выделяет фиксированная часть стека для локальных переменных и временных переменных и при необходимости создается указатель кадра. В связанных данных завершения описывается действие пролога и необходимо предоставить сведения, необходимые для отмены результатов выполнения кода пролога.

Если фиксированного выделения в стеке имеет более одной страницы (то есть больше, чем 4096 байт), то может возникнуть ситуация, что выделение памяти в стеке может занимать более одной страницы виртуальной памяти, и, таким образом, выделение должен быть проверен до фактического выделения. Для этой цели предоставляется специальной программе, из пролога и не уничтожает любые регистры аргумента.

Сохранение неизменяемые регистры, рекомендуется переместить их в стек перед выделение фиксированной части стека. Если выделение фиксированной части стека выполняется до неизменяемые регистры были сохранены, а затем скорее будет обязан адрес 32-разрядное смещение к области сохраненного регистра (сообщается, что, Push-уведомлений регистров выполняются так же быстро, как перемещается и должен оставаться так обозримом будущем несмотря на неявную зависимость между Push-уведомления). Неизменяемые регистры можно сохранить в любом порядке. Тем не менее использование первый защищенный регистр в прологе необходимо сохранить его.

Код пролога обычно может быть:

```
mov       [RSP + 8], RCX
push   R15
push   R14
push   R13
sub      RSP, fixed-allocation-size
lea      R13, 128[RSP]
...
```

В этом прологе аргумент регистра RCX внутреннему адресу, сохраняются защищенные регистры R13-R15, выделяет фиксированной части кадра стека, а также устанавливает указатель кадра, который указывает 128 байт в фиксированную область. Смещение с помощью нескольких фиксированную область с помощью однобайтовых смещений.

Если размер фиксированного выделения не меньше одной страницы памяти, вспомогательная функция должен вызываться перед изменением RSP. Этот вспомогательный __chkstk, несет ответственность за проверку диапазона в подлежащей выделению стека, чтобы убедиться, что стек распространяется должным образом. В этом случае приведенный выше пример пролога будет выглядеть:

```
mov       [RSP + 8], RCX
push   R15
push   R14
push   R13
mov      RAX,  fixed-allocation-size
call   __chkstk
sub      RSP, RAX
lea      R13, 128[RSP]
...
```

Вспомогательная функция __chkstk не будет изменять регистры R10, R11 и условных кодов. В частности он возвращает RAX без изменений и оставить все неизменяемые регистры и регистры передача аргумента без изменений.

Код эпилога существует для каждого выхода функции. В то время как имеется один пролог, допускается использование нескольких эпилогов. Код эпилога выполняется усечение стека до размера фиксированного выделения, (при необходимости), освобождает выделение фиксированной части стека, неизменяемые регистры для восстановления путем извлечения их сохраненных значений из стека и возвращает.

Код эпилога необходимо выполнить строгому набору правил в коде для очистки надежно исключений и прерываний. Это уменьшает объем используемых данных завершения, так как нет дополнительные данные, необходимые для описания каждого эпилога. Вместо этого код очистки можно определить, что эпилога выполняется посредством прямого просмотра потока кода для идентификации эпилога.

Если нет указателя кадра используется в функции, а затем эпилога необходимо сначала отменить фиксированной части стека, извлекаются неизменяемые регистры и возврата управления вызывающей функции. Например, примененная к объекту директива

```
add      RSP, fixed-allocation-size
pop      R13
pop      R14
pop      R15
ret
```

При использовании в функции указатель кадра стека должен быть усечена в его фиксированного выделения, до выполнения эпилога. Это технически не является частью эпилога. Например следующий эпилог может использоваться для отмены ранее выполненного пролога:

```
lea      RSP, -128[R13]
; epilogue proper starts here
add      RSP, fixed-allocation-size
pop      R13
pop      R14
pop      R15
ret
```

На практике Если используется указатель кадра, есть без видимых причин для корректировки RSP в два этапа, поэтому вместо него будет использоваться следующий эпилог:

```
lea      RSP, fixed-allocation-size - 128[R13]
pop      R13
pop      R14
pop      R15
ret
```

Это единственно допустимые формы эпилога. Он должен содержать либо `add RSP,constant` или `lea RSP,constant[FPReg]`, а затем ряд ноль или более точек подключения register размером 8 байт и возвращаемое значение или jmp. (Только подмножество операторов jmp, разрешенное в эпилога. Это исключительно класса операторы jmp со ссылки на память ModRM равно где поля mod ModRM равно значение 00. Запрещенное использование операторов jmp в эпилоге значение поля mod ModRM равно 01 или 10. См. в разделе таблицы A-15 в программиста AMD x86 64 архитектура том 3: общего назначения и системные инструкции, Дополнительные сведения о допустимых ссылках ModRM.). Никакой другой код может отображаться. В частности ничего не могут быть запланированы в заключительной части, включая загрузку возвращаемое значение.

Обратите внимание, что, когда указатель фрейма не используется, необходимо использовать эпилога `add RSP,constant` для отмены выделения фиксированной части стека. Она может не использовать `lea RSP,constant[RSP]` вместо этого. Это ограничение существует, код очистки имеет меньшее число шаблонов, распознаваемых при поиске эпилогов.

Следование этим правилам обеспечивает код очистки, чтобы определить, что эпилога в настоящее время выполняется и имитировать выполнение оставшейся части эпилога, что позволяет воссоздать контекст вызывающей функции.

## <a name="see-also"></a>См. также

[Программные соглашения для X64](../build/x64-software-conventions.md)