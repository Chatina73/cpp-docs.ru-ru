---
title: Импорт вызовов функций с помощью __declspec(dllimport)
description: Как и зачем использовать __declspec (dllimport) при вызове данных и функций библиотеки DLL.
ms.date: 05/03/2020
helpviewer_keywords:
- importing function calls [C++]
- dllimport attribute [C++], function call imports
- __declspec(dllimport) keyword [C++]
- function calls [C++], importing
ms.assetid: 6b53c616-0c6d-419a-8e2a-d2fff20510b3
ms.openlocfilehash: 515fbdb2824c1eaf41e822adeae1a16d3072eec4
ms.sourcegitcommit: 8a01ae145bc65f5bc90d6e47b4a1bdf47b073ee7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/04/2020
ms.locfileid: "82765725"
---
# <a name="importing-function-calls-using-__declspecdllimport"></a>Импорт вызовов функций с помощью`__declspec(dllimport)`

Создание заметок к **`__declspec(dllimport)`** вызовам с помощью метода позволяет ускорить их выполнение. **`__declspec(dllimport)`** всегда требуется для доступа к экспортированным данным библиотеки DLL.

## <a name="import-a-function-from-a-dll"></a>Импорт функции из библиотеки DLL

В следующем примере кода показано, как использовать **`__declspec(dllimport)`** для импорта вызовов функций из библиотеки DLL в приложение. Предположим, `func1` что — это функция, которая находится в библиотеке DLL, отдельно от исполняемого файла, содержащего функцию **Main** .

Без **`__declspec(dllimport)`**, учитывая следующий код:

```C
int main(void)
{
   func1();
}
```

компилятор создает код, который выглядит следующим образом:

```asm
call func1
```

и компоновщик преобразует вызов в нечто вроде следующего:

```asm
call 0x4000000         ; The address of 'func1'.
```

Если `func1` существует в другой библиотеке DLL, компоновщик не может разрешить этот адрес напрямую, так как он не позволяет узнать, какой адрес `func1` имеет значение. В 32-разрядных и 64-разрядных средах компоновщик создает преобразователь по известному адресу. В 32-разрядной среде преобразователь выглядит следующим образом:

```asm
0x40000000:    jmp DWORD PTR __imp_func1
```

Ниже `__imp_func1` приведен адрес для `func1` слота в таблице адресов импорта исполняемого файла. Все эти адреса известны компоновщику. Загрузчику необходимо обновить таблицу адресов импорта исполняемого файла во время загрузки, чтобы все работало правильно.

Вот почему использовать **`__declspec(dllimport)`** лучше: так как компоновщик не создает преобразователь, если он не требуется. Преобразователи делают код крупнее (в системах RISC это может быть несколько инструкций), что может привести к снижению производительности кэша. Если сообщить компилятору, что функция находится в библиотеке DLL, она может создать косвенный вызов.

Итак, теперь этот код:

```C
__declspec(dllimport) void func1(void);
int main(void)
{
   func1();
}
```

создает следующую инструкцию:

```asm
call DWORD PTR __imp_func1
```

Нет ни преобразователя, ни `jmp` инструкции, поэтому код будет меньше и быстрее. Вы также можете получить такой же результат без **`__declspec(dllimport)`** использования оптимизации всей программы. Дополнительные сведения см. в разделе [/GL (оптимизация всей программы)](reference/gl-whole-program-optimization.md).

Для вызовов функций в библиотеке DLL не требуется использовать косвенный вызов. Компоновщик уже знает адрес функции. Загрузка и сохранение адреса функции перед прямым вызовом занимает дополнительное время и место. Прямой вызов всегда выполняется быстрее и меньше. Вы хотите использовать **`__declspec(dllimport)`** только при вызове функций DLL извне самой библиотеки DLL. Не используйте **`__declspec(dllimport)`** для функций в библиотеке DLL при создании этой библиотеки DLL.

## <a name="see-also"></a>См. также

[Импорт в приложение](importing-into-an-application.md)
