---
title: Импорт вызовов функций с помощью объявления __declspec(dllimport)
ms.date: 11/04/2016
helpviewer_keywords:
- importing function calls [C++]
- dllimport attribute [C++], function call imports
- __declspec(dllimport) keyword [C++]
- function calls [C++], importing
ms.assetid: 6b53c616-0c6d-419a-8e2a-d2fff20510b3
ms.openlocfilehash: 1743cbba8c3046ef844f16be8e78d43c61f62606
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79442520"
---
# <a name="importing-function-calls-using-__declspecdllimport"></a>Импорт вызовов функций с помощью объявления __declspec(dllimport)

В следующем примере кода показано, как использовать **_declspec (dllimport)** для импорта вызовов функций из библиотеки DLL в приложение. Предположим, что `func1` — это функция, которая находится в библиотеке DLL, отдельно от EXE-файла, содержащего функцию **Main** .

Без **__declspec (dllimport)** , учитывая следующий код:

```
int main(void)
{
   func1();
}
```

компилятор создает код, который выглядит следующим образом:

```
call func1
```

и компоновщик преобразует вызов в нечто вроде следующего:

```
call 0x4000000         ; The address of 'func1'.
```

Если `func1` существует в другой библиотеке DLL, компоновщик не может разрешить это напрямую, так как не имеет способа узнать, какой адрес `func1`. В 16-разрядных средах компоновщик добавляет этот адрес кода в список в файле exe, который загрузчик будет исправлять во время выполнения с правильным адресом. В 32-разрядных и 64-разрядных средах компоновщик создает преобразователь, для которого он знает адрес. В 32-разрядной среде преобразователь выглядит следующим образом:

```
0x40000000:    jmp DWORD PTR __imp_func1
```

Здесь `imp_func1` адрес для слота `func1` в таблице адресов импорта exe-файла. Все адреса, таким же, известны компоновщику. Загрузчику необходимо обновить таблицу адресов импорта exe во время загрузки, чтобы все работало правильно.

Поэтому использование **__declspec (dllimport)** лучше, поскольку компоновщик не создает преобразователь, если он не требуется. Преобразователи делают код крупнее (в системах RISC это может быть несколько инструкций), что может привести к снижению производительности кэша. Если сообщить компилятору, что функция находится в библиотеке DLL, она может создать косвенный вызов.

Итак, теперь этот код:

```
__declspec(dllimport) void func1(void);
int main(void)
{
   func1();
}
```

создает следующую инструкцию:

```
call DWORD PTR __imp_func1
```

Отсутствует преобразователь и инструкция `jmp`, поэтому код будет меньше и быстрее.

С другой стороны, для вызовов функций внутри библиотеки DLL нежелательно использовать косвенный вызов. Вы уже знакомы с адресом функции. Поскольку для загрузки и сохранения адреса функции перед косвенным вызовом требуется время и пространство, прямой вызов всегда выполняется быстрее и меньше. Вы хотите использовать только **__declspec (dllimport)** при вызове функций DLL извне самой библиотеки DLL. Не используйте **__declspec (dllimport)** для функций внутри библиотеки DLL при построении этой библиотеки DLL.

## <a name="see-also"></a>См. также раздел

[Импорт в приложение](importing-into-an-application.md)
