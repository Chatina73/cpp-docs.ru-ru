---
title: Импорт вызовов функций с помощью __declspec(dllimport)
ms.date: 11/04/2016
f1_keywords:
- __declspec
- dllimport
helpviewer_keywords:
- importing function calls [C++]
- dllimport attribute [C++], function call imports
- __declspec(dllimport) keyword [C++]
- function calls [C++], importing
ms.assetid: 6b53c616-0c6d-419a-8e2a-d2fff20510b3
ms.openlocfilehash: 513e6bd7b1120dd710852ab61aa7603bba74907e
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50498232"
---
# <a name="importing-function-calls-using-declspecdllimport"></a>Импорт вызовов функций с помощью __declspec(dllimport)

В следующем примере кода показано, как использовать **_declspec(dllimport)** Импорт вызовов функций из библиотеки DLL в приложение. Предполагается, что `func1` является функцией, которая хранится в библиотеке DLL, отдельно от файла .exe, содержащий **основной** функции.

Без **__declspec(dllimport)**, учитывая этот код:

```
int main(void)
{
   func1();
}
```

компилятор создает код, который выглядит следующим образом:

```
call func1
```

и компоновщик преобразует вызов подобным образом:

```
call 0x4000000         ; The address of 'func1'.
```

Если `func1` существует в другой библиотеке DLL, компоновщик не может ее распознать, поскольку в нем нет способа узнать об адресе `func1` является. В 16-разрядных сред компоновщик добавляет адрес этого кода в список в файл .exe, загрузчик бы patch во время выполнения с правильным адресом. В 32-разрядных и 64-разрядных сред компоновщик создает преобразователь адресов, из которых он знает адрес. В 32-разрядной среде преобразователь выглядит следующим образом:

```
0x40000000:    jmp DWORD PTR __imp_func1
```

Здесь `imp_func1` адрес `func1` слот в таблице адресов импорта файла .exe. Таким образом, все адреса известны в компоновщик. Загрузчик имеет только для обновления таблицы адресов импорта файла .exe во время загрузки для правильной работы.

Таким образом, использование **__declspec(dllimport)** лучше, так как компоновщик не создает преобразователь, если не требуется. Преобразователи расширяют код (в системах RISC, он может быть несколько) и может привести к снижению производительности вашего кэша. Если вы предписываете компилятору, что функция находится в библиотеке DLL, он может создавать непрямой вызов для вас.

Итак, теперь следующим кодом:

```
__declspec(dllimport) void func1(void);
int main(void)
{
   func1();
}
```

создает следующую инструкцию:

```
call DWORD PTR __imp_func1
```

Нет преобразователь и нет `jmp` инструкции, что код компактнее и быстрее.

С другой стороны для вызовов функций внутри библиотеки DLL, вы не хотите использовать непрямой вызов. Вы уже знаете адрес функции. Так как требуется время и место для загрузки и сохранить адрес функции перед непрямой вызов, прямой вызов всегда быстрее и занимает меньше места. Вы хотите использовать **__declspec(dllimport)** при вызове функций DLL из самой библиотеке. Не используйте **__declspec(dllimport)** на функции внутри библиотеки DLL при построении библиотеки DLL.

## <a name="see-also"></a>См. также

[Импорт в приложение](../build/importing-into-an-application.md)