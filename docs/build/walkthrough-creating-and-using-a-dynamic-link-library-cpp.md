---
title: Пошаговое руководство. Создание и использование собственной библиотеки динамическойC++компоновки ()
description: Сведения о создании библиотеки динамической компоновки Windows (DLL) в Visual Studio с использованием C++.
ms.custom: conceptual
ms.date: 08/22/2019
helpviewer_keywords:
- libraries [C++], DLLs
- DLLs [C++], walkthroughs
ms.assetid: 3ae94848-44e7-4955-bbad-7d40f493e941
ms.openlocfilehash: 37dc59dfb77af9fff240c0d44b21de84b17d073b
ms.sourcegitcommit: a8ef52ff4a4944a1a257bdaba1a3331607fb8d0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77127846"
---
# <a name="walkthrough-create-and-use-your-own-dynamic-link-library-c"></a>Пошаговое руководство. Создание и использование собственной библиотеки динамическойC++компоновки ()

В этом пошаговом руководстве показано, как использовать интегрированную среду разработки Visual Studio для создания собственной библиотеки динамической компоновки (DLL), написанной C++ в Microsoft (компилятором MSVC). Затем показано, как использовать библиотеку DLL из другого C++ приложения. Библиотеки DLL (также называемые *общими библиотеками* в операционных системах на основе UNIX) являются одним из наиболее полезных типов компонентов Windows. Их можно использовать в качестве способа совместного использования кода и ресурсов, а также для уменьшения размера приложений. Библиотеки DLL могут упростить обслуживание и расширение приложений.

В этом пошаговом руководстве вы создадите библиотеку DLL, которая реализует некоторые математические функции. Затем вы создадите консольное приложение, использующее функции из библиотеки DLL. Вы также получите введение в некоторые приемы программирования и соглашения, используемые в библиотеках DLL Windows.

В этом пошаговом руководстве рассматриваются следующие задачи:

- Создание проекта библиотеки DLL в Visual Studio.

- Добавление экспортированных функций и переменных в библиотеку DLL.

- Создание проекта "Консольное приложение" в Visual Studio.

- Использование в консольном приложении функций и переменных, импортированных из библиотеки DLL.

- Запуск готового приложения.

Как и в случае со статически связанной библиотекой, Библиотека DLL _экспортирует_ переменные, функции и ресурсы по имени. Клиентское приложение _импортирует_ имена для использования этих переменных, функций и ресурсов. В отличие от статически компонуемой библиотеки, Windows соединяет импорт в вашем приложении с экспортом в библиотеку DLL во время загрузки или выполнения, а не во время компоновки. Для выполнения этих подключений Windows требуются дополнительные сведения, которые не являются частью стандартной модели компиляции C++. Чтобы предоставить эти дополнительные сведения, компилятор MSVC реализует некоторые специальные расширения Майкрософт для C++. Мы рассмотрим эти расширения далее.

В этом пошаговом руководстве создаются два решения Visual Studio. Первое решение создает библиотеку DLL, а второе — клиентское приложение. Библиотека DLL использует соглашение о вызовах C. Его можно вызывать из приложений, написанных на других языках программирования, при условии, что платформа, соглашения о вызовах и соглашения о связывании совпадают. Клиентское приложение использует _неявную компоновку_, в рамках которой Windows связывает приложение с библиотекой DLL во время загрузки. Эта компоновка позволяет приложению вызывать функции, предоставляемые библиотекой DLL, точно так же, как функции в библиотеке статической компоновки.

В этом пошаговом руководстве не рассматриваются некоторые общие ситуации. Код не показывает использование C++ библиотек DLL другими языками программирования. Он не показывает, как [создать библиотеку DLL с ресурсами](creating-a-resource-only-dll.md)или использовать [явную компоновку](linking-an-executable-to-a-dll.md#linking-explicitly) для загрузки библиотек DLL во время выполнения, а не во время загрузки. Если вы уверены, вы можете использовать КОМПИЛЯТОРОМ MSVC и Visual Studio, чтобы выполнить все эти действия.

Ссылки на дополнительные сведения о DLL см. в статье [Создание библиотек DLL на C/C++ в Visual Studio](dlls-in-visual-cpp.md). Дополнительные сведения о неявной компоновке и явной компоновке см. [в разделе Определение используемого метода связывания](linking-an-executable-to-a-dll.md#determining-which-linking-method-to-use). Сведения о создании C++ библиотек DLL для использования с языками программирования, использующими соглашения о компоновках c-Language, см. [в разделе Экспорт C++ функций для использования в исполняемых файлах языка c](exporting-cpp-functions-for-use-in-c-language-executables.md). Дополнительные сведения о том, как создавать библиотеки DLL для использования с языками .NET, см. в статье [Вызов функций библиотек DLL из приложений Visual Basic](calling-dll-functions-from-visual-basic-applications.md).

## <a name="prerequisites"></a>предварительные требования

- Компьютер под управлением Microsoft Windows 7 или более поздних версий. Для обеспечения оптимальной среды разработки рекомендуется использовать Windows 10.

::: moniker range=">=vs-2017"

- Копия Visual Studio. Сведения о скачивании и установке Visual Studio см. в [этой статье](/visualstudio/install/install-visual-studio). Когда вы запускаете установщик, убедитесь, что установлена рабочая нагрузка **Разработка классических приложений на C++** . Не беспокойтесь, если вы не установили эту рабочую нагрузку при установке Visual Studio. Вы можете снова запустить установщик и установить ее сейчас.

   ![Разработка классических приложений на C++](media/desktop-development-with-cpp.png "разработка классических приложений на C++;")

::: moniker-end

::: moniker range="vs-2015"

- Копия Visual Studio. Сведения о том, как скачать и установить Visual Studio 2015, см. в [статье Установка Visual studio 2015](/visualstudio/install/install-visual-studio-2015?view=vs-2015). Используйте **выборочную** установку для установки C++ компилятора и средств, так как они не устанавливаются по умолчанию.

::: moniker-end

- Базовые значения об использовании интегрированной среды разработки Visual Studio. Если вы уже использовали классические приложения для Windows, вы, вероятно, справитесь. Общие сведения см. в [обзоре возможностей интегрированной среды разработки Visual Studio](/visualstudio/ide/visual-studio-ide).

- Основные навыки владения языком C++. Не волнуйтесь, мы не будем делать ничего сложного.

::: moniker range="vs-2017"

> [!NOTE]
> В этом пошаговом руководстве предполагается, что вы используете Visual Studio 2017 версии 15,9 или более поздней. Некоторые более ранние версии Visual Studio 2017 имели дефекты в шаблонах кода или использовали разные диалоговые окна пользовательского интерфейса. Чтобы избежать проблем, используйте Visual Studio Installer для обновления Visual Studio 2017 до версии 15,9 или более поздней.

::: moniker-end

## <a name="create-the-dll-project"></a>Создание проекта библиотеки DLL

Этот набор задач позволяет создать проект для библиотеки DLL, добавить код и выполнить его сборку. Для начала запустите IDE Visual Studio и выполните вход, если это необходимо. Эти инструкции немного различаются в зависимости от используемой версии Visual Studio. Убедитесь, что в элементе управления в верхнем левом углу этой страницы выбрана правильная версия.

::: moniker range=">=vs-2019"

### <a name="to-create-a-dll-project-in-visual-studio-2019"></a>Создание проекта библиотеки DLL в Visual Studio 2019

1. В строке меню последовательно выберите **файл** > **создать** > **проект** , чтобы открыть диалоговое окно **Создание нового проекта** .

   ![Создание нового проекта библиотеки DLL](media/create-new-dll-project-2019.png "Создание проекта Маслибрари")

1. В верхней части диалогового окна для параметра **Язык** установите значение **C++** , для параметра **Платформа** — значение **Windows**, а для параметра **Тип проекта** — значение **Библиотека**.

1. В отфильтрованном списке типов проектов выберите **Библиотека динамической компоновки (DLL)** , а затем нажмите кнопку **Далее**.

1. На странице **Настройка нового проекта** введите *маслибрари* в поле **имя проекта** , чтобы указать имя проекта. Оставьте значения **расположения** и **имени решения** по умолчанию. Задайте **решение** для **создания нового решения**. Снимите флажок **размещать решение и проект в том же каталоге,** если он установлен.

1. Нажмите кнопку **Создать**, чтобы создать проект.

После создания решения можно просмотреть созданный проект и исходные файлы в окне **Обозреватель решений** в Visual Studio.

![Созданное решение в Visual Studio](media/mathlibrary-solution-explorer-162.png "Созданное решение в Visual Studio")

::: moniker-end

::: moniker range="vs-2017"

### <a name="to-create-a-dll-project-in-visual-studio-2017"></a>Создание проекта библиотеки DLL в Visual Studio 2017

1. В строке меню последовательно выберите **файл** > **создать** > **проект** , чтобы открыть диалоговое окно **Создание проекта** .

1. В левой области диалогового окна **Новый проект** выберите **установлено** > **Visual C++**  > **Рабочий стол Windows**. В центральной области выберите **Библиотека динамической компоновки (DLL)** . Введите *маслибрари* в поле **имя** , чтобы указать имя проекта. Оставьте значения **расположения** и **имени решения** по умолчанию. Задайте **решение** для **создания нового решения**. Установите флажок **создать каталог для решения** , если он не установлен.

   ![Назовите проект Маслибрари.](media/mathlibrary-new-project-name-159.png "Назовите проект Маслибрари.")

1. Нажмите кнопку **ОК**, чтобы создать проект.

После создания решения можно просмотреть созданный проект и исходные файлы в окне **Обозреватель решений** в Visual Studio.

![Созданное решение в Visual Studio](media/mathlibrary-solution-explorer-159.png "Созданное решение в Visual Studio")

::: moniker-end

::: moniker range="vs-2015"

### <a name="to-create-a-dll-project-in-visual-studio-2015-and-older-versions"></a>Создание проекта DLL в Visual Studio 2015 и более ранних версий

1. В строке меню щелкните **Файл** > **Создать** > **Проект**.

1. В левой области диалогового окна **Новый проект** разверните узлы **Установленные** > **Шаблоны** и выберите **Visual C++** , а затем в центральной области щелкните **Консольное приложение Win32**. Введите *маслибрари* в поле ввода **имя** , чтобы указать имя проекта. Оставьте значения **расположения** и **имени решения** по умолчанию. Задайте **решение** для **создания нового решения**. Установите флажок **создать каталог для решения** , если он не установлен.

   ![Назовите проект Маслибрари.](media/mathlibrary-project-name.png "Назовите проект Маслибрари.")

1. Нажмите кнопку **​​ОК**, чтобы закрыть диалоговое окно **Новый проект**, и запустите **мастер приложений Win32**.

   ![Общие сведения о мастере приложений Win32](media/mathlibrary-project-wizard-1.png "Общие сведения о мастере приложений Win32")

1. Нажмите кнопку **Далее**. На странице **Параметры приложения** в поле **Тип приложения** выберите пункт **DLL**.

   ![Создание библиотеки DLL в мастере приложений Win32](media/mathlibrary-project-wizard-2.png "Создание библиотеки DLL в мастере приложений Win32")

1. Нажмите кнопку **Готово** , чтобы создать проект.

Когда мастер завершит создание решения, вы сможете увидеть созданный проект вместе с исходными файлами в окне **обозревателя решений** в Visual Studio.

![Созданное решение в Visual Studio](media/mathlibrary-solution-explorer-153.png "Созданное решение в Visual Studio")

::: moniker-end

Пока эта библиотека DLL ничего не делает. Далее предстоит создать файл заголовка для объявления функций, экспортируемых библиотекой DLL, а затем добавить определения функций в библиотеку DLL, чтобы сделать ее более полезной.

### <a name="to-add-a-header-file-to-the-dll"></a>Добавление файла заголовка в библиотеку DLL

1. Чтобы создать файл заголовка для функций, последовательно щелкните **Проект** > **Добавить новый элемент**.

1. В диалоговом окне **Добавление нового элемента** в левой области щелкните **Visual C++** . В центральной области выберите **Заголовочный файл (.h)** . Укажите *маслибрари. h* в качестве имени файла заголовка.

   ![Добавить заголовок в диалоговом окне "Добавление нового элемента"](media/mathlibrary-add-new-item-header-file.png "Добавить заголовочный файл в диалоговом окне "Добавление нового элемента"")

1. Нажмите кнопку **​​Добавить**, чтобы создать пустой файл заголовка, который отображается в новом окне редактора.

   ![Пустой файл Маслибрари. h в редакторе](media/edit-empty-mathlibrary-header.png "Пустой файл Маслибрари. h в редакторе")

1. Замените все содержимое этого файла заголовка следующим кодом:

   ```cpp
   // MathLibrary.h - Contains declarations of math functions
   #pragma once

   #ifdef MATHLIBRARY_EXPORTS
   #define MATHLIBRARY_API __declspec(dllexport)
   #else
   #define MATHLIBRARY_API __declspec(dllimport)
   #endif

   // The Fibonacci recurrence relation describes a sequence F
   // where F(n) is { n = 0, a
   //               { n = 1, b
   //               { n > 1, F(n-2) + F(n-1)
   // for some initial integral values a and b.
   // If the sequence is initialized F(0) = 1, F(1) = 1,
   // then this relation produces the well-known Fibonacci
   // sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

   // Initialize a Fibonacci relation sequence
   // such that F(0) = a, F(1) = b.
   // This function must be called before any other function.
   extern "C" MATHLIBRARY_API void fibonacci_init(
       const unsigned long long a, const unsigned long long b);

   // Produce the next value in the sequence.
   // Returns true on success and updates current value and index;
   // false on overflow, leaves current value and index unchanged.
   extern "C" MATHLIBRARY_API bool fibonacci_next();

   // Get the current value in the sequence.
   extern "C" MATHLIBRARY_API unsigned long long fibonacci_current();

   // Get the position of the current value in the sequence.
   extern "C" MATHLIBRARY_API unsigned fibonacci_index();
   ```

Этот файл заголовка объявляет некоторые функции для создания обобщенной последовательности Фибоначчи, исходя из двух начальных значений. Вызов `fibonacci_init(1, 1)` создает знакомую последовательность чисел Фибоначчи.

Обратите внимание на операторы препроцессора в верхней части файла. Новый шаблон проекта для проекта DLL добавляет **экспорты _имяПроекта_&#95;** в определенные макросы препроцессора. В этом примере Visual Studio определяет **MATHLIBRARY_EXPORTS** при сборке проекта библиотеки DLL MathLibrary.

Когда макрос **MATHLIBRARY_EXPORTS** определен, макрос **MATHLIBRARY_API** устанавливает модификатор `__declspec(dllexport)` в объявлениях функций. Этот модификатор указывает компилятору и компоновщику экспортировать функцию или переменную из библиотеки DLL для использования другими приложениями. Если **MATHLIBRARY_EXPORTS** не определен, например, когда файл заголовка включен клиентским приложением, **MATHLIBRARY_API** применяет модификатор `__declspec(dllimport)` к объявлениям. Этот модификатор оптимизирует импорт функции или переменной в приложении. Дополнительные сведения см. в статье [dllexport, dllimport](../cpp/dllexport-dllimport.md).

### <a name="to-add-an-implementation-to-the-dll"></a>Добавление реализации в библиотеку DLL

::: moniker range=">=vs-2019"

1. В **Обозреватель решений**щелкните правой кнопкой мыши узел **исходные файлы** и выберите команду **добавить** > **новый элемент**. Создайте новый CPP-файл с именем *маслибрари. cpp*, аналогично добавлению нового файла заголовка на предыдущем шаге.

1. В окне редактора выберите вкладку **MathLibrary.cpp**, если она уже открыта. Если нет, в **Обозреватель решений**дважды щелкните **маслибрари. cpp** в папке **исходных файлов** проекта **маслибрари** , чтобы открыть его.

1. В редакторе замените содержимое файла MathLibrary.cpp следующим кодом:

   ```cpp
   // MathLibrary.cpp : Defines the exported functions for the DLL.
   #include "pch.h" // use stdafx.h in Visual Studio 2017 and earlier
   #include <utility>
   #include <limits.h>
   #include "MathLibrary.h"

   // DLL internal state variables:
   static unsigned long long previous_;  // Previous value, if any
   static unsigned long long current_;   // Current sequence value
   static unsigned index_;               // Current seq. position

   // Initialize a Fibonacci relation sequence
   // such that F(0) = a, F(1) = b.
   // This function must be called before any other function.
   void fibonacci_init(
       const unsigned long long a,
       const unsigned long long b)
   {
       index_ = 0;
       current_ = a;
       previous_ = b; // see special case when initialized
   }

   // Produce the next value in the sequence.
   // Returns true on success, false on overflow.
   bool fibonacci_next()
   {
       // check to see if we'd overflow result or position
       if ((ULLONG_MAX - previous_ < current_) ||
           (UINT_MAX == index_))
       {
           return false;
       }

       // Special case when index == 0, just return b value
       if (index_ > 0)
       {
           // otherwise, calculate next sequence value
           previous_ += current_;
       }
       std::swap(current_, previous_);
       ++index_;
       return true;
   }

   // Get the current value in the sequence.
   unsigned long long fibonacci_current()
   {
       return current_;
   }

   // Get the current index position in the sequence.
   unsigned fibonacci_index()
   {
       return index_;
   }
   ```

::: moniker-end

::: moniker range="<=vs-2017"

1. В окне редактора выберите вкладку **MathLibrary.cpp**, если она уже открыта. Если нет, в **Обозреватель решений**дважды щелкните **маслибрари. cpp** в папке **исходных файлов** проекта **маслибрари** , чтобы открыть его.

1. В редакторе замените содержимое файла MathLibrary.cpp следующим кодом:

   ```cpp
   // MathLibrary.cpp : Defines the exported functions for the DLL.
   #include "stdafx.h" // use pch.h in Visual Studio 2019 and later
   #include <utility>
   #include <limits.h>
   #include "MathLibrary.h"

   // DLL internal state variables:
   static unsigned long long previous_;  // Previous value, if any
   static unsigned long long current_;   // Current sequence value
   static unsigned index_;               // Current seq. position

   // Initialize a Fibonacci relation sequence
   // such that F(0) = a, F(1) = b.
   // This function must be called before any other function.
   void fibonacci_init(
       const unsigned long long a,
       const unsigned long long b)
   {
       index_ = 0;
       current_ = a;
       previous_ = b; // see special case when initialized
   }

   // Produce the next value in the sequence.
   // Returns true on success, false on overflow.
   bool fibonacci_next()
   {
       // check to see if we'd overflow result or position
       if ((ULLONG_MAX - previous_ < current_) ||
           (UINT_MAX == index_))
       {
           return false;
       }

       // Special case when index == 0, just return b value
       if (index_ > 0)
       {
           // otherwise, calculate next sequence value
           previous_ += current_;
       }
       std::swap(current_, previous_);
       ++index_;
       return true;
   }

   // Get the current value in the sequence.
   unsigned long long fibonacci_current()
   {
       return current_;
   }

   // Get the current index position in the sequence.
   unsigned fibonacci_index()
   {
       return index_;
   }
   ```

::: moniker-end

Чтобы убедиться, что все работает, скомпилируйте библиотеку динамической компоновки. Чтобы выполнить компиляцию, последовательно выберите **Сборка** > **Собрать решение**. Библиотека DLL и связанные выходные данные компилятора помещаются в папку с именем *Отладка* непосредственно под папкой решения. При создании сборки выпуска выходные данные помещаются в папку с именем *Release*. Результат должен выглядеть следующим образом.

::: moniker range=">=vs-2019"

```Output
1>------ Build started: Project: MathLibrary, Configuration: Debug Win32 ------
1>pch.cpp
1>dllmain.cpp
1>MathLibrary.cpp
1>Generating Code...
1>   Creating library C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.lib and object C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.exp
1>MathLibrary.vcxproj -> C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.dll
========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========
```

::: moniker-end

::: moniker range="vs-2017"

```Output
1>------ Build started: Project: MathLibrary, Configuration: Debug Win32 ------
1>stdafx.cpp
1>dllmain.cpp
1>MathLibrary.cpp
1>Generating Code...
1>   Creating library C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.lib and object C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.exp
1>MathLibrary.vcxproj -> C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.dll
========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========
```

::: moniker-end

::: moniker range="vs-2015"

```Output
1>------ Build started: Project: MathLibrary, Configuration: Debug Win32 ------
1>MathLibrary.cpp
1>dllmain.cpp
1>Generating Code...
1>   Creating library C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.lib and object C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.exp
1>MathLibrary.vcxproj -> C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.dll
1>MathLibrary.vcxproj -> C:\Users\username\Source\Repos\MathLibrary\Debug\MathLibrary.pdb (Partial PDB)
========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========
```

::: moniker-end

Поздравляем, вы создали библиотеку DLL с помощью Visual Studio! Далее вы создадите клиентское приложение, которое использует функции, экспортируемые из библиотеки DLL.

## <a name="create-a-client-app-that-uses-the-dll"></a>Создание клиентского приложения, которое использует библиотеку DLL

При создании библиотеки DLL Подумайте о том, как клиентские приложения могут его использовать. Чтобы вызвать функции или получить доступ к данным, экспортированным библиотекой DLL, исходный код клиента должен иметь объявления, доступные во время компиляции. Во время компоновки компоновщику требуются сведения для разрешения вызовов функций или доступа к данным. Библиотека DLL предоставляет эти сведения в *библиотеке импорта*— файле, который содержит сведения о поиске функций и данных вместо фактического кода. Во время выполнения библиотека DLL должна быть доступна клиенту в месте, которое может найти операционная система.

Независимо от того, являетесь ли оно собственным или сторонним разработчиком, вашему проекту клиентского приложения требуется несколько фрагментов информации для использования библиотеки DLL. Ему необходимо найти заголовки, в которых объявляются экспорты DLL, библиотеки импорта для компоновщика и саму библиотеку DLL. Одним из решений является копирование всех этих файлов в клиентский проект. Для сторонних библиотек DLL, которые вряд ли изменятся во время разработки вашего клиента, этот метод может быть лучшим способом их использования. Однако, когда вы также создаете библиотеку DLL, лучше избегать дублирования. Если создать локальную копию DLL-файлов, находящихся под разработкой, вы можете случайно изменить файл заголовка в одной копии, но не в другом, или использовать устаревшую библиотеку.

Чтобы избежать несинхронизированного кода, мы рекомендуем задать путь включения в проекте клиента, чтобы включить файлы заголовков DLL непосредственно из проекта DLL. Кроме того, укажите путь к библиотеке в своем клиентском проекте, чтобы добавить библиотеки импорта DLL из проекта DLL. И, наконец, скопируйте сборку DLL из проекта DLL в выходной каталог сборки клиента. Этот шаг позволяет вашему клиентскому приложению использовать тот же код библиотеки DLL, который вы создали.

::: moniker range=">=vs-2019"

### <a name="to-create-a-client-app-in-visual-studio"></a>Создание клиентского приложения в Visual Studio

1. В строке меню последовательно выберите **файл** > **создать** > **проект** , чтобы открыть диалоговое окно **Создание нового проекта** .

1. В верхней части диалогового окна для параметра **Язык** выберите значение **C++** , для параметра **Платформа** — значение **Windows**, а для параметра **Тип проекта** — значение **Консоль**.

1. В отфильтрованном списке типов проектов щелкните **Консольное приложение**, а затем нажмите кнопку **Далее**.

1. На странице **Настройка нового проекта** введите *масклиент* в поле **имя проекта** , чтобы указать имя проекта. Оставьте значения **расположения** и **имени решения** по умолчанию. Задайте **решение** для **создания нового решения**. Снимите флажок **размещать решение и проект в том же каталоге,** если он установлен.

   ![Назовите клиентский проект](media/mathclient-project-name-2019.png "Назовите клиентский проект")

1. Нажмите кнопку **Создать**, чтобы создать клиентский проект.

Для вас создается минимальный проект консольного приложения. Имя главного исходного файла будет совпадать с ранее введенным именем проекта. В этом примере используется имя **MathClient.cpp**. Вы можете создать проект, но он еще не использует вашу библиотеку DLL.

::: moniker-end

::: moniker range="vs-2017"

### <a name="to-create-a-client-app-in-visual-studio-2017"></a>Создание клиентского приложения в Visual Studio 2017

1. Чтобы C++ создать приложение, использующее СОЗДАННУЮ библиотеку DLL, в строке меню выберите **файл** > **Новый** > **проект**.

1. В левой области диалогового окна **Новый проект** выберите **Классическое приложение Windows** в разделе **Установленные** > **Visual C++** . В центральной области выберите **консольное приложение Windows**. Укажите имя проекта *масклиент*в поле ввода **имя** .  Оставьте значения **расположения** и **имени решения** по умолчанию. Задайте **решение** для **создания нового решения**. Установите флажок **создать каталог для решения** , если он не установлен.

   ![Назовите клиентский проект](media/mathclient-new-project-name-159.png "Назовите клиентский проект")

1. Нажмите кнопку **ОК** , чтобы создать проект клиентского приложения.

Для вас создается минимальный проект консольного приложения. Имя главного исходного файла будет совпадать с ранее введенным именем проекта. В этом примере используется имя **MathClient.cpp**. Вы можете создать проект, но он еще не использует вашу библиотеку DLL.

::: moniker-end

::: moniker range="vs-2015"

### <a name="to-create-a-client-app-in-visual-studio-2015"></a>Создание клиентского приложения в Visual Studio 2015

1. Чтобы C++ создать приложение, использующее СОЗДАННУЮ библиотеку DLL, в строке меню выберите **файл** > **Новый** > **проект**.

1. В левой области диалогового окна **Новый проект** щелкните **Win32** в разделе **Установленные** > **Шаблоны** > **Visual C++** . В центральной области выберите **Консольное приложение Win32**. Укажите имя проекта *масклиент*в поле ввода **имя** . Оставьте значения **расположения** и **имени решения** по умолчанию. Задайте **решение** для **создания нового решения**. Установите флажок **создать каталог для решения** , если он не установлен.

   ![Назовите клиентский проект](media/mathclient-project-name.png "Назовите клиентский проект")

1. Нажмите кнопку **​​ОК**, чтобы закрыть диалоговое окно **Новый проект**, и запустите **мастер приложений Win32**. На странице **Обзор** диалогового окна **Мастер приложений Win32** нажмите кнопку **Далее** .

1. На странице **Параметры приложения** в поле **Тип приложения** выберите пункт **Консольное приложение**, если он еще не выбран.

1. Нажмите кнопку **Готово** , чтобы создать проект.

После завершения работы мастера создается минимальный проект консольного приложения. Имя главного исходного файла будет совпадать с ранее введенным именем проекта. В этом примере используется имя **MathClient.cpp**. Вы можете создать проект, но он еще не использует вашу библиотеку DLL.

::: moniker-end

Затем для вызова функций Маслибрари в исходном коде проект должен содержать файл *маслибрари. h* . Этот файл заголовка можно скопировать в проект клиентского приложения, а затем добавить его в проект как существующий элемент. Этот метод подходит для сторонних библиотек. Однако если вы работаете с кодом для библиотеки DLL и клиента одновременно, файлы заголовков могут оказаться несинхронизированными. Чтобы избежать этой проблемы, задайте в проекте путь к **дополнительным каталогам включения** , чтобы включить путь к исходному заголовку.

### <a name="to-add-the-dll-header-to-your-include-path"></a>Добавление заголовка библиотеки DLL в путь включения

1. Щелкните правой кнопкой мыши узел **MathClient** в **обозревателе решений**, чтобы открыть диалоговое окно **Страницы свойств**.

1. В раскрывающемся списке **Конфигурация** выберите пункт **все конфигурации** , если они еще не выбраны.

1. В области слева выберите **Свойства конфигурации** > **Общие**сведения о **языкеC++ C/**  > .

1. На панели свойств щелкните раскрывающийся элемент управления рядом с полем ввода параметра **Дополнительные каталоги включаемых файлов**, а затем щелкните **Правка**.

   ![Изменение свойства дополнительных каталогов включения](media/mathclient-additional-include-directories-property.png "Изменение свойства дополнительных каталогов включения")

1. Дважды щелкните в верхней панели диалогового окна **Дополнительные каталоги включаемых файлов**, чтобы включить элемент управления "Поле ввода". Или щелкните значок папки, чтобы создать новую запись.

1. В элементе управления "Поле ввода" укажите путь к расположению файла заголовка **MathLibrary.h**. Чтобы перейти к нужной папке, можно выбрать элемент управления с многоточием ( **...** ).

   Можно также ввести относительный путь от исходных файлов клиента в папку, содержащую файлы заголовков DLL. Если следовать инструкциям по размещению клиентского проекта в отдельном решении из библиотеки DLL, относительный путь должен выглядеть следующим образом:

   `..\..\MathLibrary\MathLibrary`

   Если библиотеки DLL и клиентские проекты находятся в одном решении, относительный путь может выглядеть следующим образом:

   `..\MathLibrary`

   Если библиотеки DLL и клиентские проекты находятся в других папках, измените относительный путь для соответствия. Или используйте элемент управления многоточием для поиска папки.

   ![Добавление расположения заголовка в свойство дополнительных включаемых каталогов](media/mathclient-additional-include-directories.png "Добавление расположения заголовка в свойство дополнительных включаемых каталогов")

1. После ввода пути к файлу заголовка в диалоговом окне **Дополнительные каталоги включаемых** файлов нажмите кнопку **ОК** . В диалоговом окне **страницы свойств** нажмите кнопку **ОК** , чтобы сохранить изменения.

Теперь можно добавить файл **MathLibrary.h** и использовать функции, которые он объявляет, в вашем клиентском приложении. Замените содержимое файла **MathClient.cpp**, используя следующий код:

```cpp
// MathClient.cpp : Client app for MathLibrary DLL.
// #include "pch.h" Uncomment for Visual Studio 2017 and earlier
#include <iostream>
#include "MathLibrary.h"

int main()
{
    // Initialize a Fibonacci relation sequence.
    fibonacci_init(1, 1);
    // Write out the sequence values until overflow.
    do {
        std::cout << fibonacci_index() << ": "
            << fibonacci_current() << std::endl;
    } while (fibonacci_next());
    // Report count of values written before overflow.
    std::cout << fibonacci_index() + 1 <<
        " Fibonacci sequence values fit in an " <<
        "unsigned 64-bit integer." << std::endl;
}
```

Этот код может быть скомпилирован, но не связан. Если вы создаете клиентское приложение, в списке ошибок появится несколько ошибок LNK2019. Причина в том, что в проекте отсутствуют некоторые сведения: вы не указали, что проект еще не зависит от библиотеки *маслибрари. lib* . И вы не указали компоновщику, как найти файл *маслибрари. lib* .

Чтобы устранить эту проблему, можно скопировать файл библиотеки непосредственно в проект клиентского приложения. Компоновщик сможет найти и использовать его автоматически. Однако если и библиотека, и клиентское приложение находятся в разработке, это может привести к изменениям в одной копии, которая не отображается в другой. Чтобы избежать этой проблемы, можно задать свойство **Дополнительные зависимости** , чтобы сообщить системе сборки о том, что ваш проект зависит от *маслибрари. lib*. Кроме того, можно задать в проекте путь к **дополнительным каталогам библиотек** , чтобы включить путь к исходной библиотеке при компоновке.

### <a name="to-add-the-dll-import-library-to-your-project"></a>Добавление библиотеки импорта DLL в проект

1. Щелкните правой кнопкой мыши узел **масклиент** в **Обозреватель решений** и выберите **Свойства** , чтобы открыть диалоговое окно **страницы свойств** .

1. В раскрывающемся списке **Конфигурация** выберите пункт **все конфигурации** , если они еще не выбраны. Это гарантирует, что любые изменения свойств применяются к сборкам отладки и выпуска.

1. В левой области выберите **Свойства конфигурации** > **Компоновщик** > **входные данные**. На панели свойств щелкните раскрывающийся элемент управления рядом с полем ввода параметра **Дополнительные зависимости**, а затем щелкните **Правка**.

   ![Изменение свойства "Дополнительные зависимости"](media/mathclient-additional-dependencies-property.png "Изменение свойства "Дополнительные зависимости"")

1. В диалоговом окне **Дополнительные зависимости** добавьте *маслибрари. lib* в список в верхнем элементе управления Edit.

   ![Добавление зависимости библиотеки](media/mathclient-additional-dependencies.png "Добавление зависимости библиотеки")

1. Нажмите кнопку **OK**, чтобы вернуться в диалоговое окно **Страницы свойств**.

1. В левой области выберите **Свойства конфигурации** > **Компоновщик** > **Общие**. На панели свойств щелкните раскрывающийся элемент управления рядом с полем ввода параметра **Дополнительные каталоги библиотек**, а затем щелкните **Правка**.

   ![Изменение свойства дополнительных каталогов библиотеки](media/mathclient-additional-library-directories-property.png "Изменение свойства дополнительных каталогов библиотеки")

1. Дважды щелкните в верхней панели диалогового окна **Дополнительные каталоги библиотек**, чтобы включить элемент управления "Поле ввода". В элементе управления "Поле ввода" укажите путь к расположению файла **MathLibrary.lib**. По умолчанию он находится в папке с именем *Debug* непосредственно в папке DLL-решения. При создании сборки выпуска файл помещается в папку с именем *Release*. Можно использовать макрос `$(IntDir)`, чтобы компоновщик мог найти библиотеку DLL независимо от типа создаваемой сборки. Если следовать инструкциям по размещению клиентского проекта в отдельном решении из проекта DLL, относительный путь должен выглядеть следующим образом:

   `..\..\MathLibrary\$(IntDir)`

   Если библиотеки DLL и клиентские проекты находятся в других расположениях, измените относительный путь для соответствия.

   ![Добавление каталога библиотеки](media/mathclient-additional-library-directories.png "Добавление каталога библиотеки")

1. Как только вы ввели путь к файлу библиотеки, в диалоговом окне **Дополнительные каталоги библиотек** нажмите кнопку **ОК**, чтобы вернуться в диалоговое окно **Страницы свойств**. Нажмите кнопку **ОК** , чтобы сохранить изменения свойств.

Ваше клиентское приложение теперь можно компилировать и компоновать, но в нем по-прежнему нет всего необходимого для запуска. Когда операционная система загружает ваше приложение, оно ищет библиотеку DLL MathLibrary. Если она не может найти библиотеку DLL в определенных системных каталогах, в пути среды или локальном каталоге приложения, загрузка завершается сбоем. В зависимости от операционной системы вы увидите сообщение об ошибке следующего вида:

![Ошибка "Библиотека DLL Маслибрари не найдена"](media/mathclient-system-error-mathlibrary-dll-not-found.png "Ошибка "Библиотека DLL Маслибрари не найдена"")

Чтобы избежать этой проблемы, можно скопировать библиотеку DLL в каталог, в котором находится исполняемый файл клиента, в процессе сборки. Вы можете добавить в проект **событие после сборки** , чтобы добавить команду, которая копирует библиотеку DLL в выходной каталог сборки. Указанная здесь команда копирует библиотеку DLL только в том случае, если она отсутствует или была изменена. Он использует макросы для копирования в расположения отладки или выпуска на основе конфигурации сборки.

### <a name="to-copy-the-dll-in-a-post-build-event"></a>Копирование библиотеки DLL в событие после сборки

1. Щелкните правой кнопкой мыши узел **масклиент** в **Обозреватель решений** и выберите **Свойства** , чтобы открыть диалоговое окно **страницы свойств** .

1. В раскрывающемся списке **Конфигурация** выберите пункт **Все конфигурации**, если он еще не выбран.

1. В левой области выберите **Свойства конфигурации** > **события сборки** > **событие после сборки**.

1. На панели свойств выберите элемент управления Edit в поле **Командная строка** . Если вы представили инструкции по размещению клиентского проекта в отдельном решении из проекта DLL, введите следующую команду:

   `xcopy /y /d "..\..\MathLibrary\$(IntDir)MathLibrary.dll" "$(OutDir)"`

   Если библиотеки DLL и клиентские проекты находятся в других каталогах, измените относительный путь к библиотеке DLL для соответствия.

   ![Добавление команды после сборки](media/mathclient-post-build-command-line.png "Добавление команды после сборки")

1. Нажмите кнопку **OK**, чтобы сохранить изменения в свойствах проекта.

Теперь в вашем клиентском приложении есть все, что нужно для сборки и запуска. Соберите приложение, щелкнув команду **Сборка** > **Собрать решение** в меню. Окно **вывода** в Visual Studio должно иметь нечто вроде следующего примера в зависимости от используемой версии Visual Studio:

```Output
1>------ Build started: Project: MathClient, Configuration: Debug Win32 ------
1>MathClient.cpp
1>MathClient.vcxproj -> C:\Users\username\Source\Repos\MathClient\Debug\MathClient.exe
1>1 File(s) copied
========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========
```

Поздравляем, вы создали приложение, которое вызывает функции в вашей библиотеке DLL. Теперь запустите свое приложение, чтобы увидеть, как оно работает. В строке меню щелкните **Отладка** > **Начать без отладки**. В Visual Studio открывается командное окно для запуска программы. Последняя часть выходных данных должна выглядеть так:

![Запуск клиентского приложения без отладки](media/mathclient-run-without-debugging.png "Запуск клиентского приложения без отладки")

Для закрытия командного окна нажмите любую клавишу.

Теперь, когда вы создали библиотеку DLL и клиентское приложение, вы можете экспериментировать. Попробуйте задать точки останова в коде клиентского приложения и запустите приложение в отладчике. Посмотрите, что происходит, когда вы входите в вызов библиотеки. Добавьте другие функции в библиотеку или напишите другое клиентское приложение, которое использует вашу библиотеку DLL.

При развертывании приложения необходимо также развернуть используемые им библиотеки DLL. Самый простой способ сделать создаваемые библиотеки DLL или включить их из третьих сторон — поместить их в тот же каталог, где находится приложение. Это называется *развертыванием в локальном приложении*. Дополнительные сведения о развертывании см. в разделе [Deployment in Visual C++](../windows/deployment-in-visual-cpp.md).

## <a name="see-also"></a>См. также раздел

[Вызов функций библиотек DLL из приложений Visual Basic](calling-dll-functions-from-visual-basic-applications.md)
