---
title: Общие вопросы использования Visual C++ ARM
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 518b8872b301a8fcfc0f154cb3d5d0299efb0975
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303223"
---
# <a name="common-visual-c-arm-migration-issues"></a>Общие вопросы использования Visual C++ ARM

При использовании Microsoft C++ COMPILER (компилятором MSVC) один и тот же C++ исходный код может давать разные результаты в архитектуре ARM, чем на архитектурах x86 или x64.

## <a name="sources-of-migration-issues"></a>Источники проблем с миграцией

Многие проблемы, которые могут возникнуть при переносе кода из архитектур x86 или x64 в архитектуру ARM, связаны с конструкциями исходного кода, которые могут вызывать неопределенное, определенное реализацией или неопределенное поведение.

*Неопределенное поведение* — это поведение, C++ которое не определяется стандартом, и это вызвано операцией, которая не имеет разумного результата: например, преобразование значения с плавающей запятой в целое число без знака или сдвиг значения на число позиций, которое является отрицательным или превышает число битов в его повышенном типе.

*Поведение, определяемое реализацией* , заключается C++ в том, что стандарт требует, чтобы поставщик компилятора определял и задокументирован. Программа может безопасно полагаться на поведение, определяемое реализацией, несмотря на то, что это может быть не переносимым. Примеры поведения, определяемого реализацией, включают размеры встроенных типов данных и их требования к выравниванию. Примером операции, которая может затронуть поведение, определяемая реализацией, является доступ к списку Variable arguments.

*Неопределенное поведение* — это поведение C++ , которое Стандартный оставляет намеренно недетерминированным. Хотя поведение считается недетерминированным, определенные вызовы неопределенного поведения определяются реализацией компилятора. Однако поставщику компилятору не требуется предварительно определить результат или обеспечить согласованное поведение между сравнимыми вызовами, и нет необходимости в документации. Примером неопределенного поведения является порядок, в котором оцениваются подвыражения, которые содержат аргументы для вызова функции.

Другие проблемы, связанные с миграцией, могут быть внесены в аппаратные различия между архитектурами ARM и x86 C++ или x64, которые взаимодействуют со стандартом по-разному. Например, модель строгой памяти в архитектуре x86 и x64 предоставляет `volatile`переменные с указанием дополнительных свойств, которые использовались для упрощения некоторых видов взаимодействия между потоками в прошлом. Но модель слабой памяти архитектуры ARM не поддерживает это использование, а C++ стандарт не требует этого.

> [!IMPORTANT]
>  Хотя `volatile` получит некоторые свойства, которые можно использовать для реализации ограниченных форм межпотокового взаимодействия на платформе x86 и x64, эти дополнительные свойства недостаточно для реализации взаимодействия между потоками в целом. C++ Стандарт рекомендует, чтобы такая связь была реализована с помощью соответствующих примитивов синхронизации.

Так как разные платформы могут выражать эти виды поведения по-разному, перенос программного обеспечения между платформами может быть трудной задачей и подвержена ошибкам, если это зависит от поведения конкретной платформы. Несмотря на то, что многие из этих видов поведения могут быть заметными и могут выглядеть стабильными, их полагаться не только на переносимость, но и в случае неопределенного или неопределенного поведения, также является ошибкой. Даже поведение, упоминаемое в этом документе, не должно полагаться на использование и может измениться в будущих компиляторах или реализациях ЦП.

## <a name="example-migration-issues"></a>Примеры проблем миграции

В оставшейся части документа описывается, как поведение этих C++ языковых элементов может дать разные результаты на разных платформах.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>Преобразование целого числа с плавающей запятой в число без знака

В архитектуре ARM преобразование значения с плавающей запятой в 32-разрядное целое число насыщено до ближайшего значения, которое может представлять целое число, если значение с плавающей запятой выходит за пределы диапазона, который может представлять целое число. В архитектурах x86 и x64 преобразование обходится, если целое число не подписано, или значение-2147483648, если целое число подписывается. Ни одна из этих архитектур не поддерживает непосредственное преобразование значений с плавающей запятой в меньшие целочисленные типы. Вместо этого выполняется преобразование в 32 бит, а результаты усекаются до меньшего размера.

В архитектуре ARM сочетание насыщенности и усечения означает, что преобразование в неподписанные типы правильно засекает меньшие неподписанные типы, когда оно насыщено до 32-разрядного целого числа, но создает усеченный результат для значений, превышающих тип меньшего размера может быть представлен, но слишком мал для насыщенности полного 32-разрядного целого числа. Кроме того, преобразование правильно наследуется для 32-разрядных целых чисел со знаком, но усечение насыщенных целых чисел со знаком приводит к значению-1 для положительных насыщенных значений и 0 для отрицательных насыщенных значений. Преобразование в целое число со знаком меньшего размера создает усеченный результат, который является непредсказуемым.

Для архитектур x86 и x64 — сочетание поведения при преобразовании целых чисел без знака и явной оценки для преобразований целых чисел со знаком в переполнении вместе с усечением, чтобы результаты для большинства смен были непредсказуемыми, если они слишком большой.

Эти платформы также отличаются тем, как они обрабатывали преобразование NaN (нечисловое число) в целочисленные типы. В ARM значение NaN преобразуется в 0x00000000; на платформах x86 и x64 она преобразуется в 0x80000000.

Преобразование с плавающей запятой можно использовать только в том случае, если известно, что значение находится в диапазоне целочисленного типа, в который он преобразуется.

### <a name="shift-operator---behavior"></a>Поведение оператора сдвига (\<\< > >)

В архитектуре ARM значение можно сдвинуть влево или вправо до 255 бит, прежде чем шаблон начнет повторяться. В архитектурах x86 и x64 шаблон повторяется каждые 32, если источник шаблона не является 64-разрядной переменной. в этом случае шаблон повторяется каждые 64 на x64 и каждые 256 на платформе x86, где используется реализация программного обеспечения. Например, для 32-разрядной переменной, которая имеет значение 1, смещенное влево на 32 позиций, в ARM результат равен 0, в x86 результат равен 1, а в x64 результат также равен 1. Однако если источником значения является 64-разрядная переменная, то результат на всех трех платформах будет 4294967296, а значение не будет "переноситься" до тех пор, пока оно не будет 64 смещено в 64-разрядной версии, или на уровне 256 и x86.

Поскольку результат операции сдвига, превышающий количество битов в исходном типе, не определен, компилятор не должен иметь единообразное поведение во всех ситуациях. Например, если оба операнда сдвига известны во время компиляции, компилятор может оптимизировать программу с помощью внутренней подпрограммы для предварительного вычисления результата сдвига и последующего замены результата на место операции сдвига. Если величина сдвига слишком велика или отрицательная, результат внутренней подпрограммы может отличаться от результата того же выражения сдвига, которое было выполнено ЦП.

### <a name="variable-arguments-varargs-behavior"></a>Поведение переменных аргументов (varargs)

В архитектуре ARM параметры из списка аргументов переменных, передаваемые в стек, подчиняются выравниванию. Например, 64-разрядный параметр соответствует 64-разрядной границе. В x86 и x64 аргументы, передаваемые в стеке, не подчиняются выравниванию и пакету. Это различие может привести к тому, что функция Variadic, например `printf`, считывает адреса памяти, которые использовались в качестве заполнения в ARM, если ожидаемая структура списка аргументов переменных не совпадает точно, даже если она может работать для подмножества некоторых значений в архитектурах x86 или x64. Рассмотрим следующий пример.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

В этом случае ошибку можно исправить, убедившись в том, что используется правильная спецификация формата, чтобы рассматривалось выравнивание аргумента. Этот код правильный:

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>Порядок вычисления аргументов

Поскольку процессоры ARM, x86 и x64 различаются, они могут представлять разные требования к реализации компилятора, а также различные возможности для оптимизации. По этой причине, вместе с другими факторами, такими как соглашение о вызовах и параметры оптимизации, компилятор может оценивать аргументы функции в другом порядке в разных архитектурах или при изменении других факторов. Это может привести к непредвиденному изменению поведения приложения, использующего конкретный порядок вычисления.

Этот тип ошибки может возникать, если аргументы функции имеют побочные эффекты, которые влияют на другие аргументы функции в том же вызове. Обычно такой тип зависимости легко избежать, но иногда он может закрываться зависимостями, которые трудно различить или перегрузить оператором. Рассмотрим следующий пример кода:

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

Это выглядит правильно, но если `->` и `*` являются перегруженными операторами, этот код преобразуется в нечто примерно следующее:

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

И если существует зависимость между `operator->(memory_handle)` и `operator*(p)`, то код может полагаться на конкретный порядок вычисления, даже если исходный код выглядит так же, как невозможная зависимость.

### <a name="volatile-keyword-default-behavior"></a>поведение ключевого слова volatile по умолчанию

Компилятор КОМПИЛЯТОРОМ MSVC поддерживает две различные интерпретации квалификатора хранилища `volatile`, которые можно указать с помощью параметров компилятора. Параметр [/volatile: MS](reference/volatile-volatile-keyword-interpretation.md) выбирает расширенную временную семантику Майкрософт, которая гарантирует строгое упорядочение, как традиционное дело для x86 и x64 из-за модели строгой памяти на этих архитектурах. Параметр [/volatile: ISO](reference/volatile-volatile-keyword-interpretation.md) выбирает строгую C++ стандартную временную семантику, которая не гарантирует строгого упорядочения.

В архитектуре ARM по умолчанию используется **/volatile: ISO** , так как процессоры ARM имеют слабую упорядоченную модель памяти, и поскольку программное обеспечение ARM не имеет устаревшей, чем полагаться на расширенную семантику **/volatile: MS** и обычно не требуется взаимодействовать с программным обеспечением, которое это делает. Тем не менее иногда бывает удобно или даже требовать компиляции программы ARM для использования расширенной семантики. Например, может оказаться слишком дорогостоящим, чтобы программа могла использовать семантику ISO C++ , или для правильной работы драйвера может потребоваться соблюдение традиционной семантики. В таких случаях можно использовать параметр **/volatile: MS** . Однако, чтобы повторно создать традиционную временную семантику для целевых объектов ARM, компилятор должен вставлять барьеры памяти вокруг каждой операции чтения или записи `volatile` переменной для обеспечения строгого упорядочения, что может негативно сказаться на производительности.

В архитектурах x86 и x64 значение по умолчанию — **/volatile: MS** , так как большая часть программного обеспечения, уже созданного для этих архитектур с помощью компилятором MSVC, зависит от них. При компиляции программ x86 и x64 можно указать параметр **/volatile: ISO** , чтобы избежать ненужной зависимости от традиционной временной семантики и повысить уровень переносимости.

## <a name="see-also"></a>См. также:

[Настройка Visual C++ для процессоров ARM](configuring-programs-for-arm-processors-visual-cpp.md)
