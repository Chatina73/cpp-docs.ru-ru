---
title: Общие вопросы использования Visual C++ ARM
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 2c29b4ffa5344b309622314970ce52c47a0ebd05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328795"
---
# <a name="common-visual-c-arm-migration-issues"></a>Общие вопросы использования Visual C++ ARM

При использовании компилятора Microsoft C '(MSVC) тот же исходный код СЗ может дать различные результаты в архитектуре ARM, чем в архитектуре x86 или x64.

## <a name="sources-of-migration-issues"></a>Источники миграционных вопросов

Многие проблемы, с которыми можно столкнуться при переносе кода из архитектуры x86 или x64 в архитектуру ARM, связаны с конструкциями исходного кода, которые могут вызывать неопределенные, определяемые на основе реализации или неопределенные поведения.

*Неопределенным поведением* является поведение, которое стандарт C', не определяет, и это вызвано операцией, которая не имеет разумного результата: например, преобразование значения плавающей точки в неподписанный ряд или перемещение значения на ряд позиций, которые являются отрицательными или превышают количество битов в его продвигаемом типе.

*Поведение, определяемое реализацией,* — это поведение, которое стандарт C'' требует от поставщика компилятора определить и документировать. Программа может безопасно полагаться на поведение, определяемое с реализацией, даже если это может быть не переносным. Примеры поведения, определяемого реализацией, включают размеры встроенных типов данных и требования к их выравниванию. Примером операции, которая может быть затронута поведением, определяемым реализацией, является доступ к списку переменных аргументов.

*Неопределенным поведением* является поведение, которое стандарт СЗоставляет намеренно не детерминирует. Хотя поведение считается недетерминированным, конкретные вызовы неопределенного поведения определяются реализацией компилятора. Однако поставщику компилятора не требуется предопределять результат или гарантировать последовательное поведение между сопоставимыми вызовами, и нет необходимости в документации. Примером неопределенного поведения является порядок оценки субвыражений, включающего аргументы в вызов функции.

Другие проблемы миграции могут быть отнесены к аппаратным различиям между архитектурами ARM и x86 или x64, которые по-разному взаимодействуют со стандартом C'. Например, сильная модель памяти архитектуры x86 `volatile`и x64 дает квалифицированные переменные некоторые дополнительные свойства, которые использовались для облегчения определенных видов межпоточной связи в прошлом. Но слабая модель памяти архитектуры ARM не поддерживает это использование, и стандарт СЗНе не требует этого.

> [!IMPORTANT]
> Хотя `volatile` некоторые свойства, которые могут быть использованы для реализации ограниченных форм межпоточной связи на x86 и x64, эти дополнительные свойства не достаточны для реализации межпоточной связи в целом. Стандарт СЗ рекомендует внедрять такую коммуникацию с помощью соответствующих примитивов синхронизации.

Поскольку различные платформы могут выражать такого рода поведение по-разному, перенос программного обеспечения между платформами может быть трудным и подверженным ошибкам, если это зависит от поведения конкретной платформы. Хотя многие из этих видов поведения могут наблюдаться и могут показаться стабильными, полагаться на них, по крайней мере, непортативный, а в случае неопределенных или неопределенных поведения, также является ошибкой. Даже на поведение, приведенное в этом документе, не следует полагаться и может измениться в будущих компиляторах или реализациях процессора.

## <a name="example-migration-issues"></a>Пример проблем миграции

В остальной части этого документа описывается, как различное поведение этих элементов языка СЗ может дать разные результаты на разных платформах.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>Преобразование плавающей точки в неподписанный беспринципный

На архитектуре ARM преобразование значения плавающей точки в 32-битное целое насыщает к ближайшему значению, которое может представлять целый ряд, если значение плавающей точки находится за пределами диапазона, который может представлять целый ряд. На архитектурах x86 и x64 преобразование обертывается, если ряд не подписан, или установлен о -2147483648, если ряд подписан. Ни одна из этих архитектур непосредственно не поддерживает преобразование значений плавающей точки в более мелкие типы степл; вместо этого конверсии выполняются до 32 битов, и результаты усечены до меньшего размера.

Для архитектуры ARM сочетание насыщенности и усечения означает, что преобразование в неподписанные типы правильно насыщает меньшие неподписанные типы, когда оно насыщает 32-битный целый ряд, но дает усеченный результат для значений, которые больше, чем меньший тип может представлять, но слишком мал, чтобы насытить полный 32-битный целый ряд. Преобразование также правильно насыщает 32-битные подписанные ряды, но усечение насыщенных, подписанных рядов приводит к -1 для положительно насыщенных значений и 0 для отрицательно насыщенных значений. Преобразование в меньший подписанный ряд приводит к непредсказуемому результату.

Для архитектур x86 и x64 сочетание поведения обертывания для неподписанных конверсий и явной оценки для подписанных конверсий integer на переполнении, вместе с усечкой, делает результаты для большинства сдвигов непредсказуемыми, если они слишком велики.

Эти платформы также отличаются тем, как они обрабатывают преобразование NaN (Not-a-Number) в целые типы. На ARM NaN преобразуется в 0x0000000000; на x86 и x64, он преобразуется в 0x80000000.

Преобразование плавающей точки можно положиться только на, если вы знаете, что значение находится в пределах целого типа, в который оно преобразуется.

### <a name="shift-operator---behavior"></a>Поведение оператора\< \< смены ( >>)

На архитектуре ARM значение может быть смещено влево или вправо до 255 битов до того, как шаблон начнет повторяться. На архитектурах x86 и x64 шаблон повторяется на каждом кратном 32, если только источником шаблона является 64-разрядная переменная; в этом случае шаблон повторяется на каждом кратном 64 на x64, и каждый кратный 256 на x86, где используется реализация программного обеспечения. Например, для 32-битной переменной, которая имеет значение 1 сдвинутое на левое 32 позиции, на ARM результат 0, на x86 результат 1, а на x64 результат также 1. Однако, если источником значения является 64-битная переменная, то результат на всех трех платформах составляет 4294967296, и значение не "оберните вокруг", пока не сместится 64 позиции на x64, или 256 позиций на ARM и x86.

Поскольку результат операции переноса, превышающей количество битов в типе исходного кода, не определен, компилятор не обязан иметь последовательное поведение во всех ситуациях. Например, если оба действия смены известны во время компиляции, компилятор может оптимизировать программу, используя внутреннюю рутину для предварительного расчета результата смены, а затем замены результата вместо операции смены. Если сумма смещения слишком велика или отрицательна, результат внутренней рутины может отличаться от результата того же выражения смены, что и выполняется процессором.

### <a name="variable-arguments-varargs-behavior"></a>Переменные аргументы (varargs) поведение

На архитектуре ARM параметры из списка переменных аргументов, которые передаются по стеку, подлежат выравниванию. Например, 64-битный параметр выравнивается по 64-битной границе. На x86 и x64 аргументы, которые передаются по стеку, не подлежат выравниванию и плотно упаковываются. Эта разница может привести `printf` к тому, что вазиадная функция может стать для чтения адресов памяти, которые были предназначены в качестве обивки на ARM, если ожидаемый макет списка переменных аргументов не совпадает точно, даже если он может работать для подмножества некоторых значений на архитектурах x86 или x64. Рассмотрим следующий пример.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

В этом случае ошибку можно исправить, убедившись, что используется правильная спецификация формата, чтобы учитывать выравнивание аргумента. Этот код является правильным:

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>Ордер на оценку аргументов

Поскольку процессоры ARM, x86 и x64 настолько различны, они могут представлять различные требования к реализации компилятора, а также различные возможности для оптимизации. Из-за этого, наряду с другими факторами, такими как настройки вызова-конвенции и оптимизации, компилятор может оценивать функциональные аргументы в другом порядке на разных архитектурах или при изменении других факторов. Это может привести к неожиданному изменению поведения приложения, которое полагается на конкретный порядок оценки.

Такая ошибка может возникать, когда аргументы к функции имеют побочные эффекты, которые влияют на другие аргументы к функции в том же вызове. Обычно такого рода зависимости легко избежать, но иногда она может быть скрыта зависимостями, которые трудно различить, или перегрузкой оператора. Рассмотрим этот пример кода:

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

Это кажется четко определенным, но если `->` и `*` перегружены операторами, то этот код переводится на то, что напоминает это:

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

И если есть зависимость между `operator->(memory_handle)` `operator*(p)`и, код может полагаться на конкретный порядок оценки, даже если исходный код выглядит как нет никакой возможной зависимости.

### <a name="volatile-keyword-default-behavior"></a>летучих поведение ключевого слова по умолчанию

Компилятор MSVC поддерживает две `volatile` различные интерпретации квалификатора хранилища, которые можно указать с помощью компиляторных переключателей. [Коммутатор /volatile:ms](reference/volatile-volatile-keyword-interpretation.md) выбирает расширенную семантику Microsoft, гарантирующую сильный заказ, как это было в традиционном случае для x86 и x64 из-за сильной модели памяти на этих архитектурах. [Коммутатор /volatile:iso](reference/volatile-volatile-keyword-interpretation.md) выбирает строгую стандартную семантику семантики, которая не гарантирует сильного заказа.

На архитектуре ARM по умолчанию **является /летучим:iso,** потому что arm процессоры имеют слабо упорядоченную модель памяти, и потому, что программное обеспечение ARM не имеет наследия полагаться на расширенную семантику **/летучих:ms** и обычно не имеет интерфейса с программным обеспечением, которое делает. Тем не менее, иногда удобно или даже требуется компиляция программы ARM для использования расширенной семантики. Например, портировать программу для использования семантики ISO C's может быть слишком дорого, иначе программное обеспечение драйвера может привести к правильной работе традиционной семантики. В этих случаях можно использовать **переключатель /volatile:ms;** однако, чтобы воссоздать традиционную летучую семантику на цели ARM, компилятор должен вставить барьеры памяти вокруг каждого чтения или записи переменной `volatile` для обеспечения сильного заказа, что может негативно сказаться на производительности.

В архитектурах x86 и x64 значение по умолчанию **является /летучим,** поскольку большая часть программного обеспечения, уже созданного для этих архитектур с помощью MSVC, опирается на них. При компилировании программ x86 и x64 можно указать **переключатель /volatile:iso,** чтобы избежать ненужной зависимости от традиционной летучей семантики и повысить переносимость.

## <a name="see-also"></a>См. также раздел

[Настройка Visual C++ для процессоров ARM](configuring-programs-for-arm-processors-visual-cpp.md)
