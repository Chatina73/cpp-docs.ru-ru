---
title: Общие вопросы использования Visual C++ ARM
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 78d87000240acd394edf823a778ae29060c6d09c
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2019
ms.locfileid: "65220882"
---
# <a name="common-visual-c-arm-migration-issues"></a>Общие вопросы использования Visual C++ ARM

При использовании Microsoft C++ компилятор (MSVC), же C++ исходного кода может давать разные результаты на основе архитектуры ARM, не так, как на x86 или x64 архитектурах.

## <a name="sources-of-migration-issues"></a>Источники проблем миграции

Множество проблем, которые могут возникнуть при переносе кода из архитектур x86 или x64 в архитектуре ARM, связаны с конструкции исходного кода, которые могут вызвать поведение не определено, определяемые реализацией или не указан.

*Неопределенное поведение* представляет поведение, стандарт C++ не определен, и, вызванные операцию, которая не имеет разумный результатов: например, преобразование значение с плавающей запятой в целое число без знака или сдвигая значение на количество позиций является отрицательным или превышает число битов в соответствующего типа повышенного уровня.

*Поведение, определяемое реализацией* представляет поведение, стандарт C++ требует производителю компиляторов определить и задокументировать. Программа может спокойно полагаться на поведение, определяемое реализацией, несмотря на то, что это таким образом может не быть переносимыми. Поведение, определяемое реализацией примеры размеры встроенных типов данных и их требований к выравниванию. Пример операции, которая зависит от конкретной реализации обращается к в список переменных аргументов.

*Этот атрибут не задан поведение* представляет поведение, стандарт C++ оставляет намеренно недетерминированным. Несмотря на то, что поведение считается недетерминированным, определенного вызовы неопределенное поведение зависит от реализации компилятора. Тем не менее нет необходимости для поставщика компилятора предварительно определить результат или гарантирует согласованное поведение между вызовами сопоставимых и нет необходимости документацию. Примером непредсказуемому поведению является порядок, в котором вычисляются вложенных выражений, которые включают аргументы при вызове функции.

Другие проблемы при миграции можно отнести к различия характеристик оборудования ARM и x86 или x64 архитектур, которые взаимодействуют с стандарт языка C++ по-разному. Например, предоставляет надежный памяти модели архитектуры x86 и x64 `volatile`-указанием переменные некоторые дополнительные свойства, которые были использованы для упрощения некоторых видов связи между потоками в прошлом. Но модели слабого памяти архитектуры ARM не поддерживает такое использование, или стандарт C++ требует его.

> [!IMPORTANT]
>  Несмотря на то что `volatile` прибыли, некоторые свойства, которые могут использоваться для реализации ограниченные виды связи между потоками на x86 и x64, эти дополнительные свойства не являются достаточными для реализации между потоками обмена данными в целом. Стандарт языка C++ рекомендует такие подключения реализовываться вместо этого использовать примитивы синхронизации соответствующие.

Поскольку различные платформы может по-разному express эти виды поведения, перенос между платформами может быть сложной и ошибкам, если он зависит от поведение определенной платформы. Несмотря на то, что многие из этих видов поведение можно наблюдать и могут запускаться стабильной, полагаться на них по крайней мере не является переносимым и в случаях поведение определено или не задан, также будет ошибкой. Даже поведение, приведенные в этом документе не следует полагаться на и может измениться в будущих компиляторы или реализации ЦП.

## <a name="example-migration-issues"></a>Пример проблемы при миграции

В оставшейся части этого документа описываются как различное поведение этих элементов языка C++ может дать разные результаты на разных платформах.

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>Преобразование чисел с плавающей запятой в целое число без знака

В архитектуре ARM преобразование значения с плавающей запятой в 32-разрядное целое число насыщение до ближайшего значения, который может представлять целое число, если значение с плавающей запятой находится за пределами диапазона, который может представлять целое число. В архитектурах x86 и x64 преобразование обтекает Если целое число без знака или имеет значение от -2147483648 Если подписан целое число. Ни один из этих архитектур непосредственно поддерживает преобразование значений с плавающей запятой в типы меньших целых чисел; Вместо этого преобразования выполняются до 32 бит, и результаты будут усечены до меньшего размера.

Для архитектуры ARM, сочетание насыщенность и усечение означает, что преобразование типов без знака правильно насыщение более мелкие типы без знака при насыщение 32-разрядное целое число, но выдает усеченное результат для значения, размер которых превышает тип меньшего размера может представлять но слишком мал для насыщения полного 32-разрядное целое число. Преобразование также правильно насыщение для 32-разрядное знаковое целое число, но усечение насыщенный, с подписью целых чисел приводит к -1 для значения положительно насыщенных и 0 для отрицательно насыщенных значений. Преобразование в более мелкие знакового целого числа результат усеченное непредсказуем.

Для архитектур x86 и x64 сочетание циклических поведение для преобразования целого числа без знака и явные оценки для преобразования целого числа со знаком в случае переполнения, а также усечение, сделать результаты для большинства смен непредсказуемыми, если они слишком большой.

Эти платформы также различаются способом обработки преобразование NaN (не число) в целочисленные типы. Преобразует значение NaN на ARM, чтобы 0x00000000; на x86 и x64 он преобразует 0x80000000.

Преобразования с плавающей запятой можно только надежной, если вы знаете, что значение в диапазоне, он преобразуется в тип integer.

### <a name="shift-operator---behavior"></a>Оператор сдвига (\< \< >>) поведение

В архитектуре ARM значение можно должны сдвигаться влево или вправо до 255 бит до начала шаблон повторения. Архитектур x86 и x64 шаблон повторяется в каждой кратно 32, если источником шаблона является 64-разрядную переменную; в этом случае шаблон повторяется на каждой кратен 64 на x 64 и каждый кратного 256 на x86, где работает реализации программы. Например для 32-разрядную переменную со значением 1 сдвинуты влево на 32 позиций, на ARM результат равен 0, на x86 результат равен 1, и в x64 результат также равен 1. Тем не менее если источник значения является 64-разрядной переменной, 4294967296, то результат на всех трех платформах, и значение не «циклический переход» пока не переместил 64 позиций на x64 или 256 положения на ARM и x86.

Так как результат операции сдвига, превышающее количество битов в исходный тип не определен, компилятор не обязан иметь согласованное поведение во всех ситуациях. Например если оба операнда смены известны во время компиляции, компилятор может оптимизировать программу, используя внутренний подпрограммы для предварительно вычисляет результат сдвига и затем подстановка результат вместо операции сдвига. Если величина сдвига слишком велик или отрицательное значение, результат внутренней процедуры может отличаться от результата того же выражения shift как выполняются непосредственно в ЦП.

### <a name="variable-arguments-varargs-behavior"></a>Поведение с переменными аргументами (varargs)

В архитектуре ARM параметры из списка переменных аргументов, которые передаются в стеке, распространяются выравнивания. Например 64-разрядный параметр выравнивается по границе 64-разрядной. На x86 и x64 аргументы, передаваемые в стеке и не распространяются выравнивание пакета тесно. Это может привести к функции с переменным числом аргументов, например `printf` прочитать адреса памяти, которые были предназначены как внутренние поля в ARM Если ожидаемый макет списка переменных аргументов не соответствует полностью, несмотря на то, что он может работать для подмножества некоторые значения на x86 или x64 архитектур. Рассмотрим следующий пример.

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

В этом случае можно исправить ошибки, убедившись, что в правильном формате спецификации используется, чтобы считается выравнивание аргумента. Этот код приводится правильный код:

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>Порядок вычисления аргумента

Поскольку ARM, x 86 и x64 процессоров, поэтому отличаются, они могут предоставлять различные требования к реализации компилятора, а также различные возможности для оптимизации. По этой причине вместе с других факторов, таких как параметры соглашения о вызовах и оптимизации, компилятор может вычислить аргументов функции в другом порядке в разных архитектур или изменения других факторов. Это может вызвать поведение приложения, которое зависит от конкретного порядка оценки неожиданное изменение.

Такая ошибка может произойти при аргументы для функции имеют побочные эффекты, которые влияют на другие аргументы функции в одном вызове. Обычно таким типом зависимости легко избежать, но он иногда могут быть закрыты с зависимостями, довольно трудно или перегрузки операторов. Рассмотрим следующий пример кода:

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

Это выглядит хорошо определены, но если `->` и `*` перегруженные операторы являются, а затем этот код преобразуется в то, что выглядит следующим образом:

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

И если имеется зависимость между `operator->(memory_handle)` и `operator*(p)`, код может зависеть от конкретного порядка оценки, несмотря на то, что исходный код выглядит как в ней нет никакой возможные зависимости.

### <a name="volatile-keyword-default-behavior"></a>поведение по умолчанию volatile-ключевое слово

Компилятор MSVC поддерживает две разные интерпретации `volatile` квалификатор хранилища, которое можно указать с помощью параметров компилятора. [/Volatile:ms](reference/volatile-volatile-keyword-interpretation.md) Выбор расширенные volatile семантику, что гарантирует строгое упорядочение, так же как традиционному случаю для x86 и x64 из-за надежный памяти модель на основе архитектуры Майкрософт. [/Volatile:iso](reference/volatile-volatile-keyword-interpretation.md) Выбор строгую C++ standard volatile семантику, которая не гарантирует строгое упорядочение.

В архитектуре ARM, по умолчанию используется **/volatile:iso** Поскольку процессоры ARM имеют слабо упорядоченные модели памяти, а программное обеспечение ARM не имеет устаревшего полагается на расширенную семантику **/volatile:ms**  и обычно не имеют интерфейс с программным обеспечением, который выполняет. Тем не менее это по-прежнему иногда смысла или даже необходимо скомпилировать программу ARM использует эту расширенную семантику. Например может быть слишком много ресурсов, к порту программа использует эту семантику ISO C++ или драйверов может потребоваться соблюдать традиционные семантику для правильной работы. В таких случаях можно использовать **/volatile:ms** коммутатор; тем не менее, для повторного создания традиционных volatile семантику для целевых объектов ARM, компилятор должен вставлять барьеры в памяти вокруг каждого чтения или записи из `volatile` переменной для принудительного применения строгое упорядочение, который может иметь негативное влияние на производительность.

В архитектурах x86 и x64, по умолчанию используется **/volatile:ms** , так как большая часть программного обеспечения, который уже был создан для эти архитектуры с помощью MSVC зависит от них. При компиляции программы x86 и x64, можно указать **/volatile:iso** перейдите помогает избежать ненужных зависимость от традиционных volatile семантики, а также для обеспечения переносимости.

## <a name="see-also"></a>См. также

[Настройка Visual C++ для процессоров ARM](configuring-programs-for-arm-processors-visual-cpp.md)
