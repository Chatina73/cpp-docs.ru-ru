---
title: Библиотеки DLL и поведение библиотеки времени выполнения Visual C++
ms.date: 11/04/2016
f1_keywords:
- _DllMainCRTStartup
- CRT_INIT
helpviewer_keywords:
- DLLs [C++], entry point function
- process detach [C++]
- process attach [C++]
- DLLs [C++], run-time library behavior
- DllMain function
- _CRT_INIT macro
- _DllMainCRTStartup method
- run-time [C++], DLL startup sequence
- DLLs [C++], startup sequence
ms.assetid: e06f24ab-6ca5-44ef-9857-aed0c6f049f2
ms.openlocfilehash: 8293e2e05193b34802aba0af722dd06155fdcd81
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50429059"
---
# <a name="dlls-and-visual-c-run-time-library-behavior"></a>Библиотеки DLL и поведение библиотеки времени выполнения Visual C++

При построении библиотеки динамической компоновки (DLL) с помощью Visual C++ по умолчанию компоновщик включает библиотеку времени выполнения Visual C++ (VCRuntime). VCRuntime содержит код, необходимый для инициализации и завершения исполняемый файл C/C++. При компоновке в библиотеку DLL в коде VCRuntime представлен Внутренняя функция точки входа библиотеки DLL вызывается `_DllMainCRTStartup` , обрабатывает сообщения Windows ОС на библиотеку DLL, чтобы присоединять или отсоединять их из процесса или потока. `_DllMainCRTStartup` Функция выполняет основные задачи, такие как безопасность буфера стека, Настройка, инициализации библиотеки времени выполнения (CRT) C и завершения и вызовы к конструкторы и деструкторы для статические и глобальные объекты. `_DllMainCRTStartup` также вызывает обработчик функции для других библиотек, таких как WinRT, MFC и ATL для выполнения собственных инициализация и прекращение работы. Без инициализации, CRT и другие библиотеки, а также статических переменных останется в неинициализированном состоянии. Же VCRuntime внутренней инициализации и завершения процедуры называются ли использует библиотеки DLL, статически скомпонованной CRT или динамически связанные библиотеки DLL CRT.

## <a name="default-dll-entry-point-dllmaincrtstartup"></a>_DllMainCRTStartup точки входа библиотеки DLL по умолчанию

В Windows, все библиотеки DLL могут содержать функцию точки входа необязательно, обычно вызывается `DllMain`, который вызывается для инициализации и завершения. Это дает возможность выделить или освободить дополнительные ресурсы по мере необходимости. Windows вызывает функцию точки входа в четырех случаях: присоединение процесса, отсоединение процесса, присоединение потока и отсоединение потока. При загрузке библиотеки DLL в адресного пространства процесса, когда загружается приложение, использующее его или когда приложение запрашивает DLL во время выполнения, операционная система создает отдельную копию данных библиотеки DLL. Это называется *присоединение процесса*. *Присоединение потока* возникает, когда библиотека DLL загружается в процесс создает новый поток. *Отсоединение потока* возникает, когда поток завершается, и *отсоединение процесса* когда библиотеки DLL, больше не требуется и выпускается приложением. Операционная система уведомляет отдельного вызова точки входа библиотеки DLL для каждого из этих событий, передав *Причина* аргумент для каждого типа событий. Например, операционная система отправляет `DLL_PROCESS_ATTACH` как *Причина* аргумент для обозначения процесса присоединения.

Библиотека VCRuntime предоставляет функцию точки входа с именем `_DllMainCRTStartup` для обработки операций инициализации и завершения по умолчанию. Процесс присоединения, `_DllMainCRTStartup` функция настраивает проверки безопасности буфера, инициализирует CRT и другими библиотеками, инициализирует сведения о типе времени выполнения, инициализирует и вызывает конструкторы для статических и не являющейся локальной для данных, инициализирует локальное хранилище потока , увеличивает внутренний статический счетчик для каждого подключения, а затем вызывает или библиотека пользовательские `DllMain`. В процессе отсоединения, функция выполняет эти действия в обратном порядке. Он вызывает `DllMain`, уменьшает внутреннего счетчика, вызывает деструкторы, функции завершения вызовов CRT и зарегистрирован `atexit` функции и уведомляет других библиотек прекращения. Если вложение счетчик становится равным нулю, функция возвращает значение `FALSE` для указания для Windows, что DLL может быть выгружена. `_DllMainCRTStartup` Функция также вызывается во время потока присоединение и отсоединение потока. В этом случае код VCRuntime не выполняет дополнительную инициализацию или завершение самостоятельно и просто вызывает `DllMain` для передачи сообщения вместе. Если `DllMain` возвращает `FALSE` из процесса присоединения, сигналов сбоя `_DllMainCRTStartup` вызовы `DllMain` еще раз и передает `DLL_PROCESS_DETACH` как *Причина* аргумент, затем проходит через до конца процесс завершения.

При построении библиотеки DLL в Visual C++, точки входа по умолчанию `_DllMainCRTStartup` предоставляемые VCRuntime автоматически связана в последовательности. Необходимо указать функцию точки входа для библиотеки DLL с помощью [/Entry (символ точки входа)](../build/reference/entry-entry-point-symbol.md) параметр компоновщика.

> [!NOTE]
> Хотя можно указать другую функцию точки входа для библиотеки DLL с помощью / ENTRY: параметр компоновщика, не рекомендуется, так как функция точки входа пришлось бы все повторяющиеся, `_DllMainCRTStartup` делает, в том же порядке. VCRuntime предоставляет функции, которые дают возможность скопировать его поведение. Например, можно вызвать [__security_init_cookie](../c-runtime-library/reference/security-init-cookie.md) немедленно на процесс присоединения для поддержки [/GS (проверка безопасности буфера)](../build/reference/gs-buffer-security-check.md) буфера, выбор параметра. Вы можете вызвать `_CRT_INIT` функцию, передавая те же параметры, как функцию точки входа для выполнения остальной части функций DLL инициализации или завершения.

<a name="initializing-a-dll"></a>

## <a name="initialize-a-dll"></a>Инициализация библиотеки DLL

Библиотека DLL может иметь код инициализации, который должен выполняться при загрузке библиотеки DLL. В порядке выполнять функции инициализации и завершения для собственных DLL `_DllMainCRTStartup` вызывает функцию с именем `DllMain` , вы можете предоставить. Ваш `DllMain` должен иметь сигнатуру, необходимые для точки входа библиотеки DLL. Функция точки входа по умолчанию `_DllMainCRTStartup` вызовы `DllMain` теми же параметрами передается по Windows. По умолчанию, если вы не укажете `DllMain` функции, Visual C++ предоставляет его и связывает ее в, чтобы `_DllMainCRTStartup` всегда есть что-то для вызова. Это означает, что если вам не нужно инициализации библиотеки DLL, нет ничего особенного что необходимо сделать при построении библиотеки DLL.

Это подпись, используемая для `DllMain`:

```cpp
#include <windows.h>

extern "C" BOOL WINAPI DllMain (
    HINSTANCE const instance,  // handle to DLL module
    DWORD     const reason,    // reason for calling function
    LPVOID    const reserved); // reserved
```

Некоторые библиотеки помещают `DllMain` функции для вас. Например, в обычную библиотеку DLL MFC, реализовать `CWinApp` объекта `InitInstance` и `ExitInstance` функции-члены для выполнения инициализации и завершения, необходимых для библиотеки DLL. Дополнительные сведения см. в разделе [инициализация обычных библиотек DLL MFC](#initializing-regular-dlls) раздел.

> [!WARNING]
> Существуют значительные ограничения на безопасно возможности в точки входа библиотеки DLL. См. в разделе [Общие рекомендации](/windows/desktop/Dlls/dynamic-link-library-best-practices) для определенного API Windows, небезопасные для вызова в `DllMain`. Если вам требуется, но затем простейший инициализации сделать это в функции инициализации для библиотеки DLL. Можно потребовать, чтобы приложения могли вызывать функцию инициализации после `DllMain` имеет выполнения и перед их вызывать другие функции в библиотеке DLL.

<a name="initializing-non-mfc-dlls"></a>

### <a name="initialize-ordinary-non-mfc-dlls"></a>Инициализация библиотек DLL обычный (не MFC)

Для выполнения собственных инициализации в библиотеках DLL обычный (не MFC), использующие, предоставляемую VCRuntime `_DllMainCRTStartup` точки входа, исходный код библиотеки DLL должен содержать функцию с именем `DllMain`. В следующем отрывке кода структуру определения функции `DllMain` может выглядеть так:

```cpp
#include <windows.h>

extern "C" BOOL WINAPI DllMain (
    HINSTANCE const instance,  // handle to DLL module
    DWORD     const reason,    // reason for calling function
    LPVOID    const reserved)  // reserved
{
    // Perform actions based on the reason for calling.
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        // Initialize once for each new process.
        // Return FALSE to fail DLL load.
        break;

    case DLL_THREAD_ATTACH:
        // Do thread-specific initialization.
        break;

    case DLL_THREAD_DETACH:
        // Do thread-specific cleanup.
        break;

    case DLL_PROCESS_DETACH:
        // Perform any necessary cleanup.
        break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
```

> [!NOTE]
> Документацию к предыдущим версиям Windows SDK сказано, что фактическое имя этой функции DLL точки входа должно быть указано в командной строке с помощью параметра/ENTRY компоновщик. С помощью Visual C++, не нужно использовать параметр/Entry, если имя функции точки входа `DllMain`. На самом деле, при использовании параметра/ENTRY и имя точки входа функции, что-либо отличные от `DllMain`, CRT не удастся инициализировать, если функция точки входа выполняет же вызовы инициализации, `_DllMainCRTStartup` делает.

<a name="initializing-regular-dlls"></a>

### <a name="initialize-regular-mfc-dlls"></a>Инициализация обычных библиотек DLL MFC

Так как обычные библиотеки DLL MFC имеют `CWinApp` объекта, они должны выполнять свои задачи инициализации и завершения в том же расположении, что приложение MFC: в `InitInstance` и `ExitInstance` функций-членов из библиотеки DLL `CWinApp`-производным класс. Так как MFC предоставляет `DllMain` функция, вызываемая `_DllMainCRTStartup` для `DLL_PROCESS_ATTACH` и `DLL_PROCESS_DETACH`, следует писать собственные `DllMain` функции. Предоставляемая MFC `DllMain` вызовы функций `InitInstance` при загрузке библиотеки DLL, и он вызывает `ExitInstance` перед выгрузкой библиотеки DLL.

Обычной библиотеки DLL MFC можно отслеживать, несколько потоков, вызвав [TlsAlloc](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc) и [TlsGetValue](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsgetvalue) в его `InitInstance` функции. Эти функции позволяют библиотеке DLL для отслеживания данных определенного потока.

В обычной библиотеки DLL MFC, динамически скомпонованную с MFC, если вы используете любой MFC OLE, MFC базы данных (или DAO) или сокетов MFC поддерживает определяемые пользователем, соответственно, отладочные расширения MFC DLL MFCO*версии*D.dll, MFCD*версии*D.dll и MFCN*версии*D.dll (где *версии* — это номер версии) связаны в автоматически. Необходимо вызвать один из следующих предопределенных функций настройки для каждого из этих библиотек DLL, которые используются в библиотеке регулярных DLL MFC `CWinApp::InitInstance`.

|Тип поддержки MFC|Вызываемая функция|
|-------------------------|-------------------------------------|
|MFC OLE (MFCO*версии*D.dll)|`AfxOleInitModule`|
|Базы данных MFC (MFCD*версии*D.dll)|`AfxDbInitModule`|
|Сокеты MFC (MFCN*версии*D.dll)|`AfxNetInitModule`|

<a name="initializing-extension-dlls"></a>

### <a name="initialize-mfc-extension-dlls"></a>Инициализация библиотек DLL расширений MFC

Поскольку библиотеки DLL расширения MFC не имеют `CWinApp`-производный объект (от обычных библиотек DLL MFC), следует добавить код инициализации и завершения, чтобы `DllMain` функции, создающей мастера MFC DLL.

Мастер предоставляет следующий код для библиотеки DLL расширений MFC. В коде `PROJNAME` — это заполнитель для имени проекта.

```cpp
#include "stdafx.h"
#include <afxdllx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
static AFX_EXTENSION_MODULE PROJNAMEDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      TRACE0("PROJNAME.DLL Initializing!\n");

      // MFC extension DLL one-time initialization
      AfxInitExtensionModule(PROJNAMEDLL,
                                 hInstance);

      // Insert this DLL into the resource chain
      new CDynLinkLibrary(Dll3DLL);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      TRACE0("PROJNAME.DLL Terminating!\n");
   }
   return 1;   // ok
}
```

Создание нового `CDynLinkLibrary` объект во время инициализации позволяет расширения MFC DLL для экспорта `CRuntimeClass` объектов или ресурсы, чтобы клиентское приложение.

Если вы собираетесь использовать расширения MFC DLL из одного или нескольких обычных библиотек DLL MFC, необходимо экспортировать функцию инициализации, которая создает `CDynLinkLibrary` объекта. Этой функции должен вызываться из всех регулярных DLL MFC, использовать библиотеки DLL расширения MFC. Необходимо вызвать эту функцию инициализации находится в `InitInstance` функцию-член регулярных DLL MFC `CWinApp`-объект, производной от прежде чем использовать любое экспортируемые классы или функции DLL расширения MFC.

В `DllMain` , мастер библиотек DLL MFC создает, вызов метода `AfxInitExtensionModule` захватывает классов времени выполнения модуля (`CRuntimeClass` структур) а также производства объектов (`COleObjectFactory` объектов) для использования при `CDynLinkLibrary` создается объект. Вы должны проверить возвращаемое значение `AfxInitExtensionModule`; Если нулевое значение возвращается из `AfxInitExtensionModule`, возвращают нуль из вашей `DllMain` функции.

Если библиотеки DLL расширения MFC явно связана в исполняемый файл (то есть исполняемый файл вызывает `AfxLoadLibrary` для связанных с библиотекой DLL), следует добавить вызов `AfxTermExtensionModule` на `DLL_PROCESS_DETACH`. Эта функция позволяет MFC для очистки библиотеки DLL расширения MFC, после отсоединения всех процессов из библиотеки DLL расширения MFC (что происходит при завершении процесса или при выгрузке библиотеки DLL в результате использования `AfxFreeLibrary` вызова). Если в приложение вызов неявного связывания библиотеки DLL расширения MFC `AfxTermExtensionModule` не требуется.

Приложения, которые явно ссылку, чтобы библиотеки DLL расширения MFC необходимо вызвать `AfxTermExtensionModule` при освобождении. Они также следует использовать `AfxLoadLibrary` и `AfxFreeLibrary` (вместо функций Win32 `LoadLibrary` и `FreeLibrary`) Если приложение использует несколько потоков. С помощью `AfxLoadLibrary` и `AfxFreeLibrary` гарантирует, что код запуска и завершения работы, который выполняется при загрузке и выгрузке библиотеки DLL расширения MFC не приведет к повреждению глобального состояния MFC.

Поскольку MFCx0.dll полностью к моменту `DllMain` является именем, можно выделить память и вызвать функции MFC в `DllMain` (в отличие от 16-разрядной версии MFC).

Библиотеки DLL расширения может позаботиться об многопоточности путем обработки `DLL_THREAD_ATTACH` и `DLL_THREAD_DETACH` случаи в `DllMain` функции. Эти значения передаются в `DllMain` при потоков присоединения и отсоединения от библиотеки DLL. Вызов [TlsAlloc](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc) при присоединения DLL позволит использовать Библиотеку Ведение потока, индексирует локальное хранилище (TLS) для каждого потока, присоединенного к библиотеке DLL.

Обратите внимание, что в файле заголовка Afxdllx.h содержит специальные определения для структур, используемых в библиотеки DLL расширения MFC, например определение `AFX_EXTENSION_MODULE` и `CDynLinkLibrary`. Следует включить файл заголовка в библиотеки DLL расширения MFC.

> [!NOTE]
>  Очень важно, ни определения, ни отмена определения каких `_AFX_NO_XXX` макросов в файле Stdafx.h. Эти макросы существует только в целях проверки, поддерживает ли эта функция конкретной целевой платформы или нет. Можно написать программу, чтобы проверить эти макросы (например, `#ifndef _AFX_NO_OLE_SUPPORT`), но программа никогда не следует определения или отмены определения этих макросов.

Пример функции инициализации, обработка многопоточности, включенный в [с помощью локальной памяти в библиотеке динамической компоновки](/windows/desktop/Dlls/using-thread-local-storage-in-a-dynamic-link-library) в пакете Windows SDK. Обратите внимание, что пример содержит функцию точки входа с именем `LibMain`, но вам следует присвоить имя `DllMain` работы с библиотеками MFC и C времени выполнения.

## <a name="see-also"></a>См. также

[DLL в Visual C++](../build/dlls-in-visual-cpp.md)<br/>
[Точка входа DllMain](/windows/desktop/Dlls/dllmain)<br/>
[Рекомендации по обеспечению библиотеку динамической компоновки](/windows/desktop/Dlls/dynamic-link-library-best-practices)