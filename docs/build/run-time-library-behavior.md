---
title: Библиотеки DLL и C++ поведение визуальной библиотеки времени выполнения
ms.date: 08/19/2019
f1_keywords:
- _DllMainCRTStartup
- CRT_INIT
helpviewer_keywords:
- DLLs [C++], entry point function
- process detach [C++]
- process attach [C++]
- DLLs [C++], run-time library behavior
- DllMain function
- _CRT_INIT macro
- _DllMainCRTStartup method
- run-time [C++], DLL startup sequence
- DLLs [C++], startup sequence
ms.assetid: e06f24ab-6ca5-44ef-9857-aed0c6f049f2
ms.openlocfilehash: 572a0ba70c1ba2d46d2d9fd6d8ac543a77bbbc01
ms.sourcegitcommit: 3e8fa01f323bc5043a48a0c18b855d38af3648d4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78856778"
---
# <a name="dlls-and-visual-c-run-time-library-behavior"></a>Библиотеки DLL и C++ поведение визуальной библиотеки времени выполнения

При создании библиотеки динамической компоновки (DLL) с помощью Visual Studio по умолчанию компоновщик включает в себя визуальную C++ библиотеку времени выполнения (VCRuntime). VCRuntime содержит код, необходимый для инициализации и завершения исполняемого файлаC++ C/. При связывании с библиотекой DLL код VCRuntime предоставляет внутреннюю функцию точки входа DLL, именуемую `_DllMainCRTStartup`, которая обрабатывает сообщения ОС Windows в библиотеке DLL для подключения или отсоединения от процесса или потока. Функция `_DllMainCRTStartup` выполняет такие задачи, как настройка безопасности буфера стека, инициализация и завершение библиотеки времени выполнения C (CRT), а также вызовы конструкторов и деструкторов для статических и глобальных объектов. `_DllMainCRTStartup` также вызывает функции-обработчики для других библиотек, таких как WinRT, MFC и ATL, для выполнения собственной инициализации и завершения. Без такой инициализации CRT и другие библиотеки, а также статические переменные будут оставаться в неинициализированном состоянии. Те же процедуры внутренней инициализации и завершения VCRuntime вызываются независимо от того, использует ли библиотека DLL статически связанную библиотеку CRT или динамически связанную DLL CRT.

## <a name="default-dll-entry-point-_dllmaincrtstartup"></a>_DllMainCRTStartup точки входа библиотеки DLL по умолчанию

В Windows все библиотеки DLL могут содержать необязательную функцию точки входа, которая обычно называется `DllMain`, которая вызывается как для инициализации, так и для завершения. Это дает возможность выделять или освобождать дополнительные ресурсы по мере необходимости. Windows вызывает функцию точки входа в четырех ситуациях: присоединение процесса, отключение процесса, присоединение потока и отключение потока. Когда библиотека DLL загружается в адресное пространство процесса, либо при загрузке приложения, которое его использует, либо когда приложение запрашивает библиотеку DLL во время выполнения, операционная система создает отдельную копию данных библиотеки DLL. Это называется *присоединением процесса*. *Присоединение потока* происходит, когда процесс, загруженный библиотекой DLL, создает новый поток. *Отключение потока* происходит, когда поток завершается, и *отсоединение процесса* происходит, когда библиотека DLL больше не нужна и освобождается приложением. Операционная система выполняет отдельный вызов точки входа библиотеки DLL для каждого из этих событий, передавая аргумент *Reason* для каждого типа событий. Например, операционная система отправляет `DLL_PROCESS_ATTACH` в качестве аргумента *Reason* в сигнальное подключение процесса.

Библиотека VCRuntime предоставляет функцию точки входа с именем `_DllMainCRTStartup` для управления операциями инициализации и завершения по умолчанию. При присоединении процесса функция `_DllMainCRTStartup` настраивает проверку безопасности буфера, инициализирует CRT и другие библиотеки, Инициализирует сведения о типах времени выполнения, инициализирует и вызывает конструкторы для статических и нелокальных данных, инициализирует локальное хранилище потока, увеличивает внутренний статический счетчик для каждого соединения, а затем вызывает предоставляемую пользователем или библиотеку `DllMain`. При отсоединении процесса функция проходит через эти действия в обратную. Она вызывает `DllMain`, уменьшает внутренний счетчик, вызывает деструкторы, вызывает функции завершения CRT и зарегистрированные функции `atexit` и уведомляет все другие библиотеки о завершении работы. Когда счетчик прикрепления переходит к нулю, функция возвращает `FALSE`, чтобы указать Windows, что DLL может быть выгружена. Функция `_DllMainCRTStartup` вызывается также во время присоединения потока и отключения потока. В этих случаях код VCRuntime не выполняет дополнительную инициализацию или завершение самостоятельно, а также вызывает `DllMain` для передачи сообщения. Если `DllMain` возвращает `FALSE` из процесса Attach, сбой сигнала, `_DllMainCRTStartup` вызывает `DllMain` снова и передает `DLL_PROCESS_DETACH` в качестве аргумента *Reason* , а затем выполняет оставшуюся часть процесса завершения.

При создании библиотек DLL в Visual Studio точка входа по умолчанию `_DllMainCRTStartup` предоставляемая VCRuntime, связывается автоматически. Не нужно указывать функцию точки входа для библиотеки DLL с помощью параметра компоновщика [/Entry (символ точки входа)](reference/entry-entry-point-symbol.md) .

> [!NOTE]
> Хотя можно указать другую функцию точки входа для библиотеки DLL с помощью параметра/ENTRY: компоновщика, мы не рекомендуем его, так как ваша функция-точка входа должна дублировать все, что `_DllMainCRTStartup` делает, в том же порядке. VCRuntime предоставляет функции, позволяющие дублировать свое поведение. Например, можно сразу вызвать метод [__security_init_cookie](../c-runtime-library/reference/security-init-cookie.md) для присоединения процессов, чтобы обеспечить поддержку параметра проверки буфера с параметром [/GS (проверка безопасности буфера)](reference/gs-buffer-security-check.md) . Можно вызвать функцию `_CRT_INIT`, передавая те же параметры, что и функция точки входа, для выполнения остальных функций инициализации или завершения DLL.

<a name="initializing-a-dll"></a>

## <a name="initialize-a-dll"></a>Инициализация библиотеки DLL

Библиотека DLL может содержать код инициализации, который должен выполняться при загрузке библиотеки DLL. Для выполнения собственных функций инициализации и завершения библиотеки DLL `_DllMainCRTStartup` вызывает функцию с именем `DllMain`, которую можно предоставить. У `DllMain` должна быть подпись, необходимая для точки входа библиотеки DLL. Функция точки входа по умолчанию `_DllMainCRTStartup` вызывает `DllMain` с использованием тех же параметров, которые передаются Windows. По умолчанию, если функция `DllMain` не предоставлена, Visual Studio предоставляет ее для вас и связывает ее с таким образом, чтобы `_DllMainCRTStartup` всегда вызывала что-то для вызова. Это означает, что если вам не нужно инициализировать библиотеку DLL, никаких особых действий при создании библиотеки DLL не требуется.

Это подпись, используемая для `DllMain`:

```cpp
#include <windows.h>

extern "C" BOOL WINAPI DllMain (
    HINSTANCE const instance,  // handle to DLL module
    DWORD     const reason,    // reason for calling function
    LPVOID    const reserved); // reserved
```

Некоторые библиотеки заключают функцию `DllMain`. Например, в обычной библиотеке DLL MFC Реализуйте функции-члены `InitInstance` и `ExitInstance` объекта `CWinApp` для выполнения инициализации и завершения, требуемых библиотекой DLL. Дополнительные сведения см. в разделе [Инициализация регулярных библиотек MFC](#initializing-regular-dlls) .

> [!WARNING]
> Существуют значительные ограничения на то, что можно безопасно делать в точке входа DLL. См. раздел [Общие рекомендации](/windows/win32/Dlls/dynamic-link-library-best-practices) для конкретных API Windows, которые ненадежны для вызова в `DllMain`. Если требуется что-то, но простейший способ инициализации, то это можно сделать в функции инициализации библиотеки DLL. Можно потребовать, чтобы приложения вызывали функцию инициализации после выполнения `DllMain` и перед вызовом любых других функций в библиотеке DLL.

<a name="initializing-non-mfc-dlls"></a>

### <a name="initialize-ordinary-non-mfc-dlls"></a>Инициализация обычных библиотек DLL (не MFC)

Чтобы выполнить собственную инициализацию в обычных (не MFC) библиотеках DLL, использующих VCRuntime точку входа `_DllMainCRTStartup`, исходный код библиотеки DLL должен содержать функцию с именем `DllMain`. Следующий код представляет собой базовую схему, показывающую, как может выглядеть определение `DllMain`:

```cpp
#include <windows.h>

extern "C" BOOL WINAPI DllMain (
    HINSTANCE const instance,  // handle to DLL module
    DWORD     const reason,    // reason for calling function
    LPVOID    const reserved)  // reserved
{
    // Perform actions based on the reason for calling.
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        // Initialize once for each new process.
        // Return FALSE to fail DLL load.
        break;

    case DLL_THREAD_ATTACH:
        // Do thread-specific initialization.
        break;

    case DLL_THREAD_DETACH:
        // Do thread-specific cleanup.
        break;

    case DLL_PROCESS_DETACH:
        // Perform any necessary cleanup.
        break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
```

> [!NOTE]
> В более старой документации Windows SDK говорится, что фактическое имя функции точки входа библиотеки DLL должно быть указано в командной строке компоновщика с параметром/ENTRY. В Visual Studio не нужно использовать параметр/ENTRY, если имя функции точки входа `DllMain`. Фактически, если вы используете параметр/ENTRY и называете функцию точки входа, отличную от `DllMain`, CRT не инициализируется должным образом, если функция точки входа не выполняет те же вызовы инициализации, которые `_DllMainCRTStartup` делают.

<a name="initializing-regular-dlls"></a>

### <a name="initialize-regular-mfc-dlls"></a>Инициализация регулярных библиотек DLL MFC

Так как обычные библиотеки DLL MFC имеют объект `CWinApp`, они должны выполнять задачи инициализации и завершения в том же расположении, что и приложение MFC: в `InitInstance` и `ExitInstance` функции-члены класса `CWinApp`, производного от библиотеки DLL. Поскольку MFC предоставляет функцию `DllMain`, которая вызывается `_DllMainCRTStartup` для `DLL_PROCESS_ATTACH` и `DLL_PROCESS_DETACH`, не следует писать собственную функцию `DllMain`. Предоставляемая MFC функция `DllMain` вызывает `InitInstance` при загрузке библиотеки DLL и вызывает `ExitInstance` перед выгрузкой библиотеки DLL.

Обычная библиотека DLL MFC может вести отслеживание нескольких потоков, вызывая [TlsAlloc](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsalloc) и [тлсжетвалуе](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsgetvalue) в своей функции `InitInstance`. Эти функции позволяют библиотеке DLL относить данные конкретного потока.

В обычной библиотеке DLL MFC, которая динамически связывается с MFC, если используется любая OLE-библиотека MFC, база данных MFC (или DAO) или поддержка сокетов MFC соответственно, отладка библиотек DLL расширения MFC МФКО*версии*d. dll, мфкд*версии*d. dll и мфкн*версии*d. dll (где *версия* — номер версии) автоматически связывается. Необходимо вызвать одну из следующих стандартных функций инициализации для каждой из этих библиотек DLL, которые используются в `CWinApp::InitInstance`е библиотеки DLL.

|Тип поддержки MFC|Вызываемая функция инициализации|
|-------------------------|-------------------------------------|
|MFC OLE (МФКО*версии*D. dll)|`AfxOleInitModule`|
|База данных MFC (МФКД*версии*D. dll)|`AfxDbInitModule`|
|Сокеты MFC (МФКН*версии*D. dll)|`AfxNetInitModule`|

<a name="initializing-extension-dlls"></a>

### <a name="initialize-mfc-extension-dlls"></a>Инициализация библиотек DLL расширения MFC

Так как библиотеки DLL расширения MFC не содержат объект, производный от `CWinApp`(как и обычные библиотеки DLL MFC), следует добавить код инициализации и завершения в функцию `DllMain`, создаваемую мастером MFC DLL.

Мастер предоставляет следующий код для библиотек DLL расширения MFC. В коде `PROJNAME` является заполнителем для имени проекта.

```cpp
#include "pch.h" // For Visual Studio 2017 and earlier, use "stdafx.h"
#include <afxdllx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
static AFX_EXTENSION_MODULE PROJNAMEDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      TRACE0("PROJNAME.DLL Initializing!\n");

      // MFC extension DLL one-time initialization
      AfxInitExtensionModule(PROJNAMEDLL,
                                 hInstance);

      // Insert this DLL into the resource chain
      new CDynLinkLibrary(Dll3DLL);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      TRACE0("PROJNAME.DLL Terminating!\n");
   }
   return 1;   // ok
}
```

Создание нового `CDynLinkLibrary` объекта во время инициализации позволяет библиотеке DLL расширения MFC экспортировать `CRuntimeClass` объекты или ресурсы в клиентское приложение.

Если вы собираетесь использовать библиотеку DLL расширения MFC из одной или нескольких обычных библиотек DLL MFC, необходимо экспортировать функцию инициализации, которая создает объект `CDynLinkLibrary`. Эта функция должна вызываться из каждой обычной библиотеки DLL MFC, использующей библиотеку DLL расширения MFC. Подходящее место для вызова этой функции инициализации находится в `InitInstance`ной функции-члене `CWinApp`объекта, производного от библиотеки DLL MFC, до использования экспортированных классов или функций библиотеки DLL расширения MFC.

В `DllMain`, создаваемом мастером MFC DLL, вызов `AfxInitExtensionModule` захватывает классы среды выполнения (структуры`CRuntimeClass`), а также фабрики объектов (объекты`COleObjectFactory`) для использования при создании объекта `CDynLinkLibrary`. Следует проверить возвращаемое значение `AfxInitExtensionModule`; Если в `AfxInitExtensionModule`возвращается нулевое значение, возвращается ноль из функции `DllMain`.

Если библиотека DLL расширения MFC будет явно связана с исполняемым файлом (то есть исполняемый объект вызывает `AfxLoadLibrary` для ссылки на библиотеку DLL), необходимо добавить вызов `AfxTermExtensionModule` на `DLL_PROCESS_DETACH`. Эта функция позволяет MFC очищать библиотеку DLL расширения MFC, когда каждый процесс отключается от библиотеки DLL расширения MFC (что происходит при завершении процесса или при выгрузке библиотеки DLL в результате вызова `AfxFreeLibrary`). Если библиотека DLL расширения MFC будет связана с приложением неявно, вызов `AfxTermExtensionModule` не требуется.

Приложения, которые явно связываются с библиотеками DLL расширения MFC, должны вызывать `AfxTermExtensionModule` при освобождении библиотеки DLL. Они также должны использовать `AfxLoadLibrary` и `AfxFreeLibrary` (вместо функций Win32 `LoadLibrary` и `FreeLibrary`), если приложение использует несколько потоков. Использование `AfxLoadLibrary` и `AfxFreeLibrary` гарантирует, что код запуска и завершения работы, выполняемый при загрузке и выгрузке библиотеки DLL расширения MFC, не повреждает глобальное состояние MFC.

Так как MFCx0. dll полностью инициализируется во время вызова `DllMain`, можно выделить память и вызвать функции MFC в `DllMain` (в отличие от 16-разрядной версии MFC).

Библиотеки DLL расширения могут позаботиться о многопоточности, обрабатывая `DLL_THREAD_ATTACH` и `DLL_THREAD_DETACH` варианты в функции `DllMain`. Эти случаи передаются в `DllMain` при присоединении и отсоединении потоков от библиотеки DLL. Вызов функции [TlsAlloc](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsalloc) при ПРИСОЕДИНЕНии библиотеки DLL позволяет библиотеке DLL поддерживать индексы локального хранилища потока (TLS) для каждого потока, присоединенного к библиотеке DLL.

Обратите внимание, что файл заголовка Афксдллкс. h содержит специальные определения структур, используемых в библиотеках DLL расширения MFC, например определение для `AFX_EXTENSION_MODULE` и `CDynLinkLibrary`. Этот заголовочный файл следует включить в библиотеку DLL расширения MFC.

> [!NOTE]
>  Важно не определять и не определять какие-либо макросы `_AFX_NO_XXX` в *PCH. h* (*stdafx. h* в Visual Studio 2017 и более ранних версиях). Эти макросы существуют только в целях проверки того, поддерживает ли конкретная целевая платформа эту функцию. Можно написать программу для проверки этих макросов (например, `#ifndef _AFX_NO_OLE_SUPPORT`), но программа не должна определять и не определять эти макросы.

Пример функции инициализации, обрабатывающей многопоточность, включается в [использование локального хранилища потока в библиотеке динамической компоновки](/windows/win32/Dlls/using-thread-local-storage-in-a-dynamic-link-library) в Windows SDK. Обратите внимание, что пример содержит функцию точки входа с именем `LibMain`, но ей следует присвоить имя `DllMain`, чтобы она работала с библиотеками MFC и среды выполнения C.

## <a name="see-also"></a>См. также раздел

[Создание библиотек DLL C/C++ в Visual Studio](dlls-in-visual-cpp.md)<br/>
[Точка входа DllMain](/windows/win32/Dlls/dllmain)<br/>
[Рекомендации по использованию библиотеки динамической компоновки](/windows/win32/Dlls/dynamic-link-library-best-practices)
