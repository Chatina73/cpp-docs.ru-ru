---
title: Библиотеки DLL и C++ поведение визуальной библиотеки времени выполнения
ms.date: 08/19/2019
f1_keywords:
- _DllMainCRTStartup
- CRT_INIT
helpviewer_keywords:
- DLLs [C++], entry point function
- process detach [C++]
- process attach [C++]
- DLLs [C++], run-time library behavior
- DllMain function
- _CRT_INIT macro
- _DllMainCRTStartup method
- run-time [C++], DLL startup sequence
- DLLs [C++], startup sequence
ms.assetid: e06f24ab-6ca5-44ef-9857-aed0c6f049f2
ms.openlocfilehash: 572a0ba70c1ba2d46d2d9fd6d8ac543a77bbbc01
ms.sourcegitcommit: 9d4ffb8e6e0d70520a1e1a77805785878d445b8a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2019
ms.locfileid: "69630372"
---
# <a name="dlls-and-visual-c-run-time-library-behavior"></a>Библиотеки DLL и C++ поведение визуальной библиотеки времени выполнения

При создании библиотеки динамической компоновки (DLL) с помощью Visual Studio по умолчанию компоновщик включает в себя визуальную C++ библиотеку времени выполнения (VCRuntime). VCRuntime содержит код, необходимый для инициализации и завершения исполняемого файлаC++ C/. При связывании с библиотекой DLL код VCRuntime предоставляет внутреннюю функцию `_DllMainCRTStartup` точки входа DLL, которая обрабатывает сообщения ОС Windows в библиотеке DLL для подключения или отсоединения от процесса или потока. `_DllMainCRTStartup` Функция выполняет такие задачи, как настройка безопасности буфера стека, инициализация и завершение библиотеки времени выполнения C (CRT), а также вызовы конструкторов и деструкторов для статических и глобальных объектов. `_DllMainCRTStartup`также вызывает функции-обработчики для других библиотек, таких как WinRT, MFC и ATL, для выполнения собственной инициализации и завершения. Без такой инициализации CRT и другие библиотеки, а также статические переменные будут оставаться в неинициализированном состоянии. Те же процедуры внутренней инициализации и завершения VCRuntime вызываются независимо от того, использует ли библиотека DLL статически связанную библиотеку CRT или динамически связанную DLL CRT.

## <a name="default-dll-entry-point-_dllmaincrtstartup"></a>Параметр _DllMainCRTStartup точки входа библиотеки DLL по умолчанию

В Windows все библиотеки DLL могут содержать необязательную функцию точки входа, обычно называемую `DllMain`, которая вызывается как для инициализации, так и для завершения. Это дает возможность выделять или освобождать дополнительные ресурсы по мере необходимости. Windows вызывает функцию точки входа в четырех ситуациях: присоединение процесса, отключение процесса, присоединение потока и отключение потока. Когда библиотека DLL загружается в адресное пространство процесса, либо при загрузке приложения, которое его использует, либо когда приложение запрашивает библиотеку DLL во время выполнения, операционная система создает отдельную копию данных библиотеки DLL. Это называется присоединением *процесса*. *Присоединение потока* происходит, когда процесс, загруженный библиотекой DLL, создает новый поток. *Отключение потока* происходит, когда поток завершается, и *отсоединение процесса* происходит, когда библиотека DLL больше не нужна и освобождается приложением. Операционная система выполняет отдельный вызов точки входа библиотеки DLL для каждого из этих событий, передавая аргумент *Reason* для каждого типа событий. Например, операционная система отправляет `DLL_PROCESS_ATTACH` в качестве аргумента *Reason* в сигнальное подключение процесса.

Библиотека VCRuntime предоставляет функцию точки входа, вызываемую `_DllMainCRTStartup` для управления операциями инициализации и завершения по умолчанию. При присоединении `_DllMainCRTStartup` процесса функция настраивает проверку безопасности буфера, инициализирует CRT и другие библиотеки, Инициализирует сведения о типах времени выполнения, инициализирует и вызывает конструкторы для статических и нелокальных данных, инициализирует локальное хранилище потока. , увеличивает внутренний статический счетчик для каждого присоединения, а затем вызывает предоставляемую `DllMain`пользователем или библиотеку. При отсоединении процесса функция проходит через эти действия в обратную. Он вызывает `DllMain`, уменьшает внутренний счетчик, вызывает деструкторы, вызывает функции завершения CRT и зарегистрированные `atexit` функции и уведомляет все другие библиотеки о завершении работы. Когда счетчик прикрепления переходит к нулю, функция возвращает `FALSE` значение, указывающее Windows, что DLL может быть выгружена. `_DllMainCRTStartup` Функция также вызывается во время присоединения потока и отключения потока. В этих случаях код VCRuntime не выполняет дополнительную инициализацию или завершение самостоятельно, а также только вызовы `DllMain` для передачи сообщения. Если `DllMain` возвращает `DllMain` `_DllMainCRTStartup` `DLL_PROCESS_DETACH` из процесса Attach, сбой сигнала, вызывается снова и передается в качестве аргумента Reason, а затем проходит оставшуюся часть процесса завершения. `FALSE`

При создании библиотек DLL в Visual Studio точка `_DllMainCRTStartup` входа по умолчанию, предоставляемая VCRuntime, связывается автоматически. Не нужно указывать функцию точки входа для библиотеки DLL с помощью параметра компоновщика [/Entry (символ точки входа)](reference/entry-entry-point-symbol.md) .

> [!NOTE]
> Хотя можно указать другую функцию точки входа для библиотеки DLL с помощью параметра/Entry: компоновщика, мы не советуем его использовать, так как ваша функция-точка входа должна дублировать все, что `_DllMainCRTStartup` происходит в том же порядке. VCRuntime предоставляет функции, позволяющие дублировать свое поведение. Например, можно сразу вызвать [__security_init_cookie](../c-runtime-library/reference/security-init-cookie.md) для процесса attach для поддержки параметра проверки буфера с параметром [/GS (проверка безопасности буфера)](reference/gs-buffer-security-check.md) . Можно вызвать `_CRT_INIT` функцию, передав те же параметры, что и функция точки входа, для выполнения остальных функций инициализации или завершения DLL.

<a name="initializing-a-dll"></a>

## <a name="initialize-a-dll"></a>Инициализация библиотеки DLL

Библиотека DLL может содержать код инициализации, который должен выполняться при загрузке библиотеки DLL. Для выполнения собственных функций `_DllMainCRTStartup` инициализации и завершения библиотеки DLL вызывается `DllMain` функция, которую можно предоставить. `DllMain` Необходимо иметь подпись, необходимую для точки входа DLL. Функция `_DllMainCRTStartup` точки входа по умолчанию `DllMain` вызывается с использованием тех же параметров, которые передаются Windows. По умолчанию, если `DllMain` функция не предоставлена, Visual Studio предоставляет ее для вас и связывает ее с таким образом, `_DllMainCRTStartup` чтобы всегда вызывалось действие. Это означает, что если вам не нужно инициализировать библиотеку DLL, никаких особых действий при создании библиотеки DLL не требуется.

Это подпись, используемая для `DllMain`:

```cpp
#include <windows.h>

extern "C" BOOL WINAPI DllMain (
    HINSTANCE const instance,  // handle to DLL module
    DWORD     const reason,    // reason for calling function
    LPVOID    const reserved); // reserved
```

Некоторые библиотеки заключают функцию в `DllMain` оболочку. Например, в обычной библиотеке DLL MFC реализуйте `CWinApp` функции `InitInstance` объекта и `ExitInstance` , чтобы выполнять инициализацию и завершение, необходимые для библиотеки DLL. Дополнительные сведения см. в разделе [Инициализация регулярных библиотек MFC](#initializing-regular-dlls) .

> [!WARNING]
> Существуют значительные ограничения на то, что можно безопасно делать в точке входа DLL. См. раздел [Общие рекомендации](/windows/win32/Dlls/dynamic-link-library-best-practices) для конкретных API-интерфейсов Windows, которые ненадежны для вызова в `DllMain`. Если требуется что-то, но простейший способ инициализации, то это можно сделать в функции инициализации библиотеки DLL. Можно потребовать, чтобы приложения вызывали функцию инициализации `DllMain` после выполнения и перед вызовом любых других функций в библиотеке DLL.

<a name="initializing-non-mfc-dlls"></a>

### <a name="initialize-ordinary-non-mfc-dlls"></a>Инициализация обычных библиотек DLL (не MFC)

Чтобы выполнить собственную инициализацию в обычных (не MFC) библиотеках DLL, использующих точку `_DllMainCRTStartup` входа VCRuntime, исходный код библиотеки DLL должен содержать функцию с именем `DllMain`. Следующий код представляет собой базовую схему, показывающую, как `DllMain` может выглядеть определение:

```cpp
#include <windows.h>

extern "C" BOOL WINAPI DllMain (
    HINSTANCE const instance,  // handle to DLL module
    DWORD     const reason,    // reason for calling function
    LPVOID    const reserved)  // reserved
{
    // Perform actions based on the reason for calling.
    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        // Initialize once for each new process.
        // Return FALSE to fail DLL load.
        break;

    case DLL_THREAD_ATTACH:
        // Do thread-specific initialization.
        break;

    case DLL_THREAD_DETACH:
        // Do thread-specific cleanup.
        break;

    case DLL_PROCESS_DETACH:
        // Perform any necessary cleanup.
        break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}
```

> [!NOTE]
> В более старой документации Windows SDK говорится, что фактическое имя функции точки входа библиотеки DLL должно быть указано в командной строке компоновщика с параметром/ENTRY. В Visual Studio не нужно использовать параметр/ENTRY, если для функции точки входа задано `DllMain`имя. Фактически, если вы используете параметр/Entry и называете функцию точки входа, отличную от `DllMain`, то CRT не инициализируется должным образом, если функция точки входа не выполняет одинаковые `_DllMainCRTStartup` вызовы инициализации.

<a name="initializing-regular-dlls"></a>

### <a name="initialize-regular-mfc-dlls"></a>Инициализация регулярных библиотек DLL MFC

Поскольку обычные библиотеки DLL MFC имеют `CWinApp` объект, они должны выполнять задачи инициализации и завершения в том же расположении, что и приложение MFC: `InitInstance` в функциях `CWinApp`-членах и `ExitInstance` , производных от DLL, см. `DllMain` Поскольку MFC предоставляет функцию, которая `DLL_PROCESS_ATTACH` `_DllMainCRTStartup` вызывается для и `DLL_PROCESS_DETACH`, не следует писать собственную `DllMain` функцию. Предоставляемая `DllMain` MFC функция вызывается `InitInstance` при загрузке библиотеки DLL и вызывает `ExitInstance` ее перед выгрузкой библиотеки DLL.

Обычная библиотека DLL MFC может вести отслеживание нескольких потоков, вызывая [TlsAlloc](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsalloc) и [тлсжетвалуе](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsgetvalue) в своей `InitInstance` функции. Эти функции позволяют библиотеке DLL относить данные конкретного потока.

В обычной библиотеке DLL MFC, которая динамически связывается с MFC, если используется любая OLE-библиотека MFC, база данных MFC (или DAO) или поддержка сокетов MFC соответственно, отладка библиотек DLL расширения MFC МФКО*версии*d. dll, мфкд*версии*d. dll и мфкн*версии*d. dll ( где *версия* — номер версии), связываются автоматически. Необходимо вызвать одну из следующих стандартных функций инициализации для каждой из этих библиотек DLL, которые используются в обычной библиотеке DLL `CWinApp::InitInstance`MFC.

|Тип поддержки MFC|Вызываемая функция инициализации|
|-------------------------|-------------------------------------|
|MFC OLE (МФКО*версии*D. dll)|`AfxOleInitModule`|
|База данных MFC (МФКД*версии*D. dll)|`AfxDbInitModule`|
|Сокеты MFC (МФКН*версии*D. dll)|`AfxNetInitModule`|

<a name="initializing-extension-dlls"></a>

### <a name="initialize-mfc-extension-dlls"></a>Инициализация библиотек DLL расширения MFC

Так как библиотеки DLL расширения MFC не имеют `CWinApp`производного объекта (как и обычные библиотеки DLL MFC), следует добавить код инициализации и завершения `DllMain` в функцию, создаваемую мастером MFC DLL.

Мастер предоставляет следующий код для библиотек DLL расширения MFC. В коде `PROJNAME` — это заполнитель для имени проекта.

```cpp
#include "pch.h" // For Visual Studio 2017 and earlier, use "stdafx.h"
#include <afxdllx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
static AFX_EXTENSION_MODULE PROJNAMEDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      TRACE0("PROJNAME.DLL Initializing!\n");

      // MFC extension DLL one-time initialization
      AfxInitExtensionModule(PROJNAMEDLL,
                                 hInstance);

      // Insert this DLL into the resource chain
      new CDynLinkLibrary(Dll3DLL);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
   {
      TRACE0("PROJNAME.DLL Terminating!\n");
   }
   return 1;   // ok
}
```

Создание нового `CDynLinkLibrary` объекта во время инициализации позволяет библиотеке DLL расширения MFC экспортировать `CRuntimeClass` объекты или ресурсы в клиентское приложение.

Если вы собираетесь использовать библиотеку DLL расширения MFC из одной или нескольких обычных библиотек DLL MFC, необходимо экспортировать функцию инициализации, которая создает `CDynLinkLibrary` объект. Эта функция должна вызываться из каждой обычной библиотеки DLL MFC, использующей библиотеку DLL расширения MFC. Подходящее место для вызова этой функции инициализации находится в `InitInstance` функции `CWinApp`-члене объекта, производного от библиотеки DLL MFC, перед использованием любых экспортированных классов или функций библиотеки DLL расширения MFC.

`CRuntimeClass` `AfxInitExtensionModule` `CDynLinkLibrary` `COleObjectFactory` В мастере MFC DLL создает вызов для захвата классов среды выполнения (структур) и фабрик объектов (объектов) для использования при создании объекта. `DllMain` Необходимо проверить возвращаемое значение `AfxInitExtensionModule`; Если нулевое значение возвращается из `AfxInitExtensionModule` `DllMain` функции, возвращается ноль.

Если библиотека DLL расширения MFC будет явно связана с исполняемым файлом (т `AfxLoadLibrary` `DLL_PROCESS_DETACH`. е. исполняемые вызовы для связывания с библиотекой DLL), необходимо добавить `AfxTermExtensionModule` вызов в. Эта функция позволяет MFC очищать библиотеку DLL расширения MFC, когда каждый процесс отключается от библиотеки DLL расширения MFC (что происходит при завершении процесса или при выгрузке библиотеки DLL в результате `AfxFreeLibrary` вызова). Если библиотека DLL расширения MFC будет связана неявно с приложением, вызов метода `AfxTermExtensionModule` не требуется.

Приложения, которые явно связываются с библиотеками DLL `AfxTermExtensionModule` расширения MFC, должны вызываться при освобождении библиотеки DLL. Они также должны использовать `AfxLoadLibrary` и `AfxFreeLibrary` (вместо функций `LoadLibrary` Win32 и `FreeLibrary`), если приложение использует несколько потоков. Использование `AfxLoadLibrary` и`AfxFreeLibrary` гарантирует, что код запуска и завершения работы, выполняемый при загрузке и выгрузке библиотеки DLL расширения MFC, не повреждает глобальное состояние MFC.

Поскольку MFCx0. dll полностью инициализируется во время `DllMain` вызова, можно выделить память и вызвать функции MFC в `DllMain` (в отличие от 16-разрядной версии MFC).

Библиотеки DLL расширения могут позаботиться о многопоточности, обрабатывая `DLL_THREAD_ATTACH` сценарии `DLL_THREAD_DETACH` и в `DllMain` функции. Эти случаи передаются `DllMain` в, когда потоки присоединяются к библиотеке DLL и отсоединяются от нее. Вызов функции [TlsAlloc](/windows/win32/api/processthreadsapi/nf-processthreadsapi-tlsalloc) при ПРИСОЕДИНЕНии библиотеки DLL позволяет библиотеке DLL поддерживать индексы локального хранилища потока (TLS) для каждого потока, присоединенного к библиотеке DLL.

Обратите внимание, что файл заголовка афксдллкс. h содержит специальные определения структур, используемых в библиотеках DLL расширения MFC, например `AFX_EXTENSION_MODULE` определение `CDynLinkLibrary`для и. Этот заголовочный файл следует включить в библиотеку DLL расширения MFC.

> [!NOTE]
>  Важно не определять и не определять какие-либо `_AFX_NO_XXX` макросы в *PCH. h* (*stdafx. h* в Visual Studio 2017 и более ранних версиях). Эти макросы существуют только в целях проверки того, поддерживает ли конкретная целевая платформа эту функцию. Вы можете написать программу для проверки этих макросов (например, `#ifndef _AFX_NO_OLE_SUPPORT`), но программа не должна определять и не определять эти макросы.

Пример функции инициализации, обрабатывающей многопоточность, включается в [использование локального хранилища потока в библиотеке динамической компоновки](/windows/win32/Dlls/using-thread-local-storage-in-a-dynamic-link-library) в Windows SDK. Обратите внимание, что пример содержит функцию точки входа с `LibMain`именем, но ей следует присвоить имя `DllMain` , чтобы она работала с библиотеками MFC и среды выполнения C.

## <a name="see-also"></a>См. также

[Создание библиотек DLL C/C++ в Visual Studio](dlls-in-visual-cpp.md)<br/>
[Точка входа DllMain](/windows/win32/Dlls/dllmain)<br/>
[Рекомендации по использованию библиотеки динамической компоновки](/windows/win32/Dlls/dynamic-link-library-best-practices)
