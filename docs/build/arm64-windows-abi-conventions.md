---
title: Обзор соглашений ARM64 ABI
ms.date: 03/27/2019
ms.openlocfilehash: bfb1b5b6be6a7a368c2ed7cab255da90ae7a22df
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2019
ms.locfileid: "65220986"
---
# <a name="overview-of-arm64-abi-conventions"></a>Обзор соглашений ARM64 ABI

Двоичный интерфейс основного приложения (ABI) для Windows, при компиляции и выполнения на процессорах ARM в 64-разрядном режиме (ARMv8 или более поздней версии архитектур), в большинстве случаев следует стандартный AArch64 EABI в ARM. В этой статье описаны некоторые ключевые допущения и изменения от описанных в EABI. Сведения об интерфейсе ABI 32-разрядной, см. в разделе [соглашений ABI ARM Обзор](overview-of-arm-abi-conventions.md). Дополнительные сведения о стандартных ARM EABI, см. в разделе [двоичным интерфейсом приложений (ABI) для архитектуры ARM](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) (внешняя ссылка).

## <a name="definitions"></a>Определения

С появлением поддержка 64-разрядных ARM определено несколько терминов:

- **AArch32** — набора устаревших инструкций 32-разрядной архитектуре (ISA) определяется ARM, включая выполнение в режиме Thumb.
- **AArch64** — новый 64-разрядных инструкций задать архитектуры (ISA) определяется ARM.
- **ARMv7** — спецификация «7» поколения оборудования ARM, который будет включать только поддержка AArch32. Эта версия оборудования ARM является первой версии Windows для ARM поддерживается.
- **ARMv8** — спецификация «8-го поколения» оборудование ARM, которое включает в себя поддержку AArch32 и AArch64.

Windows также используются следующие термины.

- **ARM** — ссылается на 32-разрядной архитектуры ARM (AArch32), иногда называют WoA (Windows на ARM).
- **ARM32** — то же, что ARM, выше; используются в этом документе для ясности.
- **ARM64** — ссылается на 64-разрядной архитектуры ARM (AArch64). Нет такого понятия, как WoA64.

Наконец при ссылке на типы данных, указываются следующие определения из ARM:

- **Короткий вектор** — тип данных, напрямую можно представить в SIMD, 8 или 16 байт, накопленные элементов вектора. Она выравнивается размер 8 байт или 16 байт, где каждый элемент может быть 1, 2, 4 или 8 байт.
- **HFA (агрегатом однородных с плавающей запятой)** — тип данных со 2 по 4 одинаковых элементов с плавающей запятой, расположенном или удваивается.
- **HVA (агрегатом однородных короткого вектора)** — тип данных с 2 до 4 одинаковых элементов короткого вектора.

## <a name="base-requirements"></a>Основные требования

ARM64 версию Windows предполагает, что он работает под управлением ARMv8 или более поздней версии архитектуры в любое время. Оба с плавающей запятой и поддержки NEON считаются должны присутствовать в оборудовании.

Спецификация ARMv8 обеспечивает полную поддержку AArch32 приложений. Тем не менее поддержка существующих приложений ARM32 ARM64 версия Windows не планируется. (То есть не планируем для WOW64). Эта поддержка регулируется повторной оценки в будущем, но текущий рабочий предположить.

В спецификации ARMv8 описывает новый необязательный шифрования и коды операций вспомогательный CRC для AArch32 и AArch64. Поддержка для них в данный момент необязательно, но рекомендуется. Чтобы воспользоваться преимуществами этих кодов операций, приложения должны сначала проверки времени выполнения для их существования.

## <a name="endianness"></a>Порядок байтов

Как и при работе с ARM32 в прямом режиме выполняет версии Windows на Windows ARM64. Переключение порядка следования байтов сложно добиться без поддержки режима ядра в AArch64, чтобы упростить для принудительного применения.

## <a name="alignment"></a>Выравнивание

На ARM64 с Windows позволяет оборудованию ЦП прозрачно обрабатывать невыровненные обращения к. В улучшение из AArch32 эта поддержка теперь также работает все при обращении к целым (включая доступ нескольких слов), а также для доступа с плавающей запятой.

Тем не менее доступ к памяти без кэширования (устройство) по-прежнему должны всегда быть выровнены. Если код может возможно чтение или запись невыровненных данных из памяти без кэширования, его необходимо убедиться в том выровнять все доступы к.

Выравнивание макета по умолчанию для локальных переменных:

| Размер в байтах | Выравнивание в байтах |
| - | - |
| 1 | 1 |
| 2 | 2 |
| 3, 4 | 4 |
| > 4 | 8 |

Выравнивание макета по умолчанию для глобальных переменных и статических элементов:

| Размер в байтах | Выравнивание в байтах |
| - | - |
| 1 | 1 |
| 2 - 7 | 4 |
| 8 - 63 | 8 |
| >= 64 | 16 |

## <a name="integer-registers"></a>Целочисленные регистры

Архитектура AArch64 поддерживает 32 целочисленные регистры:

| Регистровое | Переменный? | Роль |
| - | - | - |
| x0 | Переменный | Параметр/нуля зарегистрировать 1, результат регистрация |
| x1-x7 | Переменный | Параметр/нуля register 2 – 8 |
| x8-x15 | Переменный | Регистры |
| x16 x17 | Переменный | Регистры INTRA вызов процедуры |
| x18 | Неизменяемый | Регистрация платформы: в режиме ядра, указывающий KPCR для текущего процессора; в пользовательском режиме указывает на TEB |
| x19 x28 | Неизменяемый | Регистры |
| x29/fp | Неизменяемый | Указатель фрейма |
| x30/lr | Неизменяемый | Регистрирует ссылку |

Каждого из регистров может осуществляться как значение 64-разрядных (через x0-x30) или как 32-разрядное значение (с помощью w0-w30). 32-разрядных операций ноль расширить свои результаты до 64 бит.

См. в разделе Передача разделе Дополнительные сведения об использовании регистров параметра параметров.

В отличие от AArch32 счетчик команд (PC) и указатель стека (SP) не индексированное регистров. Они ограничены в том, как можно получить доступ. Также Обратите внимание, что не x31 зарегистрировать. Что кодировка, используемая для особых целей.

Указатель кадра (x29) является обязательным для совместимости с быстрой проверки стека используемые трассировки событий Windows и других служб. Оно должно указывать на предыдущем {x29, x 30} пары в стеке.

## <a name="floating-pointsimd-registers"></a>Регистры с плавающей запятой/SIMD

Архитектура AArch64 также поддерживает 32 регистров с плавающей точкой запятой/SIMD, представлены ниже:

| Регистровое | Переменный? | Роль |
| - | - | - |
| V0 | Переменный | Параметр/нуля зарегистрировать 1, результат регистрация |
| v1-v7 | Переменный | Параметр/нуля регистрирует 2 – 8 |
| версия 15 v8 | Неизменяемый | Регистрирует нуля (только младшие 64 разряда долговременного) |
| v16 v31 | Переменный | Регистры |

Каждого из регистров возможен как значение 128-разрядным (через v0 v31 или q0 q31). Он возможен как 64-разрядное значение (с помощью d0-d31), как 32-разрядное значение (с помощью s0-s31), как 16-разрядное значение (с помощью h0-h31), или как 8-разрядное значение (через b0-b31). Обращений к меньше, чем 128 бит доступ только к младшие битов 128-разрядного регистра. Оставшиеся биты они оставьте без изменений, если не указано иное. (AArch64 отличается от AArch32, где были упакованы меньше регистров поверх регистры большего размера.)

Регистр с плавающей точкой управления (FPCR) имеет определенные требования на различные битовые поля внутри него:

| Bits | Значение | Переменный? | Роль |
| - | - | - | - |
| 26 | AHP | Неизменяемые | Альтернативное управление с половинной точностью. |
| 25 | DN | Неизменяемые | Управление режимом по умолчанию NaN. |
| 24 | FZ | Неизменяемый | Управление режимом Flush к нулю. |
| 23—22 | RMode | Неизменяемый | Управление режимом округления. |
| 15,12-8 | IDE, IXE и т. д | Неизменяемые | Исключение биты отслеживания, всегда должен быть 0. |

## <a name="system-registers"></a>Регистры системы

Как AArch32 спецификация AArch64 предоставляет три контролем системы «ИД потока» реестра:

| Регистровое | Роль |
| - | - |
| TPIDR_EL0 | Зарезервировано. |
| TPIDRRO_EL0 | Содержит номер ЦП для текущего процессора. |
| TPIDR_EL1 | Указывает на структуру KPCR для текущего процессора. |

## <a name="floating-point-exceptions"></a>Исключения с плавающей запятой

Поддержка исключений с плавающей запятой IEEE является необязательным в системах AArch64. Для процессора вариантов, имеющих аппаратные исключения с плавающей запятой ядро Windows автоматически перехватывает эти исключения и неявно отключает их в регистре FPCR. Эту ловушку обеспечивается нормализованное поведение на вариантах процессоров. В противном случае — код, разработанный на платформе без поддержки исключений может оказаться самой принимая непредвиденные исключения при работе на платформе с поддержкой.

## <a name="parameter-passing"></a>Передача параметров

Для функции не с переменным числом аргументов Windows ABI соответствует правилам, определенным ARM для передачи параметров. Эти правила являются непосредственно выдержки из книги стандарту вызова процедур для архитектуры AArch64:

### <a name="stage-a--initialization"></a>Этап А — инициализация

Этот этап выполняется только один раз, перед началом обработки аргументов.

1. Далее общего назначения зарегистрировать номер (NGRN), равным нулю.

1. Далее SIMD и зарегистрировать число с плавающей запятой (NSRN), равным нулю.

1. Следующий адрес с накоплением аргумента (NSAA) устанавливается с текущим значением указателя стека (SP).

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>Этап Б — предварительного заполнения и расширение аргументов

Для каждого аргумента в списке применяется первое соответствующее правило из следующего списка. Если совпадений нет правила, аргумент используется без изменений.

1. Если аргумент имеет тип, размер которого не удается определить статически, вызывающий и вызываемый объект составной тип, аргумент копируется в память и аргумент заменяется указатель для копирования. (Отсутствуют такие типы в C/C++, но они существуют на других языках или на расширения языка).

1. Если аргумент имеет тип HFA или HVA, то используется аргумент без изменений.

1. Если аргумент имеет тип составной тип, размер которых превышает 16 байт, затем аргумент копируется в память, выделенную вызывающим и аргумент заменяется указатель для копирования.

1. Если аргумент имеет тип составной тип, то размер аргумента округляется до ближайшего кратного 8 байт.

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>Этап C — назначение аргументов регистрам и стеку

Для каждого аргумента в списке следующие правила применяются в свою очередь, пока не выделен аргумент. При назначении аргумента кассе всех неиспользуемых битов в регистре не указаны значения. Если аргумент назначается слот стека, все неиспользуемые заполнения байты не указаны значения.

1. Если аргумент равен половине-, одно-, двойной или Quad одиночной точности с плавающей запятой или типа короткого вектора и NSRN меньше 8, то аргумент назначается до наименее значащий бит регистра v\[NSRN]. NSRN увеличивается на единицу. Аргумент выделен.

1. Если аргумент является HFA или HVA недостаточно нераспределенного SIMD и регистров с плавающей запятой (NSRN + число членов ≤ 8), аргумент назначается SIMD и регистры с плавающей запятой, один регистр на член HFA или HVA. NSRN увеличивается на число использованных регистров. Аргумент выделен.

1. Если аргумент является HFA или HVA, затем NSRN установлено значение 8 и размер аргумента округляется вверх до ближайшего числа, кратного 8 байт.

1. Если аргумент является HFA, HVA, Quad одиночной точности с плавающей запятой или короткие векторного типа, то адрес NSAA округляется до большего размера, 8 или естественному выравниванию типа аргумента.

1. Если аргумент имеет тип половина - или одиночной точности с плавающей запятой, размер аргумента присваивается 8 байт. Эффект как если бы аргумент были скопированы младших разрядов 64-битным регистром, а оставшиеся биты заполняются неуказанных значения.

1. Если аргумент является HFA, HVA, половина-, одно-, Double- или Quad одиночной точности с плавающей запятой или типа короткого вектора, то аргумент копируется в память по скорректированному NSAA. Адрес NSAA увеличивается на размер аргумента. Аргумент выделен.

1. Если аргумент — это целочисленный тип или тип указателя, размер аргумента меньше или равно 8 байт и NGRN — меньше, чем 8, аргумент копируется в младших бит в x\[NGRN]. NGRN увеличивается на единицу. Аргумент выделен.

1. Если аргумент имеет выравниванием 16, затем NGRN округляется до ближайшего четного числа.

1. Если аргумент — это целочисленный тип, размер аргумента равно 16 и NGRN — меньше, чем 7, аргумент копируется в x\[NGRN] и x\[NGRN + 1]. x\[NGRN] должен содержать известные проблемы двойной разряды представления памяти аргумента. NGRN увеличивается на два. Аргумент выделен.

1. Если аргумент имеет составной тип и размер в двойные слова аргумента не более 8 минус NGRN, то аргумент копируется в последовательных регистры общего назначения, начиная с x\[NGRN]. Аргумент, передаваемый как будто он загружен в регистры с двойной word-выровненный по осям адреса, с соответствующей последовательности инструкций LDR, загрузка последовательных регистров из памяти. Содержимое все неиспользуемые части регистров этот атрибут не задан, этот стандарт. NGRN увеличивается на число использованных регистров. Аргумент выделен.

1. NGRN установлено значение 8.

1. Адрес NSAA округляется до большего размера, 8 или естественному выравниванию типа аргумента.

1. Если аргумент имеет составной тип, аргумент копируется в память по скорректированному NSAA. Адрес NSAA увеличивается на размер аргумента. Аргумент выделен.

1. Если размер аргумента меньше, чем 8 байт, то размер аргумента присваивается 8 байт. Действует так, как если аргумент был скопирован в младших разрядов 64-битным регистром, а оставшиеся биты заполненных неуказанных значениями.

1. Аргумент копируется в память по скорректированному NSAA. Адрес NSAA увеличивается на размер аргумента. Аргумент выделен.

### <a name="addendum-variadic-functions"></a>Приложение: Функции с переменным числом аргументов

Функций, принимающих переменное число аргументов обрабатываются иначе, чем выше, следующим образом:

1. Все сочетания обрабатываются alike; без специальной обработки HFAs или HVAs.

1. SIMD и регистры с плавающей запятой не используются.

Фактически это так же, как следующие правила C.12–C.15 выделить аргументы мнимой стек, первые 64 байт стека будут загружены в x0 x7, куда обычно помещаются все остальные аргументы стека.

## <a name="return-values"></a>Возвращаемые значения

Целочисленные значения возвращаются в x0.

Значения с плавающей запятой возвращаются в s0, d0 или v0, соответствующим образом.

HFA и HVA значения возвращаются в s0 s3, d0 d3 или v0-v3, соответствующим образом.

Типы, возвращаемые значения обрабатываются по-разному в зависимости от наличия у них определенные свойства. Типы, которые имеют все эти свойства

- они *агрегатные* по C ++ 14 стандартного определения, то есть они имеют не заданных пользователем конструкторов, без закрытых или защищенных нестатических данных-членов, без базовых классов и виртуальных функций, и
- у них есть оператор тривиальные копирования и присваивания и
- у них есть тривиальный деструктор,

Используйте возвращаемое следующий стиль:

- Типы, меньше или равно 8 байт, возвращаются в x0.
- Типы, меньше или равно 16 байт, возвращаются в x0 и x1 с x0 содержащее младшие 8 байт.
- Типы превышать 16 байт вызывающий объект должен оставляем за собой блок памяти, достаточный размер и выравнивание для хранения результата. Адрес блока памяти должны передаваться в качестве дополнительного аргумента в функцию x8. Вызываемый объект может изменить результат блок памяти в любой момент во время выполнения подпрограммы. Вызываемый объект не обязательно должна сохранить значение, хранящееся в x8.

Все остальные типы использования:

- Вызывающий объект должен резервировать блок памяти, достаточный размер и выравнивание для хранения результата. Адрес блока памяти должны передаваться как дополнительный аргумент в функцию x0 или x1 Если $, эти данные передаются в x0. Вызываемый объект может изменить результат блок памяти в любой момент во время выполнения подпрограммы. Вызываемый объект возвращает адрес блока памяти в x0.

## <a name="stack"></a>Стек

После интерфейса ABI, изданным советом по ARM стек должен оставаться 16-байтовый выровненным по. AArch64 содержит аппаратная функция, которая создает ошибок выравнивания стека, каждый раз, когда хранимой Процедуры не является 16-байтовым и выполняется относительно SP загрузки или хранения. Windows работает эта функция включена, все время.

Функции, выделяющие 4 КБ или больше стоит стека необходимо убедиться, что каждая страница перед последней обрабатывается по порядку. Таким образом, код не может «рост по сравнению» страницы защиты, которые Windows использует для расширения стека. Обычно касается осуществляется `__chkstk` вспомогательного приложения, который имеет пользовательское соглашение об именовании, которое передает все выделение стека, деленное на 16 в x15.

## <a name="red-zone"></a>Красная зона

Область 16-байтовый сразу после текущего указателя стека, зарезервированные для использования в процессе анализа и динамического исправления сценариев. Эта область позволяет тщательно созданный код для вставки, где хранятся два регистров в [sp, #-16] и временно использует их для произвольных целей. Ядро Windows гарантирует, что эти 16 байт не влияли на при возникновении исключения или прерывания переводе, в режиме ядра и пользователей.

## <a name="kernel-stack"></a>Стек ядра

Стек режима ядра по умолчанию в Windows — шесть страниц (24 КБ). Особое внимание на функции с большого буфера стека в режиме ядра. Прерывание несвоевременное удалось передающихся только небольшой запас и создайте проверку на наличие ошибок критической ошибки стека.

## <a name="stack-walking"></a>Проверка стека

Код Windows компилируется с включенными указателями фреймов ([/Oy-](reference/oy-frame-pointer-omission.md)) для обеспечения быстрой проверки стека. Как правило, x29 (fp) указывает на следующее звено в цепочке, который является {fp, lr} пары, указывающее, является указатель к предыдущему кадру в стеке, а обратный адрес. Сторонний код, стоит включить указатели фреймов, улучшенная профилирования и трассировки.

## <a name="exception-unwinding"></a>Очистка исключения

Очистка во время обработки исключений является телефоны службы при помощи кодов очистки. Коды очистки представляют собой последовательность байт, хранимых в разделе .xdata исполняемого файла. Они описывают работу пролога и эпилога отвлеченно, таким образом, чтобы воздействие пролога функции могут быть отменены в рамках подготовки к применению кадра стека вызывающего при архивации. Дополнительные сведения о кодах очистки, см. в разделе [обработки исключений ARM64](arm64-exception-handling.md).

ARM EABI также задает модель очистки исключения, который использует коды очистки. Тем не менее спецификации, представленный недостаточно для очистки в Windows, так как требуется обрабатывать случаи, когда компьютер находится в середине функция пролога или эпилога.

Должны быть описаны код, который создается динамически с помощью таблицы динамических функций через `RtlAddFunctionTable` и связанных функций, таким образом, чтобы созданный код может участвовать в обработке исключений.

## <a name="cycle-counter"></a>Счетчик циклов

Все ЦП ARMv8 обязаны поддерживать счетчик циклов зарегистрировать, 64-битным регистром, который настраивает Windows, чтобы их было читать на любом уровне исключения, включая пользовательском режиме. Он может осуществляться через специальный PMCCNTR_EL0 зарегистрировать, с помощью кода MSR операций в коде сборки или `_ReadStatusReg` с C /C++ кода.

Счетчик цикла — это действительно счетчик, не определенное время. Частота подсчета зависит от частоты процессора. Если вы считаете, что необходимо знать частоту счетчика циклов, не следует использовать счетчик циклов. Вместо этого необходимо измерить время по часам, для которого следует использовать `QueryPerformanceCounter`.

## <a name="see-also"></a>См. также

[Общие вопросы использования Visual C++ ARM](common-visual-cpp-arm-migration-issues.md)<br/>
[Обработка исключений ARM64](arm64-exception-handling.md)
