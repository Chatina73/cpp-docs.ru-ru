---
title: Общие сведения о соглашениях ABI ARM64
ms.date: 03/27/2019
ms.openlocfilehash: 07d58bbd64795235ad63a7b26b6f18fcffdcd1d2
ms.sourcegitcommit: 069e3833bd821e7d64f5c98d0ea41fc0c5d22e53
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2019
ms.locfileid: "74303272"
---
# <a name="overview-of-arm64-abi-conventions"></a>Общие сведения о соглашениях ABI ARM64

Базовый интерфейс приложения (ABI) для Windows при компиляции и запуске на процессорах ARM в 64-разрядном режиме (архитектура ARMv8 или более поздней версии) в большинстве случаев следует стандартному AArch64 EABI ARM. В этой статье описываются некоторые основные предположения и изменения, описанные в EABI. Дополнительные сведения о 32-разрядном ABI см. в разделе [Общие сведения о соглашениях ARM ABI](overview-of-arm-abi-conventions.md). Дополнительные сведения о стандартном EABI ARM см. [в разделе интерфейс двоичных данных приложения (ABI) для архитектуры ARM](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) (внешняя ссылка).

## <a name="definitions"></a>Определения

С появлением поддержки 64-разрядной версии ARM определил несколько терминов:

- **AArch32** — устаревшая 32-разрядная архитектура набора инструкций (ISA), определяемая ARM, включая выполнение в режиме Thumb.
- **AArch64** — новая 64-разрядная архитектура набора инструкций (ISA), определяемая ARM.
- **ARMv7** — спецификация оборудования ARM с поколением 7, которое включает поддержку AArch32. Эта версия оборудования ARM — это первая версия Windows для поддержки ARM.
- **ARMv8** — Спецификация аппаратного обеспечения ARM "8-го поколения", которая включает поддержку как AArch32, так и AArch64.

Windows также использует следующие термины:

- **ARM** — это 32-разрядная архитектура ARM (AArch32), которая иногда называется ВОА (Windows on ARM).
- **ARM32** — то же, что и ARM, выше; используется в этом документе для ясности.
- **ARM64** — относится к архитектуре 64-разрядной ARM (AArch64). Это не так, как WoA64.

Наконец, при ссылке на типы данных указываются следующие определения из ARM:

- **Short-Vector** — тип данных, который непосредственно представляется в SIMD, является вектором размером 8 байт или 16 байт. Он соответствует размеру (8 или 16 байт), где каждый элемент может иметь значение 1, 2, 4 или 8 байт.
- **Хфа (однородное статистическое выражение с плавающей запятой)** — тип данных с 2 до 4 идентичными элементами с плавающей запятой либо с плавающей точкой, либо с типом Double.
- **Хва (однородное сокращенное векторное объединение)** — тип данных с 2 до 4 идентичных элементов с коротким вектором.

## <a name="base-requirements"></a>Базовые требования

ARM64 версия Windows представим, что она работает в архитектуре ARMv8 или более поздней версии. Как поддержка с плавающей запятой, так и NEON, предполагается наличие оборудования.

Спецификация ARMv8 описывает новые необязательные вспомогательные коды операций шифрования и CRC для AArch32 и AArch64. В настоящее время поддержка этих файлов необязательна, но рекомендуется. Чтобы воспользоваться преимуществами этих кодов операций, приложения должны сначала выполнить проверку среды выполнения на предмет их существования.

## <a name="endianness"></a>Порядок байтов

Как и в случае с ARM32 версией Windows, в ARM64 Windows выполняется в режиме с прямым порядком байтов. Переключение порядок следования байтов сложно реализовать без поддержки режима ядра в AArch64, поэтому его проще применять.

## <a name="alignment"></a>Выравнивание

Windows, работающая на ARM64, позволяет аппаратному оборудованию прозрачно поддерживать неправильное согласованное использование. В усовершенствовании от AArch32 эта поддержка теперь также работает для всех целочисленных операций доступа (включая многословные) и для доступа с плавающей запятой.

Однако доступ к некэшированной памяти (устройству) по-прежнему всегда должен быть согласован. Если код может считывать или записывать неправильно выделенные данные из некэшированной памяти, необходимо обеспечить согласованность всех обращений.

Выравнивание макета по умолчанию для локальных переменных:

| Размер в байтах | Выравнивание в байтах |
| - | - |
| 1 | 1 |
| 2 | 2 |
| 3, 4 | 4 |
| > 4 | 8 |

Выравнивание макета по умолчанию для глобальных и статических элементов:

| Размер в байтах | Выравнивание в байтах |
| - | - |
| 1 | 1 |
| 2 - 7 | 4 |
| 8 - 63 | 8 |
| > = 64 | 16 |

## <a name="integer-registers"></a>Целочисленные регистры

Архитектура AArch64 поддерживает 32 целочисленных регистров:

| Регистровое | Переменный? | Роль |
| - | - | - |
| x0 | Переменный | Параметр или вспомогательный регистр 1, регистр результатов |
| x1 — 120x7x1 | Переменный | Регистр параметров и временных файлов 2-8 |
| x8-X15 | Переменный | Временных регистров |
| x16-x17 | Переменный | Временных регистров вызова внутри процедуры |
| x18 | Неизменяемый | Регистр платформы: в режиме ядра указывает на КПКР для текущего процессора; в пользовательском режиме указывает на ТЕБ |
| x19-x28 | Неизменяемый | Временных регистров |
| X29/FP | Неизменяемый | Указатель фрейма |
| x30/LR | Неизменяемый | Регистры ссылок |

К каждому регистру можно обращаться как к полному 64-разрядному значению (через x0-x30) или в виде 32-разрядного значения (через W0-W30). в 32-разрядных операциях ноль — расширение их результатов до 64 бит.

Дополнительные сведения об использовании регистров параметров см. в разделе Передача параметров.

В отличие от AArch32, счетчик программы (PC) и указатель стека (SP) не индексируют регистры. Они ограничены тем, как они могут быть доступны. Также обратите внимание, что отсутствует регистр x31. Эта кодировка используется в особых целях.

Указатель фрейма (X29) необходим для обеспечения совместимости с быстрым проходом стека, используемым ETW и другими службами. Он должен указывать на предыдущую пару {X29, x30} в стеке.

## <a name="floating-pointsimd-registers"></a>Регистры с плавающей запятой/SIMD

Архитектура AArch64 также поддерживает 32 регистров с плавающей запятой и SIMD, приведенные ниже.

| Регистровое | Переменный? | Роль |
| - | - | - |
| v0 | Переменный | Параметр или вспомогательный регистр 1, регистр результатов |
| v1 — версии 7 | Переменный | Реестр параметров и временных файлов 2-8 |
| V8 — версия 15 | Неизменяемый | Временные регистры (только младшие 64 бита не поддерживаются) |
| v16-v31 | Переменный | Временных регистров |

К каждому регистру можно обращаться как к полному 128-разрядному значению (через v0-v31 или Q0-Q31). Доступ к нему можно получить в виде 64-разрядного значения (через D0-D31) в виде 32-разрядного значения (через S0-S31) в виде 16-разрядного значения (через H0-H31) или в виде 8-разрядного значения (через B0-B31). Доступ меньше 128 бит доступа только к младшим битам полного 128-битного регистра. Оставшиеся биты остаются нетронутыми, если не указано иное. (AArch64 отличается от AArch32, где малые регистры были упакованы поверх больших регистров.)

Регистр управления с плавающей запятой (ФПКР) имеет определенные требования к различным битовых полей в нем:

| Bits | Значение | Переменный? | Роль |
| - | - | - | - |
| 26 | AHP | Без временных | Альтернативный элемент управления половинной точностью. |
| 25 | DN | Без временных | Элемент управления режима NaN по умолчанию. |
| 24 | FZ | Неизменяемый | Управление с записью в нулевой режим. |
| 23—22 | RMode | Неизменяемый | Элемент управления режимом округления. |
| 15, 12-8 | IDE, ИКСЕ и т. д. | Без временных | Ловушка исключения Enable BITS всегда должна быть равна 0. |

## <a name="system-registers"></a>Системные регистры

Как и AArch32, спецификация AArch64 предоставляет три зарегистрированные системой регистры ИДЕНТИФИКАТОРов потоков:

| Регистровое | Роль |
| - | - |
| TPIDR_EL0 | Зарезервировано. |
| TPIDRRO_EL0 | Содержит номер ЦП для текущего процессора. |
| TPIDR_EL1 | Указывает на структуру КПКР для текущего процессора. |

## <a name="floating-point-exceptions"></a>Исключения с плавающей запятой

Поддержка исключений IEEE с плавающей запятой является необязательной в системах AArch64. Для вариантов процессоров с аппаратными исключениями с плавающей запятой ядро Windows автоматически перехватывает исключения и неявно отключает их в регистре ФПКР. Эта ловушка обеспечивает нормализованное поведение между вариантами процессора. В противном случае код, разработанный на платформе без поддержки исключений, может обнаружить непредвиденные исключения при работе на платформе с поддержкой.

## <a name="parameter-passing"></a>Передача параметров

Для функций, не являющихся Variadic, интерфейс ABI Windows соответствует правилам передачи параметров, заданным параметром ARM. Эти правила выводятся непосредственно из стандарта вызова процедуры для архитектуры AArch64:

### <a name="stage-a--initialization"></a>Этап A – инициализация

Этот этап выполняется только один раз перед началом обработки аргументов.

1. Следующий номер регистра общего назначения (НГРН) имеет нулевое значение.

1. Следующий номер регистра SIMD и с плавающей запятой (НСРН) имеет нулевое значение.

1. Следующий адрес аргумента с накоплением (адрес NSAA) устанавливается равным текущему значению указателя стека (SP).

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>Этап B — предварительное заполнение и расширение аргументов

Для каждого аргумента в списке применяется первое правило сопоставления из следующего списка. Если правило не соответствует, аргумент используется без изменений.

1. Если тип аргумента является составным типом, размер которого не может быть статически определен как вызывающим объектом, так и вызываемым, аргумент копируется в память, а аргумент заменяется указателем на копию. (В C/C++ нет таких типов, но они существуют на других языках или в расширениях языка).

1. Если аргумент имеет тип ХФА или Хва, то аргумент используется без изменений.

1. Если тип аргумента является составным типом, превышающим 16 байт, то аргумент копируется в память, выделенную вызывающим объектом, а аргумент заменяется указателем на копию.

1. Если тип аргумента является составным типом, то размер аргумента округляется до ближайшего числа, кратного 8 байтам.

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>Этап C — назначение аргументов регистрам и стеку

Для каждого аргумента в списке по очереди применяются следующие правила, пока аргумент не будет выделен. При назначении аргумента регистру все неиспользуемые биты в регистре имеют неопределенное значение. Если аргумент назначен слоту стека, то все неиспользуемые байты заполнения имеют неопределенное значение.

1. Если аргумент имеет тип с плавающей запятой половинной или двойной точности, а значение НСРН меньше 8, то аргумент выделяется для наименее значимых бит Register v\[НСРН]. НСРН увеличивается на единицу. Теперь аргумент был выделен.

1. Если аргумент является ХФА или Хва и имеется достаточно нераспределенных операций SIMD и регистров с плавающей запятой (НСРН + число членов ≤ 8), то аргумент выделяется с помощью SIMD и регистров с плавающей запятой, один регистр для каждого члена ХФА или Хва. НСРН увеличивается на количество используемых регистров. Теперь аргумент был выделен.

1. Если аргумент является ХФА или Хва, то НСРН имеет значение 8, а размер аргумента округляется до ближайшего числа, кратного 8 байтам.

1. Если аргумент представляет собой ХФА, Хва, тип с плавающей запятой или короткий вектор, то адрес NSAA округляется в большую сторону до 8 или естественного выравнивания типа аргумента.

1. Если аргумент имеет тип с плавающей запятой половины или одинарной точности, то размер аргумента устанавливается в 8 байт. Результат будет таким же, как если бы аргумент был скопирован в наименее значащие биты 64-разрядного регистра, а остальные биты заполняются неуказанными значениями.

1. Если аргумент является ХФА, Хва, половинным, одиночным, двойным или четырехъядерным вектором с плавающей запятой или типом Short, то аргумент копируется в память в настроенном адрес NSAA. Адрес NSAA увеличивается на размер аргумента. Теперь аргумент был выделен.

1. Если аргумент является целочисленным или имеет тип указателя, то размер аргумента меньше или равен 8 байтам, а НГРН меньше 8, аргумент копируется на наименее значимые биты в x\[НГРН]. НГРН увеличивается на единицу. Теперь аргумент был выделен.

1. Если аргумент имеет выравнивание 16, то НГРН округляется до следующего четного числа.

1. Если аргумент является целочисленным типом, то размер аргумента равен 16, а значение НГРН меньше 7, аргумент копируется в x\[НГРН] и x\[НГРН + 1]. x\[НГРН] должен содержать строчно-ориентированное двойное слово представления памяти аргумента. НГРН увеличивается на два. Теперь аргумент был выделен.

1. Если аргумент является составным типом, а размер в двойных словах аргумента не превышает 8 минус НГРН, то аргумент копируется в последовательные регистры общего назначения, начиная с x\[НГРН]. Аргумент передается так же, как если бы он был загружен в регистры из адреса в двойных кавычках, с соответствующей последовательностью инструкций LDR, которые загружают последовательные регистры из памяти. Содержимое всех неиспользуемых частей регистров не определяется этим стандартом. НГРН увеличивается на количество используемых регистров. Теперь аргумент был выделен.

1. НГРН имеет значение 8.

1. АДРЕС NSAA округляется до большего 8 или естественного выравнивания типа аргумента.

1. Если аргумент является составным типом, то аргумент копируется в память в настроенном адрес NSAA. Адрес NSAA увеличивается на размер аргумента. Теперь аргумент был выделен.

1. Если размер аргумента меньше 8 байт, то размер аргумента устанавливается в 8 байт. Результат будет таким же, как если бы аргумент был скопирован в наименее значащие биты 64-разрядного регистра, а остальные биты были заполнены неопределенными значениями.

1. Аргумент копируется в память в настроенном адрес NSAA. Адрес NSAA увеличивается на размер аргумента. Теперь аргумент был выделен.

### <a name="addendum-variadic-functions"></a>Дополнение: функции Variadic

Функции, принимающие переменное число аргументов, обрабатываются иначе, как показано ниже.

1. Все составные блоки обрабатываются одинаково; нет специальной обработки Хфас или Хвас.

1. SIMD и регистры с плавающей запятой не используются.

Фактически, это то же самое, что и правила C. 12 – C. 15, чтобы выделить аргументы для мнимого стека, где первые 64 байт стека загружаются в x0-120x7x1, а остальные аргументы стека помещаются в обычное расположение.

## <a name="return-values"></a>Возвращаемые значения

Целочисленные значения возвращаются в x0.

При необходимости значения с плавающей запятой возвращаются в S0, D0 или v0.

Значения ХФА и Хва возвращаются в S0-S3, D0-D3 или v0-v3 соответственно.

Типы, возвращаемые по значению, обрабатываются по-разному в зависимости от того, имеют ли они определенные свойства. Типы, имеющие все эти свойства;

- они являются *агрегатами* по стандартному определению c++ 14, то есть не имеют конструкторов, предоставленных пользователем, не имеют закрытых или защищенных нестатических элементов данных, не являются базовыми классами и не являются виртуальными функциями и
- они имеют тривиальный оператор присваивания копии и
- они имеют тривиальный деструктор,

Используйте следующий стиль возврата:

- Типы, размер которых меньше или равен 8 байтам, возвращаются в x0.
- Типы, которые меньше или равны 16 байтам, возвращаются в x0 и x1 с x0, содержащей нижний порядок 8 байт.
- Для типов, превышающих 16 байт, вызывающий объект резервирует блок памяти достаточного размера и выравнивание для хранения результата. Адрес блока памяти должен передаваться в качестве дополнительного аргумента функции в x8. Вызываемый объект может изменить блок памяти результата в любой точке во время выполнения подпрограммы. Вызываемый объект не обязан сохранять значение, хранящееся в x8.

Все остальные типы используют это соглашение:

- Вызывающий объект резервирует блок памяти достаточного размера и выравнивание для хранения результата. Адрес блока памяти должен передаваться в качестве дополнительного аргумента функции в x0 или x1, если $this передается в x0. Вызываемый объект может изменить блок памяти результата в любой точке во время выполнения подпрограммы. Вызываемый объект возвращает адрес блока памяти в x0.

## <a name="stack"></a>Стек

После вставки интерфейса ABI на ARM стек должен оставаться в 16-байтовом режиме. AArch64 содержит аппаратную функцию, которая создает ошибки выравнивания стека всякий раз, когда значение SP не превышает 16 байт и выполняется загрузка или хранение относительно пакета обновления. Windows работает с включенной функцией в любое время.

Функции, выделяющие 4 КБ или более, должны иметь в своем порядке все страницы, нашедшие до последней страницы. Это действие гарантирует, что код не сможет поворачивать страницы защиты, используемые Windows для расширения стека. Как правило, касание выполняется `__chkstk` вспомогательным модулем, который имеет настраиваемое соглашение о вызовах, которое передает общее выделение стека на 16 в X15.

## <a name="red-zone"></a>Красная зона

16-байтовая область под текущим указателем стека зарезервирована для использования в сценариях анализа и динамического исправления. Эта область позволяет вставлять аккуратно созданный код, который хранит два регистра в [SP, #-16] и временно использует их для произвольной цели. Ядро Windows гарантирует, что эти 16 байт не будут перезаписаны при возникновении исключения или прерывания в режиме пользователя и ядра.

## <a name="kernel-stack"></a>Стек ядра

Стек режима ядра по умолчанию в Windows состоит из шести страниц (24k). Обратите особое внимание на функции с большими буферами стека в режиме ядра. Некорректное прерывание может помешать с минимальным запасом и создать проверку ошибки тревоги стека.

## <a name="stack-walking"></a>Проход по стеку

Код в Windows компилируется с включенными указателями кадров ([/ой-](reference/oy-frame-pointer-omission.md)) для быстрого прохода стеков. Как правило, X29 (FP) указывает на следующую ссылку в цепочке, которая представляет собой пару из {FP, LR}, указывающую указатель на предыдущий кадр стека и обратный адрес. В коде стороннего разработчика рекомендуется включить указатели на фреймы, чтобы обеспечить улучшенное профилирование и трассировку.

## <a name="exception-unwinding"></a>Исключение при очистке

Очистка во время обработки исключений помогает использовать коды очистки. Коды очистки представляют собой последовательность байтов, хранящихся в разделе. XData исполняемого файла. Они описывают операции пролога и эпилога в абстрактном виде, поэтому эффект пролога функции может быть отменен при подготовке к резервному копированию в кадр стека вызывающего объекта. Дополнительные сведения о кодах очистки см. в разделе [обработка исключений ARM64](arm64-exception-handling.md).

EABI ARM также указывает модель очистки исключений, которая использует коды завершения. Однако приведенная спецификация недостаточна для очистки в Windows, которая должна работать в случаях, когда компьютер находится в середине функции пролога или эпилога.

Динамически создаваемый код должен быть описан с динамическими таблицами функций с помощью `RtlAddFunctionTable` и связанных функций, чтобы созданный код мог участвовать в обработке исключений.

## <a name="cycle-counter"></a>Счетчик циклов

Все ЦП ARMv8 должны поддерживать регистр счетчика цикла, 64-разрядный регистр, который Windows настраивает для чтения на любом уровне исключения, в том числе в пользовательском режиме. Доступ к нему можно получить через Специальный PMCCNTR_EL0 регистр, с помощью кода операции MSR в коде сборки или `_ReadStatusReg` встроенного кода C/C++ Code.

Счетчик цикла здесь является истинным счетчиком цикла, а не часами стены. Частота подсчета зависит от частоты процессора. Если вы хотите оценить частоту счетчика циклов, вы не должны использовать счетчик циклов. Вместо этого необходимо измерять время на стене, для которого следует использовать `QueryPerformanceCounter`.

## <a name="see-also"></a>См. также

[Общие вопросы использования Visual C++ ARM](common-visual-cpp-arm-migration-issues.md)<br/>
[Обработка исключений ARM64](arm64-exception-handling.md)
