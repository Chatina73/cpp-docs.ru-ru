---
title: Определение подходящего метода экспорта
ms.date: 11/04/2016
helpviewer_keywords:
- __declspec(dllexport) keyword [C++]
- exporting DLLs [C++], method comparison
- def files [C++], exporting from DLLs
- .def files [C++], exporting from DLLs
ms.assetid: 66d773ed-935c-45c2-ad03-1a060874b34d
ms.openlocfilehash: 75cd03e2ebb8dab4069024469b2b8b5c45665704
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50615141"
---
# <a name="determining-which-exporting-method-to-use"></a>Определение подходящего метода экспорта

Вы можете экспортировать функции одним из двух способов — DEF-файл или `__declspec(dllexport)` ключевое слово. Чтобы помочь вам решить, какой способ лучше подходит для библиотеки DLL, задайте себе следующие вопросы:

- Вы планируете экспортировать большее число функций позже?

- — Это библиотека DLL используется только для приложений, можно перестроить или он используется приложениями, которые невозможно перестроить — в частности, приложения, созданные сторонними разработчиками?

## <a name="pros-and-cons-of-using-def-files"></a>Преимущества и недостатки использования DEF-файлы

Экспорт функций в DEF-файл позволяет управлять порядковые номера экспорта. При добавлении экспортированную функцию с библиотекой DLL, его можно назначить более высокое значение порядкового номера, чем экспортированную функцию. При этом приложения, использующие неявное связывание нет необходимости выполнить повторную компоновку с библиотекой импорта, который содержит новую функцию. Это очень удобно в том случае, если вы разрабатываете библиотеку DLL для использования несколькими приложениями так, как можно расширить функциональные возможности и также обеспечить их правильной работы с приложениями, которые уже зависящие от него. Например библиотеки DLL MFC, построенных с помощью DEF-файлы.

Является еще одним преимуществом использования DEF-файла, которые можно использовать `NONAME` атрибут экспортировать функцию. Таким образом, только порядковый номер в таблице экспорта библиотеки DLL. Для библиотек DLL, содержащих большое количество функций, с помощью `NONAME` атрибута можно уменьшить размер DLL-файла. Сведения о том, как написать инструкцию определение модуля, см. в разделе [правила для операторов определения модуля](../build/reference/rules-for-module-definition-statements.md). Сведения о порядковый номер экспорта, см. в разделе [Экспорт функций из библиотеки DLL по порядковому номеру, а не по имени](../build/exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md).

Использование DEF-файла — что при экспорте функции в файле C++, необходимо либо поместить декорированные имена в DEF-файл или определить экспортируемые функции с помощью extern «C», чтобы избежать Декорирование имен, это делается с помощью компилятора Visual C++.

Если поместить декорированные имена в DEF-файле, их можно получить с помощью [DUMPBIN](../build/reference/dumpbin-reference.md) средство или с помощью компоновщика [/MAP](../build/reference/map-generate-mapfile.md) параметр. Декорированные имена, созданные компилятором зависят от компилятора; Таким образом, если поместить декорированные имена, созданные компилятором в DEF-файл, приложений, связанных с библиотекой DLL должны также быть построены с помощью той же версии компилятора, чтобы декорированные имена в вызывающем приложении соответствовали экспортируемые имена i n DEF-файле библиотеки DLL.

## <a name="pros-and-cons-of-using-declspecdllexport"></a>Преимущества и недостатки с использованием __declspec(dllexport)

С помощью `__declspec(dllexport)` удобно, так как вам не нужно беспокоиться о поддержке DEF-файла и получение декорированные имена экспортированных функций. Тем не менее полезность таким образом, экспорт, ограничивается число связанных приложений, которые требуется перестроить. При повторном построении библиотеки DLL с новый экспорт, также необходимо перестроить приложения декорированные имена для экспортируемых функций C++ может измениться при использовании другой версии компилятора для перестроения.

### <a name="what-do-you-want-to-do"></a>Выберите действие

- [Экспорт из библиотеки DLL с помощью. DEF-файлы](../build/exporting-from-a-dll-using-def-files.md)

- [Экспорт из библиотеки DLL с использованием __declspec(dllexport)](../build/exporting-from-a-dll-using-declspec-dllexport.md)

- [Экспорт и импорт с использованием AFX_EXT_CLASS](../build/exporting-and-importing-using-afx-ext-class.md)

- [Экспорт функций C++ для использования в исполняемых файлах языка C](../build/exporting-cpp-functions-for-use-in-c-language-executables.md)

- [Экспорт функций на языке C для использования в исполняемых файлах C или C++-язык](../build/exporting-c-functions-for-use-in-c-or-cpp-language-executables.md)

- [Импорт в приложение с помощью объявления __declspec(dllimport)](../build/importing-into-an-application-using-declspec-dllimport.md)

- [Инициализация библиотеки DLL](../build/run-time-library-behavior.md#initializing-a-dll)

### <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Импорт и экспорт встраиваемых функций](../build/importing-and-exporting-inline-functions.md)

- [Взаимный импорт](../build/mutual-imports.md)

- [Декорированные имена](../build/reference/decorated-names.md)

## <a name="see-also"></a>См. также

[Экспорт из библиотеки DLL](../build/exporting-from-a-dll.md)