---
title: Определение подходящего способа экспорта
ms.date: 11/04/2016
helpviewer_keywords:
- __declspec(dllexport) keyword [C++]
- exporting DLLs [C++], method comparison
- def files [C++], exporting from DLLs
- .def files [C++], exporting from DLLs
ms.assetid: 66d773ed-935c-45c2-ad03-1a060874b34d
ms.openlocfilehash: 974c32cef87801599ba0d14fd146e84ad874467f
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62273741"
---
# <a name="determine-which-exporting-method-to-use"></a>Определение подходящего способа экспорта

Функции можно экспортировать одним из двух способов: с помощью файла DEF или ключевого слова `__declspec(dllexport)`. Чтобы решить, какой способ лучше подходит для библиотеки DLL, учитывайте следующие моменты.

- Вы планируете экспортировать больше функций в дальнейшем?

- Библиотека DLL используется только приложениями, которые можно перестроить или использовать в приложениях, которые нельзя перестроить (например, приложения, созданные сторонними производителями)?

## <a name="pros-and-cons-of-using-def-files"></a>Преимущества и недостатки использования файлов DEF

Экспорт функций в файл DEF позволяет контролировать порядковый номер экспорта. При добавлении экспортированной функции в библиотеку DLL можно назначить ей больший порядковый номер по сравнению с любой другой экспортированной функцией. При этом приложения, использующие неявное связывание, не должны повторно связываться с библиотекой импорта, содержащей новую функцию. Это очень удобно, если вы разрабатываете библиотеку DLL для использования сразу несколькими приложениями, поскольку вы можете добавить новые функции, а также убедиться, что она будет работать правильно с приложениями, которые уже используют ее. Например, библиотеки DLL MFC создаются с помощью файлов DEF.

Еще одним преимуществом использования файла DEF является то, что для экспорта функции можно использовать атрибут `NONAME`. После этого в таблицу EXPORTS библиотеки DLL помещается только порядковый номер. Для библиотек DLL с большим количеством экспортированных функций использование атрибута `NONAME` может уменьшить размер файла DLL. Сведения о том, как написать инструкцию определения модуля, см. в разделе [Правила для операторов определения модуля](reference/rules-for-module-definition-statements.md). Сведения об экспорте по порядковому номеру см. в разделе [Экспорт функций из библиотеки DLL по порядковому номеру, а не по имени](exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md).

Недостаток файла DEF заключается в том, что при экспорте функций в файл C++ необходимо либо поместить в файл DEF внутренние имена, либо определить экспортированные функции с помощью ключевого слова "C", чтобы избежать декорирования имен, выполненных компилятором MSVC.

Если добавить внутренние имена в файл DEF, их можно получить с помощью средства [DUMPBIN](reference/dumpbin-reference.md) или с помощью параметра [/MAP](reference/map-generate-mapfile.md) компоновщика. Внутренние имена, создаваемые компилятором, зависят от компилятора; поэтому при помещении внутренних имен, созданных компилятором, в файл DEF приложения, которые связываются с библиотекой DLL, также должны быть построены с помощью той же версии компилятора, чтобы внутренние имена в вызывающем приложении соответствовали экспортированным именам в файле DEF библиотеки DLL.

## <a name="pros-and-cons-of-using-__declspecdllexport"></a>Преимущества и недостатки использования __declspec(dllexport)

Использование `__declspec(dllexport)` является удобным, поскольку не нужно беспокоиться о поддержке файла DEF и получении внутренних имен экспортируемых функций. Однако полезность такого способа экспорта ограничена числом связанных приложений, которые нужно перестроить. При перестроении библиотеки DLL с новыми данными экспорта необходимо также перестроить приложения, поскольку внутренние имена для C++ экспортированных функций могут измениться, если для их перестроения используется другая версия компилятора.

### <a name="what-do-you-want-to-do"></a>Выберите действие

- [Экспорт из библиотеки DLL с использованием DEF-файлов](exporting-from-a-dll-using-def-files.md)

- [Экспорт из библиотеки DLL с использованием __declspec(dllexport)](exporting-from-a-dll-using-declspec-dllexport.md)

- [Экспорт и импорт с использованием AFX_EXT_CLASS](exporting-and-importing-using-afx-ext-class.md)

- [Экспорт функций на языке C++ для использования в исполняемых модулях, исходный код которых написан на языке C](exporting-cpp-functions-for-use-in-c-language-executables.md)

- [Экспорт функций на языке C для использования в исполняемых файлах, исходный код которых написан на языке C или C++](exporting-c-functions-for-use-in-c-or-cpp-language-executables.md)

- [Импорт в приложение с помощью __declspec(dllimport)](importing-into-an-application-using-declspec-dllimport.md)

- [Инициализация библиотеки DLL](run-time-library-behavior.md#initializing-a-dll)

### <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Импорт и экспорт встраиваемых функций](importing-and-exporting-inline-functions.md)

- [Взаимный импорт](mutual-imports.md)

- [Внутренние имена](reference/decorated-names.md)

## <a name="see-also"></a>См. также

[Экспорт из библиотеки DLL](exporting-from-a-dll.md)
