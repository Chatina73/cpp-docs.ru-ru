---
title: Экспорт из библиотеки DLL с использованием DEF-файлов
ms.date: 05/06/2019
helpviewer_keywords:
- def files [C++], exporting from DLLs
- .def files [C++], exporting from DLLs
- exporting DLLs [C++], DEF files
ms.assetid: 9d31eda2-184e-47de-a2ee-a93ebd603f8e
ms.openlocfilehash: 6f7d58bcb42edd89527fff41b08a15321722a6cf
ms.sourcegitcommit: 8e285a766523e653aeeb34d412dc6f615ef7b17b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2020
ms.locfileid: "80078526"
---
# <a name="exporting-from-a-dll-using-def-files"></a>Экспорт из библиотеки DLL с использованием DEF-файлов

DEF-файл определения модуля (*. DEF) — это текстовый файл, содержащий один или несколько операторов модуля, описывающих различные атрибуты библиотеки DLL. Если вы не используете ключевое слово **__declspec (dllexport)** для экспорта функций библиотеки DLL, для библиотеки DLL требуется DEF-файл.

Минимальный DEF-файл должен содержать следующие операторы определения модуля:

- Первым оператором в файле должна быть инструкция LIBRARY. Эта инструкция определяет DEF-файл как принадлежащий библиотеке DLL. За оператором библиотеки следует имя библиотеки DLL. Компоновщик помещает это имя в библиотеку импорта библиотеки DLL.

- Инструкция EXPORTs перечисляет имена и, при необходимости, порядковые значения функций, экспортируемых библиотекой DLL. Вы назначаете функцию с порядковым номером, следуя имени функции, используя знак @ и число. При указании порядковых значений они должны находиться в диапазоне от 1 до N, где N — число функций, экспортируемых библиотекой DLL. Если требуется экспортировать функции по порядковому номеру, см. раздел [Экспорт функций из библиотеки DLL по порядковому номеру, а не по имени,](exporting-functions-from-a-dll-by-ordinal-rather-than-by-name.md) а также к этой теме.

Например, Библиотека DLL, содержащая код для реализации двоичного дерева поиска, может выглядеть следующим образом:

```
LIBRARY   BTREE
EXPORTS
   Insert   @1
   Delete   @2
   Member   @3
   Min   @4
```

Если для создания библиотеки DLL MFC используется [Мастер библиотек DLL MFC](../mfc/reference/mfc-dll-wizard.md) , мастер создает скелет файла DEF и автоматически добавляет его в проект. Добавьте имена функций для экспорта в этот файл. Для библиотек DLL, отличных от MFC, создайте файл DEF и добавьте его в проект. Затем перейдите в **проект** > **свойства** > **Компоновщик** > **входной** > **файл определения модуля** и введите имя DEF файла. Повторите этот шаг для каждой конфигурации и платформы или сделайте это одновременно, выбрав **Конфигурация = все конфигурации**, а **Platform — все платформы**.

При экспорте функций в C++ файл необходимо либо поместить декорированные имена в DEF-файл, либо определить экспортированные функции с помощью стандартной компоновки c, используя extern "C". Если необходимо поместить декорированные имена в DEF, их можно получить с помощью средства [dumpbin](../build/reference/dumpbin-reference.md) или с помощью параметра компоновщика [/Map](../build/reference/map-generate-mapfile.md) . Обратите внимание, что декорированные имена, создаваемые компилятором, зависят от компилятора. Если в DEF-файл помещаются внутренние имена, C++ созданные компилятором Microsoft (компилятором MSVC), то приложения, которые связываются с библиотекой DLL, также должны быть построены с использованием той же версии компилятором MSVC, чтобы декорированные имена в вызывающем приложении совпадали с экспортированными именами в DEF-файле библиотеки DLL.

> [!NOTE]
> Библиотека DLL, созданная с помощью Visual Studio 2015, может быть использована приложениями, созданными с помощью Visual Studio 2017 или Visual Studio 2019.

Если вы создаете [библиотеку DLL расширения](../build/extension-dlls-overview.md)и экспортируете с помощью DEF-файла, поместите следующий код в начало и в конец файлов заголовков, содержащих экспортированные классы:

```
#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA
// <body of your header file>
#undef AFX_DATA
#define AFX_DATA
```

Эти строки гарантируют, что переменные MFC, которые используются внутри классов или добавляются в классы, экспортируются (или импортируются) из библиотеки DLL расширения MFC. Например, при создании производного класса с помощью `DECLARE_DYNAMIC`макрос расширяется, добавляя в класс `CRuntimeClass` переменную-член. Выход из этих четырех строк может привести к тому, что библиотека DLL компилируется или неправильно связывается или вызывает ошибку, когда клиентское приложение связывается с библиотекой DLL.

При сборке библиотеки DLL компоновщик использует DEF-файл для создания файла экспорта (exp) и файла библиотеки импорта (lib). Затем компоновщик использует файл экспорта для создания DLL-файла. Исполняемые файлы, которые неявно связываются со ссылкой на библиотеку DLL в библиотеке импорта при их построении.

Обратите внимание, что MFC использует DEF-файлы для экспорта функций и классов из MFCx0. dll.

## <a name="what-do-you-want-to-do"></a>Что необходимо сделать?

- [Экспорт из библиотеки DLL с помощью __declspec (dllexport)](exporting-from-a-dll-using-declspec-dllexport.md)

- [Экспорт и импорт с помощью AFX_EXT_CLASS](exporting-and-importing-using-afx-ext-class.md)

- [Экспорт C++ функций для использования в исполняемых файлах языка C](exporting-cpp-functions-for-use-in-c-language-executables.md)

- [Экспорт функций C для использования в исполняемых C++файлах c или языка](exporting-c-functions-for-use-in-c-or-cpp-language-executables.md)

- [Определение используемого метода экспорта](determining-which-exporting-method-to-use.md)

- [Импорт в приложение с помощью __declspec(dllimport)](importing-into-an-application-using-declspec-dllimport.md)

- [Инициализация библиотеки DLL](run-time-library-behavior.md#initializing-a-dll)

## <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [DEF, файлы](reference/module-definition-dot-def-files.md)

- [Правила для операторов определения модуля](reference/rules-for-module-definition-statements.md)

- [Декорированные имена](reference/decorated-names.md)

- [Импорт и экспорт встраиваемых функций](importing-and-exporting-inline-functions.md)

- [Взаимный импорт](mutual-imports.md)

## <a name="see-also"></a>См. также:

[Экспорт из библиотеки DLL](exporting-from-a-dll.md)
