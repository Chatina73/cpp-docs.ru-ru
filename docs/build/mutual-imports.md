---
title: Взаимный импорт
ms.date: 11/04/2016
helpviewer_keywords:
- mutual DLL imports [C++]
- AFX_DATA
- importing DLLs [C++], mutual imports
- mutually importing executable files [C++]
- AFX_EXT_CLASS macro
- circular imports
- _AFXEXT preprocessor symbol
- DLLs [C++], importing
- executable files [C++], importing
- extension DLLs [C++], mutual imports
- exporting DLLs [C++], mutual imports
ms.assetid: 2cc29537-92ee-4d92-af39-8b8b3afd808f
ms.openlocfilehash: c2d34c54491bb4b85311be3ba1ebdaed87437246
ms.sourcegitcommit: bff17488ac5538b8eaac57156a4d6f06b37d6b7f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/05/2019
ms.locfileid: "57420691"
---
# <a name="mutual-imports"></a>Взаимный импорт

Импорт или экспорт другой исполняемый файл представляет затруднения при взаимной (или циклические) импорты. Например две библиотеки DLL импортировать символы друг от друга, аналогичную взаимно рекурсивные функции.

Проблема с взаимное импортирование исполняемых файлов (обычно DLL) в том, что не могут создаваться без построения другой. Каждый процесс построения требует в качестве входных данных, созданных процесс построения библиотеки импорта.

Решением является использование программы LIB с параметром/DEF, который создает библиотеку импорта без построения исполняемого файла. Эта служебная программа, позволяет создавать все библиотеки импорта, вам требуется, независимо от того, сколько библиотек DLL связанных или насколько сложны, зависимости.

— Общее решение для разрешения взаимного импорта:

1. В свою очередь занять каждой библиотеки DLL. (Любом порядке целесообразен, несмотря на то, что некоторые заказы более оптимальны.) Если все необходимые библиотеки импорта существуют и являются текущими, ссылка для сборки исполняемого файла (DLL) для выполнения. Этот сценарий создает библиотеку импорта. В противном случае запустите программу LIB для создания библиотеки импорта.

   Запуск программы LIB с параметром/DEF создает дополнительный файл. Расширение EXP. . EXP-файл должен использоваться позже для сборки исполняемого файла.

1. После использования LINK или LIB для построения всех создаваемых библиотек импорта, вернитесь и запустите программу LINK для построения всех исполняемых файлов, которые не были созданы на предыдущем шаге. Обратите внимание на то, что соответствующий файл .exp должно быть указано в строке ссылки.

   Если вы возникала при выполнении программы LIB ранее для создания библиотеки импорта для DLL1, LIB бы получен файл DLL1.exp также. При построении DLL1.dlll, необходимо использовать DLL1.exp качестве входных данных для ссылки.

Ниже показано решение для двух взаимного импорта библиотек DLL, DLL1 и DLL2. Шаг 1 — это выполнить LIB, с набором параметров/DEF, на DLL1. Шаг 1 создает DLL1.lib библиотеки импорта и DLL1.exp. На шаге 2 библиотека импорта используется для построения DLL2, который в свою очередь создает библиотеку импорта для DLL2 символов. Шаг 3 построение DLL1 с помощью DLL1.exp и DLL2.lib в качестве входных данных. Обратите внимание на то, что файл EXP для DLL2 не является необходимым, поскольку LIB не используется для построения библиотеки импорта DLL2.

![Компоновка двух библиотек DLL с помощью взаимного импорта](../build/media/vc37yj1.gif "компоновка двух библиотек DLL с помощью взаимного импорта")<br/>
Компоновка двух библиотек DLL с взаимный импорт

## <a name="limitations-of-afxext"></a>Ограничения _AFXEXT

Можно использовать `_AFXEXT` символ препроцессора для библиотек, если у вас нет многочисленные расширения MFC библиотеки DLL расширения MFC. Если у вас есть расширение MFC DLL, вызывающие или являются производными от классов в свои собственные расширения MFC библиотеки DLL, которые являются производными от классов MFC, необходимо использовать собственный символ препроцессора во избежание неоднозначности.

Проблема в том, что в Win32, необходимо явно объявить все данные в виде **__declspec(dllexport)** Если требуется экспортировать из библиотеки DLL, и **__declspec(dllimport)** Если требуется импортировать из библиотеки DLL. При определении `_AFXEXT`, заголовки MFC убедитесь, что **AFX_EXT_CLASS** определен правильно.

При наличии нескольких уровней, один символ например **AFX_EXT_CLASS** недостаточно, так как библиотеки DLL расширения MFC может экспортировать новые классы, а также импортировать другие классы из другой библиотеки DLL расширения MFC. Чтобы решить эту проблему, используйте специальный символ препроцессора, указывающее, что вы создаете непосредственно в Библиотеки и библиотеки DLL. Например представьте себе две библиотеки DLL расширения MFC, A.dll и B.dll. Каждый из них экспортирует некоторые классы, в файлах A.h и B.h соответственно. B.dll использует классы из A.dll. Файлы заголовков будет выглядеть следующим образом:

```
/* A.H */
#ifdef A_IMPL
   #define CLASS_DECL_A   __declspec(dllexport)
#else
   #define CLASS_DECL_A   __declspec(dllimport)
#endif

class CLASS_DECL_A CExampleA : public CObject
{ ... class definition ... };

// B.H
#ifdef B_IMPL
   #define CLASS_DECL_B   __declspec(dllexport)
#else
   #define CLASS_DECL_B   __declspec(dllimport)
#endif

class CLASS_DECL_B CExampleB : public CExampleA
{ ... class definition ... };
...
```

При построении A.dll, построены с `/D A_IMPL` и при построении B.dll, построены с `/D B_IMPL`. С помощью отдельных символов для каждой библиотеки DLL, `CExampleB` экспортируется и `CExampleA` импортируется при построении B.dll. `CExampleA` экспортируется при построении A.dll и импортируется при использовании B.dll (или другим клиентом).

Не удается выполнить этот тип архитектуры при использовании встроенной **AFX_EXT_CLASS** и `_AFXEXT` символы препроцессора. Способ, описанный выше решает эту проблему в способом, отличным от используется классами MFC при создании его активных технологий, базы данных и библиотек DLL расширения MFC сети.

## <a name="not-exporting-the-entire-class"></a>Экспортирует весь класс

При не экспортируется весь класс, необходимо убедиться, что элементы необходимые данные, созданные макросы MFC экспортируются правильно. Это можно сделать путем переопределения `AFX_DATA` макрос определенного класса. Это должен сделать любое время, не экспортируется весь класс.

Пример:

```
/* A.H */
#ifdef A_IMPL
   #define CLASS_DECL_A  _declspec(dllexport)
#else
   #define CLASS_DECL_A  _declspec(dllimport)
#endif

#undef  AFX_DATA
#define AFX_DATA CLASS_DECL_A

class CExampleA : public CObject
{
   DECLARE_DYNAMIC()
   CLASS_DECL_A int SomeFunction();
   //... class definition ...
};

#undef AFX_DATA
#define AFX_DATA
```

### <a name="what-do-you-want-to-do"></a>Выберите действие

- [Экспорт из библиотеки DLL](../build/exporting-from-a-dll.md)

- [Экспорт из библиотеки DLL с помощью. DEF-файлы](../build/exporting-from-a-dll-using-def-files.md)

- [Экспорт из библиотеки DLL с использованием __declspec(dllexport)](../build/exporting-from-a-dll-using-declspec-dllexport.md)

- [Экспорт и импорт с использованием AFX_EXT_CLASS](../build/exporting-and-importing-using-afx-ext-class.md)

- [Экспорт функций C++ для использования в исполняемых файлах языка C](../build/exporting-cpp-functions-for-use-in-c-language-executables.md)

- [Определение подходящего метода экспорта для использования](../build/determining-which-exporting-method-to-use.md)

- [Импорт в приложение с помощью объявления __declspec(dllimport)](../build/importing-into-an-application-using-declspec-dllimport.md)

### <a name="what-do-you-want-to-know-more-about"></a>Дополнительные сведения

- [Программы LIB и параметр/DEF](../build/reference/lib-reference.md)

## <a name="see-also"></a>См. также

[Импортирование и экспортирование](../build/importing-and-exporting.md)
