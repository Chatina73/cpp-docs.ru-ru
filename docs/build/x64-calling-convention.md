---
title: Соглашение о вызовах для 64-разрядных систем
description: Сведения о вызовах по умолчанию x64 ABI.
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: 2cad00ac7f2cb5fe086fa262a0f512330997391f
ms.sourcegitcommit: 0e3da5cea44437c132b5c2ea522bd229ea000a10
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/12/2019
ms.locfileid: "67861163"
---
# <a name="x64-calling-convention"></a>Соглашение о вызовах для 64-разрядных систем

В этом разделе описаны стандартные процессы и соглашений, используемых в одну функцию (вызывающая сторона) для выполнения вызовов в другую функцию (вызываемый объект) x64 кода.

## <a name="calling-convention-defaults"></a>Значения по умолчанию соглашение о вызове

По умолчанию x64 используемых четырех register fast-соглашения о вызовах с двоичным интерфейсом приложений (ABI). Пространство выделяется в стеке вызовов в качестве теневого хранилища для вызывающих объектов для сохранения этих регистров. Есть точное однозначное соответствие между аргументы для вызова функции и регистров, используемых для этих аргументов. Любой аргумент, который не умещается в 8 байт, или не 1, 2, 4 или 8 байт должны передаваться по ссылке. Один аргумент никогда не распределены по нескольким регистрам. X87 зарегистрировать стека не используется и может использоваться вызываемым объектом, но должен быть временным в вызовах функций. Число с плавающей запятой, все операции выполняются с помощью 16 регистров XMM. Целочисленные аргументы передаются в регистры RCX, RDX, R8 и R9. Число с плавающей запятой, что аргументы передаются в XMM0L, XMM1L, XMM2L и XMM3L. 16-байтовый аргументы передаются по ссылке. Передача параметров описан подробно [передача параметров](#parameter-passing). Регистры RAX, R10, R11, XMM4 и XMM5 считаются временными. Все остальные регистры являются долговременного. Использование регистров описан подробно [зарегистрировать использование](../build/x64-software-conventions.md#register-usage) и ["Вызывающий/вызываемый" сохранен регистрирует](#callercallee-saved-registers).

Для функций с прототипом все аргументы преобразуются в типы ожидаемый вызываемой перед передачей. Вызывающий объект отвечает за выделение пространства для параметров в вызываемый объект и всегда должен выделить достаточно места для хранения четырех параметров, даже если вызываемый объект не принимает такое количество параметров. Это соглашение упрощает поддержку функций языка C без прототипа и функции C/C++ с переменным количеством аргументов. Для функций с переменным количеством аргументов или без прототипа, любое число с плавающей запятой значения должны дублироваться в соответствующем регистре общего назначения. Любые параметры, за первые четыре должны храниться в стеке после тени хранения до вызова метода. Сведения о функции с переменным количеством аргументов можно найти в [Varargs](#varargs). Сведения о функции без прототипа подробно описана в [функции без прототипа](#unprototyped-functions).

## <a name="alignment"></a>Выравнивание

Большинство структур выровнены естественным выравниванием. Главными исключениями являются указатель стека и `malloc` или `alloca` памяти, что выравниваются по 16 байт для сохранения производительности. Выравнивание свыше 16 байт, которые должны выполняться вручную, но поскольку 16 байт общее выравнивание размера для операций XMM, это значение должно работать для большей части кода. Дополнительные сведения о структуре и выравнивании см. в разделе [типы и хранилище](../build/x64-software-conventions.md#types-and-storage). Сведения о стеке, см. в разделе [x64 стека использования](../build/stack-usage.md).

## <a name="unwindability"></a>Способность очищаться

Конечный это функции, которые не изменяются любые неизменяемые регистры. Функция неконечных может измениться долговременного RSP, например, путем вызова функции или выделения дополнительных стекового пространства для локальных переменных. Чтобы восстановить неизменяемые регистры, когда исключение обрабатывается, неконечных функции должно быть помечено атрибутом статических данных, описывающий, каким образом выполнять функции в строке произвольные команды. Эти данные хранятся в виде *pdata*, или данные процедуры, которые в свою очередь ссылается на *xdata*, обработки данных исключения. Xdata со сведениями, очистки и может указывать на дополнительные pdata или функцию-обработчик. Прологи и эпилоги становятся сильно ограничено, так что они могут быть правильно описаны в xdata. Указатель стека должен быть выровнен по 16 байт в любой области кода, который не является частью эпилога или пролога, за исключением в конечным функциям. Конечным функциям можно развернута просто имитируя возврата, pdata и xdata не являются обязательными. Дополнительные сведения о структуре функция Прологи и эпилоги, см. в разделе [x64 пролога и эпилога](../build/prolog-and-epilog.md). Дополнительные сведения об обработке исключений и обработки исключений и очистке pdata и xdata см. в разделе [x64 обработки исключений](../build/exception-handling-x64.md).

## <a name="parameter-passing"></a>Передача параметров

Первые четыре целочисленных аргументов передаются в регистрах. Целочисленные значения передаются в порядке слева направо в RCX, RDX, R8 и R9, соответственно. Аргументы пяти и более высоким передаются в стеке. Все аргументы имеют — по правому краю в регистрах, чтобы вызываемый объект может игнорировать старшие разряды регистра и входить только часть необходимых регистр.

Все аргументы с плавающей запятой и двойной точности в первые четыре параметра передаются в XMM0 - XMM3, в зависимости от положения. Целочисленные регистры RCX, RDX, R8 и R9, который обычно используется для этих позиций учитываются, за исключением случая аргументы varargs. Дополнительные сведения см. в разделе [Varargs](#varargs). Аналогичным образом XMM0 - XMM3 регистров учитываются при соответствующего аргумента является типом целое число или указатель.

[__m128](../cpp/m128.md) типы, массивы и строки никогда не передаются с непосредственным значением. Вместо этого передается указатель на память, выделенную вызывающим объектом. Структуры и объединения размер 8, 16, 32 или 64 бита и типы __m64 передаются как будто они являются целыми числами такого же размера. Структуры или объединения других размеров, передаются как указатель на память, выделенную вызывающим объектом. Для этих агрегатных типов, переданного как указатель включая \__m128, временной памяти, выделенный вызывающим объектом должен быть 16-байтовым.

Встроенные функции, которые не выделить пространство стека и не вызывают другие функции, иногда используют другие переменные регистры для передачи дополнительных аргументов в регистры. Эта оптимизация стало возможным благодаря тесная связь между компилятором и реализацией встроенной функции.

Вызываемый объект отвечает за формирование дампа параметров регистра в теневое пространство при необходимости.

В следующей таблице перечислены передачу параметров:

|Тип параметра|Передача|
|--------------------|----------------|
|С плавающей запятой|Первые четыре параметра — от XMM0 к XMM3. Остальные передаются в стек.|
|Целое число|Первые четыре параметра - RCX, RDX, R8, R9. Остальные передаются в стек.|
|Статистические функции (8, 16, 32 или 64-разрядный) и __m64|Первые четыре параметра - RCX, RDX, R8, R9. Остальные передаются в стек.|
|Статистические выражения (другое)|Указатель. Первые четыре параметра, передаются как указатели в RCX, RDX, R8 и R9|
|__m128|Указатель. Первые четыре параметра, передаются как указатели в RCX, RDX, R8 и R9|

### <a name="example-of-argument-passing-1---all-integers"></a>Пример передачи аргумента 1 — все целые числа

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>Пример передачи аргумента 2 - все значения с плавающей запятой

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>Пример передачи аргумента 3 - смешанной целые числа и числа с плавающей запятой

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--m64-m128-and-aggregates"></a>Пример передачи аргумента 4 — __m64, \__m128 и статистические функции

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>Функции с переменным количеством аргументов (Varargs)

Если параметры передаются через varargs (например, кнопку с многоточием аргументов), затем обычного регистра параметр передачи соглашение применяется, включая вытеснение пятого и последующие аргументы в стек. Отвечает за вызываемого объекта дамп аргументов, которые получают свой адрес. Для значений с плавающей запятой только как в целочисленном регистре, так и в регистре с плавающей запятой должно содержать значение, в случае, если вызываемый объект ожидает значение в целочисленные регистры.

## <a name="unprototyped-functions"></a>Функции без прототипа

Для функции без прототипа вызывающий объект передает целочисленные значения как целые числа и значения с плавающей запятой двойной точности. Для значений с плавающей запятой только как в целочисленном регистре, так и в регистре с плавающей запятой содержат значение с плавающей запятой, в случае, если вызываемый объект ожидает значение в целочисленные регистры.

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>Возвращаемые значения

Скалярное возвращаемое значение, которое может интегрироваться в 64 разряда возвращается посредством RAX; Сюда входят типы __m64. Нескалярные типы, включая типы с плавающей точкой, тип Double и векторные типы, такие как [__m128](../cpp/m128.md), [__m128i](../cpp/m128i.md), [__m128d](../cpp/m128d.md) , возвращаются в XMM0. Состояние неиспользуемых битов в возвращаемом значении в RAX или XMM0 не определяется.

Определенные пользователем типы можно вернуть из глобальных функций и статических функций-членов по значению. Для возврата определяемого пользователем типа по значению в RAX, он должен иметь длину 1, 2, 4, 8, 16, 32 или 64 бита. Также должно иметь нет определенного пользователем конструктора, деструктора или оператор присваивания копии; Нет закрытых или защищенных нестатических данных-членов; нет нестатических данных-членов ссылочного типа; отсутствие базовых классов; без виртуальных функций; и без данных-членов, которые также не соответствуют этим требованиям. (Фактически это — определение типа C ++ 03 POD. Поскольку определение изменилось в стандарте C ++ 11, мы не рекомендуем использовать `std::is_pod` для этого теста.) В противном случае вызывающий объект берет на себя ответственность за выделение памяти и передачу указателя для возвращаемого значения в качестве первого аргумента. Последующие аргументы затем перемещаются на один аргумент вправо. Тот же указатель должен быть возвращен вызываемой стороной в RAX.

В приведенных ниже примерах показан способ передачи параметров и возвращаемых значений для функций с указанными объявлениями.

### <a name="example-of-return-value-1---64-bit-result"></a>Пример возвращаемого значения 1 - 64-разрядного результата

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>Пример возвращаемого значения 2 — 128-разрядного результата

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>Пример возвращаемого значения 3 — результат пользовательского типа по указатель

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>Пример возвращаемого значения 4 — результат пользовательского типа по значению

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>"Вызывающий/вызываемый" Сохраняемые регистры

Регистры RAX, RCX, RDX, R8, R9, R10, R11, XMM0 – 5 и верхней части YMM0-15 и ZMM0-15, считаются временными и необходимо учитывать уничтожаются при вызове функции (если в противном случае безопасность проверяемыми в процессе анализа, такие как оптимизация всей программы). На AVX512VL нестабильны ZMM YMM и регистров XMM регистры 16-31.

Регистры RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15 и XMM6 15 считаются энергонезависимой и необходимо сохранить и восстановить с помощью функции, использует их.

## <a name="function-pointers"></a>Указатели функций
 
Указатели функций являются просто указатели на метку соответствующей функции. Не предусмотрены содержание требований для указателей на функции.

## <a name="floating-point-support-for-older-code"></a>Поддержка плавающей запятой для устаревшего кода

MMX и регистры с плавающей запятой стека (MM0-MM7/ST0-ST7) сохраняются на протяжении переключений контекста. Отсутствует явное соглашение о вызовах для этих регистров. Запрещено использование этих регистров в коде режима ядра.

## <a name="fpcsr"></a>FpCsr

Состояние регистра также включает в себя x87 контрольного слова FPU. Соглашение о вызове определяет этот регистр должен быть неизменным.

Выполнение программы x87 присваиваемого регистру контрольного слова FPU следующие стандартные значения в начале:

| Зарегистрировать\[bits] | Параметр |
|-|-|
| FPCSR\[0:6] | Исключение маскирует все 1 (маскируются все исключения) |
| FPCSR\[7] | Зарезервированные — 0 |
| FPCSR\[8:9] | Управление точностью - 10B (двойная точность) |
| FPCSR\[10:11] | Управление округления — 0 (с округлением к ближайшему) |
| FPCSR\[12] | Управление бесконечностью - 0 (не используется) |

Вызываемый объект, который изменяет любое из полей в FPCSR необходимо восстановить их, прежде чем возвращать его вызывающему. Более того вызывающий объект, который был изменен любой из этих полей, должен восстановить их стандартные значения перед вызовом вызываемым объектом, если только соглашением вызываемый требует измененные значения.

Существует два исключения из правил о неизменяемости управляющих флагов.

1. В функциях, где документированных заданная функция предназначена для изменения защищенных FpCsr флаги.

1. При его правильности неплохие результаты что нарушения этих правил в программе, которая ведет себя так же, как программы, где эти правила не нарушены, например, посредством анализа всей программы.

## <a name="mxcsr"></a>Регистр MxCsr

Состояние регистра включает MxCsr. Соглашение о вызове разделяет регистр volatile фрагмент и защищенную. Изменяемая часть состоит из шести состояний флаги, то в регистре MXCSR\[0:5], а остальная часть регистре MXCSR\[6:15], считается энергонезависимой.

Защищенной части задано следующие стандартные значения в начале выполнения программы:

| Зарегистрировать\[bits] | Параметр |
|-|-|
| MXCSR\[6] | Denormals нулей - 0 |
| MXCSR\[7:12] | Исключение маскирует все 1 (маскируются все исключения) |
| MXCSR\[13:14] | Управление округления — 0 (с округлением к ближайшему) |
| MXCSR\[15] | Очистить до нуля маскированные потери точности - 0 (отключено) |

Вызываемый объект, который изменяет любое из защищенных полей в MXCSR необходимо восстановить их перед возвращением вызывающему. Более того вызывающий объект, который был изменен любой из этих полей, должен восстановить их стандартные значения перед вызовом вызываемым объектом, если только соглашением вызываемый требует измененные значения.

Существует два исключения из правил о неизменяемости управляющих флагов.

- В функциях, где документированных заданная функция предназначена для изменения защищенные MxCsr флаги.

- При его правильности неплохие результаты что нарушения этих правил в программе, которая ведет себя так же, как программы, где эти правила не нарушены, например, посредством анализа всей программы.

Невозможно сделать никаких предположений о состоянии volatile части MXCSR на границе функции оговорено особо в документации функции.

## <a name="setjmplongjmp"></a>setjmp/longjmp

При включении setjmpex.h или setjmp.h, все вызовы [setjmp](../c-runtime-library/reference/setjmp.md) или [longjmp](../c-runtime-library/reference/longjmp.md) привести очистки, который вызывает деструкторы и `__finally` вызовов.  Это отличается от x86, где setjmp.h включая приводит к `__finally` предложений и деструкторы не вызываются.

Вызов `setjmp` сохраняется текущего указателя стека, неизменяемые регистры и регистры MxCsr.  Вызовы `longjmp` возврат к последнему `setjmp` вызова сайта и сброса указателя стека, неизменяемые регистры и MxCsr регистрирует, в состояние, сохраненное с самой последней `setjmp` вызова.

## <a name="see-also"></a>См. также

[Программные соглашения для 64-разрядных систем](../build/x64-software-conventions.md)
