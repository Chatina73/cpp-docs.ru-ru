---
title: Соглашение о вызовах для 64-разрядных систем
description: Подробная информация о конвенции вызова по умолчанию x64 ABI.
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: caf22172ea5e9c20280bce8e508d72fd30c00c5b
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335131"
---
# <a name="x64-calling-convention"></a>Соглашение о вызовах для 64-разрядных систем

В этом разделе описаны стандартные процессы и конвенции, которые одна функция (вызывающий) использует для вызова в другую функцию (коллер) в коде x64.

## <a name="calling-convention-defaults"></a>Вызов по умолчанию конвенции

В приложении x64 Binary Interface (ABI) по умолчанию используется четырехрегистрная конвенция быстрого вызова. Пространство выделяется в стеке вызовов в качестве теневого хранилища для абонентов для сохранения этих регистров. Существует строгая один к одному корреспонденция между аргументами к вызову функции и регистрами, используемыми для этих аргументов. Любой аргумент, который не вписывается в 8 байтов, или не 1, 2, 4 или 8 байтов, должны быть переданы по ссылке. Один аргумент никогда не распространяется на несколько регистров. Стек регистра x87 не используется и может использоваться вызываемым абонентом, но должен считаться нестабильным во всех вызовах функций. Все операции по плавающей точке выполняются с использованием 16 регистров XMM. Аргументы Integer передаются в регистрах RCX, RDX, R8 и R9. Аргументы по плавающим точкам передаются в XMM0L, XMM1L, XMM2L и XMM3L. 16-байт аргументы передаются по ссылке. Прохождение параметра подробно описано в [Параметр Есау.](#parameter-passing) В дополнение к этим регистрам, RAX, R10, R11, XMM4, и XMM5 считаются неустойчивыми. Все остальные регистры не являются летучими. Использование регистра подробно описано в [регистрах использования](../build/x64-software-conventions.md#register-usage) и [Caller /Callee Сохраненные регистры](#callercallee-saved-registers).

Для прототипируемых функций все аргументы преобразуются в ожидаемые типы calleee перед прохождением. Вызыватель отвечает за выделение места для параметров вызывающего абонента и должен всегда выделять достаточно места для хранения четырех параметров регистра, даже если вызыватель не принимает так много параметров. Эта конвенция упрощает поддержку непрототипированных функций C-языка и функций vararg C/C. Для vararg или непрототипированных функций любые значения плавающей точки должны дублироваться в соответствующем регистре общего назначения. Любые параметры, выходящие за рамки первых четырех, должны храниться в стеке после теневого хранилища до вызова. Детали функции Vararg можно найти в [Varargs.](#varargs) Неописанная информация о функциях подробно описана в [непрототипированных функциях.](#unprototyped-functions)

## <a name="alignment"></a>Выравнивание

Большинство структур приведены в соответствие с их естественным выравниванием. Основными исключениями являются указатель `malloc` стека `alloca` и или память, которые выровнены до 16 байтов для того, чтобы помочь производительности. Выравнивание выше 16 байтов должно быть сделано вручную, но так как 16 байтов является общим размером выравнивания для операций XMM, это значение должно работать для большинства кода. Для получения дополнительной информации о макете и выравнивании структуры [см.](../build/x64-software-conventions.md#types-and-storage) Для получения информации о [x64 stack usage](../build/stack-usage.md)макете стека см.

## <a name="unwindability"></a>Неветренность

Функции листа — это функции, которые не меняют нелетучих регистров. Функция нелиста может изменять нелетучие RSP, например, вызывая функцию или выделяя дополнительное пространство стека для локальных переменных. Для восстановления нелетучих регистров при обработке исключения функции нелистовых данных должны быть аннотированы статическими данными, описывающие, как правильно раскрутить функцию при произвольной инструкции. Эти данные хранятся в виде *данных pdata*или данных процедуры, что, в свою очередь, относится к *данным обработки xdata,* обработке исключений. Xdata содержит раскручивающуюся информацию и может указывать на дополнительную функцию pdata или обработчик авериков. Прологи и эпилоги сильно ограничены, так что они могут быть правильно описаны в xdata. Указатель стека должен быть выровнен до 16 байтов в любом регионе кода, который не является частью эпилога или пролога, за исключением функций листа. Функции листьев можно развернуть, просто имитируя возврат, поэтому pdata и xdata не требуются. Подробнее о правильной структуре функциональных prologs и эпилогов [см.](../build/prolog-and-epilog.md) Для получения дополнительной информации об обработке исключений, обработке исключений и раскручивании pdata и xdata [см.](../build/exception-handling-x64.md)

## <a name="parameter-passing"></a>Передача параметров

Первые четыре единых аргумента передаются в регистрах. Значения integer передаются в порядке слева направо в RCX, RDX, R8 и R9 соответственно. Аргументы пять и выше передаются по стеку. Все аргументы являются оправданными в регистрах, поэтому calleeможет игнорировать верхние части регистра и получить доступ только к необходимой части регистра.

Любые плавающие точки и двухточные аргументы в первых четырех параметрах передаются в XMM0 - XMM3, в зависимости от позиции. Целая регистры RCX, RDX, R8 и R9, которые обычно используются для этих позиций, игнорируются, за исключением аргументов varargs. Для получения подробной информации, [см.](#varargs) Аналогичным образом, регистры XMM0 - XMM3 игнорируются, когда соответствующий аргумент представляет собой разбитую или указательную тип.

[__m128](../cpp/m128.md) типы, массивы и строки никогда не передаются немедленное значение. Вместо этого указатель передается памяти, выделенной абонентом. Структуры и союзы размером 8, 16, 32 или 64 бита, а также __m64 типов, передаются так, как если бы они были целыми числами одного размера. Структуры или союзы других размеров передаются в качестве указателя на память, выделенную абонентом. Для этих агрегированных типов, \_пройденных как указатель, включая _m128, выделенная вызываемому временной память должна быть выровнена на 16 байт.

Внутренние функции, которые не выделяют пространство стека и не вызывают другие функции, иногда используют другие нестабильные регистры для передачи дополнительных аргументов регистра. Эта оптимизация становится возможной благодаря плотной связыванию между компилятором и реализацией внутренней функции.

Звонивший отвечает за сброс параметров регистра в их теневое пространство, если это необходимо.

В следующей таблице кратко излагается, как передаются параметры:

|Тип параметра|Как прошло|
|--------------------|----------------|
|С плавающей запятой|Первые 4 параметра - XMM0 через XMM3. Другие перешли на стек.|
|Целое число|Первые 4 параметра - RCX, RDX, R8, R9. Другие перешли на стек.|
|Агрегаты (8, 16, 32 или 64 бита) и __m64|Первые 4 параметра - RCX, RDX, R8, R9. Другие перешли на стек.|
|Агрегаты (другие)|По указателю. Первые 4 параметра, пройдено в качестве указателей в RCX, RDX, R8 и R9|
|__m128|По указателю. Первые 4 параметра, пройдено в качестве указателей в RCX, RDX, R8 и R9|

### <a name="example-of-argument-passing-1---all-integers"></a>Пример аргумента прохождения 1 - все несколько часов

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>Пример аргумента прохождения 2 - все поплавки

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>Пример аргумента прохождения 3 - смешанные ints и поплавки

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--__m64-__m128-and-aggregates"></a>Пример аргумента, проходящего \_4 -__m64, _m128 и агрегаты

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>Функции с переменным количеством аргументов (Varargs)

Если параметры передаются через varargs (например, аргументы эллипсиса), то применяется нормальный параметр регистра, проходящий конвенцию, включая разлив пятого и последующих аргументов в стек. Это ответственность звоняща сбрасывать аргументы, которые имеют свой адрес. Только для значений плавающей точки как регистр ажероприра, так и регистр плавающей точки должны содержать значение, в случае, если callee ожидает значение в регистрах.

## <a name="unprototyped-functions"></a>Неопытные функции

Для функций, не полностью прототипированных, абонент передает целые значения как целые столбы и значения плавающей точки как двойную точность. Только для значений плавающей точки как регистр ажероприра, так и регистр плавающей точки содержат значение поплавка в случае, если callee ожидает значение в регистрах integer.

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>Возвращаемые значения

Значение возврата масштабирования, которое может поместиться в 64 бита, возвращается через RAX; это включает в себя __m64 типов. Нескальные типы, включая поплавки, двойные и векторные типы, такие как [__m128,](../cpp/m128.md) [__m128i,](../cpp/m128i.md) [__m128d](../cpp/m128d.md) возвращаются в XMM0. Состояние неиспользуемых битов в возвращаемом значении в RAX или XMM0 не определяется.

Определенные пользователем типы можно вернуть из глобальных функций и статических функций-членов по значению. Чтобы вернуть пользовательский тип по значению в RAX, он должен иметь длину 1, 2, 4, 8, 16, 32 или 64 бита. Он также должен иметь не определяемый пользователем конструктор, деструктор или оператор назначения копий; нет частных или защищенных нестатических членов данных; нет нестатических членов данных эталонного типа; нет базовых классов; никаких виртуальных функций; и нет членов данных, которые также не отвечают этим требованиям. (Фактически это — определение типа C ++ 03 POD. Поскольку определение изменилось в стандарте СЗ11, мы `std::is_pod` не рекомендуем использовать для этого теста.) В противном случае, абонент берет на себя ответственность за выделение памяти и передачу указателя на значение возврата в качестве первого аргумента. Последующие аргументы затем перемещаются на один аргумент вправо. Тот же указатель должен быть возвращен вызываемой стороной в RAX.

В приведенных ниже примерах показан способ передачи параметров и возвращаемых значений для функций с указанными объявлениями.

### <a name="example-of-return-value-1---64-bit-result"></a>Пример значения возврата 1 - 64-битный результат

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>Пример значения возврата 2 - 128-битный результат

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>Пример значения возврата 3 - результат типа пользователя по указателю

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>Пример значения возврата 4 - результат типа пользователя по стоимости

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>Сохраненные регистры Caller/Callee

Регистры RAX, RCX, RDX, R8, R9, R10, R11, XMM0-5, а также верхние части YMM0-15 и ZMM0-15 считаются нестабильными и должны считаться уничтоженными при вызове функций (если в противном случае безопасность не будет довобитом анализа, такого как оптимизация всей программы). На AVX512VL, Регистрах ЗММ, YMM и XMM 16-31 являются нестабильными.

Регистры RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15 и XMM6-15 считаются нелетучими и должны быть сохранены и восстановлены функцией, которая их использует.

## <a name="function-pointers"></a>Указатели функций

Функционные указатели просто указатели на метку соответствующей функции. Нет таблицы требований к содержимому (TOC) для указателей функций.

## <a name="floating-point-support-for-older-code"></a>Поддержка плавающей точки для старого кода

Регистры стеков MMX и плавающей точки (MM0-MM7/ST0-ST7) сохраняются в контекстных переключателях. Для этих регистров не существует четкой конвенции о призыве. Использование этих регистров строго запрещено в коде режима ядра.

## <a name="fpcsr"></a>FpCsr

Состояние регистра также включает в себя слово управления FPU x87. Конвенция о вызове диктует этот регистр нелетучим.

Регистр контрольных слов X87 FPU устанавливается на следующие стандартные значения в начале выполнения программы:

| Регистрация\[битов | Параметр |
|-|-|
| ФПКСР\[0:6 | Исключение маски все 1 (все исключения в масках) |
| ФПКСР\[7 | Зарезервировано - 0 |
| ФПКСР\[8:9 | Точность управления - 10B (двойная точность) |
| ФПКСР\[10:11 | Управление округлением - 0 (круглое до ближайшего) |
| ФПКСР\[12 | Управление бесконечностью - 0 (не используется) |

Звонивший, который изменяет любое из полей в FPCSR, должен восстановить их перед возвращением к вызывающему абоненту. Кроме того, вызывающий абонент, который изменил любое из этих полей, должен восстановить их к своим стандартным значениям, прежде чем вызвать вызываемого абонента, если по соглашению вызывающий абонент не ожидает измененных значений.

Есть два исключения из правил о неволатильности флагов управления:

1. В функциях, где документально подтвержденная цель данной функции заключается в изменении нелетучих флагов FpCsr.

1. Когда доказатеренно правильно, что нарушение этих правил приводит к тому, что программа ведет себя так же, как программа, где эти правила не нарушаются, например, с помощью анализа всей программы.

## <a name="mxcsr"></a>Регистр MxCsr

В реестр также входит MxCsr. Конвенция о вызове делит этот регистр на нестабильную и нелетучую часть. Волатильной части состоит из шести флагов\[статуса, в MXCSR 0:5\[", в то время как остальная часть регистра, MXCSR 6:15 ", считается нелетучим.

Нелетучая часть устанавливается на следующие стандартные значения в начале выполнения программы:

| Регистрация\[битов | Параметр |
|-|-|
| MXCSR\[6 | Денормалы - нули - 0 |
| MXCSR\[7:12 | Исключение маски все 1 (все исключения в масках) |
| MXCSR\[13:14 | Управление округлением - 0 (круглое до ближайшего) |
| MXCSR\[15 | Флеш к нулю для подливки в масках - 0 (выкл) |

Звонящая, которая изменяет любое из нелетучих полей в MXCSR, должна восстановить их перед возвращением к вызываемому абоненту. Кроме того, вызывающий абонент, который изменил любое из этих полей, должен восстановить их к своим стандартным значениям, прежде чем вызвать вызываемого абонента, если по соглашению вызывающий абонент не ожидает измененных значений.

Есть два исключения из правил о неволатильности флагов управления:

- В функциях, где документально подтвержденная цель данной функции заключается в изменении нелетучих флагов MxCsr.

- Когда доказатеренно правильно, что нарушение этих правил приводит к тому, что программа ведет себя так же, как программа, где эти правила не нарушаются, например, с помощью анализа всей программы.

Нет никаких предположений о состоянии волатильной части MXCSR через границу функции, если конкретно не описано в документации функции.

## <a name="setjmplongjmp"></a>setjmp/longjmp

Когда вы включаете setjmpex.h или setjmp.h, все вызовы, чтобы [setjmp](../c-runtime-library/reference/setjmp.md) или [longjmp](../c-runtime-library/reference/longjmp.md) `__finally` привести к расслабиться, что вызывает деструкторов и вызовов.  Это отличается от x86, где включение setjmp.h приводит к `__finally` тому, что положения и деструкторы не вызываются.

Призыв сохранить `setjmp` текущий указатель стека, нелетучие регистры и регистры MxCsr.  Призывы `longjmp` вернуться на `setjmp` самый последний сайт вызова и сбросы указателя стека, нелетучие регистры и `setjmp` регистры MxCsr, обратно в состояние, как это сохранено последним вызовом.

## <a name="see-also"></a>См. также раздел

[Программные соглашения для 64-разрядных систем](../build/x64-software-conventions.md)
