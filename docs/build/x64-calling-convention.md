---
title: Соглашение о вызовах для 64-разрядных систем
description: Сведения о соглашении о вызовах по умолчанию x64 ABI.
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: 2cad00ac7f2cb5fe086fa262a0f512330997391f
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79422706"
---
# <a name="x64-calling-convention"></a>Соглашение о вызовах для 64-разрядных систем

В этом разделе описаны стандартные процессы и соглашения, которые одна функция (вызывающая сторона) использует для выполнения вызовов к другой функции (вызываемой) в коде x64.

## <a name="calling-convention-defaults"></a>Значения соглашений о вызовах по умолчанию

В интерфейсе для 64-разрядных приложений (ABI) по умолчанию используется соглашение о вызовах по 4 регистрам. Место выделяется в стеке вызовов как теневое хранилище для вызываемые сохранения этих регистров. Между аргументами вызова функции и регистрами, используемыми для этих аргументов, существует однозначное соответствие. Любой аргумент, который не умещается в 8 байт, или не равен 1, 2, 4 или 8 байтам, должен передаваться по ссылке. Один аргумент никогда не распределяется между несколькими регистрами. Стек регистров x87 не используется и может использоваться вызываемым объектом, но должен рассматриваться как временный в рамках вызовов функций. Все операции с плавающей точкой выполняются с помощью 16 регистров XMM. Целочисленные аргументы передаются в регистрах РККС, RDX, R8 и R9. Аргументы с плавающей запятой передаются в XMM0L, XMM1L, XMM2L и XMM3L. 16-байтовые аргументы передаются по ссылке. Передача параметров подробно описана в разделе [Передача параметров](#parameter-passing). Помимо этих регистров, RAX, R10, R11, XMM4 и XMM5 считаются временными. Все остальные регистры не меняются временными. Подробное описание использования см. в статье [об использовании](../build/x64-software-conventions.md#register-usage) регистров и [сохраненных регистрах вызывающего и вызываемого объекта](#callercallee-saved-registers).

Для функций с прототипом все аргументы преобразуются в ожидаемые типы вызываемых объектов перед передачей. Вызывающий объект отвечает за выделение пространства для параметров вызываемому объекту и всегда должен выделить достаточно места для хранения четырех параметров регистров, даже если вызываемая сторона не принимает это множество параметров. Это соглашение упрощает поддержку функций языка C без прототипов и vararg C/C++ functions. Для функций vararg и unprototype все значения с плавающей запятой должны дублироваться в соответствующем регистре общего назначения. Все параметры за пределами первых четырех должны храниться в стеке после теневого хранилища перед вызовом. Подробные сведения о функции vararg можно найти в списке [varargs](#varargs). Сведения о функции без прототипа подробно описаны в [функциях без прототипов](#unprototyped-functions).

## <a name="alignment"></a>Выравнивание

Большинство структур выровнены по естественному выравниванию. Основные исключения — это указатель стека, `malloc` или `alloca` памяти, которые вычисляются до 16 байт, чтобы обеспечить производительность. Выравнивание свыше 16 байтов должно выполняться вручную, но поскольку 16 байт — это общий размер выравнивания для операций XMM, это значение должно работать для большинства кодов. Дополнительные сведения о структуре и выравнивании структуры см. в разделе [типы и хранилище](../build/x64-software-conventions.md#types-and-storage). Сведения о макете стека см. в разделе [Использование x64 Stack](../build/stack-usage.md).

## <a name="unwindability"></a>Необмотка

Конечные функции — это функции, которые не изменяют временные регистры. Неконечная функция может изменить неизменяемый RSP, например, путем вызова функции или выделения дополнительного пространства стека для локальных переменных. Чтобы восстановить непостоянные регистры при обработке исключения, неконечные функции должны быть снабжены статическими данными, описывающими, как правильно раскрутить функцию в произвольной инструкции. Эти данные хранятся в виде *pData*или данных процедуры, которые, в свою очередь, ссылаются на *XData*, данные обработки исключений. Значение XData содержит сведения о декрутке и может указывать на дополнительные pData или функцию обработчика исключений. Журналы и эпилоги имеют высокий уровень ограничений, чтобы их можно было правильно описать в xdata. Указатель стека должен быть согласован до 16 байт в любом регионе кода, который не является частью эпилога или пролога, за исключением конечных функций. Конечные функции могут быть вернуты просто путем имитации возврата, поэтому не требуются pData и XData. Дополнительные сведения о правильной структуре журналов функций и эпилоги см. в разделе [x64 Пролог и эпилога](../build/prolog-and-epilog.md). Дополнительные сведения об обработке исключений, обработке исключений и очистке для pData и XData см. в разделе [обработка исключений x64](../build/exception-handling-x64.md).

## <a name="parameter-passing"></a>Передача параметров

Первые четыре целочисленных аргумента передаются в регистры. Целочисленные значения передаются в порядке слева направо в РККС, RDX, R8 и R9 соответственно. В стеке передаются аргументы 5 и выше. Все аргументы выравниваются по правому краю в регистрах, поэтому вызываемый объект может игнорировать верхние биты регистра и получить доступ только к той части регистра, которая необходима.

Любые аргументы с плавающей запятой и двойной точностью в первых четырех параметрах передаются в XMM0-XMM3 в зависимости от позиции. Целое число регистрирует РККС, RDX, R8 и R9, которые обычно используются для этих позиций, но не в случае аргументов varargs. Дополнительные сведения см. в разделе [varargs](#varargs). Аналогичным образом регистры XMM0-XMM3 игнорируются, если соответствующий аргумент имеет тип Integer или Pointer.

типы [__m128](../cpp/m128.md) , массивы и строки никогда не передаются непосредственным значением. Вместо этого указатель передается в память, выделенную вызывающей стороной. Структуры и объединения размера 8, 16, 32 или 64 бит и __m64 типов передаются, как если бы они были целыми числами одного и того же размера. Структуры или объединения других размеров передаются в качестве указателя на память, выделенную вызывающим объектом. Для этих агрегатных типов, которые передаются в виде указателя, в том числе \__m128, выделенная вызывающей стороной временная память должна быть сопоставлена 16 байт.

Встроенные функции, которые не выделяют пространство стека и не вызывают другие функции, иногда используют другие временные регистры для передачи дополнительных аргументов регистрации. Такая оптимизация возможна благодаря тесной привязке между компилятором и внутренней реализацией функции.

Вызываемая сторона отвечает за дамп параметров регистров в теневом пространстве при необходимости.

В следующей таблице приведены сводные сведения о передаче параметров.

|Тип параметра|Как передается|
|--------------------|----------------|
|Число с плавающей запятой|Первые 4 параметра — XMM0 через XMM3. Остальные передаются в стеке.|
|Целое число|Первые 4 параметра — РККС, RDX, R8, R9. Остальные передаются в стеке.|
|Статистические выражения (8, 16, 32 или 64 бит) и __m64|Первые 4 параметра — РККС, RDX, R8, R9. Остальные передаются в стеке.|
|Агрегаты (другие)|По указателю. Первые 4 параметра передаются как указатели в РККС, RDX, R8 и R9|
|__m128|По указателю. Первые 4 параметра передаются как указатели в РККС, RDX, R8 и R9|

### <a name="example-of-argument-passing-1---all-integers"></a>Пример передачи аргумента 1 — все целые числа

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>Пример передачи аргумента 2 — все плавающие

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>Пример передачи аргумента 3 — смешанные ints и float

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--__m64-__m128-and-aggregates"></a>Пример передачи аргумента 4-__m64, \__m128 и агрегатов

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>Функции с переменным количеством аргументов (Varargs)

Если параметры передаются через varargs (например, аргументы многоточия), применяется стандартное соглашение о передаче параметров регистров, включая перенос пятого и последующих аргументов в стек. Вызываемый объект отвечает за аргументы дампа, которые получают свой адрес. Для значений с плавающей запятой как регистр целых чисел, так и регистр с плавающей запятой должны содержать значение, если вызываемый объект ожидает значение в целочисленных регистрах.

## <a name="unprototyped-functions"></a>Функции без прототипа

Для функций, не полностью прототипов, вызывающий объект передает целочисленные значения как целые числа и значения с плавающей запятой в виде двойной точности. Для значений с плавающей запятой как регистр целых чисел, так и регистр с плавающей запятой содержат значение float, если вызываемый объект ожидает значение в целочисленных регистрах.

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>Возвращаемые значения

Скалярное возвращаемое значение, которое может вместить в 64 бит, возвращается через RAX; к ним относятся __m64 типы. Нескалярные типы, в том числе типы float, Double и Vector, такие как [__m128](../cpp/m128.md), [__m128i](../cpp/m128i.md), [__m128d](../cpp/m128d.md) возвращаются в XMM0. Состояние неиспользуемых битов в возвращаемом значении в RAX или XMM0 не определяется.

Определенные пользователем типы можно вернуть из глобальных функций и статических функций-членов по значению. Чтобы вернуть определяемый пользователем тип по значению в RAX, он должен иметь длину 1, 2, 4, 8, 16, 32 или 64 бит. Он также должен иметь пользовательский конструктор, деструктор или оператор присваивания копирования. нет закрытых или защищенных нестатических элементов данных; нет нестатических данных-членов ссылочного типа; нет базовых классов; нет виртуальных функций; и не имеют элементов данных, которые также не соответствуют этим требованиям. (Фактически это — определение типа C ++ 03 POD. Поскольку определение изменилось в стандарте C++ 11, для этого теста не рекомендуется использовать `std::is_pod`.) В противном случае вызывающий объект принимает ответственность за выделение памяти и передачу указателя на возвращаемое значение в качестве первого аргумента. Последующие аргументы затем перемещаются на один аргумент вправо. Тот же указатель должен быть возвращен вызываемой стороной в RAX.

В приведенных ниже примерах показан способ передачи параметров и возвращаемых значений для функций с указанными объявлениями.

### <a name="example-of-return-value-1---64-bit-result"></a>Пример возвращаемого значения 1-64-разрядного результата

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>Пример возвращаемого значения 2-128-разрядного результата

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>Пример возвращаемого значения 3 — результат типа пользователя по указателю

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>Пример возвращаемого значения 4 — результат типа пользователя по значению

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>Сохраненные регистры вызывающего/вызываемого объекта

Регистры RAX, РККС, RDX, R8, R9, R10, R11, XMM0-5 и верхние части YMM0-15 и ZMM0-15 считаются временными и должны считаться уничтоженными при вызовах функций (если иное не обеспечивается защитой при анализе, например при оптимизации всей программы). В AVX512VL регистры ЗММ, ИММ и XMM 16-31 являются временными.

Регистры РБКС, РБП, RDI, РСИ, RSP, R12, R13, R14, R15 и XMM6-15 считаются непостоянными и должны быть сохранены и восстановлены с помощью функции, которая их использует.

## <a name="function-pointers"></a>Указатели функций
 
Указатели функций — это просто указатели на метку соответствующей функции. Для указателей на функции не предусмотрены требования к содержанию (TOC).

## <a name="floating-point-support-for-older-code"></a>Поддержка операций с плавающей запятой для старого кода

Реестры MMX и стека с плавающей запятой (MM0-MM7/ST0-ST7) сохраняются во всех переключениях контекста. Для этих регистров нет явного соглашения о вызове. Использование этих регистров строго запрещено в коде режима ядра.

## <a name="fpcsr"></a>FpCsr

Состояние регистра также включает управляющее слово x87 FPU. Соглашение о вызовах определяет, что регистр не является энергозависимым.

Регистр управляющего слова x87 FPU задается со следующими стандартными значениями в начале выполнения программы:

| Регистрация\[бит] | Параметр |
|-|-|
| ФПКСР\[0:6] | Маски исключений все 1 (все исключения маскированы) |
| ФПКСР\[7] | Зарезервировано-0 |
| ФПКСР\[8:9] | Precision Control-10B (двойная точность) |
| ФПКСР\[10:11] | Элемент управления округлением — 0 (округление до ближайшего числа) |
| ФПКСР\[12] | Управление бесконечностью — 0 (не используется) |

Вызываемая сторона, которая изменяет любое из полей в ФПКСР, должна восстановить их перед возвратом в вызывающий объект. Кроме того, вызывающий объект, который изменил любое из этих полей, должен восстановить их стандартные значения перед вызовом вызываемого объекта, если только соглашение, вызывающее, не требует измененных значений.

Существует два исключения для правил, связанных с неизменчивостиными флагами элемента управления:

1. В функциях, где документированная цель заданной функции заключается в изменении неизменяемых флагов Фпкср.

1. Если это неплохие, то нарушение этих правил приводит к тому, что в программе происходит то же, что и программа, в которой эти правила не нарушаются, например с помощью анализа всей программы.

## <a name="mxcsr"></a>Регистр MxCsr

Состояние регистра также включает Мкскср. Соглашение о вызовах делит этот регистр на временную часть и неизменяемую часть. Изменяемая часть состоит из шести флагов состояния в мкскср\[0:5], а остальная часть регистра мкскср\[6:15] считается энергонезависимой.

Для неизменяемой части в начале выполнения программы задаются следующие стандартные значения:

| Регистрация\[бит] | Параметр |
|-|-|
| МКСКСР\[6] | Нормали равны нулю-0 |
| МКСКСР\[7:12] | Маски исключений все 1 (все исключения маскированы) |
| МКСКСР\[13:14] | Элемент управления округлением — 0 (округление до ближайшего числа) |
| МКСКСР\[15] | Сброс на нуль для маскирования неточного значения 0 (выкл.) |

Вызываемый метод, который изменяет любое из неизменяемых полей в МКСКСР, должен восстановить их перед возвратом в вызывающий объект. Кроме того, вызывающий объект, который изменил любое из этих полей, должен восстановить их стандартные значения перед вызовом вызываемого объекта, если только соглашение, вызывающее, не требует измененных значений.

Существует два исключения для правил, связанных с неизменчивостиными флагами элемента управления:

- В функциях, где документированная цель заданной функции заключается в изменении неизменяемых флагов Мкскср.

- Если это неплохие, то нарушение этих правил приводит к тому, что в программе происходит то же, что и программа, в которой эти правила не нарушаются, например с помощью анализа всей программы.

Никакие допущения не могут быть сделаны относительно состояния изменяемой части МКСКСР в границах функции, кроме случаев, особо описанных в документации по функции.

## <a name="setjmplongjmp"></a>setjmp/longjmp

При включении сетжмпекс. h или setjmp. h все вызовы [setjmp](../c-runtime-library/reference/setjmp.md) или [longjmp](../c-runtime-library/reference/longjmp.md) приводят к очистке, вызывающему деструкторы и вызовы `__finally`.  Это отличается от x86, где включение setjmp. h приводит к невозможности вызова `__finally` предложений и деструкторов.

Вызов `setjmp` сохраняет текущие указатели стека, неизменяемые регистры и регистры Мкскср.  Вызовы `longjmp` возвращаться к последнему `setjmp`му сайту вызова и сбрасывают указатель стека, непостоянные регистры и регистры Мкскср назад в состояние, сохраненное последним вызовом `setjmp`.

## <a name="see-also"></a>См. также раздел

[Программные соглашения для 64-разрядных систем](../build/x64-software-conventions.md)
