---
title: Соглашение о вызовах для 64-разрядных систем
description: Сведения о соглашении о вызовах ABI для 64-разрядных систем по умолчанию.
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: caf22172ea5e9c20280bce8e508d72fd30c00c5b
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335131"
---
# <a name="x64-calling-convention"></a>Соглашение о вызовах для 64-разрядных систем

В этом разделе описаны стандартные процессы и соглашения, которые одна функция (вызывающий объект) использует для выполнения вызовов к другой функции (вызываемый объект) в коде x64.

## <a name="calling-convention-defaults"></a>Соглашения о вызовах по умолчанию

Двоичный интерфейс для 64-разрядных приложений (ABI) по умолчанию использует соглашение о вызовах по четырем регистрам. Место в стеке вызовов выделяется как теневое хранилище для вызываемых функций сохранения этих регистров. Между аргументами вызова функции и регистрами, используемыми для этих аргументов, существует однозначное соответствие. Любой аргумент, который не умещается в 8 байтов или не равен 1, 2, 4 или 8 байтам, должен передаваться по ссылке. Один аргумент никогда не распределяется между несколькими регистрами. Стек регистров x87 не задействуется и может использоваться вызываемой функцией. Однако он должен рассматриваться как изменяемый в рамках вызовов функций. Все операции с числами с плавающей запятой выполняются с помощью 16 регистров XMM. Целочисленные аргументы передаются в регистрах РККС, RDX, R8 и R9. Аргументы с плавающей запятой передаются в XMM0L, XMM1L, XMM2L и XMM3L. 16-байтовые аргументы передаются по ссылке. Подробнее о передаче параметров см. в статье [Передача параметров](#parameter-passing). Помимо этих регистров, RAX, R10, R11, XMM4 и XMM5 считаются изменяемыми. Все остальные регистры являются неизменяемыми. Подробное описание использования регистров см. в статьях [Использование регистров](../build/x64-software-conventions.md#register-usage) и [Сохраненные регистры вызывающей/вызываемой функции](#callercallee-saved-registers).

Для функций с прототипом все аргументы преобразуются в ожидаемые типы вызываемых объектов перед передачей. Вызывающий объект отвечает за выделение пространства для параметров вызываемому объекту и всегда должен выделить достаточно места для хранения четырех параметров регистров, даже если вызываемый объект не принимает это множество параметров. Это соглашение упрощает поддержку функций языка C без прототипов и функций vararg C/C++. Для функций vararg и функций без прототипа все значения с плавающей запятой должны дублироваться в соответствующем регистре общего назначения. Все параметры за пределами первых четырех регистров должны храниться в стеке после теневого хранилища перед вызовом. Подробные сведения о функции vararg см. в статье [Функции vararg](#varargs). Подробнее о функции без прототипа см. в статье [Функции без прототипов](#unprototyped-functions).

## <a name="alignment"></a>Выравнивание

Большинство структур выровнены в соответствии с естественным выравниванием. Основные исключения — это указатель стека и память `malloc` или `alloca`, которые вычисляются до 16 байтов, чтобы обеспечить производительность. Выравнивание свыше 16 байтов должно выполняться вручную, но, поскольку 16 байтов — это общий размер выравнивания для операций XMM, это значение должно подходить для большинства кодов. Дополнительные сведения о макете и выравнивании структуры см. в разделе [Типы и хранилище](../build/x64-software-conventions.md#types-and-storage). Подробнее о макете стека см. в разделе [Использование стека x64](../build/stack-usage.md).

## <a name="unwindability"></a>Раскрутка

Конечные функции — это функции, которые не изменяют неизменяемые регистры. Неконечная функция может изменить неизменяемый RSP, например путем вызова функции или выделения дополнительного пространства стека для локальных переменных. Чтобы восстановить неизменяемые регистры при обработке исключения, неконечные функции должны быть снабжены статическими данными, описывающими, как правильно раскрутить функцию в произвольной инструкции. Эти данные хранятся в виде *pdata* или данных процедуры, которые, в свою очередь, ссылаются на *xdata*, данные обработки исключений. Значение xdata содержит сведения о раскрутке и может указывать на дополнительные pdata или функцию обработчика исключений. Прологи и эпилоги имеют высокий уровень ограничений, чтобы их можно было правильно описать в xdata. Указатель стека должен быть выровнен до 16 байтов в любом регионе кода, который не является частью эпилога или пролога, за исключением конечных функций. Конечные функции можно развернуть просто путем имитации возврата, поэтому pdata и xdata не требуются. Дополнительные сведения о правильной структуре прологов и эпилогов функции см. в разделе [Пролог и эпилог в коде x64](../build/prolog-and-epilog.md). Дополнительные сведения об обработке исключений, обработке исключений и раскрутке для pdata и xdata см. в разделе [Обработка исключений в коде x64](../build/exception-handling-x64.md).

## <a name="parameter-passing"></a>Передача параметров

Первые четыре целочисленных аргумента передаются в регистрах. Целочисленные значения передаются в порядке слева направо в RCX, RDX, R8 и R9 соответственно. Аргументы с 5 и далее передаются в стеке. Все аргументы выравниваются по правому краю в регистрах, поэтому вызываемый объект может игнорировать верхние биты регистра и получить доступ только к той части регистра, которая необходима.

Любые аргументы с плавающей запятой и двойной точностью в первых четырех параметрах передаются в XMM0–XMM3 (в зависимости от позиции). Обычно для этих позиций используются регистры целочисленных значений RCX, RDX, R8 и R9, за исключением аргументов функций vararg. Дополнительные сведения см. в разделе [Функции vararg](#varargs). Аналогичным образом регистры XMM0–XMM3 игнорируются, если соответствующий аргумент является целым числом или указателем.

Типы [__m128](../cpp/m128.md), массивы и строки никогда не передаются непосредственным значением. Вместо этого указатель передается в память, выделенную вызывающим объектом. Структуры и объединения размера 8, 16, 32 или 64 бит и типов __m64 передаются, как если бы они были целыми числами одного и того же размера. Структуры или объединения других размеров передаются в качестве указателя в память, выделенную вызывающим объектом. Для этих агрегатных типов, которые передаются в виде указателя, в том числе \__m128, выделенная вызывающей стороной временная память должна составлять 16 байтов.

Встроенные функции, которые не выделяют пространство стека и не вызывают другие функции, иногда используют другие изменяемые регистры для передачи дополнительных аргументов регистра. Такая оптимизация возможна благодаря тесной привязке между компилятором и реализацией внутренней функции.

Вызываемый объект отвечает за дамп параметров регистров в теневом пространстве, если потребуется.

В следующей таблице приведены сводные сведения о передаче параметров.

|Тип параметра|Способ передачи|
|--------------------|----------------|
|С плавающей запятой|Первые 4 параметра — с XMM0 по XMM3. Остальные передаются в стеке.|
|Целое число|Первые 4 параметра — RCX, RDX, R8, R9. Остальные передаются в стеке.|
|Агрегаты (8, 16, 32 или 64 бит) и __m64|Первые 4 параметра — RCX, RDX, R8, R9. Остальные передаются в стеке.|
|Агрегаты (другие)|По указателю. Первые 4 параметра передаются как указатели в RCX, RDX, R8 и R9|
|__m128|По указателю. Первые 4 параметра передаются как указатели в RCX, RDX, R8 и R9|

### <a name="example-of-argument-passing-1---all-integers"></a>Пример передачи аргумента 1 — все целые числа

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>Пример передачи аргумента 2 — все числа с плавающей запятой

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>Пример передачи аргумента 3 — целые числа и числа с плавающей запятой

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--__m64-__m128-and-aggregates"></a>Пример передачи аргумента 4 —__m64, \__m128 и агрегаты

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>Функции с переменным количеством аргументов (Varargs)

Если параметры передаются через функции vararg (например, аргументы многоточия), применяется стандартное соглашение о передаче параметров регистров, включая перенос пятого и последующих аргументов в стек. Вызываемый объект отвечает за аргументы дампа, которые получают свой адрес. Для значений с плавающей запятой как регистр целых чисел, так и регистр чисел с плавающей запятой должны содержать значение, если вызываемый объект ожидает значение в целочисленных регистрах.

## <a name="unprototyped-functions"></a>Функции без прототипа

Для функций, для которых нет полного прототипа, вызывающий объект передает целочисленные значения как целые числа, а числа с плавающей запятой — в виде чисел двойной точности. Для значений с плавающей запятой как регистр целых чисел, так и регистр чисел с плавающей запятой содержат значение с плавающей запятой, если вызываемый объект ожидает значение в целочисленных регистрах.

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>Возвращаемые значения

Скалярное возвращаемое значение не больше 64 битов возвращается посредством RAX (сюда входят типы __m64). Нескалярные типы, включая типы с плавающей точкой, тип Double и векторные типы, такие как [__m128](../cpp/m128.md), [__m128i](../cpp/m128i.md), [__m128d](../cpp/m128d.md), возвращаются в XMM0. Состояние неиспользуемых битов в возвращаемом значении в RAX или XMM0 не определяется.

Определенные пользователем типы можно вернуть из глобальных функций и статических функций-членов по значению. Чтобы вернуть определяемый пользователем тип по значению в RAX, он должен иметь длину 1, 2, 4, 8, 16, 32 или 64 бита. В нем также должны отсутствовать заданные пользователем конструктор, деструктор или оператор назначения копирования; без частных или защищенных нестатических данных-членов; без нестатических данных-членов ссылочного типа; без базовых классов; без виртуальных функций и без данных-членов, которые также не соответствуют этим требованиям. (Фактически это — определение типа C ++ 03 POD. Поскольку определение изменилось в стандарте C ++ 11, не рекомендуется использовать `std::is_pod` для этого теста.) В противном случае вызывающий объект берет на себя ответственность за выделение памяти и передачу указателя для возвращаемого значения в качестве первого аргумента. Последующие аргументы затем перемещаются на один аргумент вправо. Тот же указатель должен быть возвращен вызываемой стороной в RAX.

В приведенных ниже примерах показан способ передачи параметров и возвращаемых значений для функций с указанными объявлениями.

### <a name="example-of-return-value-1---64-bit-result"></a>Пример возвращаемого значения 1 — результат в 64 бита

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>Пример возвращаемого значения 2 — результат в 128 бит

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>Пример возвращаемого значения 3 — результат пользовательского типа по указателю

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>Пример возвращаемого значения 4 — результат пользовательского типа по значению

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>Сохраняемые регистры вызываемого и вызывающего объектов

Регистры RAX, RCX, RDX, R8, R9, R10, R11, XMM0-5 и верхние части YMM0-15 и ZMM0-15 рассматриваются как изменяемые и должны считаться уничтоженными при вызовах функций (если иное не обеспечивается защитой при анализе, например при оптимизации всей программы). В AVX512VL регистры ZMM, YMM и XMM 16-31 являются изменяемыми.

Регистры RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15 и XMM6-15 считаются неизменяемыми и должны быть сохранены и восстановлены с помощью функции, которая их использует.

## <a name="function-pointers"></a>Указатели функций

Указатели функций — это просто указатели на метку соответствующей функции. Для указателей функций не предусмотрены требования к содержанию (TOC).

## <a name="floating-point-support-for-older-code"></a>Поддержка чисел с плавающей запятой для устаревшего кода

Регистры MMX и стека с плавающей запятой (MM0-MM7/ST0-ST7) сохраняются во всех переключениях контекста. Для этих регистров не предусмотрено явное соглашение о вызовах. Использование этих регистров строго запрещено в коде режима ядра.

## <a name="fpcsr"></a>FpCsr

Состояние регистра также включает управляющее слово x87 FPU. Соглашение о вызовах определяет, что регистр является неизменяемым.

Регистр управляющего слова x87 FPU задается со следующими стандартными значениями в начале выполнения программы:

| Регистр\[биты] | Параметр |
|-|-|
| FPCSR\[0:6] | Маски исключений все 1 (все исключения маскированы) |
| FPCSR\[7] | Зарезервировано — 0 |
| FPCSR\[8:9] | Управление точностью — 10B (двойная точность) |
| FPCSR\[10:11] | Управление округлением — 0 (округление до ближайшего числа) |
| FPCSR\[12] | Управление бесконечностью — 0 (не используется) |

Вызываемый объект, который изменяет любое из полей в FPCSR, должен восстановить их перед возвратом в вызывающий объект. Кроме того, вызывающий объект, который изменил любое из этих полей, должен восстановить их стандартные значения перед вызовом вызываемого объекта, если только по соглашению вызываемый объект не требует измененных значений.

Существует два исключения из правил, связанных с постоянством управляющих флагов:

1. В функциях, где документированная цель заданной функции заключается в изменении неизменяемых флагов FpCsr.

1. Если доказуемо корректно, что нарушение этих правил приводит к тому, что программа выполняется так же, как и программа, в которой эти правила не нарушаются (например, с помощью анализа всей программы).

## <a name="mxcsr"></a>Регистр MxCsr

Состояние регистра также включает MxCsr. Соглашение о вызовах делит этот регистр на изменяемую часть и неизменяемую часть. Изменяемая часть состоит из шести флагов состояния в MXCSR\[0:5], а остальная часть регистра, MXCSR\[6:15], считается неизменяемой.

Неизменяемая часть задается со следующими стандартными значениями в начале выполнения программы:

| Регистр\[биты] | Параметр |
|-|-|
| MXCSR\[6] | Денормализованные числа равны нулю — 0 |
| MXCSR\[7:12] | Маски исключений все 1 (все исключения маскированы) |
| MXCSR\[13:14] | Управление округлением — 0 (округление до ближайшего числа) |
| MXCSR\[15] | Сброс до нуля для маскирования неточного значения — 0 (отключено) |

Вызываемый объект, который изменяет любое из неизменяемых полей в MXCSR, должен восстановить их перед возвратом в вызывающий объект. Кроме того, вызывающий объект, который изменил любое из этих полей, должен восстановить их стандартные значения перед вызовом вызываемого объекта, если только по соглашению вызываемый объект не требует измененных значений.

Существует два исключения из правил, связанных с постоянством управляющих флагов:

- В функциях, где документированная цель заданной функции заключается в изменении неизменяемых флагов MxCsr.

- Если доказуемо корректно, что нарушение этих правил приводит к тому, что программа выполняется так же, как и программа, в которой эти правила не нарушаются (например, с помощью анализа всей программы).

Никакие допущения не могут быть сделаны относительно состояния изменяемой части MXCSR в границах функции, кроме случаев, особо описанных в документации по функции.

## <a name="setjmplongjmp"></a>setjmp/longjmp

При включении setjmpex.h или setjmp.h все вызовы [setjmp](../c-runtime-library/reference/setjmp.md) или [longjmp](../c-runtime-library/reference/longjmp.md) приводят к раскрутке, вызывающей деструкторы и вызовы `__finally`.  Это поведение отличается от x86, где включение setjmp.h приводит к невозможности вызова предложений `__finally` и деструкторов.

Вызов `setjmp` сохраняет текущий указатель стека, неизменяемые регистры и регистры MxCsr.  Вызовы `longjmp` возвращают к последнему месту вызова `setjmp` и сбрасывают указатель стека, непостоянные регистры и регистры MxCsr назад в состояние, сохраненное последним вызовом `setjmp`.

## <a name="see-also"></a>См. также

[Программные соглашения для 64-разрядных систем](../build/x64-software-conventions.md)
