---
title: Рекомендации по оптимизации
ms.date: 05/06/2019
helpviewer_keywords:
- C++, optimization
- optimization, best practices
ms.assetid: f3433148-7255-4ca6-8a4f-7c31aac88508
ms.openlocfilehash: 42178f8326def78f37bfcc905b96f37c7fc3affc
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/07/2019
ms.locfileid: "65220266"
---
# <a name="optimization-best-practices"></a>Рекомендации по оптимизации

В этом документе описаны рекомендации по оптимизации C++ программ в Visual Studio.

## <a name="compiler-and-linker-options"></a>Параметры компилятора и компоновщика

### <a name="profile-guided-optimization"></a>Профильная оптимизация

Visual Studio поддерживает *профильной оптимизации* (PGO). Эта оптимизация использует данные профиля из выполнений обучения инструментированной версии приложения для более поздних оптимизации приложения. С помощью PGO может занять много времени, поэтому оно не может быть то, что каждый разработчик использует, но мы рекомендуем использовать профильной Оптимизации для сборки окончательной версии продукта. Дополнительные сведения см. в разделе [профильной оптимизации](profile-guided-optimizations.md).

Кроме того *оптимизация всей программы* (также известная как создание кода во время компоновки) и **/O1** и **/O2** оптимизации были улучшены. Как правило приложение, скомпилированное с помощью одного из этих параметров будет быстрее, чем же приложение, скомпилированное с помощью более ранней версии компилятора.

Дополнительные сведения см. в разделе [/GL (оптимизация всей программы)](reference/gl-whole-program-optimization.md) и [/O1, / O2 (минимизировать размер, максимизировать скорость)](reference/o1-o2-minimize-size-maximize-speed.md).

### <a name="which-level-of-optimization-to-use"></a>Уровень оптимизации для использования

Если это возможно окончательной сборки компилироваться с оптимизация, зависимая от профиля. Если это не позволяет создавать с помощью PGO, ли из-за недостаточности инфраструктуры для запуска инструментированных построений или отсутствие доступа к сценариям, рекомендуется выполнить построение оптимизация всей программы.

**/Gy** коммутатор также является очень полезным. Он создает отдельный COMDAT для каждой функции, предоставляя компоновщику большую гибкость, когда дело доходит до удаления элементов COMDAT и COMDAT свертывание. Единственным недостатком использования **/Gy** — что он может вызвать проблемы при отладке. Таким образом обычно рекомендуется использовать его. Дополнительные сведения см. в разделе [/Gy (включение компоновки на уровне функций)](reference/gy-enable-function-level-linking.md).

Для компоновки в 64-разрядной среде рекомендуется использовать **предотвратят, ICF** параметр компоновщика и в 32-разрядных сред, **предотвратят** рекомендуется. Дополнительные сведения см. в разделе [/OPT (оптимизации)](reference/opt-optimizations.md).

Также настоятельно рекомендуется создавать отладочные символы, даже с помощью оптимизированных окончательных сборок. Он не влияет на созданного кода, и он значительно упрощает отладку приложений, при необходимости.

### <a name="floating-point-switches"></a>Коммутаторы с плавающей запятой

**/Op** удален параметр компилятора, и были добавлены следующие четыре параметры компилятора, работе с плавающей запятой точки оптимизации:

|||
|-|-|
|**/ fp: точное**|Это параметр по умолчанию и должны использоваться в большинстве случаев.|
|**/fp:fast**|Рекомендуется использовать, если производительность является важнейшим приоритетом, например в играх. Это приведет наибольшую производительность.|
|**/ fp: strict**|Рекомендуемые if точные исключения с плавающей запятой и IEEE требуемого поведения. Это приведет самую низкую производительность.|
|**/ fp: except [-]**|Можно использовать в сочетании с **/fp: strict** или **/fp: точное**, но не **/fp:fast**.|

Дополнительные сведения см. в разделе [/fp (определение поведения с плавающей запятой)](reference/fp-specify-floating-point-behavior.md).

## <a name="optimization-declspecs"></a>Оптимизация спецификаций объявлений

В этом разделе мы рассмотрим две спецификации объявлений, которые могут использоваться в программах для повышения производительности: `__declspec(restrict)` и `__declspec(noalias)`.

`restrict` Declspec может применяться только к объявлениям функций, которые возвращают указатель, такие как `__declspec(restrict) void *malloc(size_t size);`

`restrict` Declspec используется применительно к функциям, возвращающим указатели. Это ключевое слово используется для реализации библиотеки времени выполнения C `malloc` поскольку она никогда не возвращает значение указателя, уже используется в текущей программе (Если вы выполняете недопустимое действие, например использование памяти после ее освобождения).

`restrict` Declspec предоставляет компилятору больше сведений для выполнения оптимизации компилятора. Один из самых сложных задач для компилятора, чтобы определить, какой псевдоним указатели других указателей, они используют помогают компилятор.

Стоит, что это Обещание компилятору, то, что компилятор проверяет. Если программа использует это `restrict` declspec неправильно, программа может наблюдаться неправильная работа.

Дополнительные сведения см. в разделе [ограничить](../cpp/restrict.md).

`noalias` Declspec также применяется только к функциям и указывает, что функция является функция. Функция — это приложения, ссылающийся на или изменяет только локальные переменные, аргументы и косвенные обращения первого уровня аргументов. Declspec полагается на компилятор, и если она ссылается на глобальные переменные или косвенные обращения второго уровня аргументы указателя, а затем компилятор может генерировать код, приводит к сбою приложения.

Дополнительные сведения см. в разделе [noalias](../cpp/noalias.md).

## <a name="optimization-pragmas"></a>Оптимизация директив pragma

Существуют также несколько прагм помогает оптимизировать код. Первый из них мы обсудим — `#pragma optimize`:

```cpp
#pragma optimize("{opt-list}", on | off)
```

Эта директива #pragma позволяет задать определенный уровень оптимизации на основе функции, функции. Это идеальный вариант для редких случаях, где приложение аварийно завершает работу при компиляции с оптимизацией данной функции. Чтобы отключить оптимизацию для отдельной функции можно использовать следующее:

```cpp
#pragma optimize("", off)
int myFunc() {...}
#pragma optimize("", on)
```

Дополнительные сведения см. в разделе [оптимизировать](../preprocessor/optimize.md).

Встраивание является одним из наиболее важных оптимизаций, которые компилятор выполняет и здесь мы поговорим о директив pragma, чтобы изменить это поведение.

`#pragma inline_recursion` можно использовать для задания, требуется ли приложению встраивать рекурсивный вызов. По умолчанию оно отключено. Для неполной рекурсии малозначимые функции можно включить этот параметр. Дополнительные сведения см. в разделе [inline_recursion](../preprocessor/inline-recursion.md).

Другой полезной прагмой для ограничения глубины встраивания является `#pragma inline_depth`. Обычно это полезно в ситуациях, где вы пытаетесь ограничить размер программы или функции. Дополнительные сведения см. в разделе [inline_depth](../preprocessor/inline-depth.md).

## <a name="restrict-and-assume"></a>__restrict и \__assume

Существует несколько ключевых слов в Visual Studio, это может повысить производительность: [__restrict](../cpp/extension-restrict.md) и [__assume](../intrinsics/assume.md).

Во-первых, следует отметить, что `__restrict` и `__declspec(restrict)` — это две разные вещи. Хотя они в некоторой степени взаимосвязаны, их семантика отличается. `__restrict` является квалификатором типа, таких как `const` или `volatile`, но только для типов указателей.

Указатель, который изменяется с `__restrict` называется *__restrict указатель*. __Restrict указатель является указателем, который может осуществляться только через \__restrict указатель. Другими словами, другой указатель не может использоваться для доступа к данным, на которые указывают \__restrict указатель.

`__restrict` может быть мощным средством для Microsoft C++ оптимизатора, но использовать с большой осторожностью. При неправильном, оптимизатор может выполнить оптимизацию, которая бы нарушить работу приложения.

`__restrict` Заменяет ключевое слово **/Oa** переключиться из предыдущих версий.

С помощью `__assume`, разработчик сообщает компилятору указание сделать предположение относительно значения некоторой переменной.

Например `__assume(a < 5);` означает, что в этой строке кода переменной `a` меньше 5. Опять же это Обещание компилятор. Если `a` является фактически 6 в программе, то поведение программы после оптимизации компилятор может отличаться от ожидаемого. `__assume` очень полезно до операторов switch и/или условного выражения.

Существуют некоторые ограничения на `__assume`. Во-первых, такие как `__restrict`, это только рекомендация, поэтому компилятор не бесплатные, игнорируйте его. Кроме того `__assume` в настоящее время работает только неравенству переменных относительно константы. Он не распространяет символьные неравенства, например, assume(a < b).

## <a name="intrinsic-support"></a>Встроенную поддержку

Встроенные функции, функция вызывает, где компилятор имеет внутренние сведения о вызове, а вместо вызова функции в библиотеке, создает код для этой функции. Файл заголовка \<intrin.h > содержит все доступные встроенные функции для каждого из поддерживаемых аппаратных платформах.

Встроенные функции предоставить программисту возможность углубленного код без использования сборки. Ниже перечислены некоторые преимущества использования встроенных функций:

- Код является более пригодным для переноса. Некоторые встроенные функции доступны на несколько архитектур ЦП.

- Код является более удобным для чтения, так как он написан на C/C++.

- Код получает преимущества оптимизации компилятора. Как компилятора улучшается, улучшает создание кода для встроенных функций.

Дополнительные сведения см. в разделе [встроенные объекты компилятора](../intrinsics/compiler-intrinsics.md).

## <a name="exceptions"></a>Исключения

Производительности попаданий, связанные с использованием исключения. Существует несколько ограничений использования блоков try, которые не позволяют компилятору выполнять определенные оптимизации. На x86 платформы, которые снижения производительности из блоки "try" из-за дополнительную информацию о состоянии, должен быть создан во время выполнения кода. На 64-разрядных платформах, попробуйте блоки не снижают производительность настолько, но как только создается исключение, могут потреблять процесс поиск обработчика и очистки стека.

Таким образом рекомендуется во избежание внесения блоки try/catch в код, который без необходимости его. Если необходимо использовать исключения, по возможности используйте синхронных исключений. Дополнительные сведения см. в разделе [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md).

Исключения следует вызывать только в исключительных случаях. Использование исключений для общего потока управления скорее всего сделает к снижению производительности.

## <a name="see-also"></a>См. также

- [Оптимизация кода](optimizing-your-code.md)
