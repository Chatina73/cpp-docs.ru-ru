---
title: Рекомендации по оптимизации
ms.date: 05/06/2019
helpviewer_keywords:
- C++, optimization
- optimization, best practices
ms.assetid: f3433148-7255-4ca6-8a4f-7c31aac88508
ms.openlocfilehash: 541114b4cbf7d3d063e48b50ab265b4c95c6237c
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328453"
---
# <a name="optimization-best-practices"></a>Рекомендации по оптимизации

В этом документе описаны некоторые рекомендации по оптимизации программ СЗ в Visual Studio.

## <a name="compiler-and-linker-options"></a>Варианты компилятора и связующим

### <a name="profile-guided-optimization"></a>Оптимизация с профилем

Visual Studio поддерживает *оптимизацию профиля* (PGO). Эта оптимизация использует данные профиля из обучающие исполнения инструментальной версии приложения для последующей оптимизации приложения. Использование PGO может занять много времени, поэтому может быть не то, что каждый разработчик использует, но мы рекомендуем использовать PGO для окончательного выпуска сборки продукта. Дополнительные сведения см. в статье [Профильные оптимизации](profile-guided-optimizations.md).

Кроме того, была улучшена *оптимизация всей программы* (также известна как поколение кода времени ссылки) и оптимизация **/O1** и **/O2.** Как правило, приложение, составленное с одним из этих параметров, будет быстрее, чем то же приложение, составленное с более ранним компилятором.

Для получения дополнительной информации [см. /GL (Оптимизация программы)](reference/gl-whole-program-optimization.md) и [/O1, /O2 (Минимный размер, максимальная скорость).](reference/o1-o2-minimize-size-maximize-speed.md)

### <a name="which-level-of-optimization-to-use"></a>Какой уровень оптимизации использовать

Если это вообще возможно, окончательные сборки релиза должны быть составлены с помощью оптимизации профилей. Если невозможно построить с помощью PGO, будь то из-за недостаточной инфраструктуры для запуска инструментированных сборок или не имеющих доступа к сценариям, то мы предлагаем строить с помощью оптимизации всей программы.

**/Gy** переключатель также очень полезно. Он генерирует отдельный COMDAT для каждой функции, давая связующего большую гибкость, когда дело доходит до удаления неупомянутых COMDATs и COMDAT складывания. Единственным недостатком использования **/Gy** является то, что это может вызвать проблемы при отладке. Поэтому, как правило, рекомендуется использовать его. Дополнительные сведения см. в разделе [/Gy (включение компоновки на уровне функций)](reference/gy-enable-function-level-linking.md).

Для ссылок в 64-битных средах рекомендуется использовать **опцию /OPT:REF, iCF** linker, а также в 32-битных средах/OPT:REF. **/OPT:REF** Для получения дополнительной информации [см./ OPT (Оптимизация)](reference/opt-optimizations.md).

Также настоятельно рекомендуется создавать символы отладки, даже при оптимизированных сборках релизов. Это не влияет на сгенерированный код, и это делает его намного легче отладить приложение, если это необходимо.

### <a name="floating-point-switches"></a>Переключатели плавающей точки

Опция компилятора **/Op** была удалена, и добавлены следующие четыре варианта компилятора, связанные с оптимизацией плавающей точки:

|||
|-|-|
|**/fp:точный**|Это рекомендация по умолчанию и должна использоваться в большинстве случаев.|
|**/fp:быстрый**|Рекомендуется, если производительность имеет первостепенное значение, например, в играх. Это приведет к самой быстрой производительности.|
|**/fp:строгий**|Рекомендуется, если точные исключения плавающей точки и поведение IEEE желательно. Это приведет к самой низкой производительности.|
|**/fp:за исключением**|Может быть использован в сочетании с **/fp:строгий** или **/fp:точный,** но не **/fp:fast**.|

Дополнительные сведения см. в разделе [/fp (определение поведения с плавающей запятой)](reference/fp-specify-floating-point-behavior.md).

## <a name="optimization-declspecs"></a>Оптимизация declspecs

В этом разделе мы рассмотрим два declspecs, которые могут `__declspec(restrict)` `__declspec(noalias)`быть использованы в программах, чтобы помочь производительности: и .

Declspec `restrict` может применяться только для функциональных деклараций, которые возвращают указатель, такие как`__declspec(restrict) void *malloc(size_t size);`

Declspec `restrict` используется на функции, которые возвращают неалиазированные указатели. Это ключевое слово используется для реализации `malloc` C-Runtime Library, так как оно никогда не вернет значение указателя, которое уже используется в текущей программе (если вы не делаете что-то незаконное, например, используя память после ее освобождения).

Declspec `restrict` дает компилятору больше информации для выполнения оптимизации компилятора. Одна из самых трудных вещей для компилятора, чтобы определить, какие указатели псевдоним других указателей, и использование этой информации в значительной степени помогает компилятору.

Стоит отметить, что это обещание компилятора, а не то, что компилятор будет проверять. Если ваша программа `restrict` использует этот declspec ненадлежащим образом, ваша программа может иметь неправильное поведение.

Для получения дополнительной информации [см.](../cpp/restrict.md)

Declspec `noalias` также применяется только к функциям, и указывает, что функция является получистой функцией. Получистая функция — это функция, которая ссылается или изменяет только местных жителей, аргументы и на первом уровне ненаправления аргументов. Это declspec является обещанием компилятора, и если функция ссылается на глобальные или второго уровня indirections аргументов указателя, то компилятор может генерировать код, который нарушает приложение.

Дополнительные сведения см. в разделе [noalias](../cpp/noalias.md).

## <a name="optimization-pragmas"></a>Оптимизация прагмы

Есть также несколько полезных прагм, помогающих оптимизировать код. Первый из них мы `#pragma optimize`будем обсуждать это:

```cpp
#pragma optimize("{opt-list}", on | off)
```

Эта прагма позволяет установить данный уровень оптимизации на функциональной основе. Это идеально подходит для тех редких случаев, когда ваше приложение выходит из строя, когда данная функция компилируется с помощью оптимизации. Это можно использовать для выключения оптимизации для одной функции:

```cpp
#pragma optimize("", off)
int myFunc() {...}
#pragma optimize("", on)
```

Для получения дополнительной информации [см.](../preprocessor/optimize.md)

Inlining является одним из наиболее важных оптимизаций, что компилятор выполняет и здесь мы говорим о нескольких прагмей, которые помогают изменить это поведение.

`#pragma inline_recursion`полезно указать, хотите ли вы, чтобы приложение могло ввести рекурсивный вызов. По умолчанию он выключен. Для мелкой рекурсии небольших функций вы можете включить это. Для получения дополнительной информации см [inline_recursion.](../preprocessor/inline-recursion.md)

Еще одна полезная прагма для `#pragma inline_depth`ограничения глубины inlining является . Это обычно полезно в ситуациях, когда вы пытаетесь ограничить размер программы или функции. Для получения дополнительной информации см [inline_depth.](../preprocessor/inline-depth.md)

## <a name="__restrict-and-__assume"></a>__restrict \_и _assume

Есть несколько ключевых слов в Visual Studio, которые могут помочь производительности: [__restrict](../cpp/extension-restrict.md) и [__assume](../intrinsics/assume.md).

Во-первых, следует `__restrict` отметить, что и `__declspec(restrict)` две разные вещи. Хотя они несколько связаны, их семантика отличается. `__restrict`является тип квалификатор, как `const` или `volatile`, но исключительно для типов указателей.

Указатель, который модифицируется с `__restrict` называется *указателем __restrict.* Указатель __restrict — это указатель, к которым \_можно получить доступ только через указатель _restrict. Другими словами, другой указатель не может быть \_использован для доступа к данным, указанным указателем _restrict.

`__restrict`может быть мощным инструментом для оптимизатора Microsoft C, но использовать его с большой осторожностью. При неправильном использовании оптимизатор может выполнить оптимизацию, которая нарушит приложение.

Ключевое `__restrict` слово заменяет **/Oa** переключатель от предыдущих версий.

С `__assume`помощью , разработчик может сказать компилятор, чтобы сделать предположения о значении некоторых переменных.

Например, `__assume(a < 5);` оптимизатор говорит, что `a` в этой строке кода переменная меньше 5. Опять же это обещание компилятора. Если `a` на самом деле 6 на данный момент в программе, то поведение программы после оптимизации компилятора может быть не то, что вы ожидаете. `__assume`наиболее полезно перед переключением инструкций и/или условных выражений.

Есть некоторые ограничения `__assume`на . Во-первых, как, `__restrict`это только предложение, так что компилятор может игнорировать его. Кроме `__assume` того, в настоящее время работает только с переменным неравенством против констант. Он не пропагандирует символическое неравенство, например, предполагают (< б).

## <a name="intrinsic-support"></a>Внутренняя поддержка

Внутренности — это вызовы функций, когда компилятор обладает неотъемлемыми знаниями о вызове, и вместо вызова функции в библиотеке он излучает код для этой функции. Файл заголовка \<intrin.h> содержит все доступные внутренностя для каждой из поддерживаемых аппаратных платформ.

Внутренности дают программисту возможность углубиться в код без использования сборки. Есть несколько преимуществ использования внутренней присущей:

- Ваш код более портативный. Некоторые из внутреннозависимостей доступны на нескольких архитектурах процессора.

- Ваш код легче читать, так как код по-прежнему написан в C/C.

- Ваш код получает преимущество оптимизации компилятора. По мере улучшения составителя улучшается генерация кода для внутренностих.

Для получения дополнительной [информации, см.](../intrinsics/compiler-intrinsics.md)

## <a name="exceptions"></a>Исключения

Существует хит производительности, связанный с использованием исключений. Некоторые ограничения вводятся при использовании блоков try, которые мешают компилятору выполнять определенные оптимизации. На платформах x86 происходит дополнительная деградация производительности от блоков try из-за дополнительной информации о состоянии, которая должна быть сгенерирована во время выполнения кода. На 64-битных платформах попробуйте блоки не ухудшают производительность так сильно, но как только исключение будет брошено, процесс поиска обработчика и раскручивания стека может быть дорогим.

Поэтому рекомендуется избегать введения блоков try/catch в код, который действительно не нужен. Если необходимо использовать исключения, если это возможно, используйте синхронные исключения. Дополнительные сведения см. в разделе [Structured Exception Handling (C/C++)](../cpp/structured-exception-handling-c-cpp.md).

Наконец, бросать исключения только для исключительных случаев. Использование исключений для общего потока управления, скорее всего, приведет к постраданию производительности.

## <a name="see-also"></a>См. также раздел

- [Оптимизация кода](optimizing-your-code.md)
