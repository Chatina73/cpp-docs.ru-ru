---
title: Обработка исключений ARM
ms.date: 07/11/2018
ms.assetid: fe0e615f-c033-4ad5-97f4-ff96af45b201
ms.openlocfilehash: 4bdf0c88f0c2fe445f3a8865353ca1259ba586fa
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81323221"
---
# <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows на ARM использует один механизм структурированной обработки исключений для асинхронных аппаратных и синхронных программных исключений. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. В этом документе описывается обработка исключений в Windows на ARM, а также языковые помощники, используемые кодом, генерируемым сборщиком Microsoft ARM и компилятором MSVC.

## <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows на ARM использует *коды раскручивания* для управления раскручиванием стека во время [структурированной обработки исключений](/windows/win32/debug/structured-exception-handling) (SEH). Коды очистки представляют собой последовательность байт, хранимых в разделе .XDATA исполняемого образа. Они описывают работу пролога функции и кода эпилога абстрактно, так что эффекты пролога функции могут быть отменены в рамках подготовки к раскручиванию стека кадра вызывающего абонента.

Встроенный двоичный интерфейс приложения ARM EABI задает модель очистки исключения, использующую коды очистки, однако SEH этого недостаточно для выполнения очистки в Windows, так как требуется обрабатывать асинхронные случаи, когда процессор находится в середине пролога или эпилога функции. Windows также разделяет управление очисткой на очистку функционального уровня и очистку языковой области, которая унифицирована в ARM EABI. По этим причинам Windows на ARM указывает больше сведений о данных и процедуре очистки.

### <a name="assumptions"></a>Предположения

Исполняемые образы для Windows на ARM используют формат переносимого исполняемого файла (PE). Для получения дополнительной [Microsoft PE and COFF Specification](https://go.microsoft.com/fwlink/p/?linkid=84140)информации см. Информация об обработке исключений хранится в разделах .PDATA и .XDATA образа.

Механизм обработки исключений делает определенные предположения о коде, который соответствует двоичному интерфейсу приложения для Windows на ARM.

- Когда в теле функции происходит исключение, не имеет значения, отменяются ли операции пролога или операции эпилога выполняются вперед. Оба случая должны давать одинаковые результаты.

- Прологи и эпилоги стремятся зеркально отображать друг друга. Это можно использовать для сокращения объема метаданных, требуемых для описания очистки.

- Функции имеют относительно небольшой размер. На этом основано несколько оптимизаций для более эффективной упаковки данных.

- Если условие ставится в эпилоге, оно в равной степени применяется ко всем инструкциям эпилога.

- Если в прологе указатель стека (SP) сохраняется в другом регистре, этот регистр должен оставаться неизменным в течение всего времени работы функции, чтобы исходный указатель стека можно было получить в любое время.

- Если только указатель стека не сохранен в другом регистре, все операции с ним должны производиться исключительно в пределах пролога и эпилога.

- Для очистки кадра стека необходимо выполнить следующие операции.

  - Скорректируйте r13 (SP) с 4-байтными приращениями.

  - Извлеките один или несколько целочисленных регистров.

  - Извлеките один или несколько регистров VFP (виртуальные операции с плавающей запятой).

  - Скопируйте значение произвольного регистра в r13 (SP).

  - Загрузите указатель стека из стека с помощью небольшой постдекрементной операции.

  - Произведите анализ одного из нескольких четко заданных типов кадров.

### <a name="pdata-records"></a>Записи .PDATA

Записи .PDATA в образе формата PE представляют собой упорядоченный массив с элементами фиксированной длины, которые описывают каждую работающую со стеком функцию. Конечным функциям, которые не вызывают другие функции, записи .PDATA не требуются, если только они не работают со стеком. (Таким образом, им не требуется локальное хранилище и не нужно сохранять или восстанавливать неизменяемые регистры.) Для экономии места записи для таких функций в разделе .PDATA можно опускать. Операция очистки из одной из таких функций может просто скопировать адрес возврата из регистра связи (LR) в счетчик команд (PC) для перемещения к вызывающему объекту.

Каждая запись .PDATA для ARM имеет длину 8 байт. Общий формат записи имеет следующий вид: относительный виртуальный адрес (RVA) в начале функции в первом 32-битном слове, после которого идет второе слово с указателем на блок .XDATA переменной длины или упакованным словом, описывающим каноническую последовательность очистки функции, как показано в следующей таблице.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*Функция Start RVA* является 32-битной RVA начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0–1|*Флаг* — это 2-битное поле, которое показывает, как интерпретировать оставшиеся 30 бит второго слова .pdata. Если *флаг* равен 0, то оставшиеся биты образуют *RVA-информацию об исключении* (с низкими двумя битами неявно 0). Если *флаг* не является нулевым, то остальные биты образуют структуру *упакованных данных Раскручивания.*|
|1|2—31|*Информация об исключении RVA* или *упакованные данные раскручивания.*<br /><br /> *Информация об исключении RVA* — это адрес информационной структуры исключения с переменной длиной, хранящейся в разделе .xdata. Эти данные должны быть выровнены по 4-байтовой границе.<br /><br /> *Упакованные данные Unwind* Data — это сжатое описание операций, необходимых для раскручивания функции, предполагая каноническую форму. В этом случае запись .XDATA не требуется.|

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для функций, прологи и эпилоги которых соответствуют описанной ниже канонической форме, можно использовать упакованные данные очистки. Это устраняет потребность в записи .XDATA и значительно сокращает требования к месту для предоставления данных очистки. Канонические прологи и эпилоги предназначены для удовлетворения общих требований простой функции, которая не требует обработчика событий и выполняет операции настройки и удаления в стандартном порядке.

В этой таблице показан формат записи .PDATA, содержащей упакованные данные очистки.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*Функция Start RVA* является 32-битной RVA начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0–1|*Флаг* представляет собой 2-битное поле, которое имеет следующие значения:<br /><br />- 00 - упакованные данные раскручивания не используются; остальные биты указывают на запись .xdata.<br />- 01 - упакованные данные раскручивания.<br />- 10 - упакованные данные раскручивания, где функция, как предполагается, не имеет пролога. Это удобно для описания фрагментов функции, которые разобщены с началом функции.<br />- 11 - зарезервировано.|
|1|2—12|*Длина функции* представляет собой 11-битное поле, которое обеспечивает длину всей функции в байтах, разделенных на 2. Если размер функции больше 4 КБ, следует использовать полную запись .XDATA.|
|1|13—14|*Ret* — это 2-битное поле, которое показывает, как возвращается функция:<br /><br />- 00 - возврат через поп-шт» (бит *флага L* должен быть установлен на 1 в этом случае).<br />- 01 - возвращение с помощью 16-битной ветви.<br />- 10 - возвращение с помощью 32-битной ветви.<br />- 11 - нет эпилога вообще. Это удобно для описания разобщенного фрагмента функции, который может содержать только пролог, однако его эпилог находится в другом месте.|
|1|15|*H* представляет собой 1-битный флаг, который указывает, регистрирует ли функция «дома» рядовые регистры параметров (r0-r3), нажав на них в начале функции, и раздевливает 16 байтов стека перед возвращением. (0 = не помещает в начальное расположение, 1 = помещает в начальное расположение.)|
|1|16—18|*Reg* — это 3-битное поле, указывающее на индекс последнего сохраненного нелетучого регистра. Если *R* бит 0, то сохраняются только целые регистры, и предполагается, что он находится в диапазоне r4-rN, где N равен 4 *reg*. Если *R* бит составляет 1, то сохраняются только плавающие точки регистров, и предполагается, что в диапазоне d8-dN, где N равен 8 *reg*. Специальная комбинация *R* No 1 и *Reg* No 7 указывает на то, что регистры не сохраняются.|
|1|19|*R* — это 1-битный флаг, указывающий на то, являются ли сохраненные нелетучие регистры едиными регистрами (0) или регистрами плавающей точки (1). Если *R* установлен на 1 и поле *Reg* установлено до 7, не было включено регистров.|
|1|20|*L* представляет собой 1-битный флаг, указывающий на то, сохраняет ли функция/восстанавливает LR, наряду с другими регистрами, указанными полем *Reg.* (0 = не сохраняет/восстанавливает, 1 = сохраняет/восстанавливает.)|
|1|21|*C* представляет собой 1-битный флаг, который указывает, включает ли функция дополнительные инструкции по настройке цепочки кадров для быстрой ходьбы стека (1) или нет (0). Если этот бит задан, r11 неявно добавляется в список сохраняемых неизменяемых регистров для целочисленных операций. (См. ограничения ниже, если используется флаг *C.)*|
|1|22—31|*Stack Adjust* — это 10-битное поле, которое указывает количество байтов стека, которые выделены для этой функции, разделенного на 4. Однако напрямую возможно кодирование лишь значений из диапазона 0x000—0x3F3. Функции, выделяющие более 4044 байт стека, должны использовать полную запись .XDATA. Если поле *Stack Adjust* 0x3F4 или больше, то низкие 4 бита имеют особое значение:<br /><br />- Биты 0-1 указывают количество слов корректировки стека (1-4) минус 1.<br />- Бит 2 устанавливается на 1, если пролог объединил эту корректировку в свою операцию нажатия.<br />- Бит 3 установлен на 1, если эпилог объединил эту корректировку в свою поп-операцию.|

В связи с возможным дублированием в описанном выше кодировании применяются следующие ограничения.

- Если флаг *C* установлен на 1:

  - Флаг *L* также должен быть установлен на 1, потому что цепочка рамы требуется как r11, так и LR.

  - r11 не должны быть включены в набор регистров, описанных *Reg*. То есть, если r4-r11 толкают, *Reg* следует описать только r4-r10, потому что флаг *C* подразумевает r11.

- Если поле *Ret* настроено на 0, флаг *L* должен быть установлен на 1.

Нарушение этих ограничений ведет к неподдерживаемой последовательности операций.

Для целей обсуждения ниже, два псевдофлага являются производными от *Стек Adjust*:

- *PF* или "сворачивание пролога" указывает на то, что *Stack Adjust* 0x3F4 или больше, и бит 2 установлен.

- *EF* или "эпилог складывания" указывает на то, что *стек Adjust* 0x3F4 или больше и бит 3 установлен.

Прологи для канонических функций могут иметь до 5 инструкций (обратите внимание, что 3а и 3б являются взаимоисключающими).

|Инструкция|Предполагается наличие кода операции, если|Размер|Код операции|Коды очистки|
|-----------------|-----------------------------------|----------|------------|------------------|
|1|*H*No 1|16|`push {r0-r3}`|04|
|2|*C*No 1 или *L*No 1 или *R*No0 или ПФЗ1|16/32|`push {registers}`|80—BF/D0—DF/EC—ED|
|3а|*C*No 1 и *(L*No 0 и *R*No 1 и ПФЗ0)|16|`mov r11,sp`|C0—CF/FB|
|3б|*C*No 1 и *(L*No 1 или *R*0 или ПФЗ 1)|32|`add r11,sp,#xx`|FC|
|4|*R*No 1 и *Reg* ! 7|32|`vpush {d8-dE}`|E0—E7|
|5|*Стек Отрегулируйте* ! » 0 и ПФЗ 0|16/32|`sub sp,sp,#xx`|00—7F/E8—EB|

Инструкция 1 всегда присутствует, если *H* бит установлен на 1.

Для настройки каркасной цепочки, либо инструкция 3a или 3b присутствует, если *c* bit установлен. Это 16-разрядная `mov`, если отправляются только регистры r11 и LR; в противном случае это 32-разрядная `add`.

Если указана подстройка без свертывания, инструкция 5 является явной подстройкой стека.

Инструкции 2 и 4 задаются с учетом того, требуется ли отправка. В этой таблице кратко излагаются, какие регистры сохраняются на основе полей *C,* *L,* *R*и *PF.* Во всех случаях *N* равен *Регу* No 4, *E* равен *Регу* No 8, а *S* равен (стек*Adjust)*& 3.

|C|L|R|PF|Отправленные целочисленные регистры|Отправленные регистры VFP|
|-------|-------|-------|--------|------------------------------|--------------------------|
|0|0|0|0|r4-r*N*|Нет|
|0|0|0|1|r*S-r**N*|Нет|
|0|0|1|0|Нет|d8-d*E*|
|0|0|1|1|r*S*-r3|d8-d*E*|
|0|1|0|0|r4-r*N*, LR|Нет|
|0|1|0|1|r*S*-r*N*, LR|Нет|
|0|1|1|0|LR|d8-d*E*|
|0|1|1|1|r*S*-r3, LR|d8-d*E*|
|1|0|0|0|r4-r*N*, r11|Нет|
|1|0|0|1|r*S*-r*N*, r11|Нет|
|1|0|1|0|r11|d8-d*E*|
|1|0|1|1|r*S*-r3, r11|d8-d*E*|
|1|1|0|0|r4-r*N*, r11, LR|Нет|
|1|1|0|1|r*S*-r*N*, r11, LR|Нет|
|1|1|1|0|r11, LR|d8-d*E*|
|1|1|1|1|r*S*-r3, r11, LR|d8-d*E*|

Эпилоги для канонических функций имеют аналогичную форму, однако с обратным порядком и дополнительными параметрами. Эпилог может иметь длину до 5 инструкций, а его форма жестко определяется формой пролога.

|Инструкция|Предполагается наличие кода операции, если|Размер|Код операции|
|-----------------|-----------------------------------|----------|------------|
|6|*Стек Отрегулируйте*! *EF*|16/32|`add   sp,sp,#xx`|
|7|*R*No 1 и *Рег*!|32|`vpop  {d8-dE}`|
|8|*C*No 1 или *(L*No 1 и *H*No0) или *R*Q0 или *EF*No 1|16/32|`pop   {registers}`|
|9а|*H*No 1 и *L*No 0|16|`add   sp,sp,#0x10`|
|9б|*H*No 1 и *L*No 1|32|`ldr   pc,[sp],#0x14`|
|10а|*В рет*No 1|16|`bx    reg`|
|10б|*В рет*No 2|32|`b     address`|

Инструкция 6 является явной подстройкой стека, если указана подстройка без свертывания. Поскольку *PF* не зависит от *EF,* можно иметь инструкцию 5, присутствующей без инструкции 6, или наоборот.

Инструкции 7 и 8 используют ту же логику, что и пролог, чтобы определить, какие регистры восстанавливаются из стека, но с этими двумя изменениями: во-первых, *EF* используется вместо *PF*; во-вторых, если *Ret* 0, то LR заменяется ПК в списке регистров и эпилог заканчивается немедленно.

Если *H* установлен, то либо инструкция 9a или 9b присутствует. Инструкция 9a используется, когда *L* 0, чтобы указать, что LR не находится на стеке. В этом случае стек корректируется вручную, а *Ret* должен быть 1 или 2, чтобы указать явный возврат. Инструкция 9b используется, когда *L* 1, чтобы указать ранний конец эпилога, и вернуться и настроить стек в то же время.

Если эпилог еще не закончился, то присутствует либо инструкция 10a или 10b, чтобы указать 16-битную или 32-битную ветвь, основанную на значении *Ret*.

### <a name="xdata-records"></a>Записи .XDATA

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись .XDATA переменной длины. Адрес этой записи хранится во втором слове записи .PDATA. Формат .XDATA представляет собой упакованный набор слов переменной длины, состоящий из четырех разделов.

1. Заголовок из 1 или 2 слов, описывающий общий размер структуры .XDATA и предоставляющий ключевые функциональные данные. Второе слово присутствует только в том случае, если поля *Epilogue Count* и *Code Words* настроены на 0. Эти поля описаны в следующей таблице.

   |Word|Bits|Цель|
   |----------|----------|-------------|
   |0|0—17|*Длина функции* представляет собой 18-битное поле, которое указывает общую длину функции в байтах, разделенных на 2. Если размер функции больше 512 КБ, для ее описания следует создать несколько записей .PDATA и .XDATA. Дополнительные сведения см. в разделе "Большие функции" настоящего документа.|
   |0|18—19|*Vers* — это 2-битное поле, описывая версию оставшейся xdata. Сейчас определена только версия 0; значения 1—3 зарезервированы.|
   |0|20|*X* — это поле объемом 1 бит, которое указывает на наличие (1) или отсутствие (0) данных об исключениях.|
   |0|21|*E* представляет собой поле объемом 1, которое указывает на то, что информация, описывающая один эпилог, упакована в заголовок (1), а не требует дополнительных слов области позже (0).|
   |0|22|*F* — это поле объемом 1, которое указывает на то, что эта запись описывает фрагмент функции (1) или полную функцию (0). Если указан фрагмент, пролог отсутствует, поэтому его обработку можно проигнорировать.|
   |0|23—27|*Epilogue Count* — это 5-битное поле, которое имеет два значения, в зависимости от состояния *бита E:*<br /><br /> - Если *E* 0, это поле представляет собой подсчет общего числа областей исключения, описанных в разделе 3. Если в функции существует более 31 области, то это поле и поле *Code Words* должны быть установлены на 0, чтобы указать, что требуется слово расширения.<br />- Если *E* 1, это поле определяет индекс первого раскручиваемого кода, который описывает единственный эпилог.|
   |0|28—31|*Code Words* — это 4-битное поле, которое определяет количество 32-битных слов, необходимых для содержания всех кодов раскручивания в разделе 4. Если для более чем 63 байтов кода для раскручивания требуется более 15 слов, это поле и поле *Epilogue Count* должны быть установлены на 0, чтобы указать, что требуется слово расширения.|
   |1|0-15|*Расширенный Epilogue Count* — это 16-битное поле, которое предоставляет больше пространства для кодирования необычно большого количества эпилогов. Слово расширения, содержащее это поле, присутствует только в том случае, если поля *Epilogue Count* и *Code Words* в первом слове заголовка настроены на 0.|
   |1|16—23|*Расширенный код Words* — это 8-битное поле, которое предоставляет больше места для кодирования необычно большого количества кодовых слов. Слово расширения, содержащее это поле, присутствует только в том случае, если поля *Epilogue Count* и *Code Words* в первом слове заголовка настроены на 0.|
   |1|24—31|Reserved|

1. После того, как данные об исключении (если *e* бит в заголовке был установлен на 0) представляет собой список информации об области эпилога, которые упакованы от одного к слову и хранятся в порядке увеличения стартового смещения. Каждая область содержит следующие поля.

   |Bits|Цель|
   |----------|-------------|
   |0—17|*Epilogue Start Offset* — это 18-битное поле, описывая смещение эпилога, в байтах, разделенных на 2, относительно начала функции.|
   |18—19|*Res* — это 2-битное поле, зарезервированное для будущего расширения. Оно должно иметь значение 0.|
   |20—23|*Состояние* представляет собой 4-битное поле, которое дает условие, при котором выполняется эпилог. Для безусловных эпилогов в нем следует задать значение 0xE, которое означает "всегда". (Эпилог должен быть полностью условным или полностью безусловным, а в режиме Thumb-2 эпилог начинается с первой инструкции после кода операции IT.)|
   |24—31|*Epilogue Start Index* — это 8-битное поле, указка которое указывает на индекс байта первого раскручиваемого кода, описывающий этот эпилог.|

1. После списка областей эпилога идет массив с кодами очистки, которые подробно описаны в разделе "Коды очистки" данной статьи. Этот массив дополняется в конец ближайшей границы полного слова. Байты хранятся с прямым порядком, чтобы их можно было напрямую получать в соответствующем режиме.

1. Если поле *X* в заголовке равен 1, за байтами срасвиной кода следует информация об обработчика исключений. Она состоит из одного *RVA Обработчика исключений,* который содержит адрес обработчика исключений, за которым сразу же следует (переменная длина) объем данных, требуемый обработчиком исключений.

Запись .XDATA спроектирована таким образом, что можно получить первые 8 байт и вычислить полный размер записи без учета размера последующих данных об исключении, имеющих переменную длину. Этот фрагмент кода вычисляет размер записи:

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogueScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 23) != 0) {
        Size = 4;
        EpilogueScopes = (Xdata[0] >> 23) & 0x1f;
        UnwindWords = (Xdata[0] >> 28) & 0x0f;
    } else {
        Size = 8;
        EpilogueScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    if (!(Xdata[0] & (1 << 21))) {
        Size += 4 * EpilogueScopes;
    }
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;
    }
    return Size;
}
```

Хотя пролог и каждый эпилог имеет индекс в коды раскручивания, таблица распределяется между ними. Довольно распространена ситуация, когда все они используют совместно одинаковые коды очистки. Мы рекомендуем разработчикам компилятора предусмотреть оптимизацию такого случая, так как самый большой индекс, который можно указать, равен 255, что ограничивает общее возможное число кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет собой пул последовательностей инструкций, описывающий, как устранить влияние пролога, и содержащий операции в порядке их отмены. Коды очистки представляют собой мининаборы инструкций, закодированные в виде строки байтов. После окончания выполнения адрес возврата в вызывающую функцию находится в регистре LR, а для всех неизменяемых регистров восстанавливаются значения, актуальные на момент вызова функции.

Если бы существовала уверенность в том, что исключения возникают только в теле функции и никогда не возникают в прологе или эпилоге, потребовалась бы всего одна последовательность очистки. Однако модель очистки Windows требует наличия возможности выполнения очистки из частично выполненного пролога или эпилога. Чтобы выполнить это требование, коды очистки были тщательно спроектированы для обеспечения однозначного сопоставления с каждым соответствующим кодом операции в прологе и эпилоге. Эта особенность имеет несколько разных применений.

- Можно вычислить длину пролога и эпилога, сосчитав число кодов очистки. Это возможно даже при инструкциях переменной длины в режиме Thumb-2, так как имеются четкие сопоставления для 16- и 32-разрядных кодов операций.

- Считая число инструкций после начала области эпилога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы завершить частично выполненную очистку, произведенную эпилогом.

- Считая число инструкций до окончания пролога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы отменить только те части пролога, выполнение которых завершилось.

В приведенной ниже таблице показано сопоставление кодов очистки с кодами операций. Наиболее распространены коды длиной в один байт, реже попадаются коды из двух, трех и даже четырех байт. Каждый код хранится от старшего байта к младшему. Структура кода очистки отличается от кодировки, описанной в стандартном встроенном двоичном интерфейсе приложения ARM, так как эти коды очистки рассчитаны на наличие однозначного сопоставления с кодами операций в прологе и эпилоге, что делает возможной очистку частично выполненных прологов и эпилогов.

|Байт 1|Байт 2|Байт 3|Байт 4|Размер операции|Объяснение|
|------------|------------|------------|------------|------------|-----------------|
|00—7F||||16|`add   sp,sp,#X`<br /><br /> где X (код & 0x7F) \* 4|
|80—BF|00—FF|||32|`pop   {r0-r12, lr}`<br /><br /> где LR выскочил, если код & 0x2000 и r0-r12 выскочил, если соответствующий бит установлен в коде & 0x1FFF|
|C0—CF||||16|`mov   sp,rX`<br /><br /> где X код & 0x0F|
|D0—D7||||16|`pop   {r4-rX,lr}`<br /><br /> где X (Код & 0x03) No 4 и LR выскочил, если код & 0x04|
|D8—DF||||32|`pop   {r4-rX,lr}`<br /><br /> где X является (код & 0x03) No 8 и LR выскочил, если код & 0x04|
|E0—E7||||32|`vpop  {d8-dX}`<br /><br /> где находится X (Код & 0x07)|
|E8—EB|00—FF|||32|`addw  sp,sp,#X`<br /><br /> где X (Код & 0x03FF) \* 4|
|EC—ED|00—FF|||16|`pop   {r0-r7,lr}`<br /><br /> где LR выскочил, если код & 0x0100 и r0-r7 выскочил, если соответствующий бит установлен в коде & 0x00FF|
|EE|00—0F|||16|Специально для систем Майкрософт|
|EE|10—FF|||16|Доступно|
|EF|00—0F|||32|`ldr   lr,[sp],#X`<br /><br /> где X (Код & 0x000F) \* 4|
|EF|10—FF|||32|Доступно|
|F0—F4||||-|Доступно|
|F5|00—FF|||32|`vpop  {dS-dE}`<br /><br /> где S (Код & 0x00F0) >> 4 и E код & 0x000F|
|F6|00—FF|||32|`vpop  {dS-dE}`<br /><br /> где S (Код & 0x00F0) >> 4) No 16 и E (Код & 0x000F)|
|F7|00—FF|00—FF||16|`add   sp,sp,#X`<br /><br /> где X (Код & 0x00FFFF) \* 4|
|F8|00—FF|00—FF|00—FF|16|`add   sp,sp,#X`<br /><br /> где X (Код & 0x00FFFF) \* 4|
|F9|00—FF|00—FF||32|`add   sp,sp,#X`<br /><br /> где X (Код & 0x00FFFF) \* 4|
|FA|00—FF|00—FF|00—FF|32|`add   sp,sp,#X`<br /><br /> где X (Код & 0x00FFFF) \* 4|
|FB||||16|nop (16-разрядный)|
|FC||||32|nop (32-разрядный)|
|FD||||16|end + 16-разрядный nop в эпилоге|
|FE||||32|end + 32-разрядный nop в эпилоге|
|FF||||-|end|

Это показывает диапазон гексадецимальных значений для каждого байта в коде раскрутки *кода,* наряду с размером opcode *Opsize* и соответствующей оригинальной интерпретацией инструкций. Пустые ячейки обозначают более короткие коды очистки. В инструкциях с большими значениями, охватывающими несколько байт, старшие биты сохраняются первыми. Поле *Opsize* показывает неявный размер опкода, связанный с каждой операцией Thumb-2. Видимые повторяющиеся записи в таблице с разными кодировками помогают различить разные размеры кодов операций.

Коды очистки спроектированы таким образом, что первый байт кода сообщает как общий размер кода в байтах, так и размер соответствующего кода операции в потоке инструкций. Чтобы вычислить размер пролога или эпилога, выполните проход по кодам очистки от начала и до конца последовательности и воспользуйтесь таблицей подстановки или аналогичным методом, чтобы определить длину соответствующего кода операции.

Коды очистки 0xFD и 0xFE эквивалентны обычному коду end 0xFF, однако имеют один дополнительный код операции nop в случае эпилога — 16- или 32-разрядный. Для прологов коды 0xFD, 0xFE и 0xFF полностью эквивалентны друг другу. Это объясняет общие окончаний эпилога `bx lr` или `b <tailcall-target>`, которые не имеют эквивалентного инструкции пролога. Это повышает вероятность того, что последовательности очистки можно будет совместно использовать в прологе и эпилогах.

Во многих случаях для пролога и всех эпилогов можно использовать один набор кодов очистки. Однако для обработки очистки частично выполненных прологов может потребоваться несколько последовательностей кодов очистки, отличающихся порядком или поведением. Именно поэтому каждый эпилог имеет собственный индекс в массиве очистки, чтобы показать момент начала выполнения.

### <a name="unwinding-partial-prologues-and-epilogues"></a>Очистка частичных прологов и эпилогов

Наиболее распространенным случаем очистки является возникновение исключения в теле функции, не затрагивающее пролог и все эпилоги. В этом случае средство очистки выполняет коды в массиве очистки, начиная с индекса 0 и продолжая до обнаружения конечного кода операции.

Если исключение возникает во время выполнения пролога или эпилога, кадр стека создан лишь частично, поэтому средству очистки нужно определить, что именно было сделано, чтобы правильно отменить это.

Например, рассмотрим данную последовательность пролога и эпилога:

```asm
0000:   push  {r0-r3}         ; 0x04
0002:   push  {r4-r9, lr}     ; 0xdd
0006:   mov   r7, sp          ; 0xc7
...
0140:   mov   sp, r7          ; 0xc7
0142:   pop   {r4-r9, lr}     ; 0xdd
0146:   add   sp, sp, #16     ; 0x04
0148:   bx    lr
```

Рядом с каждым кодом операции находится подходящий код очистки для описания этой операции. Последовательность кодов очистки для пролога является зеркальным отображением кодов очистки для эпилога без учета последней инструкции. Этот случай является обычным явлением и является причиной того, что коды раскручивания пролога всегда считаются сохранены в обратном порядке из заказа исполнения пролога. Это дает нам общий набор кодов очистки:

```asm
0xc7, 0xdd, 0x04, 0xfd
```

Код 0xFD предназначен специально для конца последовательности, то есть эпилог на одну 16-разрядную инструкцию длиннее пролога. Это открывает широкие возможности для совместного использования кодов очистки.

Если в данном примере исключение возникает, пока выполняется тело функции между прологом и эпилогом, очистка начинается с эпилога с нулевым смещением в коде эпилога. В примере это соответствует смещению 0x140. Средство очистки выполняет полную последовательность освобождения, так как очистка не выполнялась. Если же исключение возникает на одну инструкцию после начала кода эпилога, средство очистки может успешно выполнить очистку, пропустив первый код очистки. Учитывая один-к-одному отображение между opcodes и раскрутить коды, если раскручивание от инструкции *п* в эпилоге, раскручивание должно пропустить первый *п* раскрутить коды.

Аналогичная логика работает и в обратном направлении для пролога. Если очистка осуществляется с нулевого смещения пролога, ничего выполнять не требуется. При осуществлении очистки с погружением на одну инструкцию последовательность очистки должна начаться с предпоследнего кода очистки, так как коды очистки пролога хранятся в обратном порядке. В общем случае, если раскручиваться от инструкции *n* в прологе, раскручивание должно начать выполнение на *n* раскрутки кодов с конца списка кодов.

Коды очистки пролога и эпилога не всегда совпадают полностью. В этом случае в массиве кодов очистки может потребоваться наличие нескольких последовательностей кодов. Чтобы определить смещение для начала обработки кодов, используйте следующую логику.

1. Если очистка выполняется из тела функции, начинайте выполнять коды очистки с индекса 0 и продолжайте до достижения конечного кода операции.

2. Если очистка выполняется из эпилога, используйте специальный начальный индекс эпилога, указанный в области эпилога. Вычислите, на сколько байт PC отстоит от начала эпилога. Пропустите такое число кодов очистки, которое соответствует уже выполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

3. Если очистка осуществляется из пролога, начните с индекса 0 в кодах очистки. Вычислите длину кода пролога из последовательности, а затем рассчитайте, на сколько байт PC отстоит от конца пролога. Пропустите такое число кодов очистки, которое соответствует невыполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

Коды очистки для пролога должны всегда стоять в массиве первыми. Именно эти коды используются для очистки в общем случае, когда очистка осуществляется из тела. Сразу после последовательности кода для пролога должны идти специальные последовательности для эпилога.

### <a name="function-fragments"></a>Фрагменты функции

В целях оптимизации кода может оказаться полезным разделить функцию на разобщенные части. После этого каждому фрагменту функции требуется своя собственная запись .PDATA, а возможно, и запись .XDATA.

Учитывая, что пролог находится в начале функции и не может быть разделен, существует четыре сценария фрагментов функции.

- Только пролог; все эпилоги в других фрагментах.

- Только пролог и один или несколько эпилогов; дополнительные эпилоги в других фрагментах.

- Без пролога и эпилогов; пролог и один или несколько эпилогов в других фрагментах.

- Только эпилоги; пролог и, возможно, дополнительные эпилоги в других фрагментах.

В первом сценарии описать требуется только пролог. Это может быть сделано в компактной форме .pdata, описывая пролог нормально и указывая значение *Ret* 3, чтобы указать отсутствие эпилога. В полной форме .XDATA это можно сделать, предоставив коды очистки пролога как обычно с индексом 0 и указав число эпилогов равным 0.

Второй сценарий аналогичен обычной функции. Если в фрагменте есть только один эпилог, и он находится в конце фрагмента, то можно использовать компактную запись .pdata. В противном случае необходимо использовать полную запись .XDATA. Помните, что значения смещения, указанные для начала эпилога, заданы относительно начала фрагмента, а не исходного начала функции.

Третий и четвертый случаи являются вариантами первого и второго случаев, соответственно, за исключением того, что они не содержат пролога. В таких ситуациях предполагается, что перед началом эпилога имеется код и он считается частью тела функции, поэтому требует обычной очистки в виде устранения влияния пролога. В таких случаях требуется закодировать псевдопролог, который описывает, как выполнить очистку из тела, однако считается имеющим нулевую длину при определении потребности в частичной очистке в начале фрагмента. Кроме того, этот псевдопролог можно описать с помощью тех же кодов очистки, что и эпилог, так как они предположительно выполняют аналогичные операции.

В третьем и четвертом случаях наличие псевдопролога указывается либо путем установки поля *флага* компактной записи .pdata до 2, либо путем установки флага *F* в заголовке .xdata до 1. В любом случае проверка потребности в частичной очистке пролога игнорируется, и все очистки, не относящиеся к эпилогу, считаются полными.

#### <a name="large-functions"></a>Большие функции

Фрагменты можно использовать для описания функций, размер которых превышает предел в 512 КБ, накладываемый битовыми полями в заголовке .XDATA. Чтобы описать очень большую функцию, просто разделите ее на фрагменты размером менее 512 КБ. Для каждого фрагмента требуется подстройка, чтобы он не разбивал эпилог на множество частей.

Только первый фрагмент функции содержит пролог, все остальные фрагменты помечаются как не содержащие пролог. В зависимости от числа эпилогов каждый фрагмент может содержать от нуля до нескольких эпилогов. Помните, что область каждого эпилога во фрагменте указывает начальное смещение относительно начала данного фрагмента, а не начала функции.

Если фрагмент не содержит ни пролог, ни эпилог, ему все равно требуется отдельная запись .PDATA и, возможно, запись .XDATA, чтобы описать очистку из тела функции.

#### <a name="shrink-wrapping"></a>Упаковка со сжатием

Более сложным особым случаем фрагментов функции является *сжатие-обертывание,* метод отсрочки регистра экономит от начала функции до более позднего в функции, чтобы оптимизировать для простых случаев, которые не требуют сохранения регистра. Это можно представить себе как внешний регион, который выделяет место в стеке, но сохраняет минимальный набор регистров, и внутренний регион, который сохраняет и восстанавливает дополнительные регистры.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatiles
    sub    sp, sp, #0x100    ; A: allocate all stack space up front
    ...                      ; A:
    add    r0, sp, #0xE4     ; A: prepare to do the inner save
    stm    r0, {r5-r11}      ; A: save remaining non-volatiles
    ...                      ; B:
    add    r0, sp, #0xE4     ; B: prepare to do the inner restore
    ldm    r0, {r5-r11}      ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C:
```

Упакованные со сжатием функции чаще всего заранее выделяют место под сохранение дополнительных регистров в обычном прологе, а затем выполняют сохранения регистров с помощью `str` или `stm` вместо `push`. Это сохраняет все стек-указатель манипуляции в оригинальном прологе функции.

Пример упакованной со сжатием функции необходимо разделить на три региона, которые в комментариях помечены как A, B и C. Первый регион A охватывает начало функции до конца сохранения дополнительных неизменяемых регистров. Необходимо создать запись .PDATA или .XDATA, чтобы описать этот фрагмент как имеющий пролог и не имеющий эпилогов.

Средний регион B получает собственную запись .PDATA или .XDATA, описывающую его как фрагмент без пролога и эпилога. Однако коды очистки для этого региона все равно должны присутствовать, так как он считается телом функции. Коды должны описывать составной пролог, представляющий как исходные регистры, сохраненные в прологе региона A, так и дополнительные регистры, сохраненные перед входом в регион B, как если бы они были созданы одной последовательностью операций.

Сохранения регистров для региона B нельзя считать "внутренним прологом", так как составной пролог, описанный в регионе B, должен описывать как пролог региона A, так и дополнительные сохраненные регистры. Если бы фрагмент B был описан как имеющий пролог, коды очистки неявно учли бы его размер и у нас не было бы способа описать составной пролог с однозначным сопоставлением с кодами операций, которые сохраняют только дополнительные регистры.

Сохранения дополнительных регистров следует считать частью региона A, поскольку до их завершения составной пролог не дает точное описание состояния стека.

Последний регион C получает собственную запись .PDATA или .XDATA, описывающую его как фрагмент без пролога, но с эпилогом.

Если работу со стеком до входа в регион B можно ограничить одной инструкцией, можно воспользоваться альтернативным подходом.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatile registers
    sub    sp, sp, #0xE0     ; A: allocate minimal stack space up front
    ...                      ; A:
    push   {r4-r9}           ; A: save remaining non-volatiles
    ...                      ; B:
    pop    {r4-r9}           ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C: restore non-volatile registers
```

Основная идея заключается в том, что на каждой границе инструкций стек полностью согласован с кодами очистки для этого региона. Если очистка происходит до внутренней отправки в данном примере, она считается частью региона A, и только пролог этого региона не очищен. Если раскручивание происходит после внутреннего толчка, оно считается частью области B, которая не имеет пролога, но имеет раскручивающиеся коды, описывающие как внутренний толчок, так и исходный пролог из области A. Аналогичная логика имеет место для внутреннего поп-музыки.

### <a name="encoding-optimizations"></a>Оптимизации кодирования

Многообразие кодов очистки и наличие краткой и развернутой форм данных предоставляют множество возможностей для оптимизации кодирования в целях дальнейшего сокращения занимаемого места. При активном использовании этих методик можно сохранить нагрузку от описания функций и фрагментов с помощью кодов очистки на минимальном уровне.

Самый важный аспект оптимизации заключается в том, чтобы не перепутать границы пролога/эпилога для проведения очистки с логическими границами пролога/эпилога с точки зрения компилятора. Для повышения эффективности границы очистки можно сжать, сделав их более тесными. Например, пролог может содержать код после настройки стека для выполнения дополнительных проверок. Но после окончания всей работы со стеком кодировать дополнительные операции больше не нужно, поэтому все остальное из очищаемого пролога можно удалить.

Это же правило применяется и для длины функции. Если имеются данные, например пул литералов, относящиеся к эпилогу функции, их не следует включать в состав длины функции. Сжав функцию и оставив в ней только код, являющийся ее частью, вы значительно увеличите вероятность того, что эпилог будет находиться в самом конце и будет иметь компактный размер. Можно использовать запись .PDATA.

После сохранения указателя стека в другом регистре в прологе больше не нужно записывать дополнительные коды операций. Чтобы очистить функцию, прежде всего следует восстановить указатель стека из сохраненного регистра, чтобы последующие операции никак не повлияли на очистку.

Эпилоги с одной инструкцией вообще не нужно кодировать ни как области, ни как коды очистки. Если очистка производится до выполнения этой инструкции, то можно предположить, что такая очистка выполняется из тела функции, поэтому простого выполнения кодов очистки пролога будет достаточно. Если очистка производится после выполнение единственной инструкции, то по определению она относится к другому региону.

По той же причине в эпилогах с несколькими инструкциями не нужно кодировать первую инструкцию: если очистка производится до выполнения этой инструкции, полной очистки пролога будет достаточно. Если очистка производится после такой инструкции, то следует учитывать только последующие операции.

Следует активно использовать коды очистки повторно. Индекс, заданный каждой областью эпилога, указывает на произвольную начальную точку в массиве кодов очистки. Он совершенно свободно может указывать не на начало предыдущей последовательности, а на ее середину. Оптимальный подход заключается в создании требуемой последовательности кодов с последующим поиском точного побайтового совпадения в уже закодированном пуле последовательностей и использованием найденного совпадения в качестве начальной точки для повторного использования.

Если после пропуска эпилогов с одной инструкцией эпилогов не остается, рекомендуется использовать краткую форму .PDATA; она становится еще актуальнее при полном отсутствии эпилогов.

## <a name="examples"></a>Примеры

В этих примерах база образа находится в 0x00400000.

### <a name="example-1-leaf-function-no-locals"></a>Пример 1: конечная функция, без локальных элементов

```asm
Prologue:
  004535F8: B430      push        {r4-r5}
Epilogue:
  00453656: BC30      pop         {r4-r5}
  00453658: 4770      bx          lr
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *Функция Start RVA* 0x000535F8 (яп.

- Слово 1

  - *Флаг* No 1, указывающий на канонические форматы пролога и эпилога

  - *Длина функции* 0x31 (0x62/2)

  - *Ret* No 1, указывая 16-битный возврат ветви

  - *H* q 0, указывая, что параметры не были домохозяйки

  - *R*No 0 и *Reg* No 1, указывающие на толчок/поп r4-r5

  - *L* No 0, что не указывает на отсутствие lR сохранения/восстановления

  - *C* No 0, что указывает на отсутствие каркаса цепей

  - *Стек Отрегулировать* No 0, указывая, что корректировка стека не

### <a name="example-2-nested-function-with-local-allocation"></a>Пример 2: вложенная функция с локальным выделением

```asm
Prologue:
  004533AC: B5F0      push        {r4-r7, lr}
  004533AE: B083      sub         sp, sp, #0xC
Epilogue:
  00453412: B003      add         sp, sp, #0xC
  00453414: BDF0      pop         {r4-r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *Функция Start RVA* 0x000533AC (Я004533AC -0x004000000)

- Слово 1

  - *Флаг* No 1, указывающий на канонические форматы пролога и эпилога

  - *Длина функции* 0x35 (0x6A/2)

  - *Ret* No 0, указывая на возвращение поп-компьютера

  - *H* q 0, указывая, что параметры не были домохозяйки

  - *R*No 0 и *Reg* 3, указывающие на толчок/поп r4-r7

  - *L* No 1, указывая LR был сохранен/восстановлен

  - *C* No 0, что указывает на отсутствие каркаса цепей

  - *Стек Стек Скорректировать* No 3 (0x0C/4)

### <a name="example-3-nested-variadic-function"></a>Пример 3: вложенная функция с переменным числом аргументов

```asm
Prologue:
  00453988: B40F      push        {r0-r3}
  0045398A: B570      push        {r4-r6, lr}
Epilogue:
  004539D4: E8BD 4070 pop         {r4-r6}
  004539D8: F85D FB14 ldr         pc, [sp], #0x14
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *Функция Start RVA* 0x00053988 (Я000453988-0x004000000)

- Слово 1

  - *Флаг* No 1, указывающий на канонические форматы пролога и эпилога

  - *Длина функции* 0x2A (Я0х54/2)

  - *Ret* No 0, указывая на возвращение в стиле поп-пс (в данном случае возврат ldr pc,#0x14 возврата)

  - *H* No 1, указывая параметры были homed

  - *R*No 0 и *Reg* No 2, указывающие на толчок/поп r4-r6

  - *L* No 1, указывая LR был сохранен/восстановлен

  - *C* No 0, что указывает на отсутствие каркаса цепей

  - *Стек Отрегулировать* No 0, указывая, что корректировка стека не

### <a name="example-4-function-with-multiple-epilogues"></a>Пример 4: функция с несколькими эпилогами

```asm
Prologue:
  004592F4: E92D 47F0 stmdb       sp!, {r4-r10, lr}
  004592F8: B086      sub         sp, sp, #0x18
Epilogues:
  00459316: B006      add         sp, sp, #0x18
  00459318: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  0045943E: B006      add         sp, sp, #0x18
  00459440: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  004595D4: B006      add         sp, sp, #0x18
  004595D6: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459606: B006      add         sp, sp, #0x18
  00459608: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459636: F028 FF0F bl          KeBugCheckEx     ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *Функция Start RVA* 0x000592F4 (яп.

- Слово 1

  - *Пометить* No 0, указывая .xdata запись настоящее время (требуется из-за нескольких эпилогов)

  - *адрес .xdata* - 0x004000000

.XDATA (переменная, 6 слов):

- Слово 0

  - *Длина функции* 0x0001A3 (0x000346/2)

  - *Vers* 0, указывая на первую версию xdata

  - *X* No 0, не указывающие данных об исключениях

  - *E* No 0, указывающий список прицелов эпилога

  - *F* 0, указывая полное описание функции, включая пролог

  - *Эпилог Граф* 0x04, с указанием 4 общих областей эпилога

  - *Кодовые слова* No 0x01, указывающие на одно 32-битное слово раскручиваемых кодов

- Слова 1—4, описывающие 4 области эпилогов в 4 расположениях. Каждая область имеет общий набор кодов очистки, который используется совместно с прологом, имеет смещение 0x00 и является безусловным — задано условие 0x0E ("всегда").

- Коды очистки, начиная со слова 5: (используются совместно прологом и эпилогом).

  - Раскрутите код 0 и 0x06: сп з (6 << 2)

  - Код очистки 1 = 0xDE: pop {r4-r10, lr}.

  - Код очистки 2 = 0xFF: end.

### <a name="example-5-function-with-dynamic-stack-and-inner-epilogue"></a>Пример 5: функция с динамическим стеком и внутренним эпилогом

```asm
Prologue:
  00485A20: B40F      push        {r0-r3}
  00485A22: E92D 41F0 stmdb       sp!, {r4-r8, lr}
  00485A26: 466E      mov         r6, sp
  00485A28: 0934      lsrs        r4, r6, #4
  00485A2A: 0124      lsls        r4, r4, #4
  00485A2C: 46A5      mov         sp, r4
  00485A2E: F2AD 2D90 subw        sp, sp, #0x290
Epilogue:
  00485BAC: 46B5      mov         sp, r6
  00485BAE: E8BD 41F0 ldm         sp!, {r4-r8, lr}
  00485BB2: B004      add         sp, sp, #0x10
  00485BB4: 4770      bx          lr
  ...
  00485E2A: F7FF BE7D b           #0x485B28    ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *Функция Start RVA* 0x00085A20 (яп.

- Слово 1

  - *Пометить* No 0, указывая .xdata запись настоящее время (необходимо из-за нескольких эпилогов)

  - *адрес .xdata* - 0x004000000

.XDATA (переменная, 3 слов):

- Слово 0

  - *Длина функции* 0x0001A3 (0x000346/2)

  - *Vers* 0, указывая на первую версию xdata

  - *X* No 0, не указывающие данных об исключениях

  - *E* No 0, указывающий список прицелов эпилога

  - *F* 0, указывая полное описание функции, включая пролог

  - *Эпилог Граф* 0x001, указывающий на 1 общий охват эпилога

  - *Кодовые слова* No 0x01, указывающие на одно 32-битное слово раскручиваемых кодов

- Слово 1: область эпилога со смещением 0xC6 (= 0x18C/2), начальным индексом кода очистки 0x00 и условием 0x0E ("всегда")

- Коды очистки, начиная со слова 2: (используются совместно прологом и эпилогом).

  - Код очистки 0 = 0xC6: sp = r6.

  - Код очистки 1 = 0xDC: pop {r4-r8, lr}.

  - Раскрутите код 2 и 0x04: sp ( 4 << 2)

  - Код очистки 3 = 0xFD: end, засчитывается как 16-разрядная инструкция для эпилога.

### <a name="example-6-function-with-exception-handler"></a>Пример 6: функция с обработчиком исключений

```asm
Prologue:
  00488C1C: 0059 A7ED dc.w  0x0059A7ED
  00488C20: 005A 8ED0 dc.w  0x005A8ED0
FunctionStart:
  00488C24: B590      push        {r4, r7, lr}
  00488C26: B085      sub         sp, sp, #0x14
  00488C28: 466F      mov         r7, sp
Epilogue:
  00488C6C: 46BD      mov         sp, r7
  00488C6E: B005      add         sp, sp, #0x14
  00488C70: BD90      pop         {r4, r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *Функция Start RVA* 0x0088C24 (яп.

- Слово 1

  - *Пометить* No 0, указывая .xdata запись настоящее время (необходимо из-за нескольких эпилогов)

  - *адрес .xdata* - 0x004000000

.XDATA (переменная, 5 слов):

- Слово 0

  - *Длина функции* 0x00027 (0x00004E/2)

  - *Vers* 0, указывая на первую версию xdata

  - *X* No 1, указывая на данные об исключениях

  - *E* No 1, указывающий на один эпилог

  - *F* 0, указывая полное описание функции, включая пролог

  - *Эпилог Граф* 0x00, указывая эпилог раскручивания коды начинаются с смещения 0x00

  - *Кодовые слова* No 0x02, указывающие на два 32-битных слова раскручивания кодов

- Коды очистки, начиная со слова 1.

  - Код очистки 0 = 0xC7: sp = r7.

  - Раскрутите код 1 и 0x05: сп з (5 << 2)

  - Код очистки 2 = 0xED/0x90: pop {r4, r7, lr}.

  - Код очистки 4 = 0xFF: end.

- Слово 3 указывает обработчик исключений - 0x0019A7ED (я0x0059A7ED - 0x00400000000)

- Слова с 4 и выше являются встроенными данными об исключении.

### <a name="example-7-funclet"></a>Пример 7: Funclet

```asm
Function:
  00488C72: B500      push        {lr}
  00488C74: B081      sub         sp, sp, #4
  00488C76: 3F20      subs        r7, #0x20
  00488C78: F117 0308 adds        r3, r7, #8
  00488C7C: 1D3A      adds        r2, r7, #4
  00488C7E: 1C39      adds        r1, r7, #0
  00488C80: F7FF FFAC bl          target
  00488C84: B001      add         sp, sp, #4
  00488C86: BD00      pop         {pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *Функция Start RVA* 0x0088C72 (яп.

- Слово 1

  - *Флаг* No 1, указывающий на канонические форматы пролога и эпилога

  - *Длина функции* 0x0B (0x16/2)

  - *Ret* No 0, указывая на возвращение поп-компьютера

  - *H* q 0, указывая, что параметры не были домохозяйки

  - *R*No 0 и *Reg* No 7, указывающие на отсутствие регистров, сохраненных/восстановленных

  - *L* No 1, указывая LR был сохранен/восстановлен

  - *C* No 0, что указывает на отсутствие каркаса цепей

  - *Стек Отрегулировать* No 1, указывая 1 и 4 байт стек корректировки

## <a name="see-also"></a>См. также раздел

[Обзор конвенций ARM ABI](overview-of-arm-abi-conventions.md)<br/>
[Общие вопросы использования Visual C++ ARM](common-visual-cpp-arm-migration-issues.md)
