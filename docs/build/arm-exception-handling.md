---
title: Обработка исключений ARM
ms.date: 07/11/2018
ms.assetid: fe0e615f-c033-4ad5-97f4-ff96af45b201
ms.openlocfilehash: 8a2bae8e42ac6a624bebe7c185ac7e0ade8d5491
ms.sourcegitcommit: 6e4dd21759caaed262a7255735cf8d6e8fb9f4d7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/26/2019
ms.locfileid: "58476946"
---
# <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows на ARM использует один механизм структурированной обработки исключений для асинхронных аппаратных и синхронных программных исключений. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. В этом документе описывается обработка исключений в Windows на ARM, а также вспомогательные функции языка, используемых кодом, созданных в ассемблер ARM Microsoft и компилятором MSVC.

## <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows на ARM использует *коды очистки* для управления очисткой стека во время [структурированная обработка исключений](/windows/desktop/debug/structured-exception-handling) (SEH). Коды очистки представляют собой последовательность байт, хранимых в разделе .XDATA исполняемого образа. Они отвлеченно описывают работу кода пролога и эпилога функции, чтобы можно было нейтрализовать воздействие пролога функции во время подготовки к очистке кадра стека вызывающего объекта.

Встроенный двоичный интерфейс приложения ARM EABI задает модель очистки исключения, использующую коды очистки, однако SEH этого недостаточно для выполнения очистки в Windows, так как требуется обрабатывать асинхронные случаи, когда процессор находится в середине пролога или эпилога функции. Windows также разделяет управление очисткой на очистку функционального уровня и очистку языковой области, которая унифицирована в ARM EABI. По этим причинам Windows на ARM указывает больше сведений о данных и процедуре очистки.

### <a name="assumptions"></a>Допущения

Исполняемые образы для Windows на ARM используют формат переносимого исполняемого файла (PE). Дополнительные сведения см. в разделе [Microsoft PE и COFF](http://go.microsoft.com/fwlink/p/?linkid=84140). Информация об обработке исключений хранится в разделах .PDATA и .XDATA образа.

Механизм обработки исключений делает определенные предположения о коде, который соответствует двоичному интерфейсу приложения для Windows на ARM.

- При возникновении исключения в теле функции не имеет никакого значения, выполнены ли операции пролога или операции эпилога выполняются с опережением. Оба случая должны давать одинаковые результаты.

- Прологи и эпилоги стремятся зеркально отображать друг друга. Это можно использовать для сокращения объема метаданных, требуемых для описания очистки.

- Функции имеют относительно небольшой размер. На этом основано несколько оптимизаций для более эффективной упаковки данных.

- Если условие ставится в эпилоге, оно в равной степени применяется ко всем инструкциям эпилога.

- Если в прологе указатель стека (SP) сохраняется в другом регистре, этот регистр должен оставаться неизменным в течение всего времени работы функции, чтобы исходный указатель стека можно было получить в любое время.

- Если только указатель стека не сохранен в другом регистре, все операции с ним должны производиться исключительно в пределах пролога и эпилога.

- Для очистки кадра стека необходимо выполнить следующие операции.

  - Скорректируйте r13 (SP) с 4-байтными приращениями.

  - Извлеките один или несколько целочисленных регистров.

  - Извлеките один или несколько регистров VFP (виртуальные операции с плавающей запятой).

  - Скопируйте значение произвольного регистра в r13 (SP).

  - Загрузите указатель стека из стека с помощью небольшой постдекрементной операции.

  - Произведите анализ одного из нескольких четко заданных типов кадров.

### <a name="pdata-records"></a>Записи .PDATA

Записи .PDATA в образе формата PE представляют собой упорядоченный массив с элементами фиксированной длины, которые описывают каждую работающую со стеком функцию. Конечным функциям, которые не вызывают другие функции, записи .PDATA не требуются, если только они не работают со стеком. (Таким образом, им не требуется локальное хранилище и не нужно сохранять или восстанавливать неизменяемые регистры.) Для экономии места записи для таких функций в разделе .PDATA можно опускать. Операция очистки из одной из таких функций может просто скопировать адрес возврата из регистра связи (LR) в счетчик команд (PC) для перемещения к вызывающему объекту.

Каждая запись .PDATA для ARM имеет длину 8 байт. Общий формат записи имеет следующий вид: относительный виртуальный адрес (RVA) в начале функции в первом 32-битном слове, после которого идет второе слово с указателем на блок .XDATA переменной длины или упакованным словом, описывающим каноническую последовательность очистки функции, как показано в следующей таблице.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*Функция запуска RVA* является 32-разрядный относительный виртуальный адрес начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0—1|*Флаг* представляет собой 2-битовое поле, указывающее, как интерпретировать остальные 30 бит второго слова .pdata. Если *флаг* равно 0, то оставшиеся биты формируют *RVA сведения исключение* (с низкой два бита неявно 0). Если *флаг* не равно нулю, то оставшиеся биты формируют *упакованные данные очистки* структуры.|
|1|2—31|*Сведения об исключении RVA* или *упакованные данные очистки*.<br /><br /> *Исключение сведения RVA* — это адрес структуры сведений исключении переменной длины, хранимых в разделе .xdata. Эти данные должны быть выровнены по 4-байтовой границе.<br /><br /> *Упакованные данные очистки* представляет собой сжатое описание операций, необходимых для выполнения очистки из функции в канонической форме. В этом случае запись .XDATA не требуется.|

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для функций, прологи и эпилоги которых соответствуют описанной ниже канонической форме, можно использовать упакованные данные очистки. Это устраняет потребность в записи .XDATA и значительно сокращает требования к месту для предоставления данных очистки. Канонические прологи и эпилоги предназначены для удовлетворения общих требований простой функции, которая не требует обработчика событий и выполняет операции настройки и удаления в стандартном порядке.

В этой таблице показан формат записи .PDATA, содержащей упакованные данные очистки.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*Функция запуска RVA* является 32-разрядный относительный виртуальный адрес начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0—1|*Флаг* представляет собой 2-битовое поле, имеющее следующие значения:<br /><br />-00 = упакованные данные очистки не используются; остальные биты указывают на запись .xdata.<br />-01 = упакованные данные очистки.<br />-10 = упакованные данные, где предполагается отсутствие пролога функции очистки. Это удобно для описания фрагментов функции, которые разобщены с началом функции.<br />-11 = зарезервированным.|
|1|2—12|*Функция длина* представляет собой 11-битовое поле, которое предоставляет длину всей функции в байтах, поделенную на 2. Если размер функции больше 4 КБ, следует использовать полную запись .XDATA.|
|1|13—14|*Возвращаемое значение* представляет собой 2-битовое поле, указывающее способ возврата данных функцией:<br /><br />-00 = возврат посредством извлечения {pc} ( *L* битовый флаг должно быть установлено в 1, в данном случае).<br />-01 = возвращение посредством 16-разрядного ветвления.<br />-10 = возвращение посредством 32-разрядного ветвления.<br />-11 = полное отсутствие эпилога вообще. Это удобно для описания разобщенного фрагмента функции, который может содержать только пролог, однако его эпилог находится в другом месте.|
|1|15|*H* 1-битовый флаг, указывающий, является ли функция «начальное расположение» целочисленный параметр регистрирует (r0 — r3) посредством их отправки в начале функции, и освобождает 16 байт стека перед возвратом. (0 = не помещает в начальное расположение, 1 = помещает в начальное расположение.)|
|1|16—18|*REG* 3-битовое поле, которое указывает индекс последнего сохранения неизменяемого регистра. Если *R* бит равен 0, то сохраняются только целочисленные регистры и предполагается, что находиться в диапазоне от r4 — RN, где значение N равно 4 + *Reg*. Если *R* бит равен 1, то только с плавающей точкой регистры сохраняются, предполагается, что находиться в диапазоне от d8 — DN, где N равно 8 + *Reg*. Особое сочетание *R* = 1 и *Reg* = 7 указывает, что никакие регистры сохраняются.|
|1|19|*R* представляет собой 1-битовый флаг, указывающее ли сохраненные неизменяемые регистры целочисленных регистров (0) или регистров с плавающей запятой (1). Если *R* имеет значение 1 и *Reg* поле имеет значение 7, не неизменяемые регистры не отправлялись.|
|1|20|*L* представляет собой 1-битовый флаг, указывающее, является ли функция сохранение или восстановление регистра LR вместе с другими регистрами, указанными в *Reg* поля. (0 = не сохраняет/восстанавливает, 1 = сохраняет/восстанавливает.)|
|1|21|*C* представляет собой 1-битовый флаг, который указывает, содержит ли функция Дополнительные инструкции по настройке цепочки кадров для ускорения проверки (1) или нет стека (0). Если этот бит задан, r11 неявно добавляется в список сохраняемых неизменяемых регистров для целочисленных операций. (См. в разделе описанные ниже ограничения при *C* используется флаг.)|
|1|22—31|*Настройка стека* представляет собой 10-битовое поле, которое указывает общее число байт в стеке, выделенных для этой функции, поделенное на 4. Однако напрямую возможно кодирование лишь значений из диапазона 0x000—0x3F3. Функции, выделяющие более 4044 байт стека, должны использовать полную запись .XDATA. Если *настроить стек* поле имеет размер 0x3F4 и более, то 4 младших бита имеют особое значение:<br /><br />-Биты 0 — 1 указывают число слов в подстройке стека (1 – 4) минус 1.<br />-Бит 2 имеет значение 1, если пролог объединил эту подстройку со своей операцией отправки.<br />-Бит 3 имеет значение 1, если эпилог объединил эту подстройку со своей операцией извлечения.|

В связи с возможным дублированием в описанном выше кодировании применяются следующие ограничения.

- Если *C* флаг имеет значение 1:

   - *L* должен быть также установлен флаг в значение 1, так как цепочка кадров требует как r11 и LR.

   - R11 не должны быть включены в набор регистров, описываемый *Reg*. То есть, если передаются r4 — r11, *Reg* должен описывать только регистры r4 — r10, так как *C* флаг подразумевает r11.

- Если *Ret* поле имеет значение 0, *L* 1 должен быть установлен флаг.

Нарушение этих ограничений ведет к неподдерживаемой последовательности операций.

В целях дальнейшего обсуждения двух псевдофлагов из *настроить стек*:

- *PF* или «свертывание пролога» указывает, что *настроить стек* имеет размер 0x3F4 или больше и бит 2 имеет значение.

- *EF* или «свертывание эпилога» указывает, что *настроить стек* имеет размер 0x3F4 или больше и бит 3 имеет значение.

Прологи для канонических функций могут иметь до 5 инструкций (обратите внимание, что 3а и 3б являются взаимоисключающими).

|Инструкция|Предполагается наличие кода операции, если|Размер|Код операции|Коды очистки|
|-----------------|-----------------------------------|----------|------------|------------------|
|1|*H*== 1|16|`push {r0-r3}`|04|
|2|*C*== 1 или *L*== 1 или *R*== 0 или PF == 1|16/32|`push {registers}`|80—BF/D0—DF/EC—ED|
|3а|*C*== 1 и (*L*== 0 и *R*== 1 и PF == 0)|16|`mov r11,sp`|C0—CF/FB|
|3б|*C*== 1 и (*L*== 1 или *R*== 0 или PF == 1)|32|`add r11,sp,#xx`|FC|
|4|*R*== 1 и *Reg* ! = 7|32|`vpush {d8-dE}`|E0—E7|
|5|*Настройка стека* ! = 0 и PF == 0|16/32|`sub sp,sp,#xx`|00—7F/E8—EB|

Инструкция 1 всегда присутствует Если *H* бит равен 1.

Чтобы настроить цепочку кадров, присутствует инструкция 3а или 3б при *C* бита. Это 16-разрядная `mov`, если отправляются только регистры r11 и LR; в противном случае это 32-разрядная `add`.

Если указана подстройка без свертывания, инструкция 5 является явной подстройкой стека.

Инструкции 2 и 4 задаются с учетом того, требуется ли отправка. В следующей таблице перечислены какие регистры сохраняются на основе *C*, *L*, *R*, и *PF* поля. Во всех случаях *N* равен *Reg* + 4, *E* равен *Reg* + 8, и *S* равен (~*Настроить стек*) & 3.

|В|L|R|PF|Отправленные целочисленные регистры|Отправленные регистры VFP|
|-------|-------|-------|--------|------------------------------|--------------------------|
|0|0|0|0|R4 — r*N*|Нет|
|0|0|0|1|r*S*- r*N*|Нет|
|0|0|1|0|Нет|d8-d*E*|
|0|0|1|1|r*S*-r3|d8-d*E*|
|0|1|0|0|r4-r*N*, LR|Нет|
|0|1|0|1|r*S*- r*N*, LR|Нет|
|0|1|1|0|LR|d8-d*E*|
|0|1|1|1|r*S*-r3, LR|d8-d*E*|
|1|0|0|0|R4 — r*N*, r11|Нет|
|1|0|0|1|r*S*- r*N*, r11|Нет|
|1|0|1|0|r11|d8-d*E*|
|1|0|1|1|r*S*-r3, r11|d8-d*E*|
|1|1|0|0|r4-r*N*, r11, LR|Нет|
|1|1|0|1|r*S*- r*N*, r11, LR|Нет|
|1|1|1|0|r11, LR|d8-d*E*|
|1|1|1|1|r*S*-r3, r11, LR|d8-d*E*|

Эпилоги для канонических функций имеют аналогичную форму, однако с обратным порядком и дополнительными параметрами. Эпилог может иметь длину до 5 инструкций, а его форма жестко определяется формой пролога.

|Инструкция|Предполагается наличие кода операции, если|Размер|Код операции|
|-----------------|-----------------------------------|----------|------------|
|6|*Настройка стека*! = 0 и *EF*== 0|16/32|`add   sp,sp,#xx`|
|7|*R*== 1 и *Reg*! = 7|32|`vpop  {d8-dE}`|
|8|*C*== 1 или (*L*== 1 и *H*== 0) или *R*== 0 или *EF*== 1|16/32|`pop   {registers}`|
|9а|*H*== 1 и *L*== 0|16|`add   sp,sp,#0x10`|
|9б|*H*== 1 и *L*== 1|32|`ldr   pc,[sp],#0x14`|
|10а|*RET*== 1|16|`bx    reg`|
|10б|*RET*== 2|32|`b     address`|

Инструкция 6 является явной подстройкой стека, если указана подстройка без свертывания. Так как *PF* не зависит от *EF*, его можно использовать инструкцию без 5 инструкции 6 или наоборот.

Инструкции 7 и 8 использовать ту же логику как пролога, чтобы определить, какие регистры восстанавливаются из стека, но с этими изменениями два: во-первых, *EF* используется вместо *PF*; во-вторых, если *Ret*  = 0, то LR заменяется на PC в списке регистров, а эпилог моментально завершается.

Если *H* имеет значение, то присутствует либо инструкция 9а, либо инструкция 9б. Инструкция 9а используется при *L* равен 0, чтобы указать, что не является LR в стеке. В этом случае выполнена Ручная Подстройка стека и *Ret* должен быть 1 или 2 для указания явного возврата. Инструкция 9б используется при *L* -1, чтобы указать на раннее завершение эпилога и чтобы возвратить и подстроить стек, в то же время.

Если эпилог еще не закончен, затем либо инструкция 10А или 10b присутствует, чтобы указать ветвь 16- или 32-разрядной, на основе значения из *Ret*.

### <a name="xdata-records"></a>Записи .XDATA

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись .XDATA переменной длины. Адрес этой записи хранится во втором слове записи .PDATA. Формат .XDATA представляет собой упакованный набор слов переменной длины, состоящий из четырех разделов.

1. Заголовок из 1 или 2 слов, описывающий общий размер структуры .XDATA и предоставляющий ключевые функциональные данные. Второе слово присутствует, только если *число эпилогов* и *слов кодов* полей являются равными 0. Эти поля описаны в следующей таблице.

   |Слово|Bits|Цель|
   |----------|----------|-------------|
   |0|0—17|*Функция длина* представляет собой 18-битовое поле, которое указывает общую длину функции в байтах, поделенную на 2. Если размер функции больше 512 КБ, для ее описания следует создать несколько записей .PDATA и .XDATA. Дополнительные сведения см. в разделе "Большие функции" настоящего документа.|
   |0|18—19|*Vers* представляет собой 2-битовое поле, описывающее версию оставшиеся xdata. Сейчас определена только версия 0; значения 1—3 зарезервированы.|
   |0|20|*X* представляет собой 1-битовое поле, указывающее наличие (1) или отсутствие (0) данных исключения.|
   |0|21|*E* является 1-битовое поле, которое указывает, что сведения, описывающие отдельного эпилога, упакована в заголовок (1) не потребует дополнительных слов, более поздней версии (0).|
   |0|22|*F* представляет собой 1-битовое поле, которое указывает, что данная запись описывает фрагмент функции (1) или всю функцию целиком (0). Если указан фрагмент, пролог отсутствует, поэтому его обработку можно проигнорировать.|
   |0|23—27|*Число эпилогов* представляет собой 5-битовое поле, имеющее два значения в зависимости от состояния *E* бит:<br /><br /> Если *E* равно 0, это поле представляет собой число общее число областей исключений, описанных в разделе 3. Если присутствует более 31 области существует в функции, то это поле и *слов кодов* поля должны быть равными 0, чтобы указать на потребность в слове расширения.<br />Если *E* -1, это поле указывает индекс первого кода очистки, описывающего единственный эпилог.|
   |0|28—31|*Код слова* представляет собой 4-битовое поле, которое указывает число 32-разрядных слов, требуемое для размещения всех кодов очистки в разделе 4. Если требуются более 15 слов для более чем 63 байт кодов очистки, это поле и *число эпилогов* поля должны быть равными 0, чтобы указать на потребность в слове расширения.|
   |1|0—15|*Расширенные число эпилогов* представляет собой 16-битовое поле, которое предоставляет дополнительное место для кодирования необычайно большого числа эпилогов. Слово расширения, содержащий это поле присутствует, только если *число эпилогов* и *слов кодов* поля в первом слове заголовка равны 0.|
   |1|16—23|*Расширенные слов кодов* представляет собой 8-битовое поле, которое предоставляет дополнительное место для кодирования необычайно большого числа слов кодов очистки. Слово расширения, содержащий это поле присутствует, только если *число эпилогов* и *слов кодов* поля в первом слове заголовка равны 0.|
   |1|24—31|Зарезервированное|

1. После данных об исключении (если *E* бит в заголовке было присвоено значение 0) — это список сведений об областях эпилога, которые упакованы в слова и хранятся в порядке увеличения начального смещения. Каждая область содержит следующие поля.

   |Bits|Цель|
   |----------|-------------|
   |0—17|*Запуск смещение эпилога* представляет собой 18-битовое поле, которое описывает смещение эпилога в байтах, поделенную на 2, относительно начала функции.|
   |18—19|*RES* представляет собой 2-битовое поле, которое зарезервировано для будущего расширения. Оно должно иметь значение 0.|
   |20—23|*Условие* представляет собой 4-битовое поле, содержащее условие, в котором выполняется эпилога. Для безусловных эпилогов в нем следует задать значение 0xE, которое означает "всегда". (Эпилог должен быть полностью условным или полностью безусловным, а в режиме Thumb-2 эпилог начинается с первой инструкции после кода операции IT.)|
   |24—31|*Начальный индекс эпилога* представляет собой 8-битовое поле, указывающее индекс байта первого кода очистки, описывающего этот эпилог.|

1. После списка областей эпилога идет массив с кодами очистки, которые подробно описаны в разделе "Коды очистки" данной статьи. Этот массив дополняется в конец ближайшей границы полного слова. Байты хранятся с прямым порядком, чтобы их можно было напрямую получать в соответствующем режиме.

1. Если *X* поля в заголовке равно 1, после байтов кодов очистки располагаются сведения об обработчике исключений. Состоят из одного *RVA обработчик исключений* , содержащий адрес обработчика исключений, непосредственно за объем данных, необходимый для обработчика исключений (переменной длины).

Запись .XDATA спроектирована таким образом, что можно получить первые 8 байт и вычислить полный размер записи без учета размера последующих данных об исключении, имеющих переменную длину. Этот фрагмент кода вычисляет размер записи:

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogueScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 23) != 0) {
        Size = 4;
        EpilogueScopes = (Xdata[0] >> 23) & 0x1f;
        UnwindWords = (Xdata[0] >> 28) & 0x0f;
    } else {
        Size = 8;
        EpilogueScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    if (!(Xdata[0] & (1 << 21))) {
        Size += 4 * EpilogueScopes;
    }
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;
    }
    return Size;
}
```

Несмотря на то, что пролог и каждый эпилог имеют индекс в кодах очистки, таблица используется ими совместно. Довольно распространена ситуация, когда все они используют совместно одинаковые коды очистки. Мы рекомендуем разработчикам компилятора предусмотреть оптимизацию такого случая, так как самый большой индекс, который можно указать, равен 255, что ограничивает общее возможное число кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет собой пул последовательностей инструкций, описывающий, как устранить влияние пролога, и содержащий операции в порядке их отмены. Коды очистки представляют собой мининаборы инструкций, закодированные в виде строки байтов. После окончания выполнения адрес возврата в вызывающую функцию находится в регистре LR, а для всех неизменяемых регистров восстанавливаются значения, актуальные на момент вызова функции.

Если бы существовала уверенность в том, что исключения возникают только в теле функции и никогда не возникают в прологе или эпилоге, потребовалась бы всего одна последовательность очистки. Однако модель очистки Windows требует наличия возможности выполнения очистки из частично выполненного пролога или эпилога. Чтобы выполнить это требование, коды очистки были тщательно спроектированы для обеспечения однозначного сопоставления с каждым соответствующим кодом операции в прологе и эпилоге. Эта особенность имеет несколько разных применений.

- Можно вычислить длину пролога и эпилога, сосчитав число кодов очистки. Это возможно даже при инструкциях переменной длины в режиме Thumb-2, так как имеются четкие сопоставления для 16- и 32-разрядных кодов операций.

- Считая число инструкций после начала области эпилога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы завершить частично выполненную очистку, произведенную эпилогом.

- Считая число инструкций до окончания пролога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы отменить только те части пролога, выполнение которых завершилось.

В приведенной ниже таблице показано сопоставление кодов очистки с кодами операций. Наиболее распространены коды длиной в один байт, реже попадаются коды из двух, трех и даже четырех байт. Каждый код хранится от старшего байта к младшему. Структура кода очистки отличается от кодировки, описанной в стандартном встроенном двоичном интерфейсе приложения ARM, так как эти коды очистки рассчитаны на наличие однозначного сопоставления с кодами операций в прологе и эпилоге, что делает возможной очистку частично выполненных прологов и эпилогов.

|Байт 1|Байт 2|Байт 3|Байт 4|Размер операции|Объяснение|
|------------|------------|------------|------------|------------|-----------------|
|00—7F||||16|`add   sp,sp,#X`<br /><br /> где X равен (код & 0x7F) \* 4|
|80—BF|00—FF|||32|`pop   {r0-r12, lr}`<br /><br /> где LR извлекается, если код & 0x2000 и r0 — r12 извлекаются, если соответствующий бит задан в код & 0x1FFF|
|C0—CF||||16|`mov   sp,rX`<br /><br /> где X — код & 0x0F|
|D0—D7||||16|`pop   {r4-rX,lr}`<br /><br /> где X равен (код & 0x03) + 4, а LR извлекается, если код & 0x04|
|D8—DF||||32|`pop   {r4-rX,lr}`<br /><br /> где X равен (код & 0x03) + 8, а LR извлекается, если код & 0x04|
|E0—E7||||32|`vpop  {d8-dX}`<br /><br /> Где X равен (код & 0x07) + 8.|
|E8—EB|00—FF|||32|`addw  sp,sp,#X`<br /><br /> где X равен (код & 0x03FF) \* 4|
|EC—ED|00—FF|||16|`pop   {r0-r7,lr}`<br /><br /> где LR извлекается, если код & 0x0100 и r0 — r7 извлекаются, если соответствующий бит задан в код & 0x00FF|
|EE|00—0F|||16|Специально для систем Майкрософт|
|EE|10—FF|||16|Доступно|
|EF|00—0F|||32|`ldr   lr,[sp],#X`<br /><br /> где X равен (код & 0x000F) \* 4|
|EF|10—FF|||32|Доступно|
|F0—F4||||-|Доступно|
|F5|00—FF|||32|`vpop  {dS-dE}`<br /><br /> где S равен (код & 0x00F0) >> 4 и E равен код & 0x000F|
|F6|00—FF|||32|`vpop  {dS-dE}`<br /><br /> где S — ((Code & 0x00F0) >> 4) + 16 и E равен (код & 0x000F) + 16|
|F7|00—FF|00—FF||16|`add   sp,sp,#X`<br /><br /> где X равен (код & 0x00FFFF) \* 4|
|F8|00—FF|00—FF|00—FF|16|`add   sp,sp,#X`<br /><br /> где X равен (код & 0x00FFFFFF) \* 4|
|F9|00—FF|00—FF||32|`add   sp,sp,#X`<br /><br /> где X равен (код & 0x00FFFF) \* 4|
|FA|00—FF|00—FF|00—FF|32|`add   sp,sp,#X`<br /><br /> где X равен (код & 0x00FFFFFF) \* 4|
|FB||||16|nop (16-разрядный)|
|FC||||32|nop (32-разрядный)|
|FD||||16|end + 16-разрядный nop в эпилоге|
|FE||||32|end + 32-разрядный nop в эпилоге|
|FF||||-|end|

Здесь показан диапазон шестнадцатеричных значений для каждого байта в коде очистки *кода*, а также размер кода операции *Opsize* и соответствующая Интерпретация исходных инструкций. Пустые ячейки обозначают более короткие коды очистки. В инструкциях с большими значениями, охватывающими несколько байт, старшие биты сохраняются первыми. *Opsize* поле показывает неявный размер кода операции связанные с каждой операцией Thumb-2. Видимые повторяющиеся записи в таблице с разными кодировками помогают различить разные размеры кодов операций.

Коды очистки спроектированы таким образом, что первый байт кода сообщает как общий размер кода в байтах, так и размер соответствующего кода операции в потоке инструкций. Чтобы вычислить размер пролога или эпилога, выполните проход по кодам очистки от начала и до конца последовательности и воспользуйтесь таблицей подстановки или аналогичным методом, чтобы определить длину соответствующего кода операции.

Коды очистки 0xFD и 0xFE эквивалентны обычному коду end 0xFF, однако имеют один дополнительный код операции nop в случае эпилога — 16- или 32-разрядный. Для прологов коды 0xFD, 0xFE и 0xFF полностью эквивалентны друг другу. Это дает нам общие окончания эпилога `bx lr` или `b <tailcall-target>`, для чего эквивалентная инструкция пролога отсутствует. Это повышает вероятность того, что последовательности очистки можно будет совместно использовать в прологе и эпилогах.

Во многих случаях для пролога и всех эпилогов можно использовать один набор кодов очистки. Однако для обработки очистки частично выполненных прологов может потребоваться несколько последовательностей кодов очистки, отличающихся порядком или поведением. Именно поэтому каждый эпилог имеет собственный индекс в массиве очистки, чтобы показать момент начала выполнения.

### <a name="unwinding-partial-prologues-and-epilogues"></a>Очистка частичных прологов и эпилогов

Наиболее распространенным случаем очистки является возникновение исключения в теле функции, не затрагивающее пролог и все эпилоги. В этом случае средство очистки выполняет коды в массиве очистки, начиная с индекса 0 и продолжая до обнаружения конечного кода операции.

Если исключение возникает во время выполнения пролога или эпилога, кадр стека создан лишь частично, поэтому средству очистки нужно определить, что именно было сделано, чтобы правильно отменить это.

Например, рассмотрим данную последовательность пролога и эпилога:

```asm
0000:   push  {r0-r3}         ; 0x04
0002:   push  {r4-r9, lr}     ; 0xdd
0006:   mov   r7, sp          ; 0xc7
...
0140:   mov   sp, r7          ; 0xc7
0142:   pop   {r4-r9, lr}     ; 0xdd
0146:   add   sp, sp, #16     ; 0x04
0148:   bx    lr
```

Рядом с каждым кодом операции находится подходящий код очистки для описания этой операции. Последовательность кодов очистки для пролога является зеркальным отображением кодов очистки для эпилога без учета последней инструкции. Это распространенный случай, и причина здесь заключается в том, что коды очистки всегда предполагается хранить в обратном порядке по сравнению с порядком выполнения пролога. Это дает нам общий набор кодов очистки:

```asm
0xc7, 0xdd, 0x04, 0xfd
```

Код 0xFD предназначен специально для конца последовательности, то есть эпилог на одну 16-разрядную инструкцию длиннее пролога. Это открывает широкие возможности для совместного использования кодов очистки.

Если в данном примере исключение возникает, пока выполняется тело функции между прологом и эпилогом, очистка начинается с эпилога с нулевым смещением в коде эпилога. В примере это соответствует смещению 0x140. Средство очистки выполняет полную последовательность освобождения, так как очистка не выполнялась. Если же исключение возникает на одну инструкцию после начала кода эпилога, средство очистки может успешно выполнить очистку, пропустив первый код очистки. Учитывая однозначное сопоставление между кодами операций и кодами очистки, при очистке с инструкции *n* эпилога будут пропущены первый *n* коды очистки.

Аналогичная логика работает и в обратном направлении для пролога. Если очистка осуществляется с нулевого смещения пролога, ничего выполнять не требуется. При осуществлении очистки с погружением на одну инструкцию последовательность очистки должна начаться с предпоследнего кода очистки, так как коды очистки пролога хранятся в обратном порядке. В общем случае при очистке с инструкции *n* в прологе выполнение следует начинать с *n* коды от конца списка кодов очистки.

Коды очистки пролога и эпилога не всегда совпадают полностью. В этом случае в массиве кодов очистки может потребоваться наличие нескольких последовательностей кодов. Чтобы определить смещение для начала обработки кодов, используйте следующую логику.

1. Если очистка выполняется из тела функции, начинайте выполнять коды очистки с индекса 0 и продолжайте до достижения конечного кода операции.

2. Если очистка выполняется из эпилога, используйте специальный начальный индекс эпилога, указанный в области эпилога. Вычислите, на сколько байт PC отстоит от начала эпилога. Пропустите такое число кодов очистки, которое соответствует уже выполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

3. Если очистка осуществляется из пролога, начните с индекса 0 в кодах очистки. Вычислите длину кода пролога из последовательности, а затем рассчитайте, на сколько байт PC отстоит от конца пролога. Пропустите такое число кодов очистки, которое соответствует невыполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

Коды очистки для пролога должны всегда стоять в массиве первыми. Именно эти коды используются для очистки в общем случае, когда очистка осуществляется из тела. Сразу после последовательности кода для пролога должны идти специальные последовательности для эпилога.

### <a name="function-fragments"></a>Фрагменты функции

В целях оптимизации кода может оказаться полезным разделить функцию на разобщенные части. После этого каждому фрагменту функции требуется своя собственная запись .PDATA, а возможно, и запись .XDATA.

Учитывая, что пролог находится в начале функции и не может быть разделен, существует четыре сценария фрагментов функции.

- Только пролог; все эпилоги в других фрагментах.

- Только пролог и один или несколько эпилогов; дополнительные эпилоги в других фрагментах.

- Без пролога и эпилогов; пролог и один или несколько эпилогов в других фрагментах.

- Только эпилоги; пролог и, возможно, дополнительные эпилоги в других фрагментах.

В первом сценарии описать требуется только пролог. Это можно сделать в краткой форме .pdata, описав пролог обычным образом и указав *Ret* значение 3, указывающее на отсутствие эпилога. В полной форме .XDATA это можно сделать, предоставив коды очистки пролога как обычно с индексом 0 и указав число эпилогов равным 0.

Второй сценарий аналогичен обычной функции. Если во фрагменте присутствует только один эпилог, расположенный в конце фрагмента, можно использовать краткую запись .PDATA. В противном случае необходимо использовать полную запись .XDATA. Помните, что значения смещения, указанные для начала эпилога, заданы относительно начала фрагмента, а не исходного начала функции.

Третий и четвертый сценарии являются вариантами первого и второго сценариев соответственно, за исключением того, что в них нет пролога. В таких ситуациях предполагается, что перед началом эпилога имеется код и он считается частью тела функции, поэтому требует обычной очистки в виде устранения влияния пролога. В таких случаях требуется закодировать псевдопролог, который описывает, как выполнить очистку из тела, однако считается имеющим нулевую длину при определении потребности в частичной очистке в начале фрагмента. Кроме того, этот псевдопролог можно описать с помощью тех же кодов очистки, что и эпилог, так как они предположительно выполняют аналогичные операции.

В третьем и четвертом сценарии наличие псевдопролога указывается путем установки *флаг* поле записи .pdata 2, или установив *F* флаг в заголовке .xdata 1. В любом случае проверка потребности в частичной очистке пролога игнорируется, и все очистки, не относящиеся к эпилогу, считаются полными.

#### <a name="large-functions"></a>Большие функции

Фрагменты можно использовать для описания функций, размер которых превышает предел в 512 КБ, накладываемый битовыми полями в заголовке .XDATA. Чтобы описать очень большую функцию, просто разделите ее на фрагменты размером менее 512 КБ. Для каждого фрагмента требуется подстройка, чтобы он не разбивал эпилог на множество частей.

Только первый фрагмент функции содержит пролог, все остальные фрагменты помечаются как не содержащие пролог. В зависимости от числа эпилогов каждый фрагмент может содержать от нуля до нескольких эпилогов. Помните, что область каждого эпилога во фрагменте указывает начальное смещение относительно начала данного фрагмента, а не начала функции.

Если фрагмент не содержит ни пролог, ни эпилог, ему все равно требуется отдельная запись .PDATA и, возможно, запись .XDATA, чтобы описать очистку из тела функции.

#### <a name="shrink-wrapping"></a>Упаковка со сжатием

Более сложным частным случаем фрагментов функции является *отведения сохранения*, методика для регистров из начала функции, чтобы позже в функции, для оптимизации простых случаях, не требующих сохранение регистров. Это можно представить себе как внешний регион, который выделяет место в стеке, но сохраняет минимальный набор регистров, и внутренний регион, который сохраняет и восстанавливает дополнительные регистры.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatiles
    sub    sp, sp, #0x100    ; A: allocate all stack space up front
    ...                      ; A:
    add    r0, sp, #0xE4     ; A: prepare to do the inner save
    stm    r0, {r5-r11}      ; A: save remaining non-volatiles
    ...                      ; B:
    add    r0, sp, #0xE4     ; B: prepare to do the inner restore
    ldm    r0, {r5-r11}      ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C:
```

Упакованные со сжатием функции чаще всего заранее выделяют место под сохранение дополнительных регистров в обычном прологе, а затем выполняют сохранения регистров с помощью `str` или `stm` вместо `push`. Это позволяет осуществить всю работу с указателем стека в исходном прологе функции.

Пример упакованной со сжатием функции необходимо разделить на три региона, которые в комментариях помечены как A, B и C. Первый регион A охватывает начало функции до конца сохранения дополнительных неизменяемых регистров. Необходимо создать запись .PDATA или .XDATA, чтобы описать этот фрагмент как имеющий пролог и не имеющий эпилогов.

Средний регион B получает собственную запись .PDATA или .XDATA, описывающую его как фрагмент без пролога и эпилога. Однако коды очистки для этого региона все равно должны присутствовать, так как он считается телом функции. Коды должны описывать составной пролог, представляющий как исходные регистры, сохраненные в прологе региона A, так и дополнительные регистры, сохраненные перед входом в регион B, как если бы они были созданы одной последовательностью операций.

Сохранения регистров для региона B нельзя считать "внутренним прологом", так как составной пролог, описанный в регионе B, должен описывать как пролог региона A, так и дополнительные сохраненные регистры. Если бы фрагмент B был описан как имеющий пролог, коды очистки неявно учли бы его размер и у нас не было бы способа описать составной пролог с однозначным сопоставлением с кодами операций, которые сохраняют только дополнительные регистры.

Сохранения дополнительных регистров следует считать частью региона A, поскольку до их завершения составной пролог не дает точное описание состояния стека.

Последний регион C получает собственную запись .PDATA или .XDATA, описывающую его как фрагмент без пролога, но с эпилогом.

Если работу со стеком до входа в регион B можно ограничить одной инструкцией, можно воспользоваться альтернативным подходом.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatile registers
    sub    sp, sp, #0xE0     ; A: allocate minimal stack space up front
    ...                      ; A:
    push   {r4-r9}           ; A: save remaining non-volatiles
    ...                      ; B:
    pop    {r4-r9}           ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C: restore non-volatile registers
```

Основная идея заключается в том, что на каждой границе инструкций стек полностью согласован с кодами очистки для этого региона. Если очистка происходит до внутренней отправки в данном примере, она считается частью региона A, и только пролог этого региона не очищен. Если очистка происходит после внутренней отправки, он считается, что содержит частью региона B, который без пролога, но есть коды очистки, которые описывают внутренней отправки и исходный пролог из региона A. аналогичная логика для внутреннего извлечения.

### <a name="encoding-optimizations"></a>Оптимизации кодирования

Многообразие кодов очистки и наличие краткой и развернутой форм данных предоставляют множество возможностей для оптимизации кодирования в целях дальнейшего сокращения занимаемого места. При активном использовании этих методик можно сохранить нагрузку от описания функций и фрагментов с помощью кодов очистки на минимальном уровне.

Самый важный аспект оптимизации заключается в том, чтобы не перепутать границы пролога/эпилога для проведения очистки с логическими границами пролога/эпилога с точки зрения компилятора. Для повышения эффективности границы очистки можно сжать, сделав их более тесными. Например, пролог может содержать код после настройки стека для выполнения дополнительных проверок. Но после окончания всей работы со стеком кодировать дополнительные операции больше не нужно, поэтому все остальное из очищаемого пролога можно удалить.

Это же правило применяется и для длины функции. Если имеются данные, например пул литералов, относящиеся к эпилогу функции, их не следует включать в состав длины функции. Сжав функцию и оставив в ней только код, являющийся ее частью, вы значительно увеличите вероятность того, что эпилог будет находиться в самом конце и будет иметь компактный размер. Можно использовать запись .PDATA.

После сохранения указателя стека в другом регистре в прологе больше не нужно записывать дополнительные коды операций. Чтобы очистить функцию, прежде всего следует восстановить указатель стека из сохраненного регистра, чтобы последующие операции никак не повлияли на очистку.

Эпилоги с одной инструкцией вообще не нужно кодировать ни как области, ни как коды очистки. Если очистка производится до выполнения этой инструкции, то можно предположить, что такая очистка выполняется из тела функции, поэтому простого выполнения кодов очистки пролога будет достаточно. Если очистка производится после выполнение единственной инструкции, то по определению она относится к другому региону.

По той же причине в эпилогах с несколькими инструкциями не нужно кодировать первую инструкцию: если очистка производится до выполнения этой инструкции, полной очистки пролога будет достаточно. Если очистка производится после такой инструкции, то следует учитывать только последующие операции.

Следует активно использовать коды очистки повторно. Индекс, заданный каждой областью эпилога, указывает на произвольную начальную точку в массиве кодов очистки. Он совершенно свободно может указывать не на начало предыдущей последовательности, а на ее середину. Оптимальный подход заключается в создании требуемой последовательности кодов с последующим поиском точного побайтового совпадения в уже закодированном пуле последовательностей и использованием найденного совпадения в качестве начальной точки для повторного использования.

Если после пропуска эпилогов с одной инструкцией эпилогов не остается, рекомендуется использовать краткую форму .PDATA; она становится еще актуальнее при полном отсутствии эпилогов.

## <a name="examples"></a>Примеры

В этих примерах база образа находится в 0x00400000.

### <a name="example-1-leaf-function-no-locals"></a>Пример 1: Конечная функция, не "Локальные"

```asm
Prologue:
  004535F8: B430      push        {r4-r5}
Epilogue:
  00453656: BC30      pop         {r4-r5}
  00453658: 4770      bx          lr
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Начало функции RVA* = 0x000535F8 (= 0x004535F8-0x00400000)

- Слово 1

   - *Флаг* = 1, указывающее, канонические форматы пролога и эпилога

   - *Функция длина* = 0x31 (= 0x62/2)

   - *Возвращаемое значение* = 1, указывает возвращаемое 16-разрядного ветвления

   - *H* = 0, указывающее, параметры не помещены

   - *R*= 0 и *Reg* = 1, указывает на отправку/извлечение для r4 — r5

   - *L* = 0, указывает без сохранения/восстановления LR

   - *C* = 0, указывает на отсутствие цепочки кадров.

   - *Настройка стека* = 0, указывает на отсутствие подстройки стека.

### <a name="example-2-nested-function-with-local-allocation"></a>Пример 2: Вложенная функция с локальным выделением

```asm
Prologue:
  004533AC: B5F0      push        {r4-r7, lr}
  004533AE: B083      sub         sp, sp, #0xC
Epilogue:
  00453412: B003      add         sp, sp, #0xC
  00453414: BDF0      pop         {r4-r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Начало функции RVA* = 0x000533AC (= 0x004533AC — 0x00400000)

- Слово 1

   - *Флаг* = 1, указывающее, канонические форматы пролога и эпилога

   - *Функция длина* = 0x35 (= 0x6A/2)

   - *RET* = 0, указывает извлечения {pc} возвращаемого значения

   - *H* = 0, указывающее, параметры не помещены

   - *R*= 0 и *Reg* = 3, указывает на отправку/извлечение для r4 — r7

   - *L* = 1, указывающее, LR сохранения/восстановления

   - *C* = 0, указывает на отсутствие цепочки кадров.

   - *Настройка стека* = 3 (= 0x0C/4)

### <a name="example-3-nested-variadic-function"></a>Пример 3. Вложенная функция с переменным числом аргументов

```asm
Prologue:
  00453988: B40F      push        {r0-r3}
  0045398A: B570      push        {r4-r6, lr}
Epilogue:
  004539D4: E8BD 4070 pop         {r4-r6}
  004539D8: F85D FB14 ldr         pc, [sp], #0x14
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Начало функции RVA* = 0x00053988 (= 0x00453988-0x00400000)

- Слово 1

   - *Флаг* = 1, указывающее, канонические форматы пролога и эпилога

   - *Функция длина* = 0x2A (= 0x54/2)

   - *RET* = 0, указывает извлечения {pc}-стиля return (в этом случае ПК ldr [sp] #0x14 возвратить)

   - *H* = 1, указывающее параметры были адресацией

   - *R*= 0 и *Reg* = 2, указывает на отправку/извлечение для r4 — r6

   - *L* = 1, указывающее, LR сохранения/восстановления

   - *C* = 0, указывает на отсутствие цепочки кадров.

   - *Настройка стека* = 0, указывает на отсутствие подстройки стека.

### <a name="example-4-function-with-multiple-epilogues"></a>Пример 4. Функция с несколькими Эпилогами

```asm
Prologue:
  004592F4: E92D 47F0 stmdb       sp!, {r4-r10, lr}
  004592F8: B086      sub         sp, sp, #0x18
Epilogues:
  00459316: B006      add         sp, sp, #0x18
  00459318: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  0045943E: B006      add         sp, sp, #0x18
  00459440: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  004595D4: B006      add         sp, sp, #0x18
  004595D6: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459606: B006      add         sp, sp, #0x18
  00459608: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459636: F028 FF0F bl          KeBugCheckEx     ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Начало функции RVA* = 0x000592F4 (= 0x004592F4-0x00400000)

- Слово 1

   - *Флаг* = 0, указывает на наличие записи .xdata (требуется нескольких эпилогов)

   - *адрес .xdata* -0x00400000

.XDATA (переменная, 6 слов):

- Слово 0

   - *Функция длина* = 0x0001A3 (= 0x000346/2)

   - *Vers* = 0, указывает первую версию .XData

   - *X* = 0, указывает на отсутствие данных об исключении

   - *E* = 0, указывает на список областей эпилогов

   - *F* = 0, указывает на полное описание функции, включая пролог.

   - *Число эпилогов* = 0x04, указывающее, 4 общее число областей эпилогов

   - *Код слова* = 0x01, указывает на одно 32-разрядное слово кодов очистки.

- Слова 1—4, описывающие 4 области эпилогов в 4 расположениях. Каждая область имеет общий набор кодов очистки, который используется совместно с прологом, имеет смещение 0x00 и является безусловным — задано условие 0x0E ("всегда").

- Коды очистки, начиная со слова 5: (используются совместно прологом и эпилогом).

   - Код очистки 0 = 0x06: sp += (6 << 2)

   - Код очистки 1 = 0xDE: pop {r4-r10, lr}.

   - Код очистки 2 = 0xFF: end.

### <a name="example-5-function-with-dynamic-stack-and-inner-epilogue"></a>Пример 5. Функция с динамическим стеком и внутренним эпилогом

```asm
Prologue:
  00485A20: B40F      push        {r0-r3}
  00485A22: E92D 41F0 stmdb       sp!, {r4-r8, lr}
  00485A26: 466E      mov         r6, sp
  00485A28: 0934      lsrs        r4, r6, #4
  00485A2A: 0124      lsls        r4, r4, #4
  00485A2C: 46A5      mov         sp, r4
  00485A2E: F2AD 2D90 subw        sp, sp, #0x290
Epilogue:
  00485BAC: 46B5      mov         sp, r6
  00485BAE: E8BD 41F0 ldm         sp!, {r4-r8, lr}
  00485BB2: B004      add         sp, sp, #0x10
  00485BB4: 4770      bx          lr
  ...
  00485E2A: F7FF BE7D b           #0x485B28    ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Начало функции RVA* = 0x00085A20 (= 0x00485A20-0x00400000)

- Слово 1

   - *Флаг* = 0, указывает на наличие записи .xdata (требуется нескольких эпилогов)

   - *адрес .xdata* -0x00400000

.XDATA (переменная, 3 слов):

- Слово 0

   - *Функция длина* = 0x0001A3 (= 0x000346/2)

   - *Vers* = 0, указывает первую версию .XData

   - *X* = 0, указывает на отсутствие данных об исключении

   - *E* = 0, указывает на список областей эпилогов

   - *F* = 0, указывает на полное описание функции, включая пролог.

   - *Число эпилогов* = 0x001, указывающая область 1 общее эпилога

   - *Код слова* = 0x01, указывает на одно 32-разрядное слово кодов очистки.

- Word 1: Область эпилога со смещением 0xC6 (= 0x18C/2), начальным индексом кода очистки 0x00 и условием 0x0E ("всегда")

- Коды очистки, начиная со слова 2: (используются совместно прологом и эпилогом).

   - Код очистки 0 = 0xC6: sp = r6.

   - Код очистки 1 = 0xDC: pop {r4-r8, lr}.

   - Код очистки 2 = 0x04: sp += (4 << 2)

   - Код очистки 3 = 0xFD: end, засчитывается как 16-разрядная инструкция для эпилога.

### <a name="example-6-function-with-exception-handler"></a>Пример 6. Функция с обработчиком исключений

```asm
Prologue:
  00488C1C: 0059 A7ED dc.w  0x0059A7ED
  00488C20: 005A 8ED0 dc.w  0x005A8ED0
FunctionStart:
  00488C24: B590      push        {r4, r7, lr}
  00488C26: B085      sub         sp, sp, #0x14
  00488C28: 466F      mov         r7, sp
Epilogue:
  00488C6C: 46BD      mov         sp, r7
  00488C6E: B005      add         sp, sp, #0x14
  00488C70: BD90      pop         {r4, r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Начало функции RVA* = 0x00088C24 (= 0x00488C24-0x00400000)

- Слово 1

   - *Флаг* = 0, указывает на наличие записи .xdata (требуется нескольких эпилогов)

   - *адрес .xdata* -0x00400000

.XDATA (переменная, 5 слов):

- Слово 0

   - *Функция длина* = 0x000027 (= 0x00004E/2)

   - *Vers* = 0, указывает первую версию .XData

   - *X* = 1, указывает наличие данных об исключении

   - *E* = 1, указывает на отдельный эпилог.

   - *F* = 0, указывает на полное описание функции, включая пролог.

   - *Число эпилогов* = 0x00, указывающее, коды очистки эпилога начинаются со смещения 0x00

   - *Код слова* = 0x02, указывает на два 32-разрядных слова кодов очистки.

- Коды очистки, начиная со слова 1.

   - Код очистки 0 = 0xC7: sp = r7.

   - Код очистки 1 = 0x05: sp += (5 << 2).

   - Код очистки 2 = 0xED/0x90: pop {r4, r7, lr}.

   - Код очистки 4 = 0xFF: end.

- Слово 3 указывает обработчик исключений = 0x0019A7ED (= 0x0059A7ED - 0x00400000)

- Слова с 4 и выше являются встроенными данными об исключении.

### <a name="example-7-funclet"></a>Пример 7. Библиотека Funclet

```asm
Function:
  00488C72: B500      push        {lr}
  00488C74: B081      sub         sp, sp, #4
  00488C76: 3F20      subs        r7, #0x20
  00488C78: F117 0308 adds        r3, r7, #8
  00488C7C: 1D3A      adds        r2, r7, #4
  00488C7E: 1C39      adds        r1, r7, #0
  00488C80: F7FF FFAC bl          target
  00488C84: B001      add         sp, sp, #4
  00488C86: BD00      pop         {pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Начало функции RVA* = 0x00088C72 (= 0x00488C72-0x00400000)

- Слово 1

   - *Флаг* = 1, указывающее, канонические форматы пролога и эпилога

   - *Функция длина* = 0x0B (= 0x16/2)

   - *RET* = 0, указывает извлечения {pc} возвращаемого значения

   - *H* = 0, указывающее, параметры не помещены

   - *R*= 0 и *Reg* = 7, показывающее, нет регистрах были сохранения/восстановления

   - *L* = 1, указывающее, LR сохранения/восстановления

   - *C* = 0, указывает на отсутствие цепочки кадров.

   - *Настройка стека* = 1, указывает 1 подстройкой стека байтов × 4

## <a name="see-also"></a>См. также

[Обзор соглашений ABI ARM](overview-of-arm-abi-conventions.md)<br/>
[Общие вопросы использования Visual C++ ARM](common-visual-cpp-arm-migration-issues.md)
