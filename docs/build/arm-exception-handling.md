---
title: Обработка исключений ARM
ms.date: 07/11/2018
ms.assetid: fe0e615f-c033-4ad5-97f4-ff96af45b201
ms.openlocfilehash: a3d1a5f3becefc064c5bb38dc566892ae8da8530
ms.sourcegitcommit: fcb48824f9ca24b1f8bd37d647a4d592de1cc925
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/15/2019
ms.locfileid: "69493368"
---
# <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows на ARM использует один механизм структурированной обработки исключений для асинхронных аппаратных и синхронных программных исключений. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. В этом документе описывается обработка исключений в Windows на ARM и вспомогательные методы языка, используемые кодом, создаваемым ассемблером Microsoft ARM и компилятором КОМПИЛЯТОРОМ MSVC.

## <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows в ARM использует *коды очистки* для управления очисткой стека во время [структурированной обработки исключений](/windows/win32/debug/structured-exception-handling) (SEH). Коды очистки представляют собой последовательность байт, хранимых в разделе .XDATA исполняемого образа. Они отвлеченно описывают работу кода пролога и эпилога функции, чтобы можно было нейтрализовать воздействие пролога функции во время подготовки к очистке кадра стека вызывающего объекта.

Встроенный двоичный интерфейс приложения ARM EABI задает модель очистки исключения, использующую коды очистки, однако SEH этого недостаточно для выполнения очистки в Windows, так как требуется обрабатывать асинхронные случаи, когда процессор находится в середине пролога или эпилога функции. Windows также разделяет управление очисткой на очистку функционального уровня и очистку языковой области, которая унифицирована в ARM EABI. По этим причинам Windows на ARM указывает больше сведений о данных и процедуре очистки.

### <a name="assumptions"></a>Допущения

Исполняемые образы для Windows на ARM используют формат переносимого исполняемого файла (PE). Дополнительные сведения см. в [статье Спецификация Microsoft PE и COFF](https://go.microsoft.com/fwlink/p/?linkid=84140). Информация об обработке исключений хранится в разделах .PDATA и .XDATA образа.

Механизм обработки исключений делает определенные предположения о коде, который соответствует двоичному интерфейсу приложения для Windows на ARM.

- При возникновении исключения в теле функции не имеет никакого значения, выполнены ли операции пролога или операции эпилога выполняются с опережением. Оба случая должны давать одинаковые результаты.

- Прологи и эпилоги стремятся зеркально отображать друг друга. Это можно использовать для сокращения объема метаданных, требуемых для описания очистки.

- Функции имеют относительно небольшой размер. На этом основано несколько оптимизаций для более эффективной упаковки данных.

- Если условие ставится в эпилоге, оно в равной степени применяется ко всем инструкциям эпилога.

- Если в прологе указатель стека (SP) сохраняется в другом регистре, этот регистр должен оставаться неизменным в течение всего времени работы функции, чтобы исходный указатель стека можно было получить в любое время.

- Если только указатель стека не сохранен в другом регистре, все операции с ним должны производиться исключительно в пределах пролога и эпилога.

- Для очистки кадра стека необходимо выполнить следующие операции.

  - Скорректируйте r13 (SP) с 4-байтными приращениями.

  - Извлеките один или несколько целочисленных регистров.

  - Извлеките один или несколько регистров VFP (виртуальные операции с плавающей запятой).

  - Скопируйте значение произвольного регистра в r13 (SP).

  - Загрузите указатель стека из стека с помощью небольшой постдекрементной операции.

  - Произведите анализ одного из нескольких четко заданных типов кадров.

### <a name="pdata-records"></a>Записи .PDATA

Записи .PDATA в образе формата PE представляют собой упорядоченный массив с элементами фиксированной длины, которые описывают каждую работающую со стеком функцию. Конечным функциям, которые не вызывают другие функции, записи .PDATA не требуются, если только они не работают со стеком. (Таким образом, им не требуется локальное хранилище и не нужно сохранять или восстанавливать неизменяемые регистры.) Для экономии места записи для таких функций в разделе .PDATA можно опускать. Операция очистки из одной из таких функций может просто скопировать адрес возврата из регистра связи (LR) в счетчик команд (PC) для перемещения к вызывающему объекту.

Каждая запись .PDATA для ARM имеет длину 8 байт. Общий формат записи имеет следующий вид: относительный виртуальный адрес (RVA) в начале функции в первом 32-битном слове, после которого идет второе слово с указателем на блок .XDATA переменной длины или упакованным словом, описывающим каноническую последовательность очистки функции, как показано в следующей таблице.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*Начальный RVA функции* — это 32-разрядный RVA начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0—1|*Флаг* — это 2-битовое поле, которое указывает, как интерпретировать оставшиеся 30 бит второго слова. pData. Если *флаг* имеет значение 0, остальные биты формируют *RVA сведений об исключении* (с низкими двумя битами неявно 0). Если *флаг* не равен нулю, остальные биты формируют упакованную структуру *данных очистки* .|
|1|2—31|*Сведения об исключении RVA* или *Упакованные данные*раскрутки.<br /><br /> *RVA сведений об исключении* — это адрес структуры сведений об исключении переменной длины, хранящейся в разделе. XData. Эти данные должны быть выровнены по 4-байтовой границе.<br /><br /> *Упакованные данные* раскрутки — это сжатое описание операций, необходимых для очистки от функции при условии канонической формы. В этом случае запись .XDATA не требуется.|

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для функций, прологи и эпилоги которых соответствуют описанной ниже канонической форме, можно использовать упакованные данные очистки. Это устраняет потребность в записи .XDATA и значительно сокращает требования к месту для предоставления данных очистки. Канонические прологи и эпилоги предназначены для удовлетворения общих требований простой функции, которая не требует обработчика событий и выполняет операции настройки и удаления в стандартном порядке.

В этой таблице показан формат записи .PDATA, содержащей упакованные данные очистки.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*Начальный RVA функции* — это 32-разрядный RVA начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0—1|*Флаг* — это 2-битовое поле, которое имеет следующие значения:<br /><br />-00 = Упакованные данные очистки не используются; остальные биты указывают на запись. XData.<br />-01 = Упакованные данные очистки.<br />-10 = Упакованные данные очистки, в которых предполагается, что функция не имеет пролога. Это удобно для описания фрагментов функции, которые разобщены с началом функции.<br />-11 = зарезервировано.|
|1|2—12|*Длина функции* — это 11-разрядное поле, которое предоставляет длину всей функции в байтах, деленную на 2. Если размер функции больше 4 КБ, следует использовать полную запись .XDATA.|
|1|13—14|*RET* — это 2-битовое поле, которое показывает, как функция возвращает:<br /><br />-00 = возврат через POP {PC} (бит флага *L* должен иметь значение 1 в этом случае).<br />-01 = Возврат с использованием 16-разрядной ветви.<br />-10 = возврат с использованием 32-разрядной ветви.<br />-11 = вообще нет эпилога. Это удобно для описания разобщенного фрагмента функции, который может содержать только пролог, однако его эпилог находится в другом месте.|
|1|15|*H* — это 1-разрядный флаг, указывающий, регистрируется ли функция "домов" целочисленного параметра (R0-R3), помещая их в начале функции, и освобождает 16 байт стека перед возвратом. (0 = не помещает в начальное расположение, 1 = помещает в начальное расположение.)|
|1|16—18|*Reg* — это 3-битовое поле, которое указывает индекс последнего сохраненного регистра. Если бит *R* равен 0, то сохраняются только целочисленные регистры, и они считаются в диапазоне от R4-RN, где N равно 4 + *reg*. Если бит *R* равен 1, то сохраняются только регистры с плавающей запятой и предполагается, что они находятся в диапазоне D8-DN, где N равно 8 + *reg*. Специальная комбинация *R* = 1 и *reg* = 7 означает, что регистры не сохраняются.|
|1|19|*R* — это 1-разрядный флаг, указывающий, являются ли сохраненные регистры без временных регистрами (0) или регистрами с плавающей запятой (1). Если *R* имеет значение 1, а поле *reg* имеет значение 7, непостоянные регистры не были отправлены.|
|1|20|*L* — 1-разрядный флаг, который указывает, сохраняет ли функция LR, а также другие регистры, указанные в поле *reg* . (0 = не сохраняет/восстанавливает, 1 = сохраняет/восстанавливает.)|
|1|21|*C* — 1-разрядный флаг, указывающий, включает ли функция дополнительные инструкции по настройке цепочки кадров для быстрого прохода стека (1) или нет (0). Если этот бит задан, r11 неявно добавляется в список сохраняемых неизменяемых регистров для целочисленных операций. (См. ограничения ниже, если используется флаг *C* .)|
|1|22—31|*Настройка стека* — это 10-разрядное поле, которое указывает число байтов стека, выделенных для этой функции, деленное на 4. Однако напрямую возможно кодирование лишь значений из диапазона 0x000—0x3F3. Функции, выделяющие более 4044 байт стека, должны использовать полную запись .XDATA. Если поле *настройки стека* имеет значение размер 0x3f4 или больше, то младшие 4 бита имеют особое значение:<br /><br />-Разрядность 0-1 указывает количество слов в настройке стека (1-4) минус 1.<br />-Бит 2 имеет значение 1, если в прологе была объединена Эта корректировка в операцию принудительной отправки.<br />-Бит 3 имеет значение 1, если эпилога объединила эту корректировку в операцию POP.|

В связи с возможным дублированием в описанном выше кодировании применяются следующие ограничения.

- Если флаг *C* имеет значение 1:

   - Флаг *L* также должен иметь значение 1, так как для цепочки кадров требуется как R11, так и LR.

   - R11 не должен включаться в набор регистров, описанных в *reg*. То есть если в R4-R11 были отправлены, *reg* должен описывать только R4-R10, поскольку флаг *C* подразумевает R11.

- Если поле *RET* имеет значение 0, то флагу *L* должно быть присвоено значение 1.

Нарушение этих ограничений ведет к неподдерживаемой последовательности операций.

В приведенном ниже примере показано, что два псевдо-флага являются производными от *настройки стека*.

- *PF* или "сворачивание пролога" указывает , что для стека задано значение размер 0x3f4 или больше, а для второго — 2.

- *EF* или «эпилога сворачивание» указывает, что параметр *Stack* Set имеет значение размер 0x3f4 или больше, а бит 3 установлен.

Прологи для канонических функций могут иметь до 5 инструкций (обратите внимание, что 3а и 3б являются взаимоисключающими).

|Инструкция|Предполагается наличие кода операции, если|Size|Код операции|Коды очистки|
|-----------------|-----------------------------------|----------|------------|------------------|
|1|*H*= = 1|16|`push {r0-r3}`|04|
|2|*C*= = 1 или *L*= = 1 или *R*= = 0 или PF = = 1|16/32|`push {registers}`|80—BF/D0—DF/EC—ED|
|3а|*C*= = 1 и (*L*= = 0 и *R*= = 1 и PF = = 0)|16|`mov r11,sp`|C0—CF/FB|
|3б|*C*= = 1 и (*L*= = 1 или *R*= = 0 или PF = = 1)|32|`add r11,sp,#xx`|FC|
|4|*R*= = 1 и *reg* ! = 7|32|`vpush {d8-dE}`|E0—E7|
|5|*Stack регулировка* ! = 0 и PF = = 0|16/32|`sub sp,sp,#xx`|00—7F/E8—EB|

Инструкция 1 всегда отображается, если бит *H* имеет значение 1.

Чтобы настроить цепочку кадров, имеется инструкция 3a или 3b, если установлен бит *C* . Это 16-разрядная `mov`, если отправляются только регистры r11 и LR; в противном случае это 32-разрядная `add`.

Если указана подстройка без свертывания, инструкция 5 является явной подстройкой стека.

Инструкции 2 и 4 задаются с учетом того, требуется ли отправка. В этой таблице приведены сведения о том, какие регистры сохраняются на основе полей *C*, *L*, *R*и *PF* . Во всех случаях *N* равно *reg* + 4, *E* равно *reg* + 8, а *S* равно (~*Stack корректировка*) & 3.

|В|L|R|PF|Отправленные целочисленные регистры|Отправленные регистры VFP|
|-------|-------|-------|--------|------------------------------|--------------------------|
|0|0|0|0|R4-r*N*|none|
|0|0|0|1|r*S*-r*N*|none|
|0|0|1|0|none|D8-d*E*|
|0|0|1|1|r*S*— R3|D8-d*E*|
|0|1|0|0|R4-r*N*, LR|none|
|0|1|0|1|r*S*-r*N*, LR|none|
|0|1|1|0|LR|D8-d*E*|
|0|1|1|1|r*S*-R3, LR|D8-d*E*|
|1|0|0|0|R4-r*N*, R11|none|
|1|0|0|1|r*S*-r*N*, R11|none|
|1|0|1|0|r11|D8-d*E*|
|1|0|1|1|r*S*-R3, R11|D8-d*E*|
|1|1|0|0|R4-r*N*, R11, LR|none|
|1|1|0|1|r*S*-r*N*, R11, LR|none|
|1|1|1|0|r11, LR|D8-d*E*|
|1|1|1|1|r*S*-R3, R11, LR|D8-d*E*|

Эпилоги для канонических функций имеют аналогичную форму, однако с обратным порядком и дополнительными параметрами. Эпилог может иметь длину до 5 инструкций, а его форма жестко определяется формой пролога.

|Инструкция|Предполагается наличие кода операции, если|Size|Код операции|
|-----------------|-----------------------------------|----------|------------|
|6|*Настройка стека*! = 0 и *EF*= = 0|16/32|`add   sp,sp,#xx`|
|7|*R*= = 1 и *reg*! = 7|32|`vpop  {d8-dE}`|
|8|*C*= = 1 или (*L*= = 1 и *H*= = 0) или *R*= = 0 или *EF*= = 1|16/32|`pop   {registers}`|
|9а|*H*= = 1 и *L*= = 0|16|`add   sp,sp,#0x10`|
|9б|*H*= = 1 и *L*= = 1|32|`ldr   pc,[sp],#0x14`|
|10а|*RET*= = 1|16|`bx    reg`|
|10б|*RET*= = 2|32|`b     address`|

Инструкция 6 является явной подстройкой стека, если указана подстройка без свертывания. Поскольку *PF* не зависит от *EF*, можно использовать инструкцию 5, которая не имеет инструкции 6 или наоборот.

Инструкции 7 и 8 используют ту же логику, что и Пролог, чтобы определить, какие регистры восстанавливаются из стека, но с этими двумя изменениями: сначала *EF* используется вместо *PF*; Во-вторых, если *RET* = 0, то LR заменяется на PC в списке регистров, а эпилога немедленно завершается.

Если задано значение *H* , то имеется либо инструкция 9A, либо 9Б. Инструкция 9a используется, если параметр *L* имеет значение 0, чтобы указать, что LR не находится в стеке. В этом случае стек корректируется вручную, а параметр *RET* должен иметь значение 1 или 2, чтобы указать явный возврат. Инструкция 9Б используется, если параметр *L* имеет значение 1, указывает на ранний конец эпилога, а также для возврата и корректировки стека одновременно.

Если эпилога еще не завершен, то используется либо инструкция 10A, либо 10b, чтобы указать 16-разрядную или 32-разрядную ветвь на основе значения *RET*.

### <a name="xdata-records"></a>Записи .XDATA

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись .XDATA переменной длины. Адрес этой записи хранится во втором слове записи .PDATA. Формат .XDATA представляет собой упакованный набор слов переменной длины, состоящий из четырех разделов.

1. Заголовок из 1 или 2 слов, описывающий общий размер структуры .XDATA и предоставляющий ключевые функциональные данные. Второе слово имеется только в том случае, если в полях *эпилога Count* и *Code Words* установлено значение 0. Эти поля описаны в следующей таблице.

   |Слово|Bits|Цель|
   |----------|----------|-------------|
   |0|0—17|*Длина функции* — это 18-разрядное поле, указывающее общую длину функции в байтах, деленную на 2. Если размер функции больше 512 КБ, для ее описания следует создать несколько записей .PDATA и .XDATA. Дополнительные сведения см. в разделе "Большие функции" настоящего документа.|
   |0|18—19|«Инверсия» — это 2-битовое поле, описывающее версию оставшегося XData. Сейчас определена только версия 0; значения 1—3 зарезервированы.|
   |0|20|*X* — это 1 битовое поле, которое указывает на присутствие (1) или отсутствие (0) данных исключения.|
   |0|21|*E* — это 1-битовое поле, указывающее, что сведения, описывающие один эпилога, упаковываются в заголовок (1), а не требуют дополнительных слов области позже (0).|
   |0|22|*F* — это 1 битовое поле, указывающее, что эта запись описывает фрагмент функции (1) или полную функцию (0). Если указан фрагмент, пролог отсутствует, поэтому его обработку можно проигнорировать.|
   |0|23—27|*Эпилога Count* — это 5-битовое поле, которое имеет два значения в зависимости от состояния бита *E* :<br /><br /> -Если значение *E* равно 0, это поле представляет собой общее число областей исключений, описанных в разделе 3. Если в функции существует более 31 области, то в этом поле и в поле *кода* Words должно быть задано значение 0, чтобы указать, что требуется расширение.<br />-Если значение *E* равно 1, в этом поле указывается индекс первого кода очистки, который описывает единственный эпилога.|
   |0|28—31|*Слова Code* — это 4-разрядное поле, которое указывает число 32-разрядных слов, которые должны содержать все коды очистки в разделе 4. Если для более чем 63 байт кода очистки требуется более 15 слов, это поле и поле *эпилога Count* должны иметь значение 0, чтобы указать, что требуется расширение слова.|
   |1|0—15|*Расширенное число эпилога* — это 16-разрядное поле, которое предоставляет больше пространства для кодирования необычного большого количества эпилоги. Слово расширения, содержащее это поле, доступно только в том случае, если поля *эпилога Count* и *Code* Word в первом заголовке имеют значение 0.|
   |1|16—23|*Слова расширенного кода* — это 8-битовое поле, которое предоставляет больше пространства для кодирования необычного большого количества слов кода очистки. Слово расширения, содержащее это поле, доступно только в том случае, если поля *эпилога Count* и *Code* Word в первом заголовке имеют значение 0.|
   |1|24—31|Зарезервированное|

1. После данных исключения (если бит *E* в заголовке был установлен равным 0) представляет собой список сведений об областях эпилога, упакованных в одно слово и сохраненных в порядке увеличения начального смещения. Каждая область содержит следующие поля.

   |Bits|Цель|
   |----------|-------------|
   |0—17|*Начальное смещение эпилога* — это 18-битовое поле, описывающее смещение эпилога (в байтах, деленное на 2) относительно начала функции.|
   |18—19|*RES* — это 2-битовое поле, зарезервированное для будущего расширения. Оно должно иметь значение 0.|
   |20—23|*Condition* — это 4-битовое поле, которое дает условие, при котором выполняется эпилога. Для безусловных эпилогов в нем следует задать значение 0xE, которое означает "всегда". (Эпилог должен быть полностью условным или полностью безусловным, а в режиме Thumb-2 эпилог начинается с первой инструкции после кода операции IT.)|
   |24—31|*Эпилога начальный индекс* — это 8-битовое поле, указывающее байтовый индекс первого кода очистки, который описывает этот эпилога.|

1. После списка областей эпилога идет массив с кодами очистки, которые подробно описаны в разделе "Коды очистки" данной статьи. Этот массив дополняется в конец ближайшей границы полного слова. Байты хранятся с прямым порядком, чтобы их можно было напрямую получать в соответствующем режиме.

1. Если поле *X* в заголовке равно 1, за байтами кода очистки следуют сведения об обработчике исключений. Это состоит из одного *RVA обработчика исключений* , который содержит адрес обработчика исключений, за которым следует значение (переменной длины) данных, необходимых обработчику исключений.

Запись .XDATA спроектирована таким образом, что можно получить первые 8 байт и вычислить полный размер записи без учета размера последующих данных об исключении, имеющих переменную длину. Этот фрагмент кода вычисляет размер записи:

```cpp
ULONG ComputeXdataSize(PULONG *Xdata)
{
    ULONG EpilogueScopes;
    ULONG Size;
    ULONG UnwindWords;

    if ((Xdata[0] >> 23) != 0) {
        Size = 4;
        EpilogueScopes = (Xdata[0] >> 23) & 0x1f;
        UnwindWords = (Xdata[0] >> 28) & 0x0f;
    } else {
        Size = 8;
        EpilogueScopes = Xdata[1] & 0xffff;
        UnwindWords = (Xdata[1] >> 16) & 0xff;
    }

    if (!(Xdata[0] & (1 << 21))) {
        Size += 4 * EpilogueScopes;
    }
    Size += 4 * UnwindWords;
    if (Xdata[0] & (1 << 20)) {
        Size += 4;
    }
    return Size;
}
```

Несмотря на то, что в прологе и каждом эпилога есть индекс в кодах очистки, к ним применяется Общая таблица. Довольно распространена ситуация, когда все они используют совместно одинаковые коды очистки. Мы рекомендуем разработчикам компилятора предусмотреть оптимизацию такого случая, так как самый большой индекс, который можно указать, равен 255, что ограничивает общее возможное число кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет собой пул последовательностей инструкций, описывающий, как устранить влияние пролога, и содержащий операции в порядке их отмены. Коды очистки представляют собой мининаборы инструкций, закодированные в виде строки байтов. После окончания выполнения адрес возврата в вызывающую функцию находится в регистре LR, а для всех неизменяемых регистров восстанавливаются значения, актуальные на момент вызова функции.

Если бы существовала уверенность в том, что исключения возникают только в теле функции и никогда не возникают в прологе или эпилоге, потребовалась бы всего одна последовательность очистки. Однако модель очистки Windows требует наличия возможности выполнения очистки из частично выполненного пролога или эпилога. Чтобы выполнить это требование, коды очистки были тщательно спроектированы для обеспечения однозначного сопоставления с каждым соответствующим кодом операции в прологе и эпилоге. Эта особенность имеет несколько разных применений.

- Можно вычислить длину пролога и эпилога, сосчитав число кодов очистки. Это возможно даже при инструкциях переменной длины в режиме Thumb-2, так как имеются четкие сопоставления для 16- и 32-разрядных кодов операций.

- Считая число инструкций после начала области эпилога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы завершить частично выполненную очистку, произведенную эпилогом.

- Считая число инструкций до окончания пролога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы отменить только те части пролога, выполнение которых завершилось.

В приведенной ниже таблице показано сопоставление кодов очистки с кодами операций. Наиболее распространены коды длиной в один байт, реже попадаются коды из двух, трех и даже четырех байт. Каждый код хранится от старшего байта к младшему. Структура кода очистки отличается от кодировки, описанной в стандартном встроенном двоичном интерфейсе приложения ARM, так как эти коды очистки рассчитаны на наличие однозначного сопоставления с кодами операций в прологе и эпилоге, что делает возможной очистку частично выполненных прологов и эпилогов.

|Байт 1|Байт 2|Байт 3|Байт 4|Размер операции|Объяснение|
|------------|------------|------------|------------|------------|-----------------|
|00—7F||||16|`add   sp,sp,#X`<br /><br /> где X — (код & 0x7F) \* 4|
|80—BF|00—FF|||32|`pop   {r0-r12, lr}`<br /><br /> где LR извлекается при извлечении кода & 0x2000 и R0-R12, если соответствующий бит задан в коде & 0x1FFF|
|C0—CF||||16|`mov   sp,rX`<br /><br /> где X — код & 0x0F|
|D0—D7||||16|`pop   {r4-rX,lr}`<br /><br /> где X имеет значение (Code & 0x03) + 4 и LR извлекается, если код & 0x04|
|D8—DF||||32|`pop   {r4-rX,lr}`<br /><br /> где X имеет значение (Code & 0x03) + 8 и LR извлекается, если код & 0x04|
|E0—E7||||32|`vpop  {d8-dX}`<br /><br /> Где X равен (код & 0x07) + 8.|
|E8—EB|00—FF|||32|`addw  sp,sp,#X`<br /><br /> где X — (Code & 0x03FF) \* 4|
|EC—ED|00—FF|||16|`pop   {r0-r7,lr}`<br /><br /> где LR извлекается при извлечении кода & 0x0100 и R0-R7, если соответствующий бит задан в коде & 0x00FF|
|EE|00—0F|||16|Специально для систем Майкрософт|
|EE|10—FF|||16|Доступно|
|EF|00—0F|||32|`ldr   lr,[sp],#X`<br /><br /> где X — (Code & 0x000F) \* 4|
|EF|10—FF|||32|Доступно|
|F0—F4||||-|Доступно|
|F5|00—FF|||32|`vpop  {dS-dE}`<br /><br /> где S — (Code & 0x00F0) > > 4 и E — код & 0x000F|
|F6|00—FF|||32|`vpop  {dS-dE}`<br /><br /> где S — ((Code & 0x00F0) > > 4) + 16 и E — (Code & 0x000F) + 16|
|F7|00—FF|00—FF||16|`add   sp,sp,#X`<br /><br /> где X — (Code & 0x00FFFF) \* 4|
|F8|00—FF|00—FF|00—FF|16|`add   sp,sp,#X`<br /><br /> где X — (Code & 0x00FFFFFF) \* 4|
|F9|00—FF|00—FF||32|`add   sp,sp,#X`<br /><br /> где X — (Code & 0x00FFFF) \* 4|
|FA|00—FF|00—FF|00—FF|32|`add   sp,sp,#X`<br /><br /> где X — (Code & 0x00FFFFFF) \* 4|
|FB||||16|nop (16-разрядный)|
|FC||||32|nop (32-разрядный)|
|FD||||16|end + 16-разрядный nop в эпилоге|
|FE||||32|end + 32-разрядный nop в эпилоге|
|FF||||-|end|

Он показывает диапазон шестнадцатеричных значений для каждого байта в *коде*кода очистки, а также код операции *опсизе* и соответствующую исходную интерпретацию инструкций. Пустые ячейки обозначают более короткие коды очистки. В инструкциях с большими значениями, охватывающими несколько байт, старшие биты сохраняются первыми. В поле *опсизе* показан неявный размер кода операции, связанный с каждой операцией Thumb-2. Видимые повторяющиеся записи в таблице с разными кодировками помогают различить разные размеры кодов операций.

Коды очистки спроектированы таким образом, что первый байт кода сообщает как общий размер кода в байтах, так и размер соответствующего кода операции в потоке инструкций. Чтобы вычислить размер пролога или эпилога, выполните проход по кодам очистки от начала и до конца последовательности и воспользуйтесь таблицей подстановки или аналогичным методом, чтобы определить длину соответствующего кода операции.

Коды очистки 0xFD и 0xFE эквивалентны обычному коду end 0xFF, однако имеют один дополнительный код операции nop в случае эпилога — 16- или 32-разрядный. Для прологов коды 0xFD, 0xFE и 0xFF полностью эквивалентны друг другу. Это дает нам общие окончания эпилога `bx lr` или `b <tailcall-target>`, для чего эквивалентная инструкция пролога отсутствует. Это повышает вероятность того, что последовательности очистки можно будет совместно использовать в прологе и эпилогах.

Во многих случаях для пролога и всех эпилогов можно использовать один набор кодов очистки. Однако для обработки очистки частично выполненных прологов может потребоваться несколько последовательностей кодов очистки, отличающихся порядком или поведением. Именно поэтому каждый эпилог имеет собственный индекс в массиве очистки, чтобы показать момент начала выполнения.

### <a name="unwinding-partial-prologues-and-epilogues"></a>Очистка частичных прологов и эпилогов

Наиболее распространенным случаем очистки является возникновение исключения в теле функции, не затрагивающее пролог и все эпилоги. В этом случае средство очистки выполняет коды в массиве очистки, начиная с индекса 0 и продолжая до обнаружения конечного кода операции.

Если исключение возникает во время выполнения пролога или эпилога, кадр стека создан лишь частично, поэтому средству очистки нужно определить, что именно было сделано, чтобы правильно отменить это.

Например, рассмотрим данную последовательность пролога и эпилога:

```asm
0000:   push  {r0-r3}         ; 0x04
0002:   push  {r4-r9, lr}     ; 0xdd
0006:   mov   r7, sp          ; 0xc7
...
0140:   mov   sp, r7          ; 0xc7
0142:   pop   {r4-r9, lr}     ; 0xdd
0146:   add   sp, sp, #16     ; 0x04
0148:   bx    lr
```

Рядом с каждым кодом операции находится подходящий код очистки для описания этой операции. Последовательность кодов очистки для пролога является зеркальным отображением кодов очистки для эпилога без учета последней инструкции. Это распространенный случай, и причина здесь заключается в том, что коды очистки всегда предполагается хранить в обратном порядке по сравнению с порядком выполнения пролога. Это дает нам общий набор кодов очистки:

```asm
0xc7, 0xdd, 0x04, 0xfd
```

Код 0xFD предназначен специально для конца последовательности, то есть эпилог на одну 16-разрядную инструкцию длиннее пролога. Это открывает широкие возможности для совместного использования кодов очистки.

Если в данном примере исключение возникает, пока выполняется тело функции между прологом и эпилогом, очистка начинается с эпилога с нулевым смещением в коде эпилога. В примере это соответствует смещению 0x140. Средство очистки выполняет полную последовательность освобождения, так как очистка не выполнялась. Если же исключение возникает на одну инструкцию после начала кода эпилога, средство очистки может успешно выполнить очистку, пропустив первый код очистки. При указании однозначного сопоставления между кодом операций и кодами очистки, при очистке из инструкции *n* в эпилога, в качестве первого из них должны пропускаться первые *n* кодов очистки.

Аналогичная логика работает и в обратном направлении для пролога. Если очистка осуществляется с нулевого смещения пролога, ничего выполнять не требуется. При осуществлении очистки с погружением на одну инструкцию последовательность очистки должна начаться с предпоследнего кода очистки, так как коды очистки пролога хранятся в обратном порядке. В общем случае, при очистке из инструкции *n* в прологе, в конце списка кодов должна начаться очистка от *n* кодов очистки.

Коды очистки пролога и эпилога не всегда совпадают полностью. В этом случае в массиве кодов очистки может потребоваться наличие нескольких последовательностей кодов. Чтобы определить смещение для начала обработки кодов, используйте следующую логику.

1. Если очистка выполняется из тела функции, начинайте выполнять коды очистки с индекса 0 и продолжайте до достижения конечного кода операции.

2. Если очистка выполняется из эпилога, используйте специальный начальный индекс эпилога, указанный в области эпилога. Вычислите, на сколько байт PC отстоит от начала эпилога. Пропустите такое число кодов очистки, которое соответствует уже выполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

3. Если очистка осуществляется из пролога, начните с индекса 0 в кодах очистки. Вычислите длину кода пролога из последовательности, а затем рассчитайте, на сколько байт PC отстоит от конца пролога. Пропустите такое число кодов очистки, которое соответствует невыполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

Коды очистки для пролога должны всегда стоять в массиве первыми. Именно эти коды используются для очистки в общем случае, когда очистка осуществляется из тела. Сразу после последовательности кода для пролога должны идти специальные последовательности для эпилога.

### <a name="function-fragments"></a>Фрагменты функции

В целях оптимизации кода может оказаться полезным разделить функцию на разобщенные части. После этого каждому фрагменту функции требуется своя собственная запись .PDATA, а возможно, и запись .XDATA.

Учитывая, что пролог находится в начале функции и не может быть разделен, существует четыре сценария фрагментов функции.

- Только пролог; все эпилоги в других фрагментах.

- Только пролог и один или несколько эпилогов; дополнительные эпилоги в других фрагментах.

- Без пролога и эпилогов; пролог и один или несколько эпилогов в других фрагментах.

- Только эпилоги; пролог и, возможно, дополнительные эпилоги в других фрагментах.

В первом сценарии описать требуется только пролог. Это можно сделать в виде Compact. pData, описывая Пролог в обычном режиме и указав значение *возврата* 3, чтобы не указывать эпилога. В полной форме .XDATA это можно сделать, предоставив коды очистки пролога как обычно с индексом 0 и указав число эпилогов равным 0.

Второй сценарий аналогичен обычной функции. Если во фрагменте присутствует только один эпилог, расположенный в конце фрагмента, можно использовать краткую запись .PDATA. В противном случае необходимо использовать полную запись .XDATA. Помните, что значения смещения, указанные для начала эпилога, заданы относительно начала фрагмента, а не исходного начала функции.

Третий и четвертый сценарии являются вариантами первого и второго сценариев соответственно, за исключением того, что в них нет пролога. В таких ситуациях предполагается, что перед началом эпилога имеется код и он считается частью тела функции, поэтому требует обычной очистки в виде устранения влияния пролога. В таких случаях требуется закодировать псевдопролог, который описывает, как выполнить очистку из тела, однако считается имеющим нулевую длину при определении потребности в частичной очистке в начале фрагмента. Кроме того, этот псевдопролог можно описать с помощью тех же кодов очистки, что и эпилог, так как они предположительно выполняют аналогичные операции.

В третьем и четвертом случаях наличие псевдо-пролога указывается либо путем установки поля флага в записи Compact. pData в значение 2, либо путем установки флага *F* в заголовке. XData в значение 1. В любом случае проверка потребности в частичной очистке пролога игнорируется, и все очистки, не относящиеся к эпилогу, считаются полными.

#### <a name="large-functions"></a>Большие функции

Фрагменты можно использовать для описания функций, размер которых превышает предел в 512 КБ, накладываемый битовыми полями в заголовке .XDATA. Чтобы описать очень большую функцию, просто разделите ее на фрагменты размером менее 512 КБ. Для каждого фрагмента требуется подстройка, чтобы он не разбивал эпилог на множество частей.

Только первый фрагмент функции содержит пролог, все остальные фрагменты помечаются как не содержащие пролог. В зависимости от числа эпилогов каждый фрагмент может содержать от нуля до нескольких эпилогов. Помните, что область каждого эпилога во фрагменте указывает начальное смещение относительно начала данного фрагмента, а не начала функции.

Если фрагмент не содержит ни пролог, ни эпилог, ему все равно требуется отдельная запись .PDATA и, возможно, запись .XDATA, чтобы описать очистку из тела функции.

#### <a name="shrink-wrapping"></a>Упаковка со сжатием

Более сложная разновидность фрагментов функций заключается в *переносе*, что позволяет отложить сохранение сохранения от начала функции до последующего в функции, чтобы оптимизировать для простых случаев, которые не нуждаются в сохранении регистра. Это можно представить себе как внешний регион, который выделяет место в стеке, но сохраняет минимальный набор регистров, и внутренний регион, который сохраняет и восстанавливает дополнительные регистры.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatiles
    sub    sp, sp, #0x100    ; A: allocate all stack space up front
    ...                      ; A:
    add    r0, sp, #0xE4     ; A: prepare to do the inner save
    stm    r0, {r5-r11}      ; A: save remaining non-volatiles
    ...                      ; B:
    add    r0, sp, #0xE4     ; B: prepare to do the inner restore
    ldm    r0, {r5-r11}      ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C:
```

Упакованные со сжатием функции чаще всего заранее выделяют место под сохранение дополнительных регистров в обычном прологе, а затем выполняют сохранения регистров с помощью `str` или `stm` вместо `push`. Это позволяет осуществить всю работу с указателем стека в исходном прологе функции.

Пример упакованной со сжатием функции необходимо разделить на три региона, которые в комментариях помечены как A, B и C. Первый регион A охватывает начало функции до конца сохранения дополнительных неизменяемых регистров. Необходимо создать запись .PDATA или .XDATA, чтобы описать этот фрагмент как имеющий пролог и не имеющий эпилогов.

Средний регион B получает собственную запись .PDATA или .XDATA, описывающую его как фрагмент без пролога и эпилога. Однако коды очистки для этого региона все равно должны присутствовать, так как он считается телом функции. Коды должны описывать составной пролог, представляющий как исходные регистры, сохраненные в прологе региона A, так и дополнительные регистры, сохраненные перед входом в регион B, как если бы они были созданы одной последовательностью операций.

Сохранения регистров для региона B нельзя считать "внутренним прологом", так как составной пролог, описанный в регионе B, должен описывать как пролог региона A, так и дополнительные сохраненные регистры. Если бы фрагмент B был описан как имеющий пролог, коды очистки неявно учли бы его размер и у нас не было бы способа описать составной пролог с однозначным сопоставлением с кодами операций, которые сохраняют только дополнительные регистры.

Сохранения дополнительных регистров следует считать частью региона A, поскольку до их завершения составной пролог не дает точное описание состояния стека.

Последний регион C получает собственную запись .PDATA или .XDATA, описывающую его как фрагмент без пролога, но с эпилогом.

Если работу со стеком до входа в регион B можно ограничить одной инструкцией, можно воспользоваться альтернативным подходом.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatile registers
    sub    sp, sp, #0xE0     ; A: allocate minimal stack space up front
    ...                      ; A:
    push   {r4-r9}           ; A: save remaining non-volatiles
    ...                      ; B:
    pop    {r4-r9}           ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C: restore non-volatile registers
```

Основная идея заключается в том, что на каждой границе инструкций стек полностью согласован с кодами очистки для этого региона. Если очистка происходит до внутренней отправки в данном примере, она считается частью региона A, и только пролог этого региона не очищен. Если очистка происходит после внутренней отправки, она считается частью региона б, который не имеет пролога, но содержит коды очистки, описывающие как внутреннюю отправку, так и исходный Пролог из региона а. Аналогичная логика для внутренней точки подключения.

### <a name="encoding-optimizations"></a>Оптимизации кодирования

Многообразие кодов очистки и наличие краткой и развернутой форм данных предоставляют множество возможностей для оптимизации кодирования в целях дальнейшего сокращения занимаемого места. При активном использовании этих методик можно сохранить нагрузку от описания функций и фрагментов с помощью кодов очистки на минимальном уровне.

Самый важный аспект оптимизации заключается в том, чтобы не перепутать границы пролога/эпилога для проведения очистки с логическими границами пролога/эпилога с точки зрения компилятора. Для повышения эффективности границы очистки можно сжать, сделав их более тесными. Например, пролог может содержать код после настройки стека для выполнения дополнительных проверок. Но после окончания всей работы со стеком кодировать дополнительные операции больше не нужно, поэтому все остальное из очищаемого пролога можно удалить.

Это же правило применяется и для длины функции. Если имеются данные, например пул литералов, относящиеся к эпилогу функции, их не следует включать в состав длины функции. Сжав функцию и оставив в ней только код, являющийся ее частью, вы значительно увеличите вероятность того, что эпилог будет находиться в самом конце и будет иметь компактный размер. Можно использовать запись .PDATA.

После сохранения указателя стека в другом регистре в прологе больше не нужно записывать дополнительные коды операций. Чтобы очистить функцию, прежде всего следует восстановить указатель стека из сохраненного регистра, чтобы последующие операции никак не повлияли на очистку.

Эпилоги с одной инструкцией вообще не нужно кодировать ни как области, ни как коды очистки. Если очистка производится до выполнения этой инструкции, то можно предположить, что такая очистка выполняется из тела функции, поэтому простого выполнения кодов очистки пролога будет достаточно. Если очистка производится после выполнение единственной инструкции, то по определению она относится к другому региону.

По той же причине в эпилогах с несколькими инструкциями не нужно кодировать первую инструкцию: если очистка производится до выполнения этой инструкции, полной очистки пролога будет достаточно. Если очистка производится после такой инструкции, то следует учитывать только последующие операции.

Следует активно использовать коды очистки повторно. Индекс, заданный каждой областью эпилога, указывает на произвольную начальную точку в массиве кодов очистки. Он совершенно свободно может указывать не на начало предыдущей последовательности, а на ее середину. Оптимальный подход заключается в создании требуемой последовательности кодов с последующим поиском точного побайтового совпадения в уже закодированном пуле последовательностей и использованием найденного совпадения в качестве начальной точки для повторного использования.

Если после пропуска эпилогов с одной инструкцией эпилогов не остается, рекомендуется использовать краткую форму .PDATA; она становится еще актуальнее при полном отсутствии эпилогов.

## <a name="examples"></a>Примеры

В этих примерах база образа находится в 0x00400000.

### <a name="example-1-leaf-function-no-locals"></a>Пример 1: Конечная функция, без локальных переменных

```asm
Prologue:
  004535F8: B430      push        {r4-r5}
Epilogue:
  00453656: BC30      pop         {r4-r5}
  00453658: 4770      bx          lr
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Start RVA для функции* = 0x000535F8 (= 0x004535F8-0x00400000)

- Слово 1

   - *Флаг* = 1, указывающий канонические форматы пролога и эпилога

   - *Длина функции* = 0x31 (= 0x62/2)

   - *RET* = 1, означающее возврат 16-разрядной ветви

   - *H* = 0, указывающий, что параметры не были размещены

   - *R*= 0 и *reg* = 1, указывающие на принудительную отправку или POP в R4-R5

   - *L* = 0, указывающее на отсутствие операций сохранения и восстановления LR

   - *C* = 0, указывающее, что цепочки кадров отсутствуют

   - *Stack корректируют* = 0, что означает отсутствие настройки стека

### <a name="example-2-nested-function-with-local-allocation"></a>Пример 2 Вложенная функция с локальным выделением

```asm
Prologue:
  004533AC: B5F0      push        {r4-r7, lr}
  004533AE: B083      sub         sp, sp, #0xC
Epilogue:
  00453412: B003      add         sp, sp, #0xC
  00453414: BDF0      pop         {r4-r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Start RVA для функции* = 0x000533AC (= 0x004533AC-0x00400000)

- Слово 1

   - *Флаг* = 1, указывающий канонические форматы пролога и эпилога

   - *Длина функции* = 0x35 (= 0x6A/2)

   - *RET* = 0, означающее возврат POP {PC}

   - *H* = 0, указывающий, что параметры не были размещены

   - *R*= 0 и *reg* = 3, указывающие на принудительную отправку или POP в R4-R7

   - *L* = 1, означающее, что LR был сохранен или восстановлен

   - *C* = 0, указывающее, что цепочки кадров отсутствуют

   - *Stack корректировка* = 3 (= 0x0C/4)

### <a name="example-3-nested-variadic-function"></a>Пример 3 Вложенная функция Variadic

```asm
Prologue:
  00453988: B40F      push        {r0-r3}
  0045398A: B570      push        {r4-r6, lr}
Epilogue:
  004539D4: E8BD 4070 pop         {r4-r6}
  004539D8: F85D FB14 ldr         pc, [sp], #0x14
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Start RVA для функции* = 0x00053988 (= 0x00453988-0x00400000)

- Слово 1

   - *Флаг* = 1, указывающий канонические форматы пролога и эпилога

   - *Длина функции* = 0x2A (= 0x54/2)

   - *RET* = 0, указывающий на возврат в стиле Pop {PC} (в данном случае это компьютер LDR, [SP], #0x14 Return)

   - *H* = 1, указывающее, что параметры были размещены

   - *R*= 0 и *reg* = 2, указывающие на принудительную отправку или POP в R4-R6

   - *L* = 1, означающее, что LR был сохранен или восстановлен

   - *C* = 0, указывающее, что цепочки кадров отсутствуют

   - *Stack корректируют* = 0, что означает отсутствие настройки стека

### <a name="example-4-function-with-multiple-epilogues"></a>Пример 4. Функция с несколькими эпилоги

```asm
Prologue:
  004592F4: E92D 47F0 stmdb       sp!, {r4-r10, lr}
  004592F8: B086      sub         sp, sp, #0x18
Epilogues:
  00459316: B006      add         sp, sp, #0x18
  00459318: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  0045943E: B006      add         sp, sp, #0x18
  00459440: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  004595D4: B006      add         sp, sp, #0x18
  004595D6: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459606: B006      add         sp, sp, #0x18
  00459608: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459636: F028 FF0F bl          KeBugCheckEx     ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Start RVA для функции* = 0x000592F4 (= 0x004592F4-0x00400000)

- Слово 1

   - *Флаг* = 0, указывающий на присутствие записи XData (требуется из-за нескольких эпилоги)

   - *. XData-адрес* — 0x00400000

.XDATA (переменная, 6 слов):

- Слово 0

   - *Длина функции* = 0x0001A3 (= 0x000346/2)

   - *Наоборот* = 0, указывающий первую версию XData

   - *X* = 0, указывающий на отсутствие данных исключения

   - *E* = 0, что означает список областей эпилога

   - *F* = 0, указывающее полное описание функции, включая Пролог

   - *Эпилога Count* = 0x04, указывающее 4 общего объема эпилога

   - *Кодовые слова* = 0x01, обозначающее 1 32-разрядное слово кодов очистки

- Слова 1—4, описывающие 4 области эпилогов в 4 расположениях. Каждая область имеет общий набор кодов очистки, который используется совместно с прологом, имеет смещение 0x00 и является безусловным — задано условие 0x0E ("всегда").

- Коды очистки, начиная со слова 5: (используются совместно прологом и эпилогом).

   - Код очистки 0 = 0x06: SP + = (6 < < 2)

   - Код очистки 1 = 0xDE: pop {r4-r10, lr}.

   - Код очистки 2 = 0xFF: end.

### <a name="example-5-function-with-dynamic-stack-and-inner-epilogue"></a>Пример 5. Функция с динамическим стеком и внутренним эпилога

```asm
Prologue:
  00485A20: B40F      push        {r0-r3}
  00485A22: E92D 41F0 stmdb       sp!, {r4-r8, lr}
  00485A26: 466E      mov         r6, sp
  00485A28: 0934      lsrs        r4, r6, #4
  00485A2A: 0124      lsls        r4, r4, #4
  00485A2C: 46A5      mov         sp, r4
  00485A2E: F2AD 2D90 subw        sp, sp, #0x290
Epilogue:
  00485BAC: 46B5      mov         sp, r6
  00485BAE: E8BD 41F0 ldm         sp!, {r4-r8, lr}
  00485BB2: B004      add         sp, sp, #0x10
  00485BB4: 4770      bx          lr
  ...
  00485E2A: F7FF BE7D b           #0x485B28    ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Start RVA для функции* = 0x00085A20 (= 0x00485A20-0x00400000)

- Слово 1

   - *Флаг* = 0, указывающий на присутствие записи XData (требуется из-за нескольких эпилоги)

   - *. XData-адрес* — 0x00400000

.XDATA (переменная, 3 слов):

- Слово 0

   - *Длина функции* = 0x0001A3 (= 0x000346/2)

   - *Наоборот* = 0, указывающий первую версию XData

   - *X* = 0, указывающий на отсутствие данных исключения

   - *E* = 0, что означает список областей эпилога

   - *F* = 0, указывающее полное описание функции, включая Пролог

   - *Эпилога Count* = 0x001, показывающее общую область эпилога

   - *Кодовые слова* = 0x01, обозначающее 1 32-разрядное слово кодов очистки

- Слово 1: Область эпилога по смещению 0xC6 (= 0x18C/2), запуск индекса кода очистки в 0x00 и с условием 0x0E (всегда)

- Коды очистки, начиная со слова 2: (используются совместно прологом и эпилогом).

   - Код очистки 0 = 0xC6: sp = r6.

   - Код очистки 1 = 0xDC: pop {r4-r8, lr}.

   - Код очистки 2 = 0x04: SP + = (4 < < 2)

   - Код очистки 3 = 0xFD: end, засчитывается как 16-разрядная инструкция для эпилога.

### <a name="example-6-function-with-exception-handler"></a>Пример 6. Функция с обработчиком исключений

```asm
Prologue:
  00488C1C: 0059 A7ED dc.w  0x0059A7ED
  00488C20: 005A 8ED0 dc.w  0x005A8ED0
FunctionStart:
  00488C24: B590      push        {r4, r7, lr}
  00488C26: B085      sub         sp, sp, #0x14
  00488C28: 466F      mov         r7, sp
Epilogue:
  00488C6C: 46BD      mov         sp, r7
  00488C6E: B005      add         sp, sp, #0x14
  00488C70: BD90      pop         {r4, r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Start RVA для функции* = 0x00088C24 (= 0x00488C24-0x00400000)

- Слово 1

   - *Флаг* = 0, указывающий на присутствие записи XData (требуется из-за нескольких эпилоги)

   - *. XData-адрес* — 0x00400000

.XDATA (переменная, 5 слов):

- Слово 0

   - *Длина функции* = 0x000027 (= 0x00004E/2)

   - *Наоборот* = 0, указывающий первую версию XData

   - *X* = 1, указывающее на наличие данных исключений

   - *E* = 1, что означает один эпилога

   - *F* = 0, указывающее полное описание функции, включая Пролог

   - *Эпилога Count* = 0x00, указывающее, что коды очистки эпилога начинаются со смещения 0x00

   - *Кодовые слова* = 0x02, указывающие 2 32-разрядные слова кодов очистки

- Коды очистки, начиная со слова 1.

   - Код очистки 0 = 0xC7: sp = r7.

   - Код очистки 1 = 0x05: SP + = (5 < < 2)

   - Код очистки 2 = 0xED/0x90: pop {r4, r7, lr}.

   - Код очистки 4 = 0xFF: end.

- В Word 3 указан обработчик исключений = 0x0019A7ED (= 0x0059A7ED-0x00400000).

- Слова с 4 и выше являются встроенными данными об исключении.

### <a name="example-7-funclet"></a>Пример 7. Библиотека funclet

```asm
Function:
  00488C72: B500      push        {lr}
  00488C74: B081      sub         sp, sp, #4
  00488C76: 3F20      subs        r7, #0x20
  00488C78: F117 0308 adds        r3, r7, #8
  00488C7C: 1D3A      adds        r2, r7, #4
  00488C7E: 1C39      adds        r1, r7, #0
  00488C80: F7FF FFAC bl          target
  00488C84: B001      add         sp, sp, #4
  00488C86: BD00      pop         {pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

   - *Start RVA для функции* = 0x00088C72 (= 0x00488C72-0x00400000)

- Слово 1

   - *Флаг* = 1, указывающий канонические форматы пролога и эпилога

   - *Длина функции* = 0x0B (= 0x16/2)

   - *RET* = 0, означающее возврат POP {PC}

   - *H* = 0, указывающий, что параметры не были размещены

   - *R*= 0 и *reg* = 7, указывающие, что регистры не были сохранены или восстановлены

   - *L* = 1, означающее, что LR был сохранен или восстановлен

   - *C* = 0, указывающее, что цепочки кадров отсутствуют

   - *Stack корректируют* = 1, что означает настройку стека 1 × 4 байт

## <a name="see-also"></a>См. также

[Обзор соглашений ABI ARM](overview-of-arm-abi-conventions.md)<br/>
[Общие вопросы использования Visual C++ ARM](common-visual-cpp-arm-migration-issues.md)
