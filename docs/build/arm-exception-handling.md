---
description: 'Подробнее о следующем: Обработка исключений ARM'
title: Обработка исключений ARM
ms.date: 07/11/2018
ms.assetid: fe0e615f-c033-4ad5-97f4-ff96af45b201
ms.openlocfilehash: 74c915eeee90e0689881621b562f143b7d313941
ms.sourcegitcommit: 6183207b11575d7b44ebd7c18918e916a0d8c63d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "97951503"
---
# <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows на ARM использует один механизм структурированной обработки исключений для асинхронных аппаратных и синхронных программных исключений. Обработчики исключения для конкретных языков созданы на базе структурированной обработки исключений Windows с помощью вспомогательных функций языка. Этот документ описывает обработку исключений в Windows на устройствах ARM, а также вспомогательные функции языка, которые использует код, созданный ассемблером Microsoft ARM и компилятором MSVC.

## <a name="arm-exception-handling"></a>Обработка исключений ARM

Windows на ARM использует *коды очистки* для управления очисткой стека во время [структурированной обработки исключений](/windows/win32/debug/structured-exception-handling) (SEH). Коды очистки представляют собой последовательность байт, хранимых в разделе `.xdata` исполняемого образа. Они отвлеченно описывают работу кода пролога и эпилога функции, чтобы можно было нейтрализовать воздействие пролога функции во время подготовки к очистке кадра стека вызывающего объекта.

Встроенный двоичный интерфейс приложения ARM EABI задает модель очистки исключения, использующую коды очистки, однако SEH этого недостаточно для выполнения очистки в Windows, так как требуется обрабатывать асинхронные случаи, когда процессор находится в середине пролога или эпилога функции. Windows также разделяет управление очисткой на очистку функционального уровня и очистку языковой области, которая унифицирована в ARM EABI. По этим причинам Windows на ARM указывает больше сведений о данных и процедуре очистки.

### <a name="assumptions"></a>Допущения

Исполняемые образы для Windows на ARM используют формат переносимого исполняемого файла (PE). Дополнительные сведения см. в разделе [Формат переносимого исполняемого файла](/windows/win32/debug/pe-format). Информация об обработке исключений хранится в разделах `.pdata` и `.xdata` образа.

Механизм обработки исключений делает определенные предположения о коде, который соответствует двоичному интерфейсу приложения для Windows на ARM.

- При возникновении исключения в теле функции не имеет никакого значения, откачены ли операции пролога или операции эпилога выполняются с опережением. Оба случая должны давать одинаковые результаты.

- Прологи и эпилоги стремятся зеркально отображать друг друга. Это можно использовать для сокращения объема метаданных, требуемых для описания очистки.

- Функции имеют относительно небольшой размер. На этом основано несколько оптимизаций для более эффективной упаковки данных.

- Если условие ставится в эпилоге, оно в равной степени применяется ко всем инструкциям эпилога.

- Если в прологе указатель стека (SP) сохраняется в другом регистре, этот регистр должен оставаться неизменным в течение всего времени работы функции, чтобы исходный указатель стека можно было получить в любое время.

- Если только указатель стека не сохранен в другом регистре, все операции с ним должны производиться исключительно в пределах пролога и эпилога.

- Для очистки кадра стека необходимо выполнить следующие операции.

  - Скорректируйте r13 (SP) с 4-байтными приращениями.

  - Извлеките один или несколько целочисленных регистров.

  - Извлеките один или несколько регистров VFP (виртуальные операции с плавающей запятой).

  - Скопируйте значение произвольного регистра в r13 (SP).

  - Загрузите указатель стека из стека с помощью небольшой постдекрементной операции.

  - Произведите анализ одного из нескольких четко заданных типов кадров.

### <a name="pdata-records"></a>Записи `.pdata`

Записи `.pdata` в образе формата PE представляют собой упорядоченный массив с элементами фиксированной длины, которые описывают каждую работающую со стеком функцию. Конечным функциям, которые не вызывают другие функции, записи `.pdata` не требуются, если только они не работают со стеком. (Таким образом, им не требуется локальное хранилище и не нужно сохранять или восстанавливать неизменяемые регистры.) Для экономии места записи для таких функций в разделе `.pdata` можно опускать. Операция очистки из одной из таких функций может просто скопировать адрес возврата из регистра связи (LR) в счетчик команд (PC) для перемещения к вызывающему объекту.

Каждая запись `.pdata` для ARM имеет длину 8 байт. Общий формат записи имеет следующий вид: относительный виртуальный адрес (RVA) в начале функции в первом 32-битном слове, после которого идет второе слово с указателем на блок `.xdata` переменной длины или упакованным словом, описывающим каноническую последовательность очистки функции, как показано в следующей таблице.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*`Function Start RVA`* представляет собой 32-разрядный относительный виртуальный адрес начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0—1|*`Flag`* представляет собой 2-битовое поле, указывающее, как правильно интерпретировать остальные 30 бит второго слова `.pdata`. Если *`Flag`* имеет значение 0, то оставшиеся биты формируют *Exception Information RVA* (при этом два младших бита неявно становятся равны 0). Если *`Flag`* имеет ненулевое значение, то оставшиеся биты формируют структуру *Packed Unwind Data*.|
|1|2—31|*Exception Information RVA* или *Packed Unwind Data*.<br /><br /> *Exception Information RVA* (Относительный виртуальный адрес сведений об исключении) представляет собой адрес структуры сведений об исключении переменной длины, хранимой в разделе `.xdata`. Эти данные должны быть выровнены по 4-байтовой границе.<br /><br /> *Packed Unwind Data* (Упакованные данные очистки) представляет собой сжатое описание операций, необходимых для выполнения очистки из функции в канонической форме. В этом случае запись `.xdata` не требуется.|

### <a name="packed-unwind-data"></a>Упакованные данные очистки

Для функций, прологи и эпилоги которых соответствуют описанной ниже канонической форме, можно использовать упакованные данные очистки. Это устраняет потребность в записи `.xdata` и значительно сокращает требования к месту для предоставления данных очистки. Канонические прологи и эпилоги предназначены для удовлетворения общих требований простой функции, которая не требует обработчика событий и выполняет операции настройки и удаления в стандартном порядке.

В этой таблице показан формат записи `.pdata`, содержащей упакованные данные очистки.

|Смещение слов|Bits|Цель|
|-----------------|----------|-------------|
|0|0—31|*`Function Start RVA`* представляет собой 32-разрядный относительный виртуальный адрес начала функции. Если функция содержит код бегунка, необходимо задать младший бит этого адреса.|
|1|0—1|*`Flag`* представляет собой 2-битовое поле, имеющее следующие значения.<br /><br />— 00 = упакованные данные очистки не используются; оставшиеся биты указывают на запись `.xdata`.<br />— 01= упакованные данные очистки.<br />— 10 = упакованные данные очистки, когда для функции предполагается отсутствие пролога. Это удобно для описания фрагментов функции, которые разобщены с началом функции.<br />— 11 = зарезервировано.|
|1|2—12|*`Function Length`* представляет собой 11-битовое поле, которое предоставляет длину всей функции в байтах, поделенную на 2. Если размер функции больше 4 КБ, следует использовать полную запись `.xdata`.|
|1|13—14|*`Ret`* представляет собой 2-битовое поле, указывающее способ возврата данных функцией.<br /><br />— 00 = возврат посредством извлечения {pc} (в этом случае для флагового разряда *`L`* следует установить значение 1).<br />— 01 = возвращение посредством 16-разрядного ветвления.<br />— 10 = возвращение посредством 32-разрядного ветвления.<br />— 11 = полное отсутствие эпилога. Это удобно для описания разобщенного фрагмента функции, который может содержать только пролог, однако его эпилог находится в другом месте.|
|1|15|*`H`* представляет собой 1-битный флаг, который указывает, устанавливает ли функция регистры целочисленных параметров (r0–r3) в начальное расположение посредством их отправки в начале функции, и освобождает 16 байтов стека перед возвратом. (0 = не помещает в начальное расположение, 1 = помещает в начальное расположение.)|
|1|16—18|*`Reg`* представляет собой 3-битовое поле, указывающее индекс последнего сохраненного неизменяемого регистра. Если бит *`R`* равен 0, то сохраняются только целочисленные регистры, которые должны находиться в пределах r4–rN, где значение N равно 4 + *`Reg`* . Если бит *`R`* равен 1, то сохраняются только регистры операций с плавающей запятой, которые должны находиться в пределах d8–dN, где значение N равно 8 + *`Reg`* . Особое сочетание *`R`* = 1 и *`Reg`* = 7 указывает на то, что никакие регистры не сохраняются.|
|1|19|*`R`* представляет собой 1-битовый флаг, который указывает, предназначены ли сохраненные неизменяемые регистры для целочисленных операций (0) или для операций с плавающей запятой (1). Если *`R`* имеет значение 1, а поле *`Reg`* имеет значение 7, то никакие неизменяемые регистры не отправлялись.|
|1|20|*`L`* представляет собой 1-битовый флаг, который указывает, выполняет ли функция сохранение или восстановление регистра LR вместе с другими регистрами, указанными в поле *`Reg`* . (0 = не сохраняет/восстанавливает, 1 = сохраняет/восстанавливает.)|
|1|21|*`C`* представляет собой 1-битовый флаг, который указывает, содержит (1) функция дополнительные инструкции по настройке цепочки кадров для ускорения проверки стека или нет (0). Если этот бит задан, r11 неявно добавляется в список сохраняемых неизменяемых регистров для целочисленных операций. (См. описанные ниже ограничения при использовании флага *`C`* .)|
|1|22—31|*`Stack Adjust`* представляет собой 10-битовое поле, которое указывает число выделенных для этой функции бит в стеке, поделенное на 4. Однако напрямую возможно кодирование лишь значений из диапазона 0x000—0x3F3. Функции, выделяющие более 4044 байт стека, должны использовать полную запись `.xdata`. Если поле *`Stack Adjust`* имеет размер 0x3F4 и более, то 4 младших бита имеют особое значение.<br /><br />— Биты 0–1 указывают число слов в подстройке стека (1–4) минус 1.<br />— Бит 2 имеет значение 1, если пролог объединил эту подстройку со своей операцией отправки.<br />— Бит 3 имеет значение 1, если эпилог объединил эту подстройку со своей операцией извлечения.|

В связи с возможным дублированием в описанном выше кодировании применяются следующие ограничения.

- Если флаг *`C`* имеет значение 1.

  - Для флага *`L`* следует также установить значение 1, так как цепочка кадров требует как r11, так и LR.

  - r11 не следует включать в набор регистров, описываемый *`Reg`* . Таким образом, при отправке регистров r4–r11 *`Reg`* должен описывать только регистры r4–r10, так как флаг *`C`* подразумевает r11.

- Если поле *`Ret`* имеет значение 0, для флага *`L`* следует установить значение 1.

Нарушение этих ограничений ведет к неподдерживаемой последовательности операций.

В целях дальнейшего обсуждения от *`Stack Adjust`* производится наследование двух псевдофлагов:

- *`PF`* или "свертывание пролога" указывает, что *`Stack Adjust`* имеет размер 0x3F4 или больше и задан бит 2;

- *`EF`* или "свертывание эпилога" указывает, что *`Stack Adjust`* имеет размер 0x3F4 или больше и задан бит 3.

Прологи для канонических функций могут иметь до 5 инструкций (обратите внимание, что 3а и 3б являются взаимоисключающими).

|Инструкция|Предполагается наличие кода операции, если|Размер|Код операции|Коды очистки|
|-----------------|-----------------------------------|----------|------------|------------------|
|1|*`H`* ==1|16|`push {r0-r3}`|04|
|2|*`C`* ==1 или *`L`* ==1 или *`R`* ==0 или *`PF`* ==1|16/32|`push {registers}`|80—BF/D0—DF/EC—ED|
|3а|*`C`* ==1 и ( *`L`* ==0 и *`R`* ==1 и *`PF`* ==0)|16|`mov r11,sp`|C0—CF/FB|
|3б|*`C`* ==1 и ( *`L`* ==1 или *`R`* ==0 или *`PF`* ==1)|32|`add r11,sp,#xx`|FC|
|4|*`R`* ==1 и *`Reg`* != 7|32|`vpush {d8-dE}`|E0—E7|
|5|*`Stack Adjust`* != 0 и *`PF`* ==0|16/32|`sub sp,sp,#xx`|00—7F/E8—EB|

Инструкция 1 всегда присутствует, если для бита *`H`* задано значение 1.

Чтобы настроить цепочку кадров, присутствует инструкция 3а или 3б при заданном бите *`C`* . Это 16-разрядная `mov`, если отправляются только регистры r11 и LR; в противном случае это 32-разрядная `add`.

Если указана подстройка без свертывания, инструкция 5 является явной подстройкой стека.

Инструкции 2 и 4 задаются с учетом того, требуется ли отправка. В этой таблице приведены сводные сведения о том, какие регистры сохраняются в зависимости от состояния полей *`C`* , *`L`* , *`R`* и *`PF`* . Во всех случаях *`N`* равен *`Reg`*  + 4, *`E`* равен *`Reg`*  + 8, а *`S`* равен (~ *`Stack Adjust`* ) & 3.

|В|L|R|PF|Отправленные целочисленные регистры|Отправленные регистры VFP|
|-------|-------|-------|--------|------------------------------|--------------------------|
|0|0|0|0|r4–r *`N`*|Нет|
|0|0|0|1|r *`S`* –r *`N`*|Нет|
|0|0|1|0|none|d8–d *`E`*|
|0|0|1|1|r *`S`* –r3|d8–d *`E`*|
|0|1|0|0|r4–r *`N`* , LR|Нет|
|0|1|0|1|r *`S`* –r *`N`* , LR|Нет|
|0|1|1|0|LR|d8–d *`E`*|
|0|1|1|1|r *`S`* –r3, LR|d8–d *`E`*|
|1|0|0|0|r4–r *`N`* , r11|Нет|
|1|0|0|1|r *`S`* –r *`N`* , r11|Нет|
|1|0|1|0|r11|d8–d *`E`*|
|1|0|1|1|r *`S`* –r3, r11|d8–d *`E`*|
|1|1|0|0|r4–r *`N`* , r11, LR|Нет|
|1|1|0|1|r *`S`* –r *`N`* , r11, LR|Нет|
|1|1|1|0|r11, LR|d8–d *`E`*|
|1|1|1|1|r *`S`* –r3, r11, LR|d8–d *`E`*|

Эпилоги для канонических функций имеют аналогичную форму, однако с обратным порядком и дополнительными параметрами. Эпилог может иметь длину до 5 инструкций, а его форма жестко определяется формой пролога.

|Инструкция|Предполагается наличие кода операции, если|Размер|Код операции|
|-----------------|-----------------------------------|----------|------------|
|6|*`Stack Adjust`* !=0 и *`EF`* ==0|16/32|`add   sp,sp,#xx`|
|7|*`R`* ==1 и *`Reg`* !=7|32|`vpop  {d8-dE}`|
|8|*`C`* ==1 или ( *`L`* ==1 и *`H`* ==0) или *`R`* ==0 или *`EF`* ==1|16/32|`pop   {registers}`|
|9а|*`H`* ==1 и *`L`* ==0|16|`add   sp,sp,#0x10`|
|9б|*`H`* ==1 и *`L`* ==1|32|`ldr   pc,[sp],#0x14`|
|10а|*`Ret`* ==1|16|`bx    reg`|
|10б|*`Ret`* ==2|32|`b     address`|

Инструкция 6 является явной подстройкой стека, если указана подстройка без свертывания. Поскольку *`PF`* не зависит от *`EF`* , можно получить инструкцию 5 без инструкции 6 или наоборот.

Инструкции 7 и 8 используют ту же логику, что и пролог, чтобы определить, какие регистры восстанавливаются из стека, но с учетом двух следующих изменений: во-первых, *`EF`* используется вместо *`PF`* ; во-вторых, если *`Ret`* = 0, то LR заменяется на PC в списке регистров, а эпилог моментально завершается.

Если задан *`H`* , то присутствует либо инструкция 9а, либо инструкция 9б. Инструкция 9a используется, когда *`L`* равно 0, чтобы указать, что LR не находится в стеке. В этом случае выполнена ручная подстройка стека, а *`Ret`* должен иметь значение 1 или 2 для указания явного возврата. Инструкция 9б используется, когда *`L`* равен 1, чтобы указать на раннее завершение эпилога и одновременно возвратить и подстроить стек.

Если эпилог еще не закончен, то присутствует либо инструкция 10а, либо инструкция 10б, указывая на 16- или 32-разрядное ветвление в зависимости от значения *`Ret`* .

### <a name="xdata-records"></a>Записи `.xdata`

Когда формата упакованных данных очистки недостаточно для описания очистки функции, необходимо создать запись `.xdata` переменной длины. Адрес этой записи хранится во втором слове записи `.pdata`. Формат `.xdata` представляет собой упакованный набор слов переменной длины, состоящий из четырех разделов.

1. Заголовок из 1 или 2 слов, описывающий общий размер структуры `.xdata` и предоставляющий ключевые функциональные данные. Второе слово присутствует только в том случае, если для полей *Epilogue Count* и *Code Words* задано значение 0. Эти поля описаны в следующей таблице.

   |Слово|Bits|Цель|
   |----------|----------|-------------|
   |0|0—17|*`Function Length`* представляет собой 18-битовое поле, которое указывает общую длину функции в байтах, поделенную на 2. Если размер функции больше 512 КБ, для ее описания следует создать несколько записей `.pdata` и `.xdata`. Дополнительные сведения см. в разделе "Большие функции" настоящего документа.|
   |0|18—19|*Vers* представляет собой 2-битовое поле, описывающее версию оставшейся записи `.xdata`. Сейчас определена только версия 0; значения 1—3 зарезервированы.|
   |0|20|*X* представляет собой 1-битовое поле, указывающее наличие (1) или отсутствие (0) данных исключения.|
   |0|21|*`E`* представляет собой 1-битовое поле, указывающее, что информация с описанием отдельного эпилога упакована в заголовок (1) и позднее не потребует дополнительных слов (0).|
   |0|22|*F* представляет собой 1-битовое поле, которое указывает, что данная запись описывает фрагмент функции (1) или всю функцию целиком (0). Если указан фрагмент, пролог отсутствует, поэтому его обработку можно проигнорировать.|
   |0|23—27|*Epilogue Count* представляет собой 5-битовое поле, имеющее два значения в зависимости от состояния бита *`E`* :<br /><br /> – Если *`E`* равен 0, это поле подсчитывает общее число областей исключений, описанных в разделе 3. Если в функции присутствует более 31 области, для этого поля и поля *Code Words* следует установить значение 0, чтобы указать на потребность в слове расширения.<br />– Если *`E`* равен 1, это поле указывает индекс первого кода очистки, описывающего единственный эпилог.|
   |0|28—31|*Code Words* представляет собой 4-битовое поле, которое указывает число 32-разрядных слов, требуемое для размещения всех кодов очистки в разделе 4. Если требуется более 15 слов для более чем 63 байт кодов очистки, для этого поля и поля *Epilogue Count* следует установить значение 0, чтобы указать на потребность в слове расширения.|
   |1|0—15|*Extended Epilogue Count* представляет собой 16-битовое поле, которое предоставляет дополнительное место для кодирования необычайно большого числа эпилогов. Слово расширения, содержащее это поле, присутствует только в том случае, если для полей *Epilogue Count* и *Code Words* в первом слове заголовка задано значение 0.|
   |1|16—23|*Extended Code Words* представляет собой 8-битовое поле, которое предоставляет дополнительное место для кодирования необычайно большого числа слов кодов очистки. Слово расширения, содержащее это поле, присутствует только в том случае, если для полей *Epilogue Count* и *Code Words* в первом слове заголовка задано значение 0.|
   |1|24—31|Зарезервированное|

1. После данных об исключении — если бит *`E`* в заголовке был установлен в значение 0 — находится список информации об областях эпилога, которые по одной упакованы в слова и хранятся в порядке увеличения начального смещения. Каждая область содержит следующие поля.

   |Bits|Цель|
   |----------|-------------|
   |0—17|*Смещение начала эпилога* представляет собой 18-битовое поле, которое описывает смещение эпилога в байтах, поделенное на 2, относительно начала функции.|
   |18—19|*Res* представляет собой 2-битовое поле, зарезервированное для расширения в будущем. Оно должно иметь значение 0.|
   |20—23|*Условие* представляет собой 4-битовое поле, содержащее условие для выполнения эпилога. Для безусловных эпилогов в нем следует задать значение 0xE, которое означает "всегда". (Эпилог должен быть полностью условным или полностью безусловным, а в режиме Thumb-2 эпилог начинается с первой инструкции после кода операции IT.)|
   |24—31|*Индекс начала эпилога* представляет собой 8-битовое поле, которое указывает индекс байта первого кода очистки, описывающего этот эпилог.|

1. После списка областей эпилога идет массив с кодами очистки, которые подробно описаны в разделе "Коды очистки" данной статьи. Этот массив дополняется в конец ближайшей границы полного слова. Байты хранятся с прямым порядком, чтобы их можно было напрямую получать в соответствующем режиме.

1. Если поле *X* в заголовке равно 1, после байтов кодов очистки располагаются сведения об обработчике исключений. Они состоят из одного поля *Относительный виртуальный адрес обработчика исключений*, содержащего адрес обработчика исключений, после которого сразу идет объем (переменный) данных, требуемых этому обработчику исключений.

Запись `.xdata` спроектирована таким образом, что можно получить первые 8 байт и вычислить полный размер записи без учета размера последующих данных об исключении, имеющих переменную длину. Этот фрагмент кода вычисляет размер записи:

```cpp
ULONG Comput`.xdata`Size(PULONG `.xdata`)
{
    ULONG EpilogueScopes;
    ULONG Size;
    ULONG UnwindWords;

    if (`.xdata`[0] >> 23) != 0) {
        Size = 4;
        EpilogueScopes = `.xdata`[0] >> 23) & 0x1f;
        UnwindWords = `.xdata`[0] >> 28) & 0x0f;
    } else {
        Size = 8;
        EpilogueScopes =`.xdata`[1] & 0xffff;
        UnwindWords = `.xdata`[1] >> 16) & 0xff;
    }

    if (!`.xdata`[0] & (1 << 21))) {
        Size += 4 * EpilogueScopes;
    }
    Size += 4 * UnwindWords;
    if `.xdata`[0] & (1 << 20)) {
        Size += 4;
    }
    return Size;
}
```

Хотя пролог и каждый эпилог имеют индекс в кодах очистки, эта таблица используется ими совместно. Довольно распространена ситуация, когда все они используют совместно одинаковые коды очистки. Мы рекомендуем разработчикам компилятора предусмотреть оптимизацию такого случая, так как самый большой индекс, который можно указать, равен 255, что ограничивает общее возможное число кодов очистки для конкретной функции.

### <a name="unwind-codes"></a>Коды очистки

Массив кодов очистки представляет собой пул последовательностей инструкций, описывающий, как устранить влияние пролога, и содержащий операции в порядке их отмены. Коды очистки представляют собой мининаборы инструкций, закодированные в виде строки байтов. После окончания выполнения адрес возврата в вызывающую функцию находится в регистре LR, а для всех неизменяемых регистров восстанавливаются значения, актуальные на момент вызова функции.

Если бы существовала уверенность в том, что исключения возникают только в теле функции и никогда не возникают в прологе или эпилоге, потребовалась бы всего одна последовательность очистки. Однако модель очистки Windows требует наличия возможности выполнения очистки из частично выполненного пролога или эпилога. Чтобы выполнить это требование, коды очистки были тщательно спроектированы для обеспечения однозначного сопоставления с каждым соответствующим кодом операции в прологе и эпилоге. Эта особенность имеет несколько разных применений.

- Можно вычислить длину пролога и эпилога, сосчитав число кодов очистки. Это возможно даже при инструкциях переменной длины в режиме Thumb-2, так как имеются четкие сопоставления для 16- и 32-разрядных кодов операций.

- Считая число инструкций после начала области эпилога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы завершить частично выполненную очистку, произведенную эпилогом.

- Считая число инструкций до окончания пролога, можно пропустить эквивалентное число кодов очистки и выполнить остаток последовательности, чтобы отменить только те части пролога, выполнение которых завершилось.

В приведенной ниже таблице показано сопоставление кодов очистки с кодами операций. Наиболее распространены коды длиной в один байт, реже попадаются коды из двух, трех и даже четырех байт. Каждый код хранится от старшего байта к младшему. Структура кода очистки отличается от кодировки, описанной в стандартном встроенном двоичном интерфейсе приложения ARM, так как эти коды очистки рассчитаны на наличие однозначного сопоставления с кодами операций в прологе и эпилоге, что делает возможной очистку частично выполненных прологов и эпилогов.

|Байт 1|Байт 2|Байт 3|Байт 4|Размер операции|Объяснение|
|------------|------------|------------|------------|------------|-----------------|
|00—7F||||16|`add   sp,sp,#X`<br /><br /> Где X равен (код & 0x7F) \* 4|
|80—BF|00—FF|||32|`pop   {r0-r12, lr}`<br /><br /> Где LR извлекается, если "код & 0x2000" и r0–r12 извлекаются, когда соответствующий бит задан в значение "код & 0x1FFF".|
|C0—CF||||16|`mov   sp,rX`<br /><br /> Где X равен "код & 0x0F"|
|D0—D7||||16|`pop   {r4-rX,lr}`<br /><br /> Где X равен (код & 0x03) + 4, а LR извлекается, если "код & 0x04".|
|D8—DF||||32|`pop   {r4-rX,lr}`<br /><br /> Где X равен (код & 0x03) + 8, а LR извлекается, если "код & 0x04".|
|E0—E7||||32|`vpop  {d8-dX}`<br /><br /> Где X равен (код & 0x07) + 8|
|E8—EB|00—FF|||32|`addw  sp,sp,#X`<br /><br /> Где X равен (код & 0x03FF) \* 4|
|EC—ED|00—FF|||16|`pop   {r0-r7,lr}`<br /><br /> Где LR извлекается, если "код & 0x0100" и r0–r7 извлекаются, когда соответствующий бит задан в значение "код & 0x00FF"|
|EE|00—0F|||16|Специально для систем Майкрософт|
|EE|10—FF|||16|Доступно|
|EF|00—0F|||32|`ldr   lr,[sp],#X`<br /><br /> Где X равен (код & 0x000F) \* 4.|
|EF|10—FF|||32|Доступно|
|F0—F4||||-|Доступно|
|F5|00—FF|||32|`vpop  {dS-dE}`<br /><br /> Где S равно (код & 0x00F0) >> 4 и E равно "код Code & 0x000F"|
|F6|00—FF|||32|`vpop  {dS-dE}`<br /><br /> Где S равно ((код & 0x00F0) >> 4) + 16 и E равно (код Code & 0x000F) + 16|
|F7|00—FF|00—FF||16|`add   sp,sp,#X`<br /><br /> Где X равен (код & 0x00FFFF) \* 4|
|F8|00—FF|00—FF|00—FF|16|`add   sp,sp,#X`<br /><br /> Где X равен (код & 0x00FFFFFF) \* 4|
|F9|00—FF|00—FF||32|`add   sp,sp,#X`<br /><br /> Где X равен (код & 0x00FFFF) \* 4|
|FA|00—FF|00—FF|00—FF|32|`add   sp,sp,#X`<br /><br /> Где X равен (код & 0x00FFFFFF) \* 4|
|FB||||16|nop (16-разрядный)|
|FC||||32|nop (32-разрядный)|
|FD||||16|end + 16-разрядный nop в эпилоге|
|FE||||32|end + 32-разрядный nop в эпилоге|
|FF||||-|end|

Здесь показан диапазон шестнадцатеричных значений для каждого байта в коде очистки *Code*, а также размер кода операции *Opsize* и соответствующая интерпретация исходных инструкций. Пустые ячейки обозначают более короткие коды очистки. В инструкциях с большими значениями, охватывающими несколько байт, старшие биты сохраняются первыми. Поле *Opsize* показывает неявный размер кода операции, связанный с каждой операцией Thumb-2. Видимые повторяющиеся записи в таблице с разными кодировками помогают различить разные размеры кодов операций.

Коды очистки спроектированы таким образом, что первый байт кода сообщает как общий размер кода в байтах, так и размер соответствующего кода операции в потоке инструкций. Чтобы вычислить размер пролога или эпилога, выполните проход по кодам очистки от начала и до конца последовательности и воспользуйтесь таблицей подстановки или аналогичным методом, чтобы определить длину соответствующего кода операции.

Коды очистки 0xFD и 0xFE эквивалентны обычному коду end 0xFF, однако имеют один дополнительный код операции nop в случае эпилога — 16- или 32-разрядный. Для прологов коды 0xFD, 0xFE и 0xFF полностью эквивалентны друг другу. Это дает нам общие окончания эпилога `bx lr` или `b <tailcall-target>`, для чего эквивалентная инструкция пролога отсутствует. Это повышает вероятность того, что последовательности очистки можно будет совместно использовать в прологе и эпилогах.

Во многих случаях для пролога и всех эпилогов можно использовать один набор кодов очистки. Однако для обработки очистки частично выполненных прологов может потребоваться несколько последовательностей кодов очистки, отличающихся порядком или поведением. Именно поэтому каждый эпилог имеет собственный индекс в массиве очистки, чтобы показать момент начала выполнения.

### <a name="unwinding-partial-prologues-and-epilogues"></a>Очистка частичных прологов и эпилогов

Наиболее распространенным случаем очистки является возникновение исключения в теле функции, не затрагивающее пролог и все эпилоги. В этом случае средство очистки выполняет коды в массиве очистки, начиная с индекса 0 и продолжая до обнаружения конечного кода операции.

Если исключение возникает во время выполнения пролога или эпилога, кадр стека создан лишь частично, поэтому средству очистки нужно определить, что именно было сделано, чтобы правильно отменить это.

Например, рассмотрим данную последовательность пролога и эпилога:

```asm
0000:   push  {r0-r3}         ; 0x04
0002:   push  {r4-r9, lr}     ; 0xdd
0006:   mov   r7, sp          ; 0xc7
...
0140:   mov   sp, r7          ; 0xc7
0142:   pop   {r4-r9, lr}     ; 0xdd
0146:   add   sp, sp, #16     ; 0x04
0148:   bx    lr
```

Рядом с каждым кодом операции находится подходящий код очистки для описания этой операции. Последовательность кодов очистки для пролога является зеркальным отображением кодов очистки для эпилога без учета последней инструкции. Это распространенный случай, и причина здесь заключается в том, что коды очистки всегда предполагается хранить в обратном порядке по сравнению с порядком выполнения пролога. Это дает нам общий набор кодов очистки:

```asm
0xc7, 0xdd, 0x04, 0xfd
```

Код 0xFD предназначен специально для конца последовательности, то есть эпилог на одну 16-разрядную инструкцию длиннее пролога. Это открывает широкие возможности для совместного использования кодов очистки.

Если в данном примере исключение возникает, пока выполняется тело функции между прологом и эпилогом, очистка начинается с эпилога с нулевым смещением в коде эпилога. В примере это соответствует смещению 0x140. Средство очистки выполняет полную последовательность освобождения, так как очистка не выполнялась. Если же исключение возникает на одну инструкцию после начала кода эпилога, средство очистки может успешно выполнить очистку, пропустив первый код очистки. Учитывая однозначное сопоставление между кодами операций и кодами очистки, при выполнении очистки из инструкции *n* эпилога будут пропущены первые *n* кодов очистки.

Аналогичная логика работает и в обратном направлении для пролога. Если очистка осуществляется с нулевого смещения пролога, ничего выполнять не требуется. При осуществлении очистки с погружением на одну инструкцию последовательность очистки должна начаться с предпоследнего кода очистки, так как коды очистки пролога хранятся в обратном порядке. В общем случае при очистке с инструкции *n* в прологе выполнение следует начинать с *n* кодов очистки с конца списка кодов.

Коды очистки пролога и эпилога не всегда совпадают полностью. В этом случае в массиве кодов очистки может потребоваться наличие нескольких последовательностей кодов. Чтобы определить смещение для начала обработки кодов, используйте следующую логику.

1. Если очистка выполняется из тела функции, начинайте выполнять коды очистки с индекса 0 и продолжайте до достижения конечного кода операции.

2. Если очистка выполняется из эпилога, используйте специальный начальный индекс эпилога, указанный в области эпилога. Вычислите, на сколько байт PC отстоит от начала эпилога. Пропустите такое число кодов очистки, которое соответствует уже выполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

3. Если очистка осуществляется из пролога, начните с индекса 0 в кодах очистки. Вычислите длину кода пролога из последовательности, а затем рассчитайте, на сколько байт PC отстоит от конца пролога. Пропустите такое число кодов очистки, которое соответствует невыполненным инструкциям. Выполните последовательность очистки, начиная с этой точки.

Коды очистки для пролога должны всегда стоять в массиве первыми. Именно эти коды используются для очистки в общем случае, когда очистка осуществляется из тела. Сразу после последовательности кода для пролога должны идти специальные последовательности для эпилога.

### <a name="function-fragments"></a>Фрагменты функции

В целях оптимизации кода может оказаться полезным разделить функцию на разобщенные части. После этого каждому фрагменту функции требуется своя собственная запись `.pdata`, а возможно, и запись `.xdata`.

Учитывая, что пролог находится в начале функции и не может быть разделен, существует четыре сценария фрагментов функции.

- Только пролог; все эпилоги в других фрагментах.

- Только пролог и один или несколько эпилогов; дополнительные эпилоги в других фрагментах.

- Без пролога и эпилогов; пролог и один или несколько эпилогов в других фрагментах.

- Только эпилоги; пролог и, возможно, дополнительные эпилоги в других фрагментах.

В первом сценарии описать требуется только пролог. Это можно сделать в краткой форме `.pdata`, описав пролог обычным образом и задав для *`Ret`* значение 3, указывающее на отсутствие эпилога. В полной форме `.xdata` это можно сделать, предоставив коды очистки пролога как обычно с индексом 0 и указав число эпилогов равным 0.

Второй сценарий аналогичен обычной функции. Если во фрагменте присутствует только один эпилог, расположенный в конце фрагмента, можно использовать краткую запись `.pdata`. В противном случае необходимо использовать полную запись `.xdata`. Помните, что значения смещения, указанные для начала эпилога, заданы относительно начала фрагмента, а не исходного начала функции.

Третий и четвертый сценарии являются вариантами первого и второго сценариев соответственно, за исключением того, что в них нет пролога. В таких ситуациях предполагается, что перед началом эпилога имеется код и он считается частью тела функции, поэтому требует обычной очистки в виде устранения влияния пролога. В таких случаях требуется закодировать псевдопролог, который описывает, как выполнить очистку из тела, однако считается имеющим нулевую длину при определении потребности в частичной очистке в начале фрагмента. Кроме того, этот псевдопролог можно описать с помощью тех же кодов очистки, что и эпилог, так как они предположительно выполняют аналогичные операции.

В третьем и четвертом сценарии наличие псевдопролога указывается посредством задания значения 2 для *`Flag`* краткой записи `.pdata` либо значения 1 для флага *F* в заголовке `.xdata`. В любом случае проверка потребности в частичной очистке пролога игнорируется, и все очистки, не относящиеся к эпилогу, считаются полными.

#### <a name="large-functions"></a>Большие функции

Фрагменты можно использовать для описания функций, размер которых превышает предел в 512 КБ, накладываемый битовыми полями в заголовке `.xdata`. Чтобы описать очень большую функцию, просто разделите ее на фрагменты размером менее 512 КБ. Для каждого фрагмента требуется подстройка, чтобы он не разбивал эпилог на множество частей.

Только первый фрагмент функции содержит пролог, все остальные фрагменты помечаются как не содержащие пролог. В зависимости от числа эпилогов каждый фрагмент может содержать от нуля до нескольких эпилогов. Помните, что область каждого эпилога во фрагменте указывает начальное смещение относительно начала данного фрагмента, а не начала функции.

Если фрагмент не содержит ни пролог, ни эпилог, ему все равно требуется отдельная запись `.pdata` и, возможно, запись `.xdata`, чтобы описать очистку из тела функции.

#### <a name="shrink-wrapping"></a>Упаковка со сжатием

Более сложным частным случаем фрагментов функции является *упаковка со сжатием* — методика для отведения сохранения регистров из начала в конец функции, что позволяет оптимизировать работу в простых случаях, не требующих сохранение регистров. Это можно представить себе как внешний регион, который выделяет место в стеке, но сохраняет минимальный набор регистров, и внутренний регион, который сохраняет и восстанавливает дополнительные регистры.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatiles
    sub    sp, sp, #0x100    ; A: allocate all stack space up front
    ...                      ; A:
    add    r0, sp, #0xE4     ; A: prepare to do the inner save
    stm    r0, {r5-r11}      ; A: save remaining non-volatiles
    ...                      ; B:
    add    r0, sp, #0xE4     ; B: prepare to do the inner restore
    ldm    r0, {r5-r11}      ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C:
```

Упакованные со сжатием функции чаще всего заранее выделяют место под сохранение дополнительных регистров в обычном прологе, а затем выполняют сохранения регистров с помощью `str` или `stm` вместо `push`. Это позволяет осуществить всю работу с указателем стека в исходном прологе функции.

Пример упакованной со сжатием функции необходимо разделить на три региона, которые в комментариях помечены как A, B и C. Первый регион A охватывает начало функции до конца сохранения дополнительных неизменяемых регистров. Необходимо создать запись `.pdata` или `.xdata`, чтобы описать этот фрагмент как имеющий пролог и не имеющий эпилогов.

Средний регион B получает собственную запись `.pdata` или `.xdata`, описывающую его как фрагмент без пролога и эпилога. Однако коды очистки для этого региона все равно должны присутствовать, так как он считается телом функции. Коды должны описывать составной пролог, представляющий как исходные регистры, сохраненные в прологе региона A, так и дополнительные регистры, сохраненные перед входом в регион B, как если бы они были созданы одной последовательностью операций.

Сохранения регистров для региона B нельзя считать "внутренним прологом", так как составной пролог, описанный в регионе B, должен описывать как пролог региона A, так и дополнительные сохраненные регистры. Если бы фрагмент B был описан как имеющий пролог, коды очистки неявно учли бы его размер и у нас не было бы способа описать составной пролог с однозначным сопоставлением с кодами операций, которые сохраняют только дополнительные регистры.

Сохранения дополнительных регистров следует считать частью региона A, поскольку до их завершения составной пролог не дает точное описание состояния стека.

Последний регион C получает собственную запись `.pdata` или `.xdata`, описывающую его как фрагмент без пролога, но с эпилогом.

Если работу со стеком до входа в регион B можно ограничить одной инструкцией, можно воспользоваться альтернативным подходом.

```asm
ShrinkWrappedFunction
    push   {r4, lr}          ; A: save minimal non-volatile registers
    sub    sp, sp, #0xE0     ; A: allocate minimal stack space up front
    ...                      ; A:
    push   {r4-r9}           ; A: save remaining non-volatiles
    ...                      ; B:
    pop    {r4-r9}           ; B: restore remaining non-volatiles
    ...                      ; C:
    pop    {r4, pc}          ; C: restore non-volatile registers
```

Основная идея заключается в том, что на каждой границе инструкций стек полностью согласован с кодами очистки для этого региона. Если очистка происходит до внутренней отправки в данном примере, она считается частью региона A, и только пролог этого региона не очищен. Если очистка происходит после внутренней отправки, она считается частью региона B, у которого нет пролога, но есть коды очистки, описывающие как внутреннюю отправку, так и исходный пролог из региона A. Аналогичная логика применяется и для внутреннего извлечения.

### <a name="encoding-optimizations"></a>Оптимизации кодирования

Многообразие кодов очистки и наличие краткой и развернутой форм данных предоставляют множество возможностей для оптимизации кодирования в целях дальнейшего сокращения занимаемого места. При активном использовании этих методик можно сохранить нагрузку от описания функций и фрагментов с помощью кодов очистки на минимальном уровне.

Самый важный аспект оптимизации заключается в том, чтобы не перепутать границы пролога/эпилога для проведения очистки с логическими границами пролога/эпилога с точки зрения компилятора. Для повышения эффективности границы очистки можно сжать, сделав их более тесными. Например, пролог может содержать код после настройки стека для выполнения дополнительных проверок. Но после окончания всей работы со стеком кодировать дополнительные операции больше не нужно, поэтому все остальное из очищаемого пролога можно удалить.

Это же правило применяется и для длины функции. Если имеются данные, например пул литералов, относящиеся к эпилогу функции, их не следует включать в состав длины функции. Сжав функцию и оставив в ней только код, являющийся ее частью, вы значительно увеличите вероятность того, что эпилог будет находиться в самом конце и можно будет использовать краткую запись `.pdata`.

После сохранения указателя стека в другом регистре в прологе больше не нужно записывать дополнительные коды операций. Чтобы очистить функцию, прежде всего следует восстановить указатель стека из сохраненного регистра, чтобы последующие операции никак не повлияли на очистку.

Эпилоги с одной инструкцией вообще не нужно кодировать ни как области, ни как коды очистки. Если очистка производится до выполнения этой инструкции, то можно предположить, что такая очистка выполняется из тела функции, поэтому достаточно будет простого выполнения кодов очистки пролога. Если очистка производится после выполнение единственной инструкции, то по определению она относится к другому региону.

По той же причине в эпилогах с несколькими инструкциями не нужно кодировать первую инструкцию: если очистка производится до выполнения этой инструкции, полной очистки пролога будет достаточно. Если очистка производится после такой инструкции, то следует учитывать только последующие операции.

Следует активно использовать коды очистки повторно. Индекс, заданный каждой областью эпилога, указывает на произвольную начальную точку в массиве кодов очистки. Он совершенно свободно может указывать не на начало предыдущей последовательности, а на ее середину. Оптимальный подход заключается в создании требуемой последовательности кодов с последующим поиском точного побайтового совпадения в уже закодированном пуле последовательностей. Используйте любое найденное совпадение в качестве начальной точки для повторного использования.

Если после пропуска эпилогов с одной инструкцией эпилогов не остается, рекомендуется использовать краткую форму `.pdata`; она становится еще актуальнее при полном отсутствии эпилогов.

## <a name="examples"></a>Примеры

В этих примерах база образа находится в 0x00400000.

### <a name="example-1-leaf-function-no-locals"></a>Пример 1: Конечная функция, без локальных элементов

```asm
Prologue:
  004535F8: B430      push        {r4-r5}
Epilogue:
  00453656: BC30      pop         {r4-r5}
  00453658: 4770      bx          lr
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *`Function Start RVA`* = 0x000535F8 (= 0x004535F8–0x00400000).

- Слово 1

  - *`Flag`* = 1, указывает канонические форматы пролога и эпилога.

  - *`Function Length`* = 0x31 (= 0x62/2).

  - *`Ret`* = 1, указывает на возвращение посредством 16-разрядного ветвления.

  - *`H`* = 0, указывает, что параметры не помещены в начальное состояние.

  - *`R`* =0 и *`Reg`* = 1, указывает на отправку / извлечение для r4–r5.

  - *`L`* = 0, указывает на отсутствие сохранения / восстановления LR.

  - *`C`* = 0, указывает на отсутствие цепочки кадров.

  - *`Stack Adjust`* = 0, указывает на отсутствие подстройки стека.

### <a name="example-2-nested-function-with-local-allocation"></a>Пример 2: вложенная функция с локальным выделением

```asm
Prologue:
  004533AC: B5F0      push        {r4-r7, lr}
  004533AE: B083      sub         sp, sp, #0xC
Epilogue:
  00453412: B003      add         sp, sp, #0xC
  00453414: BDF0      pop         {r4-r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *`Function Start RVA`* = 0x000533AC (= 0x004533AC–0x00400000).

- Слово 1

  - *`Flag`* = 1, указывает канонические форматы пролога и эпилога.

  - *`Function Length`* = 0x35 (= 0x6A/2).

  - *`Ret`* = 0, указывает на возвращение посредством извлечения {pc}.

  - *`H`* = 0, указывает, что параметры не помещены в начальное состояние.

  - *`R`* =0 и *`Reg`* = 3, указывает на отправку / извлечение для r4–r7.

  - *`L`* = 1, указывает на выполнение сохранения / восстановления LR.

  - *`C`* = 0, указывает на отсутствие цепочки кадров.

  - *`Stack Adjust`* = 3 (= 0x0C/4).

### <a name="example-3-nested-variadic-function"></a>Пример 3. Вложенная функция с переменным числом аргументов

```asm
Prologue:
  00453988: B40F      push        {r0-r3}
  0045398A: B570      push        {r4-r6, lr}
Epilogue:
  004539D4: E8BD 4070 pop         {r4-r6}
  004539D8: F85D FB14 ldr         pc, [sp], #0x14
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *`Function Start RVA`* = 0x00053988 (= 0x00453988–0x00400000).

- Слово 1

  - *`Flag`* = 1, указывает канонические форматы пролога и эпилога.

  - *`Function Length`* = 0x2A (= 0x54/2).

  - *`Ret`* = 0, указывает на возвращение посредством извлечения {pc} (в данном случае это возвращение `ldr pc,[sp],#0x14`).

  - *`H`* = 1, указывает, что параметры были помещены в начальное состояние.

  - *`R`* =0 и *`Reg`* = 2, указывает на отправку / извлечение для r4–r6.

  - *`L`* = 1, указывает на выполнение сохранения / восстановления LR.

  - *`C`* = 0, указывает на отсутствие цепочки кадров.

  - *`Stack Adjust`* = 0, указывает на отсутствие подстройки стека.

### <a name="example-4-function-with-multiple-epilogues"></a>Пример 4. Функция с несколькими эпилогами

```asm
Prologue:
  004592F4: E92D 47F0 stmdb       sp!, {r4-r10, lr}
  004592F8: B086      sub         sp, sp, #0x18
Epilogues:
  00459316: B006      add         sp, sp, #0x18
  00459318: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  0045943E: B006      add         sp, sp, #0x18
  00459440: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  004595D4: B006      add         sp, sp, #0x18
  004595D6: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459606: B006      add         sp, sp, #0x18
  00459608: E8BD 87F0 ldm         sp!, {r4-r10, pc}
  ...
  00459636: F028 FF0F bl          KeBugCheckEx     ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *`Function Start RVA`* = 0x000592F4 (= 0x004592F4–0x00400000).

- Слово 1

  - *`Flag`* = 0, указывает на наличие записи `.xdata` (которая нужна для нескольких эпилогов).

  - *Адрес `.xdata`* — 0x00400000

`.xdata` (переменная, 6 слов):

- Слово 0

  - *`Function Length`* = 0x0001A3 (= 0x000346/2).

  - *Vers* = 0, указывает первую версию `.xdata`.

  - *X* = 0, указывает на отсутствие данных об исключении.

  - *`E`* = 0, указывает на список областей эпилогов.

  - *F* = 0, указывает на полное описание функции, включая пролог.

  - *Epilogue Count* = 0x04, указывает, что общее число областей эпилогов равно 4.

  - *Code Words* = 0x01, указывает на одно 32-разрядное слово кодов очистки.

- Слова 1—4, описывающие 4 области эпилогов в 4 расположениях. Каждая область имеет общий набор кодов очистки, который используется совместно с прологом, имеет смещение 0x00 и является безусловным — задано условие 0x0E ("всегда").

- Коды очистки, начиная со слова 5: (используются совместно прологом и эпилогом).

  - Код очистки 0 = 0x06: sp += (6 << 2)

  - Код очистки 1 = 0xDE: pop {r4-r10, lr}.

  - Код очистки 2 = 0xFF: end.

### <a name="example-5-function-with-dynamic-stack-and-inner-epilogue"></a>Пример 5. Функция с динамическим стеком и внутренним эпилогом

```asm
Prologue:
  00485A20: B40F      push        {r0-r3}
  00485A22: E92D 41F0 stmdb       sp!, {r4-r8, lr}
  00485A26: 466E      mov         r6, sp
  00485A28: 0934      lsrs        r4, r6, #4
  00485A2A: 0124      lsls        r4, r4, #4
  00485A2C: 46A5      mov         sp, r4
  00485A2E: F2AD 2D90 subw        sp, sp, #0x290
Epilogue:
  00485BAC: 46B5      mov         sp, r6
  00485BAE: E8BD 41F0 ldm         sp!, {r4-r8, lr}
  00485BB2: B004      add         sp, sp, #0x10
  00485BB4: 4770      bx          lr
  ...
  00485E2A: F7FF BE7D b           #0x485B28    ; end of function
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *`Function Start RVA`* = 0x00085A20 (= 0x00485A20–0x00400000).

- Слово 1

  - *`Flag`* = 0, указывает на наличие записи `.xdata` (которая нужна для нескольких эпилогов).

  - *Адрес `.xdata`* — 0x00400000

`.xdata` (переменная, 3 слова):

- Слово 0

  - *`Function Length`* = 0x0001A3 (= 0x000346/2).

  - *Vers* = 0, указывает первую версию `.xdata`.

  - *X* = 0, указывает на отсутствие данных об исключении.

  - *`E`* = 0, указывает на список областей эпилогов.

  - *F* = 0, указывает на полное описание функции, включая пролог.

  - *Epilogue Count* = 0x001, указывает, что общее число областей эпилогов равно 1.

  - *Code Words* = 0x01, указывает на одно 32-разрядное слово кодов очистки.

- Слово 1: область эпилога со смещением 0xC6 (= 0x18C/2), начальным индексом кода очистки 0x00 и условием 0x0E ("всегда")

- Коды очистки, начиная со слова 2: (используются совместно прологом и эпилогом).

  - Код очистки 0 = 0xC6: sp = r6.

  - Код очистки 1 = 0xDC: pop {r4-r8, lr}.

  - Код очистки 2 = 0x04: sp += (4 << 2)

  - Код очистки 3 = 0xFD: end, засчитывается как 16-разрядная инструкция для эпилога.

### <a name="example-6-function-with-exception-handler"></a>Пример 6. Функция с обработчиком исключений

```asm
Prologue:
  00488C1C: 0059 A7ED dc.w  0x0059A7ED
  00488C20: 005A 8ED0 dc.w  0x005A8ED0
FunctionStart:
  00488C24: B590      push        {r4, r7, lr}
  00488C26: B085      sub         sp, sp, #0x14
  00488C28: 466F      mov         r7, sp
Epilogue:
  00488C6C: 46BD      mov         sp, r7
  00488C6E: B005      add         sp, sp, #0x14
  00488C70: BD90      pop         {r4, r7, pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *`Function Start RVA`* = 0x00088C24 (= 0x00488C24–0x00400000).

- Слово 1

  - *`Flag`* = 0, указывает на наличие записи `.xdata` (которая нужна для нескольких эпилогов).

  - *Адрес `.xdata`* — 0x00400000

`.xdata` (переменная, 5 слов):

- Слово 0

  - *`Function Length`* =0x000027 (= 0x00004E/2).

  - *Vers* = 0, указывает первую версию `.xdata`.

  - *X* = 1, указывает на наличие данных об исключении.

  - *`E`* = 1, указывает на отдельный эпилог.

  - *F* = 0, указывает на полное описание функции, включая пролог.

  - *Epilogue Count* = 0x00, указывает, что коды очистки эпилога начинаются со смещения 0x00.

  - *Code Words* = 0x02, указывает на два 32-разрядных слова кодов очистки.

- Коды очистки, начиная со слова 1.

  - Код очистки 0 = 0xC7: sp = r7.

  - Код очистки 1 = 0x05: sp += (5 << 2)

  - Код очистки 2 = 0xED/0x90: pop {r4, r7, lr}.

  - Код очистки 4 = 0xFF: end.

- Слово 3 указывает обработчик исключений = 0x0019A7ED (= 0x0059A7ED – 0x00400000)

- Слова с 4 и выше являются встроенными данными об исключении.

### <a name="example-7-funclet"></a>Пример 7. Funclet

```asm
Function:
  00488C72: B500      push        {lr}
  00488C74: B081      sub         sp, sp, #4
  00488C76: 3F20      subs        r7, #0x20
  00488C78: F117 0308 adds        r3, r7, #8
  00488C7C: 1D3A      adds        r2, r7, #4
  00488C7E: 1C39      adds        r1, r7, #0
  00488C80: F7FF FFAC bl          target
  00488C84: B001      add         sp, sp, #4
  00488C86: BD00      pop         {pc}
```

.PDATA (фиксированная, 2 слова)

- Слово 0

  - *`Function Start RVA`* = 0x00088C72 (= 0x00488C72–0x00400000).

- Слово 1

  - *`Flag`* = 1, указывает канонические форматы пролога и эпилога.

  - *`Function Length`* = 0x0B (= 0x16/2).

  - *`Ret`* = 0, указывает на возвращение посредством извлечения {pc}.

  - *`H`* = 0, указывает, что параметры не помещены в начальное состояние.

  - *`R`* =0 и *`Reg`* = 7, указывает на то, что сохранение / восстановление регистров не выполнялось.

  - *`L`* = 1, указывает на выполнение сохранения / восстановления LR.

  - *`C`* = 0, указывает на отсутствие цепочки кадров.

  - *`Stack Adjust`* = 1, указывает на подстройку стека 1 × 4 байта.

## <a name="see-also"></a>См. также

[Обзор соглашений ABI ARM](overview-of-arm-abi-conventions.md)<br/>
[Общие вопросы использования Visual C++ ARM](common-visual-cpp-arm-migration-issues.md)
