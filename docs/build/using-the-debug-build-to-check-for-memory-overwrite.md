---
title: Использование отладочного построения для проверки затирания памяти
ms.date: 11/04/2016
helpviewer_keywords:
- memory, overwrites
ms.assetid: 1345eb4d-24ba-4595-b1cc-2da66986311e
ms.openlocfilehash: 152f72749d2ebdacd46dd3e4db671bc5705d4b6a
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87213753"
---
# <a name="using-the-debug-build-to-check-for-memory-overwrite"></a>Использование отладочного построения для проверки затирания памяти

Чтобы использовать отладочную сборку для проверки перезаписи памяти, сначала необходимо перестроить проект для отладки. Затем перейдите в начало функции `InitInstance` приложения и добавьте следующую строку:

```
afxMemDF |= checkAlwaysMemDF;
```

Механизм распределения отладочной памяти разместит защитные байты вокруг всех выделений памяти. Однако эти защитные байты будут бесполезны, если не проверить, были ли они изменены (что указывало бы на перезапись памяти). В противном случае у вас просто будет буфер, который, на самом деле, может позволить избежать перезаписи памяти.

Если включить `checkAlwaysMemDF`, MFC будет принудительно вызывать функцию `AfxCheckMemory` при каждом вызове операции **`new`** или **`delete`** . При обнаружении перезаписи памяти будет сформировано сообщение TRACE, которое выглядит следующим образом:

```
Damage Occurred! Block=0x5533
```

Если отображается одно из этих сообщений, необходимо пошагово пройти код для определения места сбоя. Для более точного выявления места перезаписи памяти можно явным образом самостоятельно вызывать `AfxCheckMemory`. Пример:

```
ASSERT(AfxCheckMemory());
    DoABunchOfStuff();
    ASSERT(AfxCheckMemory());
```

Если первый метод ASSERT завершается успешно, а второй — нет, это означает, что в функции между двумя вызовами, видимо, произошла перезапись памяти.

В зависимости от характера приложения может оказаться, что `afxMemDF` приводит к слишком медленному выполнению программы, недостаточному даже для тестирования. Переменная `afxMemDF` приводит к вызову `AfxCheckMemory` для каждого вызова операции создания и удаления. В этом случае следует распределить собственные вызовы `AfxCheckMemory`( ), как показано выше, и попытаться таким образом изолировать перезапись памяти.

## <a name="see-also"></a>См. также

[Устранение проблем сборки выпуска](fixing-release-build-problems.md)
