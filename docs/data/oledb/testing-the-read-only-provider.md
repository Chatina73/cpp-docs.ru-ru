---
title: Проверка поставщика в режиме "только для чтения"
ms.date: 11/04/2016
helpviewer_keywords:
- testing, OLE DB providers
- testing providers
- OLE DB providers, calling
- OLE DB providers, testing
ms.assetid: e4aa30c1-391b-41f8-ac73-5270e46fd712
ms.openlocfilehash: a9601b2afe40133a5cc88589b530b5ed549ac81e
ms.sourcegitcommit: 72583d30170d6ef29ea5c6848dc00169f2c909aa
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/18/2019
ms.locfileid: "59025134"
---
# <a name="testing-the-read-only-provider"></a>Проверка поставщика в режиме "только для чтения"

Для проверки поставщика требуется объект-получатель. Это полезно, если потребитель может совпадать с поставщиком. Шаблоны потребителей OLE DB являются оболочками для OLE DB и соответствуют поставщику COM-объектов. Так как источник поставляется с шаблонами объекта-получателя, это можно легко выполнять отладку поставщика с ними. Шаблоны потребителей также являются простой и быстрый способ разработки приложения-потребители.

В примере в этом разделе создается приложение по умолчанию мастер приложений MFC для проверки объекта-получателя. Тестовое приложение представляет собой простой диалог с добавленным кодом шаблона потребителя OLE DB.

## <a name="to-create-the-test-application"></a>Создание тестового приложения

1. В меню **Файл** последовательно выберите пункты **Создать**и **Проект**.

1. В **типы проектов** области выберите **установленные** > **Visual C++** > **MFC/ATL** папки. В **шаблоны** области выберите **приложения MFC**.

1. Имя проекта, введите *TestProv*, а затем нажмите кнопку **ОК**.

   **Приложения MFC** откроется мастер.

1. На **тип приложения** выберите **на основе диалоговых окон**.

1. На **дополнительные функции** выберите **автоматизации**, а затем нажмите кнопку **Готово**.

> [!NOTE]
> При добавлении приложения не требуется поддержка модели автоматизации `CoInitialize` в `CTestProvApp::InitInstance`.

Можно просматривать и изменять **TestProv** диалоговое окно (IDD_TESTPROV_DIALOG), выбрав ее в **представление ресурсов**. Поместите два окна списка, по одному для каждой строки в наборе строк, в диалоговом окне. Отключить свойство sort для обоих списках, нажав клавишу **Alt**+**ввод** при выборе поле со списком и параметр **сортировки** свойства **False**. Кроме того, поместите **запуска** кнопку в диалоговом окне для выбора файла. Готовый **TestProv** диалоговое окно должно быть два окна с меткой «Строка 1» и «строка 2", того, он также имеет **ОК**, **отменить**, и **запуска**  кнопки.

Откройте файл заголовка для класса диалогового окна (в случае этого, файл TestProvDlg.h). Добавьте следующий код в файл заголовка (вне объявлений классов):

```cpp
////////////////////////////////////////////////////////////////////////
// TestProvDlg.h
#include <atldbcli.h>  

class CProvider
{
// Attributes
public:
   char   szField1[16];
   char   szField2[16];

   // Binding Maps
BEGIN_COLUMN_MAP(CProvider)
   COLUMN_ENTRY(1, szField1)
   COLUMN_ENTRY(2, szField2)
END_COLUMN_MAP()
};
```

Код представляет запись пользователя, который определяет, какие столбцы будут в наборе строк. Когда клиент вызывает `IAccessor::CreateAccessor`, эти записи используются для определения столбцов для привязки. Шаблоны потребителей OLE DB также позволяют динамическая привязка столбцов. COLUMN_ENTRY они версию PROVIDER_COLUMN_ENTRY в клиентские. Два макроса COLUMN_ENTRY указать порядковый номер, тип, длина и элемент данных для двух строк.

Добавьте функцию обработчика событий для **запуска** кнопку, нажав клавишу **Ctrl** и дважды щелкнув **запуска** кнопки. Поместите следующий код в функцию:

```cpp
///////////////////////////////////////////////////////////////////////
// TestProvDlg.cpp

void CTestProvDlg::OnRun()
{
   CCommand<CAccessor<CProvider>> table;
   CDataSource source;
   CSession session;

   if (source.Open("Custom.Custom.1", NULL) != S_OK)
      return;

   if (session.Open(source) != S_OK)
      return;

   if (table.Open(session, _T("c:\\samples\\myprov\\myData.txt")) != S_OK)
      return;

   while (table.MoveNext() == S_OK)
   {
      m_ctlString1.AddString(table.szField1);
      m_ctlString2.AddString(table.szField2);
   }
}
```

`CCommand`, `CDataSource`, И `CSession` классы, которые принадлежат к числу Шаблоны потребителей OLE DB. Каждый класс имитирует COM-объект в поставщике. `CCommand` Объекта принимает `CProvider` класс, объявленный в файле заголовка, в качестве параметра шаблона. `CProvider` Представляет параметр привязки, которые используются для доступа к данным от поставщика. 

Строки для открытия каждого класса создайте каждого COM-объект в поставщике. Чтобы найти поставщика, используйте `ProgID` поставщика. Вы можете получить `ProgID` из системного реестра, либо в файле Custom.rgs (откройте каталог поставщика и выполните поиск `ProgID` ключ).

Файл MyData.txt входит в состав `MyProv` образца. Чтобы создать файл с вашими требованиями, редактор и введите четное число строк, нажав клавишу **ввод** между каждой строкой. Измените имя пути, при перемещении файла.

Передайте строку «c:\\\samples\\\myprov\\\MyData.txt» в `table.Open` строки. При выполнении шага с заходом `Open` вызова, появится эта строка передается `SetCommandText` метод в поставщике. Обратите внимание, что `ICommandText::Execute` метод, используемый этой строки.

Чтобы извлечь данные, вызовите `MoveNext` для таблицы. `MoveNext` вызовы `IRowset::GetNextRows`, `GetRowCount`, и `GetData` функции. При наличии больше нет строк (то есть текущей позиции в наборе строк больше, чем `GetRowCount`), цикл завершается.

Если больше нет строк, поставщики, возвращают DB_S_ENDOFROWSET. Значение DB_S_ENDOFROWSET не ошибка. Всегда следует проверять значение S_OK для отмены цикла выборки и не использовать макрос SUCCEEDED.

Теперь можно создавать и тестировать программу.

## <a name="see-also"></a>См. также

[Усовершенствование простого поставщика только для чтения](../../data/oledb/enhancing-the-simple-read-only-provider.md)