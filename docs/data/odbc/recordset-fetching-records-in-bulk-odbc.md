---
title: 'Набор записей: пакетная выборка строк (ODBC)'
ms.date: 11/04/2016
helpviewer_keywords:
- bulk row fetching, implementing
- ODBC recordsets, bulk row fetching
- bulk record field exchange
- bulk row fetching
- bulk RFX functions
- recordsets, bulk row fetching
- DoBulkFieldExchange method
- fetching ODBC records in bulk
- RFX (ODBC), bulk
- rowsets, bulk row fetching
- RFX (ODBC), bulk row fetching
ms.assetid: 20d10fe9-c58a-414a-b675-cdf9aa283e4f
ms.openlocfilehash: ccdc4668f0c19f63ec86ee9a6d788532eb4d9d38
ms.sourcegitcommit: 6b3d793f0ef3bbb7eefaf9f372ba570fdfe61199
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/15/2020
ms.locfileid: "86403716"
---
# <a name="recordset-fetching-records-in-bulk-odbc"></a>Набор записей: пакетная выборка строк (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

`CRecordset`Предоставляет поддержку для групповой выборки строк. Это означает, что несколько записей могут быть извлечены одновременно во время одной выборки, а не как получать одну запись за раз из источника данных. Можно реализовать групповую выборку строк только в производном `CRecordset` классе. Процесс передачи данных из источника данных в объект набора записей называется групповой обмен полями записи (групповой RFX). Обратите внимание, что если не используется групповая выборка строк в `CRecordset` классе, производном от, данные передаются через обмен полями записей (RFX). Дополнительные сведения см. в статье [Обмен полями записей (RFX)](../../data/odbc/record-field-exchange-rfx.md).

В этом разделе рассматриваются следующие вопросы.

- [Как CRecordset поддерживает групповую выборку строк](#_core_how_crecordset_supports_bulk_row_fetching).

- [При использовании групповой выборки строк необходимо учитывать некоторые особенности](#_core_special_considerations).

- [Как реализовать блочный обмен полей записей](#_core_how_to_implement_bulk_record_field_exchange).

## <a name="how-crecordset-supports-bulk-row-fetching"></a><a name="_core_how_crecordset_supports_bulk_row_fetching"></a>Как CRecordset поддерживает групповую выборку строк

Перед открытием объекта набора записей можно определить размер набора строк с помощью `SetRowsetSize` функции-члена. Размер набора строк определяет, сколько записей следует получить во время одной выборки. При реализации групповой выборки строк размер набора строк по умолчанию равен 25. Если многострочная выборка строк не реализована, размер набора строк остается фиксированным в 1.

После инициализации размера набора строк вызовите функцию [Open](../../mfc/reference/crecordset-class.md#open) Member. Здесь необходимо указать `CRecordset::useMultiRowFetch` параметр *двоптионс* для реализации групповой выборки строк. Можно дополнительно задать `CRecordset::userAllocMultiRowBuffers` параметр. Механизм обмена полей с массовыми записями использует массивы для хранения нескольких строк данных, получаемых во время выборки. Эти буферы хранилища могут быть автоматически выделены платформой, или их можно выделить вручную. Указание `CRecordset::userAllocMultiRowBuffers` параметра означает, что выделение будет выделено.

В следующей таблице перечислены функции элементов, предоставляемые службами `CRecordset` для поддержки групповой выборки строк.

|Функция-член|Описание|
|---------------------|-----------------|
|[чеккровсетеррор](../../mfc/reference/crecordset-class.md#checkrowseterror)|Виртуальная функция, которая обрабатывает ошибки, происходящие во время выборки.|
|[добулкфиелдексчанже](../../mfc/reference/crecordset-class.md#dobulkfieldexchange)|Реализует блочный обмен полей записей. Вызывается автоматически для передачи нескольких строк данных из источника данных в объект набора записей.|
|[жетровсетсизе](../../mfc/reference/crecordset-class.md#getrowsetsize)|Извлекает текущее значение для размера набора строк.|
|[жетровсфетчед](../../mfc/reference/crecordset-class.md#getrowsfetched)|Указывает, сколько строк было фактически извлечено после заданной выборки. В большинстве случаев это размер набора строк, если не был выбран неполный набор строк.|
|[жетровстатус](../../mfc/reference/crecordset-class.md#getrowstatus)|Возвращает состояние выборки для определенной строки в наборе строк.|
|[рефрешровсет](../../mfc/reference/crecordset-class.md#refreshrowset)|Обновляет данные и состояние определенной строки в наборе строк.|
|[сетровсеткурсорпоситион](../../mfc/reference/crecordset-class.md#setrowsetcursorposition)|Перемещает курсор в определенную строку в наборе строк.|
|[сетровсетсизе](../../mfc/reference/crecordset-class.md#setrowsetsize)|Виртуальная функция, которая изменяет параметр для размера набора строк на указанное значение.|

## <a name="special-considerations"></a><a name="_core_special_considerations"></a>Особые рекомендации

Хотя групповое извлечение строк является выигрышем в производительности, некоторые функции работают по-разному. Прежде чем принять решение о реализации групповой выборки строк, учитывайте следующее.

- Платформа автоматически вызывает `DoBulkFieldExchange` функцию члена для перемещения данных из источника данных в объект набора записей. Однако данные не передаются из набора записей обратно в источник данных. Вызов `AddNew` функций- `Edit` членов,, `Delete` или `Update` приводит к неудачному утверждению. Хотя `CRecordset` в настоящее время не предоставляет механизм обновления строк данных, можно написать собственные функции с помощью функции API ODBC `SQLSetPos` . Дополнительные сведения о `SQLSetPos` см. в [справочнике программиста по ODBC](/sql/odbc/reference/odbc-programmer-s-reference).

- Функции элементов,,, `IsDeleted` `IsFieldDirty` `IsFieldNull` `IsFieldNullable` `SetFieldDirty` и `SetFieldNull` не могут использоваться для наборов записей, реализующих многострочную выборку строк. Тем не менее, можно вызвать `GetRowStatus` вместо `IsDeleted` , и вместо `GetODBCFieldInfo` `IsFieldNullable` .

- `Move`Операции переопределяют расположение набора записей по набору строк. Например, предположим, что вы открыли набор записей, содержащий 100 записей с исходным размером набора строк, равным 10. `Open`Извлекает строки с 1 по 10, с текущей записью, расположенной в строке 1. Вызов для `MoveNext` выборки следующего набора строк, а не следующей строки. Этот набор строк состоит из строк с 11 по 20, где текущая запись находится в строке 11. Обратите внимание, что `MoveNext` и `Move( 1 )` не эквивалентны при реализации групповой выборки строк. `Move( 1 )`Извлекает набор строк, который начинается с 1 строки из текущей записи. В этом примере вызов `Move( 1 )` после вызова `Open` извлекает набор строк, состоящий из строк с 2 по 11, с текущей записью, расположенной в строке 2. Дополнительные сведения см. в описании функции [перемещения](../../mfc/reference/crecordset-class.md#move) элемента.

- В отличие от обмена полями записей, мастера не поддерживают обмен полями с массовыми записями. Это означает, что необходимо вручную объявить элементы данных поля и переопределить их вручную `DoBulkFieldExchange` путем написания вызовов функций функции "массовый RFX". Дополнительные сведения см. в разделе [функции обмена полями записи](../../mfc/reference/record-field-exchange-functions.md) в *справочнике по библиотеке классов*.

## <a name="how-to-implement-bulk-record-field-exchange"></a><a name="_core_how_to_implement_bulk_record_field_exchange"></a>Как реализовать блочный обмен полей записей

Обмен полями с массовыми записями передает набор данных из источника данных в объект набора записей. Функции групповой RFX используют массивы для хранения этих данных, а также массивы для хранения длины каждого элемента данных в наборе строк. В определении класса необходимо определить элементы данных поля как указатели для доступа к массивам данных. Кроме того, необходимо определить набор указателей для доступа к массивам длин. Все члены данных параметров не должны объявляться как указатели; объявление членов данных параметров при использовании блочного обмена полей записей аналогично объявлению их при использовании обмена полями записей. В следующем примере кода показан простой пример:

```cpp
class MultiRowSet : public CRecordset
{
public:
   // Field/Param Data
      // field data members
      long* m_rgID;
      LPSTR m_rgName;

      // pointers for the lengths
      // of the field data
      long* m_rgIDLengths;
      long* m_rgNameLengths;

      // input parameter data member
      CString m_strNameParam;

   .
   .
   .
}
```

Можно либо выделить эти буферы хранилища вручную, либо сделать так, чтобы платформа выделила ресурсы. Чтобы самостоятельно выделить буферы, необходимо указать `CRecordset::userAllocMultiRowBuffers` параметр *двоптионс* в `Open` функции Member. Не забудьте установить размеры массивов по крайней мере равными размеру набора строк. Если требуется, чтобы платформа выполнила выделение, следует инициализировать указатели на NULL. Обычно это делается в конструкторе объекта Recordset:

```cpp
MultiRowSet::MultiRowSet( CDatabase* pDB )
   : CRecordset( pDB )
{
   m_rgID = NULL;
   m_rgName = NULL;
   m_rgIDLengths = NULL;
   m_rgNameLengths = NULL;
   m_strNameParam = "";

   m_nFields = 2;
   m_nParams = 1;

   .
   .
   .
}
```

Наконец, необходимо переопределить `DoBulkFieldExchange` функцию члена. Для элементов данных поля вызывайте функции групповой RFX. для всех элементов данных параметров вызывайте функции RFX. Если набор записей был открыт путем передачи инструкции SQL или хранимой процедуры в `Open` , порядок, в котором выполняется вызов инструкций массовых RFX, должен соответствовать порядку столбцов в наборе записей. Аналогично, порядок вызовов RFX для параметров должен соответствовать порядку параметров в инструкции SQL или хранимой процедуре.

```cpp
void MultiRowSet::DoBulkFieldExchange( CFieldExchange* pFX )
{
   // call the Bulk RFX functions
   // for field data members
   pFX->SetFieldType( CFieldExchange::outputColumn );
   RFX_Long_Bulk( pFX, _T( "[colRecID]" ),
                  &m_rgID, &m_rgIDLengths );
   RFX_Text_Bulk( pFX, _T( "[colName]" ),
                  &m_rgName, &m_rgNameLengths, 30 );

   // call the RFX functions for
   // for parameter data members
   pFX->SetFieldType( CFieldExchange::inputParam );
   RFX_Text( pFX, "NameParam", m_strNameParam );
}
```

> [!NOTE]
> Необходимо вызвать `Close` функцию члена до того, как производный `CRecordset` класс выйдет из области действия. Это гарантирует высвобождение памяти, выделенной платформой. Рекомендуется всегда явно вызывать метод `Close` , независимо от того, реализована ли многострочная выборка строк.

Дополнительные сведения об обмене полями записей (RFX) см. в разделе [Обмен полями записей: принципы работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md). Дополнительные сведения об использовании параметров см. в разделе [кфиелдексчанже:: сетфиелдтипе](../../mfc/reference/cfieldexchange-class.md#setfieldtype) and [Recordset: Параметризация набора записей (ODBC)](../../data/odbc/recordset-parameterizing-a-recordset-odbc.md).

## <a name="see-also"></a>См. также раздел

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[CRecordset:: m_nFields](../../mfc/reference/crecordset-class.md#m_nfields)<br/>
[CRecordset:: m_nParams](../../mfc/reference/crecordset-class.md#m_nparams)
