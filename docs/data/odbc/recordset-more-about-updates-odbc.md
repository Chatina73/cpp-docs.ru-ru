---
description: 'Дополнительные сведения: набор записей: Дополнительные сведения об обновлениях (ODBC)'
title: Набор записей. Дополнительные сведения об обновлениях (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- records, updating
- transactions, updating recordsets
- ODBC recordsets, updating
- multiuser environments, updates to recordsets
- scrolling, updates to recordsets
- updating recordsets
- recordsets, updating
ms.assetid: 0353a742-d226-4fe2-8881-a7daeffe86cd
ms.openlocfilehash: 9d125456189828d50f1fbfd4aece00a16790424f
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97304445"
---
# <a name="recordset-more-about-updates-odbc"></a>Набор записей. Дополнительные сведения об обновлениях (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

В этом разделе рассматриваются следующие вопросы.

- [Влияние других операций, таких как транзакции, на обновления](#_core_how_transactions_affect_updates).

- [Ваши обновления и другие пользователи](#_core_your_updates_and_the_updates_of_other_users).

- [Дополнительные сведения о функциях элементов Update и DELETE](#_core_more_about_update_and_delete).

> [!NOTE]
> Этот раздел относится к объектам, производным от `CRecordset`, в которых пакетное получение строк не реализовано. При реализации групповой выборки строк некоторые сведения не применяются. Например, нельзя вызывать `AddNew` `Edit` `Delete` функции элементов,, и, `Update` однако можно выполнять транзакции. Дополнительные сведения о групповой выборке строк см. [в разделе набор записей. сбор записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

## <a name="how-other-operations-affect-updates"></a><a name="_core_how_other_operations_affect_updates"></a> Влияние других операций на обновления

На обновления влияют транзакции, действующие во время обновления, закрывая набор записей перед завершением транзакции и прокруткой перед завершением транзакции.

### <a name="how-transactions-affect-updates"></a><a name="_core_how_transactions_affect_updates"></a> Влияние транзакций на обновления

Помимо понимания того, как `AddNew` , `Edit` и `Delete` работает, важно понимать, как функции- `BeginTrans` `CommitTrans` члены, и в `Rollback` [CDatabase](../../mfc/reference/cdatabase-class.md) работают с функциями обновления класса [CRecordset](../../mfc/reference/crecordset-class.md).

По умолчанию вызывает `AddNew` и `Edit` повлияет на источник данных сразу же после вызова `Update` . `Delete` вызовы вступают в силу немедленно. Но можно создать транзакцию и выполнить пакет таких вызовов. Обновления не являются постоянными, пока вы не зафиксируете их. Если вы передумали, то можете откатить транзакцию, а не фиксировать ее.

Дополнительные сведения о транзакциях см. в разделе [Transaction (ODBC)](../../data/odbc/transaction-odbc.md).

### <a name="how-closing-the-recordset-affects-updates"></a><a name="_core_how_closing_the_recordset_affects_updates"></a> Влияние закрытия набора записей на обновления

Если закрывается набор записей или связанный `CDatabase` с ним объект с выполняющейся транзакцией (не был вызван метод [CDatabase:: CommitTrans](../../mfc/reference/cdatabase-class.md#committrans) или [CDatabase:: ROLLBACK](../../mfc/reference/cdatabase-class.md#rollback)), то транзакция откатывается автоматически (если серверная часть базы данных не является ядром СУБД Microsoft Jet).

> [!CAUTION]
> Если используется ядро СУБД Microsoft Jet, закрытие набора записей внутри явной транзакции не приводит к освобождению каких-либо измененных строк или блокировок, которые были помещены до фиксации или отката явной транзакции. Рекомендуется всегда открывать и закрывать наборы записей внутри или за пределами явной транзакции Jet.

### <a name="how-scrolling-affects-updates"></a><a name="_core_how_scrolling_affects_updates"></a> Влияние прокрутки на обновления

При [наборе записей с прокруткой (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) в наборе записей буфер редактирования заполняется каждой новой текущей записью (Предыдущая запись не сохраняется первой). Прокрутка пропускает ранее удаленные записи. При прокрутке после `AddNew` вызова или `Edit` без вызова `Update` , или во `CommitTrans` `Rollback` всех случаях все изменения теряются (без предупреждения), так как новая запись переносится в буфер редактирования. Буфер редактирования заполняется записью, а хранимая запись освобождается, и в источнике данных не происходит никаких изменений. Это относится и к `AddNew` , и к `Edit` .

## <a name="your-updates-and-the-updates-of-other-users"></a><a name="_core_your_updates_and_the_updates_of_other_users"></a> Обновления и обновления других пользователей

При использовании набора записей для обновления данных обновления влияют на других пользователей. Аналогичным образом обновления других пользователей в течение времени существования набора записей повлияют на вас.

В многопользовательской среде другие пользователи могут открывать наборы записей, содержащие некоторые из тех записей, которые были выбраны в наборе записей. Изменения записи перед ее извлечением отражаются в наборе записей. Так как динамические подмножества данных извлекают запись при каждой прокрутке, динамические подмножества отображают изменения при каждой прокрутке до записи. Моментальные снимки извлекают запись при первой прокрутке до нее, поэтому моментальные снимки отображают только те изменения, которые происходят до первоначальной прокрутки к записи.

Записи, добавленные другими пользователями после открытия набора записей, не отображаются в наборе записей, если не выполняется запрос. Если набор записей является динамическим, изменения, внесенные другими пользователями, будут отображаться в динамическом виде при прокрутке к затронутой записи. Если набор записей является моментальным снимком, изменения не отображаются до тех пор, пока не будет выполнен запрос моментального снимка. Если вы хотите просмотреть записи, добавленные или удаленные другими пользователями в вашем моментальном снимке, или записи, добавленные другими пользователями в динамическом наборе, вызовите метод [CRecordset:: Requery](../../mfc/reference/crecordset-class.md#requery) для перестроения набора записей. (Обратите внимание, что в динамическом наборе отображаются удаления других пользователей.) Вы также можете вызвать `Requery` , чтобы просмотреть записи, которые вы добавляете, но не можете видеть их удаления.

> [!TIP]
> Чтобы принудительно выполнить кэширование всего моментального снимка одновременно, вызовите `MoveLast` немедленно после открытия моментального снимка. Затем вызовите `MoveFirst` , чтобы начать работу с записями. `MoveLast` эквивалентен прокрутке всех записей, но все они извлекаются одновременно. Однако обратите внимание, что это может снизить производительность и может не требоваться для некоторых драйверов.

Влияние обновлений на других пользователей аналогично их влиянию на вас.

## <a name="more-about-update-and-delete"></a><a name="_core_more_about_update_and_delete"></a> Дополнительные сведения об обновлении и удалении

В этом разделе содержатся дополнительные сведения, помогающие работать с `Update` и `Delete` .

### <a name="update-success-and-failure"></a>Успешное завершение и сбой обновления

`Update`В случае успешности `AddNew` `Edit` режим или завершается. Чтобы снова начать `AddNew` `Edit` режим или, вызовите `AddNew` или `Edit` .

Если `Update` происходит сбой (Возвращает значение false или вызывается исключение), то остается в `AddNew` режиме или в `Edit` зависимости от того, какая функция была вызвана последней. При этом можно предпринять одно из следующих действий:

- Измените элемент данных поля и повторите `Update` попытку.

- Вызовите метод, `AddNew` чтобы сбросить элементы данных поля до значения NULL, задать значения элементов данных поля, а затем вызвать `Update` снова.

- Вызовите метод, `Edit` чтобы перезагрузить значения, которые были в наборе записей перед первым вызовом `AddNew` или `Edit` , задайте значения элементов данных поля и затем вызовите `Update` снова. После успешного `Update` вызова (за исключением `AddNew` вызова) элементы данных поля сохраняют свои новые значения.

- Вызов `Move` (в том числе `Move` с параметром AFX_MOVE_REFRESH или 0), который сбрасывает все изменения и завершает работу любого `AddNew` или `Edit` режима.

### <a name="update-and-delete"></a>Обновление и удаление

Этот раздел относится как к `Update` , так и к `Delete` .

Для `Update` операции или `Delete` необходимо обновить одну и только одну запись. Эта запись является текущей записью, которая соответствует значениям данных в полях набора записей. Если по какой-либо причине не затрагивается ни одна запись или не затрагивается несколько записей, создается исключение, содержащее одно из следующих значений **реткоде** :

- AFX_SQL_ERROR_NO_ROWS_AFFECTED

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED

При возникновении этих исключений вы остается в `AddNew` состоянии или, `Edit` которое вы использовали при вызове `Update` или `Delete` . Ниже приведены наиболее распространенные сценарии, в которых можно увидеть эти исключения. Скорее всего, вы увидите следующее:

- AFX_SQL_ERROR_NO_ROWS_AFFECTED, когда используется режим оптимистической блокировки и другой пользователь изменил запись таким образом, чтобы платформа не определила правильную запись для обновления или удаления.

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED, когда обновляемая таблица не имеет первичного ключа или уникального индекса и в наборе записей недостаточно столбцов для уникальной идентификации строки таблицы.

## <a name="see-also"></a>См. также раздел

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[Набор записей. Выбор записей в наборе записей (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)<br/>
[Обмен полями записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)<br/>
[SQL](../../data/odbc/sql.md)<br/>
[Исключения: исключения базы данных](../../mfc/exceptions-database-exceptions.md)
