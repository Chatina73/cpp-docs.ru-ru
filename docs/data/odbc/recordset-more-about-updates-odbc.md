---
title: Набор записей. Дополнительные сведения об обновлениях (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- records, updating
- transactions, updating recordsets
- ODBC recordsets, updating
- multiuser environments, updates to recordsets
- scrolling, updates to recordsets
- updating recordsets
- recordsets, updating
ms.assetid: 0353a742-d226-4fe2-8881-a7daeffe86cd
ms.openlocfilehash: 955b26137ce976514d84f95f4d819779b93bd78a
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81368678"
---
# <a name="recordset-more-about-updates-odbc"></a>Набор записей. Дополнительные сведения об обновлениях (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

В этом разделе рассматриваются следующие вопросы.

- [Как другие операции, такие как транзакции, влияют на обновления.](#_core_how_transactions_affect_updates)

- [Ваши обновления и обновления других пользователей](#_core_your_updates_and_the_updates_of_other_users).

- [Подробнее о функциях участников обновления и удаления.](#_core_more_about_update_and_delete)

> [!NOTE]
> Этот раздел относится к объектам, производным от `CRecordset`, в которых пакетное получение строк не реализовано. Если вы реализовали объем строки извлечения, часть информации не применяется. Например, вы не `AddNew` `Edit`можете `Delete`вызвать функции , и, и `Update` член; однако, вы можете выполнять транзакции. Для получения дополнительной информации о массовом строке извлечения, см [Recordset: Извлечение записей в массовых (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

## <a name="how-other-operations-affect-updates"></a><a name="_core_how_other_operations_affect_updates"></a>Как другие операции влияют на обновления

На обновления влияют транзакции, действоваваемые во время обновления, закрытие записи, установленное перед завершением транзакции, и прокрутка перед завершением транзакции.

### <a name="how-transactions-affect-updates"></a><a name="_core_how_transactions_affect_updates"></a>Как транзакции влияют на обновления

Помимо `AddNew`понимания `Edit`того, как , и `Delete` работать, важно `BeginTrans`понять, `CommitTrans`как , и `Rollback` член функции [CDatabase](../../mfc/reference/cdatabase-class.md) работы с обновлениями функций [CRecordset](../../mfc/reference/crecordset-class.md).

По умолчанию `AddNew` вызовите и `Edit` влияют `Update`на источник данных сразу же при вызове. `Delete`звонки вснят немедленно. Но вы можете установить транзакцию и выполнить пакет таких вызовов. Обновления не являются постоянными до тех пор, пока вы их не совершите. Если вы передумаете, вы можете откатить транзакцию вместо того, чтобы ее совершить.

Для получения дополнительной информации о транзакциях [см.](../../data/odbc/transaction-odbc.md)

### <a name="how-closing-the-recordset-affects-updates"></a><a name="_core_how_closing_the_recordset_affects_updates"></a>Как закрытие набора записей влияет на обновления

Если вы закрываете запись или `CDatabase` связанный с ним объект с транзакцией в процессе (вы не вызвали [CDatabase::CommitTrans](../../mfc/reference/cdatabase-class.md#committrans) или [CDatabase::Rollback),](../../mfc/reference/cdatabase-class.md#rollback)транзакция откатывается автоматически (если бэкэнд базы данных не является движком базы данных Microsoft Jet).

> [!CAUTION]
> Если вы используете движок базы данных Microsoft Jet, закрытие рекордного набора внутри явной транзакции не приводит к освобождению каких-либо строк, которые были изменены или замки, которые были размещены до тех пор, пока не будет совершена явная транзакция или откат. Рекомендуется всегда открывать и закрывать записи внутри или за пределами явной транзакции Jet.

### <a name="how-scrolling-affects-updates"></a><a name="_core_how_scrolling_affects_updates"></a>Как прокрутка влияет на обновления

При [записи: Прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) в наборе записей буфер отодвивания заполняется каждой новой текущей записью (предыдущая запись не хранится первой). Прокрутка пропускает записи, ранее удаленные. Если вы прокрутите `Update`после `CommitTrans`вызова `Rollback` `AddNew` или `Edit` вызова без вызова, или во-первых, любые изменения теряются (без предупреждения для вас), как новая запись ввелась в буфер естрита. Буфер изменения заполняется прокруткой записи, сохраненной записью освобождается, и никаких изменений в источнике данных не происходит. Это относится `AddNew` как `Edit`к .

## <a name="your-updates-and-the-updates-of-other-users"></a><a name="_core_your_updates_and_the_updates_of_other_users"></a>Ваши обновления и обновления других пользователей

При использовании набора записей для обновления данных обновления влияют на других пользователей. Аналогичным образом, обновления других пользователей в течение всего срока службы вашего рекорда влияют на вас.

В многопользовательской среде другие пользователи могут открывать записи, содержащие те же записи, которые вы выбрали в своем наборе записей. Изменения в записи перед ее извлечением отражаются в вашем рекорде. Поскольку dynasets извлекают запись каждый раз, когда вы прокручиваете ее, динасеты отражают изменения каждый раз при прокрутке записи. Снимки извлекают запись при первом прокрутке, поэтому снимки отражают только те изменения, которые происходят перед прокруткой к записи.

Записи, добавленные другими пользователями после открытия набора записей, не отображаются в записи, если вы не зарегистрируетесь. Если ваш набор записей является динасетом, редифицируется к существующим записям другими пользователями, которые отображаются в вашем динасете при прокрутке пострадавшей записи. Если ваш рекордный моментальный снимок — это моментальный снимок, редиты не отображаются до тех пор, пока вы не зарегистрируете снимок. Если вы хотите увидеть записи, добавленные или удаленные другими пользователями в моментальном снимке, или записи, добавленные другими пользователями в вашем dynaset, позвоните [cRecordset::Requery](../../mfc/reference/crecordset-class.md#requery) для восстановления набора записей. (Обратите внимание, что удаления других пользователей отображаются в динасете.) Вы также `Requery` можете позвонить, чтобы увидеть записи, которые вы добавляете, но не видеть ваши удаления.

> [!TIP]
> Чтобы заставить кэширование всего снимка сразу, позвоните `MoveLast` сразу после открытия снимка. Затем `MoveFirst` позвоните, чтобы начать работать с записями. `MoveLast`эквивалентно прокрутке всех записей, но она получает их все сразу. Обратите внимание, однако, что это может снизить производительность и может не потребоваться для некоторых драйверов.

Влияние ваших обновлений на других пользователей аналогично их воздействию на вас.

## <a name="more-about-update-and-delete"></a><a name="_core_more_about_update_and_delete"></a>Подробнее об обновлении и удалении

В этом разделе содержится дополнительная информация, которая поможет вам работать с `Update` и `Delete`.

### <a name="update-success-and-failure"></a>Успех обновления и неудачи

В `Update` случае успеха `AddNew` `Edit` режим или режим заканчивается. Чтобы начать `AddNew` `Edit` или режим `AddNew` снова, позвоните или `Edit`.

Если `Update` сбой (возвращает FALSE или бросает `AddNew` исключение), вы остаетесь в режиме или `Edit` режиме, в зависимости от того, какую функцию вы назвали последней. При этом можно предпринять одно из следующих действий:

- Измените состав данных `Update` поля и повторите попытку.

- Вызов `AddNew` для сбросить данные поля в Null, установить значения членов `Update` данных поля, а затем снова вызвать.

- Вызов `Edit` перезагрузить значения, которые были в записи до `AddNew` `Edit`первого вызова или, установить значения членов `Update` данных поля, а затем снова вызвать. После успешного `Update` вызова (кроме `AddNew` вызова) участники полевых данных сохраняют свои новые значения.

- Вызов `Move` (в том числе `Move` с параметром AFX_MOVE_REFRESH, или 0), который сбрасывает любые изменения и заканчивается любой `AddNew` или `Edit` режим в силу.

### <a name="update-and-delete"></a>Обновление и удаление

Этот раздел относится `Update` `Delete`как к .

`Update` На `Delete` или операции, одна и только одна запись должна быть обновлена. Эта запись является текущей записью, которая соответствует значениям данных в полях рекорда. Если по какой-либо причине не затрагиваются записи или затрагивается более одной записи, выбрасывается исключение, содержащее одно из следующих значений **RETCODE:**

- AFX_SQL_ERROR_NO_ROWS_AFFECTED

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED

Когда эти исключения брошены, вы `AddNew` `Edit` остаетесь в состоянии или состоянии, в каком вы были, когда звонили `Update` или `Delete`. Вот наиболее распространенные сценарии, в которых вы увидите эти исключения. Вы, скорее всего, увидите:

- AFX_SQL_ERROR_NO_ROWS_AFFECTED, когда вы используете оптимистичный режим блокировки, и другой пользователь изменил запись таким образом, чтобы предотвратить систему от идентификации правильной записи для обновления или удаления.

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED, когда таблица, в ней обветшается, не имеет основного ключа или уникального индекса и у вас недостаточно столбцов в наборе рекордов, чтобы однозначно определить строку таблицы.

## <a name="see-also"></a>См. также раздел

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[Набор записей. Порядок выборки записей в наборе (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)<br/>
[Рекордная полевая биржа (RFX)](../../data/odbc/record-field-exchange-rfx.md)<br/>
[SQL](../../data/odbc/sql.md)<br/>
[Исключения. Исключения баз данных](../../mfc/exceptions-database-exceptions.md)
