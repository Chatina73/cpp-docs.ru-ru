---
title: Набор записей. Дополнительные сведения об обновлениях (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- records, updating
- transactions, updating recordsets
- ODBC recordsets, updating
- multiuser environments, updates to recordsets
- scrolling, updates to recordsets
- updating recordsets
- recordsets, updating
ms.assetid: 0353a742-d226-4fe2-8881-a7daeffe86cd
ms.openlocfilehash: b34f6f51c6ff3a0995f4cf6044ddd7949644f42c
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50665300"
---
# <a name="recordset-more-about-updates-odbc"></a>Набор записей. Дополнительные сведения об обновлениях (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

Содержание раздела:

- [Влияние обновления других операций, таких как транзакции,](#_core_how_transactions_affect_updates).

- [Обновления и других пользователей](#_core_your_updates_and_the_updates_of_other_users).

- [Дополнительные сведения о функции-члены Update и Delete](#_core_more_about_update_and_delete).

> [!NOTE]
>  Этот раздел относится к объектам, производным от `CRecordset` в какой строке массовой выборка не был реализован. Если вы реализовали выборка строк, некоторые данные не применяется. Например, нельзя вызывать `AddNew`, `Edit`, `Delete`, и `Update` функций-членов; тем не менее, можно выполнять транзакции. Дополнительные сведения о массовой выборке строк см. в разделе [набор записей: получение записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

##  <a name="_core_how_other_operations_affect_updates"></a> Влияние на другие операции обновления

Обновления, подвержены транзакций действует во время обновления, закрыв набор записей до завершения транзакции и прокручивается до завершения транзакции.

###  <a name="_core_how_transactions_affect_updates"></a> Влияние транзакций на обновления

Помимо понимания как `AddNew`, `Edit`, и `Delete` работы, важно понять, как `BeginTrans`, `CommitTrans`, и `Rollback` функциями-членами [CDatabase](../../mfc/reference/cdatabase-class.md) работают с функции обновления [CRecordset](../../mfc/reference/crecordset-class.md).

По умолчанию вызывает `AddNew` и `Edit` влияют на источник данных, немедленно при вызове `Update`. `Delete` вызовы вступают в силу немедленно. Но можно создать транзакцию и выполнить пакет такие вызовы. Обновления не являются постоянными, до их фиксации. Если вы передумаете, выполнить откат транзакции, а его фиксацией.

Дополнительные сведения о транзакциях см. в разделе [транзакции (ODBC)](../../data/odbc/transaction-odbc.md).

###  <a name="_core_how_closing_the_recordset_affects_updates"></a> Влияние закрытия набора записей на обновление

Если вы закроете набор записей или связанный с ним `CDatabase` из объектов, во время выполнения транзакции (не вызывался [CDatabase::CommitTrans](../../mfc/reference/cdatabase-class.md#committrans) или [CDatabase::Rollback](../../mfc/reference/cdatabase-class.md#rollback)), откат транзакции обратно автоматически (если серверной части базы данных не базы данных Microsoft Jet).

> [!CAUTION]
>  Если вы используете базы данных Microsoft Jet, закрытии набора записей в явной транзакции не приводит освобождение строк, которые были изменены или блокировок, которые были размещены пока явная транзакция фиксируется или откатывается назад. Рекомендуется, вы всегда как открывающие и закрывающие наборы записей внутри или вне явной транзакции Jet.

###  <a name="_core_how_scrolling_affects_updates"></a> Влияние прокрутки на обновление

Когда вы [набор записей: прокрутка (ODBC)](../../data/odbc/recordset-scrolling-odbc.md) в наборе записей, в буфере заполняется каждая новая текущая запись (предыдущая запись при этом не сохраняется). При прокрутке пропускаются ранее удаленные записи. Если прокрутить после `AddNew` или `Edit` вызов без вызова `Update`, `CommitTrans`, или `Rollback` во-первых, все изменения будут потеряны (предупреждение при этом не отображается) при записи в буфер. В буфере заполняется новая запись, сохраненная запись освобождается и не произойдет никаких изменений в источнике данных. Это относится как `AddNew` и `Edit`.

##  <a name="_core_your_updates_and_the_updates_of_other_users"></a> Обновления и обновления других пользователей

При использовании набора записей для обновления данных, изменения влияют на других пользователей. Аналогичным образом обновления других пользователей в течение времени существования набора записей затрагивают именно вас.

В многопользовательской среде другие пользователи могут открывать наборы записей, которые содержат некоторые из записей, выбранных в набор записей. Изменения в записи до ее извлечения, отражаются в наборе записей. Так как динамических подмножеств данных извлекают записи каждый раз при переходе на нее, динамических подмножеств данных отражают изменения каждый раз при переходе к записи. Моментальные снимки извлечение записи при первом переходе на нее, поэтому моментальные снимки отражены только те изменения, которые произойти, прежде чем перейти к записи, изначально.

Записи, добавленные другими пользователями после открытия набора записей не отображаются в наборе данных только по отдельному запросу. Если набор записей является динамическим подмножеством данных, изменения существующих записей, другие пользователи будут отображаться динамического набора при прокрутке к измененной записи. Если набор записей является моментальным снимком, изменения не отображаются до requery моментального снимка. Если вы хотите просмотреть записи, добавленные или удаленные другими пользователями в моментальный снимок или записи, добавленные другими пользователями динамического набора, вызовите метод [метод CRecordset::Requery](../../mfc/reference/crecordset-class.md#requery) для перестроения набор записей. (Обратите внимание, что удаления других пользователей будут отображаться динамического набора). Также можно вызвать метод `Requery` для просмотра записей, добавленные, но не см. в разделе удаления.

> [!TIP]
>  Чтобы выполнить принудительное кэширование всего моментального снимка за один раз, вызовите `MoveLast` сразу же после открытия моментального снимка. Затем вызовите `MoveFirst` для начала работы с записями. `MoveLast` эквивалентно прокрутке все записи, но он извлекает все сразу. Обратите внимание, что это может снизить производительность и может не потребоваться для некоторых драйверов.

Влияние обновления на других пользователей, аналогичны их воздействия на вас.

##  <a name="_core_more_about_update_and_delete"></a> Дополнительные сведения о Update и Delete

Этот раздел содержит дополнительные сведения, которые помогают работать с `Update` и `Delete`.

### <a name="update-success-and-failure"></a>Обновление Успех и отказ

Если `Update` завершается успешно, `AddNew` или `Edit` режиме заканчивается. Чтобы начать `AddNew` или `Edit` режим, вызов `AddNew` или `Edit`.

Если `Update` завершается сбоем (возвращает значение FALSE или создает исключение), остаются в `AddNew` или `Edit` режим, в зависимости от того, какая функция вызывается последнего. Затем можно выполнить одно из следующих:

- Изменить член поля данных и повторите `Update` еще раз.

- Вызовите `AddNew` сбросить элементами данных полей в значение Null, задайте значения свойств поля элементов данных, а затем вызовите `Update` еще раз.

- Вызовите `Edit` перезагрузить значений, сохраненных в наборе записей до первого вызова `AddNew` или `Edit`, задайте значения свойств поля элементов данных, а затем вызовите `Update` еще раз. После успешной `Update` вызова (Кроме запуска после `AddNew` вызова), элементами данных полей сохраняются новые значения.

- Вызовите `Move` (включая `Move` с параметром AFX_MOVE_REFRESH или 0), который очищает любые изменения и завершает `AddNew` или `Edit` действующий режим.

### <a name="update-and-delete"></a>Update и Delete

Этот раздел относится к обоим `Update` и `Delete`.

На `Update` или `Delete` операции, должны обновляться только одна запись. Этой записи является текущей записи, соответствующее значениям данных в полях набора записей. Если для какой-либо причине записи не изменяются или несколько записей, создается исключение с одним из следующих **RETCODE** значения:

- AFX_SQL_ERROR_NO_ROWS_AFFECTED

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED

При возникновении этих исключений, позволяя держать `AddNew` или `Edit` состояние, при вызове `Update` или `Delete`. Ниже приведены наиболее распространенные сценарии, в которых будет видеть эти исключения. Вы скорее всего, см. в разделе:

- AFX_SQL_ERROR_NO_ROWS_AFFECTED при использовании режима оптимистичной блокировки и другой пользователь изменил запись таким образом, предотвращает платформы идентификации запись update или delete.

- AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED при обновлении таблицы не имеет первичного ключа или уникального индекса, а не содержит достаточного количества столбцов в наборе записей для уникальной идентификации строки таблицы.

## <a name="see-also"></a>См. также

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[Набор записей. Порядок выборки записей в наборе (ODBC)](../../data/odbc/recordset-how-recordsets-select-records-odbc.md)<br/>
[Обмен данными полей записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)<br/>
[SQL](../../data/odbc/sql.md)<br/>
[Исключения. Исключения баз данных](../../mfc/exceptions-database-exceptions.md)