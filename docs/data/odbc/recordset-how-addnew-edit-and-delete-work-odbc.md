---
title: Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- records [C++], updating
- record editing [C++], in recordsets
- recordsets [C++], adding records
- records [C++], adding
- ODBC recordsets [C++], adding records
- recordsets [C++], editing records
- recordsets [C++], updating
- AddNew method
- ODBC recordsets [C++], deleting records
- records [C++], deleting in recordsets
- data in recordsets [C++]
- recordsets [C++], deleting records
- ODBC recordsets [C++], editing records
- records [C++], editing
ms.assetid: cab43d43-235a-4bed-ac05-67d10e94f34e
ms.openlocfilehash: 13d4461833180b527fae153c1677c9e911fc2737
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/31/2018
ms.locfileid: "50620485"
---
# <a name="recordset-how-addnew-edit-and-delete-work-odbc"></a>Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

В этом разделе объясняется как `AddNew`, `Edit`, и `Delete` функции-члены класса `CRecordset` работать. Рассмотрены следующие темы.

- [Принципы добавления записей](#_core_adding_a_record)

- [Видимость добавленных записей](#_core_visibility_of_added_records)

- [Изменение записи](#_core_editing_an_existing_record)

- [Принципы удаления записей](#_core_deleting_a_record)

> [!NOTE]
>  Этот раздел относится к объектам, производным от `CRecordset` в какой строке массовой выборка не был реализован. Если вы используете выборка строк, см. в разделе [набор записей: получение записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

В дополнение, вы можете прочитать [обмен полями записей: принцип работы RFX](../../data/odbc/record-field-exchange-how-rfx-works.md), которая описывает роль RFX в операциях обновления.

##  <a name="_core_adding_a_record"></a> Добавление записи

Добавление новой записи в набор записей подразумевает вызов набора записей [AddNew](../../mfc/reference/crecordset-class.md#addnew) функция-член, установки значений элементов данных полей новой записи и вызова [обновления](../../mfc/reference/crecordset-class.md#update) функции-члена для записи запись в источник данных.

В вызове функции-члена `AddNew`, набор записей не должен быть открыт только для чтения. `CanUpdate` И `CanAppend` функции-члены позволяют определять эти условия.

При вызове `AddNew`:

- Запись в буфере редактирования, сохраняется, чтобы можно было восстановить его содержимое, если операция отменена.

- Элементами данных полей отмечаются, так что вполне возможно, для обнаружения изменений в их позже. Поля данных, элементы также помечаются как чистые (без изменений) и присваивается значение Null.

После вызова метода `AddNew`, в буфере представляет новый, пустая запись, заполненный значениями. Чтобы сделать это, можно вручную установить значения, назначая им. Вместо указания конкретного значения для поля, можно вызвать `SetFieldNull` для указания значения Null.

Чтобы зафиксировать изменения, необходимо вызвать `Update`. При вызове `Update` для новой записи:

- Если драйвер ODBC поддерживает `::SQLSetPos` ODBC API, MFC использует эту функцию для добавления записи в источнике данных. С помощью `::SQLSetPos`, MFC более эффективно можно добавить запись, так как он имеет для создания и обработки инструкции SQL.

- Если `::SQLSetPos` не может быть использована, MFC выполняет следующее:

    1.  Если изменения не обнаружены, `Update` ничего не делает и возвращает значение 0.

    2.  При наличии изменений, `Update` конструкции SQL **вставить** инструкции. Столбцы, представленные все члены поля "грязных" данных, перечислены в **вставить** инструкции. Чтобы принудительно включить столбец, вызовите [SetFieldDirty](../../mfc/reference/crecordset-class.md#setfielddirty) функция-член:

        ```
        SetFieldDirty( &m_dataMember, TRUE );
        ```

    3.  `Update` фиксирует новую запись — **вставить** выполняется инструкция, и запись фиксируется в таблицу источника данных (и в наборе записей, если он не моментальный снимок), если транзакция уже выполняется.

    4.  Сохраненная запись восстанавливается в буфере. Запись, которая была текущей до `AddNew` вызов является текущей, снова независимо от того, следует ли **вставить** инструкция была выполнена успешно.

    > [!TIP]
    >  Для обеспечения полного контроля над новой записью можно использовать следующий подход: задайте значения всех полей, которые будут иметь значения и явным образом задать все поля, которые останутся Null путем вызова `SetFieldNull` с использованием указателя на поле и параметра TRUE (по умолчанию). Если вы хотите убедиться, что поле не записываются в источник данных, вызов `SetFieldDirty` с использованием указателя на поле и параметра FALSE и не изменяйте значение поля. Чтобы определить, разрешено ли поле иметь значение Null, вызовите `IsFieldNullable`.

    > [!TIP]
    >  Для обнаружения изменений значений элементов данных набора записей, MFC использует PSEUDO_NULL значение, подходящее для каждого типа данных, которые можно хранить в наборе записей. Если необходимо явно задать полю значение PSEUDO_NULL и поле происходит уже помечено как Null, необходимо также вызвать `SetFieldNull`, передав адрес поля в первого параметра и значение FALSE в качестве второго параметра.

##  <a name="_core_visibility_of_added_records"></a> Видимость добавленных записей

Если добавленная запись является видимой для набора записей? Иногда отображаются добавленных записей и иногда не отображаются, в зависимости от две вещи:

- Какой драйвер способен.

- Какую платформу можно воспользоваться преимуществами.

Если драйвер ODBC поддерживает `::SQLSetPos` ODBC API, MFC использует эту функцию для добавления записей. С помощью `::SQLSetPos`, добавленные записи являются видимыми для любого обновляемого набора записей MFC. Не поддерживается для функции, добавленные записи не отображаются, и необходимо вызвать `Requery` видеть их. С помощью `::SQLSetPos` также является более эффективным.

##  <a name="_core_editing_an_existing_record"></a> Изменение существующей записи

Изменение существующей записи в наборе записей предполагает переход к записи, вызов набора записей [изменить](../../mfc/reference/crecordset-class.md#edit) функция-член, установки значений элементов данных полей новой записи и вызова [обновить](../../mfc/reference/crecordset-class.md#update)функцию-член для записи измененной записи в источник данных.

В вызове функции-члена `Edit`, набор записей должно быть обновляемым и на запись. `CanUpdate` И `IsDeleted` функции-члены позволяют определять эти условия. Текущая запись также должна не уже были удалены, и должен существовать записей в наборе записей (оба `IsBOF` и `IsEOF` возвращают 0).

При вызове `Edit`, запись в буфере редактирования (текущая запись), сохраняется. Сохраненная запись значения позже используются для определения того, были ли изменены все поля.

После вызова метода `Edit`, в буфере по-прежнему представляет текущую запись, но теперь готов для сохранения изменений в поля элементов данных. Чтобы изменить запись, вручную задаются значения, все поля элементов данных, которые вы хотите изменить. Вместо указания конкретного значения для поля, можно вызвать `SetFieldNull` для указания значения Null. Чтобы зафиксировать изменения, вызовите `Update`.

> [!TIP]
>  Чтобы получить из `AddNew` или `Edit` режиме, вызовите `Move` с параметром *AFX_MOVE_REFRESH*.

В вызове функции-члена `Update`, набор записей не должно быть пустым и текущей записи должен не были удалены. `IsBOF`, `IsEOF`, и `IsDeleted` должны возвращать значение 0.

При вызове `Update` для измененной записи:

- Если драйвер ODBC поддерживает `::SQLSetPos` ODBC API, MFC использует эту функцию для обновления записи в источнике данных. С помощью `::SQLSetPos`, драйвер сравнивает содержимое буфера редактирования с соответствующей записью на сервере, обновляя запись на сервере, если они отличаются. С помощью `::SQLSetPos`, MFC можно более эффективно обновлять записи, так как он имеет для создания и обработки инструкции SQL.

     - или -

- Если `::SQLSetPos` не может быть использована, MFC выполняет следующее:

    1.  Если будут внесены изменения, не `Update` ничего не делает и возвращает значение 0.

    2.  При наличии изменений, `Update` конструкции SQL **обновления** инструкции. Столбцы, перечисленные в **обновления** инструкции основаны на элементами данных полей, которые были изменены.

    3.  `Update` Фиксирует изменения, выполняет **обновления** инструкции — и запись в источнике данных изменяется, но если только транзакции не выполняется (см. в разделе [транзакции: выполнение транзакции в наборе записей (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md) сведения о влиянии обновления транзакции). ODBC сохраняет копию записи, которая также изменяется.

    4.  В отличие от выполнения `AddNew`, `Edit` сохраненная запись не восстанавливается. Измененной записи остается в качестве текущей записи.

    > [!CAUTION]
    >  При подготовке к обновлению набора записей, вызвав `Update`, будьте внимательны, что набор записей включает все столбцы, составляющие первичный ключ таблицы (или все столбцы уникального индекса для таблицы или недостаточно столбцов для уникальной идентификации строк). В некоторых случаях может использоваться платформой только столбцы, выбранные в наборе записей для определения записи в таблице для обновления. Без необходимых столбцов может обновить несколько записей в таблице. В этом случае платформа создает исключения, при вызове `Update`.

    > [!TIP]
    >  При вызове метода `AddNew` или `Edit` после вызова любой из этих функций ранее, но до вызова `Update`, обновляются с использованием хранимая запись вместо новой или измененной записи в буфере. Это дает возможность прервать `AddNew` или `Edit` и начать новый: Если вы понимаете, что неисправность записи выполняется, просто вызовите `Edit` или `AddNew` еще раз.

##  <a name="_core_deleting_a_record"></a> Удаление записи

Удаление записи из набора записей предполагает переход к записи и вызов набора записей [удалить](../../mfc/reference/crecordset-class.md#delete) функция-член. В отличие от `AddNew` и `Edit`, `Delete` не требует соответствующего вызова `Update`.

В вызове функции-члена `Delete`, набор записей должна быть обновлена, и он должен размещаться в записи. `CanUpdate`, `IsBOF`, `IsEOF`, И `IsDeleted` функции-члены позволяют определять эти условия.

При вызове `Delete`:

- Если драйвер ODBC поддерживает `::SQLSetPos` ODBC API, MFC использует эту функцию для удаления записи в источнике данных. С помощью `::SQLSetPos` обычно более эффективен, чем с помощью SQL.

     - или -

- Если `::SQLSetPos` не может быть использована, MFC выполняет следующее:

    1.  В качестве текущей записи в буфере редактирования не резервного копирования `AddNew` и `Edit`.

    2.  `Delete` Создает SQL **удалить** инструкцию, которая удаляет запись.

         Текущая запись в буфере редактирования не сохраняется как в `AddNew` и `Edit`.

    3.  `Delete` фиксирует удаление — выполняет **удалить** инструкции. Запись помечается как удаленная в источнике данных и, если запись является моментальным снимком, в ODBC.

    4.  Удаленная запись все еще находятся в элементами данных полей в наборе записей, но значение Null, а также набора записей, помеченные элементами данных полей `IsDeleted` функция-член возвращает ненулевое значение.

    > [!NOTE]
    >  После удаления записи, следует перейти к другой записи, чтобы заполнить в буфере, с новой записи данных. Это ошибка для вызова `Delete` еще раз или вызвать метод `Edit`.

Сведения об инструкциях SQL, используемых в операциях обновления, см. в разделе [SQL](../../data/odbc/sql.md).

## <a name="see-also"></a>См. также

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[Набор записей. Дополнительные сведения об обновлениях (ODBC)](../../data/odbc/recordset-more-about-updates-odbc.md)<br/>
[Обмен данными полей записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)