---
title: Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- records [C++], updating
- record editing [C++], in recordsets
- recordsets [C++], adding records
- records [C++], adding
- ODBC recordsets [C++], adding records
- recordsets [C++], editing records
- recordsets [C++], updating
- AddNew method
- ODBC recordsets [C++], deleting records
- records [C++], deleting in recordsets
- data in recordsets [C++]
- recordsets [C++], deleting records
- ODBC recordsets [C++], editing records
- records [C++], editing
ms.assetid: cab43d43-235a-4bed-ac05-67d10e94f34e
ms.openlocfilehash: 8799ac36c443898f1e32b539f017e682bbf3e033
ms.sourcegitcommit: 857fa6b530224fa6c18675138043aba9aa0619fb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/24/2020
ms.locfileid: "80212915"
---
# <a name="recordset-how-addnew-edit-and-delete-work-odbc"></a>Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

В этом разделе объясняется, как `AddNew`, `Edit`и `Delete` функции членов класса `CRecordset` работать. Здесь рассматриваются такие темы:

- [Как работает Добавление записей](#_core_adding_a_record)

- [Видимость добавленных записей](#_core_visibility_of_added_records)

- [Как работает редактирование записей](#_core_editing_an_existing_record)

- [Как работает удаление записей](#_core_deleting_a_record)

> [!NOTE]
>  Этот раздел относится к объектам, производным от `CRecordset`, в которых пакетное получение строк не реализовано. Если используется многострочная выборка строк, см. раздел [набор записей: групповая выборка записей (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

В качестве дополнения можно читать [Обмен полями записей: как работает RFX](../../data/odbc/record-field-exchange-how-rfx-works.md), описывающий СООТВЕТСТВУЮЩУЮ роль RFX в операциях Update.

##  <a name="adding-a-record"></a><a name="_core_adding_a_record"></a>Добавление записи

Добавление новой записи в набор записей включает вызов функции-члена [AddNew](../../mfc/reference/crecordset-class.md#addnew) набора записей, задание значений элементов данных поля новой записи и вызов функции-члена [обновления](../../mfc/reference/crecordset-class.md#update) для записи записи в источник данных.

В качестве предусловия для вызова `AddNew`набор записей не должен быть открыт только для чтения. Функции членов `CanUpdate` и `CanAppend` позволяют определить эти условия.

При вызове `AddNew`:

- Запись в буфере редактирования сохраняется, поэтому ее содержимое можно восстановить, если операция отменена.

- Элементы данных поля помечаются пометкой, чтобы можно было обнаружить изменения в них позже. Элементы данных поля также помечаются как чистые (без изменений) и устанавливаются в значение null.

После вызова `AddNew`буфер редактирования представляет новую пустую запись, готовую к заполнению значениями. Для этого вручную задайте значения, назначив их. Вместо указания фактического значения данных для поля можно вызвать `SetFieldNull`, чтобы указать значение null.

Чтобы зафиксировать изменения, вызовите `Update`. При вызове `Update` для новой записи:

- Если драйвер ODBC поддерживает функцию `::SQLSetPos` ODBC API, MFC использует функцию для добавления записи в источник данных. С помощью `::SQLSetPos`MFC может добавить запись более эффективно, так как ей не нужно создавать и обрабатывать инструкцию SQL.

- Если `::SQLSetPos` нельзя использовать, MFC выполняет следующие действия:

   1. Если изменения не обнаружены, `Update` не выполняет никаких действий и возвращает значение 0.

   1. При наличии изменений `Update` формирует инструкцию SQL **INSERT** . Столбцы, представленные всеми элементами данных «грязных» полей, перечислены в инструкции **INSERT** . Чтобы принудительно включить столбец, вызовите функцию-член [сетфиелддирти](../../mfc/reference/crecordset-class.md#setfielddirty) :

        ```cpp
        SetFieldDirty( &m_dataMember, TRUE );
        ```

   1. `Update` фиксирует новую запись — инструкция **INSERT** выполняется, а запись фиксируется в таблице в источнике данных (и наборе записей, если он не является моментальным снимком), если только не выполняется транзакция.

   1. Сохраненная запись восстанавливается в буфер редактирования. Запись, которая была текущей до вызова `AddNew`, снова становится текущей независимо от того, была ли успешно выполнена инструкция **INSERT** .

   > [!TIP]
   > Для полного управления новой записью сделайте следующий подход: задайте значения для всех полей, которые будут иметь значения, а затем явно задавайте поля, которые останутся пустыми, вызвав `SetFieldNull` с указателем на поле, а параметр — TRUE (по умолчанию). Если необходимо обеспечить, чтобы поле не записывалось в источник данных, вызовите `SetFieldDirty` с указателем на поле и параметром FALSE и не изменяйте значение поля. Чтобы определить, может ли поле иметь значение null, вызовите `IsFieldNullable`.

   > [!TIP]
   > Чтобы определить, когда изменяется значение элементов данных набора записей, MFC использует PSEUDO_NULL значение, соответствующее каждому типу данных, который можно хранить в наборе записей. Если необходимо явно задать для поля значение PSEUDO_NULL и поле уже помечено как null, необходимо также вызвать метод `SetFieldNull`, передав адрес поля в первом параметре и значение FALSE во втором параметре.

##  <a name="visibility-of-added-records"></a><a name="_core_visibility_of_added_records"></a>Видимость добавленных записей

Когда добавляется запись, видимая для набора записей? Добавленные записи иногда отображаются и иногда не отображаются в зависимости от двух вещей:

- Возможности драйвера.

- Возможности, которые может использовать платформа.

Если драйвер ODBC поддерживает функцию `::SQLSetPos` ODBC API, MFC использует функцию для добавления записей. С `::SQLSetPos`добавленные записи видимы для любого обновляемого набора записей MFC. Без поддержки функции добавленные записи не отображаются, и для их просмотра необходимо вызвать `Requery`. Использование `::SQLSetPos` также более эффективно.

##  <a name="editing-an-existing-record"></a><a name="_core_editing_an_existing_record"></a>Изменение существующей записи

Изменение существующей записи в наборе записей включает прокрутку к записи, вызов функции-члена [редактирования](../../mfc/reference/crecordset-class.md#edit) набора записей, установку значений элементов данных поля новой записи и вызов функции [обновления](../../mfc/reference/crecordset-class.md#update) -члена для записи измененной записи в источник данных.

В качестве предусловия для вызова `Edit`набор записей должен поддерживать обновление и запись. Функции членов `CanUpdate` и `IsDeleted` позволяют определить эти условия. Текущая запись также не должна быть удалена, и в наборе записей должны быть записи (как `IsBOF`, так и `IsEOF` возвращают 0).

При вызове `Edit`сохраняется запись в буфере редактирования (текущая запись). Значения хранимой записи позже используются для определения, изменились ли какие бы то ни было поля.

После вызова `Edit`буфер редактирования по-прежнему представляет текущую запись, но теперь готов к принятию изменений в элементы данных поля. Чтобы изменить запись, необходимо вручную задать значения всех элементов данных полей, которые требуется изменить. Вместо указания фактического значения данных для поля можно вызвать `SetFieldNull`, чтобы указать значение null. Чтобы зафиксировать изменения, вызовите `Update`.

> [!TIP]
> Чтобы выйти из режима `AddNew` или `Edit`, вызовите `Move` с параметром *AFX_MOVE_REFRESH*.

В качестве предусловия для вызова `Update`набор записей не должен быть пустым, а текущая запись не должна быть удалена. `IsBOF`, `IsEOF`и `IsDeleted` должны возвращать 0.

При вызове `Update` для измененной записи:

- Если драйвер ODBC поддерживает функцию `::SQLSetPos` ODBC API, MFC использует функцию для обновления записи в источнике данных. При использовании `::SQLSetPos`драйвер сравнивает буфер редактирования с соответствующей записью на сервере, обновляя запись на сервере, если эти две различаются. При использовании `::SQLSetPos`MFC может обновлять запись более эффективно, поскольку ей не нужно создавать и обрабатывать инструкцию SQL.

   \- или -

- Если `::SQLSetPos` нельзя использовать, MFC выполняет следующие действия:

   1. Если изменения отсутствуют, `Update` не выполняет никаких действий и возвращает значение 0.

   1. При наличии изменений `Update` формирует инструкцию SQL **Update** . Столбцы, перечисленные в инструкции **Update** , основываются на измененных элементах данных полей.

   1. `Update` фиксирует изменения — выполняет инструкцию **Update** , а запись изменяется в источнике данных, но не фиксируется, если выполняется транзакция (см. [транзакцию выполнение транзакции в наборе записей (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md) ), чтобы получить сведения о том, как транзакция влияет на обновление. ODBC сохраняет копию записи, которая также изменяется.

   1. В отличие от процесса для `AddNew`, процесс `Edit` не восстанавливает хранимую запись. Измененная запись остается на месте текущей записи.

   > [!CAUTION]
   > При подготовке к обновлению набора записей путем вызова `Update`Следите за тем, чтобы набор записей включал все столбцы, которые составляют первичный ключ таблицы (или все столбцы любого уникального индекса в таблице, или достаточное количество столбцов для уникальной идентификации строки). В некоторых случаях платформа может использовать только столбцы, выбранные в наборе записей, чтобы указать, какую запись в таблице нужно обновить. При отсутствии всех необходимых столбцов в таблице могут быть обновлены несколько записей. В этом случае платформа создает исключения при вызове `Update`.

   > [!TIP]
   > Если вы вызываете `AddNew` или `Edit` после того, как ранее вызывалась какая-либо функция, но перед вызовом `Update`, буфер редактирования обновляется хранимой записью, заменяя новую или измененную запись. Такое поведение дает возможность прервать `AddNew` или `Edit` и начать новый: Если вы определили, что запись выполняется неудачно, просто вызовите `Edit` или `AddNew` снова.

##  <a name="deleting-a-record"></a><a name="_core_deleting_a_record"></a>Удаление записи

Удаление записи из набора записей включает прокрутку к записи и вызов функции-члена [Delete](../../mfc/reference/crecordset-class.md#delete) набора записей. В отличие от `AddNew` и `Edit`, `Delete` не требует соответствующего вызова `Update`.

В качестве предусловия для вызова `Delete`набор записей должен быть обновляемым и должен быть в записи. Функции членов `CanUpdate`, `IsBOF`, `IsEOF`и `IsDeleted` позволяют определить эти условия.

При вызове `Delete`:

- Если драйвер ODBC поддерживает функцию `::SQLSetPos` ODBC API, MFC использует функцию для удаления записи из источника данных. Использование `::SQLSetPos` обычно более эффективно, чем использование SQL.

   \- или -

- Если `::SQLSetPos` нельзя использовать, MFC выполняет следующие действия:

   1. Текущая запись в буфере редактирования не архивируется, как в `AddNew` и `Edit`.

   1. `Delete` конструирует инструкцию SQL **Delete** , которая удаляет запись.

      Текущая запись в буфере редактирования не сохраняется, как в `AddNew` и `Edit`.

   1. `Delete` фиксирует удаление — выполняет инструкцию **Delete** . Запись помечается как удаленная в источнике данных и, если запись является моментальным снимком, в ODBC.

   1. Значения удаленной записи по-прежнему находятся в элементах данных поля набора записей, но элементы данных поля помечаются как null, а функция-член `IsDeleted` набора записей возвращает ненулевое значение.

   > [!NOTE]
   > После удаления записи необходимо перейти к другой записи, чтобы перезаполнить буфер редактирования данными новой записи. Вызов `Delete` повторно или вызов `Edit`вызывается ошибкой.

Дополнительные сведения о инструкциях SQL, используемых в операциях Update, см. в разделе [SQL](../../data/odbc/sql.md).

## <a name="see-also"></a>См. также раздел

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[Набор записей. Дополнительные сведения об обновлениях (ODBC)](../../data/odbc/recordset-more-about-updates-odbc.md)<br/>
[Обмен данными полей записей (RFX)](../../data/odbc/record-field-exchange-rfx.md)
