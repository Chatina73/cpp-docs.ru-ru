---
title: Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- records [C++], updating
- record editing [C++], in recordsets
- recordsets [C++], adding records
- records [C++], adding
- ODBC recordsets [C++], adding records
- recordsets [C++], editing records
- recordsets [C++], updating
- AddNew method
- ODBC recordsets [C++], deleting records
- records [C++], deleting in recordsets
- data in recordsets [C++]
- recordsets [C++], deleting records
- ODBC recordsets [C++], editing records
- records [C++], editing
ms.assetid: cab43d43-235a-4bed-ac05-67d10e94f34e
ms.openlocfilehash: 63718a6be3a9ce19ddbce923a84def21448c42a0
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81367004"
---
# <a name="recordset-how-addnew-edit-and-delete-work-odbc"></a>Наборы записей. Принципы работы функций AddNew, Edit и Delete (ODBC)

Этот раздел относится к классам ODBC библиотеки MFC.

Эта тема `AddNew`объясняет, `Edit`как `Delete` , и `CRecordset` член функции класса работы. Здесь рассматриваются такие темы:

- [Как работает добавление записей](#_core_adding_a_record)

- [Видимость добавленных записей](#_core_visibility_of_added_records)

- [Как работает редактирование записей](#_core_editing_an_existing_record)

- [Как работает deleting Records](#_core_deleting_a_record)

> [!NOTE]
> Этот раздел относится к объектам, производным от `CRecordset`, в которых пакетное получение строк не реализовано. Если вы используете объем строки извлечения, см [Recordset: Извлечение записей в массовых (ODBC)](../../data/odbc/recordset-fetching-records-in-bulk-odbc.md).

В качестве дополнения, вы можете прочитать [Record Field Exchange: How RFX Works](../../data/odbc/record-field-exchange-how-rfx-works.md), который описывает соответствующую роль RFX в операциях обновления.

## <a name="adding-a-record"></a><a name="_core_adding_a_record"></a>Добавление записи

Добавление новой записи к набору записей включает в себя вызов функции [члена AddNew](../../mfc/reference/crecordset-class.md#addnew) записи, установление значений полевых данных новых членов записи и вызов функции участника [обновления](../../mfc/reference/crecordset-class.md#update) для записи в исходный исход данных.

В качестве предварительного `AddNew`условия для вызова, рекордсет не должен был быть открыт как только для чтения. `CanUpdate` Функции `CanAppend` и функции участника позволяют определить эти условия.

Когда вы `AddNew`звоните:

- Запись в буфере отодействия сохраняется, поэтому ее содержимое может быть восстановлено, если операция отменена.

- Члены полевых данных помечены таким образом, чтобы можно было обнаружить изменения в них позже. Члены полевых данных также помечены как чистые (без изменений) и настроены на Null.

После вызова `AddNew`буфер отсеивок представляет собой новую пустую запись, готовую к заполнению значениями. Для этого вы вручную устанавливаете значения, назначая им. Вместо указания фактического значения данных для поля `SetFieldNull` можно вызвать вызов, чтобы указать значение Null.

Чтобы совершить изменения, `Update`вы звоните . При вызове `Update` новой записи:

- Если драйвер ODBC `::SQLSetPos` поддерживает функцию ODBC API, MFC использует эту функцию для добавления записи в источник данных. С `::SQLSetPos`помощью, MFC может добавить запись более эффективно, потому что он не должен строить и обрабатывать выписку s'L.

- Если `::SQLSetPos` не может быть использован, МФЦ делает следующее:

   1. Если изменения не обнаружены, `Update` ничего не делает и возвращает 0.

   1. При внесении `Update` изменений конструируется выписка по S'L **INSERT.** Столбцы, представленные всеми грязными полями данных, перечислены в выписке **INSERT.** Чтобы заставить столбец быть включенным, позвоните в функцию участника [SetFieldDirty:](../../mfc/reference/crecordset-class.md#setfielddirty)

        ```cpp
        SetFieldDirty( &m_dataMember, TRUE );
        ```

   1. `Update`фиксирует новую запись - выполняется заявление **INSERT** и запись совершается в таблице источника данных (и набора записей, если не моментального снимка), если транзакция не выполняется.

   1. Сохраненная запись восстанавливается в буфере отодвивания. Запись, которая была `AddNew` текуща до вызова, снова актуирована независимо от того, была ли успешно выполнена запись **INSERT.**

   > [!TIP]
   > Для полного контроля над новой записью, возьмите следующий подход: установить значения любых полей, которые будут `SetFieldNull` иметь значения, а затем явно установить любые поля, которые останутся Null, вызывая указатель на поле и параметр TRUE (по умолчанию). Если вы хотите убедиться, что поле не записано в источник данных, позвоните `SetFieldDirty` с указателем на поле и параметр FALSE, и не изменяйте значение поля. Чтобы определить, разрешено ли поле `IsFieldNullable`быть недействительным, позвоните .

   > [!TIP]
   > Для обнаружения изменения значения данных, установленных данными, MFC использует PSEUDO_NULL значение, соответствующее каждому типу данных, которое можно хранить в рекордном наборе. Если необходимо четко установить поле к PSEUDO_NULL значение и поле уже будет помечено Null, вы также должны вызвать, `SetFieldNull`передавая адрес поля в первом параметре и FALSE во втором параметре.

## <a name="visibility-of-added-records"></a><a name="_core_visibility_of_added_records"></a>Видимость добавленных записей

Когда добавленная запись видна вашему рекордсету? Добавленные записи иногда отображаются, а иногда не видны, в зависимости от двух вещей:

- На что способен ваш водитель.

- Чем могут воспользоваться фреймворк.

Если ваш драйвер ODBC поддерживает функцию `::SQLSetPos` ODBC API, MFC использует эту функцию для добавления записей. С `::SQLSetPos`помощью добавленных записей видны любые рекордные записи MFC. Без поддержки функции, добавленные записи `Requery` не видны, и вы должны позвонить, чтобы увидеть их. Использование `::SQLSetPos` также является более эффективным.

## <a name="editing-an-existing-record"></a><a name="_core_editing_an_existing_record"></a>Редактирование существующей записи

Редактирование существующей записи в наборе записей включает прокрутку записи, вызов функции члена записи [Edit,](../../mfc/reference/crecordset-class.md#edit) установление значений полевых данных новых членов записи и вызов функции участника [обновления](../../mfc/reference/crecordset-class.md#update) для записи измененной записи в источник данных.

В качестве предварительного `Edit`условия для вызова, рекордсет должен быть updatable и на запись. `CanUpdate` Функции `IsDeleted` и функции участника позволяют определить эти условия. Текущая запись также не должна быть удалена, и должны быть `IsBOF` записи в наборе рекордов (оба и `IsEOF` возврат 0).

При вызове `Edit`записи в буфере отображаемого действия (текущая запись) сохраняется. Значения сохраненной записи позже используются для определения того, изменились ли какие-либо поля.

После вызова `Edit`буфер изменения по-прежнему представляет текущую запись, но теперь готов принять изменения в составе полевых данных. Чтобы изменить запись, вы вручную установите значения любых членов полевых данных, которые вы хотите отменить. Вместо указания фактического значения данных для поля `SetFieldNull` можно вызвать вызов, чтобы указать значение Null. Чтобы совершить изменения, позвоните `Update`.

> [!TIP]
> Чтобы выйти `AddNew` `Edit` из или `Move` режима, позвоните с параметром *AFX_MOVE_REFRESH*.

В качестве предварительного `Update`условия для вызова, запись не должна быть пустой и текущая запись не должны быть удалены. `IsBOF`, `IsEOF`, `IsDeleted` и все должны вернуться 0.

При вызове `Update` отредактированной записи:

- Если ваш драйвер ODBC поддерживает функцию `::SQLSetPos` ODBC API, MFC использует эту функцию для обновления записи в источнике данных. С `::SQLSetPos`помощью, драйвер сравнивает ваш буфер отодействия с соответствующей записью на сервере, обновляя запись на сервере, если они отличаются. С `::SQLSetPos`помощью, MFC может обновить запись более эффективно, потому что он не должен строить и обрабатывать выписку s'L.

   \- или -

- Если `::SQLSetPos` не может быть использован, МФЦ делает следующее:

   1. Если не было никаких изменений, `Update` ничего не делает и возвращает 0.

   1. При внесении `Update` изменений в стройте заявление ОБ **ОБНОВЛЕНИ.** Столбцы, перечисленные в заявлении **UPDATE,** основаны на измененных членах данных на местах.

   1. `Update`фиксирует изменения — выполняет заявление **UPDATE** — и запись изменяется в источнике данных, но не совершается, если транзакция выполняется (см. [Транзакция: Выполнение транзакции в наборе записей (ODBC)](../../data/odbc/transaction-performing-a-transaction-in-a-recordset-odbc.md) для получения информации о том, как транзакция влияет на обновление). ODBC хранит копию записи, которая также меняется.

   1. В отличие `AddNew`от `Edit` процесса, процесс не восстанавливает сохраненную запись. Отредактированная запись остается в силе в качестве текущей записи.

   > [!CAUTION]
   > Когда вы готовитесь обновить `Update`набор записей, позвонив, позаботьтесь о том, чтобы ваш набор включает в себя все столбцы, составляющие основной ключ таблицы (или все столбцы любого уникального индекса на столе, или достаточно столбцов, чтобы однозначно определить строку). В некоторых случаях фреймворк может использовать только выбранные в записи столбцы, чтобы определить, какую запись в таблице обновлять. Без всех необходимых столбцов несколько записей могут быть обновлены в таблице. В этом случае фреймворк выбрасывает исключения при вызове. `Update`

   > [!TIP]
   > Если вы `AddNew` `Edit` вызываете или после вызова любой функции ранее, но прежде чем вы вызываете, `Update`буфер редактирования обновляется с сохраненной записью, заменяя новую или отредактированную запись в процессе. Такое поведение дает вам возможность `AddNew` прервать или `Edit` начать новую: если вы определите, что запись `Edit` `AddNew` в процессе неисправна, просто позвоните или снова.

## <a name="deleting-a-record"></a><a name="_core_deleting_a_record"></a>Удалять запись

Удаление записи из набора записей включает прокрутку до записи и вызов функции [участника записи Delete.](../../mfc/reference/crecordset-class.md#delete) В `AddNew` `Edit`отличие `Delete` от и, не `Update`требует соответствующего вызова .

В качестве предварительного `Delete`условия для вызова, рекордсет должен быть updatable и он должен быть на записи. `CanUpdate`Функции `IsBOF` `IsEOF`участника `IsDeleted` , и функции участника позволяют определить эти условия.

Когда вы `Delete`звоните:

- Если драйвер ODBC `::SQLSetPos` поддерживает функцию ODBC API, MFC использует эту функцию для удаления записи в источнике данных. Использование, `::SQLSetPos` как правило, более эффективно, чем с помощью S'L.

   \- или -

- Если `::SQLSetPos` не может быть использован, МФЦ делает следующее:

   1. Текущая запись в буфере отсеивании не резервируется как в `AddNew` и `Edit`.

   1. `Delete`конструирует заявление S'L **DELETE,** которое удаляет запись.

      Текущая запись в буфере отсеиваний не хранится как в `AddNew` и `Edit`.

   1. `Delete`фиксирует удаление - выполняет сядек **DELETE.** Запись помечается удаленной на источнике данных и, если запись является моментальным снимком, в ODBC.

   1. Значения удаленных записей по-прежнему находятся в полевых данных членов набора записей, но члены полевых данных помечены недействительно, а функция `IsDeleted` члена записи возвращает ненулевое значение.

   > [!NOTE]
   > После удаляния записи следует прокрутить другую запись, чтобы пополнить буфер отсеивания данными новой записи. Это ошибка, чтобы `Delete` позвонить `Edit`еще раз или позвонить .

Для получения информации о выписках по [SQL](../../data/odbc/sql.md)обновлению, используемых в операциях по обновлению, см.

## <a name="see-also"></a>См. также раздел

[Набор записей (ODBC)](../../data/odbc/recordset-odbc.md)<br/>
[Набор записей. Дополнительные сведения об обновлениях (ODBC)](../../data/odbc/recordset-more-about-updates-odbc.md)<br/>
[Рекордная полевая биржа (RFX)](../../data/odbc/record-field-exchange-rfx.md)
