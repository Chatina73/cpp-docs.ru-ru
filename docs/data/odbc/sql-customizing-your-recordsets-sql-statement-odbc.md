---
description: 'Дополнительные сведения о: SQL: Настройка инструкции SQL для набора записей (ODBC)'
title: SQL. Настройка инструкции SQL набора записей (ODBC)
ms.date: 11/04/2016
helpviewer_keywords:
- recordsets, SQL statements
- ODBC recordsets, SQL statements
- SQL statements, customizing
- SQL statements, recordset
- customizing SQL statements
- overriding, SQL statements
- SQL, opening recordsets
ms.assetid: 72293a08-cef2-4be2-aa1c-30565fcfbaf9
ms.openlocfilehash: 73765ed66dacbc017cca6236ae5a90388390fa45
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/11/2020
ms.locfileid: "97278692"
---
# <a name="sql-customizing-your-recordsets-sql-statement-odbc"></a>SQL. Настройка инструкции SQL набора записей (ODBC)

В этом разделе рассматриваются следующие вопросы.

- Как платформа конструирует инструкцию SQL

- Переопределение инструкции SQL

> [!NOTE]
> Эта информация относится к классам ODBC библиотеки MFC. Если вы работаете с классами MFC DAO, ознакомьтесь с разделом «Сравнение Microsoft Jet ядро СУБД SQL и ANSI SQL» справки DAO.

## <a name="sql-statement-construction"></a>Создание инструкции SQL

Выбор записей, основанный на наборе записей, в основном на инструкции SQL **SELECT** . При объявлении класса с помощью мастера он создает переопределяющую версию `GetDefaultSQL` функции-члена, которая выглядит примерно так (для класса набора записей с именем `CAuthors` ).

```cpp
CString CAuthors::GetDefaultSQL()
{
    return "AUTHORS";
}
```

По умолчанию это переопределение возвращает имя таблицы, указанное в мастере. В этом примере имя таблицы — AUTHORs. При последующем вызове функции- `Open` члена набора записей `Open` создается окончательная инструкция **SELECT** в форме:

```
SELECT rfx-field-list FROM table-name [WHERE m_strFilter]
       [ORDER BY m_strSort]
```

где `table-name` получается путем вызова метода `GetDefaultSQL` и `rfx-field-list` получается из вызовов функции RFX в `DoFieldExchange` . Это то, что вы получаете для инструкции **SELECT** , если не заменить ее переопределяющей версией во время выполнения, хотя можно также изменить инструкцию по умолчанию с параметрами или фильтром.

> [!NOTE]
> Если указать имя столбца, содержащего пробелы (или могут содержать), имя необходимо заключить в квадратные скобки. Например, имя "First Name" должно быть "[First Name]".

Чтобы переопределить инструкцию **SELECT** по умолчанию, передайте строку, содержащую полную инструкцию **SELECT** , при вызове метода `Open` . Вместо создания собственной строки по умолчанию набор записей использует указанную строку. Если замещающая инструкция содержит предложение **WHERE** , не указывайте фильтр в, `m_strFilter` так как у вас будут две инструкции фильтра. Аналогично, если замещающая инструкция содержит предложение **ORDER BY** , не указывайте сортировку в, `m_strSort` чтобы не было двух инструкций сортировки.

> [!NOTE]
> Если в фильтрах используются строковые литералы (или другие части инструкции SQL), то может потребоваться "Quote" (заключить в указанные разделители) такие строки с префиксом литерала, зависящим от СУБД, и символом литерального суффикса (или символами).

Вы также можете столкнуться с особыми синтаксическими требованиями для таких операций, как внешние объединения, в зависимости от СУБД. Используйте функции ODBC для получения этих сведений из драйвера СУБД. Например, вызовите метод `::SQLGetTypeInfo` для конкретного типа данных, например `SQL_VARCHAR` , для запроса LITERAL_PREFIX и LITERAL_SUFFIX символов. Если вы создаете код, не зависящий от базы данных, см. [Приложение C: грамматика SQL](/sql/odbc/reference/appendixes/appendix-c-sql-grammar) в [справочнике программиста ODBC](/sql/odbc/reference/odbc-programmer-s-reference) для получения подробных сведений о синтаксисе.

Объект Recordset конструирует инструкцию SQL, которая используется для выбора записей, если не передать пользовательскую инструкцию SQL. Как это делается, зависит главным образом от значения, переданного в параметре *lpszSQL* `Open` функции-члена.

В общей форме инструкции SQL **SELECT** :

```
SELECT [ALL | DISTINCT] column-list FROM table-list
    [WHERE search-condition][ORDER BY column-list [ASC | DESC]]
```

Одним из способов добавления ключевого слова **DISTINCT** в инструкцию SQL набора записей является встраивание ключевого слова в первый вызов функции RFX в `DoFieldExchange` . Пример:

```
...
    RFX_Text(pFX, "DISTINCT CourseID", m_strCourseID);
...
```

> [!NOTE]
> Используйте этот метод только в том случае, если набор записей открыт только для чтения.

## <a name="overriding-the-sql-statement"></a>Переопределение инструкции SQL

В следующей таблице показаны возможности параметра *lpszSQL* для `Open` . Варианты в таблице описаны после таблицы.

**Параметр lpszSQL и результирующая строка SQL**

|Случай|Что передается в lpszSQL|Результирующая инструкция SELECT|
|----------|------------------------------|------------------------------------|
|1|NULL|**Выберите** *RFX-Field-List* **из** *Table-name* .<br /><br /> `CRecordset::Open` вызывает метод `GetDefaultSQL` для получения имени таблицы. Результирующая строка является одним из случаев 2 – 5 в зависимости от `GetDefaultSQL` возвращаемых данных.|
|2|Имя таблицы|**Выберите** *RFX-Field-List* **из** *Table-name* .<br /><br /> Список полей берется из инструкций RFX в `DoFieldExchange` . Если `m_strFilter` и `m_strSort` не пусты, добавляет предложения **WHERE** и/или **ORDER BY** .|
|3-5 \*|Полная инструкция **SELECT** , но без предложения **WHERE** или **ORDER BY**|В соответствии с переданными. Если `m_strFilter` и `m_strSort` не пусты, добавляет предложения **WHERE** и/или **ORDER BY** .|
|четырех \*|Полная инструкция **SELECT** с предложением **WHERE** и/или **ORDER BY**|В соответствии с переданными. `m_strFilter` и (или `m_strSort` ) должны оставаться пустыми или создаваться две инструкции Filter и/или Sort.|
|5.0 \*|Вызов хранимой процедуры|В соответствии с переданными.|

\*`m_nFields`должно быть меньше или равно количеству столбцов, указанных в инструкции **SELECT** . Тип данных каждого столбца, указанного в инструкции **SELECT** , должен совпадать с типом данных соответствующего выходного столбца RFX.

### <a name="case-1---lpszsql--null"></a>Вариант 1, lpszSQL = NULL

Выбор набора записей зависит от того, какие `GetDefaultSQL` возвраты `CRecordset::Open` вызываются. В вариантах с 2 по 5 описаны возможные строки.

### <a name="case-2---lpszsql--a-table-name"></a>Вариант 2 lpszSQL = имя таблицы

Набор записей использует обмен полями записей (RFX) для создания списка столбцов из имен столбцов, указанных в вызовах функций RFX в переопределении класса набора записей `DoFieldExchange` . Если вы использовали мастер для объявления класса Recordset, этот вариант имеет тот же результат, что и вариант 1 (при условии, что имя таблицы, указанное в мастере, передается). Если вы не используете мастер для написания класса, вариант 2 является самым простым способом создания инструкции SQL.

В следующем примере создается инструкция SQL, выбирающая записи из приложения базы данных MFC. Когда платформа вызывает `GetDefaultSQL` функцию члена, она возвращает имя таблицы `SECTION` .

```cpp
CString CEnrollSet::GetDefaultSQL()
{
    return "SECTION";
}
```

Чтобы получить имена столбцов для инструкции SQL **SELECT** , платформа вызывает `DoFieldExchange` функцию члена.

```cpp
void CEnrollSet::DoFieldExchange(CFieldExchange* pFX)
{
    pFX->SetFieldType(CFieldExchange::outputColumn);
    RFX_Text(pFX, "CourseID", m_strCourseID);
    RFX_Text(pFX, "InstructorID", m_strInstructorID);
    RFX_Text(pFX, "RoomNo", m_strRoomNo);
    RFX_Text(pFX, "Schedule", m_strSchedule);
    RFX_Text(pFX, "SectionNo", m_strSectionNo);
}
```

По завершении инструкция SQL выглядит следующим образом:

```sql
SELECT CourseID, InstructorID, RoomNo, Schedule, SectionNo
    FROM SECTION
```

### <a name="case-3---lpszsql--a-selectfrom-statement"></a>Case 3 lpszSQL = оператор SELECT/FROM

Список столбцов указывается вручную вместо того, чтобы использовать RFX для автоматического создания. Это может потребоваться в следующих случаях.

- Необходимо указать ключевое слово **DISTINCT** после **SELECT**.

   Список столбцов должен совпадать с именами и типами столбцов в том же порядке, в котором они перечислены в `DoFieldExchange` .

- Есть основания вручную получать значения столбцов с помощью функции ODBC, а не использовать `::SQLGetData` RFX для привязки и извлечения столбцов.

   Например, вы можете разместить в новых столбцах клиента приложения, добавленного в таблицы базы данных после распространения приложения. Необходимо добавить эти дополнительные элементы данных полей, которые не были известны во время объявления класса с помощью мастера.

   Список столбцов должен совпадать с именами и типами столбцов в том же порядке, в котором они перечислены в `DoFieldExchange` , за которым следуют имена столбцов, привязываются к ним вручную. Дополнительные сведения см. в разделе [набор записей: динамическая привязка столбцов данных (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md).

- Необходимо соединить таблицы, указав несколько таблиц в предложении **from** .

   Дополнительные сведения и пример см. [в разделе набор записей. Выполнение соединения (ODBC)](../../data/odbc/recordset-performing-a-join-odbc.md).

### <a name="case-4---lpszsql--selectfrom-plus-where-andor-order-by"></a>Вариант 4 lpszSQL = SELECT/FROM плюс WHERE and (или ORDER BY)

Вы указываете все: список столбцов (на основе вызовов RFX в `DoFieldExchange` ), список таблиц и содержимое предложения **WHERE** и/или **ORDER BY** . Если указать предложения **WHERE** и/или **ORDER BY** таким образом, не используйте `m_strFilter` и (или) `m_strSort` .

### <a name="case-5---lpszsql--a-stored-procedure-call"></a>Вариант 5 lpszSQL = вызов хранимой процедуры

Если необходимо вызвать предопределенный запрос (например, хранимую процедуру в Microsoft SQL Server базе данных), необходимо написать инструкцию **Call** в строке, которая передается в *lpszSQL*. Мастера не поддерживают объявление класса набора записей для вызова предопределенного запроса. Не все предопределенные запросы возвращают записи.

Если предопределенный запрос не возвращает записи, можно использовать `CDatabase` функцию-член `ExecuteSQL` напрямую. Для предопределенного запроса, который возвращает записи, необходимо также вручную написать вызовы RFX в `DoFieldExchange` для любых столбцов, возвращаемых процедурой. Вызовы RFX должны быть в том же порядке и возвращать те же типы, что и предопределенный запрос. Дополнительные сведения см. в разделе [набор записей: объявление класса для предопределенного запроса (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-predefined-query-odbc.md).

## <a name="see-also"></a>См. также раздел

[SQL: типы данных SQL и C++ (ODBC)](../../data/odbc/sql-sql-and-cpp-data-types-odbc.md)<br/>
[SQL: выполнение прямых вызовов SQL (ODBC)](../../data/odbc/sql-making-direct-sql-calls-odbc.md)
