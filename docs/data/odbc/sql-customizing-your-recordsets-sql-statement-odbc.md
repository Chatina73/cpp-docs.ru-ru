---
title: 'SQL: Настройка инструкции SQL набора записей (ODBC)'
ms.date: 11/04/2016
helpviewer_keywords:
- recordsets, SQL statements
- ODBC recordsets, SQL statements
- SQL statements, customizing
- SQL statements, recordset
- customizing SQL statements
- overriding, SQL statements
- SQL, opening recordsets
ms.assetid: 72293a08-cef2-4be2-aa1c-30565fcfbaf9
ms.openlocfilehash: eabaab019ee94b0c5617573c534d920ec710e9b2
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/23/2019
ms.locfileid: "62329937"
---
# <a name="sql-customizing-your-recordsets-sql-statement-odbc"></a>SQL: Настройка инструкции SQL набора записей (ODBC)

Содержание раздела:

- Как платформа создает инструкцию SQL

- Переопределение инструкции SQL

> [!NOTE]
>  Эти сведения относятся к классам ODBC библиотеки MFC. Если вы работаете с классами MFC DAO, см. в разделе «Сравнения Microsoft Jet базы данных ядра SQL и ANSI SQL» в справке DAO.

## <a name="sql-statement-construction"></a>Конструирование инструкций SQL

Набор записей выполняет выделение записи в основном на SQL **ВЫБЕРИТЕ** инструкции. При объявлении класса с помощью мастера, он записывает переопределение `GetDefaultSQL` функция-член, выглядит примерно следующим образом (для класса набора записей называется `CAuthors`).

```cpp
CString CAuthors::GetDefaultSQL()
{
    return "AUTHORS";
}
```

По умолчанию это переопределение возвращает имя таблицы, указанное с помощью мастера. В этом примере имя таблицы — «АВТОРЫ». При последующем вызове набора записей `Open` функции-члена `Open` создает окончательную **ВЫБЕРИТЕ** инструкцию для формы:

```
SELECT rfx-field-list FROM table-name [WHERE m_strFilter]
       [ORDER BY m_strSort]
```

где `table-name` получается путем вызова `GetDefaultSQL` и `rfx-field-list` получается из вызова функций RFX в `DoFieldExchange`. Это именно **ВЫБЕРИТЕ** инструкции, если не будет заменена переопределением во время выполнения, несмотря на то, что также можно изменить инструкцию по умолчанию с параметрами или фильтр.

> [!NOTE]
>  Если указать имя столбца, который содержит (или может содержать) пробелы, необходимо заключить имя в квадратные скобки. Например «First Name» должны называться «[имя]».

Чтобы переопределить значение по умолчанию **ВЫБЕРИТЕ** инструкции, передайте этот строка, содержащая полный **ВЫБЕРИТЕ** инструкции при вызове `Open`. Вместо создания собственной строки по умолчанию, набор записей использует строку, которую вы указали. Если замещающая инструкция содержит **ГДЕ** предложение, задают фильтр в `m_strFilter` так, как будет получено два фильтра инструкций. Аналогично Если замещающая инструкция содержит **ORDER BY** предложение, не указать порядок сортировки в `m_strSort` таким образом, чтобы не нужно будет двух инструкций сортировки.

> [!NOTE]
>  Если вы используете строковых литералов в фильтрах (или других частей инструкции SQL), может потребоваться «Квота» (заключить в указанные разделители) такие строки с префиксом литерала СУБД и литералов суффикс, символ (или символы).

Особые требования к синтаксису для операций, таких как внешние соединения также могут возникнуть в зависимости от используемой СУБД. Использование функции ODBC для получения этих сведений от драйвера для СУБД. Например, вызвать `::SQLGetTypeInfo` для определенного типа данных, таких как `SQL_VARCHAR`, чтобы запросить LITERAL_PREFIX и LITERAL_SUFFIX символы. При написании кода базы данных, см. в разделе [приложение в: Грамматика SQL](/sql/odbc/reference/appendixes/appendix-c-sql-grammar) в [Справочник по программированию ODBC](/sql/odbc/reference/odbc-programmer-s-reference) подробные сведения о синтаксисе.

Объект набора записей создает инструкцию SQL, которая используется для выбора записей в том случае, если не передать пользовательские инструкции SQL. Как это можно сделать главным образом зависит от значения, передаваемого в *lpszSQL* параметр `Open` функция-член.

Общий вид SQL **ВЫБЕРИТЕ** инструкция является:

```
SELECT [ALL | DISTINCT] column-list FROM table-list
    [WHERE search-condition][ORDER BY column-list [ASC | DESC]]
```

Можно добавить **DISTINCT** ключевое слово для инструкции SQL набора записей является внедрение ключевого слова в первый вызов функции RFX в `DoFieldExchange`. Пример:

```
...
    RFX_Text(pFX, "DISTINCT CourseID", m_strCourseID);
...
```

> [!NOTE]
>  Этот метод можно используйте только с набором записей, открыт только для чтения.

## <a name="overriding-the-sql-statement"></a>Переопределение инструкции SQL

В следующей таблице показаны возможности *lpszSQL* параметр `Open`. В таблице случаи описаны в следующей таблице.

**LpszSQL параметр и результирующая строка SQL**

|Case|Передайте lpszSQL|Результирующая инструкция SELECT|
|----------|------------------------------|------------------------------------|
|1|NULL|**ВЫБЕРИТЕ** *rfx список полей* **FROM** *имя таблицы*<br /><br /> `CRecordset::Open` вызовы `GetDefaultSQL` для получения имени таблицы. Результирующая строка является одним из случаев 2 – 5, в зависимости от того, что `GetDefaultSQL` возвращает.|
|2|Имя таблицы|**ВЫБЕРИТЕ** *rfx список полей* **FROM** *имя таблицы*<br /><br /> Список полей берется из инструкций RFX в `DoFieldExchange`. Если `m_strFilter` и `m_strSort` не пусты, добавляет **ГДЕ** и/или **ORDER BY** предложения.|
|3 \*|Полный **ВЫБЕРИТЕ** инструкции но без **ГДЕ** или **ORDER BY** предложение|Как пройденный. Если `m_strFilter` и `m_strSort` не пусты, добавляет **ГДЕ** и/или **ORDER BY** предложения.|
|4 \*|Полный **ВЫБЕРИТЕ** инструкции с **ГДЕ** и/или **ORDER BY** предложение|Как пройденный. `m_strFilter` и/или `m_strSort` должен оставаться пустым или два фильтра или сортировки инструкций.|
|5 \*|Вызов хранимой процедуры|Как пройденный.|

\* `m_nFields` должно быть меньше или равно количеству столбцов, указанных в **ВЫБЕРИТЕ** инструкции. Тип данных каждого столбца, указанного в **ВЫБЕРИТЕ** инструкция должна быть совпадал с типом данных соответствующего выходного столбца RFX.

### <a name="case-1---lpszsql--null"></a>Case 1 lpszSQL = NULL

Выбор набора записей зависит от что `GetDefaultSQL` возвращает, если `CRecordset::Open` вызывает ее. Случаев 2 – 5 описываются возможные строки.

### <a name="case-2---lpszsql--a-table-name"></a>Вариант 2 lpszSQL = имя таблицы

Набор записей использует обмен полями записей (RFX) для создания списка имен столбцов, предоставляемых в RFX вызовы функции в класс записей переопределение `DoFieldExchange`. Если мастер используется для объявления класса набора записей, в этом случае будет тот же результат, в случае 1 (при условии, что можно передать то же имя таблицы, которые вы указали в мастере). Если вы не используете мастер для создания класса, вариант 2 — это самый простой способ создания инструкции SQL.

Следующий пример создает инструкцию SQL, для отбора записей из базы данных приложения MFC. Когда платформа вызывает `GetDefaultSQL` функция-член, функция возвращает имя таблицы, `SECTION`.

```cpp
CString CEnrollSet::GetDefaultSQL()
{
    return "SECTION";
}
```

Для получения имен столбцов для SQL **ВЫБЕРИТЕ** инструкции, платформа вызывает `DoFieldExchange` функция-член.

```cpp
void CEnrollSet::DoFieldExchange(CFieldExchange* pFX)
{
    pFX->SetFieldType(CFieldExchange::outputColumn);
    RFX_Text(pFX, "CourseID", m_strCourseID);
    RFX_Text(pFX, "InstructorID", m_strInstructorID);
    RFX_Text(pFX, "RoomNo", m_strRoomNo);
    RFX_Text(pFX, "Schedule", m_strSchedule);
    RFX_Text(pFX, "SectionNo", m_strSectionNo);
}
```

По завершении инструкции SQL выглядит следующим образом:

```sql
SELECT CourseID, InstructorID, RoomNo, Schedule, SectionNo
    FROM SECTION
```

### <a name="case-3---lpszsql--a-selectfrom-statement"></a>Вариант 3 lpszSQL = SELECT / FROM инструкция

Укажите список столбцов вручную вместо того чтобы полагаться на RFX автоматического создания. Вы можете это сделать, если:

- Вы хотите указать **DISTINCT** ключевое слово после **ВЫБЕРИТЕ**.

   Список столбцов должны соответствовать имена столбцов и типы в том же порядке, как они указаны в `DoFieldExchange`.

- У вас есть необходимо вручную извлечь значения столбцов с помощью функции ODBC `::SQLGetData` вместо того чтобы полагаться на RFX для привязки и извлечения столбцов.

   Например, можно разместить новые столбцы, которые пользователь приложения добавлены в таблицы базы данных после распространения приложения. Необходимо добавить эти дополнительные поля элементов данных, которые не были известны во время объявления класса с помощью мастера.

   Список столбцов должны соответствовать имена столбцов и типы в том же порядке, как они указаны в `DoFieldExchange`, а затем по названиям вручную привязанные столбцы. Дополнительные сведения см. в разделе [набор записей: Динамическая привязка столбцов данных (ODBC)](../../data/odbc/recordset-dynamically-binding-data-columns-odbc.md).

- Вы хотите присоединиться к таблицам, указав несколько таблиц в **FROM** предложение.

   Сведения и пример см. в разделе [набор записей: Объединение (ODBC)](../../data/odbc/recordset-performing-a-join-odbc.md).

### <a name="case-4---lpszsql--selectfrom-plus-where-andor-order-by"></a>Вариант 4 lpszSQL = SELECT / с, а также ГДЕ и/или ORDER BY

Указывается все: список столбцов (на основе вызовов RFX в `DoFieldExchange`), список таблиц и содержимое **ГДЕ** и/или **ORDER BY** предложение. Если указать ваш **ГДЕ** и/или **ORDER BY** предложений таким образом, не используйте `m_strFilter` и/или `m_strSort`.

### <a name="case-5---lpszsql--a-stored-procedure-call"></a>Вариант 5 lpszSQL = вызов хранимой процедуры

Если необходимо вызвать предопределенного запроса (например, хранимая процедура в базе данных Microsoft SQL Server), необходимо написать **вызвать** инструкцией в строке, передаваемой в *lpszSQL*. Мастера не поддерживают объявление класса набора записей для вызова предопределенного запроса. Не все предопределенные запросы возвращают записи.

Если предопределенного запроса не возвращает записей, вы можете использовать `CDatabase` функция-член `ExecuteSQL` напрямую. Для предопределенных запросов, возвращающих записи, необходимо вручную записать вызовы RFX в `DoFieldExchange` для всех столбцов, процедура возвращает результат. Вызовы функций RFX должна находиться в том же порядке и возвращать те же типы, что предопределенного запроса. Дополнительные сведения см. в разделе [набор записей: Объявление класса для предопределенного запроса (ODBC)](../../data/odbc/recordset-declaring-a-class-for-a-predefined-query-odbc.md).

## <a name="see-also"></a>См. также

[SQL. Типы данных SQL и C++ (ODBC)](../../data/odbc/sql-sql-and-cpp-data-types-odbc.md)<br/>
[SQL. Выполнение прямых вызовов SQL (ODBC)](../../data/odbc/sql-making-direct-sql-calls-odbc.md)
