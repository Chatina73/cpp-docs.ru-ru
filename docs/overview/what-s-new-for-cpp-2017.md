---
title: Новые возможности C++ в Visual Studio 2017
description: Новые возможности и исправления для компилятора и средства C/C++ в Visual Studio 2017.
ms.date: 03/08/2021
ms.technology: cpp-ide
ms.openlocfilehash: bb99f98482484f46824d16f4e202989b0ec6b8ca
ms.sourcegitcommit: f8ba5db09d05683b24c58505f0e57c21f85545dc
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103147281"
---
# <a name="whats-new-for-c-in-visual-studio-2017"></a>Новые возможности C++ в Visual Studio 2017

В Visual Studio 2017 реализовано множество изменений и исправлений для среды C++. Мы устранили более 250 ошибок и обнаруженных проблем в компиляторе и инструментах. О многих из них нам сообщили клиенты с помощью инструментов для [отправки сообщения о проблеме и отправки предложения](/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2017&preserve-view=true) в разделе **Отправить отзыв**. Спасибо, что сообщаете нам об ошибках!

Дополнительные сведения о новых возможностях всех компонентов Visual Studio см. на странице [Новые возможности Visual Studio 2017](/visualstudio/ide/whats-new-visual-studio-2017?view=vs-2017&preserve-view=true). Сведения о новых возможностях для C++ в Visual Studio 2019 см. в статье [What's New for C++ in Visual Studio](what-s-new-for-visual-cpp-in-visual-studio.md?preserve-view=true&view=msvc-160) (Новые возможности для C++ в Visual Studio). Сведения о новых возможностях для C++ в Visual Studio 2015 и более ранних версиях см. в статье [Visual C++ What's New 2003 through 2015](../porting/visual-cpp-what-s-new-2003-through-2015.md) (Новые возможности Visual C++ в версиях с 2003 по 2015). Сведения об изменениях в документации по C++ см. в разделе [Документация по C++: новое](whats-new-cpp-docs.md).

## <a name="visual-studio-2017-c-compiler"></a>Компилятор C++ в Visual Studio 2017

### <a name="c-conformance-improvements"></a>Улучшение соответствия C++

Мы обновили компилятор C++ и стандартную библиотеку в этом выпуске с улучшенной поддержкой возможностей C++11 и C++14. Кроме того, в предварительном виде реализована поддержка определенных возможностей, которые, как предполагается, войдут в стандарт C++17. Подробные сведения см. в статье [C++ conformance improvements in Visual Studio 2017](cpp-conformance-improvements.md) (Улучшения соответствия C++ в Visual Studio 2017).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Компилятор поддерживает около 75 % новых возможностей C++17, включая структурированные привязки, лямбда-выражения **`constexpr`** , `if constexpr`, встроенные переменные, выражения свертывания и добавление **`noexcept`** в систему типов. Эти возможности доступны с использованием параметра **`/std:c++17`** . Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2017](cpp-conformance-improvements.md).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

Набор инструментов компилятора MSVC в Visual Studio версии 15.7 теперь соответствует стандарту C++. Дополнительные сведения см. в статьях [Announcing: MSVC Conforms to the C++ Standard](https://devblogs.microsoft.com/cppblog/announcing-msvc-conforms-to-the-c-standard/) (Объявление: MSVC соответствует стандарту C++) и [Соответствие стандартам языка Visual C++](./visual-cpp-language-conformance.md).

##### <a name="visual-studio-2017-version-158"></a>Visual Studio 2017 версии 15.8

Параметр компилятора [`/experimental:preprocessor`](../build/reference/experimental-preprocessor.md) позволяет включить новый экспериментальный препроцессор MSVC, который в будущем будет соответствовать всем применимым стандартам C и C++. Дополнительные сведения см. в статье [Обзор нового препроцессора MSVC](../preprocessor/preprocessor-experimental-overview.md).

### <a name="new-compiler-options"></a>Новые параметры компилятора

- [`/permissive-`](../build/reference/permissive-standards-conformance.md): включение всех параметров компилятора, обеспечивающих строгое соответствие стандартам, и отключение большей части расширений от Майкрософт (но не `__declspec(dllimport)`, например). В Visual Studio 2017 версии 15.5 этот параметр включен по умолчанию.  Режим соответствия **`/permissive-`** включает поддержку двухэтапного поиска имени. Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio](cpp-conformance-improvements.md).

- [`/diagnostics`](../build/reference/diagnostics-compiler-diagnostic-options.md): отображение расположения ошибки или предупреждения диагностики одним из трех способов: только номер строки, номер строки и столбец, номер строки и столбец с курсором в строке кода, вызвавшей ошибку.

- [`/debug:fastlink`](../build/reference/debug-generate-debug-info.md): ускорение компоновки на 30 % (по сравнению с Visual Studio 2015) без копирования всех сведений об отладке в PDB-файл. PDB-файл указывает на отладочную информацию для файлов объекта и библиотеки, используемых для создания исполняемого файла. См. статьи [Ускорение цикла сборки C++ в VS "15"с помощью `/Debug:fastlink`](https://devblogs.microsoft.com/cppblog/faster-c-build-cycle-in-vs-15-with-debugfastlink/) и [Рекомендации ускорению операций сборки C++ в Visual Studio](https://devblogs.microsoft.com/cppblog/recommendations-to-speed-c-builds-in-visual-studio/).

- В Visual Studio 2017 можно использовать [`/sdl`](../build/reference/sdl-enable-additional-security-checks.md) с [`/await`](../build/reference/await-enable-coroutine-support.md). Мы удалили ограничение [`/RTC`](../build/reference/rtc-run-time-error-checks.md) для сопрограмм.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- [`/std:c++14` и `/std:c++latest`](../build/reference/std-specify-language-standard-version.md): Эти параметры компилятора позволяют выбирать в проекте конкретные версии языка программирования C++, соответствующие стандарту ISO. Большинство новых стандартных функций защищены с помощью параметра **`/std:c++latest`** .

- [`/std:c++17`](../build/reference/std-specify-language-standard-version.md) включает набор функций C++17, который реализован с помощью компилятора. Этот параметр отключает компилятор и поддержку стандартной библиотеки для функций после выхода C++17 — тех функций, что были изменены и добавлены в более поздних версиях рабочего проекта — и исключает обновления стандарта C++. Чтобы включить эти функции, используйте **`/std:c++latest`** .

### <a name="codegen-security-diagnostics-and-versioning"></a>Создание кода, безопасность, диагностика и управления версиями

В этом выпуске представлено несколько улучшений в области оптимизации и создания кода, управления версиями набора инструментов и диагностики. К важным улучшениям можно отнести следующие:

- Улучшенное создание кода циклов. Поддержка автоматической векторизации деления целочисленных констант и улучшенное распознавание шаблонов memset.
- Повышенная защищенность кода. Более полная диагностика компилятора при переполнении буфера. Параметр [`/guard:cf`](../build/reference/guard-enable-control-flow-guard.md) теперь обеспечивает защиту операторов switch, которые создают таблицы переходов.
- Управление версиями. Значение встроенного препроцессорного макроса **\_MSC\_VER** теперь монотонно обновляется при каждом обновлении набора инструментов Visual C++. Дополнительные сведения см. в статье [Visual C++ Compiler Version](https://devblogs.microsoft.com/cppblog/visual-c-compiler-version/) (Версия компилятора Visual C++).
- Новое расположение набора инструментов. Компилятор и связанные средства сборки имеют новое расположение и структуру каталогов на компьютере разработки. Новый макет позволяет параллельно устанавливать несколько версий компилятора. Дополнительные сведения см. в статье [Compiler Tools Layout in Visual Studio 2017](https://devblogs.microsoft.com/cppblog/compiler-tools-layout-in-visual-studio-15/) (Макет инструментов компилятора в Visual Studio 2017).
- Улучшенная диагностика. В окне вывода теперь отображается столбец, в котором произошла ошибка. Дополнительные сведения см. в статье [Усовершенствования функций диагностики компилятора C++ в VS "15" Preview 5](https://devblogs.microsoft.com/cppblog/c-compiler-diagnostics-improvements-in-vs-15-rc/).
- При использовании сопрограмм экспериментальное ключевое слово **yield** (в параметре **`/await`** ) удалено. Нужно обновить код для использования `co_yield` вместо него. Дополнительные сведения см. в статье [о преобразовании ключевого слова `yield` в `co_yield` в Visual Studio 2017](https://devblogs.microsoft.com/cppblog/yield-keyword-to-become-co_yield-in-vs-2017/).

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

дополнительные улучшения диагностики в компиляторе. Дополнительные сведения см. в статье [Diagnostic Improvements in Visual Studio 2017 15.3.0](https://devblogs.microsoft.com/cppblog/diagnostic-improvements-in-vs2017-15-3-0/) (Улучшения диагностики в Visual Studio 2017 версии 15.3.0).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Улучшение производительности среды выполнения Visual C++ все так же реализуется за счет повышения качества генерируемого кода. Это означает, что можно просто перекомпилировать код, и приложение будет работать быстрее. Представлен ряд совершенно новых оптимизаций компилятора, например векторизация условных скалярных хранилищ, объединение вызовов функций `sin(x)` и `cos(x)` в новую функцию `sincos(x)`,а также устранение избыточных инструкций из оптимизатора SSA. Другие виды оптимизации компилятора являются улучшениями существующих функций, например эвристика векторизатора для условных выражений, улучшенные оптимизации цикла и значения типа float для функций min и max генератора кода. Компоновщик имеет новую и более быструю реализацию **`/OPT:ICF`** , что может привести к ускорению компоновки на 9 %. Также доступны другие улучшения производительности инкрементной компоновки. Дополнительные сведения см. в разделах [Параметр /OPT (оптимизации)](../build/reference/opt-optimizations.md) и [Параметр /INCREMENTAL (инкрементная компоновка)](../build/reference/incremental-link-incrementally.md).

Компилятор Microsoft C++ поддерживает Intel AVX-512. Он содержит инструкции, касающиеся длины вектора, которые применяют новые функции AVX-512 к 128-разрядным и 256-разрядным регистрам.

Параметр [`/Zc:noexceptTypes-`](../build/reference/zc-noexcepttypes.md) можно использовать для возврата к **`noexcept`** версии C++14 при использовании режима C++17 в целом. Этот параметр позволяет обновить исходный код для соответствия C++17, без необходимости переписывать весь код `throw()`. Дополнительные сведения см. в разделе [Удаление спецификации динамических исключений и noexcept](cpp-conformance-improvements-2017.md#noexcept_removal).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Новый переключатель компилятора [/Qspectre](../build/reference/qspectre.md) предназначен для противодействия спекулятивному выполнению атак по сторонним каналам. Дополнительные сведения см. в записи блога [Spectre mitigations in MSVC](https://devblogs.microsoft.com/cppblog/spectre-mitigations-in-msvc/) (Устранение рисков с использованием Spectre в MSVC).
- Новое диагностическое предупреждение для устранения рисков Spectre. Подробнее см. в записи блога [Spectre diagnostic in Visual Studio 2017 Version 15.7 Preview 4](https://devblogs.microsoft.com/cppblog/spectre-diagnostic-in-visual-studio-2017-version-15-7-preview-4/) (Диагностика с использованием Spectre в Visual Studio 2017 версии 15.4, предварительная версия 4).
- Новое значение для параметра /Zc **`/Zc:__cplusplus`** обеспечивает корректное информирование о поддержке стандарта C++. Например, если этот параметр установлен и компилятор находится в режиме **`/std:c++17`** , значение будет расширено до **`201703L`** . Дополнительные сведения см. в записи блога [MSVC now correctly reports __cplusplus](https://devblogs.microsoft.com/cppblog/msvc-now-correctly-reports-__cplusplus/) (MSVC теперь корректно сообщает значение __cplusplus).

## <a name="c-standard-library"></a>Стандартная библиотека C++

### <a name="correctness-improvements"></a>Усовершенствования правильности

##### <a name="visual-studio-2017-rtm-version-150"></a>Visual Studio 2017 RTM (версия 15.0)

- Незначительные усовершенствования диагностики `basic_string``_ITERATOR_DEBUG_LEVEL != 0`. При активации проверки IDL в механизме обработки строк теперь указывается конкретное поведение, которое стало причиной активации. Например, вместо "string iterator not dereferencable" (итератор строки не является разыменуемым) вы получите сообщение "cannot dereference string iterator because it is out of range (e.g. an end iterator)" (не удается разыменовать итератор строки, так как он выходит за пределы диапазона, например конечный итератор).
- Исправлен оператор присваивания перемещением `std::promise`, из-за которого раньше в коде могла возникнуть вечная блокировка.
- Устранены ошибки в компиляторе, связанные с неявным преобразованием `atomic<T*>` в `T*`.
- `pointer_traits<Ptr>` теперь корректно обнаруживает `Ptr::rebind<U>`.
- Исправлен отсутствующий квалификатор **`const`** в операторе вычитания `move_iterator`.
- Исправлено автоматическое неправильное создание кода для определяемых пользователем распределителей с отслеживанием состояния, запрашивающих `propagate_on_container_copy_assignment` и `propagate_on_container_move_assignment`.
- `atomic<T>` теперь допускает перегруженные `operator&()`.
- Немного улучшилась диагностика компилятора для неверных вызовов `bind()`.

В Visual Studio 2017 RTM представлены и другие улучшения стандартной библиотеки. Полный список см. в записи блога команды разработчиков C++ [об исправлениях стандартной библиотеки в Visual Studio 2017 RTM](https://devblogs.microsoft.com/cppblog/stl-fixes-in-vs-2017-rtm/).

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Теперь контейнеры стандартной библиотеки выполняют приведение `max_size()` в `numeric_limits<difference_type>::max()`, а не `max()` в `size_type`. Это гарантирует, что результат `distance()` с итераторами из этого контейнера можно представить в возвращаемом типе `distance()`.
- Исправлена отсутствующая специализация `auto_ptr<void>`.
- Алгоритмы `for_each_n()`, `generate_n()` и `search_n()` ранее не компилировались, если аргумент длины не был целочисленного типа. Теперь они пытаются преобразовать значения длины нецелочисленного типа в тип `difference_type` итераторов.
- `normal_distribution<float>` больше не выдает предупреждения в стандартной библиотеке о сужающем преобразовании из типа double во float.
- Исправлены некоторые операции `basic_string`, которые использовали `npos` вместо `max_size()` при проверке переполнения максимального размера.
- `condition_variable::wait_for(lock, relative_time, predicate)` приходилось ожидать в течение всего относительного времени в случае ложного пробуждения. Теперь этот метод ожидает только в течение одного интервала относительного времени.
- `future::get()` теперь не допускает `future`, как того требует стандарт.
- `iterator_traits<void *>` являлся критической ошибкой, так как он пытался сформировать `void&`. Теперь он становится пустой структурой, позволяющей использовать `iterator_traits` в условиях SFINAE is iterator.
- Некоторые предупреждения, выдававшиеся в **-Wsystem-headers** Clang, были исправлены.
- Кроме того, исправлена ошибка "Спецификация исключений в объявлении не соответствует предыдущему объявлению", о которой сообщал Clang **-Wmicrosoft-exception-spec**.
- Кроме того, исправлены предупреждения упорядочивания mem-initializer-list, о которых сообщают Clang и C1XX.
- Неупорядоченные контейнеры не переключали хэширование и предикаты при переключении. Теперь они это делают.
- Многие операции переключения контейнеров теперь помечены как **`noexcept`** (так как наша стандартная библиотека никогда не будет выдавать исключение при обнаружении неопределенного условия поведения non-`propagate_on_container_swap` non-equal-allocator).
- Многие операции `vector<bool>` теперь помечены как **`noexcept`** .
- Стандартная библиотека теперь будет требовать сопоставление распределителя `value_type` (в режиме C++17) с резервной возможностью отказа.
- Исправлены некоторые условия, при которых self-range-insert в `basic_string` будет шифровать содержимое строки. (Обратите внимание, что использование self-range-insert в векторах все еще запрещено стандартной библиотекой.)
- `basic_string::shrink_to_fit()` больше не затрагивается `propagate_on_container_swap`распределителя.
- `std::decay` теперь обрабатывает недопустимые типы функций (например, типы функций с квалификацией типа cv, ref или обоих типов одновременно).
- Изменены директивы включения для использования правильного учета регистра и косых черт, улучшая мобильность.
- Исправлено предупреждение C4061 "перечислитель *перечислитель* в параметре перечисления *перечисление* неявно обработан меткой регистра". Это предупреждение отключено по умолчанию и исправлено в качестве исключения в общей политике предупреждений в стандартной библиотеке. (В стандартной библиотеке обеспечивается чистота **`/W4`** , но не **`/Wall`** . Множество отключенных по умолчанию предупреждений срабатывают слишком часто и не предназначены для постоянного использования.)
- Улучшены проверки отладки `std::list`. Итераторы списка теперь проверяют `operator->()`, а `list::unique()` помечает итераторы как недействительные.
- Исправлено метапрограммирование uses-allocator в `tuple`.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- `std::partition` теперь вызывает предикат `N` раз вместо `N + 1` раз, в соответствии с требованиями стандарта.
- Попытки избежать магической статики в версии 15.3 исправлены в версии 15.5.
- `std::atomic<T>` больше не требуется `T`, чтобы быть конструируемым по умолчанию.
- Алгоритмы кучи, которые принимают логарифмическое время, теперь работают иначе, если включена отладка итератора. Они больше не реализуют утверждение линейного времени о том, что входные данные на самом деле представляют собой кучу.
- `__declspec(allocator)` теперь защищается только для C1XX, чтобы предотвращать вывод предупреждений из Clang, который не понимает declspec.
- `basic_string::npos` теперь доступен в качестве константы времени компиляции.
- `std::allocator` теперь правильно обрабатывает выделение чрезмерно выровненных типов (типов, выравнивание которых больше `max_align_t`) в режиме C++17 (если не отключено с помощью **`/Zc:alignedNew-`** ).  Например, векторы объектов с 16- или 32-байтовым выравниванием теперь правильно выравниваются для инструкций SSE и AVX.

### <a name="conformance-improvements"></a>Улучшение соответствия

- Были добавлены \<any\>, \<string_view\>, `apply()`, `make_from_tuple()`.
- Добавлены \<optional\>, \<variant\>, `shared_ptr::weak_type` и \<cstdalign\>.
- Включено C++14 **`constexpr`** в `min(initializer_list)`, `max(initializer_list)`, `minmax(initializer_list)`, `min_element()`, `max_element()` и `minmax_element()`.

Дополнительные сведения см. в статье [Таблица соответствия Microsoft Visual C++ стандартам языка](./visual-cpp-language-conformance.md).

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Реализовано несколько дополнительных функций C++17. Дополнительные сведения см. в статье [Таблица соответствия Microsoft Visual C++ стандартам языка](cpp-conformance-improvements-2017.md#improvements_153).
- Реализовано исправление P0602R0: variant и optional должны распространять тривиальность копирования и перемещения.
- Стандартная библиотека теперь официально допускает отключение динамической RTTI с помощью параметра [/GR-](../build/reference/gr-enable-run-time-type-information.md). Для `dynamic_pointer_cast()` и `rethrow_if_nested()` изначально требуется **`dynamic_cast`** , поэтому стандартная библиотека теперь помечает их как `=delete` в параметре **`/GR-`** .
- Даже если динамическая идентификация типа (RTTI) отключена через **`/GR-`** , статистическая RTTI (в виде `typeid(SomeType)`) все еще доступна и позволяет применять несколько компонентов стандартной библиотеки. Стандартная библиотека теперь также поддерживает отключение этой возможности с использованием **`/D_HAS_STATIC_RTTI=0`** . Этот флаг отключает также функции-члены `std::any`, `target()` и `target_type()` для `std::function` и дружественную функцию-член `get_deleter()` для `std::shared_ptr` и `std::weak_ptr`.
- Стандартная библиотека теперь использует C++14 **`constexpr`** без дополнительный условий вместо макросов, определяемых условиями.
- Стандартная библиотека теперь использует шаблоны псевдонимов внутренним образом.
- Стандартная библиотека теперь внутренне использует **`nullptr`** вместо `nullptr_t{}`. (NULL больше не используется внутренне. Внутреннее использование 0 в качестве null постепенно отменяется.)
- Стандартная библиотека теперь внутренне использует `std::move()` вместо стилистически неправильного использования `std::forward()`.
- Изменено с `static_assert(false, "message")` на `#error message`. Это изменение улучшает диагностику компилятора, так как `#error` немедленно прекращает компиляцию.
- Стандартная библиотека больше не помечает функции как `__declspec(dllimport)`. Для современных компоновщиков это больше не требуется.
- Извлечены SFINAE для аргументов шаблона по умолчанию, что сокращает беспорядок по сравнению с типами возвращаемых данных и типами аргумента функции.
- При проверке отладки в режиме \<random\> теперь используются обычные механизмы стандартной библиотеки вместо внутренней функции `_Rng_abort()`, которая вызывала `fputs()` в **stderr**. Реализация этой функции оставлена для совместимости на уровне двоичного кода. Мы удалим ее в следующей версии стандартной библиотеки, несовместимой с двоичным кодом.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- В соответствии со стандартом C++17 были добавлены, признаны нерекомендуемыми и удалены несколько функций стандартной библиотеки. Дополнительные сведения см. в статье [Улучшения соответствия C++ в Visual Studio](cpp-conformance-improvements-2017.md#improvements_155).
- Экспериментальная поддержка следующих параллельных алгоритмов:
  - `all_of`
  - `any_of`
  - `for_each`
  - `for_each_n`
  - `none_of`
  - `reduce`
  - `replace`
  - `replace_if`
  - `sort`
- В настоящее время подписи для следующих параллельных алгоритмов добавлены, но не параллелизированы. Согласно результатам профилирования, нет смысла использовать алгоритмы параллелизации, которые только перемещают или переставляют элементы:
  - `copy`
  - `copy_n`
  - `fill`
  - `fill_n`
  - `move`
  - `reverse`
  - `reverse_copy`
  - `rotate`
  - `rotate_copy`
  - `swap_ranges`

##### <a name="visual-studio-2017-version-156"></a>Visual Studio 2017 версии 15.6

- \<memory_resource>
- Основы работы с библиотеками V1
- Удаление присваивания `polymorphic_allocator`
- Улучшение выведения аргументов шаблонов класса

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Поддержка параллельных алгоритмов теперь не является экспериментальной
- Новая реализация \<filesystem>
- Простые преобразования строк (частично)
- `std::launder()`
- `std::byte`
- `hypot(x,y,z)`
- Отказ от лишнего вырождения
- Специальные математические функции
- `constexpr char_traits`
- Рекомендации по удержанию для стандартной библиотеки

Дополнительные сведения см. в статье [Таблица соответствия Microsoft Visual C++ стандартам языка](./visual-cpp-language-conformance.md).

### <a name="performance-and-throughput-fixes"></a>Повышение производительности и пропускной способности

- Теперь перегрузки `basic_string::find(char)` вызывают `traits::find` только один раз. Ранее это было реализовано в качестве общего механизма поиска строки для строки длиной 1.
- Теперь `basic_string::operator==` проверяет размер строки перед сравнением содержимого строк.
- Удалена взаимозависимость элементов управления в `basic_string`, которая вызывала трудности при анализе оптимизатором компилятора. Для всех коротких строк вызов `reserve` по-прежнему имеет ненулевое значение затрат при отсутствии выполняемых операций.
- Мы значительно изменили `std::vector` для обеспечения правильной работы и производительности. Теперь присвоение псевдонима во время вставки и назначения места обрабатывается правильно и в соответствии с требованиями стандарта. При использовании `move_if_noexcept()` и другой логики гарантируется возникновение исключений в тех случаях, когда того требует стандарт, а при вставке или назначении места выполняется меньше операций с элементами.
- Стандартная библиотека C++ теперь избегает разыменования пустых (NULL) указателей.
- Улучшена производительность `weak_ptr::lock()`.
- Для повышения скорости работы компилятора заголовки стандартной библиотеки C++ теперь не включают объявления для ненужных встроенных функций компилятора.
- Производительность конструкторов перемещения `std::string`и `std::wstring` повышена более чем в 3 раза.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Устранена проблема взаимодействия с **`noexcept`** , которая не позволяла встраивать реализацию `std::atomic` в функции, которые используют структурированную обработку исключений (SEH).
- Изменена внутренняя функция стандартной библиотеки `_Deallocate()`, чтобы оптимизировать ее в код меньшего размера, что позволяет встроить ее в большее количество мест.
- Изменен `std::try_lock()` для использования расширения пакета вместо рекурсии.
- Улучшен алгоритм предотвращения взаимоблокировки `std::lock()` при использовании операций `lock()` вместо обращения ко всем методам `try_lock()` блокировки.
- Включена оптимизация именованных возвращаемых значений в `system_category::message()`.
- `conjunction` и `disjunction` теперь создают экземпляры типов `N + 1`, а не типов `2N + 2`.
- `std::function` больше не создает экземпляры механизмов поддержки распределителя для каждого вызываемого элемента с удалением типа, улучшая пропускную способность и уменьшая размер .obj в программах, которые передают много различных лямбда-выражений в `std::function`.
- `allocator_traits<std::allocator>` содержит вручную встроенные операции `std::allocator`, уменьшая объем кода в коде, который взаимодействует с `std::allocator` только через `allocator_traits` (то есть, в большей части кода).
- Интерфейс минимального распределителя C++11 теперь обрабатывается таким образом: стандартная библиотека напрямую вызывает `allocator_traits`, а не помещает распределитель во внутренний класс `_Wrap_alloc`. Это изменение уменьшает размер кода, создаваемого для поддержки распределителя, в некоторых случаях улучшается способность оптимизатора делать выводы о контейнерах стандартной библиотеки и оптимизируется отладка (так как теперь в отладчике отображается тип распределителя, а не `_Wrap_alloc<your_allocator_type>`).
- Удалено метапрограммирование для настроенного метода `allocator::reference`, распределители которого запрещено настраивать. (Распределители могут настроить в контейнерах использование специальных указателей, но не специальных ссылок.)
- Интерфейс компилятора переделан для распаковывания итераторов отладки в цикле for на основе диапазона, улучшая производительность отладочных сборок.
- Путь внутреннего сжатия `basic_string` для `shrink_to_fit()` и `reserve()` больше не перераспределяет операции, уменьшая объем кода для всех участников изменения.
- Внутренний путь создания `basic_string` больше не находится в пути `shrink_to_fit()`.
- Операции изменения `basic_string` теперь факторизованы в быстром пути без распределения и в функциях медленного пути с распределением, повышая вероятность встраивания стандартного сценария без распределения в вызывающие объекты.
- Операции изменения `basic_string` теперь создают перераспределенные буферы в предпочтительном состоянии, а не изменяют их размер на месте. Например, вставка в начале строки теперь перемещает содержимое после вставки только один раз. Оно перемещается либо вниз, либо в новый выделенный буфер. Оно больше не перемещается дважды в регистре перераспределения — сначала в новый выделенный буфер, а затем вниз.
- Операции, вызывающие стандартную библиотеку C в \<string\>, теперь кэшируют адрес `errno` для удаления повторяющегося взаимодействия с протоколом TLS.
- Упрощена реализация `is_pointer`.
- Завершено изменение основанного на функции выражения SFINAE на **`struct`** или `void_t`.
- Алгоритмы стандартной библиотеки теперь не используют итераторы последующего увеличения.
- Устранены предупреждения об усечении при использовании 32-разрядных распределителей в 64-разрядных системах.
- `std::vector` перемещает назначение эффективнее в случае использования неравного распределителя без применения non-POCMA, повторно используя буфер по необходимости.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- `basic_string<char16_t>` теперь использует те же `memcmp`, `memcpy`, а также аналогичные оптимизации, применяемые `basic_string<wchar_t>`.
- Ограничение оптимизатора, которое не позволяло указателям на функции быть представленными как встроенные в Visual Studio 2015 с обновлением 3, устранено, что способствует восстановлению производительности `lower_bound(iter, iter, function pointer)`.
- Затраты на проверку порядка входных данных для включаемых файлов, `includes`, `set_difference`, `set_symmetric_difference` и `set_union`, выполняемую при отладке итератора, были сокращены за счет распаковки итераторов перед проверкой.
- `std::inplace_merge` теперь пропускает элементы, которые уже находятся в нужной позиции.
- При создании `std::random_device` больше не создается и затем удаляется `std::string`.
- `std::equal` и `std::partition` использовали проход оптимизации потоков перехода, который избавлял от сравнения итераторов.
- Когда `std::reverse` передает указатели на традиционно копируемый `T`, передача будет выполняться в рукописную векторизированную реализацию.
- `std::fill`, `std::equal` и `std::lexicographical_compare` могут выполнять передачу в `memset` и `memcmp` для `std::byte` и `gsl::byte` (и другие аналогичные символьным перечисления и классы перечислений). `std::copy` выполняет диспетчеризацию с помощью `is_trivially_copyable`, поэтому вносить изменения не требуется.
- Стандартная библиотека больше не содержит деструкторы с пустыми скобками, единственное действие которых заключалось в том, чтобы сделать типы нетривиально уничтожаемыми.

## <a name="other-libraries"></a>Прочие библиотеки

### <a name="open-source-library-support"></a>Поддержка библиотеки с открытым исходным кодом

**Vcpkg** является средством командной строки с открытым исходным кодом, которое значительно упрощает процесс получения и создания статических библиотек открытым исходным кодом C++ и библиотек DLL в Visual Studio. Дополнительные сведения см. в разделе [vcpkg: диспетчер пакетов для C++](../build/vcpkg.md).

### <a name="cpprest-sdk-290"></a>Пакет SDK для CPPRest 2.9.0

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

CPPRestSDK, кроссплатформенный веб-API для C++, был обновлен до версии 2.9.0. Дополнительные сведения см. в статье [Доступность CppRestSDK 2.9.0 в GitHub](https://devblogs.microsoft.com/cppblog/cpprestsdk-2-9-0-is-available-on-github/).

### <a name="atl"></a>ATL

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- Еще один набор исправлений соответствия поиска по имени.
- Имеющиеся конструкторы перемещения и операторы присваивания перемещения теперь правильно помечены как не предусматривающие формирование исключений.
- Отменено отключение допустимого предупреждения C4640 о потокобезопасной инициализации локальных статических элементов в atlstr.h.
- Потокобезопасная инициализация локальных статических элементов автоматически отключалась в наборе инструментов XP при использовании ATL и сборке библиотеки DLL. Теперь этого не происходит. Если вы не хотите использовать потокобезопасную инициализацию, добавьте **`/Zc:threadSafeInit-`** в параметры проекта.

### <a name="visual-c-runtime"></a>Среда выполнения Visual C++

- Новый заголовок "cfguard.h" для символов защиты потока управления.

## <a name="visual-studio-2017-c-ide"></a>Интегрированная среда разработки для языка C++ Visual Studio 2017

- Повышена производительность изменения конфигурации для проектов в машинном коде на C++ и проектов C++/CLI. При первой активации конфигурации решения процесс теперь будет работать быстрее, а все последующие активации будут происходить практически мгновенно.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Некоторые мастера проекта и кода были переписаны в стиле диалоговых окон с подписями.
- При выборе пункта меню **Добавить класс** теперь запускается мастер добавления классов. Все остальные элементы, которые ранее здесь находились, теперь доступны в разделе **Добавить > Новый элемент**.
- Проекты Win32 теперь находятся в каталоге **Классические приложения Windows** в диалоговом окне **Создание проекта**.
- При выборе шаблонов **Консольное приложение Windows** и **Классическое приложение Windows** теперь создаются проекты без вызова мастера. Теперь доступен новый **мастер создания классических приложений Windows**. Он отображается в той же категории, что и прежний мастер **создания консольных приложение Win32**, и с теми же параметрами.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

несколько операций C++, которые используют модуль IntelliSense для навигации по коду и рефакторинга кода, работают гораздо быстрее. Следующие данные основаны на решении Visual Studio Chromium решения с 3500 проектами.

| Функция | Повышение производительности |
|--|--|
| Переименовать | в 5,3 раза |
| Изменение сигнатуры | в 4,5 раза |
| Найти все ссылки | в 4,7 раза |

C++ теперь поддерживает комбинацию клавиши CTRL+щелчок мыши, что упрощает **переход к определениям** с помощью мыши. Визуализатор структуры из пакета инструментов повышения производительности теперь также включен в продукт по умолчанию.

## <a name="intellisense"></a>IntelliSense

- По умолчанию теперь используется новое ядро СУБД на основе SQLite. Новый модуль ускоряет операции базы данных, такие как **переход к определению** и **поиск всех ссылок**. Он значительно сокращает начальное время анализа решения. Параметр перемещен в раздел **Средства > Параметры > Текстовый редактор > C/C++ > Дополнительно**. (Раньше он находился в разделе ...C/ C++ > Экспериментальные.)

- Улучшена производительность IntelliSense в проектах и файлах, где не используются предкомпилированные заголовки. В текущем файле для заголовков будет создан автоматический предкомпилированный заголовок.

- Добавлена фильтрация ошибок и справка по ошибкам IntelliSense для списка ошибок. Теперь выполнить фильтрацию можно, просто щелкнув столбец ошибок. Кроме того, если щелкнуть конкретные ошибки или нажать клавишу F1, запустится поиск сообщения об ошибке в сети.

  ![Список ошибок](media/ErrorList1.png "Список ошибок")

  ![Отфильтрованный список ошибок](media/ErrorList2.png "Отфильтрованный список ошибок")

- Добавлена фильтрация пунктов списка элементов по виду.

  ![Фильтрация списка элементов](media/mlfiltering.png "Фильтрация списка элементов")

- Добавлена новая экспериментальная возможность — прогнозная технология IntelliSense, — которая фильтрует содержимое списка элементов с учетом контекста. Подробнее см. статью [Усовершенствования C++ IntelliSense — прогнозная технология IntelliSense и фильтрация](https://devblogs.microsoft.com/cppblog/c-intellisense-improvements-predictive-intellisense-filtering/).
- Команда **Найти все ссылки** (SHIFT+F12) теперь позволяет легко перемещаться даже по сложным базам кода. Она предоставляет расширенные возможности группирования, фильтрации, сортировки, поиска в найденном и цветового выделения результатов. Это дает вам четкое понимание ссылок. Для C++ предоставлен новый компонент пользовательского интерфейса, который содержит информацию о том, выполняется ли чтение из переменной или запись в переменную.
- Функция замены точки на стрелку IntelliSense была перенесена из экспериментальных в расширенные и теперь включена по умолчанию. Функции **расширения областей** и **приоритета расширения** в редакторе также были перенесены из экспериментальных в расширенные.
- Экспериментальные функции рефакторинга **Изменить сигнатуру** и **Извлечь функцию** теперь доступны по умолчанию.
- Добавлена экспериментальная функция для проектов C++ "Меньшее время загрузки проекта". Когда вы в следующий раз откроете проект C++, он загрузится быстрее, а в следующий раз — *очень* быстро.
- Некоторые из этих функций являются общими для других языков, а некоторые специфичны для C++. Дополнительные сведения об этих новых возможностях см. в [объявлении о выпуске Visual Studio 15, предварительная версия 5](https://devblogs.microsoft.com/visualstudio/announcing-visual-studio-15-preview-5/).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- добавлена поддержка ClangFormat. Дополнительные сведения см. в записи блога [ClangFormat Support in Visual Studio 2017](https://devblogs.microsoft.com/cppblog/clangformat-support-in-visual-studio-2017-15-7-preview-1/) (Поддержка ClangFormat в Visual Studio).

## <a name="non-msbuild-projects-with-open-folder"></a>Поддержка проектов, отличных от MSBuild, с помощью функции "Открыть папку"

В Visual Studio 2017 появилась функция **Открыть папку**. Она позволяет писать код, выполнять сборку и отладку в папке, содержащей исходный код, не создавая каких-либо решений и проектов. Стало намного проще начать работу с Visual Studio, даже если проект не основан на MSBuild. Функция **Открыть папку** предоставляет доступ к мощным средствам для анализа, редактирования, сборки и отладки кода. Это та же функция, которую Visual Studio уже предоставляет для проектов MSBuild. Дополнительные сведения см. в статье [Проекты "Открыть папку" для C++](../build/open-folder-projects-cpp.md).

- Улучшения в процедуре открытия папки. Можно выполнить настройку с помощью следующих файлов JSON.
  - CppProperties.json используется для настройки работы с IntelliSense и браузером.
  - Tasks.json используется для настройки этапов сборки.
  - Launch.json используется для настройки процедуры отладки.

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- Улучшенная поддержка альтернативных компиляторов и сред сборки, таких как MinGW и Cygwin. Дополнительные сведения см. в статье [Using MinGW and Cygwin with Visual C++ and Open Folder](https://devblogs.microsoft.com/cppblog/using-mingw-and-cygwin-with-visual-cpp-and-open-folder/) (Использование MinGW и Cygwin с Visual C++ и функцией "Открыть папку").
- Добавлена поддержка определения глобальных и зависящих от конфигурации переменных среды в файлах CppProperties.json и CMakeSettings.json. Эти переменные среды могут использоваться в конфигурациях отладки, определенных в файле launch.vs.json, и в задачах, определенных в файле tasks.vs.json. Дополнительные сведения см. в статье [Использование MinGW и Cygwin с Visual C++ и функцией "Открыть папку"](https://devblogs.microsoft.com/cppblog/customizing-your-environment-with-visual-c-and-open-folder/).
- Улучшена поддержка генератора CMake Ninja, включая упрощение выбора 64-разрядной платформы в качестве целевой.

## <a name="cmake-support-via-open-folder"></a>Поддержка CMake с помощью функции "Открыть папку"

В Visual Studio 2017 добавлена поддержка использования проектов CMake без преобразования в файлы проекта MSBuild (с расширением VCXPROJ). Дополнительные сведения см. в статье [Проекты CMake в Visual C++](../build/cmake-projects-in-visual-studio.md). При открытии проектов CMake с помощью функции **Открыть папку** автоматически настраивается среда для редактирования, сборки и отладки кода C++.

- Для работы C++ IntelliSense не требуется создавать файл CppProperties.json в корневой папке. Мы также добавили новый раскрывающийся список, который позволяет пользователям легко переключаться между конфигурациями, предоставляемыми файлами CMake и CppProperties.json.

- Дальнейшая настройка поддерживается посредством файла CMakeSettings.json, который находится в одной папке с файлом CMakeLists.txt.

  ![Функция "Открыть папку" в CMake](media/cmake-cpp.png "Функция "Открыть папку" в CMake")

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- добавлена поддержка генератора CMake Ninja.

##### <a name="visual-studio-2017-version-154"></a>Visual Studio 2017 версии 15.4

- добавлена поддержка импорта существующих кэшей CMake.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- добавлена поддержка CMake 3.11, анализ кода в проектах CMake, представление целевых объектов в обозревателе решений, параметры формирования кэша и компиляция на базе одного файла. Дополнительные сведения см. в статьях [CMake support in Visual Studio](https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/) (Поддержка CMake в Visual Studio) [CMake projects in Visual C++](../build/cmake-projects-in-visual-studio.md) (Проекты CMake в Visual C++).

## <a name="windows-desktop-development"></a>Разработка классических приложений для Windows

Теперь предоставляется более точный контроль над процедурой установки исходной рабочей нагрузки C++. Мы добавили возможность выбора компонентов, чтобы вы могли устанавливать только необходимые инструменты. В пользовательском интерфейсе установщика указаны неточные размеры установки для компонентов. Таким образом, общий размер занижен.

Чтобы успешно создавать проекты Win32 в рабочей нагрузке для разработки приложений на C++, необходимо установить набор средств и пакет SDK для Windows. Для гарантии работы следует установить рекомендуемые (выбранные) компоненты **Набор средств VC++ 2017 v141 (x86, x64)** и **Пакет SDK Windows 10 (10.0.nnnnn)** . Если необходимые средства не установлены, создание проектов завершится ошибкой, а мастер перестанет отвечать на запросы.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Visual C++ Build Tools (ранее доступный как отдельный продукт), теперь включен в Visual Studio Installer в качестве рабочей нагрузки. Эта рабочая нагрузка устанавливает только инструменты, необходимые для сборки проектов C++ без установки среды Visual Studio. Включены наборы инструментов v141 и v140. Набор инструментов v141 содержит последние улучшения в Visual Studio 2017 версии 15.5. Дополнительные сведения см. в статье [В состав Visual Studio Build Tools теперь входят наборы инструментов MSVC VS2017 и VS2015](https://devblogs.microsoft.com/cppblog/visual-studio-build-tools-now-include-the-vs2017-and-vs2015-msvc-toolsets/).

## <a name="linux-development-with-c"></a>Разработка приложений для Linux на C++

Популярное расширение, [Visual C++ для разработки приложений Linux](https://marketplace.visualstudio.com/items?itemName=VisualCppDevLabs.VisualCforLinuxDevelopment), теперь стало частью Visual Studio. В этой установке представлено все необходимое для разработки и отладки приложений C++, работающих в среде Linux.

##### <a name="visual-studio-2017-version-152"></a>Visual Studio 2017 версии 15.2

улучшение использования кроссплатформенного кода и типа визуализации. Дополнительные сведения см. в статье [Linux C++ improvements for cross-platform code sharing and type visualization](https://devblogs.microsoft.com/cppblog/linux-cross-platform-and-type-visualization/) (Улучшения Linux C++ при использовании кроссплатформенного кода и визуализации типов).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- Рабочая нагрузка Linux имеет дополнительную поддержку для **rsync** в качестве альтернативы **sftp** для синхронизации файлов на удаленных компьютерах Linux.
- Добавлена поддержка для перекрестной компиляции, предназначенной для микроконтроллеров ARM. Чтобы включить ее в установку, выберите рабочую нагрузку **Разработка приложений Linux на C++** и установите флажок **Разработка для встроенных платформ и Интернета вещей**. В вашу установку будут добавлены инструменты перекрестной компиляции ARM GCC и Make. Дополнительные сведения см. в статье [Перекрестная компиляция ARM GCC в Visual Studio](https://devblogs.microsoft.com/cppblog/arm-gcc-cross-compilation-in-visual-studio/).
- Добавлена поддержка для CMake. Теперь вы можете работать с существующей базой кода, не преобразовывая ее в проект Visual Studio. Дополнительные сведения см. в разделе [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).
- Добавлена поддержка для выполнения удаленных задач. Эта возможность позволяет запускать любую команду в удаленной системе, которая определена в диспетчере подключений Visual Studio. Удаленные задачи также позволяют копировать файлы в удаленную систему.
Дополнительные сведения см. в разделе [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Различные улучшения сценариев рабочих нагрузок в Linux. Дополнительные сведения см. в записи блога [Изменения в рабочих нагрузках C++ в Linux для системы проектов, консольного окна Linux, rsync and команды "Присоединение к процессу"](https://devblogs.microsoft.com/cppblog/linux-c-workload-improvements-to-the-project-system-linux-console-window-rsync-and-attach-to-process/).
- IntelliSense для заголовков удаленных подключений Linux. Дополнительные сведения см. в статьях [IntelliSense for Remote Linux Headers](https://devblogs.microsoft.com/cppblog/intellisense-for-remote-linux-headers/) (IntelliSense для удаленных заголовков Linux) и [Настройка проекта Linux CMake](../linux/cmake-linux-project.md).

## <a name="game-development-with-c"></a>Разработка игр на C++

Доступны все возможности C++ для создания профессиональных игр на базе DirectX или Cocos2d.

## <a name="mobile-development-with-c-for-android-and-ios"></a>Разработка мобильных приложений на C++ для iOS и Android

Теперь в Visual Studio можно создавать мобильные приложения для Android и iOS и отлаживать их.

## <a name="universal-windows-apps"></a>Универсальные приложения Windows

C++ поставляется как дополнительный компонент для рабочей нагрузки универсального приложения для Windows. В настоящее время проекты C++ необходимо обновлять вручную. В Visual Studio 2017 можно открыть проект универсальной платформы Windows, предназначенный для версии 140. Тем не менее, если у вас не установлена среда Visual Studio 2015, вам нужно выбрать набор инструментов платформы версии 141 на страницах свойств проекта.

## <a name="new-options-for-c-on-universal-windows-platform-uwp"></a>Новые возможности C++ на универсальной платформе Windows (UWP)

Доступны новые возможности написания и упаковки приложений C++ для универсальной платформы Windows и Microsoft Store. Инфраструктура моста для классических приложений позволяет упаковать имеющееся классическое приложение или COM-объект для развертывания через Microsoft Store. Также его можно подготовить для развертывания через существующие каналы с помощью загрузки неопубликованных компонентов. Благодаря новым возможностям в Windows 10 можно добавлять функции UWP в классическое приложение различными способами. Дополнительные сведения см. в статье [Мост для классических приложений](/windows/uwp/porting/desktop-to-uwp-root).

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Добавлен шаблон **Проект упаковки приложений Windows**, который значительно упрощает упаковку классических приложений благодаря мосту для классических приложений. Он находится в разделе **Файл | Создать | Проект | Установленные | Visual C++ | Универсальная платформа Windows**. Дополнительные сведения см. в статье [Упаковка приложения с помощью Visual Studio (мост для классических приложений)](/windows/uwp/porting/desktop-to-uwp-packaging-dot-net).

При написании кода теперь можно использовать C++/WinRT — это проекция стандартного C++ для среды выполнения Windows, реализованная исключительно за счет файлов заголовков. Она позволяет как использовать, так и создавать API среды выполнения Windows с помощью любого соответствующего стандартам компилятора C++. C++/WinRT предоставляет разработчикам на C++ первоклассный доступ к современным API Windows. См. дополнительные сведения о [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/).

Начиная со сборки 17025 Insider Preview пакета SDK Windows, C++/WinRT входит в пакет Windows SDK. Дополнительные сведения см. в статье [C++/WinRT включен в состав пакета Windows SDK](https://devblogs.microsoft.com/cppblog/cppwinrt-is-now-included-the-windows-sdk/).

## <a name="the-clangc2-platform-toolset"></a>Набор инструментов платформы Clang/C2

Набор инструментов Clang/C2, который поставляется с Visual Studio 2017, теперь поддерживает параметр **`/bigobj`** , который крайне важен для сборки больших проектов. Он также включает несколько важных исправлений как во внешнем интерфейсе, так и в серверной части компилятора.

## <a name="c-code-analysis"></a>Анализ кода C++

Средства проверки на соответствие кода C++ [проверенным рекомендациям](https://github.com/isocpp/CppCoreGuidelines) (C++ Core Checker) теперь распространяются вместе с Visual Studio. Включите средства проверки на странице **Code Analysis Extensions** (Расширения анализа кода) на страницах свойств проекта. После этого расширения будут использоваться при анализе кода. Дополнительные сведения см. в статье [Using the C++ Core Guidelines checkers](../code-quality/using-the-cpp-core-guidelines-checkers.md) (Использование средств проверки на соответствие рекомендациям C++ Core).

![Снимок экрана: диалоговое окно "Страница свойств" с открытым разделом "Свойства конфигурации" > "Code Analysis" > "Общие" и перечислением Core Checks в списке "Выполнить этот набор правил".](media/CppCoreCheck.png "Страница свойств CppCoreCheck")

##### <a name="visual-studio-2017-version-153"></a>Visual Studio 2017 версия 15.3

- поддержка правил, связанных с управлением ресурсов.

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

- Новые проверки C++ Core Guidelines проверяют корректность интеллектуальных указателей, правильность использования глобальных инициализаторов и применение флагов конструкций, таких как **`goto`** и неправильные приведения.

- Некоторые номера предупреждений, которые можно встретить в версии 15.3, больше не доступны в версии 15.5. Эти предупреждения были заменены более конкретными проверками.

##### <a name="visual-studio-2017-version-156"></a>Visual Studio 2017 версии 15.6

- Добавлена поддержка анализа одиночного файла, а также улучшения в анализе производительности времени выполнения. Дополнительные сведения см. в статье [C++ Static Analysis Improvements for Visual Studio 2017 15.6 Preview 2](https://devblogs.microsoft.com/cppblog/c-static-analysis-improvements-for-visual-studio-2017-15-6-preview-2/) (Усовершенствования статического анализа C++ в Visual Studio 2017 15.6 Preview 2)

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

- Добавлена поддержка параметра [`/analyze:ruleset`](../build/reference/analyze-code-analysis.md), чтобы вы могли указать, какие нужно применять правила анализа кода.
- Добавлена поддержка дополнительных правил C++ Core Guidelines.  Дополнительные сведения см. в статье [Using the C++ Core Guidelines checkers](../code-quality/using-the-cpp-core-guidelines-checkers.md) (Использование средств проверки на соответствие рекомендациям C++ Core).

## <a name="unit-testing-in-visual-studio-2017"></a>Модульное тестирование в Visual Studio 2017

##### <a name="visual-studio-2017-version-155"></a>Visual Studio 2017 версии 15.5

Адаптеры для Google Test и Boost.Test теперь доступны как компоненты рабочей нагрузки **Разработка классических приложений на C++** . Они интегрированы с **обозревателем тестов**. Добавлена поддержка CTest для проектов CMake (с использованием функции "Открыть папку"), хотя полная интеграция с **обозревателем тестов** еще не доступна. Дополнительные сведения см. в разделе [Создание модульных тестов для C/C++](/visualstudio/test/writing-unit-tests-for-c-cpp).

##### <a name="visual-studio-2017-version-156"></a>Visual Studio 2017 версии 15.6

- Добавлена поддержка динамической библиотеки `Boost.Test`.
- В интегрированной среде разработки теперь доступен шаблон элемента `Boost.Test`.

Дополнительные сведения см. в статье [`Boost.Test` Unit Testing: Dynamic Library support and New Item Template](https://devblogs.microsoft.com/cppblog/boost-test-unit-testing-dynamic-library-support-and-new-item-template/) (Модульное тестирование Boost.Test: поддержка динамических библиотек и новый шаблон элемента).

##### <a name="visual-studio-2017-version-157"></a>Visual Studio 2017 версии 15.7

Добавлена поддержка [CodeLens](/visualstudio/ide/find-code-changes-and-other-history-with-codelens) для проектов модульного тестирования C++. Дополнительные сведения см. в записи блога [Announcing CodeLens for C++ Unit Testing](https://devblogs.microsoft.com/cppblog/announcing-codelens-for-c-unit-testing/) (Объявлена поддержка CodeLens для модульного тестирования C++).

## <a name="visual-studio-graphics-diagnostics"></a>Диагностика графики в Visual Studio

Инструменты для диагностики графики в Visual Studio можно использовать для записи и анализа проблем с рендерингом и производительностью в приложениях Direct3D. Используйте их для приложений, которые выполняются локально на компьютере под управлением Windows, в эмуляторе устройства Windows или на удаленном ПК или устройстве.

- **Ввод и вывод для шейдеров вершин и геометрии.** Возможность просмотра входных и выходных данных вершинных шейдеров и геометрических шейдеров была одной из наиболее часто запрашиваемых функций. Теперь она поддерживается в инструментах. Выберите этап вершинных или геометрических шейдеров в представлении "Этапы конвейера", чтобы запустить проверку входных и выходных данных, перечисленных в таблице ниже.

  ![Входные и выходные данные для шейдеров](media/io-shaders.png)

- **Поиск и фильтрация в таблице объектов.** Теперь доступен простой и быстрый поиск нужных ресурсов.

  ![Снимок экрана: раздел "Таблица объектов" с выделенным раскрывающимся списком "Тип" и полем поиска.](media/search.png)

- **Журнал ресурсов.** Новое упрощенное представление всей истории изменений ресурса по мере его использования в ходе отрисовки захваченного кадра. Чтобы открыть журнал для любого ресурса, щелкните значок часов рядом с гиперссылкой на ресурс.

  ![Журнал ресурсов](media/resource-history.png)

  Откроется новое окно инструментов **Журнал ресурсов**, в котором заполнены данные об изменении ресурса.

  ![Изменение журнала ресурсов](media/resource-history-change.png)

  Вы можете записать кадры при включенной записи полного стека вызовов. Это позволяет быстро определить контекст каждого события изменения и проверить его в проекте Visual Studio. Установите параметр записи полного стека в Visual Studio в разделе **Диагностика графики** диалогового окна **Средства > Параметры**.

- **Статистика API.** Обобщенная сводка по использованию API в вашем кадре. Это удобно для обнаружения вызовов, выполнение которых вы можете не замечать, или вызовов, которые выполняются слишком часто. Это окно можно открыть в анализаторе графики Visual Studio, выбрав **Вид > Статистика использования API**.

  ![Статистика использования API](media/api-stats.png)

- **Статистика памяти.** Просмотр объема памяти, выделяемого драйвером для создаваемых ресурсов в кадре. Это окно можно открыть в **анализаторе графики Visual Studio**, выбрав **Вид > Статистика использования памяти**. Чтобы скопировать данные в CSV-файл для просмотра в электронной таблице, щелкните правой кнопкой мыши и выберите **Копировать все**.

  ![Статистика использования памяти](media/memory-stats.png)

- **Проверка кадров.** Новый список ошибок и предупреждений позволяет легко просматривать события, где обнаружены потенциальные проблемы на уровне отладки Direct3D. Чтобы открыть окно, в анализаторе графики Visual Studio выберите **Вид > Проверка кадра**. Затем щелкните **Выполнить проверку**, чтобы начать анализ. В зависимости от сложности кадра процесс может занять несколько минут.

  ![Проверка кадра](media/frame-validation.png)

- **Анализ кадров для D3D12.** Используйте анализ кадров для оценки работы вызовов рисования с помощью контролируемых экспериментов. Перейдите на вкладку "Анализ кадров", чтобы просмотреть отчет. Дополнительные сведения см. в видеоролике [GoingNative 25: Visual Studio Graphics Frame Analysis](https://channel9.msdn.com/Shows/C9-GoingNative/GoingNative-25-Offline-Analysis-Graphics-Tool), посвященном анализу кадров графики Visual Studio.

  ![Анализ кадров](media/frame-analysis.png)

- **Усовершенствованный анализ использования GPU.** Открытые трассировки можно передать через профилировщик использования GPU в Visual Studio, используя представление GPU или инструмент Windows Performance Analyzer (WPA) для более подробного анализа. Если у вас установлен набор Windows Performance Toolkit, в правом нижнем углу экрана с общими сведениями о сеансе вы увидите две гиперссылки: одна для WPA, а другая — для режима GPU.

  ![Использование GPU](media/gpu-usage.png)

  Трассировки, открываемые в режиме GPU с помощью этой ссылки, поддерживают синхронизированное масштабирование и панорамирование временной шкалы в режимах VS и GPU. С помощью флажка в VS можно включать и отключать синхронизацию.

  ![Режим GPU](media/gpu-view.png)
