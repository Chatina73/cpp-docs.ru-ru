---
title: Новые возможности C++ в Visual Studio 2019
ms.date: 05/13/2019
ms.technology: cpp-ide
ms.assetid: 8801dbdb-ca0b-491f-9e33-01618bff5ae9
author: mikeblome
ms.author: mblome
ms.openlocfilehash: 19eaa9d4ed1cf12e721825f998fa674363eda488
ms.sourcegitcommit: 61121faf879cc581a4d39e4baccabf7cf1f673a5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/20/2019
ms.locfileid: "65934141"
---
# <a name="whats-new-for-c-in-visual-studio-2019"></a>Новые возможности C++ в Visual Studio 2019

В Visual Studio 2019 реализовано множество изменений и исправлений для среды Microsoft C++. Мы исправили множество ошибок и проблем с компилятором и средствами. Сообщения о многих таких проблемах были отправлены клиентами с помощью инструментов [Сообщить о проблеме](/visualstudio/how-to-report-a-problem-with-visual-studio-2017) и [Отправить предложение](https://developercommunity.visualstudio.com/spaces/62/index.html) в разделе **Отправить отзыв**. Спасибо, что сообщаете нам об ошибках! Дополнительные сведения о новых возможностях всех компонентов Visual Studio см. на странице [Новые возможности в Visual Studio](/visualstudio/ide/whats-new-visual-studio-2019).

## <a name="c-compiler"></a>компилятор C++

- Улучшенная поддержка функций C++17 и корректирующие исправления, а также экспериментальная поддержка функций C++20, таких как модули и сопрограммы. Подробные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2019](../cpp-conformance-improvements.md).

- Параметр `/std:c++latest` теперь поддерживает функции C++20, которые не обязательно завершены, включая начальную поддержку оператора C++20 \<=> ("космический корабль") для трехстороннего сравнения.

- Параметр компилятора C++ `/Gm` теперь считается устаревшим. Рекомендуется отключить параметр `/Gm` в скриптах сборки, если он задан явно. Можно просто проигнорировать предупреждение об устаревании `/Gm`, так как оно не считается ошибкой при использовании режима "Обрабатывать предупреждения как ошибки" (`/WX`).

- В MSVC уже внедряются функции из проекта стандарта C++20 с флагом `/std:c++latest`, поэтому `/std:c++latest` теперь несовместим с `/clr` (все варианты), `/ZW` и `/Gm`. В Visual Studio 2019 используйте режим `/std:c++17` или `/std:c++14` при компиляции с параметром `/clr`, `/ZW` или `/Gm` (но обратите внимание на предыдущий пункт).

- Предкомпилированные заголовки больше не создаются по умолчанию для консоли C++ и настольных приложений.

### <a name="codegen-security-diagnostics-and-versioning"></a>Создание кода, безопасность, диагностика и управления версиями

Доступен параметр `/Qspectre` для более эффективного анализа и устранения рисков, связанных с уязвимостью Spectre 1-го варианта (CVE-2017-5753). Дополнительные сведения см. в записи блога [Устранение рисков Spectre в MSVC](https://devblogs.microsoft.com/cppblog/spectre-mitigations-in-msvc/).

## <a name="c-standard-library-improvements"></a>Улучшения стандартной библиотеки C++

- Реализация дополнительных функций библиотек и корректирующих исправлений C++17 и C++20. Подробные сведения см. в статье [Улучшения соответствия C++ в Visual Studio 2019](../cpp-conformance-improvements.md).

- Для улучшения читаемости кода в заголовках стандартной библиотеки C++ применен Clang-Format.

- Так как Visual Studio теперь поддерживает функцию "Только мой код" для C++, стандартная библиотека больше не должна предоставлять настраиваемый механизм для `std::function` и `std::visit`, чтобы обеспечить такой же результат. Ликвидация такого механизма в основном не окажет заметного влияния на работу, за исключением того, что компилятор больше не будет сообщать о наличии проблем в строках 15732480 и 16707566 для \<type_traits> или \<variant>.

## <a name="performancethroughput-improvements-in-the-compiler-and-standard-library"></a>Повышение производительности и пропускной способности в компиляторе и стандартной библиотеке

- Реализованы усовершенствования пропускной способности сборки, включая обработку компоновщиком ввода-вывода файлов и время компоновки при объединении и создании типа PDB.

- Добавлена базовая поддержка векторизации OpenMP SIMD. Вы можете включить ее с помощью нового параметра компилятора `-openmp:experimental`. Эта опция позволяет при необходимости векторизовать циклы, аннотированные с `#pragma omp simd`. Векторизация не гарантируется, и циклы с аннотацией, но без векторизации, будут выдавать предупреждение. Предложения SIMD не поддерживаются, они просто игнорируются с предупреждением.

- Добавлен новый параметр встраивания командной строки `-Ob3`, который представляет собой более активную версию `-Ob2`. `-O2` (оптимизация двоичного файла для скорости) по-прежнему подразумевает `-Ob2` по умолчанию. Если обнаружится, что компилятор недостаточно активно встраивает, попробуйте передать `-O2 -Ob3`.

- Для поддержки векторизации циклов вручную с вызовами функций математической библиотеки и некоторыми другими операциями, такими как целочисленное деление, мы добавили поддержку встроенных функций Short Vector Math Library (SVML). Эти функции вычисляют 128-разрядные, 256-разрядные или 512-разрядные векторные эквиваленты. См. раздел [Руководство по встроенным функциям Intel](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#!=undefined&techs=SVML) с определениями поддерживаемых функций.

- Новые и улучшенные оптимизации:

  - Свертывание констант и арифметические упрощения для выражений с помощью встроенных функций SIMD (вектор) для чисел с плавающей запятой и целых чисел.

  - Более эффективный анализ для извлечения данных из потока управления (инструкции if/else/switch) для удаления ветвей, которые всегда имеют значение true или false.

  - Улучшенное развертывание memset для использования векторных инструкций SSE2.

  - Улучшенное удаление бесполезных копий структур или классов, особенно для программ C++, которые передают по значению.

  - Улучшена оптимизация кода с использованием `memmove`, например конструкции `std::copy` или `std::vector` и `std::string`.

- Оптимизирована физическая структура стандартной библиотеки, чтобы избежать компиляции ее частей, для которых не используется #include. Это в два раза ускоряет время сборки пустого файла, включающего только \<vector>. В результате этого изменения вам, возможно, потребуется добавить директивы #include для заголовков, которые ранее были включены непрямо. Например, в коде с `std::out_of_range` теперь, возможно, потребуется использовать #include для \<stdexcept>. В коде с оператором вставки потока, возможно, потребуется использовать #include для \<ostream>. Преимущество заключается в том, что нагрузка на пропускную способность будет возникать только при компиляции тех единиц преобразования, которые фактически используют компоненты \<stdexcept> или \<ostream>.

- `if constexpr` теперь более широко применяется в стандартной библиотеке для снижения нагрузки на пропускную способность и уменьшения размера кода в операциях копирования и преобразования (обращение и вращение), а также в библиотеке параллельных алгоритмов. 

- Стандартная библиотека теперь внутренне использует `if constexpr` для ускорения компиляции даже в режиме C++14.

- При обнаружении динамической компоновки в среде выполнения для библиотеки параллельных алгоритмов для хранения массива с указателями на функции больше не используется целая страница. Использование этой памяти как памяти только для чтения более не считается целесообразным из соображений безопасности.

- Конструктор `std::thread` больше не ожидает запуска потока и не вставляет так много уровней вызова функции между базовой библиотекой C `_beginthreadex` и предоставляемым вызываемым объектом. Ранее функция `std::thread` вставляла 6 функций между библиотекой `_beginthreadex` и предоставляемым вызываемым объектом. Теперь это число уменьшено до 3 (2 из которых — `std::invoke`). Это также позволяет устранить редкую ошибку времени, при которой конструктор `std::thread` переставал отвечать на запросы, если системное время было изменено в момент создания `std::thread`.

- Устранена проблема с производительностью в `std::hash`, которая начала появляться после добавления `std::hash<std::filesystem::path>`.

- Иногда для обеспечения корректности стандартная библиотека теперь использует деструкторы, а не catch-блоки. Это приводит к улучшенному взаимодействию с отладчиком. Исключения, которые вызывались через библиотеку в затронутых расположениях, теперь будут отображаться как исключения из расположения их возникновения (а не из расположения их повторного вызова). Ликвидированы не все catch-блоки стандартной библиотеки. Мы планируем уменьшить число catch-блоков в последующих выпусках MSVC.

- Проблема с неоптимальной работой генератора кода в `std::bitset` из-за условного вызова в функции noexcept устранена. Для этого путь вызова был вынесен за скобки.

- `std::list` и семейство `std::unordered_*` более широко внутренне используют итераторы без возможности отладки.

- Несколько членов `std::list` теперь не освобождают и не выделяют заново узлы списков, а при возможности повторно используют их. Например, если размер `list<int>` уже равен 3, вызов к `assign(4, 1729)` теперь перезапишет значения int в первых трех узлах списков и выделит один новый узел списка со значением 1729. Ранее он бы освободил три узла списка, а затем бы выделил четыре новых узла списка со значением 1729.

- Все вызовы стандартной библиотеки к `erase(begin(), end())` изменены на `clear()`.

- В некоторых случаях `std::vector` теперь более эффективно инициализирует и удаляет элементы.

- Усовершенствован `std::variant` для более удобной работы с оптимизатором, что приводит к улучшению сформированного кода. Встраивание кода теперь гораздо лучше с `std::visit`.

## <a name="c-ide"></a>IDE C++

### <a name="live-share-c-support"></a>Поддержка Live Share C++

[Live Share](/visualstudio/liveshare/) теперь поддерживает C++, позволяя разработчикам, использующим Visual Studio или Visual Studio Code, сотрудничать в режиме реального времени. Дополнительные сведения см. в статьях [Объявление Live Share для C++: общий доступ и совместная работа в режиме реального времени](https://devblogs.microsoft.com/cppblog/cppliveshare/)

### <a name="intellicode-for-c"></a>IntelliCode для C++

IntelliCode — это дополнительное расширение (добавлено в качестве компонента рабочей нагрузки в версии 16.1), которое использует обучение и контекст кода для вывода тех вариантов, которые вы чаще всего используете, в верхней части списка завершения. Он также часто устраняет необходимость прокручивать список. В C++ IntelliCode наиболее эффективно работает при использовании популярных библиотек, таких как стандартная библиотека. Дополнительные сведения см. в разделе [Рекомендации по завершению кода на базе ИИ в C++ через IntelliCode](https://devblogs.microsoft.com/cppblog/cppintellicode/).

### <a name="template-intellisense"></a>Шаблон IntelliSense

В **строке шаблона** теперь используется пользовательский интерфейс **Окно просмотра**, а не модальное окно, поддерживаются вложенные шаблоны и автоматически заполняются аргументы по умолчанию в **Окне просмотра**. Дополнительные сведения см. в статье [Усовершенствования шаблона IntelliSense для Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/template-intellisense-improvements-for-visual-studio-2019-preview-2/). Раскрывающийся список **Недавно использовавшиеся** в **строке шаблона** позволяет быстро переключаться между предыдущими наборами аргументов шаблона.

### <a name="new-start-window-experience"></a>Новый интерфейс начального окна

При запуске интегрированной среды разработки откроется новое начальное окно с параметрами, которые позволяют открыть последние проекты, клонировать код из системы управления версиями, открыть локальный код как решение или папку или создать новый проект. Диалоговое окно создания проекта также теперь ориентировано на поиск и фильтрацию.

### <a name="new-names-for-some-project-templates"></a>Новые имена для некоторых шаблонов проектов

Мы изменили несколько имен и описаний шаблонов проектов в соответствии с обновленным диалоговым окном создания проекта.

### <a name="various-productivity-improvements"></a>Различные улучшения производительности

Visual Studio 2019 включает в себя следующие возможности, которые помогут сделать процесс кодирования более простым и интуитивным:

- Быстрые исправления для:
  - Добавление недостающих #include
  - NULL и nullptr
  - Добавление недостающих точек с запятой.
  - Разрешение отсутствующего пространства имен или области
  - Замена неправильных операндов косвенного обращения (\* на & и & на \*)
- Краткие сведения для блока при наведении указателя на закрывающую скобку
- Просмотреть файл заголовка или кода
- "Перейти к определению" для #include открывает файл

Дополнительные сведения см. в статье [Улучшения производительности C++ в Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/c-productivity-improvements-in-visual-studio-2019-preview-2/).

**Visual Studio 2019 версии 16.1**

### <a name="quickinfo-improvements"></a>Усовершенствования подсказок

При отображении подсказок теперь учитывается семантическая подсветка в редакторе. Также доступна новая ссылка **Поиск в Интернете**, с помощью которой можно находить онлайн-документацию по конструкции кода, на которую наведен указатель мыши. Для кода, подчеркнутого волнистой красной линией, ссылка в подсказке позволяет выполнить поиск сведений об ошибке в Интернете. То есть вам не придется повторно вводить сообщение в браузер. Подробные сведения см. в записи блога [Quick Info Improvements in Visual Studio 2019: Colorization and Search Online](https://devblogs.microsoft.com/cppblog/quick-info-improvements-in-visual-studio-2019-colorization-and-search-online/) (Улучшения подсказок в Visual Studio 2019: подсветка и поиск в Интернете).

### <a name="intellicode-available-in-c-workload"></a>Компонент IntelliCode доступен в рабочей нагрузке C++

IntelliCode теперь предоставляется в виде дополнительного компонента в рабочей нагрузке **Разработка классических приложений на C++**. Подробные сведения см. в записи блога [Improved C++ IntelliCode now Ships with Visual Studio 2019](https://devblogs.microsoft.com/cppblog/) (Улучшенный компонент IntelliCode для C++ теперь предоставляется с Visual Studio 2019).

## <a name="cmake-support"></a>Поддержка CMake

- Поддержка CMake 3.14

- Visual Studio теперь может открыть существующие кэши CMake, созданные внешними средствами, например CMakeGUI или пользовательскими системами мета-сборки, или создать скрипты, которые сами вызывают cmake.exe.

- Усовершенствование производительности IntelliSense.

- Новый редактор параметров предоставляет альтернативу редактированию файла CMakeSettings.json вручную и частичное равенство с CMakeGUI.

- Visual Studio помогает начать разработку на C++ с помощью CMake в Linux, определяя наличие совместимой версии CMake на компьютере Linux, а если она отсутствует, предлагает ее установить.

- Несовместимые параметры в CMakeSettings, например несоответствие архитектур или несовместимые параметры генератора CMake, выделены волнистыми линиями в редакторе JSON и отображаются в списке ошибок.

- Цепочка инструментов vcpkg автоматически обнаруживается и включается для проектов CMake, которые открыты в интегрированной среде разработки, после запуска `vcpkg integrate install`. Это поведение можно отключить, указав пустой файл цепочки инструментов в CMakeSettings.

- Проекты CMake теперь включают отладку "Только мой код" по умолчанию.

- Предупреждения статического анализа теперь могут обрабатываться в фоновом режиме и отображаться в редакторе для проектов CMake.

- Более понятные сообщения о конце и начале сборки и конфигурации для проектов CMake и поддержка пользовательского интерфейса хода сборки Visual Studio. Кроме того, теперь есть параметр детализации CMake в разделе **Сервис > Параметры** для настройки уровня детализации сообщений о сборке и конфигурации CMake в окне вывода.

- Параметр `cmakeToolchain` теперь поддерживается в CMakeSettings.json для указания цепочек инструментов без изменения командной строки CMake вручную.

- Новое сочетание клавиш для меню **Собрать все** — **CTRL+SHIFT+B**.

**Visual Studio 2019 версии 16.1**

- Встроенная поддержка редактирования, сборки и отладки проектов CMake с Clang/LLVM. Подробные сведения см. в записи блога [Clang/LLVM Support in Visual Studio](https://devblogs.microsoft.com/cppblog/clang-llvm-support-in-visual-studio/) (Поддержка Clang/LLVM в Visual Studio).

## <a name="linux-and-wsl"></a>Linux и WSL

**Visual Studio 2019 версии 16.1**

- Поддержка [AddressSanitizer (ASan)](https://github.com/google/sanitizers/wiki/AddressSanitizer) в Linux и кроссплатформенных проектах CMake. Подробные сведения см. в записи блога [AddressSanitizer (ASan) for the Linux Workload in Visual Studio 2019](https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-the-linux-workload-in-visual-studio-2019/) (AddressSanitizer (ASan) для рабочей нагрузки Linux в Visual Studio 2019).

- Интегрированная поддержка Visual Studio для использования C++ с подсистемой Windows для Linux (WSL). Подробные сведения см. в записи блога [C++ with Visual Studio 2019 and Windows Subsystem for Linux (WSL)](https://devblogs.microsoft.com/cppblog/c-with-visual-studio-2019-and-windows-subsystem-for-linux-wsl/) (C++ с Visual Studio 2019 и подсистемой Windows для Linux (WSL)).

## <a name="incredibuild-integration"></a>Интеграция IncrediBuild

IncrediBuild теперь включается в виде дополнительного компонента в рабочую нагрузку **Разработка классических приложений на C++**. Монитор сборки IncrediBuild полностью интегрирован в IDE Visual Studio. Подробные сведения см. в записи блога [Visualize your build with IncrediBuild’s Build Monitor and Visual Studio 2019](https://devblogs.microsoft.com/cppblog/visualize-your-build-with-incredibuilds-build-monitor-and-visual-studio-2019/) (Визуализация сборки с помощью монитора сборки IncrediBuild и Visual Studio 2019).
 
## <a name="debugging"></a>Отладка

- Для приложений на C++, работающих в Windows, PDB-файлы теперь загружаются в отдельном 64-разрядном процессе. Это изменение позволяет устранить ряд сбоев из-за нехватки памяти при отладке приложений, которые содержат большое количество модулей и PDB-файлов.

- Поиск включен в окнах **контрольных значений**, **видимых переменных** и **локальных переменных**.

## <a name="windows-desktop-development-with-c"></a>Разработка классических приложений для Windows на C++

- Следующие мастера C++, ATL и MFC больше не доступны:

  - Мастер компонентов ATL COM+ 1.0
  - Мастер компонентов ATL ASP
  - Мастер поставщика ATL OLE DB
  - Мастер страницы свойств ATL
  - Мастер потребителя ATL OLE DB
  - Потребитель ODBC MFC
  - Класс MFC из элемента управления ActiveX
  - Класс MFC из TypeLib.

  Пример кода для этих технологий находится в архиве в документации Майкрософт и репозитории VCSamples на GitHub.

- Пакет SDK Windows 8.1 больше не доступен в установщике Visual Studio. Обновите проекты C++ до последней версии пакета SDK для Windows 10. Если у вас есть жесткая зависимость от версии 8.1, ее можно скачать из архива Windows SDK.

- Windows XP больше нельзя выбрать в качестве целевой платформы для последнего набора инструментов C++. XP для библиотек и компилятора MSVC уровня VS 2017 по-прежнему поддерживается и может устанавливаться через раздел "Отдельные компоненты".

- В нашей документации настоятельно не рекомендуется использовать модули слияния для развертывания среды выполнения Visual C++. В этом выпуске мы принимаем дополнительные меры, чтобы отметить MSM как нерекомендуемые. Возможно, следует перенести центральное развертывание VCRuntime из MSM в распространяемый пакет.

## <a name="mobile-development-with-c-android-and-ios"></a>Разработка мобильных приложений на C++ (для iOS и Android)

C++ для Android теперь по умолчанию равняется на Android SDK 25 и пакет NDK для Android 16b.

## <a name="clangc2-platform-toolset"></a>Набор средств платформы Clang/C2

Экспериментальный компонент Clang/C2 удален. Для обеспечения полного соответствия стандартам C++ используйте набор инструментов MSVC с параметрами `/permissive-` и `/std:c++17` или же цепочку инструментов Clang/LLVM для Windows.

## <a name="code-analysis"></a>Анализ кода

- Анализ кода теперь выполняется автоматически в фоновом режиме. Предупреждения отображаются зелеными волнистыми линиями в редакторе при вводе. Дополнительные сведения см. в разделе [Анализа кода в редакторе в Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/in-editor-code-analysis-in-visual-studio-2019-preview-2/).

- Новые экспериментальные правила ConcurrencyCheck для хорошо известных типов стандартной библиотеки из заголовка \<mutex>. Дополнительные сведения см. в разделе [Параллельный анализ кода в Visual Studio 2019](https://devblogs.microsoft.com/cppblog/concurrency-code-analysis-in-visual-studio-2019/).

- Обновленная частичная реализация [инструмента проверки профиля времени существования](https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/) для обнаружения висячих указателей и ссылок. Дополнительные сведения см. в разделе [Обновление профиля времени существования в Visual Studio 2019, предварительная версия 2](https://devblogs.microsoft.com/cppblog/lifetime-profile-update-in-visual-studio-2019-preview-2/).

- Дополнительные проверки сопрограмм, включая C26138, C26810, C26811 и экспериментальное правило C26800. Дополнительные сведения см. в разделе [Новые проверки анализа кода в Visual Studio 2019: использование после перемещения и сопрограмма](https://devblogs.microsoft.com/cppblog/new-code-analysis-checks-in-visual-studio-2019-use-after-move-and-coroutine/).

**Visual Studio 2019 версии 16.1**

Новые быстрые исправления для проверок неинициализированных переменных. Подробные сведения см. в записи блога [New code analysis quick fixes for uninitialized memory (C6001) and use before init (C26494) warnings](https://devblogs.microsoft.com/cppblog/new-code-analysis-quick-fixes-for-uninitialized-memory-c6001-and-use-before-init-c26494-warnings/) (Новые быстрые исправления анализа кода для предупреждений о неинициализированной памяти (C6001) и использовании переменных перед инициализацией (C26494)).

## <a name="unit-testing"></a>Модульное тестирование

Шаблон управляемого тестового проекта C++ больше не доступен. Вы можете продолжить использование платформы управляемых тестов C++ в существующих проектах. Но для новых модульных тестов мы рекомендуем использовать собственные тестовые платформы, для которых Visual Studio предоставляет шаблоны (MSTest, Google Test), или шаблон управляемого тестового проекта C#.
